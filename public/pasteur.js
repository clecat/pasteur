//# 1 "pasteur.bc.runtime.js"
// Generated by js_of_ocaml 3.9.1
(function(joo_global_object)
   {"use strict";
    function caml_int64_is_zero(x){return + x.isZero()}
    function caml_str_repeat(n,s)
     {if(n == 0)return "";
      if(s.repeat)return s.repeat(n);
      var r="",l=0;
      for(;;)
       {if(n & 1)r += s;
        n >>= 1;
        if(n == 0)return r;
        s += s;
        l++;
        if(l == 9)s.slice(0,1)}}
    var caml_int64_offset=Math.pow(2,- 24);
    function caml_raise_constant(tag){throw tag}
    var caml_global_data=[0];
    function caml_raise_zero_divide()
     {caml_raise_constant(caml_global_data.Division_by_zero)}
    function MlInt64(lo,mi,hi)
     {this.lo = lo & 0xffffff;this.mi = mi & 0xffffff;this.hi = hi & 0xffff}
    MlInt64.prototype.caml_custom = "_j";
    MlInt64.prototype.copy
    =
    function(){return new MlInt64(this.lo,this.mi,this.hi)};
    MlInt64.prototype.ucompare
    =
    function(x)
     {if(this.hi > x.hi)return 1;
      if(this.hi < x.hi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.compare
    =
    function(x)
     {var hi=this.hi << 16,xhi=x.hi << 16;
      if(hi > xhi)return 1;
      if(hi < xhi)return - 1;
      if(this.mi > x.mi)return 1;
      if(this.mi < x.mi)return - 1;
      if(this.lo > x.lo)return 1;
      if(this.lo < x.lo)return - 1;
      return 0};
    MlInt64.prototype.neg
    =
    function()
     {var lo=- this.lo,mi=- this.mi + (lo >> 24),hi=- this.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.add
    =
    function(x)
     {var
       lo=this.lo + x.lo,
       mi=this.mi + x.mi + (lo >> 24),
       hi=this.hi + x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.sub
    =
    function(x)
     {var
       lo=this.lo - x.lo,
       mi=this.mi - x.mi + (lo >> 24),
       hi=this.hi - x.hi + (mi >> 24);
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.mul
    =
    function(x)
     {var
       lo=this.lo * x.lo,
       mi=(lo * caml_int64_offset | 0) + this.mi * x.lo + this.lo * x.mi,
       hi=
        (mi * caml_int64_offset | 0)
        +
        this.hi
        *
        x.lo
        +
        this.mi
        *
        x.mi
        +
        this.lo
        *
        x.hi;
      return new MlInt64(lo,mi,hi)};
    MlInt64.prototype.isZero
    =
    function(){return (this.lo | this.mi | this.hi) == 0};
    MlInt64.prototype.isNeg = function(){return this.hi << 16 < 0};
    MlInt64.prototype.and
    =
    function(x)
     {return new MlInt64(this.lo & x.lo,this.mi & x.mi,this.hi & x.hi)};
    MlInt64.prototype.or
    =
    function(x)
     {return new MlInt64(this.lo | x.lo,this.mi | x.mi,this.hi | x.hi)};
    MlInt64.prototype.xor
    =
    function(x)
     {return new MlInt64(this.lo ^ x.lo,this.mi ^ x.mi,this.hi ^ x.hi)};
    MlInt64.prototype.shift_left
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo << s,
                this.mi << s | this.lo >> 24 - s,
                this.hi << s | this.mi >> 24 - s);
      if(s < 48)
       return new
               MlInt64
               (0,this.lo << s - 24,this.mi << s - 24 | this.lo >> 48 - s);
      return new MlInt64(0,0,this.lo << s - 48)};
    MlInt64.prototype.shift_right_unsigned
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | this.hi << 24 - s,
                this.hi >> s);
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,this.hi >> s - 24,0);
      return new MlInt64(this.hi >> s - 48,0,0)};
    MlInt64.prototype.shift_right
    =
    function(s)
     {s = s & 63;
      if(s == 0)return this;
      var h=this.hi << 16 >> 16;
      if(s < 24)
       return new
               MlInt64
               (this.lo >> s | this.mi << 24 - s,
                this.mi >> s | h << 24 - s,
                this.hi << 16 >> s >>> 16);
      var sign=this.hi << 16 >> 31;
      if(s < 48)
       return new
               MlInt64
               (this.mi >> s - 24 | this.hi << 48 - s,
                this.hi << 16 >> s - 24 >> 16,
                sign & 0xffff);
      return new MlInt64(this.hi << 16 >> s - 32,sign,sign)};
    MlInt64.prototype.lsl1
    =
    function()
     {this.hi = this.hi << 1 | this.mi >> 23;
      this.mi = (this.mi << 1 | this.lo >> 23) & 0xffffff;
      this.lo = this.lo << 1 & 0xffffff};
    MlInt64.prototype.lsr1
    =
    function()
     {this.lo = (this.lo >>> 1 | this.mi << 23) & 0xffffff;
      this.mi = (this.mi >>> 1 | this.hi << 23) & 0xffffff;
      this.hi = this.hi >>> 1};
    MlInt64.prototype.udivmod
    =
    function(x)
     {var
       offset=0,
       modulus=this.copy(),
       divisor=x.copy(),
       quotient=new MlInt64(0,0,0);
      while(modulus.ucompare(divisor) > 0){offset++;divisor.lsl1()}
      while(offset >= 0)
       {offset--;
        quotient.lsl1();
        if(modulus.ucompare(divisor) >= 0)
         {quotient.lo++;modulus = modulus.sub(divisor)}
        divisor.lsr1()}
      return {quotient:quotient,modulus:modulus}};
    MlInt64.prototype.div
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi ^ y.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var q=x.udivmod(y).quotient;
      if(sign & 0x8000)q = q.neg();
      return q};
    MlInt64.prototype.mod
    =
    function(y)
     {var x=this;
      if(y.isZero())caml_raise_zero_divide();
      var sign=x.hi;
      if(x.hi & 0x8000)x = x.neg();
      if(y.hi & 0x8000)y = y.neg();
      var r=x.udivmod(y).modulus;
      if(sign & 0x8000)r = r.neg();
      return r};
    MlInt64.prototype.toInt = function(){return this.lo | this.mi << 24};
    MlInt64.prototype.toFloat
    =
    function()
     {return (this.hi << 16)
             *
             Math.pow(2,32)
             +
             this.mi
             *
             Math.pow(2,24)
             +
             this.lo};
    MlInt64.prototype.toArray
    =
    function()
     {return [this.hi >> 8,
              this.hi & 0xff,
              this.mi >> 16,
              this.mi >> 8 & 0xff,
              this.mi & 0xff,
              this.lo >> 16,
              this.lo >> 8 & 0xff,
              this.lo & 0xff]};
    MlInt64.prototype.lo32
    =
    function(){return this.lo | (this.mi & 0xff) << 24};
    MlInt64.prototype.hi32
    =
    function(){return this.mi >>> 8 & 0xffff | this.hi << 16};
    function caml_int64_of_int32(x)
     {return new MlInt64(x & 0xffffff,x >> 24 & 0xffffff,x >> 31 & 0xffff)}
    function caml_int64_to_int32(x){return x.toInt()}
    function caml_int64_is_negative(x){return + x.isNeg()}
    function caml_int64_neg(x){return x.neg()}
    function caml_subarray_to_jsbytes(a,i,len)
     {var f=String.fromCharCode;
      if(i == 0 && len <= 4096 && len == a.length)return f.apply(null,a);
      var s="";
      for(;0 < len;i += 1024,len -= 1024)
       s += f.apply(null,a.slice(i,i + Math.min(len,1024)));
      return s}
    function caml_convert_string_to_bytes(s)
     {if(s.t == 2)
       s.c += caml_str_repeat(s.l - s.c.length,"\0");
      else
       s.c = caml_subarray_to_jsbytes(s.c,0,s.c.length);
      s.t = 0}
    function caml_jsbytes_of_string(s)
     {if((s.t & 6) != 0)caml_convert_string_to_bytes(s);return s.c}
    function caml_raise_with_arg(tag,arg){throw [0,tag,arg]}
    function jsoo_is_ascii(s)
     {if(s.length < 24)
       {for(var i=0;i < s.length;i++)if(s.charCodeAt(i) > 127)return false;
        return true}
      else
       return ! /[^\x00-\x7f]/.test(s)}
    function caml_utf16_of_utf8(s)
     {for(var b="",t="",c,c1,c2,v,i=0,l=s.length;i < l;i++)
       {c1 = s.charCodeAt(i);
        if(c1 < 0x80)
         {for(var j=i + 1;j < l && (c1 = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        v = 1;
        if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
         {c = c2 + (c1 << 6);
          if(c1 < 0xe0)
           {v = c - 0x3080;if(v < 0x80)v = 1}
          else
           {v = 2;
            if(++i < l && ((c2 = s.charCodeAt(i)) & - 64) == 128)
             {c = c2 + (c << 6);
              if(c1 < 0xf0)
               {v = c - 0xe2080;
                if(v < 0x800 || v >= 0xd7ff && v < 0xe000)v = 2}
              else
               {v = 3;
                if
                 (++i
                  <
                  l
                  &&
                  ((c2 = s.charCodeAt(i)) & - 64)
                  ==
                  128
                  &&
                  c1
                  <
                  0xf5)
                 {v = c2 - 0x3c82080 + (c << 6);
                  if(v < 0x10000 || v > 0x10ffff)v = 3}}}}}
        if(v < 4)
         {i -= v;t += "\ufffd"}
        else
         if(v > 0xffff)
          t += String.fromCharCode(0xd7c0 + (v >> 10),0xdc00 + (v & 0x3FF));
         else
          t += String.fromCharCode(v);
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function MlBytes(tag,contents,length)
     {this.t = tag;this.c = contents;this.l = length}
    MlBytes.prototype.toString
    =
    function()
     {switch(this.t)
       {case 9:return this.c;
        default:caml_convert_string_to_bytes(this);case 0:
         if(jsoo_is_ascii(this.c)){this.t = 9;return this.c}this.t = 8;
        case 8:return this.c
        }};
    MlBytes.prototype.toUtf16
    =
    function()
     {var r=this.toString();
      if(this.t == 9)return r;
      return caml_utf16_of_utf8(r)};
    MlBytes.prototype.slice
    =
    function()
     {var content=this.t == 4?this.c.slice():this.c;
      return new MlBytes(this.t,content,this.l)};
    function caml_bytes_of_jsbytes(s){return new MlBytes(0,s,s.length)}
    function caml_string_of_jsbytes(s){return caml_bytes_of_jsbytes(s)}
    function caml_raise_with_string(tag,msg)
     {caml_raise_with_arg(tag,caml_string_of_jsbytes(msg))}
    function caml_invalid_argument(msg)
     {caml_raise_with_string(caml_global_data.Invalid_argument,msg)}
    function caml_parse_format(fmt)
     {fmt = caml_jsbytes_of_string(fmt);
      var len=fmt.length;
      if(len > 31)caml_invalid_argument("format_int: format too long");
      var
       f=
        {justify:"+",
         signstyle:"-",
         filler:" ",
         alternate:false,
         base:0,
         signedconv:false,
         width:0,
         uppercase:false,
         sign:1,
         prec:- 1,
         conv:"f"};
      for(var i=0;i < len;i++)
       {var c=fmt.charAt(i);
        switch(c)
         {case "-":f.justify = "-";break;
          case "+":
          case " ":f.signstyle = c;break;
          case "0":f.filler = "0";break;
          case "#":f.alternate = true;break;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
           f.width = 0;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.width = f.width * 10 + c;i++}
           i--;
           break;
          case ".":
           f.prec = 0;
           i++;
           while(c = fmt.charCodeAt(i) - 48,c >= 0 && c <= 9)
            {f.prec = f.prec * 10 + c;i++}
           i--;
          case "d":
          case "i":f.signedconv = true;
          case "u":f.base = 10;break;
          case "x":f.base = 16;break;
          case "X":f.base = 16;f.uppercase = true;break;
          case "o":f.base = 8;break;
          case "e":
          case "f":
          case "g":f.signedconv = true;f.conv = c;break;
          case "E":
          case "F":
          case "G":
           f.signedconv = true;
           f.uppercase = true;
           f.conv = c.toLowerCase();
           break
          }}
      return f}
    function caml_finish_formatting(f,rawbuffer)
     {if(f.uppercase)rawbuffer = rawbuffer.toUpperCase();
      var len=rawbuffer.length;
      if(f.signedconv && (f.sign < 0 || f.signstyle != "-"))len++;
      if(f.alternate){if(f.base == 8)len += 1;if(f.base == 16)len += 2}
      var buffer="";
      if(f.justify == "+" && f.filler == " ")
       for(var i=len;i < f.width;i++)buffer += " ";
      if(f.signedconv)
       if(f.sign < 0)
        buffer += "-";
       else
        if(f.signstyle != "-")buffer += f.signstyle;
      if(f.alternate && f.base == 8)buffer += "0";
      if(f.alternate && f.base == 16)buffer += "0x";
      if(f.justify == "+" && f.filler == "0")
       for(var i=len;i < f.width;i++)buffer += "0";
      buffer += rawbuffer;
      if(f.justify == "-")for(var i=len;i < f.width;i++)buffer += " ";
      return caml_string_of_jsbytes(buffer)}
    function caml_int64_format(fmt,x)
     {var f=caml_parse_format(fmt);
      if(f.signedconv && caml_int64_is_negative(x))
       {f.sign = - 1;x = caml_int64_neg(x)}
      var
       buffer="",
       wbase=caml_int64_of_int32(f.base),
       cvtbl="0123456789abcdef";
      do
       {var p=x.udivmod(wbase);
        x = p.quotient;
        buffer = cvtbl.charAt(caml_int64_to_int32(p.modulus)) + buffer}
      while
       (! caml_int64_is_zero(x));
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - buffer.length;
        if(n > 0)buffer = caml_str_repeat(n,"0") + buffer}
      return caml_finish_formatting(f,buffer)}
    function caml_expm1_float(x)
     {var y=Math.exp(x),z=y - 1;
      return Math.abs(x) > 1?z:z == 0?x:x * z / Math.log(y)}
    function caml_jsstring_of_string(s){return s.toUtf16()}
    if(joo_global_object.process && joo_global_object.process.cwd)
     var caml_current_dir=joo_global_object.process.cwd().replace(/\\/g,"/");
    else
     var caml_current_dir="/static";
    if(caml_current_dir.slice(- 1) !== "/")caml_current_dir += "/";
    function caml_make_path(name)
     {name = caml_jsstring_of_string(name);
      if(name.charCodeAt(0) != 47)name = caml_current_dir + name;
      var comp=name.split("/"),ncomp=[];
      for(var i=0;i < comp.length;i++)
       switch(comp[i])
        {case "..":if(ncomp.length > 1)ncomp.pop();break;
         case ".":break;
         case "":if(ncomp.length == 0)ncomp.push("");break;
         default:ncomp.push(comp[i]);break}
      ncomp.orig = name;
      return ncomp}
    function caml_is_ml_bytes(s){return s instanceof MlBytes}
    function caml_is_ml_string(s){return caml_is_ml_bytes(s)}
    function caml_bytes_of_array(a){return new MlBytes(4,a,a.length)}
    function caml_bytes_of_string(s){return s}
    function caml_utf8_of_utf16(s)
     {for(var b="",t=b,c,d,i=0,l=s.length;i < l;i++)
       {c = s.charCodeAt(i);
        if(c < 0x80)
         {for(var j=i + 1;j < l && (c = s.charCodeAt(j)) < 0x80;j++);
          if(j - i > 512)
           {t.substr(0,1);b += t;t = "";b += s.slice(i,j)}
          else
           t += s.slice(i,j);
          if(j == l)break;
          i = j}
        if(c < 0x800)
         {t += String.fromCharCode(0xc0 | c >> 6);
          t += String.fromCharCode(0x80 | c & 0x3f)}
        else
         if(c < 0xd800 || c >= 0xdfff)
          t
          +=
          String.fromCharCode
           (0xe0 | c >> 12,0x80 | c >> 6 & 0x3f,0x80 | c & 0x3f);
         else
          if
           (c
            >=
            0xdbff
            ||
            i
            +
            1
            ==
            l
            ||
            (d = s.charCodeAt(i + 1))
            <
            0xdc00
            ||
            d
            >
            0xdfff)
           t += "\xef\xbf\xbd";
          else
           {i++;
            c = (c << 10) + d - 0x35fdc00;
            t
            +=
            String.fromCharCode
             (0xf0 | c >> 18,
              0x80 | c >> 12 & 0x3f,
              0x80 | c >> 6 & 0x3f,
              0x80 | c & 0x3f)}
        if(t.length > 1024){t.substr(0,1);b += t;t = ""}}
      return b + t}
    function caml_bytes_of_utf16_jsstring(s)
     {var tag=9;
      if(! jsoo_is_ascii(s))tag = 8,s = caml_utf8_of_utf16(s);
      return new MlBytes(tag,s,s.length)}
    function caml_string_of_jsstring(s)
     {return caml_bytes_of_utf16_jsstring(s)}
    function caml_raise_sys_error(msg)
     {caml_raise_with_string(caml_global_data.Sys_error,msg)}
    function caml_raise_no_such_file(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": No such file or directory")}
    function caml_bytes_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_bytes_unsafe_get(s,i)
     {switch(s.t & 6)
       {default:if(i >= s.c.length)return 0;case 0:return s.c.charCodeAt(i);
        case 4:return s.c[i]
        }}
    function caml_bytes_get(s,i)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_get(s,i)}
    function caml_create_bytes(len)
     {if(len < 0)caml_invalid_argument("Bytes.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_ml_bytes_length(s){return s.l}
    function caml_convert_bytes_to_array(s)
     {if(joo_global_object.Uint8Array)
       var a=new (joo_global_object.Uint8Array)(s.l);
      else
       var a=new Array(s.l);
      var b=s.c,l=b.length,i=0;
      for(;i < l;i++)a[i] = b.charCodeAt(i);
      for(l = s.l;i < l;i++)a[i] = 0;
      s.c = a;
      s.t = 4;
      return a}
    function caml_blit_bytes(s1,i1,s2,i2,len)
     {if(len == 0)return 0;
      if(i2 == 0 && (len >= s2.l || s2.t == 2 && len >= s2.c.length))
       {s2.c
        =
        s1.t == 4
         ?caml_subarray_to_jsbytes(s1.c,i1,len)
         :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
        s2.t = s2.c.length == s2.l?0:2}
      else
       if(s2.t == 2 && i2 == s2.c.length)
        {s2.c
         +=
         s1.t == 4
          ?caml_subarray_to_jsbytes(s1.c,i1,len)
          :i1 == 0 && s1.c.length == len?s1.c:s1.c.substr(i1,len);
         s2.t = s2.c.length == s2.l?0:2}
       else
        {if(s2.t != 4)caml_convert_bytes_to_array(s2);
         var c1=s1.c,c2=s2.c;
         if(s1.t == 4)
          if(i2 <= i1)
           for(var i=0;i < len;i++)c2[i2 + i] = c1[i1 + i];
          else
           for(var i=len - 1;i >= 0;i--)c2[i2 + i] = c1[i1 + i];
         else
          {var l=Math.min(len,c1.length - i1);
           for(var i=0;i < l;i++)c2[i2 + i] = c1.charCodeAt(i1 + i);
           for(;i < len;i++)c2[i2 + i] = 0}}
      return 0}
    function caml_blit_string(a,b,c,d,e)
     {caml_blit_bytes(caml_bytes_of_string(a),b,c,d,e);return 0}
    function MlFile(){}
    function MlFakeFile(content){this.data = content}
    MlFakeFile.prototype = new MlFile();
    MlFakeFile.prototype.truncate
    =
    function(len)
     {var old=this.data;
      this.data = caml_create_bytes(len | 0);
      caml_blit_bytes(old,0,this.data,0,len)};
    MlFakeFile.prototype.length
    =
    function(){return caml_ml_bytes_length(this.data)};
    MlFakeFile.prototype.write
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      if(offset + len >= clen)
       {var new_str=caml_create_bytes(offset + len),old_data=this.data;
        this.data = new_str;
        caml_blit_bytes(old_data,0,this.data,0,clen)}
      caml_blit_string(buf,pos,this.data,offset,len);
      return 0};
    MlFakeFile.prototype.read
    =
    function(offset,buf,pos,len)
     {var clen=this.length();
      caml_blit_bytes(this.data,offset,buf,pos,len);
      return 0};
    MlFakeFile.prototype.read_one
    =
    function(offset){return caml_bytes_get(this.data,offset)};
    MlFakeFile.prototype.close = function(){};
    MlFakeFile.prototype.constructor = MlFakeFile;
    function MlFakeDevice(root,f)
     {this.content = {};this.root = root;this.lookupFun = f}
    MlFakeDevice.prototype.nm = function(name){return this.root + name};
    MlFakeDevice.prototype.lookup
    =
    function(name)
     {if(! this.content[name] && this.lookupFun)
       {var
         res=
          this.lookupFun
           (caml_string_of_jsbytes(this.root),caml_string_of_jsbytes(name));
        if(res !== 0)
         this.content[name] = new MlFakeFile(caml_bytes_of_string(res[1]))}};
    MlFakeDevice.prototype.exists
    =
    function(name)
     {if(name == "")return 1;
      var name_slash=name + "/",r=new RegExp("^" + name_slash);
      for(var n in this.content)if(n.match(r))return 1;
      this.lookup(name);
      return this.content[name]?1:0};
    MlFakeDevice.prototype.readdir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       seen={},
       a=[];
      for(var n in this.content)
       {var m=n.match(r);
        if(m && ! seen[m[1]]){seen[m[1]] = true;a.push(m[1])}}
      return a};
    MlFakeDevice.prototype.is_dir
    =
    function(name)
     {var
       name_slash=name == ""?"":name + "/",
       r=new RegExp("^" + name_slash + "([^/]*)"),
       a=[];
      for(var n in this.content){var m=n.match(r);if(m)return 1}
      return 0};
    MlFakeDevice.prototype.unlink
    =
    function(name)
     {var ok=this.content[name]?true:false;
      delete this.content[name];
      return ok};
    MlFakeDevice.prototype.open
    =
    function(name,f)
     {if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (this.nm(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      this.lookup(name);
      if(this.content[name])
       {if(this.is_dir(name))
         caml_raise_sys_error(this.nm(name) + " : is a directory");
        if(f.create && f.excl)
         caml_raise_sys_error(this.nm(name) + " : file already exists");
        var file=this.content[name];
        if(f.truncate)file.truncate();
        return file}
      else
       if(f.create)
        {this.content[name] = new MlFakeFile(caml_create_bytes(0));
         return this.content[name]}
       else
        caml_raise_no_such_file(this.nm(name))};
    MlFakeDevice.prototype.register
    =
    function(name,content)
     {if(this.content[name])
       caml_raise_sys_error(this.nm(name) + " : file already exists");
      if(caml_is_ml_bytes(content))
       this.content[name] = new MlFakeFile(content);
      if(caml_is_ml_string(content))
       this.content[name] = new MlFakeFile(caml_bytes_of_string(content));
      else
       if(content instanceof Array)
        this.content[name] = new MlFakeFile(caml_bytes_of_array(content));
       else
        if(typeof content === "string")
         this.content[name] = new MlFakeFile(caml_bytes_of_jsbytes(content));
        else
         if(content.toString)
          {var
            bytes=
             caml_bytes_of_string(caml_string_of_jsstring(content.toString()));
           this.content[name] = new MlFakeFile(bytes)}
         else
          caml_raise_sys_error
           (this.nm(name) + " : registering file with invalid content type")};
    MlFakeDevice.prototype.constructor = MlFakeDevice;
    function caml_ml_string_length(s){return caml_ml_bytes_length(s)}
    function caml_string_unsafe_get(s,i){return caml_bytes_unsafe_get(s,i)}
    function caml_array_of_string(s)
     {var l=caml_ml_string_length(s),a=new Array(l),i=0;
      for(;i < l;i++)a[i] = caml_string_unsafe_get(s,i);
      return a}
    function caml_array_of_bytes(s)
     {if(s.t != 4)caml_convert_bytes_to_array(s);return s.c}
    function caml_bytes_unsafe_set(s,i,c)
     {c &= 0xff;
      if(s.t != 4)
       {if(i == s.c.length)
         {s.c += String.fromCharCode(c);if(i + 1 == s.l)s.t = 0;return 0}
        caml_convert_bytes_to_array(s)}
      s.c[i] = c;
      return 0}
    function caml_bytes_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_bytes_bound_error();
      return caml_bytes_unsafe_set(s,i,c)}
    function MlNodeFile(fd){this.fs = require("fs");this.fd = fd}
    MlNodeFile.prototype = new MlFile();
    MlNodeFile.prototype.truncate
    =
    function(len)
     {try
       {this.fs.ftruncateSync(this.fd,len | 0)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.length
    =
    function()
     {try
       {return this.fs.fstatSync(this.fd).size}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.write
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_string(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.writeSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return 0};
    MlNodeFile.prototype.read
    =
    function(offset,buf,buf_offset,len)
     {var a=caml_array_of_bytes(buf);
      if(! (a instanceof joo_global_object.Uint8Array))
       a = new (joo_global_object.Uint8Array)(a);
      var buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,buf_offset,len,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      for(var i=0;i < len;i++)
       caml_bytes_set(buf,buf_offset + i,buffer[buf_offset + i]);
      return 0};
    MlNodeFile.prototype.read_one
    =
    function(offset)
     {var
       a=new (joo_global_object.Uint8Array)(1),
       buffer=joo_global_object.Buffer.from(a);
      try
       {this.fs.readSync(this.fd,buffer,0,1,offset)}
      catch(err){caml_raise_sys_error(err.toString())}
      return buffer[0]};
    MlNodeFile.prototype.close
    =
    function()
     {try
       {this.fs.closeSync(this.fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeFile.prototype.constructor = MlNodeFile;
    function MlNodeDevice(root){this.fs = require("fs");this.root = root}
    MlNodeDevice.prototype.nm = function(name){return this.root + name};
    MlNodeDevice.prototype.exists
    =
    function(name)
     {try
       {return this.fs.existsSync(this.nm(name))?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.readdir
    =
    function(name)
     {try
       {return this.fs.readdirSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.is_dir
    =
    function(name)
     {try
       {return this.fs.statSync(this.nm(name)).isDirectory()?1:0}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.unlink
    =
    function(name)
     {try
       {var b=this.fs.existsSync(this.nm(name))?1:0;
        this.fs.unlinkSync(this.nm(name))}
      catch(err){caml_raise_sys_error(err.toString())}
      return b};
    MlNodeDevice.prototype.open
    =
    function(name,f)
     {var consts=require("constants"),res=0;
      for(var key in f)
       switch(key)
        {case "rdonly":res |= consts.O_RDONLY;break;
         case "wronly":res |= consts.O_WRONLY;break;
         case "append":res |= consts.O_WRONLY | consts.O_APPEND;break;
         case "create":res |= consts.O_CREAT;break;
         case "truncate":res |= consts.O_TRUNC;break;
         case "excl":res |= consts.O_EXCL;break;
         case "binary":res |= consts.O_BINARY;break;
         case "text":res |= consts.O_TEXT;break;
         case "nonblock":res |= consts.O_NONBLOCK;break
         }
      try
       {var fd=this.fs.openSync(this.nm(name),res);return new MlNodeFile(fd)}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.rename
    =
    function(o,n)
     {try
       {this.fs.renameSync(this.nm(o),this.nm(n))}
      catch(err){caml_raise_sys_error(err.toString())}};
    MlNodeDevice.prototype.constructor = MlNodeDevice;
    var caml_root=caml_current_dir.match(/[^\/]*\//)[0];
    function fs_node_supported()
     {return typeof joo_global_object.process
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions
             !==
             "undefined"
             &&
             typeof joo_global_object.process.versions.node
             !==
             "undefined"
             &&
             joo_global_object.process.platform
             !==
             "browser"}
    var jsoo_mount_point=[];
    if(fs_node_supported())
     jsoo_mount_point.push
      ({path:caml_root,device:new MlNodeDevice(caml_root)});
    else
     jsoo_mount_point.push
      ({path:caml_root,device:new MlFakeDevice(caml_root)});
    jsoo_mount_point.push
     ({path:caml_root + "static/",
       device:new MlFakeDevice(caml_root + "static/")});
    function resolve_fs_device(name)
     {var
       path=caml_make_path(name),
       name=path.join("/"),
       name_slash=name + "/",
       res;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var m=jsoo_mount_point[i];
        if
         (name_slash.search(m.path)
          ==
          0
          &&
          (! res || res.path.length < m.path.length))
         res
         =
         {path:m.path,
          device:m.device,
          rest:name.substring(m.path.length,name.length)}}
      return res}
    function caml_sys_is_directory(name)
     {var root=resolve_fs_device(name),a=root.device.is_dir(root.rest);
      return a?1:0}
    function caml_raise_not_found()
     {caml_raise_constant(caml_global_data.Not_found)}
    function caml_sys_getenv(name)
     {var g=joo_global_object,n=caml_jsstring_of_string(name);
      if(g.process && g.process.env && g.process.env[n] != undefined)
       return caml_string_of_jsstring(g.process.env[n]);
      if
       (joo_global_object.jsoo_static_env
        &&
        joo_global_object.jsoo_static_env[n])
       return caml_string_of_jsstring(joo_global_object.jsoo_static_env[n]);
      caml_raise_not_found()}
    function shift_right_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=len1 - 1;i >= 0;i--)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a >>> nbits | wrap;
        wrap = a << 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    var caml_named_values={};
    function caml_named_value(nm){return caml_named_values[nm]}
    var caml_gr_state;
    function caml_gr_state_get()
     {if(caml_gr_state)return caml_gr_state;
      throw [0,
             caml_named_value("Graphics.Graphic_failure"),
             caml_string_of_jsbytes("Not initialized")]}
    function caml_gr_point_color(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.getImageData(x,s.height - y,1,1),
       d=im.data;
      return (d[0] << 16) + (d[1] << 8) + d[2]}
    var MlObjectTable;
    if(typeof joo_global_object.WeakMap === "undefined")
     MlObjectTable
     =
     function()
       {function NaiveLookup(objs){this.objs = objs}
        NaiveLookup.prototype.get
        =
        function(v)
         {for(var i=0;i < this.objs.length;i++)if(this.objs[i] === v)return i};
        NaiveLookup.prototype.set = function(){};
        return function()
         {this.objs = [];this.lookup = new NaiveLookup(this.objs)}}
      ();
    else
     MlObjectTable
     =
     function()
      {this.objs = [];this.lookup = new (joo_global_object.WeakMap)()};
    MlObjectTable.prototype.store
    =
    function(v){this.lookup.set(v,this.objs.length);this.objs.push(v)};
    MlObjectTable.prototype.recall
    =
    function(v)
     {var i=this.lookup.get(v);
      return i === undefined?undefined:this.objs.length - i};
    function caml_failwith(msg)
     {caml_raise_with_string(caml_global_data.Failure,msg)}
    function caml_sys_rename(o,n)
     {var o_root=resolve_fs_device(o),n_root=resolve_fs_device(n);
      if(o_root.device != n_root.device)
       caml_failwith
        ("caml_sys_rename: cannot move file between two filesystem");
      if(! o_root.device.rename)
       caml_failwith("caml_sys_rename: no implemented");
      o_root.device.rename(o_root.rest,n_root.rest)}
    function caml_log10_float(x){return Math.LOG10E * Math.log(x)}
    var caml_runtime_warnings=0;
    function caml_ml_enable_runtime_warnings(bool)
     {caml_runtime_warnings = bool;return 0}
    function caml_classify_float(x)
     {if(isFinite(x))
       {if(Math.abs(x) >= 2.2250738585072014e-308)return 0;
        if(x != 0)return 1;
        return 2}
      return isNaN(x)?4:3}
    function caml_ml_refill_input(chan)
     {var str=chan.refill(),str_len=caml_ml_string_length(str);
      if(str_len == 0)chan.refill = null;
      chan.file.write(chan.file.length(),str,0,str_len);
      return str_len}
    var caml_ml_channels=new Array();
    function caml_ml_may_refill_input(chanid)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill == null)return;
      if(chan.file.length() != chan.offset)return;
      caml_ml_refill_input(chan)}
    function caml_array_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_ml_input_scan_line(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      var p=chan.offset,len=chan.file.length();
      if(p >= len)return 0;
      while(true)
       {if(p >= len)return - (p - chan.offset);
        if(chan.file.read_one(p) == 10)return p - chan.offset + 1;
        p++}}
    function caml_gc_minor(){return 0}
    function caml_int64_of_bytes(a)
     {return new
              MlInt64
              (a[7] << 0 | a[6] << 8 | a[5] << 16,
               a[4] << 0 | a[3] << 8 | a[2] << 16,
               a[1] << 0 | a[0] << 8)}
    function caml_ba_uint8_get64(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3),
       b5=ba.get(ofs + 4),
       b6=ba.get(ofs + 5),
       b7=ba.get(ofs + 6),
       b8=ba.get(ofs + 7);
      return caml_int64_of_bytes([b8,b7,b6,b5,b4,b3,b2,b1])}
    function caml_int64_to_bytes(x){return x.toArray()}
    function caml_int64_marshal(writer,v,sizes)
     {var b=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)writer.write(8,b[i]);
      sizes[0] = 8;
      sizes[1] = 8}
    function caml_ba_num_dims(ba){return ba.dims.length}
    function caml_return_exn_constant(tag){return tag}
    function caml_wrap_exception(e)
     {if(e instanceof Array)return e;
      if
       (joo_global_object.RangeError
        &&
        e instanceof joo_global_object.RangeError
        &&
        e.message
        &&
        e.message.match(/maximum call stack/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if
       (joo_global_object.InternalError
        &&
        e instanceof joo_global_object.InternalError
        &&
        e.message
        &&
        e.message.match(/too much recursion/i))
       return caml_return_exn_constant(caml_global_data.Stack_overflow);
      if(e instanceof joo_global_object.Error && caml_named_value("jsError"))
       return [0,caml_named_value("jsError"),e];
      return [0,caml_global_data.Failure,caml_string_of_jsstring(String(e))]}
    function caml_create_file(name,content)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       content=
        typeof content == "string"?caml_string_of_jsbytes(content):content,
       root=resolve_fs_device(name);
      if(! root.device.register)caml_failwith("cannot register file");
      root.device.register(root.rest,content);
      return 0}
    function caml_fs_init()
     {var tmp=joo_global_object.caml_fs_tmp;
      if(tmp)
       for(var i=0;i < tmp.length;i++)
        caml_create_file(tmp[i].name,tmp[i].content);
      joo_global_object.caml_create_file = caml_create_file;
      joo_global_object.caml_fs_tmp = [];
      return 0}
    function caml_set_parser_trace(){return 0}
    function caml_list_of_js_array(a)
     {var l=0;
      for(var i=a.length - 1;i >= 0;i--){var e=a[i];l = [0,e,l]}
      return l}
    function unix_gettimeofday(){return new Date().getTime() / 1000}
    function caml_mul(a,b){return Math.imul(a,b)}
    function caml_hash_mix_int(h,d)
     {d = caml_mul(d,0xcc9e2d51 | 0);
      d = d << 15 | d >>> 32 - 15;
      d = caml_mul(d,0x1b873593);
      h ^= d;
      h = h << 13 | h >>> 32 - 13;
      return (h + (h << 2) | 0) + (0xe6546b64 | 0) | 0}
    function num_digits_nat(nat,ofs,len)
     {for(var i=len - 1;i >= 0;i--)if(nat.data[ofs + i] != 0)return i + 1;
      return 1}
    function caml_hash_nat(x)
     {var len=num_digits_nat(x,0,x.data.length),h=0;
      for(var i=0;i < len;i++)h = caml_hash_mix_int(h,x.data[i]);
      return h}
    function caml_call_gen(f,args)
     {if(f.fun)return caml_call_gen(f.fun,args);
      if(typeof f !== "function")return f;
      var n=f.length | 0;
      if(n === 0)return f.apply(null,args);
      var argsLen=args.length | 0,d=n - argsLen | 0;
      if(d == 0)
       return f.apply(null,args);
      else
       if(d < 0)
        return caml_call_gen(f.apply(null,args.slice(0,n)),args.slice(n));
       else
        return function()
         {var
           extra_args=arguments.length == 0?1:arguments.length,
           nargs=new Array(args.length + extra_args);
          for(var i=0;i < args.length;i++)nargs[i] = args[i];
          for(var i=0;i < arguments.length;i++)
           nargs[args.length + i] = arguments[i];
          return caml_call_gen(f,nargs)}}
    function caml_js_wrap_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[args])}}
    function caml_sys_chdir(dir)
     {var root=resolve_fs_device(dir);
      if(root.device.exists(root.rest))
       {if(root.rest)
         caml_current_dir = root.path + root.rest + "/";
        else
         caml_current_dir = root.path;
        return 0}
      else
       caml_raise_no_such_file(dir)}
    function caml_gc_counters(){return [254,0,0,0]}
    function caml_gr_synchronize()
     {caml_failwith("caml_gr_synchronize not Implemented")}
    var log2_ok=Math.log2 && Math.log2(1.1235582092889474E+307) == 1020;
    function jsoo_floor_log2(x)
     {if(log2_ok)return Math.floor(Math.log2(x));
      var i=0;
      if(x == 0)return - Infinity;
      if(x >= 1)while(x >= 2){x /= 2;i++}else while(x < 1){x *= 2;i--}
      return i}
    function caml_int32_bits_of_float(x)
     {var float32a=new (joo_global_object.Float32Array)(1);
      float32a[0] = x;
      var int32a=new (joo_global_object.Int32Array)(float32a.buffer);
      return int32a[0] | 0}
    function caml_int64_create_lo_mi_hi(lo,mi,hi)
     {return new MlInt64(lo,mi,hi)}
    function caml_int64_bits_of_float(x)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_int64_create_lo_mi_hi(1,0,0x7ff0);
        return x > 0
                ?caml_int64_create_lo_mi_hi(0,0,0x7ff0)
                :caml_int64_create_lo_mi_hi(0,0,0xfff0)}
      var sign=x == 0 && 1 / x == - Infinity?0x8000:x >= 0?0:0x8000;
      if(sign)x = - x;
      var exp=jsoo_floor_log2(x) + 1023;
      if(exp <= 0)
       {exp = 0;x /= Math.pow(2,- 1026)}
      else
       {x /= Math.pow(2,exp - 1027);
        if(x < 16){x *= 2;exp -= 1}
        if(exp == 0)x /= 2}
      var k=Math.pow(2,24),r3=x | 0;
      x = (x - r3) * k;
      var r2=x | 0;
      x = (x - r2) * k;
      var r1=x | 0;
      r3 = r3 & 0xf | sign | exp << 4;
      return caml_int64_create_lo_mi_hi(r1,r2,r3)}
    function caml_ba_serialize(writer,ba,sz)
     {writer.write(32,ba.dims.length);
      writer.write(32,ba.kind | ba.layout << 8);
      if(ba.caml_custom == "_bigarr02")
       for(var i=0;i < ba.dims.length;i++)
        if(ba.dims[i] < 0xffff)
         writer.write(16,ba.dims[i]);
        else
         {writer.write(16,0xffff);
          writer.write(32,0);
          writer.write(32,ba.dims[i])}
      else
       for(var i=0;i < ba.dims.length;i++)writer.write(32,ba.dims[i]);
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         for(var i=0;i < ba.data.length;i++)writer.write(8,ba.data[i]);break;
        case 4:
        case 5:
         for(var i=0;i < ba.data.length;i++)writer.write(16,ba.data[i]);break;
        case 6:
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);break;
        case 8:
        case 9:
         writer.write(8,0);
         for(var i=0;i < ba.data.length;i++)writer.write(32,ba.data[i]);
         break;
        case 7:
         for(var i=0;i < ba.data.length / 2;i++)
          {var b=caml_int64_to_bytes(ba.get(i));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 1:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int64_to_bytes(caml_int64_bits_of_float(ba.get(i)));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break;
        case 0:
         for(var i=0;i < ba.data.length;i++)
          {var b=caml_int32_bits_of_float(ba.get(i));writer.write(32,b)}
         break;
        case 10:
         for(var i=0;i < ba.data.length / 2;i++)
          {var j=ba.get(i);
           writer.write(32,caml_int32_bits_of_float(j[1]));
           writer.write(32,caml_int32_bits_of_float(j[2]))}
         break;
        case 11:
         for(var i=0;i < ba.data.length / 2;i++)
          {var
            complex=ba.get(i),
            b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[1]));
           for(var j=0;j < 8;j++)writer.write(8,b[j]);
           var b=caml_int64_to_bytes(caml_int64_bits_of_float(complex[2]));
           for(var j=0;j < 8;j++)writer.write(8,b[j])}
         break
        }
      sz[0] = (4 + ba.dims.length) * 4;
      sz[1] = (4 + ba.dims.length) * 8}
    function caml_ba_get_size_per_element(kind)
     {switch(kind){case 7:case 10:case 11:return 2;default:return 1}}
    function caml_ba_create_buffer(kind,size)
     {var g=joo_global_object,view;
      switch(kind)
       {case 0:view = g.Float32Array;break;
        case 1:view = g.Float64Array;break;
        case 2:view = g.Int8Array;break;
        case 3:view = g.Uint8Array;break;
        case 4:view = g.Int16Array;break;
        case 5:view = g.Uint16Array;break;
        case 6:view = g.Int32Array;break;
        case 7:view = g.Int32Array;break;
        case 8:view = g.Int32Array;break;
        case 9:view = g.Int32Array;break;
        case 10:view = g.Float32Array;break;
        case 11:view = g.Float64Array;break;
        case 12:view = g.Uint8Array;break
        }
      if(! view)caml_invalid_argument("Bigarray.create: unsupported kind");
      var data=new view(size * caml_ba_get_size_per_element(kind));
      return data}
    function caml_int32_float_of_bits(x)
     {var int32a=new (joo_global_object.Int32Array)(1);
      int32a[0] = x;
      var float32a=new (joo_global_object.Float32Array)(int32a.buffer);
      return float32a[0]}
    function caml_int64_float_of_bits(x)
     {var lo=x.lo,mi=x.mi,hi=x.hi,exp=(hi & 0x7fff) >> 4;
      if(exp == 2047)
       return (lo | mi | hi & 0xf) == 0?hi & 0x8000?- Infinity:Infinity:NaN;
      var k=Math.pow(2,- 24),res=(lo * k + mi) * k + (hi & 0xf);
      if(exp > 0)
       {res += 16;res *= Math.pow(2,exp - 1027)}
      else
       res *= Math.pow(2,- 1026);
      if(hi & 0x8000)res = - res;
      return res}
    function caml_ba_get_size(dims)
     {var n_dims=dims.length,size=1;
      for(var i=0;i < n_dims;i++)
       {if(dims[i] < 0)
         caml_invalid_argument("Bigarray.create: negative dimension");
        size = size * dims[i]}
      return size}
    function caml_int64_create_lo_hi(lo,hi)
     {return new
              MlInt64
              (lo & 0xffffff,
               lo >>> 24 & 0xff | (hi & 0xffff) << 8,
               hi >>> 16 & 0xffff)}
    function caml_int64_hi32(v){return v.hi32()}
    function caml_int64_lo32(v){return v.lo32()}
    var caml_ba_custom_name="_bigarr02";
    function Ml_Bigarray(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray.prototype.caml_custom = caml_ba_custom_name;
    Ml_Bigarray.prototype.offset
    =
    function(arg)
     {var ofs=0;
      if(typeof arg === "number")arg = [arg];
      if(! (arg instanceof Array))
       caml_invalid_argument("bigarray.js: invalid offset");
      if(this.dims.length != arg.length)
       caml_invalid_argument("Bigarray.get/set: bad number of dimensions");
      if(this.layout == 0)
       for(var i=0;i < this.dims.length;i++)
        {if(arg[i] < 0 || arg[i] >= this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + arg[i]}
      else
       for(var i=this.dims.length - 1;i >= 0;i--)
        {if(arg[i] < 1 || arg[i] > this.dims[i])caml_array_bound_error();
         ofs = ofs * this.dims[i] + (arg[i] - 1)}
      return ofs};
    Ml_Bigarray.prototype.get
    =
    function(ofs)
     {switch(this.kind)
       {case 7:
         var l=this.data[ofs * 2 + 0],h=this.data[ofs * 2 + 1];
         return caml_int64_create_lo_hi(l,h);
        case 10:
        case 11:
         var r=this.data[ofs * 2 + 0],i=this.data[ofs * 2 + 1];
         return [254,r,i];
        default:return this.data[ofs]}};
    Ml_Bigarray.prototype.set
    =
    function(ofs,v)
     {switch(this.kind)
       {case 7:
         this.data[ofs * 2 + 0] = caml_int64_lo32(v);
         this.data[ofs * 2 + 1] = caml_int64_hi32(v);
         break;
        case 10:
        case 11:
         this.data[ofs * 2 + 0] = v[1];this.data[ofs * 2 + 1] = v[2];break;
        default:this.data[ofs] = v;break}
      return 0};
    Ml_Bigarray.prototype.fill
    =
    function(v)
     {switch(this.kind)
       {case 7:
         var a=caml_int64_lo32(v),b=caml_int64_hi32(v);
         if(a == b)
          this.data.fill(a);
         else
          for(var i=0;i < this.data.length;i++)this.data[i] = i % 2 == 0?a:b;
         break;
        case 10:
        case 11:
         var im=v[1],re=v[2];
         if(im == re)
          this.data.fill(im);
         else
          for(var i=0;i < this.data.length;i++)
           this.data[i] = i % 2 == 0?im:re;
         break;
        default:this.data.fill(v);break}};
    Ml_Bigarray.prototype.compare
    =
    function(b,total)
     {if(this.layout != b.layout || this.kind != b.kind)
       {var k1=this.kind | this.layout << 8,k2=b.kind | b.layout << 8;
        return k2 - k1}
      if(this.dims.length != b.dims.length)
       return b.dims.length - this.dims.length;
      for(var i=0;i < this.dims.length;i++)
       if(this.dims[i] != b.dims[i])return this.dims[i] < b.dims[i]?- 1:1;
      switch(this.kind)
       {case 0:
        case 1:
        case 10:
        case 11:
         var x,y;
         for(var i=0;i < this.data.length;i++)
          {x = this.data[i];
           y = b.data[i];
           if(x < y)return - 1;
           if(x > y)return 1;
           if(x != y)
            {if(! total)return NaN;if(x == x)return 1;if(y == y)return - 1}}
         break;
        case 7:
         for(var i=0;i < this.data.length;i += 2)
          {if(this.data[i + 1] < b.data[i + 1])return - 1;
           if(this.data[i + 1] > b.data[i + 1])return 1;
           if(this.data[i] >>> 0 < b.data[i] >>> 0)return - 1;
           if(this.data[i] >>> 0 > b.data[i] >>> 0)return 1}
         break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
         for(var i=0;i < this.data.length;i++)
          {if(this.data[i] < b.data[i])return - 1;
           if(this.data[i] > b.data[i])return 1}
         break
        }
      return 0};
    function Ml_Bigarray_c_1_1(kind,layout,dims,buffer)
     {this.kind = kind;
      this.layout = layout;
      this.dims = dims;
      this.data = buffer}
    Ml_Bigarray_c_1_1.prototype = new Ml_Bigarray();
    Ml_Bigarray_c_1_1.prototype.offset
    =
    function(arg)
     {if(typeof arg !== "number")
       if(arg instanceof Array && arg.length == 1)
        arg = arg[0];
       else
        caml_invalid_argument("Ml_Bigarray_c_1_1.offset");
      if(arg < 0 || arg >= this.dims[0])caml_array_bound_error();
      return arg};
    Ml_Bigarray_c_1_1.prototype.get = function(ofs){return this.data[ofs]};
    Ml_Bigarray_c_1_1.prototype.set
    =
    function(ofs,v){this.data[ofs] = v;return 0};
    Ml_Bigarray_c_1_1.prototype.fill
    =
    function(v){this.data.fill(v);return 0};
    function caml_ba_create_unsafe(kind,layout,dims,data)
     {var size_per_element=caml_ba_get_size_per_element(kind);
      if(caml_ba_get_size(dims) * size_per_element != data.length)
       caml_invalid_argument("length doesn't match dims");
      if(layout == 0 && dims.length == 1 && size_per_element == 1)
       return new Ml_Bigarray_c_1_1(kind,layout,dims,data);
      return new Ml_Bigarray(kind,layout,dims,data)}
    function caml_ba_deserialize(reader,sz,name)
     {var num_dims=reader.read32s();
      if(num_dims < 0 || num_dims > 16)
       caml_failwith("input_value: wrong number of bigarray dimensions");
      var tag=reader.read32s(),kind=tag & 0xff,layout=tag >> 8 & 1,dims=[];
      if(name == "_bigarr02")
       for(var i=0;i < num_dims;i++)
        {var size_dim=reader.read16u();
         if(size_dim == 0xffff)
          {var size_dim_hi=reader.read32u(),size_dim_lo=reader.read32u();
           if(size_dim_hi != 0)
            caml_failwith("input_value: bigarray dimension overflow in 32bit");
           size_dim = size_dim_lo}
         dims.push(size_dim)}
      else
       for(var i=0;i < num_dims;i++)dims.push(reader.read32u());
      var
       size=caml_ba_get_size(dims),
       data=caml_ba_create_buffer(kind,size),
       ba=caml_ba_create_unsafe(kind,layout,dims,data);
      switch(kind)
       {case 2:for(var i=0;i < size;i++)data[i] = reader.read8s();break;
        case 3:
        case 12:for(var i=0;i < size;i++)data[i] = reader.read8u();break;
        case 4:for(var i=0;i < size;i++)data[i] = reader.read16s();break;
        case 5:for(var i=0;i < size;i++)data[i] = reader.read16u();break;
        case 6:for(var i=0;i < size;i++)data[i] = reader.read32s();break;
        case 8:
        case 9:
         var sixty=reader.read8u();
         if(sixty)
          caml_failwith
           ("input_value: cannot read bigarray with 64-bit OCaml ints");
         for(var i=0;i < size;i++)data[i] = reader.read32s();
         break;
        case 7:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var int64=caml_int64_of_bytes(t);
           ba.set(i,int64)}
         break;
        case 1:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var f=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,f)}
         break;
        case 0:
         for(var i=0;i < size;i++)
          {var f=caml_int32_float_of_bits(reader.read32s());ba.set(i,f)}
         break;
        case 10:
         for(var i=0;i < size;i++)
          {var
            re=caml_int32_float_of_bits(reader.read32s()),
            im=caml_int32_float_of_bits(reader.read32s());
           ba.set(i,[254,re,im])}
         break;
        case 11:
         var t=new Array(8);
         for(var i=0;i < size;i++)
          {for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var re=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           for(var j=0;j < 8;j++)t[j] = reader.read8u();
           var im=caml_int64_float_of_bits(caml_int64_of_bytes(t));
           ba.set(i,[254,re,im])}
         break
        }
      sz[0] = (4 + num_dims) * 4;
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_ba_compare(a,b,total){return a.compare(b,total)}
    function caml_hash_mix_int64(h,v)
     {h = caml_hash_mix_int(h,caml_int64_lo32(v));
      h = caml_hash_mix_int(h,caml_int64_hi32(v));
      return h}
    function caml_hash_mix_float(h,v0)
     {return caml_hash_mix_int64(h,caml_int64_bits_of_float(v0))}
    function caml_ba_hash(ba)
     {var num_elts=caml_ba_get_size(ba.dims),h=0;
      switch(ba.kind)
       {case 2:
        case 3:
        case 12:
         if(num_elts > 256)num_elts = 256;
         var w=0,i=0;
         for(i = 0;i + 4 <= ba.data.length;i += 4)
          {w
           =
           ba.data[i + 0]
           |
           ba.data[i + 1]
           <<
           8
           |
           ba.data[i + 2]
           <<
           16
           |
           ba.data[i + 3]
           <<
           24;
           h = caml_hash_mix_int(h,w)}
         w = 0;
         switch(num_elts & 3)
          {case 3:w = ba.data[i + 2] << 16;
           case 2:w |= ba.data[i + 1] << 8;
           case 1:w |= ba.data[i + 0];h = caml_hash_mix_int(h,w)
           }
         break;
        case 4:
        case 5:
         if(num_elts > 128)num_elts = 128;
         var w=0,i=0;
         for(i = 0;i + 2 <= ba.data.length;i += 2)
          {w = ba.data[i + 0] | ba.data[i + 1] << 16;
           h = caml_hash_mix_int(h,w)}
         if((num_elts & 1) != 0)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 6:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 8:
        case 9:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 7:
         if(num_elts > 32)num_elts = 32;
         num_elts *= 2;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_int(h,ba.data[i]);
         break;
        case 10:num_elts *= 2;
        case 0:
         if(num_elts > 64)num_elts = 64;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break;
        case 11:num_elts *= 2;
        case 1:
         if(num_elts > 32)num_elts = 32;
         for(var i=0;i < num_elts;i++)h = caml_hash_mix_float(h,ba.data[i]);
         break
        }
      return h}
    function caml_int32_unmarshal(reader,size)
     {size[0] = 4;return reader.read32s()}
    function caml_nativeint_unmarshal(reader,size)
     {switch(reader.read8u())
       {case 1:size[0] = 4;return reader.read32s();
        case 2:caml_failwith("input_value: native integer value too large");
        default:caml_failwith("input_value: ill-formed native integer")}}
    function caml_int64_unmarshal(reader,size)
     {var t=new Array(8);
      for(var j=0;j < 8;j++)t[j] = reader.read8u();
      size[0] = 8;
      return caml_int64_of_bytes(t)}
    function caml_int64_compare(x,y,total){return x.compare(y)}
    function caml_int64_hash(v){return v.lo32() ^ v.hi32()}
    var
     caml_custom_ops=
      {"_j":
       {deserialize:caml_int64_unmarshal,
        serialize:caml_int64_marshal,
        fixed_length:8,
        compare:caml_int64_compare,
        hash:caml_int64_hash},
       "_i":{deserialize:caml_int32_unmarshal,fixed_length:4},
       "_n":{deserialize:caml_nativeint_unmarshal,fixed_length:4},
       "_bigarray":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarray")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash},
       "_bigarr02":
       {deserialize:
        function(reader,sz){return caml_ba_deserialize(reader,sz,"_bigarr02")},
        serialize:caml_ba_serialize,
        compare:caml_ba_compare,
        hash:caml_ba_hash}};
    function caml_compare_val_get_custom(a)
     {return caml_custom_ops[a.caml_custom]
             &&
             caml_custom_ops[a.caml_custom].compare}
    function caml_compare_val_number_custom(num,custom,swap,total)
     {var comp=caml_compare_val_get_custom(custom);
      if(comp)
       {var x=swap > 0?comp(custom,num,total):comp(num,custom,total);
        if(total && x != x)return swap;
        if(+ x != + x)return + x;
        if((x | 0) != 0)return x | 0}
      return swap}
    function caml_compare_val_tag(a)
     {if(typeof a === "number")
       return 1000;
      else
       if(caml_is_ml_bytes(a))
        return 252;
       else
        if(caml_is_ml_string(a))
         return 1252;
        else
         if(a instanceof Array && a[0] === a[0] >>> 0 && a[0] <= 255)
          {var tag=a[0] | 0;return tag == 254?0:tag}
         else
          if(a instanceof String)
           return 12520;
          else
           if(typeof a == "string")
            return 12520;
           else
            if(a instanceof Number)
             return 1000;
            else
             if(a && a.caml_custom)
              return 1255;
             else
              if(a && a.compare)
               return 1256;
              else
               if(typeof a == "function")
                return 1247;
               else
                if(typeof a == "symbol")return 1251;
      return 1001}
    function caml_int_compare(a,b)
     {if(a < b)return - 1;if(a == b)return 0;return 1}
    function caml_bytes_compare(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?- 1:s1.c > s2.c?1:0}
    function caml_string_compare(s1,s2){return caml_bytes_compare(s1,s2)}
    function caml_compare_val(a,b,total)
     {var stack=[];
      for(;;)
       {if(! (total && a === b))
         {var tag_a=caml_compare_val_tag(a);
          if(tag_a == 250){a = a[1];continue}
          var tag_b=caml_compare_val_tag(b);
          if(tag_b == 250){b = b[1];continue}
          if(tag_a !== tag_b)
           {if(tag_a == 1000)
             {if(tag_b == 1255)
               return caml_compare_val_number_custom(a,b,- 1,total);
              return - 1}
            if(tag_b == 1000)
             {if(tag_a == 1255)
               return caml_compare_val_number_custom(b,a,1,total);
              return 1}
            return tag_a < tag_b?- 1:1}
          switch(tag_a)
           {case 247:caml_invalid_argument("compare: functional value");break;
            case 248:
             var x=caml_int_compare(a[2],b[2]);if(x != 0)return x | 0;break;
            case 249:caml_invalid_argument("compare: functional value");break;
            case 250:
             caml_invalid_argument
              ("equal: got Forward_tag, should not happen");
             break;
            case 251:caml_invalid_argument("equal: abstract value");break;
            case 252:
             if(a !== b){var x=caml_bytes_compare(a,b);if(x != 0)return x | 0}
             break;
            case 253:
             caml_invalid_argument("equal: got Double_tag, should not happen");
             break;
            case 254:
             caml_invalid_argument
              ("equal: got Double_array_tag, should not happen");
             break;
            case 255:
             caml_invalid_argument("equal: got Custom_tag, should not happen");
             break;
            case 1247:
             caml_invalid_argument("compare: functional value");break;
            case 1255:
             var comp=caml_compare_val_get_custom(a);
             if(comp != caml_compare_val_get_custom(b))
              return a.caml_custom < b.caml_custom?- 1:1;
             if(! comp)caml_invalid_argument("compare: abstract value");
             var x=comp(a,b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1256:
             var x=a.compare(b,total);
             if(x != x)return total?- 1:x;
             if(x !== (x | 0))return - 1;
             if(x != 0)return x | 0;
             break;
            case 1000:
             a = + a;
             b = + b;
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1001:
             if(a < b)return - 1;
             if(a > b)return 1;
             if(a != b)
              {if(! total)return NaN;if(a == a)return 1;if(b == b)return - 1}
             break;
            case 1251:if(a !== b){if(! total)return NaN;return 1}break;
            case 1252:
             var a=caml_jsbytes_of_string(a),b=caml_jsbytes_of_string(b);
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 12520:
             var a=a.toString(),b=b.toString();
             if(a !== b){if(a < b)return - 1;if(a > b)return 1}
             break;
            case 246:
            case 254:
            default:
             if(a.length != b.length)return a.length < b.length?- 1:1;
             if(a.length > 1)stack.push(a,b,1);
             break}}
        if(stack.length == 0)return 0;
        var i=stack.pop();
        b = stack.pop();
        a = stack.pop();
        if(i + 1 < a.length)stack.push(a,b,i + 1);
        a = a[i];
        b = b[i]}}
    function caml_greaterthan(x,y){return + (caml_compare_val(x,y,false) > 0)}
    function div_helper(a,b,c)
     {var
       x=a * 65536 + (b >>> 16),
       y=Math.floor(x / c) * 65536,
       z=x % c * 65536,
       w=z + (b & 0x0000FFFF);
      return [y + Math.floor(w / c),w % c]}
    function div_digit_nat(natq,ofsq,natr,ofsr,nat1,ofs1,len,nat2,ofs2)
     {var rem=nat1.data[ofs1 + len - 1] >>> 0;
      for(var i=len - 2;i >= 0;i--)
       {var x=div_helper(rem,nat1.data[ofs1 + i] >>> 0,nat2.data[ofs2] >>> 0);
        natq.data[ofsq + i] = x[0];
        rem = x[1]}
      natr.data[ofsr] = rem;
      return 0}
    function num_leading_zero_bits_in_digit(nat,ofs)
     {var a=nat.data[ofs],b=0;
      if(a & 0xFFFF0000){b += 16;a >>>= 16}
      if(a & 0xFF00){b += 8;a >>>= 8}
      if(a & 0xF0){b += 4;a >>>= 4}
      if(a & 12){b += 2;a >>>= 2}
      if(a & 2){b += 1;a >>>= 1}
      if(a & 1)b += 1;
      return 32 - b}
    function shift_left_nat(nat1,ofs1,len1,nat2,ofs2,nbits)
     {if(nbits == 0){nat2.data[ofs2] = 0;return 0}
      var wrap=0;
      for(var i=0;i < len1;i++)
       {var a=nat1.data[ofs1 + i] >>> 0;
        nat1.data[ofs1 + i] = a << nbits | wrap;
        wrap = a >>> 32 - nbits}
      nat2.data[ofs2] = wrap;
      return 0}
    function MlNat(x)
     {this.data = new (joo_global_object.Int32Array)(x);
      this.length = this.data.length + 2}
    MlNat.prototype.caml_custom = "_nat";
    function create_nat(size)
     {var arr=new MlNat(size);
      for(var i=0;i < size;i++)arr.data[i] = - 1;
      return arr}
    function set_to_zero_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)nat.data[ofs + i] = 0;return 0}
    function incr_nat(nat,ofs,len,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) + carry;
        nat.data[ofs + i] = x | 0;
        if(x == x >>> 0){carry = 0;break}else carry = 1}
      return carry}
    function add_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var carry=carry_in;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) + (nat2.data[ofs2 + i] >>> 0) + carry;
        nat1.data[ofs1 + i] = x;
        if(x == x >>> 0)carry = 0;else carry = 1}
      return incr_nat(nat1,ofs1 + len2,len1 - len2,carry)}
    function nat_of_array(l){return new MlNat(l)}
    function mult_digit_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3)
     {var carry=0,a=nat3.data[ofs3] >>> 0;
      for(var i=0;i < len2;i++)
       {var
         x1=
          (nat1.data[ofs1 + i] >>> 0)
          +
          (nat2.data[ofs2 + i] >>> 0)
          *
          (a & 0x0000FFFF)
          +
          carry,
         x2=(nat2.data[ofs2 + i] >>> 0) * (a >>> 16);
        carry = Math.floor(x2 / 65536);
        var x3=x1 + x2 % 65536 * 65536;
        nat1.data[ofs1 + i] = x3;
        carry += Math.floor(x3 / 4294967296)}
      return len2 < len1 && carry
              ?add_nat
                (nat1,ofs1 + len2,len1 - len2,nat_of_array([carry]),0,1,0)
              :carry}
    function decr_nat(nat,ofs,len,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len;i++)
       {var x=(nat.data[ofs + i] >>> 0) - borrow;
        nat.data[ofs + i] = x;
        if(x >= 0){borrow = 0;break}else borrow = 1}
      return borrow == 1?0:1}
    function sub_nat(nat1,ofs1,len1,nat2,ofs2,len2,carry_in)
     {var borrow=carry_in == 1?0:1;
      for(var i=0;i < len2;i++)
       {var
         x=
          (nat1.data[ofs1 + i] >>> 0) - (nat2.data[ofs2 + i] >>> 0) - borrow;
        nat1.data[ofs1 + i] = x;
        if(x >= 0)borrow = 0;else borrow = 1}
      return decr_nat(nat1,ofs1 + len2,len1 - len2,borrow == 1?0:1)}
    function compare_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var a=num_digits_nat(nat1,ofs1,len1),b=num_digits_nat(nat2,ofs2,len2);
      if(a > b)return 1;
      if(a < b)return - 1;
      for(var i=len1 - 1;i >= 0;i--)
       {if(nat1.data[ofs1 + i] >>> 0 > nat2.data[ofs2 + i] >>> 0)return 1;
        if(nat1.data[ofs1 + i] >>> 0 < nat2.data[ofs2 + i] >>> 0)return - 1}
      return 0}
    function div_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {if(len2 == 1)
       {div_digit_nat(nat1,ofs1 + 1,nat1,ofs1,nat1,ofs1,len1,nat2,ofs2);
        return 0}
      var s=num_leading_zero_bits_in_digit(nat2,ofs2 + len2 - 1);
      shift_left_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      shift_left_nat(nat1,ofs1,len1,nat_of_array([0]),0,s);
      var d=(nat2.data[ofs2 + len2 - 1] >>> 0) + 1,a=create_nat(len2 + 1);
      for(var i=len1 - 1;i >= len2;i--)
       {var
         quo=
          d == 4294967296
           ?nat1.data[ofs1 + i] >>> 0
           :div_helper
              (nat1.data[ofs1 + i] >>> 0,nat1.data[ofs1 + i - 1] >>> 0,d)
             [0];
        set_to_zero_nat(a,0,len2 + 1);
        mult_digit_nat(a,0,len2 + 1,nat2,ofs2,len2,nat_of_array([quo]),0);
        sub_nat(nat1,ofs1 + i - len2,len2 + 1,a,0,len2 + 1,1);
        while
         (nat1.data[ofs1 + i]
          !=
          0
          ||
          compare_nat(nat1,ofs1 + i - len2,len2,nat2,ofs2,len2)
          >=
          0)
         {quo = quo + 1;
          sub_nat(nat1,ofs1 + i - len2,len2 + 1,nat2,ofs2,len2,1)}
        nat1.data[ofs1 + i] = quo}
      shift_right_nat(nat1,ofs1,len2,nat_of_array([0]),0,s);
      shift_right_nat(nat2,ofs2,len2,nat_of_array([0]),0,s);
      return 0}
    function caml_ba_blit(src,dst)
     {if(dst.dims.length != src.dims.length)
       caml_invalid_argument("Bigarray.blit: dimension mismatch");
      for(var i=0;i < dst.dims.length;i++)
       if(dst.dims[i] != src.dims[i])
        caml_invalid_argument("Bigarray.blit: dimension mismatch");
      dst.data.set(src.data);
      return 0}
    function is_digit_int(nat,ofs){if(nat.data[ofs] >= 0)return 1;return 0}
    function caml_int64_div(x,y){return x.div(y)}
    function caml_js_html_entities(s)
     {var entity=/^&#?[0-9a-zA-Z]+;$/;
      if(s.match(entity))
       {var str,temp=document.createElement("p");
        temp.innerHTML = s;
        str = temp.textContent || temp.innerText;
        temp = null;
        return str}
      else
       caml_failwith("Invalid entity " + s)}
    function caml_string_unsafe_set(s,i,c)
     {return caml_bytes_unsafe_set(s,i,c)}
    function caml_int64_of_float(x)
     {if(x < 0)x = Math.ceil(x);
      return new
              MlInt64
              (x & 0xffffff,
               Math.floor(x * caml_int64_offset) & 0xffffff,
               Math.floor(x * caml_int64_offset * caml_int64_offset) & 0xffff)}
    function caml_ml_channel_size_64(chanid)
     {var chan=caml_ml_channels[chanid];
      return caml_int64_of_float(chan.file.length())}
    function caml_ba_set_2(ba,i0,i1,v){ba.set(ba.offset([i0,i1]),v);return 0}
    var
     caml_argv=
      function()
        {var g=joo_global_object,main="a.out",args=[];
         if(g.process && g.process.argv && g.process.argv.length > 1)
          {var argv=g.process.argv;main = argv[1];args = argv.slice(2)}
         var p=caml_string_of_jsstring(main),args2=[0,p];
         for(var i=0;i < args.length;i++)
          args2.push(caml_string_of_jsstring(args[i]));
         return args2}
       (),
     caml_executable_name=caml_argv[1];
    function caml_js_eval_string(s){return eval(caml_jsstring_of_string(s))}
    function caml_CamlinternalMod_init_mod(loc,shape)
     {function undef_module(_x)
       {caml_raise_with_arg(caml_global_data.Undefined_recursive_module,loc)}
      function loop(shape,struct,idx)
       {if(typeof shape === "number")
         switch(shape)
          {case 0:struct[idx] = {fun:undef_module};break;
           case 1:struct[idx] = [246,undef_module];break;
           default:struct[idx] = []}
        else
         switch(shape[0])
          {case 0:
            struct[idx] = [0];
            for(var i=1;i < shape[1].length;i++)
             loop(shape[1][i],struct[idx],i);
            break;
           default:struct[idx] = shape[1]}}
      var res=[];
      loop(shape,res,0);
      return res[0]}
    function serialize_nat(writer,nat,sz)
     {var len=nat.data.length;
      writer.write(32,len);
      for(var i=0;i < len;i++)writer.write(32,nat.data[i]);
      sz[0] = len * 4;
      sz[1] = len * 8}
    function caml_memprof_set(_control){return 0}
    function caml_sys_exit(code)
     {var g=joo_global_object;
      if(g.quit)g.quit(code);
      if(g.process && g.process.exit)g.process.exit(code);
      caml_invalid_argument("Function 'exit' not implemented")}
    function caml_channel_descriptor(chanid)
     {var chan=caml_ml_channels[chanid];return chan.fd}
    function caml_js_from_array(a){return a.slice(1)}
    function caml_ba_reshape(ba,vind)
     {vind = caml_js_from_array(vind);
      var new_dim=[],num_dims=vind.length;
      if(num_dims < 0 || num_dims > 16)
       caml_invalid_argument("Bigarray.reshape: bad number of dimensions");
      var num_elts=1;
      for(var i=0;i < num_dims;i++)
       {new_dim[i] = vind[i];
        if(new_dim[i] < 0)
         caml_invalid_argument("Bigarray.reshape: negative dimension");
        num_elts = num_elts * new_dim[i]}
      var size=caml_ba_get_size(ba.dims);
      if(num_elts != size)
       caml_invalid_argument("Bigarray.reshape: size mismatch");
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dim,ba.data)}
    var caml_oo_last_id=0;
    function caml_set_oo_id(b){b[2] = caml_oo_last_id++;return b}
    function caml_gr_fill_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.fillRect(x,s.height - y,w,- h);
      return 0}
    function caml_bigstring_blit_string_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_string_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_string(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function caml_gr_set_window_title(name)
     {var s=caml_gr_state_get();
      s.title = name;
      var jsname=caml_jsstring_of_string(name);
      if(s.set_title)s.set_title(jsname);
      return 0}
    function caml_get_global_data(){return caml_global_data}
    function caml_int64_shift_right_unsigned(x,s)
     {return x.shift_right_unsigned(s)}
    function caml_ba_uint8_get16(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      var b1=ba.get(ofs),b2=ba.get(ofs + 1);
      return b1 | b2 << 8}
    function caml_compare(a,b){return caml_compare_val(a,b,true)}
    function caml_fresh_oo_id(){return caml_oo_last_id++}
    function caml_int64_to_float(x){return x.toFloat()}
    function caml_ba_get_1(ba,i0){return ba.get(ba.offset(i0))}
    function caml_bigstring_memcmp(s1,pos1,s2,pos2,len)
     {for(var i=0;i < len;i++)
       {var a=caml_ba_get_1(s1,pos1 + i),b=caml_ba_get_1(s2,pos2 + i);
        if(a < b)return - 1;
        if(a > b)return 1}
      return 0}
    function caml_new_string(s){return caml_string_of_jsbytes(s)}
    function caml_ba_uint8_get32(ba,i0)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      var
       b1=ba.get(ofs + 0),
       b2=ba.get(ofs + 1),
       b3=ba.get(ofs + 2),
       b4=ba.get(ofs + 3);
      return b1 << 0 | b2 << 8 | b3 << 16 | b4 << 24}
    function caml_raw_backtrace_length(){return 0}
    function caml_obj_block(tag,size)
     {var o=new Array(size + 1);
      o[0] = tag;
      for(var i=1;i <= size;i++)o[i] = 0;
      return o}
    function caml_gr_clear_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = s.width;
      s.canvas.height = s.height;
      return 0}
    function bigstring_to_array_buffer(bs){return bs.data.buffer}
    function caml_sys_const_naked_pointers_checked(_unit){return 0}
    function lxor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] ^= nat2.data[ofs2];return 0}
    function caml_final_release(){return 0}
    function caml_js_to_array(a)
     {var len=a.length,b=new Array(len + 1);
      b[0] = 0;
      for(var i=0;i < len;i++)b[i + 1] = a[i];
      return b}
    function caml_gr_plot(x,y)
     {var
       s=caml_gr_state_get(),
       im=s.context.createImageData(1,1),
       d=im.data,
       color=s.color;
      d[0] = color >> 16 & 0xff;
      d[1] = color >> 8 & 0xff,d[2] = color >> 0 & 0xff;
      d[3] = 0xFF;
      s.x = x;
      s.y = y;
      s.context.putImageData(im,x,s.height - y);
      return 0}
    function caml_bytes_set64(s,i,i64)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=caml_int64_to_bytes(i64);
      for(var j=0;j < 8;j++)caml_bytes_unsafe_set(s,i + 7 - j,a[j]);
      return 0}
    function caml_bytes_set16(s,i,i16)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b2=0xFF & i16 >> 8,b1=0xFF & i16;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      return 0}
    function caml_string_set16(s,i,i16){return caml_bytes_set16(s,i,i16)}
    function caml_int64_bswap(x)
     {var y=caml_int64_to_bytes(x);
      return caml_int64_of_bytes([y[7],y[6],y[5],y[4],y[3],y[2],y[1],y[0]])}
    function caml_fill_bytes(s,i,l,c)
     {if(l > 0)
       if(i == 0 && (l >= s.l || s.t == 2 && l >= s.c.length))
        if(c == 0)
         {s.c = "";s.t = 2}
        else
         {s.c = caml_str_repeat(l,String.fromCharCode(c));s.t = l == s.l?0:2}
       else
        {if(s.t != 4)caml_convert_bytes_to_array(s);
         for(l += i;i < l;i++)s.c[i] = c}
      return 0}
    var caml_fill_string=caml_fill_bytes;
    function caml_gc_major(){return 0}
    function caml_lex_array(s)
     {s = caml_jsbytes_of_string(s);
      var l=s.length / 2,a=new Array(l);
      for(var i=0;i < l;i++)
       a[i]
       =
       (s.charCodeAt(2 * i) | s.charCodeAt(2 * i + 1) << 8)
       <<
       16
       >>
       16;
      return a}
    function caml_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)return - base - 1;
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         if(c == 256)lexbuf[lex_eof_reached] = 0}}
    function caml_sys_file_exists(name)
     {var root=resolve_fs_device(name);return root.device.exists(root.rest)}
    function caml_convert_raw_backtrace_slot()
     {caml_failwith("caml_convert_raw_backtrace_slot")}
    function caml_array_sub(a,i,len)
     {var a2=new Array(len + 1);
      a2[0] = 0;
      for(var i2=1,i1=i + 1;i2 <= len;i2++,i1++)a2[i2] = a[i1];
      return a2}
    function caml_bytes_equal(s1,s2)
     {if(s1 === s2)return 1;
      s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c == s2.c?1:0}
    function caml_gr_size_x(){var s=caml_gr_state_get();return s.width}
    function caml_ml_debug_info_status(){return 0}
    function caml_sys_const_ostype_cygwin(){return 0}
    function caml_cosh_float(x){return (Math.exp(x) + Math.exp(- x)) / 2}
    var caml_ephe_key_offset=3;
    function caml_weak_check(x,i)
     {return x[caml_ephe_key_offset + i]
              !==
              undefined
              &&
              x[caml_ephe_key_offset + i]
              !==
              0
              ?1
              :0}
    var caml_ephe_check_key=caml_weak_check;
    function caml_hash_mix_final(h)
     {h ^= h >>> 16;
      h = caml_mul(h,0x85ebca6b | 0);
      h ^= h >>> 13;
      h = caml_mul(h,0xc2b2ae35 | 0);
      h ^= h >>> 16;
      return h}
    function caml_gr_text_size(txt)
     {var
       s=caml_gr_state_get(),
       w=s.context.measureText(caml_jsstring_of_string(txt)).width;
      return [0,w,s.text_size]}
    function caml_lex_run_mem(s,i,mem,curr_pos)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)
         mem[dst + 1] = curr_pos;
        else
         mem[dst + 1] = mem[src + 1]}}
    function caml_lex_run_tag(s,i,mem)
     {for(;;)
       {var dst=s.charCodeAt(i);
        i++;
        if(dst == 0xff)return;
        var src=s.charCodeAt(i);
        i++;
        if(src == 0xff)mem[dst + 1] = - 1;else mem[dst + 1] = mem[src + 1]}}
    function caml_new_lex_engine(tbl,start_state,lexbuf)
     {var
       lex_buffer=2,
       lex_buffer_len=3,
       lex_start_pos=5,
       lex_curr_pos=6,
       lex_last_pos=7,
       lex_last_action=8,
       lex_eof_reached=9,
       lex_mem=10,
       lex_base=1,
       lex_backtrk=2,
       lex_default=3,
       lex_trans=4,
       lex_check=5,
       lex_base_code=6,
       lex_backtrk_code=7,
       lex_default_code=8,
       lex_trans_code=9,
       lex_check_code=10,
       lex_code=11;
      if(! tbl.lex_default)
       {tbl.lex_base = caml_lex_array(tbl[lex_base]);
        tbl.lex_backtrk = caml_lex_array(tbl[lex_backtrk]);
        tbl.lex_check = caml_lex_array(tbl[lex_check]);
        tbl.lex_trans = caml_lex_array(tbl[lex_trans]);
        tbl.lex_default = caml_lex_array(tbl[lex_default])}
      if(! tbl.lex_default_code)
       {tbl.lex_base_code = caml_lex_array(tbl[lex_base_code]);
        tbl.lex_backtrk_code = caml_lex_array(tbl[lex_backtrk_code]);
        tbl.lex_check_code = caml_lex_array(tbl[lex_check_code]);
        tbl.lex_trans_code = caml_lex_array(tbl[lex_trans_code]);
        tbl.lex_default_code = caml_lex_array(tbl[lex_default_code])}
      if(tbl.lex_code == null)
       tbl.lex_code = caml_jsbytes_of_string(tbl[lex_code]);
      var c,state=start_state,buffer=caml_array_of_bytes(lexbuf[lex_buffer]);
      if(state >= 0)
       {lexbuf[lex_last_pos] = lexbuf[lex_start_pos] = lexbuf[lex_curr_pos];
        lexbuf[lex_last_action] = - 1}
      else
       state = - state - 1;
      for(;;)
       {var base=tbl.lex_base[state];
        if(base < 0)
         {var pc_off=tbl.lex_base_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          return - base - 1}
        var backtrk=tbl.lex_backtrk[state];
        if(backtrk >= 0)
         {var pc_off=tbl.lex_backtrk_code[state];
          caml_lex_run_tag(tbl.lex_code,pc_off,lexbuf[lex_mem]);
          lexbuf[lex_last_pos] = lexbuf[lex_curr_pos];
          lexbuf[lex_last_action] = backtrk}
        if(lexbuf[lex_curr_pos] >= lexbuf[lex_buffer_len])
         if(lexbuf[lex_eof_reached] == 0)return - state - 1;else c = 256;
        else
         {c = buffer[lexbuf[lex_curr_pos]];lexbuf[lex_curr_pos]++}
        var pstate=state;
        if(tbl.lex_check[base + c] == state)
         state = tbl.lex_trans[base + c];
        else
         state = tbl.lex_default[state];
        if(state < 0)
         {lexbuf[lex_curr_pos] = lexbuf[lex_last_pos];
          if(lexbuf[lex_last_action] == - 1)
           caml_failwith("lexing: empty token");
          else
           return lexbuf[lex_last_action]}
        else
         {var base_code=tbl.lex_base_code[pstate],pc_off;
          if(tbl.lex_check_code[base_code + c] == pstate)
           pc_off = tbl.lex_trans_code[base_code + c];
          else
           pc_off = tbl.lex_default_code[pstate];
          if(pc_off > 0)
           caml_lex_run_mem
            (tbl.lex_code,pc_off,lexbuf[lex_mem],lexbuf[lex_curr_pos]);
          if(c == 256)lexbuf[lex_eof_reached] = 0}}}
    function caml_ba_uint8_set64(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 7 >= ba.data.length)caml_array_bound_error();
      var v=caml_int64_to_bytes(v);
      for(var i=0;i < 8;i++)ba.set(ofs + i,v[7 - i]);
      return 0}
    function caml_sys_executable_name(a){return caml_executable_name}
    function caml_lessequal(x,y){return + (caml_compare_val(x,y,false) <= 0)}
    function caml_ml_flush(chanid)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)caml_raise_sys_error("Cannot flush a closed channel");
      if(! chan.buffer || chan.buffer == "")return 0;
      if
       (chan.fd
        &&
        caml_global_data.fds[chan.fd]
        &&
        caml_global_data.fds[chan.fd].output)
       {var output=caml_global_data.fds[chan.fd].output;
        switch(output.length)
         {case 2:output(chanid,chan.buffer);break;default:output(chan.buffer)}}
      chan.buffer = "";
      return 0}
    function caml_ml_seek_out_64(chanid,pos)
     {caml_ml_flush(chanid);
      caml_ml_channels[chanid].offset = caml_int64_to_float(pos);
      return 0}
    function compare_nat_real(nat1,nat2)
     {return compare_nat(nat1,0,nat1.data.length,nat2,0,nat2.data.length)}
    function caml_gc_set(_control){return 0}
    function caml_js_get(o,f){return o[f]}
    function caml_gc_compaction(){return 0}
    function caml_weak_get(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_key");
      return x[caml_ephe_key_offset + i] === undefined
              ?0
              :x[caml_ephe_key_offset + i]}
    var caml_ephe_get_key=caml_weak_get;
    function caml_bigstring_blit_bytes_to_ba(str1,pos1,ba2,pos2,len)
     {if(12 != ba2.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs2=ba2.offset(pos2);
      if(pos1 + len > caml_ml_bytes_length(str1))caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=caml_array_of_bytes(str1).slice(pos1,pos1 + len);
      ba2.data.set(slice,ofs2);
      return 0}
    function win_cleanup(){}
    function caml_sys_close(fd){delete caml_global_data.fds[fd];return 0}
    function caml_ml_close_channel(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_flush(chanid);
      chan.opened = false;
      chan.file.close();
      caml_sys_close(chan.fd);
      return 0}
    function caml_exn_with_js_backtrace(exn,force)
     {if(! exn.js_error || force || exn[0] == 248)
       exn.js_error
       =
       new (joo_global_object.Error)("Js exception containing backtrace");
      return exn}
    function caml_sys_isatty(_chan){return 0}
    function is_digit_zero(nat,ofs){if(nat.data[ofs] == 0)return 1;return 0}
    function unix_inet_addr_of_string(){return 0}
    function caml_js_set(o,f,v){o[f] = v;return 0}
    function caml_array_get(array,index)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      return array[index + 1]}
    function caml_spacetime_only_works_for_native_code()
     {caml_failwith("Spacetime profiling only works for native code")}
    function caml_int64_sub(x,y){return x.sub(y)}
    function caml_ml_seek_in_64(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = caml_int64_to_float(pos);
      return 0}
    function caml_int64_shift_left(x,s){return x.shift_left(s)}
    function caml_notequal(x,y){return + (caml_compare_val(x,y,false) != 0)}
    function caml_sys_const_int_size(){return 32}
    function caml_js_wrap_meth_callback(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_is_js(){return 1}
    function caml_ba_dim(ba,i)
     {if(i < 0 || i >= ba.dims.length)caml_invalid_argument("Bigarray.dim");
      return ba.dims[i]}
    function caml_ba_dim_1(ba){return caml_ba_dim(ba,0)}
    function unix_localtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(d.getFullYear(),0,1).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000),
       jan=new Date(d.getFullYear(),0,1),
       jul=new Date(d.getFullYear(),6,1),
       stdTimezoneOffset=
        Math.max(jan.getTimezoneOffset(),jul.getTimezoneOffset());
      return [0,
              d.getSeconds(),
              d.getMinutes(),
              d.getHours(),
              d.getDate(),
              d.getMonth(),
              d.getFullYear() - 1900,
              d.getDay(),
              doy,
              d.getTimezoneOffset() < stdTimezoneOffset | 0]}
    function caml_js_meth_call(o,f,args)
     {return o[caml_jsstring_of_string(f)].apply(o,caml_js_from_array(args))}
    function caml_weak_create(n)
     {if(n < 0)caml_invalid_argument("Weak.create");
      var x=[251,"caml_ephe_list_head"];
      x.length = caml_ephe_key_offset + n;
      return x}
    var caml_ephe_create=caml_weak_create;
    function caml_js_to_byte_string(s){return caml_string_of_jsbytes(s)}
    function unix_mktime(tm)
     {var
       d=new Date(tm[6] + 1900,tm[5],tm[4],tm[3],tm[2],tm[1]).getTime(),
       t=Math.floor(d / 1000),
       tm2=unix_localtime(t);
      return [0,t,tm2]}
    function caml_trampoline(res)
     {var c=1;
      while(res && res.joo_tramp)
       {res = res.joo_tramp.apply(null,res.joo_args);c++}
      return res}
    function caml_bytes_get64(s,i)
     {if(i >>> 0 >= s.l - 7)caml_bytes_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_bytes_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_weak_set(x,i,v)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.set");
      x[caml_ephe_key_offset + i] = v;
      return 0}
    function caml_sys_remove(name)
     {var root=resolve_fs_device(name),ok=root.device.unlink(root.rest);
      if(ok == 0)caml_raise_no_such_file(name);
      return 0}
    function caml_string_bound_error()
     {caml_invalid_argument("index out of bounds")}
    function caml_string_get32(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 3)caml_string_bound_error();
      var
       b1=caml_string_unsafe_get(s,i),
       b2=caml_string_unsafe_get(s,i + 1),
       b3=caml_string_unsafe_get(s,i + 2),
       b4=caml_string_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_hypot_float(x,y)
     {var
       x=Math.abs(x),
       y=Math.abs(y),
       a=Math.max(x,y),
       b=Math.min(x,y) / (a?a:1);
      return a * Math.sqrt(1 + b * b)}
    function caml_js_call(f,o,args)
     {return f.apply(o,caml_js_from_array(args))}
    function caml_sys_const_max_wosize(){return 0x7FFFFFFF / 4 | 0}
    function caml_ephe_unset_key(x,i){return caml_weak_set(x,i,0)}
    function caml_hash_mix_bytes_arr(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w = s[i] | s[i + 1] << 8 | s[i + 2] << 16 | s[i + 3] << 24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s[i + 2] << 16;
        case 2:w |= s[i + 1] << 8;
        case 1:w |= s[i];h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_jsbytes(h,s)
     {var len=s.length,i,w;
      for(i = 0;i + 4 <= len;i += 4)
       {w
        =
        s.charCodeAt(i)
        |
        s.charCodeAt(i + 1)
        <<
        8
        |
        s.charCodeAt(i + 2)
        <<
        16
        |
        s.charCodeAt(i + 3)
        <<
        24;
        h = caml_hash_mix_int(h,w)}
      w = 0;
      switch(len & 3)
       {case 3:w = s.charCodeAt(i + 2) << 16;
        case 2:w |= s.charCodeAt(i + 1) << 8;
        case 1:w |= s.charCodeAt(i);h = caml_hash_mix_int(h,w)
        }
      h ^= len;
      return h}
    function caml_hash_mix_bytes(h,v)
     {switch(v.t & 6)
       {default:caml_convert_string_to_bytes(v);case 0:
         h = caml_hash_mix_jsbytes(h,v.c);break;
        case 2:h = caml_hash_mix_bytes_arr(h,v.c)
        }
      return h}
    function caml_bytes_lessthan(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c < s2.c?1:0}
    function caml_gr_fill_poly(ar)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(ar[1][1],s.height - ar[1][2]);
      for(var i=2;i < ar.length;i++)
       s.context.lineTo(ar[i][1],s.height - ar[i][2]);
      s.context.lineTo(ar[1][1],s.height - ar[1][2]);
      s.context.fill();
      return 0}
    function caml_gc_quick_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_raise_end_of_file()
     {caml_raise_constant(caml_global_data.End_of_file)}
    function caml_ml_input_int(chanid)
     {var chan=caml_ml_channels[chanid],file=chan.file;
      while(chan.offset + 3 >= file.length())
       {var l=caml_ml_refill_input(chan);if(l == 0)caml_raise_end_of_file()}
      var
       o=chan.offset,
       r=
        file.read_one(o)
        <<
        24
        |
        file.read_one(o + 1)
        <<
        16
        |
        file.read_one(o + 2)
        <<
        8
        |
        file.read_one(o + 3);
      chan.offset += 4;
      return r}
    function caml_gr_display_mode()
     {caml_failwith("caml_gr_display_mode not Implemented")}
    function nth_digit_nat(nat,ofs){return nat.data[ofs]}
    function caml_array_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_float_of_string(s)
     {var res;
      s = caml_jsbytes_of_string(s);
      res = + s;
      if(s.length > 0 && res === res)return res;
      s = s.replace(/_/g,"");
      res = + s;
      if(s.length > 0 && res === res || /^[+-]?nan$/i.test(s))return res;
      var m=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(s);
      if(m)
       {var
         m3=m[3].replace(/0+$/,""),
         mantissa=parseInt(m[1] + m[2] + m3,16),
         exponent=(m[4] | 0) - 4 * m3.length;
        res = mantissa * Math.pow(2,exponent);
        return res}
      if(/^\+?inf(inity)?$/i.test(s))return Infinity;
      if(/^-inf(inity)?$/i.test(s))return - Infinity;
      caml_failwith("float_of_string")}
    function caml_sys_getcwd()
     {return caml_string_of_jsbytes(caml_current_dir)}
    function caml_sys_const_big_endian(){return 0}
    function caml_list_to_js_array(l)
     {var a=[];for(;l !== 0;l = l[2])a.push(l[1]);return a}
    var
     caml_legacy_custom_code=false,
     caml_output_val=
      function()
        {function Writer(){this.chunk = []}
         Writer.prototype
         =
         {chunk_idx:20,
          block_len:0,
          obj_counter:0,
          size_32:0,
          size_64:0,
          write:
          function(size,value)
           {for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_at:
          function(pos,size,value)
           {var pos=pos;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[pos++] = value >> i & 0xFF},
          write_code:
          function(size,code,value)
           {this.chunk[this.chunk_idx++] = code;
            for(var i=size - 8;i >= 0;i -= 8)
             this.chunk[this.chunk_idx++] = value >> i & 0xFF},
          write_shared:
          function(offset)
           {if(offset < 1 << 8)
             this.write_code(8,0x04,offset);
            else
             if(offset < 1 << 16)
              this.write_code(16,0x05,offset);
             else
              this.write_code(32,0x06,offset)},
          pos:function(){return this.chunk_idx},
          finalize:
          function()
           {this.block_len = this.chunk_idx - 20;
            this.chunk_idx = 0;
            this.write(32,0x8495A6BE);
            this.write(32,this.block_len);
            this.write(32,this.obj_counter);
            this.write(32,this.size_32);
            this.write(32,this.size_64);
            return this.chunk}};
         return function(v,flags)
          {flags = caml_list_to_js_array(flags);
           var
            no_sharing=flags.indexOf(0) !== - 1,
            closures=flags.indexOf(1) !== - 1;
           if(closures)
            joo_global_object.console.warn
             ("in caml_output_val: flag Marshal.Closures is not supported.");
           var
            writer=new Writer(),
            stack=[],
            intern_obj_table=no_sharing?null:new MlObjectTable();
           function memo(v)
            {if(no_sharing)return false;
             var existing_offset=intern_obj_table.recall(v);
             if(existing_offset)
              {writer.write_shared(existing_offset);return true}
             else
              {intern_obj_table.store(v);return false}}
           function extern_rec(v)
            {if(v.caml_custom)
              {if(memo(v))return;
               var
                name=v.caml_custom,
                ops=caml_custom_ops[name],
                sz_32_64=[0,0];
               if(! ops.serialize)
                caml_invalid_argument("output_value: abstract value (Custom)");
               if(caml_legacy_custom_code)
                {writer.write(8,0x12);
                 for(var i=0;i < name.length;i++)
                  writer.write(8,name.charCodeAt(i));
                 writer.write(8,0);
                 ops.serialize(writer,v,sz_32_64)}
               else
                if(ops.fixed_length == undefined)
                 {writer.write(8,0x18);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var header_pos=writer.pos();
                  for(var i=0;i < 12;i++)writer.write(8,0);
                  ops.serialize(writer,v,sz_32_64);
                  writer.write_at(header_pos,32,sz_32_64[0]);
                  writer.write_at(header_pos + 4,32,0);
                  writer.write_at(header_pos + 8,32,sz_32_64[1])}
                else
                 {writer.write(8,0x19);
                  for(var i=0;i < name.length;i++)
                   writer.write(8,name.charCodeAt(i));
                  writer.write(8,0);
                  var old_pos=writer.pos();
                  ops.serialize(writer,v,sz_32_64);
                  if(ops.fixed_length != writer.pos() - old_pos)
                   caml_failwith
                    ("output_value: incorrect fixed sizes specified by " + name)}
               writer.size_32 += 2 + (sz_32_64[0] + 3 >> 2);
               writer.size_64 += 2 + (sz_32_64[1] + 7 >> 3)}
             else
              if(v instanceof Array && v[0] === (v[0] | 0))
               {if(v[0] == 251)
                 caml_failwith("output_value: abstract value (Abstract)");
                if(v.length > 1 && memo(v))return;
                if(v[0] < 16 && v.length - 1 < 8)
                 writer.write(8,0x80 + v[0] + (v.length - 1 << 4));
                else
                 writer.write_code(32,0x08,v.length - 1 << 10 | v[0]);
                writer.size_32 += v.length;
                writer.size_64 += v.length;
                if(v.length > 1)stack.push(v,1)}
              else
               if(caml_is_ml_bytes(v))
                {if(! caml_is_ml_bytes(caml_string_of_jsbytes("")))
                  caml_failwith
                   ("output_value: [Bytes.t] cannot safely be marshaled with [--enable use-js-string]");
                 if(memo(v))return;
                 var len=caml_ml_bytes_length(v);
                 if(len < 0x20)
                  writer.write(8,0x20 + len);
                 else
                  if(len < 0x100)
                   writer.write_code(8,0x09,len);
                  else
                   writer.write_code(32,0x0A,len);
                 for(var i=0;i < len;i++)
                  writer.write(8,caml_bytes_unsafe_get(v,i));
                 writer.size_32 += 1 + ((len + 4) / 4 | 0);
                 writer.size_64 += 1 + ((len + 8) / 8 | 0)}
               else
                if(caml_is_ml_string(v))
                 {var len=caml_ml_string_length(v);
                  if(len < 0x20)
                   writer.write(8,0x20 + len);
                  else
                   if(len < 0x100)
                    writer.write_code(8,0x09,len);
                   else
                    writer.write_code(32,0x0A,len);
                  for(var i=0;i < len;i++)
                   writer.write(8,caml_string_unsafe_get(v,i));
                  writer.size_32 += 1 + ((len + 4) / 4 | 0);
                  writer.size_64 += 1 + ((len + 8) / 8 | 0)}
                else
                 if(v != (v | 0))
                  {var type_of_v=typeof v;
                   caml_failwith
                    ("output_value: abstract value (" + type_of_v + ")")}
                 else
                  if(v >= 0 && v < 0x40)
                   writer.write(8,0X40 + v);
                  else
                   if(v >= - (1 << 7) && v < 1 << 7)
                    writer.write_code(8,0x00,v);
                   else
                    if(v >= - (1 << 15) && v < 1 << 15)
                     writer.write_code(16,0x01,v);
                    else
                     writer.write_code(32,0x02,v)}
           extern_rec(v);
           while(stack.length > 0)
            {var i=stack.pop(),v=stack.pop();
             if(i + 1 < v.length)stack.push(v,i + 1);
             extern_rec(v[i])}
           if(intern_obj_table)
            writer.obj_counter = intern_obj_table.objs.length;
           writer.finalize();
           return writer.chunk}}
       ();
    function caml_string_of_array(a)
     {return caml_string_of_jsbytes(caml_subarray_to_jsbytes(a,0,a.length))}
    function caml_output_value_to_string(v,flags)
     {return caml_string_of_array(caml_output_val(v,flags))}
    function caml_raise_not_a_dir(name)
     {name = caml_jsbytes_of_string(name);
      caml_raise_sys_error(name + ": Not a directory")}
    function caml_sys_system_command(cmd)
     {var cmd=caml_jsstring_of_string(cmd);
      if
       (typeof require
        !=
        "undefined"
        &&
        require("child_process")
        &&
        require("child_process").execSync)
       try
        {require("child_process").execSync(cmd,{stdio:"inherit"});return 0}
       catch(e){return 1}
      else
       return 127}
    function unix_isatty(fileDescriptor)
     {if(fs_node_supported())
       {var tty=require("tty");return tty.isatty(fileDescriptor)}
      else
       return false}
    function caml_js_error_of_exception(exn)
     {if(exn.js_error)return exn.js_error;return null}
    function deserialize_nat(reader,sz)
     {var len=reader.read32s(),nat=new MlNat(len);
      for(var i=0;i < len;i++)nat.data[i] = reader.read32s();
      sz[0] = len * 4;
      return nat}
    function initialize_nat()
     {caml_custom_ops["_nat"]
      =
      {deserialize:deserialize_nat,serialize:serialize_nat,hash:caml_hash_nat}}
    function caml_gr_open_subwindow(a,b,c,d)
     {caml_failwith("caml_gr_open_subwindow not Implemented")}
    function js_print_stdout(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stdout.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.log && v.log(s)}}
    function caml_copysign_float(x,y)
     {if(y == 0)y = 1 / y;x = Math.abs(x);return y < 0?- x:x}
    function caml_gr_set_text_size(size)
     {var s=caml_gr_state_get();
      s.text_size = size;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    var
     caml_md5_bytes=
      function()
        {function add(x,y){return x + y | 0}
         function xx(q,a,b,x,s,t)
          {a = add(add(a,q),add(x,t));return add(a << s | a >>> 32 - s,b)}
         function ff(a,b,c,d,x,s,t){return xx(b & c | ~ b & d,a,b,x,s,t)}
         function gg(a,b,c,d,x,s,t){return xx(b & d | c & ~ d,a,b,x,s,t)}
         function hh(a,b,c,d,x,s,t){return xx(b ^ c ^ d,a,b,x,s,t)}
         function ii(a,b,c,d,x,s,t){return xx(c ^ (b | ~ d),a,b,x,s,t)}
         function md5(buffer,length)
          {var i=length;
           buffer[i >> 2] |= 0x80 << 8 * (i & 3);
           for(i = (i & ~ 0x3) + 8;(i & 0x3F) < 60;i += 4)
            buffer[(i >> 2) - 1] = 0;
           buffer[(i >> 2) - 1] = length << 3;
           buffer[i >> 2] = length >> 29 & 0x1FFFFFFF;
           var w=[0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476];
           for(i = 0;i < buffer.length;i += 16)
            {var a=w[0],b=w[1],c=w[2],d=w[3];
             a = ff(a,b,c,d,buffer[i + 0],7,0xD76AA478);
             d = ff(d,a,b,c,buffer[i + 1],12,0xE8C7B756);
             c = ff(c,d,a,b,buffer[i + 2],17,0x242070DB);
             b = ff(b,c,d,a,buffer[i + 3],22,0xC1BDCEEE);
             a = ff(a,b,c,d,buffer[i + 4],7,0xF57C0FAF);
             d = ff(d,a,b,c,buffer[i + 5],12,0x4787C62A);
             c = ff(c,d,a,b,buffer[i + 6],17,0xA8304613);
             b = ff(b,c,d,a,buffer[i + 7],22,0xFD469501);
             a = ff(a,b,c,d,buffer[i + 8],7,0x698098D8);
             d = ff(d,a,b,c,buffer[i + 9],12,0x8B44F7AF);
             c = ff(c,d,a,b,buffer[i + 10],17,0xFFFF5BB1);
             b = ff(b,c,d,a,buffer[i + 11],22,0x895CD7BE);
             a = ff(a,b,c,d,buffer[i + 12],7,0x6B901122);
             d = ff(d,a,b,c,buffer[i + 13],12,0xFD987193);
             c = ff(c,d,a,b,buffer[i + 14],17,0xA679438E);
             b = ff(b,c,d,a,buffer[i + 15],22,0x49B40821);
             a = gg(a,b,c,d,buffer[i + 1],5,0xF61E2562);
             d = gg(d,a,b,c,buffer[i + 6],9,0xC040B340);
             c = gg(c,d,a,b,buffer[i + 11],14,0x265E5A51);
             b = gg(b,c,d,a,buffer[i + 0],20,0xE9B6C7AA);
             a = gg(a,b,c,d,buffer[i + 5],5,0xD62F105D);
             d = gg(d,a,b,c,buffer[i + 10],9,0x02441453);
             c = gg(c,d,a,b,buffer[i + 15],14,0xD8A1E681);
             b = gg(b,c,d,a,buffer[i + 4],20,0xE7D3FBC8);
             a = gg(a,b,c,d,buffer[i + 9],5,0x21E1CDE6);
             d = gg(d,a,b,c,buffer[i + 14],9,0xC33707D6);
             c = gg(c,d,a,b,buffer[i + 3],14,0xF4D50D87);
             b = gg(b,c,d,a,buffer[i + 8],20,0x455A14ED);
             a = gg(a,b,c,d,buffer[i + 13],5,0xA9E3E905);
             d = gg(d,a,b,c,buffer[i + 2],9,0xFCEFA3F8);
             c = gg(c,d,a,b,buffer[i + 7],14,0x676F02D9);
             b = gg(b,c,d,a,buffer[i + 12],20,0x8D2A4C8A);
             a = hh(a,b,c,d,buffer[i + 5],4,0xFFFA3942);
             d = hh(d,a,b,c,buffer[i + 8],11,0x8771F681);
             c = hh(c,d,a,b,buffer[i + 11],16,0x6D9D6122);
             b = hh(b,c,d,a,buffer[i + 14],23,0xFDE5380C);
             a = hh(a,b,c,d,buffer[i + 1],4,0xA4BEEA44);
             d = hh(d,a,b,c,buffer[i + 4],11,0x4BDECFA9);
             c = hh(c,d,a,b,buffer[i + 7],16,0xF6BB4B60);
             b = hh(b,c,d,a,buffer[i + 10],23,0xBEBFBC70);
             a = hh(a,b,c,d,buffer[i + 13],4,0x289B7EC6);
             d = hh(d,a,b,c,buffer[i + 0],11,0xEAA127FA);
             c = hh(c,d,a,b,buffer[i + 3],16,0xD4EF3085);
             b = hh(b,c,d,a,buffer[i + 6],23,0x04881D05);
             a = hh(a,b,c,d,buffer[i + 9],4,0xD9D4D039);
             d = hh(d,a,b,c,buffer[i + 12],11,0xE6DB99E5);
             c = hh(c,d,a,b,buffer[i + 15],16,0x1FA27CF8);
             b = hh(b,c,d,a,buffer[i + 2],23,0xC4AC5665);
             a = ii(a,b,c,d,buffer[i + 0],6,0xF4292244);
             d = ii(d,a,b,c,buffer[i + 7],10,0x432AFF97);
             c = ii(c,d,a,b,buffer[i + 14],15,0xAB9423A7);
             b = ii(b,c,d,a,buffer[i + 5],21,0xFC93A039);
             a = ii(a,b,c,d,buffer[i + 12],6,0x655B59C3);
             d = ii(d,a,b,c,buffer[i + 3],10,0x8F0CCC92);
             c = ii(c,d,a,b,buffer[i + 10],15,0xFFEFF47D);
             b = ii(b,c,d,a,buffer[i + 1],21,0x85845DD1);
             a = ii(a,b,c,d,buffer[i + 8],6,0x6FA87E4F);
             d = ii(d,a,b,c,buffer[i + 15],10,0xFE2CE6E0);
             c = ii(c,d,a,b,buffer[i + 6],15,0xA3014314);
             b = ii(b,c,d,a,buffer[i + 13],21,0x4E0811A1);
             a = ii(a,b,c,d,buffer[i + 4],6,0xF7537E82);
             d = ii(d,a,b,c,buffer[i + 11],10,0xBD3AF235);
             c = ii(c,d,a,b,buffer[i + 2],15,0x2AD7D2BB);
             b = ii(b,c,d,a,buffer[i + 9],21,0xEB86D391);
             w[0] = add(a,w[0]);
             w[1] = add(b,w[1]);
             w[2] = add(c,w[2]);
             w[3] = add(d,w[3])}
           var t=new Array(16);
           for(var i=0;i < 4;i++)
            for(var j=0;j < 4;j++)t[i * 4 + j] = w[i] >> 8 * j & 0xFF;
           return t}
         return function(s,ofs,len)
          {var buf=[];
           switch(s.t & 6)
            {default:caml_convert_string_to_bytes(s);case 0:
              var b=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                b.charCodeAt(j)
                |
                b.charCodeAt(j + 1)
                <<
                8
                |
                b.charCodeAt(j + 2)
                <<
                16
                |
                b.charCodeAt(j + 3)
                <<
                24}
              for(;i < len;i++)
               buf[i >> 2] |= b.charCodeAt(i + ofs) << 8 * (i & 3);
              break;
             case 4:
              var a=s.c;
              for(var i=0;i < len;i += 4)
               {var j=i + ofs;
                buf[i >> 2]
                =
                a[j]
                |
                a[j + 1]
                <<
                8
                |
                a[j + 2]
                <<
                16
                |
                a[j + 3]
                <<
                24}
              for(;i < len;i++)buf[i >> 2] |= a[i + ofs] << 8 * (i & 3)
             }
           return caml_string_of_array(md5(buf,len))}}
       ();
    function caml_ba_set_generic(ba,i,v)
     {ba.set(ba.offset(caml_js_from_array(i)),v);return 0}
    function caml_ephe_set_key(x,i,v){return caml_weak_set(x,i,[0,v])}
    function caml_bytes_lessequal(s1,s2)
     {s1.t & 6 && caml_convert_string_to_bytes(s1);
      s2.t & 6 && caml_convert_string_to_bytes(s2);
      return s1.c <= s2.c?1:0}
    function caml_string_lessequal(s1,s2){return caml_bytes_lessequal(s1,s2)}
    function caml_string_greaterequal(s1,s2)
     {return caml_string_lessequal(s2,s1)}
    function caml_int64_add(x,y){return x.add(y)}
    function caml_nextafter_float(x,y)
     {if(isNaN(x) || isNaN(y))return NaN;
      if(x == y)return y;
      if(x == 0)return y < 0?- Math.pow(2,- 1074):Math.pow(2,- 1074);
      var bits=caml_int64_bits_of_float(x),one=caml_int64_of_int32(1);
      if(x < y == x > 0)
       bits = caml_int64_add(bits,one);
      else
       bits = caml_int64_sub(bits,one);
      return caml_int64_float_of_bits(bits)}
    function caml_gr_size_y(){var s=caml_gr_state_get();return s.height}
    function caml_ml_pos_in(chanid){return caml_ml_channels[chanid].offset}
    function caml_int64_and(x,y){return x.and(y)}
    function caml_sys_const_word_size(){return 32}
    function caml_std_output(chanid,s)
     {var
       chan=caml_ml_channels[chanid],
       str=caml_string_of_jsbytes(s),
       slen=caml_ml_string_length(str);
      chan.file.write(chan.offset,str,0,slen);
      chan.offset += slen;
      return 0}
    function js_print_stderr(s)
     {var s=caml_utf16_of_utf8(s),g=joo_global_object;
      if(g.process && g.process.stdout && g.process.stdout.write)
       g.process.stderr.write(s);
      else
       {if(s.charCodeAt(s.length - 1) == 10)s = s.substr(0,s.length - 1);
        var v=g.console;
        v && v.error && v.error(s)}}
    function caml_sys_open_internal(idx,output,file,flags)
     {if(caml_global_data.fds === undefined)
       caml_global_data.fds = new Array();
      flags = flags?flags:{};
      var info={};
      info.file = file;
      info.offset = flags.append?file.length():0;
      info.flags = flags;
      info.output = output;
      caml_global_data.fds[idx] = info;
      if(! caml_global_data.fd_last_idx || idx > caml_global_data.fd_last_idx)
       caml_global_data.fd_last_idx = idx;
      return idx}
    function caml_sys_open(name,flags,_perms)
     {var f={};
      while(flags)
       {switch(flags[1])
         {case 0:f.rdonly = 1;break;
          case 1:f.wronly = 1;break;
          case 2:f.append = 1;break;
          case 3:f.create = 1;break;
          case 4:f.truncate = 1;break;
          case 5:f.excl = 1;break;
          case 6:f.binary = 1;break;
          case 7:f.text = 1;break;
          case 8:f.nonblock = 1;break
          }
        flags = flags[2]}
      if(f.rdonly && f.wronly)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_rdonly and Open_wronly are not compatible");
      if(f.text && f.binary)
       caml_raise_sys_error
        (caml_jsbytes_of_string(name)
         +
         " : flags Open_text and Open_binary are not compatible");
      var
       root=resolve_fs_device(name),
       file=root.device.open(root.rest,f),
       idx=caml_global_data.fd_last_idx?caml_global_data.fd_last_idx:0;
      return caml_sys_open_internal(idx + 1,caml_std_output,file,f)}
    caml_sys_open_internal
     (0,caml_std_output,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (1,js_print_stdout,new MlFakeFile(caml_create_bytes(0)));
    caml_sys_open_internal
     (2,js_print_stderr,new MlFakeFile(caml_create_bytes(0)));
    function MlStringReader(s,i)
     {this.s = caml_jsbytes_of_string(s);this.i = i}
    MlStringReader.prototype
    =
    {read8u:function(){return this.s.charCodeAt(this.i++)},
     read8s:function(){return this.s.charCodeAt(this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 8 | s.charCodeAt(i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return s.charCodeAt(i) << 24 >> 16 | s.charCodeAt(i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (s.charCodeAt(i)
               <<
               24
               |
               s.charCodeAt(i + 1)
               <<
               16
               |
               s.charCodeAt(i + 2)
               <<
               8
               |
               s.charCodeAt(i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return s.charCodeAt(i)
              <<
              24
              |
              s.charCodeAt(i + 1)
              <<
              16
              |
              s.charCodeAt(i + 2)
              <<
              8
              |
              s.charCodeAt(i + 3)},
     readstr:
     function(len)
      {var i=this.i;
       this.i = i + len;
       return caml_string_of_jsbytes(this.s.substring(i,i + len))}};
    function caml_float_of_bytes(a)
     {return caml_int64_float_of_bits(caml_int64_of_bytes(a))}
    function caml_input_value_from_reader(reader,ofs)
     {var
       _magic=reader.read32u(),
       _block_len=reader.read32u(),
       num_objects=reader.read32u(),
       _size_32=reader.read32u(),
       _size_64=reader.read32u(),
       stack=[],
       intern_obj_table=num_objects > 0?[]:null,
       obj_counter=0;
      function intern_rec()
       {var code=reader.read8u();
        if(code >= 0x40)
         if(code >= 0x80)
          {var tag=code & 0xF,size=code >> 4 & 0x7,v=[tag];
           if(size == 0)return v;
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           stack.push(v,size);
           return v}
         else
          return code & 0x3F;
        else
         if(code >= 0x20)
          {var len=code & 0x1F,v=reader.readstr(len);
           if(intern_obj_table)intern_obj_table[obj_counter++] = v;
           return v}
         else
          switch(code)
           {case 0x00:return reader.read8s();
            case 0x01:return reader.read16s();
            case 0x02:return reader.read32s();
            case 0x03:caml_failwith("input_value: integer too large");break;
            case 0x04:
             var offset=reader.read8u();
             return intern_obj_table[obj_counter - offset];
            case 0x05:
             var offset=reader.read16u();
             return intern_obj_table[obj_counter - offset];
            case 0x06:
             var offset=reader.read32u();
             return intern_obj_table[obj_counter - offset];
            case 0x08:
             var
              header=reader.read32u(),
              tag=header & 0xFF,
              size=header >> 10,
              v=[tag];
             if(size == 0)return v;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             stack.push(v,size);
             return v;
            case 0x13:
             caml_failwith("input_value: data block too large");break;
            case 0x09:
             var len=reader.read8u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0A:
             var len=reader.read32u(),v=reader.readstr(len);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0C:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[7 - i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0B:
             var t=new Array(8);
             for(var i=0;i < 8;i++)t[i] = reader.read8u();
             var v=caml_float_of_bytes(t);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            case 0x0E:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0D:
             var len=reader.read8u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x07:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[7 - j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x0F:
             var len=reader.read32u(),v=new Array(len + 1);
             v[0] = 254;
             var t=new Array(8);
             for(var i=1;i <= len;i++)
              {for(var j=0;j < 8;j++)t[j] = reader.read8u();
               v[i] = caml_float_of_bytes(t)}
             return v;
            case 0x10:
            case 0x11:caml_failwith("input_value: code pointer");break;
            case 0x12:
            case 0x18:
            case 0x19:
             var c,s="";
             while((c = reader.read8u()) != 0)s += String.fromCharCode(c);
             var ops=caml_custom_ops[s],expected_size;
             if(! ops)
              caml_failwith("input_value: unknown custom block identifier");
             switch(code)
              {case 0x12:break;
               case 0x19:
                if(! ops.fixed_length)
                 caml_failwith
                  ("input_value: expected a fixed-size custom block");
                expected_size = ops.fixed_length;
                break;
               case 0x18:
                expected_size = reader.read32u();
                reader.read32s();
                reader.read32s();
                break
               }
             var old_pos=reader.i,size=[0],v=ops.deserialize(reader,size);
             if(expected_size != undefined)
              if(expected_size != size[0])
               caml_failwith
                ("input_value: incorrect length of serialized custom block");
             if(intern_obj_table)intern_obj_table[obj_counter++] = v;
             return v;
            default:caml_failwith("input_value: ill-formed message")}}
      var res=intern_rec();
      while(stack.length > 0)
       {var size=stack.pop(),v=stack.pop(),d=v.length;
        if(d < size)stack.push(v,size);
        v[d] = intern_rec()}
      if(typeof ofs != "number")ofs[0] = reader.i;
      return res}
    function caml_string_of_bytes(s){return s}
    function caml_input_value_from_bytes(s,ofs)
     {var
       reader=
        new
         MlStringReader
         (caml_string_of_bytes(s),typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_string_get(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s))caml_string_bound_error();
      return caml_string_unsafe_get(s,i)}
    var
     re_match=
      function()
        {var
          re_word_letters=
           [0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0x03,
            0xFE,
            0xFF,
            0xFF,
            0x87,
            0xFE,
            0xFF,
            0xFF,
            0x07,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0x00,
            0xFF,
            0xFF,
            0x7F,
            0xFF,
            0xFF,
            0xFF,
            0x7F,
            0xFF],
          opcodes=
           {CHAR:0,
            CHARNORM:1,
            STRING:2,
            STRINGNORM:3,
            CHARCLASS:4,
            BOL:5,
            EOL:6,
            WORDBOUNDARY:7,
            BEGGROUP:8,
            ENDGROUP:9,
            REFGROUP:10,
            ACCEPT:11,
            SIMPLEOPT:12,
            SIMPLESTAR:13,
            SIMPLEPLUS:14,
            GOTO:15,
            PUSHBACK:16,
            SETMARK:17,
            CHECKPROGRESS:18};
         function is_word_letter(c)
          {return re_word_letters[c >> 3] >> (c & 7) & 1}
         function in_bitset(s,i)
          {return caml_string_get(s,i >> 3) >> (i & 7) & 1}
         function re_match_impl(re,s,pos,partial)
          {var
            prog=caml_js_from_array(re[1]),
            cpool=caml_js_from_array(re[2]),
            normtable=caml_jsbytes_of_string(re[3]),
            numgroups=re[4] | 0,
            numregisters=re[5] | 0,
            startchars=re[6] | 0,
            s=caml_array_of_string(s),
            pc=0,
            quit=false,
            stack=[],
            groups=new Array(numgroups),
            re_register=new Array(numregisters);
           for(var i=0;i < groups.length;i++)groups[i] = {start:- 1,end:- 1};
           groups[0].start = pos;
           function backtrack()
            {while(stack.length)
              {var item=stack.pop();
               if(item.undo)
                item.undo.obj[item.undo.prop] = item.undo.value;
               else
                if(item.pos){pc = item.pos.pc;pos = item.pos.txt;return}}
             quit = true}
           function push(item){stack.push(item)}
           function accept()
            {groups[0].end = pos;
             var result=new Array(1 + groups.length * 2);
             result[0] = 0;
             for(var i=0;i < groups.length;i++)
              {var g=groups[i];
               if(g.start < 0 || g.end < 0)g.start = g.end = - 1;
               result[2 * i + 1] = g.start;
               result[2 * i + 1 + 1] = g.end}
             return result}
           function prefix_match()
            {if(partial)return accept();else backtrack()}
           while(! quit)
            {var
              op=prog[pc] & 0xff,
              sarg=prog[pc] >> 8,
              uarg=sarg & 0xff,
              c=s[pos],
              group;
             pc++;
             switch(op)
              {case opcodes.CHAR:
                if(pos === s.length){prefix_match();break}
                if(c === uarg)pos++;else backtrack();
                break;
               case opcodes.CHARNORM:
                if(pos === s.length){prefix_match();break}
                if(normtable.charCodeAt(c) === uarg)pos++;else backtrack();
                break;
               case opcodes.STRING:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(c === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.STRINGNORM:
                for
                 (var arg=caml_jsbytes_of_string(cpool[uarg]),i=0;
                  i
                  <
                  arg.length;
                  i++)
                 {if(pos === s.length){prefix_match();break}
                  if(normtable.charCodeAt(c) === arg.charCodeAt(i))
                   c = s[++pos];
                  else
                   {backtrack();break}}
                break;
               case opcodes.CHARCLASS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))pos++;else backtrack();
                break;
               case opcodes.BOL:
                if(pos > 0 && s[pos - 1] != 10)backtrack();break;
               case opcodes.EOL:
                if(pos < s.length && s[pos] != 10)backtrack();break;
               case opcodes.WORDBOUNDARY:
                if(pos == 0)
                 {if(pos === s.length){prefix_match();break}
                  if(is_word_letter(s[0]))break;
                  backtrack()}
                else
                 if(pos === s.length)
                  {if(is_word_letter(s[pos - 1]))break;backtrack()}
                 else
                  {if(is_word_letter(s[pos - 1]) != is_word_letter(s[pos]))
                    break;
                   backtrack()}
                break;
               case opcodes.BEGGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"start",value:group.start}});
                group.start = pos;
                break;
               case opcodes.ENDGROUP:
                group = groups[uarg];
                push({undo:{obj:group,prop:"end",value:group.end}});
                group.end = pos;
                break;
               case opcodes.REFGROUP:
                group = groups[uarg];
                if(group.start < 0 || group.end < 0){backtrack();break}
                for(var i=group.start;i < group.end;i++)
                 {if(pos === s.length){prefix_match();break}
                  if(s[i] != s[pos]){backtrack();break}
                  pos++}
                break;
               case opcodes.SIMPLEOPT:if(in_bitset(cpool[uarg],c))pos++;break;
               case opcodes.SIMPLESTAR:
                while(in_bitset(cpool[uarg],c))c = s[++pos];break;
               case opcodes.SIMPLEPLUS:
                if(pos === s.length){prefix_match();break}
                if(in_bitset(cpool[uarg],c))
                 do c = s[++pos];while(in_bitset(cpool[uarg],c));
                else
                 backtrack();
                break;
               case opcodes.ACCEPT:return accept();
               case opcodes.GOTO:pc = pc + sarg;break;
               case opcodes.PUSHBACK:push({pos:{pc:pc + sarg,txt:pos}});break;
               case opcodes.SETMARK:
                push
                 ({undo:{obj:re_register,prop:uarg,value:re_register[uarg]}});
                re_register[uarg] = pos;
                break;
               case opcodes.CHECKPROGRESS:
                if(re_register[uarg] === pos)backtrack();break;
               default:throw new Error("Invalid bytecode")}}
           return 0}
         return re_match_impl}
       ();
    function re_search_backward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_backward");
      while(pos >= 0){var res=re_match(re,s,pos,0);if(res)return res;pos--}
      return [0]}
    function caml_js_from_string(s){return caml_jsstring_of_string(s)}
    function caml_ba_sub(ba,ofs,len)
     {var changed_dim,mul=1;
      if(ba.layout == 0)
       {for(var i=1;i < ba.dims.length;i++)mul = mul * ba.dims[i];
        changed_dim = 0}
      else
       {for(var i=0;i < ba.dims.length - 1;i++)mul = mul * ba.dims[i];
        changed_dim = ba.dims.length - 1;
        ofs = ofs - 1}
      if(ofs < 0 || len < 0 || ofs + len > ba.dims[changed_dim])
       caml_invalid_argument("Bigarray.sub: bad sub-array");
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)new_dims[i] = ba.dims[i];
      new_dims[changed_dim] = len;
      mul *= caml_ba_get_size_per_element(ba.kind);
      var new_data=ba.data.subarray(ofs * mul,(ofs + len) * mul);
      return caml_ba_create_unsafe(ba.kind,ba.layout,new_dims,new_data)}
    function caml_gc_full_major(){return 0}
    function caml_bytes_set32(s,i,i32)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b4=0xFF & i32 >> 24,
       b3=0xFF & i32 >> 16,
       b2=0xFF & i32 >> 8,
       b1=0xFF & i32;
      caml_bytes_unsafe_set(s,i + 0,b1);
      caml_bytes_unsafe_set(s,i + 1,b2);
      caml_bytes_unsafe_set(s,i + 2,b3);
      caml_bytes_unsafe_set(s,i + 3,b4);
      return 0}
    function caml_gr_sigio_signal(){return 0}
    function caml_ba_uint8_set32(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 3 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      ba.set(ofs + 2,v >>> 16 & 0xff);
      ba.set(ofs + 3,v >>> 24 & 0xff);
      return 0}
    function caml_sys_const_ostype_unix(){return 1}
    function caml_signbit_float(x){if(x == 0)x = 1 / x;return x < 0?1:0}
    function caml_gr_current_x(){var s=caml_gr_state_get();return s.x}
    function caml_gr_set_line_width(w)
     {var s=caml_gr_state_get();
      s.line_width = w;
      s.context.lineWidth = w;
      return 0}
    function caml_gr_set_font(f)
     {var s=caml_gr_state_get();
      s.font = f;
      s.context.font = s.text_size + "px " + caml_jsstring_of_string(s.font);
      return 0}
    function caml_gr_set_color(color)
     {var s=caml_gr_state_get();
      function convert(number)
       {var str="" + number.toString(16);
        while(str.length < 2)str = "0" + str;
        return str}
      var r=color >> 16 & 0xff,g=color >> 8 & 0xff,b=color >> 0 & 0xff;
      s.color = color;
      var c_str="#" + convert(r) + convert(g) + convert(b);
      s.context.fillStyle = c_str;
      s.context.strokeStyle = c_str;
      return 0}
    function caml_gr_moveto(x,y)
     {var s=caml_gr_state_get();s.x = x;s.y = y;return 0}
    function caml_gr_resize_window(w,h)
     {var s=caml_gr_state_get();
      s.width = w;
      s.height = h;
      s.canvas.width = w;
      s.canvas.height = h;
      return 0}
    function caml_gr_state_init()
     {caml_gr_moveto(caml_gr_state.x,caml_gr_state.y);
      caml_gr_resize_window(caml_gr_state.width,caml_gr_state.height);
      caml_gr_set_line_width(caml_gr_state.line_width);
      caml_gr_set_text_size(caml_gr_state.text_size);
      caml_gr_set_font(caml_gr_state.font);
      caml_gr_set_color(caml_gr_state.color);
      caml_gr_set_window_title(caml_gr_state.title);
      caml_gr_state.context.textBaseline = "bottom"}
    function caml_ba_kind_of_typed_array(ta)
     {var g=joo_global_object,kind;
      if(ta instanceof g.Float32Array)
       kind = 0;
      else
       if(ta instanceof g.Float64Array)
        kind = 1;
       else
        if(ta instanceof g.Int8Array)
         kind = 2;
        else
         if(ta instanceof g.Uint8Array)
          kind = 3;
         else
          if(ta instanceof g.Int16Array)
           kind = 4;
          else
           if(ta instanceof g.Uint16Array)
            kind = 5;
           else
            if(ta instanceof g.Int32Array)
             kind = 6;
            else
             if(ta instanceof g.Uint32Array)
              kind = 6;
             else
              caml_invalid_argument
               ("caml_ba_kind_of_typed_array: unsupported kind");
      return kind}
    function caml_ba_from_typed_array(ta)
     {var kind=caml_ba_kind_of_typed_array(ta);
      return caml_ba_create_unsafe(kind,0,[ta.length],ta)}
    function caml_ml_seek_out(chanid,pos)
     {caml_ml_flush(chanid);caml_ml_channels[chanid].offset = pos;return 0}
    function caml_js_typeof(o){return typeof o}
    function caml_restore_raw_backtrace(exn,bt){return 0}
    function caml_gr_lineto(x,y)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      s.context.moveTo(s.x,s.height - s.y);
      s.context.lineTo(x,s.height - y);
      s.context.stroke();
      s.x = x;
      s.y = y;
      return 0}
    function caml_js_wrap_meth_callback_unsafe(f)
     {return function()
       {var len=arguments.length,args=new Array(len + 1);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return f.apply(null,args)}}
    function caml_ba_dim_3(ba){return caml_ba_dim(ba,2)}
    var caml_ephe_data_offset=2;
    function caml_ephe_check_data(x)
     {return x[caml_ephe_data_offset] === undefined?0:1}
    function caml_bytes_get16(s,i)
     {if(i >>> 0 >= s.l - 1)caml_bytes_bound_error();
      var b1=caml_bytes_unsafe_get(s,i),b2=caml_bytes_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_obj_make_forward(b,v){b[0] = 250;b[1] = v;return 0}
    function caml_js_from_bool(x){return ! ! x}
    function caml_ml_set_channel_name(){return 0}
    function caml_gr_close_graph()
     {var s=caml_gr_state_get();
      s.canvas.width = 0;
      s.canvas.height = 0;
      return 0}
    function caml_create_string(len)
     {if(len < 0)caml_invalid_argument("String.create");
      return new MlBytes(len?2:9,"",len)}
    function caml_md5_string(s,ofs,len)
     {return caml_md5_bytes(caml_bytes_of_string(s),ofs,len)}
    function caml_md5_chan(chanid,len)
     {var chan=caml_ml_channels[chanid],chan_len=chan.file.length();
      if(len < 0)len = chan_len - chan.offset;
      if(chan.offset + len > chan_len)caml_raise_end_of_file();
      var buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      return caml_md5_string(caml_string_of_bytes(buf),0,len)}
    function caml_obj_dup(x)
     {var l=x.length,a=new Array(l);
      for(var i=0;i < l;i++)a[i] = x[i];
      return a}
    function caml_weak_get_copy(x,i)
     {if(i < 0 || caml_ephe_key_offset + i >= x.length)
       caml_invalid_argument("Weak.get_copy");
      var y=caml_weak_get(x,i);
      if(y === 0)return y;
      var z=y[1];
      if(z instanceof Array)return [0,caml_obj_dup(z)];
      return y}
    function caml_ml_output_bytes(chanid,buffer,offset,len)
     {var chan=caml_ml_channels[chanid];
      if(! chan.opened)
       caml_raise_sys_error("Cannot output to a closed channel");
      var bytes;
      if(offset == 0 && caml_ml_bytes_length(buffer) == len)
       bytes = buffer;
      else
       {bytes = caml_create_bytes(len);
        caml_blit_bytes(buffer,offset,bytes,0,len)}
      var
       string=caml_string_of_bytes(bytes),
       jsstring=caml_jsbytes_of_string(string),
       id=jsstring.lastIndexOf("\n");
      if(id < 0)
       chan.buffer += jsstring;
      else
       {chan.buffer += jsstring.substr(0,id + 1);
        caml_ml_flush(chanid);
        chan.buffer += jsstring.substr(id + 1)}
      return 0}
    function caml_ml_output(chanid,buffer,offset,len)
     {return caml_ml_output_bytes
              (chanid,caml_bytes_of_string(buffer),offset,len)}
    function caml_ephe_get_data(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,x[caml_ephe_data_offset]]}
    function caml_xmlhttprequest_create(unit)
     {var g=joo_global_object;
      if(typeof g.XMLHttpRequest !== "undefined")
       try {return new (g.XMLHttpRequest)()}catch(e){}
      if(typeof g.activeXObject !== "undefined")
       {try {return new (g.activeXObject)("Msxml2.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Msxml3.XMLHTTP")}catch(e){}
        try {return new (g.activeXObject)("Microsoft.XMLHTTP")}catch(e){}}
      caml_failwith("Cannot create a XMLHttpRequest")}
    function caml_trampoline_return(f,args)
     {return {joo_tramp:f,joo_args:args}}
    function caml_array_append(a1,a2)
     {var l1=a1.length,l2=a2.length,l=l1 + l2 - 1,a=new Array(l);
      a[0] = 0;
      var i=1,j=1;
      for(;i < l1;i++)a[i] = a1[i];
      for(;i < l;i++,j++)a[i] = a2[j];
      return a}
    function caml_ml_set_channel_refill(chanid,f)
     {caml_ml_channels[chanid].refill = f;return 0}
    function caml_js_expr(s)
     {js_print_stderr("caml_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function caml_int64_mul(x,y){return x.mul(y)}
    function caml_ml_runtime_warnings_enabled(_unit)
     {return caml_runtime_warnings}
    function caml_output_value_to_bytes(v,flags)
     {return caml_bytes_of_array(caml_output_val(v,flags))}
    function caml_hash_univ_param(count,limit,obj)
     {var hash_accu=0;
      function hash_aux(obj)
       {limit--;
        if(count < 0 || limit < 0)return;
        if(obj instanceof Array && obj[0] === (obj[0] | 0))
         switch(obj[0])
          {case 248:count--;hash_accu = hash_accu * 65599 + obj[2] | 0;break;
           case 250:limit++;hash_aux(obj);break;
           default:
            count--;
            hash_accu = hash_accu * 19 + obj[0] | 0;
            for(var i=obj.length - 1;i > 0;i--)hash_aux(obj[i])}
        else
         if(caml_is_ml_bytes(obj))
          {count--;
           switch(obj.t & 6)
            {default:caml_convert_string_to_bytes(obj);case 0:
              for(var b=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
              break;
             case 2:
              for(var a=obj.c,l=caml_ml_bytes_length(obj),i=0;i < l;i++)
               hash_accu = hash_accu * 19 + a[i] | 0
             }}
         else
          if(caml_is_ml_string(obj))
           {var jsbytes=caml_jsbytes_of_string(obj);
            for(var b=jsbytes,l=jsbytes.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0}
          else
           if(typeof obj === "string")
            for(var b=obj,l=obj.length,i=0;i < l;i++)
             hash_accu = hash_accu * 19 + b.charCodeAt(i) | 0;
           else
            if(obj === (obj | 0))
             {count--;hash_accu = hash_accu * 65599 + obj | 0}
            else
             if(obj === + obj)
              {count--;
               var p=caml_int64_to_bytes(caml_int64_bits_of_float(obj));
               for(var i=7;i >= 0;i--)hash_accu = hash_accu * 19 + p[i] | 0}
             else
              if(obj && obj.caml_custom)
               if
                (caml_custom_ops[obj.caml_custom]
                 &&
                 caml_custom_ops[obj.caml_custom].hash)
                {var h=caml_custom_ops[obj.caml_custom].hash(obj) | 0;
                 hash_accu = hash_accu * 65599 + h | 0}}
      hash_aux(obj);
      return hash_accu & 0x3FFFFFFF}
    function caml_string_equal(s1,s2){return caml_bytes_equal(s1,s2)}
    function caml_output_value_to_buffer(s,ofs,len,v,flags)
     {var t=caml_output_val(v,flags);
      if(t.length > len)caml_failwith("Marshal.to_buffer: buffer overflow");
      caml_blit_bytes(t,0,s,ofs,t.length);
      return 0}
    function re_replacement_text(repl,groups,orig)
     {var
       repl=caml_jsbytes_of_string(repl),
       len=repl.length,
       orig=caml_jsbytes_of_string(orig),
       res="",
       n=0,
       cur,
       start,
       end,
       c;
      while(n < len)
       {cur = repl.charAt(n++);
        if(cur != "\\")
         res += cur;
        else
         {if(n == len)
           caml_failwith("Str.replace: illegal backslash sequence");
          cur = repl.charAt(n++);
          switch(cur)
           {case "\\":res += cur;break;
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
             c = + cur;
             if(c * 2 >= groups.length - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             start = caml_array_get(groups,c * 2);
             end = caml_array_get(groups,c * 2 + 1);
             if(start == - 1)
              caml_failwith("Str.replace: reference to unmatched group");
             res += orig.slice(start,end);
             break;
            default:res += "\\" + cur}}}
      return caml_string_of_jsbytes(res)}
    function caml_pure_js_expr(s)
     {js_print_stderr("caml_pure_js_expr: fallback to runtime evaluation\n");
      return eval(caml_jsstring_of_string(s))}
    function blit_nat(nat1,ofs1,nat2,ofs2,len)
     {for(var i=0;i < len;i++)nat1.data[ofs1 + i] = nat2.data[ofs2 + i];
      return 0}
    function caml_int64_ult(x,y){return x.ucompare(y) < 0}
    function caml_int64_xor(x,y){return x.xor(y)}
    function caml_bigstring_blit_ba_to_bytes(ba1,pos1,bytes2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument
        ("caml_bigstring_blit_string_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(pos2 + len > caml_ml_bytes_length(bytes2))caml_array_bound_error();
      var slice=ba1.data.slice(ofs1,ofs1 + len);
      caml_blit_bytes(caml_bytes_of_array(slice),0,bytes2,pos2,len);
      return 0}
    function caml_register_named_value(nm,v)
     {caml_named_values[caml_jsbytes_of_string(nm)] = v;return 0}
    function caml_to_js_string(s){return caml_jsstring_of_string(s)}
    function caml_parse_sign_and_base(s)
     {var i=0,len=caml_ml_string_length(s),base=10,sign=1;
      if(len > 0)
       switch(caml_string_unsafe_get(s,i))
        {case 45:i++;sign = - 1;break;case 43:i++;sign = 1;break}
      if(i + 1 < len && caml_string_unsafe_get(s,i) == 48)
       switch(caml_string_unsafe_get(s,i + 1))
        {case 120:
         case 88:base = 16;i += 2;break;
         case 111:
         case 79:base = 8;i += 2;break;
         case 98:
         case 66:base = 2;i += 2;break;
         case 117:
         case 85:i += 2;break
         }
      return [i,sign,base]}
    function caml_parse_digit(c)
     {if(c >= 48 && c <= 57)return c - 48;
      if(c >= 65 && c <= 90)return c - 55;
      if(c >= 97 && c <= 122)return c - 87;
      return - 1}
    function caml_int64_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       base64=caml_int64_of_int32(base),
       threshold=
        new MlInt64(0xffffff,0xfffffff,0xffff).udivmod(base64).quotient,
       c=caml_string_unsafe_get(s,i),
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=caml_int64_of_int32(d);
      for(;;)
       {i++;
        c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        if(caml_int64_ult(threshold,res))caml_failwith("int_of_string");
        d = caml_int64_of_int32(d);
        res = caml_int64_add(caml_int64_mul(base64,res),d);
        if(caml_int64_ult(res,d))caml_failwith("int_of_string")}
      if(i != caml_ml_string_length(s))caml_failwith("int_of_string");
      if(base == 10 && caml_int64_ult(new MlInt64(0,0,0x8000),res))
       caml_failwith("int_of_string");
      if(sign < 0)res = caml_int64_neg(res);
      return res}
    function re_search_forward(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.search_forward");
      while(pos <= caml_ml_string_length(s))
       {var res=re_match(re,s,pos,0);if(res)return res;pos++}
      return [0]}
    var caml_blit_string_to_bigstring=caml_bigstring_blit_string_to_ba;
    function caml_make_vect(len,init)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 0;
      for(var i=1;i < len;i++)b[i] = init;
      return b}
    function caml_ml_seek_in(chanid,pos)
     {var chan=caml_ml_channels[chanid];
      if(chan.refill != null)caml_raise_sys_error("Illegal seek");
      chan.offset = pos;
      return 0}
    function caml_sys_read_directory(name)
     {var
       root=resolve_fs_device(name),
       a=root.device.readdir(root.rest),
       l=new Array(a.length + 1);
      l[0] = 0;
      for(var i=0;i < a.length;i++)l[i + 1] = caml_string_of_jsbytes(a[i]);
      return l}
    function caml_ml_output_char(chanid,c)
     {var s=caml_string_of_jsbytes(String.fromCharCode(c));
      caml_ml_output(chanid,s,0,1);
      return 0}
    function caml_sys_const_ostype_win32(){return 0}
    function caml_obj_is_block(x){return + (x instanceof Array)}
    function caml_ml_input_char(chanid)
     {var chan=caml_ml_channels[chanid];
      caml_ml_may_refill_input(chanid);
      if(chan.offset >= chan.file.length())caml_raise_end_of_file();
      var res=chan.file.read_one(chan.offset);
      chan.offset++;
      return res}
    function caml_obj_set_raw_field(o,i,v){return o[i + 1] = v}
    function caml_js_var(x)
     {var x=caml_jsstring_of_string(x);
      if(! x.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*(\.[a-zA-Z_$][a-zA-Z_$0-9]*)*$/))
       js_print_stderr
        ('caml_js_var: "'
         +
         x
         +
         '" is not a valid JavaScript variable. continuing ..');
      return eval(x)}
    function caml_trunc_float(x){return Math.trunc(x)}
    function caml_ephe_blit_data(src,dst)
     {dst[caml_ephe_data_offset] = src[caml_ephe_data_offset];return 0}
    function caml_is_printable(c){return + (c > 31 && c < 127)}
    function caml_equal(x,y){return + (caml_compare_val(x,y,false) == 0)}
    function re_partial_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.partial_match");
      var res=re_match(re,s,pos,1);
      return res?res:[0]}
    function caml_sys_random_seed()
     {var now=new Date().getTime(),x=now ^ 0xffffffff * Math.random();
      return [0,x]}
    function caml_final_register_called_without_value(){return 0}
    function caml_ba_get_2(ba,i0,i1){return ba.get(ba.offset([i0,i1]))}
    function win_handle_fd(x){return x}
    function caml_ba_uint8_set16(ba,i0,v)
     {var ofs=ba.offset(i0);
      if(ofs + 1 >= ba.data.length)caml_array_bound_error();
      ba.set(ofs + 0,v & 0xff);
      ba.set(ofs + 1,v >>> 8 & 0xff);
      return 0}
    function caml_js_delete(o,f){delete o[f];return 0}
    function caml_int_of_string(s)
     {var
       r=caml_parse_sign_and_base(s),
       i=r[0],
       sign=r[1],
       base=r[2],
       len=caml_ml_string_length(s),
       threshold=- 1 >>> 0,
       c=i < len?caml_string_unsafe_get(s,i):0,
       d=caml_parse_digit(c);
      if(d < 0 || d >= base)caml_failwith("int_of_string");
      var res=d;
      for(i++;i < len;i++)
       {c = caml_string_unsafe_get(s,i);
        if(c == 95)continue;
        d = caml_parse_digit(c);
        if(d < 0 || d >= base)break;
        res = base * res + d;
        if(res > threshold)caml_failwith("int_of_string")}
      if(i != len)caml_failwith("int_of_string");
      res = sign * res;
      if(base == 10 && (res | 0) != res)caml_failwith("int_of_string");
      return res | 0}
    function caml_list_mount_point()
     {var prev=0;
      for(var i=0;i < jsoo_mount_point.length;i++)
       {var old=prev;
        prev = [0,caml_string_of_jsbytes(jsoo_mount_point[i].path),old]}
      return prev}
    var
     caml_marshal_constants=
      {PREFIX_SMALL_BLOCK:0x80,
       PREFIX_SMALL_INT:0x40,
       PREFIX_SMALL_STRING:0x20,
       CODE_INT8:0x00,
       CODE_INT16:0x01,
       CODE_INT32:0x02,
       CODE_INT64:0x03,
       CODE_SHARED8:0x04,
       CODE_SHARED16:0x05,
       CODE_SHARED32:0x06,
       CODE_BLOCK32:0x08,
       CODE_BLOCK64:0x13,
       CODE_STRING8:0x09,
       CODE_STRING32:0x0A,
       CODE_DOUBLE_BIG:0x0B,
       CODE_DOUBLE_LITTLE:0x0C,
       CODE_DOUBLE_ARRAY8_BIG:0x0D,
       CODE_DOUBLE_ARRAY8_LITTLE:0x0E,
       CODE_DOUBLE_ARRAY32_BIG:0x0F,
       CODE_DOUBLE_ARRAY32_LITTLE:0x07,
       CODE_CODEPOINTER:0x10,
       CODE_INFIXPOINTER:0x11,
       CODE_CUSTOM:0x12,
       CODE_CUSTOM_LEN:0x18,
       CODE_CUSTOM_FIXED:0x19};
    function caml_obj_raw_field(o,i){return o[i + 1]}
    function caml_js_equals(x,y){return + (x == y)}
    function bigstring_to_typed_array(bs){return bs.data}
    function caml_gr_arc_aux(ctx,cx,cy,ry,rx,a1,a2)
     {while(a1 > a2)a2 += 360;
      a1 /= 180;
      a2 /= 180;
      var
       rot=0,
       xPos,
       yPos,
       xPos_prev,
       yPos_prev,
       space=2,
       num=(a2 - a1) * Math.PI * ((rx + ry) / 2) / space | 0,
       delta=(a2 - a1) * Math.PI / num,
       i=a1 * Math.PI;
      for(var j=0;j <= num;j++)
       {xPos
        =
        cx
        -
        rx
        *
        Math.sin(i)
        *
        Math.sin(rot * Math.PI)
        +
        ry
        *
        Math.cos(i)
        *
        Math.cos(rot * Math.PI);
        xPos = xPos.toFixed(2);
        yPos
        =
        cy
        +
        ry
        *
        Math.cos(i)
        *
        Math.sin(rot * Math.PI)
        +
        rx
        *
        Math.sin(i)
        *
        Math.cos(rot * Math.PI);
        yPos = yPos.toFixed(2);
        if(j == 0)
         ctx.moveTo(xPos,yPos);
        else
         if(xPos_prev != xPos || yPos_prev != yPos)ctx.lineTo(xPos,yPos);
        xPos_prev = xPos;
        yPos_prev = yPos;
        i -= delta}
      return 0}
    function caml_gr_fill_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.fill();
      return 0}
    function caml_ba_slice(ba,vind)
     {vind = caml_js_from_array(vind);
      var num_inds=vind.length,index=[],sub_dims=[],ofs;
      if(num_inds > ba.dims.length)
       caml_invalid_argument("Bigarray.slice: too many indices");
      if(ba.layout == 0)
       {for(var i=0;i < num_inds;i++)index[i] = vind[i];
        for(;i < ba.dims.length;i++)index[i] = 0;
        sub_dims = ba.dims.slice(num_inds)}
      else
       {for(var i=0;i < num_inds;i++)
         index[ba.dims.length - num_inds + i] = vind[i];
        for(var i=0;i < ba.dims.length - num_inds;i++)index[i] = 1;
        sub_dims = ba.dims.slice(0,ba.dims.length - num_inds)}
      ofs = ba.offset(index);
      var
       size=caml_ba_get_size(sub_dims),
       size_per_element=caml_ba_get_size_per_element(ba.kind),
       new_data=
        ba.data.subarray
         (ofs * size_per_element,(ofs + size) * size_per_element);
      return caml_ba_create_unsafe(ba.kind,ba.layout,sub_dims,new_data)}
    function caml_marshal_data_size(s,ofs)
     {function get32(s,i)
       {return caml_bytes_unsafe_get(s,i)
               <<
               24
               |
               caml_bytes_unsafe_get(s,i + 1)
               <<
               16
               |
               caml_bytes_unsafe_get(s,i + 2)
               <<
               8
               |
               caml_bytes_unsafe_get(s,i + 3)}
      if(get32(s,ofs) != (0x8495A6BE | 0))
       caml_failwith("Marshal.data_size: bad object");
      return get32(s,ofs + 4)}
    function caml_input_value(chanid)
     {var chan=caml_ml_channels[chanid],buf=caml_create_bytes(8);
      chan.file.read(chan.offset,buf,0,8);
      var len=caml_marshal_data_size(buf,0) + 20,buf=caml_create_bytes(len);
      chan.file.read(chan.offset,buf,0,len);
      var offset=[0],res=caml_input_value_from_bytes(buf,offset);
      chan.offset = chan.offset + offset[0];
      return res}
    function caml_ba_kind(ba){return ba.kind}
    function caml_js_fun_call(f,a)
     {switch(a.length)
       {case 1:return f();
        case 2:return f(a[1]);
        case 3:return f(a[1],a[2]);
        case 4:return f(a[1],a[2],a[3]);
        case 5:return f(a[1],a[2],a[3],a[4]);
        case 6:return f(a[1],a[2],a[3],a[4],a[5]);
        case 7:return f(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return f(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      return f.apply(null,caml_js_from_array(a))}
    function caml_js_pure_expr(f){return f()}
    function compare_digits_nat(nat1,ofs1,nat2,ofs2)
     {if(nat1.data[ofs1] > nat2.data[ofs2])return 1;
      if(nat1.data[ofs1] < nat2.data[ofs2])return - 1;
      return 0}
    function caml_ml_input(chanid,s,i,l)
     {var chan=caml_ml_channels[chanid],l2=chan.file.length() - chan.offset;
      if(l2 == 0 && chan.refill != null)l2 = caml_ml_refill_input(chan);
      if(l2 < l)l = l2;
      chan.file.read(chan.offset,s,i,l);
      chan.offset += l;
      return l}
    function caml_gr_wait_event(_evl)
     {caml_failwith
       ("caml_gr_wait_event not Implemented: use Graphics_js instead")}
    function caml_gr_sigio_handler(){return 0}
    function caml_hash_mix_bigstring(h,bs)
     {return caml_hash_mix_bytes_arr(h,bs.data)}
    function caml_record_backtrace(){return 0}
    function unix_gmtime(t)
     {var
       d=new Date(t * 1000),
       d_num=d.getTime(),
       januaryfirst=new Date(Date.UTC(d.getUTCFullYear(),0,1)).getTime(),
       doy=Math.floor((d_num - januaryfirst) / 86400000);
      return [0,
              d.getUTCSeconds(),
              d.getUTCMinutes(),
              d.getUTCHours(),
              d.getUTCDate(),
              d.getUTCMonth(),
              d.getUTCFullYear() - 1900,
              d.getUTCDay(),
              doy,
              false | 0]}
    function caml_sys_get_config()
     {return [0,caml_string_of_jsbytes("Unix"),32,0]}
    function caml_sys_const_backend_type()
     {return [0,caml_string_of_jsbytes("js_of_ocaml")]}
    function unix_time(){return Math.floor(unix_gettimeofday())}
    function caml_ml_out_channels_list()
     {var l=0;
      for(var c=0;c < caml_ml_channels.length;c++)
       if
        (caml_ml_channels[c]
         &&
         caml_ml_channels[c].opened
         &&
         caml_ml_channels[c].out)
        l = [0,caml_ml_channels[c].fd,l];
      return l}
    function bigstring_of_array_buffer(ab)
     {var ta=new (joo_global_object.Uint8Array)(ab);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_mod(x,y){if(y == 0)caml_raise_zero_divide();return x % y}
    function caml_ba_init(){return 0}
    function re_string_match(re,s,pos)
     {if(pos < 0 || pos > caml_ml_string_length(s))
       caml_invalid_argument("Str.string_match");
      var res=re_match(re,s,pos,0);
      return res?res:[0]}
    function BigStringReader(bs,i){this.s = bs;this.i = i}
    BigStringReader.prototype
    =
    {read8u:function(){return caml_ba_get_1(this.s,this.i++)},
     read8s:function(){return caml_ba_get_1(this.s,this.i++) << 24 >> 24},
     read16u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 8 | caml_ba_get_1(s,i + 1)},
     read16s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 2;
       return caml_ba_get_1(s,i) << 24 >> 16 | caml_ba_get_1(s,i + 1)},
     read32u:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return (caml_ba_get_1(s,i)
               <<
               24
               |
               caml_ba_get_1(s,i + 1)
               <<
               16
               |
               caml_ba_get_1(s,i + 2)
               <<
               8
               |
               caml_ba_get_1(s,i + 3))
              >>>
              0},
     read32s:
     function()
      {var s=this.s,i=this.i;
       this.i = i + 4;
       return caml_ba_get_1(s,i)
              <<
              24
              |
              caml_ba_get_1(s,i + 1)
              <<
              16
              |
              caml_ba_get_1(s,i + 2)
              <<
              8
              |
              caml_ba_get_1(s,i + 3)},
     readstr:
     function(len)
      {var i=this.i,arr=new Array(len);
       for(var j=0;j < len;j++)arr[j] = caml_ba_get_1(this.s,i + j);
       this.i = i + len;
       return caml_string_of_array(arr)}};
    function caml_gr_dump_image(im)
     {var data=[0];
      for(var i=0;i < im.height;i++)
       {data[i + 1] = [0];
        for(var j=0;j < im.width;j++)
         {var
           o=i * (im.width * 4) + j * 4,
           r=im.data[o + 0],
           g=im.data[o + 1],
           b=im.data[o + 2];
          data[i + 1][j + 1] = (r << 16) + (g << 8) + b}}
      return data}
    function caml_ba_get_generic(ba,i)
     {var ofs=ba.offset(caml_js_from_array(i));return ba.get(ofs)}
    function caml_get_exception_backtrace(){return 0}
    function caml_format_float(fmt,x)
     {function toFixed(x,dp)
       {if(Math.abs(x) < 1.0)
         return x.toFixed(dp);
        else
         {var e=parseInt(x.toString().split("+")[1]);
          if(e > 20)
           {e -= 20;
            x /= Math.pow(10,e);
            x += new Array(e + 1).join("0");
            if(dp > 0)x = x + "." + new Array(dp + 1).join("0");
            return x}
          else
           return x.toFixed(dp)}}
      var s,f=caml_parse_format(fmt),prec=f.prec < 0?6:f.prec;
      if(x < 0 || x == 0 && 1 / x == - Infinity){f.sign = - 1;x = - x}
      if(isNaN(x))
       {s = "nan";f.filler = " "}
      else
       if(! isFinite(x))
        {s = "inf";f.filler = " "}
       else
        switch(f.conv)
         {case "e":
           var s=x.toExponential(prec),i=s.length;
           if(s.charAt(i - 3) == "e")
            s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
           break;
          case "f":s = toFixed(x,prec);break;
          case "g":
           prec = prec?prec:1;
           s = x.toExponential(prec - 1);
           var j=s.indexOf("e"),exp=+ s.slice(j + 1);
           if(exp < - 4 || x >= 1e21 || x.toFixed(0).length > prec)
            {var i=j - 1;
             while(s.charAt(i) == "0")i--;
             if(s.charAt(i) == ".")i--;
             s = s.slice(0,i + 1) + s.slice(j);
             i = s.length;
             if(s.charAt(i - 3) == "e")
              s = s.slice(0,i - 1) + "0" + s.slice(i - 1);
             break}
           else
            {var p=prec;
             if(exp < 0)
              {p -= exp + 1;s = x.toFixed(p)}
             else
              while(s = x.toFixed(p),s.length > prec + 1)p--;
             if(p)
              {var i=s.length - 1;
               while(s.charAt(i) == "0")i--;
               if(s.charAt(i) == ".")i--;
               s = s.slice(0,i + 1)}}
           break
          }
      return caml_finish_formatting(f,s)}
    function caml_mount_autoload(name,f)
     {var path=caml_make_path(name),name=path.join("/") + "/";
      jsoo_mount_point.push({path:name,device:new MlFakeDevice(name,f)});
      return 0}
    function caml_bigstring_blit_ba_to_ba(ba1,pos1,ba2,pos2,len)
     {if(12 != ba1.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(12 != ba2.kind)
       caml_invalid_argument("caml_bigstring_blit_ba_to_ba: kind mismatch");
      if(len == 0)return 0;
      var ofs1=ba1.offset(pos1),ofs2=ba2.offset(pos2);
      if(ofs1 + len > ba1.data.length)caml_array_bound_error();
      if(ofs2 + len > ba2.data.length)caml_array_bound_error();
      var slice=ba1.data.subarray(ofs1,ofs1 + len);
      ba2.data.set(slice,pos2);
      return 0}
    var caml_blit_bigstring_to_bigstring=caml_bigstring_blit_ba_to_ba;
    function caml_string_lessthan(s1,s2){return caml_bytes_lessthan(s1,s2)}
    function caml_string_greaterthan(s1,s2)
     {return caml_string_lessthan(s2,s1)}
    function caml_div(x,y)
     {if(y == 0)caml_raise_zero_divide();return x / y | 0}
    function caml_ephe_get_data_copy(x)
     {return x[caml_ephe_data_offset] === undefined
              ?0
              :[0,caml_obj_dup(x[caml_ephe_data_offset])]}
    function caml_memprof_start(rate,stack_size,tracker){return 0}
    function caml_sys_get_argv(a){return [0,caml_argv[1],caml_argv]}
    function caml_js_to_bool(x){return + x}
    function caml_gr_create_image(x,y)
     {var s=caml_gr_state_get();return s.context.createImageData(x,y)}
    var caml_ephe_get_key_copy=caml_weak_get_copy;
    function caml_lessthan(x,y){return + (caml_compare_val(x,y,false) < 0)}
    function caml_raw_backtrace_next_slot(){return 0}
    function caml_register_global(n,v,name_opt)
     {if(name_opt && joo_global_object.toplevelReloc)
       n = joo_global_object.toplevelReloc(name_opt);
      caml_global_data[n + 1] = v;
      if(name_opt)caml_global_data[name_opt] = v}
    function mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat3,ofs3,len3)
     {var carry=0;
      for(var i=0;i < len3;i++)
       carry
       +=
       mult_digit_nat(nat1,ofs1 + i,len1 - i,nat2,ofs2,len2,nat3,ofs3 + i);
      return carry}
    function square_nat(nat1,ofs1,len1,nat2,ofs2,len2)
     {var carry=0;
      carry += add_nat(nat1,ofs1,len1,nat1,ofs1,len1,0);
      carry += mult_nat(nat1,ofs1,len1,nat2,ofs2,len2,nat2,ofs2,len2);
      return carry}
    function caml_js_from_float(x){return x}
    function caml_floatarray_create(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_gc_stat(){return [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
    function caml_sys_modify_argv(arg){caml_argv = arg;return 0}
    var caml_method_cache=[];
    function caml_get_public_method(obj,tag,cacheid)
     {var meths=obj[1],ofs=caml_method_cache[cacheid];
      if(ofs === undefined)
       for(var i=caml_method_cache.length;i < cacheid;i++)
        caml_method_cache[i] = 0;
      else
       if(meths[ofs] === tag)return meths[ofs - 1];
      var li=3,hi=meths[1] * 2 + 1,mi;
      while(li < hi)
       {mi = li + hi >> 1 | 1;if(tag < meths[mi + 1])hi = mi - 2;else li = mi}
      caml_method_cache[cacheid] = li + 1;
      return tag == meths[li + 1]?meths[li]:0}
    function caml_js_get_console()
     {var
       c=joo_global_object.console?joo_global_object.console:{},
       m=
        ["log",
         "debug",
         "info",
         "warn",
         "error",
         "assert",
         "dir",
         "dirxml",
         "trace",
         "group",
         "groupCollapsed",
         "groupEnd",
         "time",
         "timeEnd"];
      function f(){}
      for(var i=0;i < m.length;i++)if(! c[m[i]])c[m[i]] = f;
      return c}
    function caml_sys_unsafe_getenv(name){return caml_sys_getenv(name)}
    function caml_ml_open_descriptor_in(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.wronly)caml_raise_sys_error("fd " + fd + " is writeonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:false,
         refill:null};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function bigstring_of_typed_array(ba)
     {var
       ta=
        new
         (joo_global_object.Uint8Array)
         (ba.buffer,ba.byteOffset,ba.length * ba.BYTES_PER_ELEMENT);
      return caml_ba_create_unsafe(12,0,[ta.length],ta)}
    function caml_round_float(x){return Math.round(x)}
    function caml_ojs_new_arr(c,a)
     {switch(a.length)
       {case 0:return new c();
        case 1:return new c(a[0]);
        case 2:return new c(a[0],a[1]);
        case 3:return new c(a[0],a[1],a[2]);
        case 4:return new c(a[0],a[1],a[2],a[3]);
        case 5:return new c(a[0],a[1],a[2],a[3],a[4]);
        case 6:return new c(a[0],a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[0],a[1],a[2],a[3],a[4],a[5],a[6])
        }
      function F(){return c.apply(this,a)}
      F.prototype = c.prototype;
      return new F()}
    function complement_nat(nat,ofs,len)
     {for(var i=0;i < len;i++)
       nat.data[ofs + i] = (- 1 >>> 0) - (nat.data[ofs + i] >>> 0)}
    var caml_js_regexps={amp:/&/g,lt:/</g,quot:/\"/g,all:/[&<\"]/};
    function caml_js_html_escape(s)
     {if(! caml_js_regexps.all.test(s))return s;
      return s.replace(caml_js_regexps.amp,"&amp;").replace
               (caml_js_regexps.lt,"&lt;").replace
              (caml_js_regexps.quot,"&quot;")}
    function caml_ba_dim_2(ba){return caml_ba_dim(ba,1)}
    function caml_js_wrap_meth_callback_arguments(f)
     {return function()
       {var len=arguments.length,args=new Array(len);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,[this,args])}}
    function caml_sinh_float(x){return (Math.exp(x) - Math.exp(- x)) / 2}
    function caml_ldexp_float(x,exp)
     {exp |= 0;
      if(exp > 1023)
       {exp -= 1023;
        x *= Math.pow(2,1023);
        if(exp > 1023){exp -= 1023;x *= Math.pow(2,1023)}}
      if(exp < - 1023){exp += 1023;x *= Math.pow(2,- 1023)}
      x *= Math.pow(2,exp);
      return x}
    function caml_gr_state_set(ctx)
     {caml_gr_state = ctx;caml_gr_state_init();return 0}
    function caml_js_wrap_callback_strict(arity,f)
     {return function()
       {var n=arguments.length;
        if(n == arity && f.length == arity)return f.apply(null,arguments);
        var args=new Array(arity),len=Math.min(arguments.length,arity);
        for(var i=0;i < len;i++)args[i] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_ba_set_1(ba,i0,v){ba.set(ba.offset(i0),v);return 0}
    function caml_get_current_callstack(){return [0]}
    function land_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] &= nat2.data[ofs2];return 0}
    function caml_int64_mod(x,y){return x.mod(y)}
    function caml_obj_set_tag(x,tag){x[0] = tag;return 0}
    function caml_create_file_extern(name,content)
     {if(joo_global_object.caml_create_file)
       joo_global_object.caml_create_file(name,content);
      else
       {if(! joo_global_object.caml_fs_tmp)joo_global_object.caml_fs_tmp = [];
        joo_global_object.caml_fs_tmp.push({name:name,content:content})}
      return 0}
    function caml_int32_bswap(x)
     {return (x & 0x000000FF)
             <<
             24
             |
             (x & 0x0000FF00)
             <<
             8
             |
             (x & 0x00FF0000)
             >>>
             8
             |
             (x & 0xFF000000)
             >>>
             24}
    function win_startup(){}
    function caml_ba_set_3(ba,i0,i1,i2,v)
     {ba.set(ba.offset([i0,i1,i2]),v);return 0}
    function caml_js_instanceof(o,c){return o instanceof c}
    var caml_blit_bigstring_to_string=caml_bigstring_blit_ba_to_bytes;
    function nth_digit_nat_native(nat,ofs){return nat.data[ofs]}
    function set_digit_nat_native(nat,ofs,digit)
     {nat.data[ofs] = digit;return 0}
    function caml_string_set64(s,i,i64){return caml_bytes_set64(s,i,i64)}
    function caml_gr_state_create(canvas,w,h)
     {var context=canvas.getContext("2d");
      return {context:context,
              canvas:canvas,
              x:0,
              y:0,
              width:w,
              height:h,
              line_width:1,
              font:caml_string_of_jsbytes("fixed"),
              text_size:26,
              color:0x000000,
              title:caml_string_of_jsbytes("")}}
    function caml_js_wrap_callback(f)
     {return function()
       {var len=arguments.length;
        if(len > 0)
         {var args=new Array(len);
          for(var i=0;i < len;i++)args[i] = arguments[i];
          return caml_call_gen(f,args)}
        else
         return caml_call_gen(f,[undefined])}}
    function caml_gr_draw_arc(x,y,rx,ry,a1,a2)
     {var s=caml_gr_state_get();
      s.context.beginPath();
      caml_gr_arc_aux(s.context,x,s.height - y,rx,ry,a1,a2);
      s.context.stroke();
      return 0}
    function caml_ba_map_file(vfd,kind,layout,shared,dims,pos)
     {caml_failwith("caml_ba_map_file not implemented")}
    function caml_ba_map_file_bytecode(argv,argn)
     {return caml_ba_map_file(argv[0],argv[1],argv[2],argv[3],argv[4],argv[5])}
    function caml_ba_create_from(data1,data2,jstyp,kind,layout,dims)
     {if(data2 || caml_ba_get_size_per_element(kind) == 2)
       caml_invalid_argument
        ("caml_ba_create_from: use return caml_ba_create_unsafe");
      return caml_ba_create_unsafe(kind,layout,dims,data1)}
    function caml_tanh_float(x)
     {var y=Math.exp(x),z=Math.exp(- x);return (y - z) / (y + z)}
    function caml_gr_draw_str(str)
     {var s=caml_gr_state_get(),m=s.context.measureText(str),dx=m.width;
      s.context.fillText(str,s.x,s.height - s.y);
      s.x += dx | 0;
      return 0}
    function caml_gr_draw_string(str)
     {caml_gr_draw_str(caml_jsstring_of_string(str));return 0}
    function caml_gr_draw_char(c)
     {caml_gr_draw_str(String.fromCharCode(c));return 0}
    function caml_unmount(name)
     {var path=caml_make_path(name),name=path.join("/") + "/",idx=- 1;
      for(var i=0;i < jsoo_mount_point.length;i++)
       if(jsoo_mount_point[i].path == name)idx = i;
      if(idx > - 1)jsoo_mount_point.splice(idx,1);
      return 0}
    function caml_input_value_from_string(s,ofs)
     {var reader=new MlStringReader(s,typeof ofs == "number"?ofs:ofs[0]);
      return caml_input_value_from_reader(reader,ofs)}
    function caml_ml_pos_in_64(chanid)
     {return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_draw_image(im,x,y)
     {var s=caml_gr_state_get();
      if(! im.image)
       {var canvas=document.createElement("canvas");
        canvas.width = s.width;
        canvas.height = s.height;
        canvas.getContext("2d").putImageData(im,0,0);
        var image=new (joo_global_object.Image)();
        image.onload
        =
        function()
         {s.context.drawImage(image,x,s.height - im.height - y);
          im.image = image};
        image.src = canvas.toDataURL("image/png")}
      else
       s.context.drawImage(im.image,x,s.height - im.height - y);
      return 0}
    function caml_register_channel_for_spacetime(_channel){return 0}
    function caml_string_set(s,i,c)
     {if(i >>> 0 >= s.l)caml_string_bound_error();
      return caml_string_unsafe_set(s,i,c)}
    function caml_ml_pos_out(chanid)
     {caml_ml_flush(chanid);return caml_ml_channels[chanid].offset}
    function caml_spacetime_enabled(_unit){return 0}
    function caml_bytes_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_runtime_parameters(_unit){return caml_string_of_jsbytes("")}
    function caml_js_object(a)
     {var o={};
      for(var i=1;i < a.length;i++)
       {var p=a[i];o[caml_jsstring_of_string(p[1])] = p[2]}
      return o}
    function caml_ba_create(kind,layout,dims_ml)
     {var
       dims=caml_js_from_array(dims_ml),
       data=caml_ba_create_buffer(kind,caml_ba_get_size(dims));
      return caml_ba_create_unsafe(kind,layout,dims,data)}
    function caml_weak_blit(a1,i1,a2,i2,len)
     {caml_array_blit
       (a1,caml_ephe_key_offset + i1 - 1,a2,caml_ephe_key_offset + i2 - 1,len);
      return 0}
    function caml_gr_remember_mode()
     {caml_failwith("caml_gr_remember_mode not Implemented")}
    function caml_bswap16(x){return (x & 0x00FF) << 8 | (x & 0xFF00) >> 8}
    function caml_ml_set_binary_mode(chanid,mode)
     {var chan=caml_ml_channels[chanid],data=caml_global_data.fds[chan.fd];
      data.flags.text = ! mode;
      data.flags.binary = mode;
      return 0}
    function caml_final_register(){return 0}
    function caml_gr_draw_rect(x,y,w,h)
     {var s=caml_gr_state_get();
      s.context.strokeRect(x,s.height - y,w,- h);
      return 0}
    function caml_string_get16(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 1)caml_string_bound_error();
      var b1=caml_string_unsafe_get(s,i),b2=caml_string_unsafe_get(s,i + 1);
      return b2 << 8 | b1}
    function caml_ephe_unset_data(x,data)
     {x[caml_ephe_data_offset] = undefined;return 0}
    function caml_output_value(chanid,v,flags)
     {var s=caml_output_value_to_string(v,flags);
      caml_ml_output(chanid,s,0,caml_ml_string_length(s));
      return 0}
    function caml_ba_get_3(ba,i0,i1,i2){return ba.get(ba.offset([i0,i1,i2]))}
    var
     caml_ephe_blit_key=caml_weak_blit,
     caml_initial_time=new Date().getTime() * 0.001;
    function caml_sys_time()
     {var now=new Date().getTime();return now * 0.001 - caml_initial_time}
    function caml_sys_time_include_children(b){return caml_sys_time()}
    function caml_check_bound(array,index)
     {if(index >>> 0 >= array.length - 1)caml_array_bound_error();
      return array}
    function caml_hash_mix_string(h,v)
     {return caml_hash_mix_jsbytes(h,caml_jsbytes_of_string(v))}
    function caml_hash(count,limit,seed,obj)
     {var queue,rd,wr,sz,num,h,v,i,len;
      sz = limit;
      if(sz < 0 || sz > 256)sz = 256;
      num = count;
      h = seed;
      queue = [obj];
      rd = 0;
      wr = 1;
      while(rd < wr && num > 0)
       {v = queue[rd++];
        if(v && v.caml_custom)
         {if
           (caml_custom_ops[v.caml_custom]
            &&
            caml_custom_ops[v.caml_custom].hash)
           {var hh=caml_custom_ops[v.caml_custom].hash(v);
            h = caml_hash_mix_int(h,hh);
            num--}}
        else
         if(v instanceof Array && v[0] === (v[0] | 0))
          switch(v[0])
           {case 248:h = caml_hash_mix_int(h,v[2]);num--;break;
            case 250:queue[--rd] = v[1];break;
            default:
             var tag=v.length - 1 << 10 | v[0];
             h = caml_hash_mix_int(h,tag);
             for(i = 1,len = v.length;i < len;i++)
              {if(wr >= sz)break;queue[wr++] = v[i]}
             break}
         else
          if(caml_is_ml_bytes(v))
           {h = caml_hash_mix_bytes(h,v);num--}
          else
           if(caml_is_ml_string(v))
            {h = caml_hash_mix_string(h,v);num--}
           else
            if(typeof v === "string")
             {h = caml_hash_mix_jsbytes(h,v);num--}
            else
             if(v === (v | 0))
              {h = caml_hash_mix_int(h,v + v + 1);num--}
             else
              if(v === + v){h = caml_hash_mix_float(h,v);num--}}
      h = caml_hash_mix_final(h);
      return h & 0x3FFFFFFF}
    function caml_obj_tag(x)
     {if(x instanceof Array && x[0] == x[0] >>> 0)
       return x[0];
      else
       if(caml_is_ml_bytes(x))
        return 252;
       else
        if(caml_is_ml_string(x))
         return 252;
        else
         if(x instanceof Function || typeof x == "function")
          return 247;
         else
          if(x && x.caml_custom)return 255;else return 1000}
    function caml_ba_to_typed_array(ba){return ba.data}
    function caml_js_export_var()
     {return typeof module !== "undefined" && module && module.exports
              ?module.exports
              :joo_global_object}
    function caml_bytes_get32(s,i)
     {if(i >>> 0 >= s.l - 3)caml_bytes_bound_error();
      var
       b1=caml_bytes_unsafe_get(s,i),
       b2=caml_bytes_unsafe_get(s,i + 1),
       b3=caml_bytes_unsafe_get(s,i + 2),
       b4=caml_bytes_unsafe_get(s,i + 3);
      return b4 << 24 | b3 << 16 | b2 << 8 | b1}
    function caml_frexp_float(x)
     {if(x == 0 || ! isFinite(x))return [0,x,0];
      var neg=x < 0;
      if(neg)x = - x;
      var exp=Math.max(- 1023,jsoo_floor_log2(x) + 1);
      x *= Math.pow(2,- exp);
      while(x < 0.5){x *= 2;exp--}
      while(x >= 1){x *= 0.5;exp++}
      if(neg)x = - x;
      return [0,x,exp]}
    function caml_string_get64(s,i)
     {if(i >>> 0 >= caml_ml_string_length(s) - 7)caml_string_bound_error();
      var a=new Array(8);
      for(var j=0;j < 8;j++)a[7 - j] = caml_string_unsafe_get(s,i + j);
      return caml_int64_of_bytes(a)}
    function caml_ml_pos_out_64(chanid)
     {caml_ml_flush(chanid);
      return caml_int64_of_float(caml_ml_channels[chanid].offset)}
    function caml_gr_close_subwindow(a)
     {caml_failwith("caml_gr_close_subwindow not Implemented")}
    function caml_floatarray_blit(a1,i1,a2,i2,len)
     {if(i2 <= i1)
       for(var j=1;j <= len;j++)a2[i2 + j] = a1[i1 + j];
      else
       for(var j=len;j >= 1;j--)a2[i2 + j] = a1[i1 + j];
      return 0}
    function caml_set_static_env(k,v)
     {if(! joo_global_object.jsoo_static_env)
       joo_global_object.jsoo_static_env = {};
      joo_global_object.jsoo_static_env[k] = v;
      return 0}
    function caml_ba_change_layout(ba,layout)
     {if(ba.layout == layout)return ba;
      var new_dims=[];
      for(var i=0;i < ba.dims.length;i++)
       new_dims[i] = ba.dims[ba.dims.length - i - 1];
      return caml_ba_create_unsafe(ba.kind,layout,new_dims,ba.data)}
    function caml_js_new(c,a)
     {switch(a.length)
       {case 1:return new c();
        case 2:return new c(a[1]);
        case 3:return new c(a[1],a[2]);
        case 4:return new c(a[1],a[2],a[3]);
        case 5:return new c(a[1],a[2],a[3],a[4]);
        case 6:return new c(a[1],a[2],a[3],a[4],a[5]);
        case 7:return new c(a[1],a[2],a[3],a[4],a[5],a[6]);
        case 8:return new c(a[1],a[2],a[3],a[4],a[5],a[6],a[7])
        }
      function F(){return c.apply(this,caml_js_from_array(a))}
      F.prototype = c.prototype;
      return new F()}
    function caml_gr_current_y(){var s=caml_gr_state_get();return s.y}
    function caml_format_int(fmt,i)
     {if(caml_jsbytes_of_string(fmt) == "%d")
       return caml_string_of_jsbytes("" + i);
      var f=caml_parse_format(fmt);
      if(i < 0)if(f.signedconv){f.sign = - 1;i = - i}else i >>>= 0;
      var s=i.toString(f.base);
      if(f.prec >= 0)
       {f.filler = " ";
        var n=f.prec - s.length;
        if(n > 0)s = caml_str_repeat(n,"0") + s}
      return caml_finish_formatting(f,s)}
    function caml_obj_truncate(x,s)
     {if(s <= 0 || s + 1 > x.length)caml_invalid_argument("Obj.truncate");
      if(x.length != s + 1)x.length = s + 1;
      return 0}
    function caml_js_to_string(s){return caml_string_of_jsstring(s)}
    function is_digit_odd(nat,ofs){if(nat.data[ofs] & 1)return 1;return 0}
    function caml_runtime_variant(_unit){return caml_string_of_jsbytes("")}
    function caml_ml_open_descriptor_out(fd)
     {var data=caml_global_data.fds[fd];
      if(data.flags.rdonly)caml_raise_sys_error("fd " + fd + " is readonly");
      var
       channel=
        {file:data.file,
         offset:data.offset,
         fd:fd,
         opened:true,
         out:true,
         buffer:""};
      caml_ml_channels[channel.fd] = channel;
      return channel.fd}
    function caml_array_concat(l)
     {var a=[0];
      while(l !== 0)
       {var b=l[1];for(var i=1;i < b.length;i++)a.push(b[i]);l = l[2]}
      return a}
    function caml_gr_open_graph(info)
     {var g=joo_global_object,info=caml_jsstring_of_string(info);
      function get(name)
       {var res=info.match("(^|,) *" + name + " *= *([a-zA-Z0-9_]+) *(,|$)");
        if(res)return res[2]}
      var specs=[];
      if(! (info == ""))specs.push(info);
      var target=get("target");
      if(! target)target = "";
      var status=get("status");
      if(! status)specs.push("status=1");
      var w=get("width");
      w = w?parseInt(w):200;
      specs.push("width=" + w);
      var h=get("height");
      h = h?parseInt(h):200;
      specs.push("height=" + h);
      var win=g.open("about:blank",target,specs.join(","));
      if(! win)caml_failwith("Graphics.open_graph: cannot open the window");
      var doc=win.document,canvas=doc.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      var ctx=caml_gr_state_create(canvas,w,h);
      ctx.set_title = function(title){doc.title = title};
      caml_gr_state_set(ctx);
      var body=doc.body;
      body.style.margin = "0px";
      body.appendChild(canvas);
      return 0}
    function caml_ephe_set_data(x,data)
     {x[caml_ephe_data_offset] = data;return 0}
    function caml_make_float_vect(len)
     {if(len < 0)caml_array_bound_error();
      var len=len + 1 | 0,b=new Array(len);
      b[0] = 254;
      for(var i=1;i < len;i++)b[i] = 0;
      return b}
    function caml_memprof_stop(unit){return 0}
    function caml_greaterequal(x,y)
     {return + (caml_compare_val(x,y,false) >= 0)}
    function caml_get_exception_raw_backtrace(){return [0]}
    function caml_log1p_float(x)
     {var y=1 + x,z=y - 1;return z == 0?x:x * Math.log(y) / z}
    function caml_int64_or(x,y){return x.or(y)}
    function caml_lazy_make_forward(v){return [250,v]}
    function lor_digit_nat(nat1,ofs1,nat2,ofs2)
     {nat1.data[ofs1] |= nat2.data[ofs2];return 0}
    function caml_gr_blit_image(im,x,y)
     {var
       s=caml_gr_state_get(),
       im2=
        s.context.getImageData(x,s.height - im.height - y,im.width,im.height);
      for(var i=0;i < im2.data.length;i += 4)
       {im.data[i] = im2.data[i];
        im.data[i + 1] = im2.data[i + 1];
        im.data[i + 2] = im2.data[i + 2];
        im.data[i + 3] = im2.data[i + 3]}
      return 0}
    function caml_gr_window_id(a)
     {caml_failwith("caml_gr_window_id not Implemented")}
    function caml_js_on_ie()
     {var
       ua=
        joo_global_object.navigator?joo_global_object.navigator.userAgent:"";
      return ua.indexOf("MSIE") != - 1 && ua.indexOf("Opera") != 0}
    function caml_int64_shift_right(x,s){return x.shift_right(s)}
    function caml_ba_layout(ba){return ba.layout}
    function caml_convert_raw_backtrace(){return [0]}
    function caml_array_set(array,index,newval)
     {if(index < 0 || index >= array.length - 1)caml_array_bound_error();
      array[index + 1] = newval;
      return 0}
    function caml_bytes_greaterequal(s1,s2)
     {return caml_bytes_lessequal(s2,s1)}
    function set_digit_nat(nat,ofs,digit){nat.data[ofs] = digit;return 0}
    function caml_update_dummy(x,y)
     {if(typeof y === "function"){x.fun = y;return 0}
      if(y.fun){x.fun = y.fun;return 0}
      var i=y.length;
      while(i--)x[i] = y[i];
      return 0}
    function caml_CamlinternalMod_update_mod(shape,real,x)
     {if(typeof shape === "number")
       switch(shape){case 0:case 1:case 2:default:caml_update_dummy(real,x)}
      else
       switch(shape[0])
        {case 0:
          for(var i=1;i < shape[1].length;i++)
           caml_CamlinternalMod_update_mod(shape[1][i],real[i],x[i]);
          break
         }
      return 0}
    function caml_gr_doc_of_state(state)
     {if(state.canvas.ownerDocument)return state.canvas.ownerDocument}
    function caml_ml_output_int(chanid,i)
     {var
       arr=[i >> 24 & 0xFF,i >> 16 & 0xFF,i >> 8 & 0xFF,i & 0xFF],
       s=caml_string_of_array(arr);
      caml_ml_output(chanid,s,0,4);
      return 0}
    function caml_obj_with_tag(tag,x)
     {var l=x.length,a=new Array(l);
      a[0] = tag;
      for(var i=1;i < l;i++)a[i] = x[i];
      return a}
    function caml_ml_channel_size(chanid)
     {var chan=caml_ml_channels[chanid];return chan.file.length()}
    function caml_raw_backtrace_slot()
     {caml_invalid_argument
       ("Printexc.get_raw_backtrace_slot: index out of bounds")}
    function caml_hexstring_of_float(x,prec,style)
     {if(! isFinite(x))
       {if(isNaN(x))return caml_string_of_jsstring("nan");
        return caml_string_of_jsstring(x > 0?"infinity":"-infinity")}
      var sign=x == 0 && 1 / x == - Infinity?1:x >= 0?0:1;
      if(sign)x = - x;
      var exp=0;
      if(x == 0)
       ;
      else
       if(x < 1)
        while(x < 1 && exp > - 1022){x *= 2;exp--}
       else
        while(x >= 2){x /= 2;exp++}
      var exp_sign=exp < 0?"":"+",sign_str="";
      if(sign)
       sign_str = "-";
      else
       switch(style)
        {case 43:sign_str = "+";break;
         case 32:sign_str = " ";break;
         default:break}
      if(prec >= 0 && prec < 13)
       {var cst=Math.pow(2,prec * 4);x = Math.round(x * cst) / cst}
      var x_str=x.toString(16);
      if(prec >= 0)
       {var idx=x_str.indexOf(".");
        if(idx < 0)
         x_str += "." + caml_str_repeat(prec,"0");
        else
         {var size=idx + 1 + prec;
          if(x_str.length < size)
           x_str += caml_str_repeat(size - x_str.length,"0");
          else
           x_str = x_str.substr(0,size)}}
      return caml_string_of_jsstring
              (sign_str + "0x" + x_str + "p" + exp_sign + exp.toString(10))}
    function caml_js_wrap_meth_callback_strict(arity,f)
     {return function()
       {var args=new Array(arity + 1),len=Math.min(arguments.length,arity);
        args[0] = this;
        for(var i=0;i < len;i++)args[i + 1] = arguments[i];
        return caml_call_gen(f,args)}}
    function caml_backtrace_status(){return 0}
    function caml_install_signal_handler(){return 0}
    function caml_sys_argv(a){return caml_argv}
    function caml_ba_fill(ba,v){ba.fill(v);return 0}
    function caml_modf_float(x)
     {if(isFinite(x))
       {var neg=1 / x < 0;
        x = Math.abs(x);
        var i=Math.floor(x),f=x - i;
        if(neg){i = - i;f = - f}
        return [0,f,i]}
      if(isNaN(x))return [0,NaN,NaN];
      return [0,1 / x,x]}
    function caml_gc_get(){return [0,0,0,0,0,0,0,0,0]}
    function caml_float_compare(x,y)
     {if(x === y)return 0;
      if(x < y)return - 1;
      if(x > y)return 1;
      if(x === x)return 1;
      if(y === y)return - 1;
      return 0}
    function caml_string_set32(s,i,i32){return caml_bytes_set32(s,i,i32)}
    function caml_parse_engine(tables,env,cmd,arg)
     {var
       ERRCODE=256,
       loop=6,
       testshift=7,
       shift=8,
       shift_recover=9,
       reduce=10,
       READ_TOKEN=0,
       RAISE_PARSE_ERROR=1,
       GROW_STACKS_1=2,
       GROW_STACKS_2=3,
       COMPUTE_SEMANTIC_ACTION=4,
       CALL_ERROR_FUNCTION=5,
       env_s_stack=1,
       env_v_stack=2,
       env_symb_start_stack=3,
       env_symb_end_stack=4,
       env_stacksize=5,
       env_stackbase=6,
       env_curr_char=7,
       env_lval=8,
       env_symb_start=9,
       env_symb_end=10,
       env_asp=11,
       env_rule_len=12,
       env_rule_number=13,
       env_sp=14,
       env_state=15,
       env_errflag=16,
       tbl_transl_const=2,
       tbl_transl_block=3,
       tbl_lhs=4,
       tbl_len=5,
       tbl_defred=6,
       tbl_dgoto=7,
       tbl_sindex=8,
       tbl_rindex=9,
       tbl_gindex=10,
       tbl_tablesize=11,
       tbl_table=12,
       tbl_check=13;
      if(! tables.dgoto)
       {tables.defred = caml_lex_array(tables[tbl_defred]);
        tables.sindex = caml_lex_array(tables[tbl_sindex]);
        tables.check = caml_lex_array(tables[tbl_check]);
        tables.rindex = caml_lex_array(tables[tbl_rindex]);
        tables.table = caml_lex_array(tables[tbl_table]);
        tables.len = caml_lex_array(tables[tbl_len]);
        tables.lhs = caml_lex_array(tables[tbl_lhs]);
        tables.gindex = caml_lex_array(tables[tbl_gindex]);
        tables.dgoto = caml_lex_array(tables[tbl_dgoto])}
      var
       res=0,
       n,
       n1,
       n2,
       state1,
       sp=env[env_sp],
       state=env[env_state],
       errflag=env[env_errflag];
      exit:
      for(;;)
       switch(cmd)
        {case 0:state = 0;errflag = 0;
         case 6:
          n = tables.defred[state];
          if(n != 0){cmd = reduce;break}
          if(env[env_curr_char] >= 0){cmd = testshift;break}
          res = READ_TOKEN;
          break exit;
         case 1:
          if(arg instanceof Array)
           {env[env_curr_char] = tables[tbl_transl_block][arg[0] + 1];
            env[env_lval] = arg[1]}
          else
           {env[env_curr_char] = tables[tbl_transl_const][arg + 1];
            env[env_lval] = 0}
         case 7:
          n1 = tables.sindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {cmd = shift;break}
          n1 = tables.rindex[state];
          n2 = n1 + env[env_curr_char];
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            env[env_curr_char])
           {n = tables.table[n2];cmd = reduce;break}
          if(errflag <= 0){res = CALL_ERROR_FUNCTION;break exit}
         case 5:
          if(errflag < 3)
           {errflag = 3;
            for(;;)
             {state1 = env[env_s_stack][sp + 1];
              n1 = tables.sindex[state1];
              n2 = n1 + ERRCODE;
              if
               (n1
                !=
                0
                &&
                n2
                >=
                0
                &&
                n2
                <=
                tables[tbl_tablesize]
                &&
                tables.check[n2]
                ==
                ERRCODE)
               {cmd = shift_recover;break}
              else
               {if(sp <= env[env_stackbase])return RAISE_PARSE_ERROR;sp--}}}
          else
           {if(env[env_curr_char] == 0)return RAISE_PARSE_ERROR;
            env[env_curr_char] = - 1;
            cmd = loop;
            break}
         case 8:env[env_curr_char] = - 1;if(errflag > 0)errflag--;
         case 9:
          state = tables.table[n2];
          sp++;
          if(sp >= env[env_stacksize]){res = GROW_STACKS_1;break exit}
         case 2:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = env[env_lval];
          env[env_symb_start_stack][sp + 1] = env[env_symb_start];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end];
          cmd = loop;
          break;
         case 10:
          var m=tables.len[n];
          env[env_asp] = sp;
          env[env_rule_number] = n;
          env[env_rule_len] = m;
          sp = sp - m + 1;
          m = tables.lhs[n];
          state1 = env[env_s_stack][sp];
          n1 = tables.gindex[m];
          n2 = n1 + state1;
          if
           (n1
            !=
            0
            &&
            n2
            >=
            0
            &&
            n2
            <=
            tables[tbl_tablesize]
            &&
            tables.check[n2]
            ==
            state1)
           state = tables.table[n2];
          else
           state = tables.dgoto[m];
          if(sp >= env[env_stacksize]){res = GROW_STACKS_2;break exit}
         case 3:res = COMPUTE_SEMANTIC_ACTION;break exit;
         case 4:
          env[env_s_stack][sp + 1] = state;
          env[env_v_stack][sp + 1] = arg;
          var asp=env[env_asp];
          env[env_symb_end_stack][sp + 1] = env[env_symb_end_stack][asp + 1];
          if(sp > asp)
           env[env_symb_start_stack][sp + 1]
           =
           env[env_symb_end_stack][asp + 1];
          cmd = loop;
          break;
         default:return RAISE_PARSE_ERROR}
      env[env_sp] = sp;
      env[env_state] = state;
      env[env_errflag] = errflag;
      return res}
    function caml_array_fill(array,ofs,len,v)
     {for(var i=0;i < len;i++)array[ofs + i + 1] = v;return 0}
    function caml_string_notequal(s1,s2){return 1 - caml_string_equal(s1,s2)}
    function caml_bytes_greaterthan(s1,s2){return caml_bytes_lessthan(s2,s1)}
    function caml_gr_make_image(arr)
     {var
       s=caml_gr_state_get(),
       h=arr.length - 1,
       w=arr[1].length - 1,
       im=s.context.createImageData(w,h);
      for(var i=0;i < h;i++)
       for(var j=0;j < w;j++)
        {var c=arr[i + 1][j + 1],o=i * (w * 4) + j * 4;
         if(c == - 1)
          {im.data[o + 0] = 0;
           im.data[o + 1] = 0;
           im.data[o + 2] = 0;
           im.data[o + 3] = 0}
         else
          {im.data[o + 0] = c >> 16 & 0xff;
           im.data[o + 1] = c >> 8 & 0xff;
           im.data[o + 2] = c >> 0 & 0Xff;
           im.data[o + 3] = 0xff}}
      return im}
    function caml_ml_set_channel_output(chanid,f)
     {var chan=caml_ml_channels[chanid];
      caml_global_data.fds[chan.fd].output = f;
      return 0}
    function caml_read_file_content(name)
     {var
       name=typeof name == "string"?caml_string_of_jsbytes(name):name,
       root=resolve_fs_device(name);
      if(root.device.exists(root.rest))
       {var
         file=root.device.open(root.rest,{rdonly:1}),
         len=file.length(),
         buf=caml_create_bytes(len);
        file.read(0,buf,0,len);
        return caml_string_of_bytes(buf)}
      caml_raise_no_such_file(name)}
    function caml_js_to_float(x){return x}
    joo_global_object.jsoo_runtime
    =
    {caml_ephe_check_data:caml_ephe_check_data,
     caml_ephe_unset_data:caml_ephe_unset_data,
     caml_ephe_set_data:caml_ephe_set_data,
     caml_ephe_get_data_copy:caml_ephe_get_data_copy,
     caml_ephe_get_data:caml_ephe_get_data,
     caml_ephe_blit_data:caml_ephe_blit_data,
     caml_ephe_unset_key:caml_ephe_unset_key,
     caml_ephe_set_key:caml_ephe_set_key,
     caml_ephe_check_key:caml_ephe_check_key,
     caml_ephe_get_key_copy:caml_ephe_get_key_copy,
     caml_ephe_get_key:caml_ephe_get_key,
     caml_ephe_blit_key:caml_ephe_blit_key,
     caml_ephe_create:caml_ephe_create,
     caml_weak_blit:caml_weak_blit,
     caml_weak_check:caml_weak_check,
     caml_weak_get_copy:caml_weak_get_copy,
     caml_weak_get:caml_weak_get,
     caml_weak_set:caml_weak_set,
     caml_weak_create:caml_weak_create,
     caml_ephe_data_offset:caml_ephe_data_offset,
     caml_ephe_key_offset:caml_ephe_key_offset,
     unix_isatty:unix_isatty,
     win_handle_fd:win_handle_fd,
     win_cleanup:win_cleanup,
     win_startup:win_startup,
     unix_mktime:unix_mktime,
     unix_localtime:unix_localtime,
     unix_gmtime:unix_gmtime,
     unix_time:unix_time,
     unix_gettimeofday:unix_gettimeofday,
     re_replacement_text:re_replacement_text,
     re_partial_match:re_partial_match,
     re_string_match:re_string_match,
     re_search_backward:re_search_backward,
     re_search_forward:re_search_forward,
     re_match:re_match,
     caml_spacetime_only_works_for_native_code:
     caml_spacetime_only_works_for_native_code,
     caml_register_channel_for_spacetime:caml_register_channel_for_spacetime,
     caml_sys_const_naked_pointers_checked:
     caml_sys_const_naked_pointers_checked,
     caml_spacetime_enabled:caml_spacetime_enabled,
     caml_ml_runtime_warnings_enabled:caml_ml_runtime_warnings_enabled,
     caml_ml_enable_runtime_warnings:caml_ml_enable_runtime_warnings,
     caml_runtime_warnings:caml_runtime_warnings,
     unix_inet_addr_of_string:unix_inet_addr_of_string,
     caml_install_signal_handler:caml_install_signal_handler,
     caml_runtime_parameters:caml_runtime_parameters,
     caml_runtime_variant:caml_runtime_variant,
     caml_sys_isatty:caml_sys_isatty,
     caml_sys_get_config:caml_sys_get_config,
     caml_sys_const_backend_type:caml_sys_const_backend_type,
     caml_sys_const_ostype_cygwin:caml_sys_const_ostype_cygwin,
     caml_sys_const_ostype_win32:caml_sys_const_ostype_win32,
     caml_sys_const_ostype_unix:caml_sys_const_ostype_unix,
     caml_sys_const_max_wosize:caml_sys_const_max_wosize,
     caml_sys_const_int_size:caml_sys_const_int_size,
     caml_sys_const_word_size:caml_sys_const_word_size,
     caml_sys_const_big_endian:caml_sys_const_big_endian,
     caml_sys_random_seed:caml_sys_random_seed,
     caml_sys_time_include_children:caml_sys_time_include_children,
     caml_sys_time:caml_sys_time,
     caml_sys_system_command:caml_sys_system_command,
     caml_sys_executable_name:caml_sys_executable_name,
     caml_sys_modify_argv:caml_sys_modify_argv,
     caml_sys_argv:caml_sys_argv,
     caml_sys_get_argv:caml_sys_get_argv,
     caml_executable_name:caml_executable_name,
     caml_argv:caml_argv,
     caml_sys_unsafe_getenv:caml_sys_unsafe_getenv,
     caml_sys_getenv:caml_sys_getenv,
     caml_set_static_env:caml_set_static_env,
     caml_sys_exit:caml_sys_exit,
     caml_raise_sys_error:caml_raise_sys_error,
     caml_is_printable:caml_is_printable,
     caml_get_global_data:caml_get_global_data,
     caml_register_global:caml_register_global,
     caml_global_data:caml_global_data,
     caml_named_value:caml_named_value,
     caml_register_named_value:caml_register_named_value,
     caml_named_values:caml_named_values,
     caml_call_gen:caml_call_gen,
     caml_set_parser_trace:caml_set_parser_trace,
     caml_parse_engine:caml_parse_engine,
     caml_obj_set_raw_field:caml_obj_set_raw_field,
     caml_obj_raw_field:caml_obj_raw_field,
     caml_fresh_oo_id:caml_fresh_oo_id,
     caml_set_oo_id:caml_set_oo_id,
     caml_oo_last_id:caml_oo_last_id,
     caml_get_public_method:caml_get_public_method,
     caml_lazy_make_forward:caml_lazy_make_forward,
     caml_obj_make_forward:caml_obj_make_forward,
     caml_obj_truncate:caml_obj_truncate,
     caml_obj_dup:caml_obj_dup,
     caml_obj_with_tag:caml_obj_with_tag,
     caml_obj_block:caml_obj_block,
     caml_obj_set_tag:caml_obj_set_tag,
     caml_obj_tag:caml_obj_tag,
     caml_obj_is_block:caml_obj_is_block,
     caml_update_dummy:caml_update_dummy,
     deserialize_nat:deserialize_nat,
     serialize_nat:serialize_nat,
     lxor_digit_nat:lxor_digit_nat,
     lor_digit_nat:lor_digit_nat,
     land_digit_nat:land_digit_nat,
     compare_nat_real:compare_nat_real,
     compare_nat:compare_nat,
     compare_digits_nat:compare_digits_nat,
     shift_right_nat:shift_right_nat,
     div_nat:div_nat,
     div_digit_nat:div_digit_nat,
     div_helper:div_helper,
     shift_left_nat:shift_left_nat,
     square_nat:square_nat,
     mult_nat:mult_nat,
     mult_digit_nat:mult_digit_nat,
     sub_nat:sub_nat,
     decr_nat:decr_nat,
     complement_nat:complement_nat,
     add_nat:add_nat,
     incr_nat:incr_nat,
     is_digit_odd:is_digit_odd,
     is_digit_zero:is_digit_zero,
     is_digit_int:is_digit_int,
     num_leading_zero_bits_in_digit:num_leading_zero_bits_in_digit,
     num_digits_nat:num_digits_nat,
     nth_digit_nat_native:nth_digit_nat_native,
     set_digit_nat_native:set_digit_nat_native,
     nth_digit_nat:nth_digit_nat,
     set_digit_nat:set_digit_nat,
     blit_nat:blit_nat,
     set_to_zero_nat:set_to_zero_nat,
     create_nat:create_nat,
     nat_of_array:nat_of_array,
     caml_hash_nat:caml_hash_nat,
     MlNat:MlNat,
     initialize_nat:initialize_nat,
     caml_js_to_string:caml_js_to_string,
     caml_to_js_string:caml_to_js_string,
     caml_js_from_string:caml_js_from_string,
     caml_new_string:caml_new_string,
     caml_js_to_byte_string:caml_js_to_byte_string,
     caml_is_ml_string:caml_is_ml_string,
     caml_is_ml_bytes:caml_is_ml_bytes,
     caml_string_of_jsstring:caml_string_of_jsstring,
     caml_jsstring_of_string:caml_jsstring_of_string,
     caml_jsbytes_of_string:caml_jsbytes_of_string,
     caml_string_of_jsbytes:caml_string_of_jsbytes,
     caml_bytes_of_string:caml_bytes_of_string,
     caml_string_of_bytes:caml_string_of_bytes,
     caml_string_lessthan:caml_string_lessthan,
     caml_string_lessequal:caml_string_lessequal,
     caml_string_equal:caml_string_equal,
     caml_string_compare:caml_string_compare,
     caml_ml_string_length:caml_ml_string_length,
     caml_string_unsafe_set:caml_string_unsafe_set,
     caml_string_unsafe_get:caml_string_unsafe_get,
     caml_bytes_of_jsbytes:caml_bytes_of_jsbytes,
     caml_ml_bytes_length:caml_ml_bytes_length,
     caml_blit_string:caml_blit_string,
     caml_blit_bytes:caml_blit_bytes,
     caml_fill_string:caml_fill_string,
     caml_fill_bytes:caml_fill_bytes,
     caml_bytes_greaterthan:caml_bytes_greaterthan,
     caml_string_greaterthan:caml_string_greaterthan,
     caml_bytes_greaterequal:caml_bytes_greaterequal,
     caml_string_greaterequal:caml_string_greaterequal,
     caml_bytes_lessthan:caml_bytes_lessthan,
     caml_bytes_lessequal:caml_bytes_lessequal,
     caml_bytes_notequal:caml_bytes_notequal,
     caml_string_notequal:caml_string_notequal,
     caml_bytes_equal:caml_bytes_equal,
     caml_bytes_compare:caml_bytes_compare,
     caml_bytes_of_array:caml_bytes_of_array,
     caml_string_of_array:caml_string_of_array,
     caml_create_bytes:caml_create_bytes,
     caml_create_string:caml_create_string,
     caml_array_of_string:caml_array_of_string,
     caml_array_of_bytes:caml_array_of_bytes,
     caml_convert_bytes_to_array:caml_convert_bytes_to_array,
     caml_convert_string_to_bytes:caml_convert_string_to_bytes,
     MlBytes:MlBytes,
     caml_bytes_of_utf16_jsstring:caml_bytes_of_utf16_jsstring,
     caml_bytes_set:caml_bytes_set,
     caml_string_set64:caml_string_set64,
     caml_bytes_set64:caml_bytes_set64,
     caml_string_set32:caml_string_set32,
     caml_bytes_set32:caml_bytes_set32,
     caml_string_set16:caml_string_set16,
     caml_bytes_set16:caml_bytes_set16,
     caml_string_set:caml_string_set,
     caml_bytes_get:caml_bytes_get,
     caml_bytes_get64:caml_bytes_get64,
     caml_string_get64:caml_string_get64,
     caml_bytes_get32:caml_bytes_get32,
     caml_string_get32:caml_string_get32,
     caml_bytes_get16:caml_bytes_get16,
     caml_string_get16:caml_string_get16,
     caml_string_get:caml_string_get,
     caml_bytes_bound_error:caml_bytes_bound_error,
     caml_string_bound_error:caml_string_bound_error,
     caml_bytes_unsafe_set:caml_bytes_unsafe_set,
     caml_bytes_unsafe_get:caml_bytes_unsafe_get,
     jsoo_is_ascii:jsoo_is_ascii,
     caml_utf16_of_utf8:caml_utf16_of_utf8,
     caml_utf8_of_utf16:caml_utf8_of_utf16,
     caml_subarray_to_jsbytes:caml_subarray_to_jsbytes,
     caml_str_repeat:caml_str_repeat,
     caml_md5_bytes:caml_md5_bytes,
     caml_md5_string:caml_md5_string,
     caml_md5_chan:caml_md5_chan,
     caml_output_value_to_buffer:caml_output_value_to_buffer,
     caml_output_value_to_bytes:caml_output_value_to_bytes,
     caml_output_value_to_string:caml_output_value_to_string,
     caml_output_val:caml_output_val,
     caml_legacy_custom_code:caml_legacy_custom_code,
     MlObjectTable:MlObjectTable,
     caml_marshal_data_size:caml_marshal_data_size,
     caml_input_value_from_reader:caml_input_value_from_reader,
     caml_custom_ops:caml_custom_ops,
     caml_nativeint_unmarshal:caml_nativeint_unmarshal,
     caml_int32_unmarshal:caml_int32_unmarshal,
     caml_int64_marshal:caml_int64_marshal,
     caml_int64_unmarshal:caml_int64_unmarshal,
     caml_input_value_from_bytes:caml_input_value_from_bytes,
     caml_input_value_from_string:caml_input_value_from_string,
     caml_float_of_bytes:caml_float_of_bytes,
     BigStringReader:BigStringReader,
     MlStringReader:MlStringReader,
     caml_marshal_constants:caml_marshal_constants,
     caml_new_lex_engine:caml_new_lex_engine,
     caml_lex_engine:caml_lex_engine,
     caml_lex_array:caml_lex_array,
     caml_xmlhttprequest_create:caml_xmlhttprequest_create,
     caml_js_export_var:caml_js_export_var,
     caml_js_object:caml_js_object,
     caml_pure_js_expr:caml_pure_js_expr,
     caml_js_expr:caml_js_expr,
     caml_js_eval_string:caml_js_eval_string,
     caml_js_equals:caml_js_equals,
     caml_js_wrap_meth_callback_unsafe:caml_js_wrap_meth_callback_unsafe,
     caml_js_wrap_meth_callback_strict:caml_js_wrap_meth_callback_strict,
     caml_js_wrap_meth_callback_arguments:caml_js_wrap_meth_callback_arguments,
     caml_js_wrap_meth_callback:caml_js_wrap_meth_callback,
     caml_js_wrap_callback_strict:caml_js_wrap_callback_strict,
     caml_js_wrap_callback_arguments:caml_js_wrap_callback_arguments,
     caml_js_wrap_callback:caml_js_wrap_callback,
     caml_ojs_new_arr:caml_ojs_new_arr,
     caml_js_new:caml_js_new,
     caml_js_meth_call:caml_js_meth_call,
     caml_js_fun_call:caml_js_fun_call,
     caml_js_call:caml_js_call,
     caml_js_var:caml_js_var,
     caml_list_to_js_array:caml_list_to_js_array,
     caml_list_of_js_array:caml_list_of_js_array,
     caml_js_to_array:caml_js_to_array,
     caml_js_from_array:caml_js_from_array,
     caml_js_to_float:caml_js_to_float,
     caml_js_from_float:caml_js_from_float,
     caml_js_to_bool:caml_js_to_bool,
     caml_js_from_bool:caml_js_from_bool,
     caml_js_error_of_exception:caml_js_error_of_exception,
     caml_exn_with_js_backtrace:caml_exn_with_js_backtrace,
     caml_wrap_exception:caml_wrap_exception,
     caml_is_js:caml_is_js,
     js_print_stderr:js_print_stderr,
     js_print_stdout:js_print_stdout,
     caml_trampoline_return:caml_trampoline_return,
     caml_trampoline:caml_trampoline,
     caml_js_get_console:caml_js_get_console,
     caml_js_html_entities:caml_js_html_entities,
     caml_js_html_escape:caml_js_html_escape,
     caml_js_on_ie:caml_js_on_ie,
     caml_js_typeof:caml_js_typeof,
     caml_js_instanceof:caml_js_instanceof,
     caml_js_delete:caml_js_delete,
     caml_js_get:caml_js_get,
     caml_js_set:caml_js_set,
     caml_js_pure_expr:caml_js_pure_expr,
     caml_ml_output_int:caml_ml_output_int,
     caml_ml_pos_out_64:caml_ml_pos_out_64,
     caml_ml_pos_out:caml_ml_pos_out,
     caml_ml_seek_out_64:caml_ml_seek_out_64,
     caml_ml_seek_out:caml_ml_seek_out,
     caml_output_value:caml_output_value,
     caml_ml_output_char:caml_ml_output_char,
     caml_ml_output:caml_ml_output,
     caml_ml_output_bytes:caml_ml_output_bytes,
     caml_ml_flush:caml_ml_flush,
     caml_ml_input_scan_line:caml_ml_input_scan_line,
     caml_ml_pos_in_64:caml_ml_pos_in_64,
     caml_ml_pos_in:caml_ml_pos_in,
     caml_ml_seek_in_64:caml_ml_seek_in_64,
     caml_ml_seek_in:caml_ml_seek_in,
     caml_ml_input_int:caml_ml_input_int,
     caml_ml_input_char:caml_ml_input_char,
     caml_input_value:caml_input_value,
     caml_ml_input:caml_ml_input,
     caml_ml_may_refill_input:caml_ml_may_refill_input,
     caml_ml_refill_input:caml_ml_refill_input,
     caml_ml_set_channel_refill:caml_ml_set_channel_refill,
     caml_ml_set_channel_output:caml_ml_set_channel_output,
     caml_ml_channel_size_64:caml_ml_channel_size_64,
     caml_ml_channel_size:caml_ml_channel_size,
     caml_ml_close_channel:caml_ml_close_channel,
     caml_ml_set_binary_mode:caml_ml_set_binary_mode,
     caml_channel_descriptor:caml_channel_descriptor,
     caml_ml_open_descriptor_in:caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out:caml_ml_open_descriptor_out,
     caml_ml_out_channels_list:caml_ml_out_channels_list,
     caml_ml_channels:caml_ml_channels,
     caml_ml_set_channel_name:caml_ml_set_channel_name,
     caml_sys_open:caml_sys_open,
     caml_std_output:caml_std_output,
     caml_sys_close:caml_sys_close,
     caml_int64_bswap:caml_int64_bswap,
     caml_int32_bswap:caml_int32_bswap,
     caml_bswap16:caml_bswap16,
     caml_mod:caml_mod,
     caml_div:caml_div,
     caml_mul:caml_mul,
     caml_int_of_string:caml_int_of_string,
     caml_parse_digit:caml_parse_digit,
     caml_parse_sign_and_base:caml_parse_sign_and_base,
     caml_format_int:caml_format_int,
     caml_CamlinternalMod_update_mod:caml_CamlinternalMod_update_mod,
     caml_CamlinternalMod_init_mod:caml_CamlinternalMod_init_mod,
     caml_int64_hash:caml_int64_hash,
     caml_int64_to_bytes:caml_int64_to_bytes,
     caml_int64_of_bytes:caml_int64_of_bytes,
     caml_int64_hi32:caml_int64_hi32,
     caml_int64_lo32:caml_int64_lo32,
     caml_int64_create_lo_hi:caml_int64_create_lo_hi,
     caml_int64_create_lo_mi_hi:caml_int64_create_lo_mi_hi,
     caml_int64_of_string:caml_int64_of_string,
     caml_int64_format:caml_int64_format,
     caml_int64_of_float:caml_int64_of_float,
     caml_int64_to_float:caml_int64_to_float,
     caml_int64_to_int32:caml_int64_to_int32,
     caml_int64_of_int32:caml_int64_of_int32,
     caml_int64_mod:caml_int64_mod,
     caml_int64_div:caml_int64_div,
     caml_int64_shift_right:caml_int64_shift_right,
     caml_int64_shift_right_unsigned:caml_int64_shift_right_unsigned,
     caml_int64_shift_left:caml_int64_shift_left,
     caml_int64_xor:caml_int64_xor,
     caml_int64_or:caml_int64_or,
     caml_int64_and:caml_int64_and,
     caml_int64_is_negative:caml_int64_is_negative,
     caml_int64_is_zero:caml_int64_is_zero,
     caml_int64_mul:caml_int64_mul,
     caml_int64_sub:caml_int64_sub,
     caml_int64_add:caml_int64_add,
     caml_int64_neg:caml_int64_neg,
     caml_int64_compare:caml_int64_compare,
     caml_int64_ult:caml_int64_ult,
     MlInt64:MlInt64,
     caml_int64_offset:caml_int64_offset,
     caml_float_of_string:caml_float_of_string,
     caml_format_float:caml_format_float,
     caml_round_float:caml_round_float,
     caml_tanh_float:caml_tanh_float,
     caml_sinh_float:caml_sinh_float,
     caml_cosh_float:caml_cosh_float,
     caml_log10_float:caml_log10_float,
     caml_hypot_float:caml_hypot_float,
     caml_log1p_float:caml_log1p_float,
     caml_expm1_float:caml_expm1_float,
     caml_signbit_float:caml_signbit_float,
     caml_copysign_float:caml_copysign_float,
     caml_float_compare:caml_float_compare,
     caml_frexp_float:caml_frexp_float,
     caml_ldexp_float:caml_ldexp_float,
     caml_modf_float:caml_modf_float,
     caml_classify_float:caml_classify_float,
     caml_int32_float_of_bits:caml_int32_float_of_bits,
     caml_trunc_float:caml_trunc_float,
     caml_nextafter_float:caml_nextafter_float,
     caml_int64_float_of_bits:caml_int64_float_of_bits,
     caml_hexstring_of_float:caml_hexstring_of_float,
     caml_int32_bits_of_float:caml_int32_bits_of_float,
     caml_int64_bits_of_float:caml_int64_bits_of_float,
     jsoo_floor_log2:jsoo_floor_log2,
     caml_hash:caml_hash,
     caml_hash_mix_string:caml_hash_mix_string,
     caml_hash_mix_bytes:caml_hash_mix_bytes,
     caml_hash_mix_bytes_arr:caml_hash_mix_bytes_arr,
     caml_hash_mix_jsbytes:caml_hash_mix_jsbytes,
     caml_hash_mix_int64:caml_hash_mix_int64,
     caml_hash_mix_float:caml_hash_mix_float,
     caml_hash_mix_final:caml_hash_mix_final,
     caml_hash_mix_int:caml_hash_mix_int,
     caml_hash_univ_param:caml_hash_univ_param,
     caml_gr_close_subwindow:caml_gr_close_subwindow,
     caml_gr_open_subwindow:caml_gr_open_subwindow,
     caml_gr_window_id:caml_gr_window_id,
     caml_gr_display_mode:caml_gr_display_mode,
     caml_gr_remember_mode:caml_gr_remember_mode,
     caml_gr_synchronize:caml_gr_synchronize,
     caml_gr_wait_event:caml_gr_wait_event,
     caml_gr_sigio_signal:caml_gr_sigio_signal,
     caml_gr_sigio_handler:caml_gr_sigio_handler,
     caml_gr_blit_image:caml_gr_blit_image,
     caml_gr_create_image:caml_gr_create_image,
     caml_gr_draw_image:caml_gr_draw_image,
     caml_gr_dump_image:caml_gr_dump_image,
     caml_gr_make_image:caml_gr_make_image,
     caml_gr_text_size:caml_gr_text_size,
     caml_gr_set_text_size:caml_gr_set_text_size,
     caml_gr_set_font:caml_gr_set_font,
     caml_gr_draw_string:caml_gr_draw_string,
     caml_gr_draw_char:caml_gr_draw_char,
     caml_gr_draw_str:caml_gr_draw_str,
     caml_gr_fill_arc:caml_gr_fill_arc,
     caml_gr_fill_poly:caml_gr_fill_poly,
     caml_gr_fill_rect:caml_gr_fill_rect,
     caml_gr_set_line_width:caml_gr_set_line_width,
     caml_gr_draw_arc:caml_gr_draw_arc,
     caml_gr_arc_aux:caml_gr_arc_aux,
     caml_gr_draw_rect:caml_gr_draw_rect,
     caml_gr_lineto:caml_gr_lineto,
     caml_gr_current_y:caml_gr_current_y,
     caml_gr_current_x:caml_gr_current_x,
     caml_gr_moveto:caml_gr_moveto,
     caml_gr_point_color:caml_gr_point_color,
     caml_gr_plot:caml_gr_plot,
     caml_gr_set_color:caml_gr_set_color,
     caml_gr_size_y:caml_gr_size_y,
     caml_gr_size_x:caml_gr_size_x,
     caml_gr_clear_graph:caml_gr_clear_graph,
     caml_gr_resize_window:caml_gr_resize_window,
     caml_gr_set_window_title:caml_gr_set_window_title,
     caml_gr_close_graph:caml_gr_close_graph,
     caml_gr_doc_of_state:caml_gr_doc_of_state,
     caml_gr_state_create:caml_gr_state_create,
     caml_gr_state_init:caml_gr_state_init,
     caml_gr_open_graph:caml_gr_open_graph,
     caml_gr_state_set:caml_gr_state_set,
     caml_gr_state_get:caml_gr_state_get,
     caml_gr_state:caml_gr_state,
     caml_memprof_stop:caml_memprof_stop,
     caml_memprof_start:caml_memprof_start,
     caml_final_release:caml_final_release,
     caml_final_register_called_without_value:
     caml_final_register_called_without_value,
     caml_final_register:caml_final_register,
     caml_memprof_set:caml_memprof_set,
     caml_gc_get:caml_gc_get,
     caml_gc_set:caml_gc_set,
     caml_gc_stat:caml_gc_stat,
     caml_gc_quick_stat:caml_gc_quick_stat,
     caml_gc_counters:caml_gc_counters,
     caml_gc_compaction:caml_gc_compaction,
     caml_gc_full_major:caml_gc_full_major,
     caml_gc_major:caml_gc_major,
     caml_gc_minor:caml_gc_minor,
     MlNodeFile:MlNodeFile,
     MlNodeDevice:MlNodeDevice,
     fs_node_supported:fs_node_supported,
     MlFakeFile:MlFakeFile,
     MlFakeDevice:MlFakeDevice,
     caml_read_file_content:caml_read_file_content,
     caml_create_file:caml_create_file,
     caml_fs_init:caml_fs_init,
     caml_create_file_extern:caml_create_file_extern,
     caml_ba_map_file_bytecode:caml_ba_map_file_bytecode,
     caml_ba_map_file:caml_ba_map_file,
     caml_sys_rename:caml_sys_rename,
     caml_sys_is_directory:caml_sys_is_directory,
     caml_sys_remove:caml_sys_remove,
     caml_sys_read_directory:caml_sys_read_directory,
     caml_sys_file_exists:caml_sys_file_exists,
     caml_raise_not_a_dir:caml_raise_not_a_dir,
     caml_raise_no_such_file:caml_raise_no_such_file,
     caml_sys_chdir:caml_sys_chdir,
     caml_sys_getcwd:caml_sys_getcwd,
     caml_unmount:caml_unmount,
     caml_mount_autoload:caml_mount_autoload,
     resolve_fs_device:resolve_fs_device,
     caml_list_mount_point:caml_list_mount_point,
     jsoo_mount_point:jsoo_mount_point,
     caml_make_path:caml_make_path,
     MlFile:MlFile,
     caml_root:caml_root,
     caml_current_dir:caml_current_dir,
     caml_finish_formatting:caml_finish_formatting,
     caml_parse_format:caml_parse_format,
     caml_array_bound_error:caml_array_bound_error,
     caml_raise_not_found:caml_raise_not_found,
     caml_raise_zero_divide:caml_raise_zero_divide,
     caml_raise_end_of_file:caml_raise_end_of_file,
     caml_invalid_argument:caml_invalid_argument,
     caml_failwith:caml_failwith,
     caml_raise_with_string:caml_raise_with_string,
     caml_raise_with_arg:caml_raise_with_arg,
     caml_return_exn_constant:caml_return_exn_constant,
     caml_raise_constant:caml_raise_constant,
     caml_lessthan:caml_lessthan,
     caml_lessequal:caml_lessequal,
     caml_greaterthan:caml_greaterthan,
     caml_greaterequal:caml_greaterequal,
     caml_notequal:caml_notequal,
     caml_equal:caml_equal,
     caml_int_compare:caml_int_compare,
     caml_compare:caml_compare,
     caml_compare_val:caml_compare_val,
     caml_compare_val_number_custom:caml_compare_val_number_custom,
     caml_compare_val_get_custom:caml_compare_val_get_custom,
     caml_compare_val_tag:caml_compare_val_tag,
     caml_blit_string_to_bigstring:caml_blit_string_to_bigstring,
     caml_blit_bigstring_to_string:caml_blit_bigstring_to_string,
     caml_blit_bigstring_to_bigstring:caml_blit_bigstring_to_bigstring,
     caml_bigstring_blit_ba_to_bytes:caml_bigstring_blit_ba_to_bytes,
     caml_bigstring_blit_bytes_to_ba:caml_bigstring_blit_bytes_to_ba,
     caml_bigstring_blit_string_to_ba:caml_bigstring_blit_string_to_ba,
     caml_bigstring_blit_ba_to_ba:caml_bigstring_blit_ba_to_ba,
     caml_bigstring_memcmp:caml_bigstring_memcmp,
     bigstring_of_typed_array:bigstring_of_typed_array,
     bigstring_of_array_buffer:bigstring_of_array_buffer,
     bigstring_to_typed_array:bigstring_to_typed_array,
     bigstring_to_array_buffer:bigstring_to_array_buffer,
     caml_hash_mix_bigstring:caml_hash_mix_bigstring,
     caml_ba_from_typed_array:caml_ba_from_typed_array,
     caml_ba_kind_of_typed_array:caml_ba_kind_of_typed_array,
     caml_ba_to_typed_array:caml_ba_to_typed_array,
     caml_ba_hash:caml_ba_hash,
     caml_ba_create_from:caml_ba_create_from,
     caml_ba_deserialize:caml_ba_deserialize,
     caml_ba_serialize:caml_ba_serialize,
     caml_ba_reshape:caml_ba_reshape,
     caml_ba_slice:caml_ba_slice,
     caml_ba_sub:caml_ba_sub,
     caml_ba_blit:caml_ba_blit,
     caml_ba_fill:caml_ba_fill,
     caml_ba_set_3:caml_ba_set_3,
     caml_ba_set_2:caml_ba_set_2,
     caml_ba_set_1:caml_ba_set_1,
     caml_ba_uint8_set64:caml_ba_uint8_set64,
     caml_ba_uint8_set32:caml_ba_uint8_set32,
     caml_ba_uint8_set16:caml_ba_uint8_set16,
     caml_ba_set_generic:caml_ba_set_generic,
     caml_ba_get_3:caml_ba_get_3,
     caml_ba_get_2:caml_ba_get_2,
     caml_ba_get_1:caml_ba_get_1,
     caml_ba_uint8_get64:caml_ba_uint8_get64,
     caml_ba_uint8_get32:caml_ba_uint8_get32,
     caml_ba_uint8_get16:caml_ba_uint8_get16,
     caml_ba_get_generic:caml_ba_get_generic,
     caml_ba_dim_3:caml_ba_dim_3,
     caml_ba_dim_2:caml_ba_dim_2,
     caml_ba_dim_1:caml_ba_dim_1,
     caml_ba_dim:caml_ba_dim,
     caml_ba_num_dims:caml_ba_num_dims,
     caml_ba_layout:caml_ba_layout,
     caml_ba_kind:caml_ba_kind,
     caml_ba_change_layout:caml_ba_change_layout,
     caml_ba_create:caml_ba_create,
     caml_ba_create_unsafe:caml_ba_create_unsafe,
     caml_ba_compare:caml_ba_compare,
     Ml_Bigarray_c_1_1:Ml_Bigarray_c_1_1,
     Ml_Bigarray:Ml_Bigarray,
     caml_ba_custom_name:caml_ba_custom_name,
     caml_ba_create_buffer:caml_ba_create_buffer,
     caml_ba_get_size_per_element:caml_ba_get_size_per_element,
     caml_ba_get_size:caml_ba_get_size,
     caml_ba_init:caml_ba_init,
     caml_convert_raw_backtrace_slot:caml_convert_raw_backtrace_slot,
     caml_get_current_callstack:caml_get_current_callstack,
     caml_restore_raw_backtrace:caml_restore_raw_backtrace,
     caml_raw_backtrace_slot:caml_raw_backtrace_slot,
     caml_raw_backtrace_next_slot:caml_raw_backtrace_next_slot,
     caml_raw_backtrace_length:caml_raw_backtrace_length,
     caml_convert_raw_backtrace:caml_convert_raw_backtrace,
     caml_record_backtrace:caml_record_backtrace,
     caml_get_exception_raw_backtrace:caml_get_exception_raw_backtrace,
     caml_get_exception_backtrace:caml_get_exception_backtrace,
     caml_backtrace_status:caml_backtrace_status,
     caml_ml_debug_info_status:caml_ml_debug_info_status,
     caml_floatarray_create:caml_floatarray_create,
     caml_make_float_vect:caml_make_float_vect,
     caml_make_vect:caml_make_vect,
     caml_check_bound:caml_check_bound,
     caml_array_fill:caml_array_fill,
     caml_array_get:caml_array_get,
     caml_array_set:caml_array_set,
     caml_floatarray_blit:caml_floatarray_blit,
     caml_array_blit:caml_array_blit,
     caml_array_concat:caml_array_concat,
     caml_array_append:caml_array_append,
     caml_array_sub:caml_array_sub};
    caml_fs_init();
    caml_register_global
     (0,[248,caml_string_of_jsbytes("Out_of_memory"),0],"Out_of_memory");
    caml_register_global
     (1,[248,caml_string_of_jsbytes("Sys_error"),-1],"Sys_error");
    caml_register_global
     (2,[248,caml_string_of_jsbytes("Failure"),-2],"Failure");
    caml_register_global
     (3,
      [248,caml_string_of_jsbytes("Invalid_argument"),-3],
      "Invalid_argument");
    caml_register_global
     (4,[248,caml_string_of_jsbytes("End_of_file"),-4],"End_of_file");
    caml_register_global
     (5,
      [248,caml_string_of_jsbytes("Division_by_zero"),-5],
      "Division_by_zero");
    caml_register_global
     (6,[248,caml_string_of_jsbytes("Not_found"),-6],"Not_found");
    caml_register_global
     (7,[248,caml_string_of_jsbytes("Match_failure"),-7],"Match_failure");
    caml_register_global
     (8,[248,caml_string_of_jsbytes("Stack_overflow"),-8],"Stack_overflow");
    caml_register_global
     (9,[248,caml_string_of_jsbytes("Sys_blocked_io"),-9],"Sys_blocked_io");
    caml_register_global
     (10,[248,caml_string_of_jsbytes("Assert_failure"),-10],"Assert_failure");
    caml_register_global
     (11,
      [248,caml_string_of_jsbytes("Undefined_recursive_module"),-11],
      "Undefined_recursive_module");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/stdlib.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_array_concat=runtime.caml_array_concat,
     caml_array_get=runtime.caml_array_get,
     caml_array_set=runtime.caml_array_set,
     caml_array_sub=runtime.caml_array_sub,
     caml_ba_change_layout=runtime.caml_ba_change_layout,
     caml_ba_create=runtime.caml_ba_create,
     caml_ba_dim_1=runtime.caml_ba_dim_1,
     caml_ba_dim_2=runtime.caml_ba_dim_2,
     caml_ba_kind=runtime.caml_ba_kind,
     caml_ba_num_dims=runtime.caml_ba_num_dims,
     caml_ba_reshape=runtime.caml_ba_reshape,
     caml_ba_slice=runtime.caml_ba_slice,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_blit_string=runtime.caml_blit_string,
     caml_bswap16=runtime.caml_bswap16,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_get16=runtime.caml_bytes_get16,
     caml_bytes_get32=runtime.caml_bytes_get32,
     caml_bytes_get64=runtime.caml_bytes_get64,
     caml_bytes_of_string=runtime.caml_bytes_of_string,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_set16=runtime.caml_bytes_set16,
     caml_bytes_set32=runtime.caml_bytes_set32,
     caml_bytes_set64=runtime.caml_bytes_set64,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_div=runtime.caml_div,
     caml_ephe_set_key=runtime.caml_ephe_set_key,
     caml_ephe_unset_key=runtime.caml_ephe_unset_key,
     caml_equal=runtime.caml_equal,
     caml_fill_bytes=runtime.caml_fill_bytes,
     caml_float_compare=runtime.caml_float_compare,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_floatarray_create=runtime.caml_floatarray_create,
     caml_format_float=runtime.caml_format_float,
     caml_format_int=runtime.caml_format_int,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_get_exception_raw_backtra=runtime.caml_get_exception_raw_backtrace,
     caml_get_public_method=runtime.caml_get_public_method,
     caml_greaterequal=runtime.caml_greaterequal,
     caml_greaterthan=runtime.caml_greaterthan,
     caml_hash=runtime.caml_hash,
     caml_input_value=runtime.caml_input_value,
     caml_int32_bswap=runtime.caml_int32_bswap,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_bswap=runtime.caml_int64_bswap,
     caml_int64_compare=runtime.caml_int64_compare,
     caml_int64_float_of_bits=runtime.caml_int64_float_of_bits,
     caml_int64_format=runtime.caml_int64_format,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_of_int32=runtime.caml_int64_of_int32,
     caml_int64_of_string=runtime.caml_int64_of_string,
     caml_int64_or=runtime.caml_int64_or,
     caml_int64_shift_left=runtime.caml_int64_shift_left,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_int_compare=runtime.caml_int_compare,
     caml_int_of_string=runtime.caml_int_of_string,
     caml_lessequal=runtime.caml_lessequal,
     caml_lessthan=runtime.caml_lessthan,
     caml_make_vect=runtime.caml_make_vect,
     caml_marshal_data_size=runtime.caml_marshal_data_size,
     caml_md5_string=runtime.caml_md5_string,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_channel_size=runtime.caml_ml_channel_size,
     caml_ml_channel_size_64=runtime.caml_ml_channel_size_64,
     caml_ml_close_channel=runtime.caml_ml_close_channel,
     caml_ml_flush=runtime.caml_ml_flush,
     caml_ml_input=runtime.caml_ml_input,
     caml_ml_input_char=runtime.caml_ml_input_char,
     caml_ml_open_descriptor_in=runtime.caml_ml_open_descriptor_in,
     caml_ml_open_descriptor_out=runtime.caml_ml_open_descriptor_out,
     caml_ml_output=runtime.caml_ml_output,
     caml_ml_output_bytes=runtime.caml_ml_output_bytes,
     caml_ml_output_char=runtime.caml_ml_output_char,
     caml_ml_set_binary_mode=runtime.caml_ml_set_binary_mode,
     caml_ml_set_channel_name=runtime.caml_ml_set_channel_name,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_nextafter_float=runtime.caml_nextafter_float,
     caml_notequal=runtime.caml_notequal,
     caml_obj_block=runtime.caml_obj_block,
     caml_obj_make_forward=runtime.caml_obj_make_forward,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_output_value=runtime.caml_output_value,
     caml_register_global=runtime.caml_register_global,
     caml_register_named_value=runtime.caml_register_named_value,
     caml_restore_raw_backtrace=runtime.caml_restore_raw_backtrace,
     caml_set_oo_id=runtime.caml_set_oo_id,
     caml_signbit_float=runtime.caml_signbit_float,
     caml_spacetime_enabled=runtime.caml_spacetime_enabled,
     caml_spacetime_only_works_for_=
      runtime.caml_spacetime_only_works_for_native_code,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_bytes=runtime.caml_string_of_bytes,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_unsafe_get=runtime.caml_string_unsafe_get,
     caml_sys_argv=runtime.caml_sys_argv,
     caml_sys_getenv=runtime.caml_sys_getenv,
     caml_sys_open=runtime.caml_sys_open,
     caml_sys_random_seed=runtime.caml_sys_random_seed,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes("%,"),
     cst_really_input=caml_string_of_jsbytes("really_input"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_output_substring=caml_string_of_jsbytes("output_substring"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_12g=caml_string_of_jsbytes("%.12g"),
     cst=caml_string_of_jsbytes("."),
     cst_false$1=caml_string_of_jsbytes("false"),
     cst_true$1=caml_string_of_jsbytes("true"),
     cst_false$0=caml_string_of_jsbytes("false"),
     cst_true$0=caml_string_of_jsbytes("true"),
     cst_bool_of_string=caml_string_of_jsbytes("bool_of_string"),
     cst_true=caml_string_of_jsbytes("true"),
     cst_false=caml_string_of_jsbytes("false"),
     cst_char_of_int=caml_string_of_jsbytes("char_of_int"),
     cst_Stdlib_Exit=caml_string_of_jsbytes("Stdlib.Exit"),
     cst_Stdlib_Pervasives_Exit=
      caml_string_of_jsbytes("Stdlib.Pervasives.Exit"),
     cst_option_is_None=caml_string_of_jsbytes("option is None"),
     cst_result_is_Ok=caml_string_of_jsbytes("result is Ok _"),
     cst_result_is_Error=caml_string_of_jsbytes("result is Error _"),
     cst_true$2=caml_string_of_jsbytes("true"),
     cst_false$2=caml_string_of_jsbytes("false"),
     cst$1=caml_string_of_jsbytes("\\\\"),
     cst$2=caml_string_of_jsbytes("\\'"),
     cst_b=caml_string_of_jsbytes("\\b"),
     cst_t=caml_string_of_jsbytes("\\t"),
     cst_n=caml_string_of_jsbytes("\\n"),
     cst_r=caml_string_of_jsbytes("\\r"),
     cst_Char_chr=caml_string_of_jsbytes("Char.chr"),
     cst_is_not_a_latin1_character=
      caml_string_of_jsbytes(" is not a latin1 character"),
     cst_04X=caml_string_of_jsbytes("%04X"),
     cst_U=caml_string_of_jsbytes("U+"),
     cst_is_not_an_Unicode_scalar_v=
      caml_string_of_jsbytes(" is not an Unicode scalar value"),
     cst_X=caml_string_of_jsbytes("%X"),
     err_no_pred=caml_string_of_jsbytes("U+0000 has no predecessor"),
     err_no_succ=caml_string_of_jsbytes("U+10FFFF has no successor"),
     cst_Stdlib_Sys_Break=caml_string_of_jsbytes("Stdlib.Sys.Break"),
     ocaml_version=caml_string_of_jsbytes("4.11.0"),
     cst_List_map2=caml_string_of_jsbytes("List.map2"),
     cst_List_iter2=caml_string_of_jsbytes("List.iter2"),
     cst_List_fold_left2=caml_string_of_jsbytes("List.fold_left2"),
     cst_List_fold_right2=caml_string_of_jsbytes("List.fold_right2"),
     cst_List_for_all2=caml_string_of_jsbytes("List.for_all2"),
     cst_List_exists2=caml_string_of_jsbytes("List.exists2"),
     cst_List_combine=caml_string_of_jsbytes("List.combine"),
     cst_List_rev_map2=caml_string_of_jsbytes("List.rev_map2"),
     cst_List_init=caml_string_of_jsbytes("List.init"),
     cst_List_nth$0=caml_string_of_jsbytes("List.nth"),
     cst_nth=caml_string_of_jsbytes("nth"),
     cst_List_nth=caml_string_of_jsbytes("List.nth"),
     cst_tl=caml_string_of_jsbytes("tl"),
     cst_hd=caml_string_of_jsbytes("hd"),
     cst_Bytes_of_seq_cannot_grow_b=
      caml_string_of_jsbytes("Bytes.of_seq: cannot grow bytes"),
     cst_String_rcontains_from_Byte=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst_Bytes_concat=caml_string_of_jsbytes("Bytes.concat"),
     cst_String_blit_Bytes_blit_str=
      caml_string_of_jsbytes("String.blit / Bytes.blit_string"),
     cst_Bytes_blit=caml_string_of_jsbytes("Bytes.blit"),
     cst_String_fill_Bytes_fill=
      caml_string_of_jsbytes("String.fill / Bytes.fill"),
     cst_Bytes_extend=caml_string_of_jsbytes("Bytes.extend"),
     cst_String_sub_Bytes_sub=caml_string_of_jsbytes("String.sub / Bytes.sub"),
     cst_String_rcontains_from_Byte$0=
      caml_string_of_jsbytes("String.rcontains_from / Bytes.rcontains_from"),
     cst_String_contains_from_Bytes$0=
      caml_string_of_jsbytes("String.contains_from / Bytes.contains_from"),
     cst_String_rindex_from_opt_Byt$0=
      caml_string_of_jsbytes("String.rindex_from_opt / Bytes.rindex_from_opt"),
     cst_String_rindex_from_Bytes_r$0=
      caml_string_of_jsbytes("String.rindex_from / Bytes.rindex_from"),
     cst_String_index_from_opt_Byte$0=
      caml_string_of_jsbytes("String.index_from_opt / Bytes.index_from_opt"),
     cst_String_index_from_Bytes_in$0=
      caml_string_of_jsbytes("String.index_from / Bytes.index_from"),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_String_concat=caml_string_of_jsbytes("String.concat"),
     cst$5=caml_string_of_jsbytes("()"),
     cst_Marshal_from_bytes=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_from_bytes$0=caml_string_of_jsbytes("Marshal.from_bytes"),
     cst_Marshal_data_size=caml_string_of_jsbytes("Marshal.data_size"),
     cst_Marshal_to_buffer_substrin=
      caml_string_of_jsbytes("Marshal.to_buffer: substring out of bounds"),
     cst_Obj_Ephemeron_blit_key=
      caml_string_of_jsbytes("Obj.Ephemeron.blit_key"),
     cst_Obj_Ephemeron_check_key=
      caml_string_of_jsbytes("Obj.Ephemeron.check_key"),
     cst_Obj_Ephemeron_unset_key=
      caml_string_of_jsbytes("Obj.Ephemeron.unset_key"),
     cst_Obj_Ephemeron_set_key=caml_string_of_jsbytes("Obj.Ephemeron.set_key"),
     cst_Obj_Ephemeron_get_key_copy=
      caml_string_of_jsbytes("Obj.Ephemeron.get_key_copy"),
     cst_Obj_Ephemeron_get_key=caml_string_of_jsbytes("Obj.Ephemeron.get_key"),
     cst_Obj_Ephemeron_create=caml_string_of_jsbytes("Obj.Ephemeron.create"),
     cst_Obj_extension_constructor$0=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Obj_extension_constructor=
      caml_string_of_jsbytes("Obj.extension_constructor"),
     cst_Array_exists2=caml_string_of_jsbytes("Array.exists2"),
     cst_Array_for_all2=caml_string_of_jsbytes("Array.for_all2"),
     cst_Array_map2_arrays_must_hav=
      caml_string_of_jsbytes("Array.map2: arrays must have the same length"),
     cst_Array_iter2_arrays_must_ha=
      caml_string_of_jsbytes("Array.iter2: arrays must have the same length"),
     cst_Array_blit=caml_string_of_jsbytes("Array.blit"),
     cst_Array_fill=caml_string_of_jsbytes("Array.fill"),
     cst_Array_sub=caml_string_of_jsbytes("Array.sub"),
     cst_Array_init=caml_string_of_jsbytes("Array.init"),
     cst_Stdlib_Array_Bottom=caml_string_of_jsbytes("Stdlib.Array.Bottom"),
     cst_Float_Array_map2_arrays_mu=
      caml_string_of_jsbytes
       ("Float.Array.map2: arrays must have the same length"),
     cst_Float_Array_iter2_arrays_m=
      caml_string_of_jsbytes
       ("Float.Array.iter2: arrays must have the same length"),
     cst_Float_array_blit=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_array_blit$0=caml_string_of_jsbytes("Float.array.blit"),
     cst_Float_Array_fill=caml_string_of_jsbytes("Float.Array.fill"),
     cst_Float_Array_sub=caml_string_of_jsbytes("Float.Array.sub"),
     cst_Float_Array_concat=caml_string_of_jsbytes("Float.Array.concat"),
     cst_Float_Array_init=caml_string_of_jsbytes("Float.Array.init"),
     cst_Stdlib_Float_Array_Bottom=
      caml_string_of_jsbytes("Stdlib.Float.Array.Bottom"),
     cst_d=caml_string_of_jsbytes("%d"),
     cst_d$0=caml_string_of_jsbytes("%d"),
     zero$2=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     one$2=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     minus_one$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     min_int$2=runtime.caml_int64_create_lo_mi_hi(0,0,32768),
     max_int$2=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32767),
     cst_d$1=caml_string_of_jsbytes("%d"),
     cst_Lexing_lex_refill_cannot_g=
      caml_string_of_jsbytes("Lexing.lex_refill: cannot grow buffer"),
     dummy_pos=[0,caml_string_of_jsbytes(""),0,0,-1],
     zero_pos=[0,caml_string_of_jsbytes(""),1,0,0],
     cst_syntax_error=caml_string_of_jsbytes("syntax error"),
     cst_Stdlib_Parsing_YYexit=caml_string_of_jsbytes("Stdlib.Parsing.YYexit"),
     cst_Stdlib_Parsing_Parse_error=
      caml_string_of_jsbytes("Stdlib.Parsing.Parse_error"),
     cst_Set_remove_min_elt=caml_string_of_jsbytes("Set.remove_min_elt"),
     cst_Set_bal=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$0=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$1=caml_string_of_jsbytes("Set.bal"),
     cst_Set_bal$2=caml_string_of_jsbytes("Set.bal"),
     cst_Map_remove_min_elt=caml_string_of_jsbytes("Map.remove_min_elt"),
     cst_Map_bal=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$0=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$1=caml_string_of_jsbytes("Map.bal"),
     cst_Map_bal$2=caml_string_of_jsbytes("Map.bal"),
     cst_Stdlib_Stack_Empty=caml_string_of_jsbytes("Stdlib.Stack.Empty"),
     cst_Stdlib_Queue_Empty=caml_string_of_jsbytes("Stdlib.Queue.Empty"),
     cst_CamlinternalLazy_Undefined=
      caml_string_of_jsbytes("CamlinternalLazy.Undefined"),
     cst_count=caml_string_of_jsbytes("{count = "),
     cst_data=caml_string_of_jsbytes("; data = "),
     cst$6=caml_string_of_jsbytes("}"),
     cst_Sempty=caml_string_of_jsbytes("Sempty"),
     cst_Scons=caml_string_of_jsbytes("Scons ("),
     cst$7=caml_string_of_jsbytes(", "),
     cst$8=caml_string_of_jsbytes(")"),
     cst_Sapp=caml_string_of_jsbytes("Sapp ("),
     cst$9=caml_string_of_jsbytes(", "),
     cst$10=caml_string_of_jsbytes(")"),
     cst_Slazy=caml_string_of_jsbytes("Slazy"),
     cst_Sgen=caml_string_of_jsbytes("Sgen"),
     cst_Sbuffio=caml_string_of_jsbytes("Sbuffio"),
     cst_Stdlib_Stream_Failure=caml_string_of_jsbytes("Stdlib.Stream.Failure"),
     cst_Stdlib_Stream_Error=caml_string_of_jsbytes("Stdlib.Stream.Error"),
     cst_Buffer_truncate=caml_string_of_jsbytes("Buffer.truncate"),
     cst_Buffer_add_channel=caml_string_of_jsbytes("Buffer.add_channel"),
     cst_Buffer_add_substring_add_s=
      caml_string_of_jsbytes("Buffer.add_substring/add_subbytes"),
     cst_Buffer_add_cannot_grow_buf=
      caml_string_of_jsbytes("Buffer.add: cannot grow buffer"),
     cst_Buffer_nth=caml_string_of_jsbytes("Buffer.nth"),
     cst_Buffer_blit=caml_string_of_jsbytes("Buffer.blit"),
     cst_Buffer_sub=caml_string_of_jsbytes("Buffer.sub"),
     cst_c=caml_string_of_jsbytes("%c"),
     cst_s=caml_string_of_jsbytes("%s"),
     cst_i=caml_string_of_jsbytes("%i"),
     cst_li=caml_string_of_jsbytes("%li"),
     cst_ni=caml_string_of_jsbytes("%ni"),
     cst_Li=caml_string_of_jsbytes("%Li"),
     cst_f=caml_string_of_jsbytes("%f"),
     cst_B=caml_string_of_jsbytes("%B"),
     cst$21=caml_string_of_jsbytes("%{"),
     cst$22=caml_string_of_jsbytes("%}"),
     cst$23=caml_string_of_jsbytes("%("),
     cst$24=caml_string_of_jsbytes("%)"),
     cst_a=caml_string_of_jsbytes("%a"),
     cst_t$0=caml_string_of_jsbytes("%t"),
     cst$25=caml_string_of_jsbytes("%?"),
     cst_r$0=caml_string_of_jsbytes("%r"),
     cst_r$1=caml_string_of_jsbytes("%_r"),
     cst_u$0=caml_string_of_jsbytes("%u"),
     cst_Printf_bad_conversion=
      caml_string_of_jsbytes("Printf: bad conversion %["),
     cst_Printf_bad_conversion$0=
      caml_string_of_jsbytes("Printf: bad conversion %_"),
     cst$30=caml_string_of_jsbytes("@{"),
     cst$31=caml_string_of_jsbytes("@["),
     cst$32=caml_string_of_jsbytes("@{"),
     cst$33=caml_string_of_jsbytes("@["),
     cst$34=caml_string_of_jsbytes("@{"),
     cst$35=caml_string_of_jsbytes("@["),
     cst_0=caml_string_of_jsbytes("0"),
     cst_padding=caml_string_of_jsbytes("padding"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst$40=caml_string_of_jsbytes("'*'"),
     cst$38=caml_string_of_jsbytes("'-'"),
     cst_0$2=caml_string_of_jsbytes("'0'"),
     cst$39=caml_string_of_jsbytes("'*'"),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst_0$1=caml_string_of_jsbytes("0"),
     cst_precision$0=caml_string_of_jsbytes("precision"),
     cst_precision$1=caml_string_of_jsbytes("precision"),
     cst$41=caml_string_of_jsbytes("'+'"),
     cst$42=caml_string_of_jsbytes("'#'"),
     cst$43=caml_string_of_jsbytes("' '"),
     cst_padding$0=caml_string_of_jsbytes("`padding'"),
     cst_precision$2=caml_string_of_jsbytes("`precision'"),
     cst$44=caml_string_of_jsbytes("'+'"),
     cst$45=caml_string_of_jsbytes("'_'"),
     sub_format=[0,0,caml_string_of_jsbytes("")],
     formatting_lit=[0,caml_string_of_jsbytes("@;"),1,0],
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_character=caml_string_of_jsbytes("character ')'"),
     cst_character$0=caml_string_of_jsbytes("character '}'"),
     cst$49=caml_string_of_jsbytes("'#'"),
     cst$46=caml_string_of_jsbytes("'+'"),
     cst$47=caml_string_of_jsbytes("'+'"),
     cst$48=caml_string_of_jsbytes("' '"),
     cst$50=caml_string_of_jsbytes("'+'"),
     cst_non_zero_widths_are_unsupp=
      caml_string_of_jsbytes
       ("non-zero widths are unsupported for %c conversions"),
     cst_unexpected_end_of_format=
      caml_string_of_jsbytes("unexpected end of format"),
     cst$36=caml_string_of_jsbytes(""),
     cst$37=caml_string_of_jsbytes(""),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_hov=caml_string_of_jsbytes("hov"),
     cst_hv=caml_string_of_jsbytes("hv"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_nan=caml_string_of_jsbytes("nan"),
     cst_neg_infinity=caml_string_of_jsbytes("neg_infinity"),
     cst_infinity=caml_string_of_jsbytes("infinity"),
     cst$29=caml_string_of_jsbytes("."),
     cst_nd$0=caml_string_of_jsbytes("%+nd"),
     cst_nd$1=caml_string_of_jsbytes("% nd"),
     cst_ni$1=caml_string_of_jsbytes("%+ni"),
     cst_ni$2=caml_string_of_jsbytes("% ni"),
     cst_nx=caml_string_of_jsbytes("%nx"),
     cst_nx$0=caml_string_of_jsbytes("%#nx"),
     cst_nX=caml_string_of_jsbytes("%nX"),
     cst_nX$0=caml_string_of_jsbytes("%#nX"),
     cst_no=caml_string_of_jsbytes("%no"),
     cst_no$0=caml_string_of_jsbytes("%#no"),
     cst_nd=caml_string_of_jsbytes("%nd"),
     cst_ni$0=caml_string_of_jsbytes("%ni"),
     cst_nu=caml_string_of_jsbytes("%nu"),
     cst_ld$0=caml_string_of_jsbytes("%+ld"),
     cst_ld$1=caml_string_of_jsbytes("% ld"),
     cst_li$1=caml_string_of_jsbytes("%+li"),
     cst_li$2=caml_string_of_jsbytes("% li"),
     cst_lx=caml_string_of_jsbytes("%lx"),
     cst_lx$0=caml_string_of_jsbytes("%#lx"),
     cst_lX=caml_string_of_jsbytes("%lX"),
     cst_lX$0=caml_string_of_jsbytes("%#lX"),
     cst_lo=caml_string_of_jsbytes("%lo"),
     cst_lo$0=caml_string_of_jsbytes("%#lo"),
     cst_ld=caml_string_of_jsbytes("%ld"),
     cst_li$0=caml_string_of_jsbytes("%li"),
     cst_lu=caml_string_of_jsbytes("%lu"),
     cst_Ld$0=caml_string_of_jsbytes("%+Ld"),
     cst_Ld$1=caml_string_of_jsbytes("% Ld"),
     cst_Li$1=caml_string_of_jsbytes("%+Li"),
     cst_Li$2=caml_string_of_jsbytes("% Li"),
     cst_Lx=caml_string_of_jsbytes("%Lx"),
     cst_Lx$0=caml_string_of_jsbytes("%#Lx"),
     cst_LX=caml_string_of_jsbytes("%LX"),
     cst_LX$0=caml_string_of_jsbytes("%#LX"),
     cst_Lo=caml_string_of_jsbytes("%Lo"),
     cst_Lo$0=caml_string_of_jsbytes("%#Lo"),
     cst_Ld=caml_string_of_jsbytes("%Ld"),
     cst_Li$0=caml_string_of_jsbytes("%Li"),
     cst_Lu=caml_string_of_jsbytes("%Lu"),
     cst_d$3=caml_string_of_jsbytes("%+d"),
     cst_d$4=caml_string_of_jsbytes("% d"),
     cst_i$1=caml_string_of_jsbytes("%+i"),
     cst_i$2=caml_string_of_jsbytes("% i"),
     cst_x=caml_string_of_jsbytes("%x"),
     cst_x$0=caml_string_of_jsbytes("%#x"),
     cst_X$0=caml_string_of_jsbytes("%X"),
     cst_X$1=caml_string_of_jsbytes("%#X"),
     cst_o=caml_string_of_jsbytes("%o"),
     cst_o$0=caml_string_of_jsbytes("%#o"),
     cst_d$2=caml_string_of_jsbytes("%d"),
     cst_i$0=caml_string_of_jsbytes("%i"),
     cst_u=caml_string_of_jsbytes("%u"),
     cst$26=caml_string_of_jsbytes("%!"),
     cst$27=caml_string_of_jsbytes("@{"),
     cst$28=caml_string_of_jsbytes("@["),
     cst_0c=caml_string_of_jsbytes("0c"),
     cst$20=caml_string_of_jsbytes("%%"),
     cst$12=caml_string_of_jsbytes("@]"),
     cst$13=caml_string_of_jsbytes("@}"),
     cst$14=caml_string_of_jsbytes("@?"),
     cst$15=caml_string_of_jsbytes("@\n"),
     cst$16=caml_string_of_jsbytes("@."),
     cst$17=caml_string_of_jsbytes("@@"),
     cst$18=caml_string_of_jsbytes("@%"),
     cst$19=caml_string_of_jsbytes("@"),
     cst$11=caml_string_of_jsbytes(".*"),
     cst_CamlinternalFormat_Type_mi=
      caml_string_of_jsbytes("CamlinternalFormat.Type_mismatch"),
     cst$58=caml_string_of_jsbytes(""),
     cst$59=caml_string_of_jsbytes("\n"),
     cst_a_boolean=caml_string_of_jsbytes("a boolean"),
     cst_an_integer=caml_string_of_jsbytes("an integer"),
     cst_an_integer$0=caml_string_of_jsbytes("an integer"),
     cst_a_float=caml_string_of_jsbytes("a float"),
     cst_a_float$0=caml_string_of_jsbytes("a float"),
     cst$55=caml_string_of_jsbytes(""),
     cst$56=caml_string_of_jsbytes(" "),
     cst$57=caml_string_of_jsbytes(""),
     cst_one_of=caml_string_of_jsbytes("one of: "),
     cst_Arg_Expand_is_is_only_allo=
      caml_string_of_jsbytes
       ("Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"),
     cst_no_argument=caml_string_of_jsbytes("no argument"),
     cst$54=caml_string_of_jsbytes("(?)"),
     cst_help$3=caml_string_of_jsbytes("--help"),
     cst_help$4=caml_string_of_jsbytes("-help"),
     cst_help$2=caml_string_of_jsbytes("-help"),
     cst_Display_this_list_of_optio=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help=caml_string_of_jsbytes("-help"),
     cst_help$1=caml_string_of_jsbytes("--help"),
     cst_Display_this_list_of_optio$0=
      caml_string_of_jsbytes(" Display this list of options"),
     cst_help$0=caml_string_of_jsbytes("--help"),
     cst$51=caml_string_of_jsbytes("}"),
     cst$52=caml_string_of_jsbytes("|"),
     cst$53=caml_string_of_jsbytes("{"),
     cst_none=caml_string_of_jsbytes("<none>"),
     cst_Stdlib_Arg_Bad=caml_string_of_jsbytes("Stdlib.Arg.Bad"),
     cst_Stdlib_Arg_Help=caml_string_of_jsbytes("Stdlib.Arg.Help"),
     cst_Stdlib_Arg_Stop=caml_string_of_jsbytes("Stdlib.Arg.Stop"),
     cst$61=caml_string_of_jsbytes(""),
     cst$65=caml_string_of_jsbytes(""),
     cst_Program_not_linked_with_g_=
      caml_string_of_jsbytes
       ("(Program not linked with -g, cannot print stack backtrace)\n"),
     cst_Raised_at=caml_string_of_jsbytes("Raised at"),
     cst_Re_raised_at=caml_string_of_jsbytes("Re-raised at"),
     cst_Raised_by_primitive_operat=
      caml_string_of_jsbytes("Raised by primitive operation at"),
     cst_Called_from=caml_string_of_jsbytes("Called from"),
     cst_inlined=caml_string_of_jsbytes(" (inlined)"),
     cst$64=caml_string_of_jsbytes(""),
     partial=[4,0,0,0,[12,45,[4,0,0,0,0]]],
     cst_Out_of_memory=caml_string_of_jsbytes("Out of memory"),
     cst_Stack_overflow=caml_string_of_jsbytes("Stack overflow"),
     cst_Pattern_matching_failed=
      caml_string_of_jsbytes("Pattern matching failed"),
     cst_Assertion_failed=caml_string_of_jsbytes("Assertion failed"),
     cst_Undefined_recursive_module=
      caml_string_of_jsbytes("Undefined recursive module"),
     cst$62=caml_string_of_jsbytes(""),
     cst$63=caml_string_of_jsbytes(""),
     cst$60=caml_string_of_jsbytes("_"),
     locfmt=
      [0,
       [11,
        caml_string_of_jsbytes('File "'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('", line '),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", characters "),
            [4,
             0,
             0,
             0,
             [12,45,[4,0,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]]]]]]]],
       caml_string_of_jsbytes('File "%s", line %d, characters %d-%d: %s')],
     cst_Fun_Finally_raised=caml_string_of_jsbytes("Fun.Finally_raised: "),
     cst_Stdlib_Fun_Finally_raised=
      caml_string_of_jsbytes("Stdlib.Fun.Finally_raised"),
     cst_Digest_from_hex$0=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_from_hex=caml_string_of_jsbytes("Digest.from_hex"),
     cst_Digest_to_hex=caml_string_of_jsbytes("Digest.to_hex"),
     cst_Digest_substring=caml_string_of_jsbytes("Digest.substring"),
     cst_Random_int64=caml_string_of_jsbytes("Random.int64"),
     cst_Random_int32=caml_string_of_jsbytes("Random.int32"),
     cst_Random_int=caml_string_of_jsbytes("Random.int"),
     cst_x$1=caml_string_of_jsbytes("x"),
     cst_OCAMLRUNPARAM=caml_string_of_jsbytes("OCAMLRUNPARAM"),
     cst_CAMLRUNPARAM=caml_string_of_jsbytes("CAMLRUNPARAM"),
     cst$66=caml_string_of_jsbytes(""),
     cst_Weak_Make_hash_bucket_cann=
      caml_string_of_jsbytes("Weak.Make: hash bucket cannot grow more"),
     cst_Weak_fill=caml_string_of_jsbytes("Weak.fill"),
     cst_Weak_blit=caml_string_of_jsbytes("Weak.blit"),
     cst_Weak_check=caml_string_of_jsbytes("Weak.check"),
     cst_Weak_get_copy=caml_string_of_jsbytes("Weak.get_copy"),
     cst_Weak_get=caml_string_of_jsbytes("Weak.get"),
     cst_Weak_set=caml_string_of_jsbytes("Weak.set"),
     cst_Weak_create=caml_string_of_jsbytes("Weak.create"),
     cst$84=caml_string_of_jsbytes(""),
     cst$85=caml_string_of_jsbytes(""),
     cst$83=caml_string_of_jsbytes("."),
     cst$80=caml_string_of_jsbytes(">"),
     cst$81=caml_string_of_jsbytes("<\/"),
     cst$82=caml_string_of_jsbytes(""),
     cst$77=caml_string_of_jsbytes(">"),
     cst$78=caml_string_of_jsbytes("<"),
     cst$79=caml_string_of_jsbytes(""),
     cst$76=caml_string_of_jsbytes("\n"),
     cst_Format_pp_set_geometry=
      caml_string_of_jsbytes("Format.pp_set_geometry: "),
     cst$72=caml_string_of_jsbytes(""),
     cst$73=caml_string_of_jsbytes(""),
     cst$74=caml_string_of_jsbytes(""),
     cst$75=caml_string_of_jsbytes(""),
     cst$68=caml_string_of_jsbytes(""),
     cst$69=caml_string_of_jsbytes(""),
     cst$70=caml_string_of_jsbytes(""),
     cst$71=caml_string_of_jsbytes(""),
     cst$67=caml_string_of_jsbytes(""),
     cst_Stdlib_Format_String_tag=
      caml_string_of_jsbytes("Stdlib.Format.String_tag"),
     cst_end_of_input_not_found=
      caml_string_of_jsbytes("end of input not found"),
     cst_scanf_bad_conversion_a=
      caml_string_of_jsbytes('scanf: bad conversion "%a"'),
     cst_scanf_bad_conversion_t=
      caml_string_of_jsbytes('scanf: bad conversion "%t"'),
     cst_scanf_missing_reader=caml_string_of_jsbytes("scanf: missing reader"),
     cst_scanf_bad_conversion_custo=
      caml_string_of_jsbytes('scanf: bad conversion "%?" (custom converter)'),
     cst_scanf_bad_conversion=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$0=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst_scanf_bad_conversion$1=
      caml_string_of_jsbytes('scanf: bad conversion "%-"'),
     cst_scanf_bad_conversion$2=
      caml_string_of_jsbytes('scanf: bad conversion "%*"'),
     cst$91=caml_string_of_jsbytes('"'),
     cst$92=caml_string_of_jsbytes('"'),
     cst$89=caml_string_of_jsbytes('"'),
     cst$90=caml_string_of_jsbytes('"'),
     cst$88=caml_string_of_jsbytes('"'),
     cst_in_format=caml_string_of_jsbytes(' in format "'),
     cst_an=caml_string_of_jsbytes("an"),
     cst_x$2=caml_string_of_jsbytes("x"),
     cst_nfinity=caml_string_of_jsbytes("nfinity"),
     cst_digits=caml_string_of_jsbytes("digits"),
     cst_decimal_digits=caml_string_of_jsbytes("decimal digits"),
     cst_0b=caml_string_of_jsbytes("0b"),
     cst_0o=caml_string_of_jsbytes("0o"),
     cst_0u=caml_string_of_jsbytes("0u"),
     cst_0x=caml_string_of_jsbytes("0x"),
     cst_false$3=caml_string_of_jsbytes("false"),
     cst_true$3=caml_string_of_jsbytes("true"),
     cst_not_a_valid_float_in_hexad=
      caml_string_of_jsbytes("not a valid float in hexadecimal notation"),
     cst_no_dot_or_exponent_part_fo=
      caml_string_of_jsbytes("no dot or exponent part found in float token"),
     cst$87=caml_string_of_jsbytes("-"),
     cst_unnamed_function=caml_string_of_jsbytes("unnamed function"),
     cst_unnamed_character_string=
      caml_string_of_jsbytes("unnamed character string"),
     cst_unnamed_Stdlib_input_chann=
      caml_string_of_jsbytes("unnamed Stdlib input channel"),
     cst$86=caml_string_of_jsbytes("-"),
     cst_Stdlib_Scanf_Scan_failure=
      caml_string_of_jsbytes("Stdlib.Scanf.Scan_failure"),
     cst_binary=caml_string_of_jsbytes("binary"),
     cst_octal=caml_string_of_jsbytes("octal"),
     cst_hexadecimal=caml_string_of_jsbytes("hexadecimal"),
     cst_a_Char=caml_string_of_jsbytes("a Char"),
     cst_a_String=caml_string_of_jsbytes("a String"),
     cst$93=caml_string_of_jsbytes(""),
     cst$94=caml_string_of_jsbytes(""),
     cst$95=caml_string_of_jsbytes(""),
     cst$96=caml_string_of_jsbytes(""),
     cst$97=caml_string_of_jsbytes(""),
     cst$99=caml_string_of_jsbytes(""),
     cst$98=caml_string_of_jsbytes(""),
     cst_Illegal_character=caml_string_of_jsbytes("Illegal character "),
     cst_Filename_chop_extension=
      caml_string_of_jsbytes("Filename.chop_extension"),
     cst$127=caml_string_of_jsbytes(""),
     cst_Filename_chop_suffix=caml_string_of_jsbytes("Filename.chop_suffix"),
     cst$126=caml_string_of_jsbytes(""),
     cst_2_1$0=caml_string_of_jsbytes(" 2>&1"),
     cst_2$0=caml_string_of_jsbytes(" 2>"),
     cst$125=caml_string_of_jsbytes(""),
     cst$117=caml_string_of_jsbytes(" >"),
     cst$124=caml_string_of_jsbytes(""),
     cst$118=caml_string_of_jsbytes(" <"),
     cst$123=caml_string_of_jsbytes(""),
     cst$119=caml_string_of_jsbytes(" "),
     cst$120=caml_string_of_jsbytes(" "),
     cst$121=caml_string_of_jsbytes('"'),
     cst$122=caml_string_of_jsbytes(""),
     cst_Filename_quote_command_bad=
      caml_string_of_jsbytes("Filename.quote_command: bad file name "),
     cst$115=caml_string_of_jsbytes('"'),
     cst$116=caml_string_of_jsbytes('"'),
     cst$113=caml_string_of_jsbytes("./"),
     cst$112=caml_string_of_jsbytes(".\\"),
     cst$111=caml_string_of_jsbytes("../"),
     cst$110=caml_string_of_jsbytes("..\\"),
     cst_2_1=caml_string_of_jsbytes(" 2>&1"),
     cst_2=caml_string_of_jsbytes(" 2>"),
     cst$109=caml_string_of_jsbytes(""),
     cst$104=caml_string_of_jsbytes(" >"),
     cst$108=caml_string_of_jsbytes(""),
     cst$105=caml_string_of_jsbytes(" <"),
     cst$107=caml_string_of_jsbytes(""),
     cst$106=caml_string_of_jsbytes(" "),
     cst$103=caml_string_of_jsbytes("./"),
     cst$102=caml_string_of_jsbytes("../"),
     cst$101=caml_string_of_jsbytes(""),
     cst$100=caml_string_of_jsbytes(""),
     null$0=caml_string_of_jsbytes("/dev/null"),
     current_dir_name=caml_string_of_jsbytes("."),
     parent_dir_name=caml_string_of_jsbytes(".."),
     dir_sep=caml_string_of_jsbytes("/"),
     cst_TMPDIR=caml_string_of_jsbytes("TMPDIR"),
     cst_tmp=caml_string_of_jsbytes("/tmp"),
     quotequote=caml_string_of_jsbytes("'\\''"),
     null$1=caml_string_of_jsbytes("NUL"),
     current_dir_name$0=caml_string_of_jsbytes("."),
     parent_dir_name$0=caml_string_of_jsbytes(".."),
     dir_sep$0=caml_string_of_jsbytes("\\"),
     cst_TEMP=caml_string_of_jsbytes("TEMP"),
     cst$114=caml_string_of_jsbytes("."),
     null$2=caml_string_of_jsbytes("/dev/null"),
     current_dir_name$1=caml_string_of_jsbytes("."),
     parent_dir_name$1=caml_string_of_jsbytes(".."),
     dir_sep$1=caml_string_of_jsbytes("/"),
     cst_Cygwin=caml_string_of_jsbytes("Cygwin"),
     cst_Win32=caml_string_of_jsbytes("Win32"),
     zero$4=[254,0.,0.],
     one$4=[254,1.,0.],
     i=[254,0.,1.],
     cst_Series_is_closed$0=caml_string_of_jsbytes("Series is closed"),
     cst_Series_is_closed=caml_string_of_jsbytes("Series is closed"),
     cst_Bigarray_array3_of_genarra=
      caml_string_of_jsbytes("Bigarray.array3_of_genarray"),
     cst_Bigarray_array2_of_genarra=
      caml_string_of_jsbytes("Bigarray.array2_of_genarray"),
     cst_Bigarray_array1_of_genarra=
      caml_string_of_jsbytes("Bigarray.array1_of_genarray"),
     cst_Bigarray_array0_of_genarra=
      caml_string_of_jsbytes("Bigarray.array0_of_genarray"),
     cst_Bigarray_Array3_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array3_of_array_n$0=
      caml_string_of_jsbytes("Bigarray.Array3.of_array: non-cubic data"),
     cst_Bigarray_Array2_of_array_n=
      caml_string_of_jsbytes("Bigarray.Array2.of_array: non-rectangular data"),
     Invalid_argument=global_data.Invalid_argument,
     Failure=global_data.Failure,
     Match_failure=global_data.Match_failure,
     Assert_failure=global_data.Assert_failure,
     Not_found=global_data.Not_found,
     Out_of_memory=global_data.Out_of_memory,
     Stack_overflow=global_data.Stack_overflow,
     Sys_error=global_data.Sys_error,
     End_of_file=global_data.End_of_file,
     Division_by_zero=global_data.Division_by_zero,
     Sys_blocked_io=global_data.Sys_blocked_io,
     Undefined_recursive_module=global_data.Undefined_recursive_module,
     _l_=[0,0,[0,6,0]],
     _k_=[0,0,[0,7,0]],
     _j_=[0,1,[0,3,[0,4,[0,6,0]]]],
     _i_=[0,1,[0,3,[0,4,[0,7,0]]]],
     _g_=[0,1],
     _h_=[0,0],
     _a_=runtime.caml_int64_create_lo_mi_hi(0,0,32752),
     _b_=runtime.caml_int64_create_lo_mi_hi(0,0,65520),
     _c_=runtime.caml_int64_create_lo_mi_hi(1,0,32752),
     _d_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,32751),
     _e_=runtime.caml_int64_create_lo_mi_hi(0,0,16),
     _f_=runtime.caml_int64_create_lo_mi_hi(0,0,15536),
     _p_=[0,0,0],
     _t_=[0,caml_string_of_jsbytes("array.ml"),258,4],
     _v_=[0,caml_string_of_jsbytes("float.ml"),381,6],
     _u_=[0,caml_string_of_jsbytes("float.ml"),208,14],
     _G_=runtime.caml_int64_create_lo_mi_hi(16777215,16777215,65535),
     _F_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _E_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _D_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _H_=[0,0,0,0],
     _I_=[0,0,0],
     _J_=[0,caml_string_of_jsbytes("set.ml"),569,18],
     _K_=[0,0,0,0],
     _L_=[0,caml_string_of_jsbytes("map.ml"),399,10],
     _M_=[0,0,0],
     _N_=[0,caml_string_of_jsbytes("stream.ml"),53,12],
     _O_=[0,0],
     _P_=[0,caml_string_of_jsbytes("stream.ml"),82,12],
     _Z_=[0,caml_string_of_jsbytes("buffer.ml"),282,9],
     _Y_=[0,caml_string_of_jsbytes("buffer.ml"),263,2],
     _X_=[0,caml_string_of_jsbytes("buffer.ml"),195,19],
     _W_=[0,caml_string_of_jsbytes("buffer.ml"),213,8],
     _V_=[0,caml_string_of_jsbytes("buffer.ml"),174,19],
     _U_=[0,caml_string_of_jsbytes("buffer.ml"),192,8],
     _T_=[0,caml_string_of_jsbytes("buffer.ml"),138,19],
     _S_=[0,caml_string_of_jsbytes("buffer.ml"),171,8],
     _R_=[0,caml_string_of_jsbytes("buffer.ml"),93,2],
     _Q_=[0,caml_string_of_jsbytes("buffer.ml"),94,2],
     _$_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),850,23],
     _ak_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),814,21],
     _ac_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),815,21],
     _al_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),818,21],
     _ad_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),819,21],
     _am_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),822,19],
     _ae_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),823,19],
     _an_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),826,22],
     _af_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),827,22],
     _ao_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),831,30],
     _ag_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),832,30],
     _ai_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),836,26],
     _aa_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),837,26],
     _aj_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),846,28],
     _ab_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),847,28],
     _ah_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),851,23],
     _aq_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1558,4],
     _ar_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1626,39],
     _as_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1649,31],
     _at_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1650,31],
     _au_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),1830,8],
     _aY_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aX_=
      [0,
       [11,
        caml_string_of_jsbytes("bad input: format type mismatch between "),
        [3,0,[11,caml_string_of_jsbytes(" and "),[3,0,0]]]],
       caml_string_of_jsbytes
        ("bad input: format type mismatch between %S and %S")],
     _aA_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", duplicate flag "),[1,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, duplicate flag %C")],
     _aB_=[0,1,0],
     _aC_=[0,0],
     _aD_=[1,0],
     _aE_=[1,1],
     _aG_=[1,1],
     _aF_=[1,1],
     _aK_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", flag "),
            [1,
             [11,
              caml_string_of_jsbytes(" is only allowed after the '"),
              [12,
               37,
               [11,
                caml_string_of_jsbytes("', before padding and precision"),
                0]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, flag %C is only allowed after the '%%', before padding and precision")],
     _aH_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(', invalid conversion "'),
            [12,37,[0,[12,34,0]]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: at character number %d, invalid conversion "%%%c"')],
     _aI_=[0,0],
     _aJ_=[0,0],
     _aL_=[0,[12,64,0]],
     _aM_=[0,caml_string_of_jsbytes("@ "),1,0],
     _aN_=[0,caml_string_of_jsbytes("@,"),0,0],
     _aO_=[2,60],
     _aP_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": '"),
          [12,
           37,
           [11,
            caml_string_of_jsbytes
             ("' alone is not accepted in character sets, use "),
            [12,
             37,
             [12,
              37,
              [11,
               caml_string_of_jsbytes(" instead at position "),
               [4,0,0,0,[12,46,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: '%%' alone is not accepted in character sets, use %%%% instead at position %d.")],
     _aQ_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": integer "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(" is greater than the limit "),
            [4,0,0,0,0]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: integer %d is greater than the limit %d")],
     _aR_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2837,11],
     _aS_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(': unclosed sub-format, expected "'),
          [12,
           37,
           [0,
            [11,caml_string_of_jsbytes('" at character number '),[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes
        ('invalid format %S: unclosed sub-format, expected "%%%c" at character number %d')],
     _aT_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2899,34],
     _aU_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2935,28],
     _aV_=[0,caml_string_of_jsbytes("camlinternalFormat.ml"),2957,11],
     _aW_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,
             0,
             [11,
              caml_string_of_jsbytes(" is incompatible with '"),
              [0,[11,caml_string_of_jsbytes("' in sub-format "),[3,0,0]]]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s is incompatible with '%c' in sub-format %S")],
     _az_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", "),
            [2,0,[11,caml_string_of_jsbytes(" expected, read "),[1,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, %s expected, read %C")],
     _ay_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,
           0,
           0,
           0,
           [11,
            caml_string_of_jsbytes(", '"),
            [0,[11,caml_string_of_jsbytes("' without "),[2,0,0]]]]]]]],
       caml_string_of_jsbytes
        ("invalid format %S: at character number %d, '%c' without %s")],
     _ax_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid format "),
        [3,
         0,
         [11,
          caml_string_of_jsbytes(": at character number "),
          [4,0,0,0,[11,caml_string_of_jsbytes(", "),[2,0,0]]]]]],
       caml_string_of_jsbytes("invalid format %S: at character number %d, %s")],
     _aw_=
      [0,
       [11,caml_string_of_jsbytes("invalid box description "),[3,0,0]],
       caml_string_of_jsbytes("invalid box description %S")],
     _av_=[0,0,4],
     _ap_=[0,103],
     ___=[0,0,0],
     _bi_=[0,[2,0,[0,0]],caml_string_of_jsbytes("%s%c")],
     _bc_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bd_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _ba_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _bb_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a__=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a$_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a4_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": unknown option '"),
         [2,0,[11,caml_string_of_jsbytes("'.\n"),0]]]],
       caml_string_of_jsbytes("%s: unknown option '%s'.\n")],
     _a7_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": wrong argument '"),
         [2,
          0,
          [11,
           caml_string_of_jsbytes("'; option '"),
           [2,
            0,
            [11,
             caml_string_of_jsbytes("' expects "),
             [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]]]]]],
       caml_string_of_jsbytes
        ("%s: wrong argument '%s'; option '%s' expects %s.\n")],
     _a8_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": option '"),
         [2,0,[11,caml_string_of_jsbytes("' needs an argument.\n"),0]]]],
       caml_string_of_jsbytes("%s: option '%s' needs an argument.\n")],
     _a9_=
      [0,
       [2,
        0,
        [11,
         caml_string_of_jsbytes(": "),
         [2,0,[11,caml_string_of_jsbytes(".\n"),0]]]],
       caml_string_of_jsbytes("%s: %s.\n")],
     _a5_=[0,caml_string_of_jsbytes("-help")],
     _a6_=[0,caml_string_of_jsbytes("--help")],
     _a3_=[0,[2,0,0],caml_string_of_jsbytes("%s")],
     _a2_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _a1_=[0,caml_string_of_jsbytes("-help")],
     _aZ_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[12,10,0]]]]],
       caml_string_of_jsbytes("  %s %s\n")],
     _a0_=
      [0,
       [11,caml_string_of_jsbytes("  "),[2,0,[12,32,[2,0,[2,0,[12,10,0]]]]]],
       caml_string_of_jsbytes("  %s %s%s\n")],
     _bn_=
      [0,
       [11,caml_string_of_jsbytes(", "),[2,0,[2,0,0]]],
       caml_string_of_jsbytes(", %s%s")],
     _bx_=
      [0,
       [11,caml_string_of_jsbytes("Fatal error: exception "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Fatal error: exception %s\n")],
     _bw_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bu_=[0,[2,0,[12,10,0]],caml_string_of_jsbytes("%s\n")],
     _bv_=
      [0,
       [11,
        caml_string_of_jsbytes
         ("(Program not linked with -g, cannot print stack backtrace)\n"),
        0],
       caml_string_of_jsbytes
        ("(Program not linked with -g, cannot print stack backtrace)\n")],
     _bs_=
      [0,
       [2,
        0,
        [12,
         32,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(' in file "'),
           [2,
            0,
            [12,
             34,
             [2,
              0,
              [11,
               caml_string_of_jsbytes(", line "),
               [4,0,0,0,[11,caml_string_of_jsbytes(", characters "),partial]]]]]]]]]],
       caml_string_of_jsbytes
        ('%s %s in file "%s"%s, line %d, characters %d-%d')],
     _bt_=
      [0,
       [2,0,[11,caml_string_of_jsbytes(" unknown location"),0]],
       caml_string_of_jsbytes("%s unknown location")],
     _br_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bq_=
      [0,
       [11,caml_string_of_jsbytes("Uncaught exception: "),[2,0,[12,10,0]]],
       caml_string_of_jsbytes("Uncaught exception: %s\n")],
     _bo_=[0,[12,40,[2,0,[2,0,[12,41,0]]]],caml_string_of_jsbytes("(%s%s)")],
     _bp_=[0,[12,40,[2,0,[12,41,0]]],caml_string_of_jsbytes("(%s)")],
     _bm_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bl_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _bF_=
      [0,
       [11,caml_string_of_jsbytes("minor_collections: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("minor_collections: %d\n")],
     _bG_=
      [0,
       [11,caml_string_of_jsbytes("major_collections: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("major_collections: %d\n")],
     _bH_=
      [0,
       [11,caml_string_of_jsbytes("compactions:       "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("compactions:       %d\n")],
     _bI_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bJ_=[0,[8,[0,0,0],0,[0,0],0],caml_string_of_jsbytes("%.0f")],
     _bK_=
      [0,
       [11,
        caml_string_of_jsbytes("minor_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("minor_words:    %*.0f\n")],
     _bL_=
      [0,
       [11,
        caml_string_of_jsbytes("promoted_words: "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("promoted_words: %*.0f\n")],
     _bM_=
      [0,
       [11,
        caml_string_of_jsbytes("major_words:    "),
        [8,[0,0,0],[1,1],[0,0],[12,10,0]]],
       caml_string_of_jsbytes("major_words:    %*.0f\n")],
     _bN_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bO_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bP_=
      [0,
       [11,caml_string_of_jsbytes("top_heap_words: "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("top_heap_words: %*d\n")],
     _bQ_=
      [0,
       [11,caml_string_of_jsbytes("heap_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("heap_words:     %*d\n")],
     _bR_=
      [0,
       [11,caml_string_of_jsbytes("live_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("live_words:     %*d\n")],
     _bS_=
      [0,
       [11,caml_string_of_jsbytes("free_words:     "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("free_words:     %*d\n")],
     _bT_=
      [0,
       [11,caml_string_of_jsbytes("largest_free:   "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("largest_free:   %*d\n")],
     _bU_=
      [0,
       [11,caml_string_of_jsbytes("fragments:      "),[4,0,[1,1],0,[12,10,0]]],
       caml_string_of_jsbytes("fragments:      %*d\n")],
     _bV_=[0,[12,10,0],caml_string_of_jsbytes("\n")],
     _bW_=
      [0,
       [11,caml_string_of_jsbytes("live_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("live_blocks: %d\n")],
     _bX_=
      [0,
       [11,caml_string_of_jsbytes("free_blocks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("free_blocks: %d\n")],
     _bY_=
      [0,
       [11,caml_string_of_jsbytes("heap_chunks: "),[4,0,0,0,[12,10,0]]],
       caml_string_of_jsbytes("heap_chunks: %d\n")],
     _b6_=runtime.caml_int64_create_lo_mi_hi(1,0,0),
     _b7_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _b8_=
      [0,
       987910699,
       495797812,
       364182224,
       414272206,
       318284740,
       990407751,
       383018966,
       270373319,
       840823159,
       24560019,
       536292337,
       512266505,
       189156120,
       730249596,
       143776328,
       51606627,
       140166561,
       366354223,
       1003410265,
       700563762,
       981890670,
       913149062,
       526082594,
       1021425055,
       784300257,
       667753350,
       630144451,
       949649812,
       48546892,
       415514493,
       258888527,
       511570777,
       89983870,
       283659902,
       308386020,
       242688715,
       482270760,
       865188196,
       1027664170,
       207196989,
       193777847,
       619708188,
       671350186,
       149669678,
       257044018,
       87658204,
       558145612,
       183450813,
       28133145,
       901332182,
       710253903,
       510646120,
       652377910,
       409934019,
       801085050],
     _ca_=[0,0],
     _b$_=[0,caml_string_of_jsbytes("hashtbl.ml"),102,23],
     _cg_=[3,0,3],
     _cf_=[1,caml_string_of_jsbytes("max_indent < 2")],
     _cd_=[1,caml_string_of_jsbytes("margin <= max_indent")],
     _ce_=[0,0],
     _cc_=[0,caml_string_of_jsbytes("")],
     _cb_=[0,caml_string_of_jsbytes(""),0,caml_string_of_jsbytes("")],
     _cw_=[0,91],
     _cv_=[0,123],
     _cx_=[0,caml_string_of_jsbytes("scanf.ml"),1453,13],
     _cy_=[0,[3,0,[10,0]],caml_string_of_jsbytes("%S%!")],
     _cu_=[0,37,caml_string_of_jsbytes("")],
     _ct_=
      [0,
       [11,
        caml_string_of_jsbytes("scanf: bad input at char number "),
        [4,3,0,0,[11,caml_string_of_jsbytes(": "),[2,0,0]]]],
       caml_string_of_jsbytes("scanf: bad input at char number %i: %s")],
     _cs_=
      [0,
       [11,
        caml_string_of_jsbytes("the character "),
        [1,[11,caml_string_of_jsbytes(" cannot start a boolean"),0]]],
       caml_string_of_jsbytes("the character %C cannot start a boolean")],
     _cr_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character hexadecimal encoding \\"),
        [0,[0,0]]],
       caml_string_of_jsbytes("bad character hexadecimal encoding \\%c%c")],
     _cq_=
      [0,
       [11,
        caml_string_of_jsbytes("bad character decimal encoding \\"),
        [0,[0,[0,0]]]],
       caml_string_of_jsbytes("bad character decimal encoding \\%c%c%c")],
     _cp_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,
         [11,
          caml_string_of_jsbytes(" is not a valid "),
          [2,0,[11,caml_string_of_jsbytes(" digit"),0]]]]],
       caml_string_of_jsbytes("character %C is not a valid %s digit")],
     _co_=
      [0,
       [11,
        caml_string_of_jsbytes("character "),
        [1,[11,caml_string_of_jsbytes(" is not a decimal digit"),0]]],
       caml_string_of_jsbytes("character %C is not a decimal digit")],
     _cn_=[0,caml_string_of_jsbytes("scanf.ml"),555,9],
     _cm_=
      [0,
       [11,caml_string_of_jsbytes("invalid boolean '"),[2,0,[12,39,0]]],
       caml_string_of_jsbytes("invalid boolean '%s'")],
     _cl_=
      [0,
       [11,
        caml_string_of_jsbytes("looking for "),
        [1,[11,caml_string_of_jsbytes(", found "),[1,0]]]],
       caml_string_of_jsbytes("looking for %C, found %C")],
     _ck_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: premature end of file occurred before end of token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: premature end of file occurred before end of token")],
     _cj_=
      [0,
       [11,
        caml_string_of_jsbytes("scanning of "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes
           (" failed: the specified length was too short for token"),
          0]]],
       caml_string_of_jsbytes
        ("scanning of %s failed: the specified length was too short for token")],
     _ci_=
      [0,
       [11,caml_string_of_jsbytes("illegal escape character "),[1,0]],
       caml_string_of_jsbytes("illegal escape character %C")],
     _cF_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),438,17],
     _cE_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),420,13],
     _cD_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),417,13],
     _cC_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),414,13],
     _cB_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),411,13],
     _cA_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),408,13],
     _cz_=[0,caml_string_of_jsbytes("camlinternalOO.ml"),281,50],
     _cI_=[0,0],
     _cH_=[0,0],
     _cG_=[0,0],
     _cN_=[0,7,0],
     _cM_=[0,1,[0,3,[0,5,0]]],
     _cL_=[0,[2,0,[4,6,[0,2,6],0,[2,0,0]]],caml_string_of_jsbytes("%s%06x%s")],
     _cK_=[0,caml_string_of_jsbytes('"'),0],
     _cO_=[254,0.,0.];
    function erase_rel(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,erase_rel(rest)];
         case 1:var rest$0=param[1];return [1,erase_rel(rest$0)];
         case 2:var rest$1=param[1];return [2,erase_rel(rest$1)];
         case 3:var rest$2=param[1];return [3,erase_rel(rest$2)];
         case 4:var rest$3=param[1];return [4,erase_rel(rest$3)];
         case 5:var rest$4=param[1];return [5,erase_rel(rest$4)];
         case 6:var rest$5=param[1];return [6,erase_rel(rest$5)];
         case 7:var rest$6=param[1];return [7,erase_rel(rest$6)];
         case 8:
          var rest$7=param[2],ty=param[1];return [8,ty,erase_rel(rest$7)];
         case 9:
          var rest$8=param[3],ty1=param[1];
          return [9,ty1,ty1,erase_rel(rest$8)];
         case 10:var rest$9=param[1];return [10,erase_rel(rest$9)];
         case 11:var rest$10=param[1];return [11,erase_rel(rest$10)];
         case 12:var rest$11=param[1];return [12,erase_rel(rest$11)];
         case 13:var rest$12=param[1];return [13,erase_rel(rest$12)];
         default:var rest$13=param[1];return [14,erase_rel(rest$13)]}}
    function concat_fmtty(fmtty1,fmtty2)
     {if(typeof fmtty1 === "number")
       return fmtty2;
      else
       switch(fmtty1[0])
        {case 0:var rest=fmtty1[1];return [0,concat_fmtty(rest,fmtty2)];
         case 1:var rest$0=fmtty1[1];return [1,concat_fmtty(rest$0,fmtty2)];
         case 2:var rest$1=fmtty1[1];return [2,concat_fmtty(rest$1,fmtty2)];
         case 3:var rest$2=fmtty1[1];return [3,concat_fmtty(rest$2,fmtty2)];
         case 4:var rest$3=fmtty1[1];return [4,concat_fmtty(rest$3,fmtty2)];
         case 5:var rest$4=fmtty1[1];return [5,concat_fmtty(rest$4,fmtty2)];
         case 6:var rest$5=fmtty1[1];return [6,concat_fmtty(rest$5,fmtty2)];
         case 7:var rest$6=fmtty1[1];return [7,concat_fmtty(rest$6,fmtty2)];
         case 8:
          var rest$7=fmtty1[2],ty=fmtty1[1];
          return [8,ty,concat_fmtty(rest$7,fmtty2)];
         case 9:
          var rest$8=fmtty1[3],ty2=fmtty1[2],ty1=fmtty1[1];
          return [9,ty1,ty2,concat_fmtty(rest$8,fmtty2)];
         case 10:var rest$9=fmtty1[1];return [10,concat_fmtty(rest$9,fmtty2)];
         case 11:
          var rest$10=fmtty1[1];return [11,concat_fmtty(rest$10,fmtty2)];
         case 12:
          var rest$11=fmtty1[1];return [12,concat_fmtty(rest$11,fmtty2)];
         case 13:
          var rest$12=fmtty1[1];return [13,concat_fmtty(rest$12,fmtty2)];
         default:
          var rest$13=fmtty1[1];return [14,concat_fmtty(rest$13,fmtty2)]}}
    function concat_fmt(fmt1,fmt2)
     {if(typeof fmt1 === "number")
       return fmt2;
      else
       switch(fmt1[0])
        {case 0:var rest=fmt1[1];return [0,concat_fmt(rest,fmt2)];
         case 1:var rest$0=fmt1[1];return [1,concat_fmt(rest$0,fmt2)];
         case 2:
          var rest$1=fmt1[2],pad=fmt1[1];
          return [2,pad,concat_fmt(rest$1,fmt2)];
         case 3:
          var rest$2=fmt1[2],pad$0=fmt1[1];
          return [3,pad$0,concat_fmt(rest$2,fmt2)];
         case 4:
          var rest$3=fmt1[4],prec=fmt1[3],pad$1=fmt1[2],iconv=fmt1[1];
          return [4,iconv,pad$1,prec,concat_fmt(rest$3,fmt2)];
         case 5:
          var rest$4=fmt1[4],prec$0=fmt1[3],pad$2=fmt1[2],iconv$0=fmt1[1];
          return [5,iconv$0,pad$2,prec$0,concat_fmt(rest$4,fmt2)];
         case 6:
          var rest$5=fmt1[4],prec$1=fmt1[3],pad$3=fmt1[2],iconv$1=fmt1[1];
          return [6,iconv$1,pad$3,prec$1,concat_fmt(rest$5,fmt2)];
         case 7:
          var rest$6=fmt1[4],prec$2=fmt1[3],pad$4=fmt1[2],iconv$2=fmt1[1];
          return [7,iconv$2,pad$4,prec$2,concat_fmt(rest$6,fmt2)];
         case 8:
          var rest$7=fmt1[4],prec$3=fmt1[3],pad$5=fmt1[2],fconv=fmt1[1];
          return [8,fconv,pad$5,prec$3,concat_fmt(rest$7,fmt2)];
         case 9:
          var rest$8=fmt1[2],pad$6=fmt1[1];
          return [9,pad$6,concat_fmt(rest$8,fmt2)];
         case 10:var rest$9=fmt1[1];return [10,concat_fmt(rest$9,fmt2)];
         case 11:
          var rest$10=fmt1[2],str=fmt1[1];
          return [11,str,concat_fmt(rest$10,fmt2)];
         case 12:
          var rest$11=fmt1[2],chr=fmt1[1];
          return [12,chr,concat_fmt(rest$11,fmt2)];
         case 13:
          var rest$12=fmt1[3],fmtty=fmt1[2],pad$7=fmt1[1];
          return [13,pad$7,fmtty,concat_fmt(rest$12,fmt2)];
         case 14:
          var rest$13=fmt1[3],fmtty$0=fmt1[2],pad$8=fmt1[1];
          return [14,pad$8,fmtty$0,concat_fmt(rest$13,fmt2)];
         case 15:var rest$14=fmt1[1];return [15,concat_fmt(rest$14,fmt2)];
         case 16:var rest$15=fmt1[1];return [16,concat_fmt(rest$15,fmt2)];
         case 17:
          var rest$16=fmt1[2],fmting_lit=fmt1[1];
          return [17,fmting_lit,concat_fmt(rest$16,fmt2)];
         case 18:
          var rest$17=fmt1[2],fmting_gen=fmt1[1];
          return [18,fmting_gen,concat_fmt(rest$17,fmt2)];
         case 19:var rest$18=fmt1[1];return [19,concat_fmt(rest$18,fmt2)];
         case 20:
          var rest$19=fmt1[3],char_set=fmt1[2],width_opt=fmt1[1];
          return [20,width_opt,char_set,concat_fmt(rest$19,fmt2)];
         case 21:
          var rest$20=fmt1[2],counter=fmt1[1];
          return [21,counter,concat_fmt(rest$20,fmt2)];
         case 22:var rest$21=fmt1[1];return [22,concat_fmt(rest$21,fmt2)];
         case 23:
          var rest$22=fmt1[2],ign=fmt1[1];
          return [23,ign,concat_fmt(rest$22,fmt2)];
         default:
          var rest$23=fmt1[3],f=fmt1[2],arity=fmt1[1];
          return [24,arity,f,concat_fmt(rest$23,fmt2)]}}
    var CamlinternalFormatBasics=[0,concat_fmtty,erase_rel,concat_fmt];
    caml_register_global
     (740,CamlinternalFormatBasics,"CamlinternalFormatBasics");
    function failwith(s){throw [0,Failure,s]}
    function invalid_arg(s){throw [0,Invalid_argument,s]}
    var Exit=[248,cst_Stdlib_Exit,caml_fresh_oo_id(0)];
    function min(x,y){return caml_lessequal(x,y)?x:y}
    function max(x,y){return caml_greaterequal(x,y)?x:y}
    function abs(x){return 0 <= x?x:- x | 0}
    function lnot(x){return x ^ -1}
    var
     infinity=caml_int64_float_of_bits(_a_),
     neg_infinity=caml_int64_float_of_bits(_b_),
     nan=caml_int64_float_of_bits(_c_),
     max_float=caml_int64_float_of_bits(_d_),
     min_float=caml_int64_float_of_bits(_e_),
     epsilon=caml_int64_float_of_bits(_f_),
     max_int=2147483647,
     min_int=-2147483648;
    function symbol(s1,s2)
     {var
       l1=caml_ml_string_length(s1),
       l2=caml_ml_string_length(s2),
       s=caml_create_bytes(l1 + l2 | 0);
      caml_blit_string(s1,0,s,0,l1);
      caml_blit_string(s2,0,s,l1,l2);
      return caml_string_of_bytes(s)}
    function char_of_int(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_char_of_int)}
    function string_of_bool(b){return b?cst_true:cst_false}
    function bool_of_string(param)
     {return caml_string_notequal(param,cst_false$0)
              ?caml_string_notequal(param,cst_true$0)
                ?invalid_arg(cst_bool_of_string)
                :1
              :0}
    function bool_of_string_opt(param)
     {return caml_string_notequal(param,cst_false$1)
              ?caml_string_notequal(param,cst_true$1)?0:_g_
              :_h_}
    function string_of_int(n){return caml_string_of_jsbytes("" + n)}
    function int_of_string_opt(s)
     {try
       {var _AP_=[0,caml_int_of_string(s)];return _AP_}
      catch(_AQ_)
       {_AQ_ = caml_wrap_exception(_AQ_);
        if(_AQ_[1] === Failure)return 0;
        throw _AQ_}}
    function valid_float_lexem(s)
     {var l=caml_ml_string_length(s),i=0;
      for(;;)
       {if(l <= i)return symbol(s,cst);
        var match=caml_string_get(s,i),switch$0=0;
        if(48 <= match)
         {if(! (58 <= match))switch$0 = 1}
        else
         if(45 === match)switch$0 = 1;
        if(switch$0){var i$0=i + 1 | 0,i=i$0;continue}
        return s}}
    function to_string(f)
     {return valid_float_lexem(caml_format_float(cst_12g,f))}
    function of_string_opt(s)
     {try
       {var _AN_=[0,caml_float_of_string(s)];return _AN_}
      catch(_AO_)
       {_AO_ = caml_wrap_exception(_AO_);
        if(_AO_[1] === Failure)return 0;
        throw _AO_}}
    function append(l1,l2)
     {if(l1){var tl=l1[2],hd=l1[1];return [0,hd,append(tl,l2)]}return l2}
    var
     stdin=caml_ml_open_descriptor_in(0),
     stdout=caml_ml_open_descriptor_out(1),
     stderr=caml_ml_open_descriptor_out(2);
    function open_out_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_out(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_out(name){return open_out_gen(_i_,438,name)}
    function open_out_bin(name){return open_out_gen(_j_,438,name)}
    function flush_all(param)
     {function iter(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var l=param$0[2],a=param$0[1];
            try
             {caml_ml_flush(a)}
            catch(_AM_)
             {_AM_ = caml_wrap_exception(_AM_);
              if(_AM_[1] !== Sys_error)throw _AM_;
              var _AL_=_AM_}
            var param$0=l;
            continue}
          return 0}}
      return iter(runtime.caml_ml_out_channels_list(0))}
    function output_bytes(oc,s)
     {return caml_ml_output_bytes(oc,s,0,caml_ml_bytes_length(s))}
    function output_string(oc,s)
     {return caml_ml_output(oc,s,0,caml_ml_string_length(s))}
    function output(oc,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_output_bytes(oc,s,ofs,len);
      return invalid_arg(cst_output)}
    function output_substring(oc,s,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(s) - len | 0) < ofs))
       return caml_ml_output(oc,s,ofs,len);
      return invalid_arg(cst_output_substring)}
    function output_value(chan,v){return caml_output_value(chan,v,0)}
    function close_out(oc){caml_ml_flush(oc);return caml_ml_close_channel(oc)}
    function close_out_noerr(oc)
     {try {caml_ml_flush(oc)}catch(_AK_){}
      try
       {var _AI_=caml_ml_close_channel(oc);return _AI_}
      catch(_AJ_){return 0}}
    function open_in_gen(mode,perm,name)
     {var c=caml_ml_open_descriptor_in(caml_sys_open(name,mode,perm));
      caml_ml_set_channel_name(c,name);
      return c}
    function open_in(name){return open_in_gen(_k_,0,name)}
    function open_in_bin(name){return open_in_gen(_l_,0,name)}
    function input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_ml_input(ic,s,ofs,len);
      return invalid_arg(cst_input)}
    function unsafe_really_input(ic,s,ofs,len)
     {var ofs$0=ofs,len$0=len;
      for(;;)
       {if(0 < len$0)
         {var r=caml_ml_input(ic,s,ofs$0,len$0);
          if(0 === r)throw End_of_file;
          var len$1=len$0 - r | 0,ofs$1=ofs$0 + r | 0,ofs$0=ofs$1,len$0=len$1;
          continue}
        return 0}}
    function really_input(ic,s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return unsafe_really_input(ic,s,ofs,len);
      return invalid_arg(cst_really_input)}
    function really_input_string(ic,len)
     {var s=caml_create_bytes(len);
      really_input(ic,s,0,len);
      return caml_string_of_bytes(s)}
    function input_line(chan)
     {function build_result(buf,pos,param)
       {var pos$0=pos,param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1],len=caml_ml_bytes_length(hd);
            caml_blit_bytes(hd,0,buf,pos$0 - len | 0,len);
            var pos$1=pos$0 - len | 0,pos$0=pos$1,param$0=tl;
            continue}
          return buf}}
      var accu=0,len=0;
      for(;;)
       {var n=runtime.caml_ml_input_scan_line(chan);
        if(0 === n)
         {if(! accu)throw End_of_file;
          var _AH_=build_result(caml_create_bytes(len),len,accu)}
        else
         {if(! (0 < n))
           {var beg=caml_create_bytes(- n | 0);
            caml_ml_input(chan,beg,0,- n | 0);
            var len$1=len - n | 0,accu$0=[0,beg,accu],accu=accu$0,len=len$1;
            continue}
          var res=caml_create_bytes(n - 1 | 0);
          caml_ml_input(chan,res,0,n - 1 | 0);
          caml_ml_input_char(chan);
          if(accu)
           var
            len$0=(len + n | 0) - 1 | 0,
            _AH_=build_result(caml_create_bytes(len$0),len$0,[0,res,accu]);
          else
           var _AH_=res}
        return caml_string_of_bytes(_AH_)}}
    function close_in_noerr(ic)
     {try
       {var _AF_=caml_ml_close_channel(ic);return _AF_}
      catch(_AG_){return 0}}
    function print_char(c){return caml_ml_output_char(stdout,c)}
    function print_string(s){return output_string(stdout,s)}
    function print_bytes(s){return output_bytes(stdout,s)}
    function print_int(i)
     {return output_string(stdout,caml_string_of_jsbytes("" + i))}
    function print_float(f){return output_string(stdout,to_string(f))}
    function print_endline(s)
     {output_string(stdout,s);
      caml_ml_output_char(stdout,10);
      return caml_ml_flush(stdout)}
    function print_newline(param)
     {caml_ml_output_char(stdout,10);return caml_ml_flush(stdout)}
    function prerr_char(c){return caml_ml_output_char(stderr,c)}
    function prerr_string(s){return output_string(stderr,s)}
    function prerr_bytes(s){return output_bytes(stderr,s)}
    function prerr_int(i)
     {return output_string(stderr,caml_string_of_jsbytes("" + i))}
    function prerr_float(f){return output_string(stderr,to_string(f))}
    function prerr_endline(s)
     {output_string(stderr,s);
      caml_ml_output_char(stderr,10);
      return caml_ml_flush(stderr)}
    function prerr_newline(param)
     {caml_ml_output_char(stderr,10);return caml_ml_flush(stderr)}
    function read_line(param){caml_ml_flush(stdout);return input_line(stdin)}
    function read_int(param){return caml_int_of_string(read_line(0))}
    function read_int_opt(param){return int_of_string_opt(read_line(0))}
    function read_float(param){return caml_float_of_string(read_line(0))}
    function read_float_opt(param){return of_string_opt(read_line(0))}
    function string_of_format(param){var str=param[2];return str}
    function symbol$0(param,_AD_)
     {var
       str2=_AD_[2],
       fmt2=_AD_[1],
       str1=param[2],
       fmt1=param[1],
       _AE_=symbol(str1,symbol(cst$0,str2));
      return [0,concat_fmt(fmt1,fmt2),_AE_]}
    var exit_function=[0,flush_all];
    function at_exit(f)
     {var g=exit_function[1],f_already_ran=[0,0];
      exit_function[1]
      =
      function(param)
       {if(1 - f_already_ran[1]){f_already_ran[1] = 1;caml_call1(f,0)}
        return caml_call1(g,0)};
      return 0}
    function do_at_exit(param){return caml_call1(exit_function[1],0)}
    function exit(retcode)
     {do_at_exit(0);return runtime.caml_sys_exit(retcode)}
    var
     set_binary_mode_in=caml_ml_set_binary_mode,
     close_in=caml_ml_close_channel,
     in_channel_length=caml_ml_channel_size,
     pos_in=runtime.caml_ml_pos_in,
     seek_in=runtime.caml_ml_seek_in,
     input_value=caml_input_value,
     input_binary_int=runtime.caml_ml_input_int,
     input_byte=caml_ml_input_char,
     input_char=caml_ml_input_char,
     set_binary_mode_out=caml_ml_set_binary_mode,
     out_channel_length=caml_ml_channel_size,
     pos_out=runtime.caml_ml_pos_out,
     seek_out=runtime.caml_ml_seek_out,
     output_binary_int=runtime.caml_ml_output_int,
     output_byte=caml_ml_output_char,
     output_char=caml_ml_output_char,
     flush=caml_ml_flush,
     Stdlib=
      [0,
       invalid_arg,
       failwith,
       Exit,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Not_found,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       [0,
        runtime.caml_ml_seek_out_64,
        runtime.caml_ml_pos_out_64,
        caml_ml_channel_size_64,
        runtime.caml_ml_seek_in_64,
        runtime.caml_ml_pos_in_64,
        caml_ml_channel_size_64],
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit];
    caml_register_global(753,Stdlib,"Stdlib");
    var
     Exit$0=[248,cst_Stdlib_Pervasives_Exit,caml_fresh_oo_id(0)],
     Stdlib_pervasives=
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       min,
       max,
       abs,
       max_int,
       min_int,
       lnot,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon,
       symbol,
       char_of_int,
       string_of_bool,
       bool_of_string,
       bool_of_string_opt,
       string_of_int,
       int_of_string_opt,
       to_string,
       of_string_opt,
       append,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int,
       read_int_opt,
       read_float,
       read_float_opt,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol$0,
       exit,
       at_exit,
       valid_float_lexem,
       do_at_exit];
    caml_register_global(754,Stdlib_pervasives,"Stdlib__pervasives");
    function empty(param){return 0}
    function return$0(x,param){return [0,x,empty]}
    function cons(x,next,param){return [0,x,next]}
    function append$0(seq1,seq2,param)
     {var match=caml_call1(seq1,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_AC_){return append$0(next,seq2,_AC_)}]}
      return caml_call1(seq2,0)}
    function map(f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var
         next=match[2],
         x=match[1],
         _AA_=function(_AB_){return map(f,next,_AB_)};
        return [0,caml_call1(f,x),_AA_]}
      return 0}
    function filter_map(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1],match$0=caml_call1(f,x);
          if(match$0)
           {var y=match$0[1];
            return [0,y,function(_Az_){return filter_map(f,next,_Az_)}]}
          var seq$0=next;
          continue}
        return 0}}
    function filter(f,seq,param)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          if(caml_call1(f,x))
           return [0,x,function(_Ay_){return filter(f,next,_Ay_)}];
          var seq$0=next;
          continue}
        return 0}}
    function flat_map$0(counter,f,seq,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1],_Ax_=caml_call1(f,x),_Aw_=0;
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return flat_map_app$0(counter$0,f,_Ax_,next,_Aw_)}
        return caml_trampoline_return(flat_map_app$0,[0,f,_Ax_,next,_Aw_])}
      return 0}
    function flat_map_app$0(counter,f,seq,tail,param)
     {var match=caml_call1(seq,0);
      if(match)
       {var next=match[2],x=match[1];
        return [0,x,function(_Av_){return flat_map_app(f,next,tail,_Av_)}]}
      var _Au_=0;
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return flat_map$0(counter$0,f,tail,_Au_)}
      return caml_trampoline_return(flat_map$0,[0,f,tail,_Au_])}
    function flat_map(f,seq,param)
     {return caml_trampoline(flat_map$0(0,f,seq,param))}
    function flat_map_app(f,seq,tail,param)
     {return caml_trampoline(flat_map_app$0(0,f,seq,tail,param))}
    function fold_left(f,acc,seq)
     {var acc$0=acc,seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var
           next=match[2],
           x=match[1],
           acc$1=caml_call2(f,acc$0,x),
           acc$0=acc$1,
           seq$0=next;
          continue}
        return acc$0}}
    function iter(f,seq)
     {var seq$0=seq;
      for(;;)
       {var match=caml_call1(seq$0,0);
        if(match)
         {var next=match[2],x=match[1];
          caml_call1(f,x);
          var seq$0=next;
          continue}
        return 0}}
    function unfold(f,u,param)
     {var match=caml_call1(f,u);
      if(match)
       {var match$0=match[1],u$0=match$0[2],x=match$0[1];
        return [0,x,function(_At_){return unfold(f,u$0,_At_)}]}
      return 0}
    var
     Stdlib_seq=
      [0,
       empty,
       return$0,
       cons,
       append$0,
       map,
       filter,
       filter_map,
       flat_map,
       fold_left,
       iter,
       unfold];
    caml_register_global(755,Stdlib_seq,"Stdlib__seq");
    var none=0;
    function some(v){return [0,v]}
    function value(o,default$0){if(o){var v=o[1];return v}return default$0}
    function get(param)
     {if(param){var v=param[1];return v}
      return invalid_arg(cst_option_is_None)}
    function bind(o,f){if(o){var v=o[1];return caml_call1(f,v)}return 0}
    function join(param){if(param){var o=param[1];return o}return 0}
    function map$0(f,o){if(o){var v=o[1];return [0,caml_call1(f,v)]}return 0}
    function fold(none,some,param)
     {if(param){var v=param[1];return caml_call1(some,v)}return none}
    function iter$0(f,param)
     {if(param){var v=param[1];return caml_call1(f,v)}return 0}
    function is_none(param){return param?0:1}
    function is_some(param){return param?1:0}
    function equal(eq,o0,o1)
     {if(o0)
       {if(o1){var v1=o1[1],v0=o0[1];return caml_call2(eq,v0,v1)}}
      else
       if(! o1)return 1;
      return 0}
    function compare(cmp,o0,o1)
     {if(o0)
       {var _As_=o0[1];
        if(o1){var v1=o1[1];return caml_call2(cmp,_As_,v1)}
        return 1}
      return o1?-1:0}
    function to_result(none,param)
     {if(param){var v=param[1];return [0,v]}return [1,none]}
    function to_list(param){if(param){var v=param[1];return [0,v,0]}return 0}
    function to_seq(param)
     {if(param){var v=param[1];return function(_Ar_){return return$0(v,_Ar_)}}
      return empty}
    var
     Stdlib_option=
      [0,
       none,
       some,
       value,
       get,
       bind,
       join,
       map$0,
       fold,
       iter$0,
       is_none,
       is_some,
       equal,
       compare,
       to_result,
       to_list,
       to_seq];
    caml_register_global(756,Stdlib_option,"Stdlib__option");
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function value$0(r,default$0)
     {if(0 === r[0]){var v=r[1];return v}return default$0}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return invalid_arg(cst_result_is_Error)}
    function get_error(param)
     {if(0 === param[0])return invalid_arg(cst_result_is_Ok);
      var e=param[1];
      return e}
    function bind$0(r,f)
     {if(0 === r[0]){var v=r[1];return caml_call1(f,v)}return r}
    function join$0(e){if(0 === e[0]){var r=e[1];return r}return e}
    function map$1(f,e)
     {if(0 === e[0]){var v=e[1];return [0,caml_call1(f,v)]}return e}
    function map_error(f,v)
     {if(0 === v[0])return v;var e=v[1];return [1,caml_call1(f,e)]}
    function fold$0(ok,error,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(ok,v)}
      var e=param[1];
      return caml_call1(error,e)}
    function iter$1(f,param)
     {if(0 === param[0]){var v=param[1];return caml_call1(f,v)}return 0}
    function iter_error(f,param)
     {if(0 === param[0])return 0;var e=param[1];return caml_call1(f,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _Ap_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_Ap_,v1)}}
      else
       {var _Aq_=r0[1];
        if(0 !== match[0]){var e1=match[1];return caml_call2(error,_Aq_,e1)}}
      return 0}
    function compare$0(ok,error,r0,match)
     {if(0 === r0[0])
       {var _An_=r0[1];
        if(0 === match[0]){var v1=match[1];return caml_call2(ok,_An_,v1)}
        return -1}
      var _Ao_=r0[1];
      if(0 === match[0])return 1;
      var e1=match[1];
      return caml_call2(error,_Ao_,e1)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function to_list$0(param)
     {if(0 === param[0]){var v=param[1];return [0,v,0]}return 0}
    function to_seq$0(param)
     {if(0 === param[0])
       {var v=param[1];return function(_Am_){return return$0(v,_Am_)}}
      return empty}
    var
     Stdlib_result=
      [0,
       ok,
       error,
       value$0,
       get_ok,
       get_error,
       bind$0,
       join$0,
       map$1,
       map_error,
       fold$0,
       iter$1,
       iter_error,
       is_ok,
       is_error,
       equal$0,
       compare$0,
       to_option,
       to_list$0,
       to_seq$0];
    caml_register_global(757,Stdlib_result,"Stdlib__result");
    function equal$1(_Al_,_Ak_){return _Al_ === _Ak_?1:0}
    var compare$1=caml_int_compare;
    function to_float(param){return param?1.:0.}
    function to_string$0(param){return param?cst_true$2:cst_false$2}
    function _m_(_Aj_){return _Aj_}
    var
     Stdlib_bool=
      [0,
       function(_Ai_){return 1 - _Ai_},
       equal$1,
       compare$1,
       _m_,
       to_float,
       to_string$0];
    caml_register_global(758,Stdlib_bool,"Stdlib__bool");
    function chr(n)
     {if(0 <= n && ! (255 < n))return n;return invalid_arg(cst_Char_chr)}
    function escaped(c)
     {var switch$0=0;
      if(40 <= c)
       {if(92 === c)return cst$1;if(! (127 <= c))switch$0 = 1}
      else
       if(32 <= c)
        {if(39 <= c)return cst$2;switch$0 = 1}
       else
        if(! (14 <= c))
         switch(c)
          {case 8:return cst_b;
           case 9:return cst_t;
           case 10:return cst_n;
           case 13:return cst_r
           }
      if(switch$0)
       {var s$0=caml_create_bytes(1);
        caml_bytes_unsafe_set(s$0,0,c);
        return caml_string_of_bytes(s$0)}
      var s=caml_create_bytes(4);
      caml_bytes_unsafe_set(s,0,92);
      caml_bytes_unsafe_set(s,1,48 + (c / 100 | 0) | 0);
      caml_bytes_unsafe_set(s,2,48 + ((c / 10 | 0) % 10 | 0) | 0);
      caml_bytes_unsafe_set(s,3,48 + (c % 10 | 0) | 0);
      return caml_string_of_bytes(s)}
    function lowercase(c)
     {var _Ah_=c - 192 | 0,switch$0=0;
      if(30 < _Ah_ >>> 0)
       {if(! (25 < (_Ah_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Ah_)switch$0 = 1;
      return switch$0?c + 32 | 0:c}
    function uppercase(c)
     {var _Ag_=c - 224 | 0,switch$0=0;
      if(30 < _Ag_ >>> 0)
       {if(! (25 < (_Ag_ + 127 | 0) >>> 0))switch$0 = 1}
      else
       if(23 !== _Ag_)switch$0 = 1;
      return switch$0?c - 32 | 0:c}
    function lowercase_ascii(c)
     {var switcher=c - 65 | 0;return 25 < switcher >>> 0?c:c + 32 | 0}
    function uppercase_ascii(c)
     {var switcher=c - 97 | 0;return 25 < switcher >>> 0?c:c - 32 | 0}
    function compare$2(c1,c2){return c1 - c2 | 0}
    function equal$2(c1,c2){return 0 === (c1 - c2 | 0)?1:0}
    var
     Stdlib_char=
      [0,
       chr,
       escaped,
       lowercase,
       uppercase,
       lowercase_ascii,
       uppercase_ascii,
       compare$2,
       equal$2];
    caml_register_global(759,Stdlib_char,"Stdlib__char");
    var
     min$0=0,
     max$0=1114111,
     lo_bound=55295,
     hi_bound=57344,
     bom=65279,
     rep=65533;
    function succ(u)
     {return u === 55295
              ?hi_bound
              :u === 1114111?invalid_arg(err_no_succ):u + 1 | 0}
    function pred(u)
     {return u === 57344?lo_bound:u === 0?invalid_arg(err_no_pred):u - 1 | 0}
    function is_valid(i)
     {var _Ac_=0 <= i?1:0,_Ad_=_Ac_?i <= 55295?1:0:_Ac_;
      if(_Ad_)
       var _Ae_=_Ad_;
      else
       var _Af_=57344 <= i?1:0,_Ae_=_Af_?i <= 1114111?1:0:_Af_;
      return _Ae_}
    function of_int(i)
     {return is_valid(i)
              ?i
              :invalid_arg
                (symbol
                  (caml_format_int(cst_X,i),cst_is_not_an_Unicode_scalar_v))}
    function is_char(u){return u < 256?1:0}
    function of_char(c){return c}
    function to_char(u)
     {return 255 < u
              ?invalid_arg
                (symbol
                  (cst_U,
                   symbol
                    (caml_format_int(cst_04X,u),cst_is_not_a_latin1_character)))
              :u}
    function unsafe_to_char(_Ab_){return _Ab_}
    function equal$3(_Aa_,_z$_){return _Aa_ === _z$_?1:0}
    var compare$3=caml_int_compare;
    function hash(_z__){return _z__}
    function _n_(_z9_){return _z9_}
    var
     Stdlib_uchar=
      [0,
       min$0,
       max$0,
       bom,
       rep,
       succ,
       pred,
       is_valid,
       of_int,
       function(_z8_){return _z8_},
       _n_,
       is_char,
       of_char,
       to_char,
       unsafe_to_char,
       equal$3,
       compare$3,
       hash];
    caml_register_global(760,Stdlib_uchar,"Stdlib__uchar");
    var
     executable_name=runtime.caml_sys_executable_name(0),
     match=runtime.caml_sys_get_config(0),
     os_type=match[1],
     match$0=runtime.caml_sys_const_backend_type(0),
     unix=runtime.caml_sys_const_ostype_unix(0),
     win32=runtime.caml_sys_const_ostype_win32(0),
     cygwin=runtime.caml_sys_const_ostype_cygwin(0),
     max_array_length=runtime.caml_sys_const_max_wosize(0),
     max_floatarray_length=max_array_length / 2 | 0,
     max_string_length=(4 * max_array_length | 0) - 1 | 0,
     big_endian=0,
     match$1=32,
     int_size=32;
    function getenv_opt(s)
     {try
       {var _z6_=[0,caml_sys_getenv(s)];return _z6_}
      catch(_z7_)
       {_z7_ = caml_wrap_exception(_z7_);
        if(_z7_ === Not_found)return 0;
        throw _z7_}}
    var interactive=[0,0];
    function set_signal(sig_num,sig_beh){return 0}
    var
     Break=[248,cst_Stdlib_Sys_Break,caml_fresh_oo_id(0)],
     sigabrt=-1,
     sigalrm=-2,
     sigfpe=-3,
     sighup=-4,
     sigill=-5,
     sigint=-6,
     sigkill=-7,
     sigpipe=-8,
     sigquit=-9,
     sigsegv=-10,
     sigterm=-11,
     sigusr1=-12,
     sigusr2=-13,
     sigchld=-14,
     sigcont=-15,
     sigstop=-16,
     sigtstp=-17,
     sigttin=-18,
     sigttou=-19,
     sigvtalrm=-20,
     sigprof=-21,
     sigbus=-22,
     sigpoll=-23,
     sigsys=-24,
     sigtrap=-25,
     sigurg=-26,
     sigxcpu=-27,
     sigxfsz=-28;
    function catch_break(on){return on?0:0}
    function Make(_z5_,_z4_){return [0,1]}
    var
     Immediate64=[0,Make],
     Stdlib_sys=
      [0,
       executable_name,
       getenv_opt,
       interactive,
       os_type,
       match$0,
       unix,
       win32,
       cygwin,
       match$1,
       int_size,
       big_endian,
       max_string_length,
       max_array_length,
       max_floatarray_length,
       set_signal,
       sigabrt,
       sigalrm,
       sigfpe,
       sighup,
       sigill,
       sigint,
       sigkill,
       sigpipe,
       sigquit,
       sigsegv,
       sigterm,
       sigusr1,
       sigusr2,
       sigchld,
       sigcont,
       sigstop,
       sigtstp,
       sigttin,
       sigttou,
       sigvtalrm,
       sigprof,
       sigbus,
       sigpoll,
       sigsys,
       sigtrap,
       sigurg,
       sigxcpu,
       sigxfsz,
       Break,
       catch_break,
       ocaml_version,
       runtime.caml_ml_enable_runtime_warnings,
       runtime.caml_ml_runtime_warnings_enabled,
       Immediate64];
    caml_register_global(761,Stdlib_sys,"Stdlib__sys");
    function length(l)
     {var len=0,param=l;
      for(;;)
       {if(param)
         {var param$0=param[2],len$0=len + 1 | 0,len=len$0,param=param$0;
          continue}
        return len}}
    function cons$0(a,l){return [0,a,l]}
    function hd(param)
     {if(param){var a=param[1];return a}return failwith(cst_hd)}
    function tl(param)
     {if(param){var l=param[2];return l}return failwith(cst_tl)}
    function nth(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return a;
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return failwith(cst_nth)}}
      return invalid_arg(cst_List_nth)}
    function nth_opt(l,n)
     {if(0 <= n)
       {var l$0=l,n$0=n;
        for(;;)
         {if(l$0)
           {var l$1=l$0[2],a=l$0[1];
            if(0 === n$0)return [0,a];
            var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;
            continue}
          return 0}}
      return invalid_arg(cst_List_nth$0)}
    function rev_append(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var l1$1=l1$0[2],a=l1$0[1],l2$1=[0,a,l2$0],l1$0=l1$1,l2$0=l2$1;
          continue}
        return l2$0}}
    function rev(l){return rev_append(l,0)}
    function init_aux(i,n,f)
     {if(n <= i)return 0;
      var r=caml_call1(f,i);
      return [0,r,init_aux(i + 1 | 0,n,f)]}
    var rev_init_threshold=typeof match$0 === "number"?10000:50;
    function init(len,f)
     {if(0 <= len)
       {if(rev_init_threshold < len)
         {var acc=0,i=0;
          for(;;)
           {if(len <= i)return rev(acc);
            var i$0=i + 1 | 0,acc$0=[0,caml_call1(f,i),acc],acc=acc$0,i=i$0;
            continue}}
        return init_aux(0,len,f)}
      return invalid_arg(cst_List_init)}
    function flatten(param)
     {if(param){var r=param[2],l=param[1];return append(l,flatten(r))}
      return 0}
    function map$2(f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call1(f,a);return [0,r,map$2(f,l)]}
      return 0}
    function _o_(i,f,param)
     {if(param)
       {var l=param[2],a=param[1],r=caml_call2(f,i,a);
        return [0,r,_o_(i + 1 | 0,f,l)]}
      return 0}
    function mapi(f,l){return _o_(0,f,l)}
    function rev_map(f,param)
     {var accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           a=param$0[1],
           accu$0=[0,caml_call1(f,a),accu],
           accu=accu$0,
           param$0=l;
          continue}
        return accu}}
    function iter$2(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1];
          caml_call1(f,a);
          var param$0=l;
          continue}
        return 0}}
    function iteri(f,l$0)
     {var i=0,param=l$0;
      for(;;)
       {if(param)
         {var l=param[2],a=param[1];
          caml_call2(f,i,a);
          var i$0=i + 1 | 0,i=i$0,param=l;
          continue}
        return 0}}
    function fold_left$0(f,accu,l)
     {var accu$0=accu,l$0=l;
      for(;;)
       {if(l$0)
         {var
           l$1=l$0[2],
           a=l$0[1],
           accu$1=caml_call2(f,accu$0,a),
           accu$0=accu$1,
           l$0=l$1;
          continue}
        return accu$0}}
    function fold_right(f,l,accu)
     {if(l){var l$0=l[2],a=l[1];return caml_call2(f,a,fold_right(f,l$0,accu))}
      return accu}
    function map2(f,l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1],r=caml_call2(f,a1,a2);
          return [0,r,map2(f,l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_map2)}
    function rev_map2(f,l1,l2)
     {var accu=0,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$0=[0,caml_call2(f,a1,a2),accu],
             accu=accu$0,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu;
        return invalid_arg(cst_List_rev_map2)}}
    function iter2(f,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var l2$1=l2$0[2],a2=l2$0[1],l1$1=l1$0[2],a1=l1$0[1];
            caml_call2(f,a1,a2);
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_iter2)}}
    function fold_left2(f,accu,l1,l2)
     {var accu$0=accu,l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             accu$1=caml_call3(f,accu$0,a1,a2),
             accu$0=accu$1,
             l1$0=l1$1,
             l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return accu$0;
        return invalid_arg(cst_List_fold_left2)}}
    function fold_right2(f,l1,l2,accu)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return caml_call3(f,a1,a2,fold_right2(f,l1$0,l2$0,accu))}}
      else
       if(! l2)return accu;
      return invalid_arg(cst_List_fold_right2)}
    function for_all(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_z3_=caml_call1(p,a);
          if(_z3_){var param$0=l;continue}
          return _z3_}
        return 1}}
    function exists(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_z2_=caml_call1(p,a);
          if(_z2_)return _z2_;
          var param$0=l;
          continue}
        return 0}}
    function for_all2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _z1_=caml_call2(p,a1,a2);
            if(_z1_){var l1$0=l1$1,l2$0=l2$1;continue}
            return _z1_}}
        else
         if(! l2$0)return 1;
        return invalid_arg(cst_List_for_all2)}}
    function exists2(p,l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             l2$1=l2$0[2],
             a2=l2$0[1],
             l1$1=l1$0[2],
             a1=l1$0[1],
             _z0_=caml_call2(p,a1,a2);
            if(_z0_)return _z0_;
            var l1$0=l1$1,l2$0=l2$1;
            continue}}
        else
         if(! l2$0)return 0;
        return invalid_arg(cst_List_exists2)}}
    function mem(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zZ_=0 === caml_compare(a,x)?1:0;
          if(_zZ_)return _zZ_;
          var param$0=l;
          continue}
        return 0}}
    function memq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],a=param$0[1],_zY_=a === x?1:0;
          if(_zY_)return _zY_;
          var param$0=l;
          continue}
        return 0}}
    function assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assoc_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(0 === caml_compare(a,x))return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return b;
          var param$0=l;
          continue}
        throw Not_found}}
    function assq_opt(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],b=match[2],a=match[1];
          if(a === x)return [0,b];
          var param$0=l;
          continue}
        return 0}}
    function mem_assoc(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           match=param$0[1],
           a=match[1],
           _zX_=0 === caml_compare(a,x)?1:0;
          if(_zX_)return _zX_;
          var param$0=l;
          continue}
        return 0}}
    function mem_assq(x,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],match=param$0[1],a=match[1],_zW_=a === x?1:0;
          if(_zW_)return _zW_;
          var param$0=l;
          continue}
        return 0}}
    function remove_assoc(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return 0 === caml_compare(a,x)?l:[0,pair,remove_assoc(x,l)]}
      return 0}
    function remove_assq(x,param)
     {if(param)
       {var l=param[2],pair=param[1],a=pair[1];
        return a === x?l:[0,pair,remove_assq(x,l)]}
      return 0}
    function find(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return x;
          var param$0=l;
          continue}
        throw Not_found}}
    function find_opt(p,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))return [0,x];
          var param$0=l;
          continue}
        return 0}}
    function find_map(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1],result=caml_call1(f,x);
          if(result)return result;
          var param$0=l;
          continue}
        return 0}}
    function find_all(p)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1];
            if(caml_call1(p,x))
             {var accu$1=[0,x,accu$0],accu$0=accu$1,param=l;continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function filteri(p,param)
     {var i=0,acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           acc$0=caml_call2(p,i,x)?[0,x,acc]:acc,
           i$0=i + 1 | 0,
           i=i$0,
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function filter_map$0(f)
     {var accu=0;
      return function(param$0)
       {var accu$0=accu,param=param$0;
        for(;;)
         {if(param)
           {var l=param[2],x=param[1],match=caml_call1(f,x);
            if(match)
             {var v=match[1],accu$1=[0,v,accu$0],accu$0=accu$1,param=l;
              continue}
            var param=l;
            continue}
          return rev(accu$0)}}}
    function concat_map(f,param)
     {var acc=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           xs=caml_call1(f,x),
           acc$0=rev_append(xs,acc),
           acc=acc$0,
           param$0=l;
          continue}
        return rev(acc)}}
    function fold_left_map(f,accu,param)
     {var accu$0=accu,l_accu=0,param$0=param;
      for(;;)
       {if(param$0)
         {var
           l=param$0[2],
           x=param$0[1],
           match=caml_call2(f,accu$0,x),
           x$0=match[2],
           accu$1=match[1],
           l_accu$0=[0,x$0,l_accu],
           accu$0=accu$1,
           l_accu=l_accu$0,
           param$0=l;
          continue}
        return [0,accu$0,rev(l_accu)]}}
    function partition(p,param)
     {var yes=0,no=0,param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],x=param$0[1];
          if(caml_call1(p,x))
           {var yes$0=[0,x,yes],yes=yes$0,param$0=l;continue}
          var no$0=[0,x,no],no=no$0,param$0=l;
          continue}
        var _zV_=rev(no);
        return [0,rev(yes),_zV_]}}
    function split(param)
     {if(param)
       {var
         l=param[2],
         match=param[1],
         y=match[2],
         x=match[1],
         match$0=split(l),
         ry=match$0[2],
         rx=match$0[1];
        return [0,[0,x,rx],[0,y,ry]]}
      return _p_}
    function combine(l1,l2)
     {if(l1)
       {if(l2)
         {var l2$0=l2[2],a2=l2[1],l1$0=l1[2],a1=l1[1];
          return [0,[0,a1,a2],combine(l1$0,l2$0)]}}
      else
       if(! l2)return 0;
      return invalid_arg(cst_List_combine)}
    function merge(cmp,l1,match)
     {if(l1)
       {if(match)
         {var t2=match[2],h2=match[1],t1=l1[2],h1=l1[1];
          return 0 < caml_call2(cmp,h1,h2)
                  ?[0,h2,merge(cmp,l1,t2)]
                  :[0,h1,merge(cmp,t1,match)]}
        return l1}
      return match}
    function fast_sort(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zR_=l[2];
            if(_zR_)
             {var
               tl=_zR_[2],
               x2=_zR_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zT_=l[2];
           if(_zT_)
            {var _zU_=_zT_[2];
             if(_zU_)
              {var
                tl$1=_zU_[2],
                x3=_zU_[1],
                x2$0=_zT_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x2$0,x3)
                    ?[0,x1$0,[0,x2$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                      :[0,x3,[0,x1$0,[0,x2$0,0]]]
                  :0 < caml_call2(cmp,x1$0,x3)
                    ?[0,x2$0,[0,x1$0,[0,x3,0]]]
                    :0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                      :[0,x3,[0,x2$0,[0,x1$0,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h2,accu],l2=t2,accu=accu$0;continue}
              var accu$1=[0,h1,accu],l1=t1,accu=accu$1;
              continue}
            var _zS_=rev_append(l1,accu)}
          else
           var _zS_=rev_append(l2,accu);
          return [0,_zS_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zN_=l[2];
            if(_zN_)
             {var
               tl=_zN_[2],
               x2=_zN_[1],
               x1=l[1],
               s=0 < caml_call2(cmp,x1,x2)?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zP_=l[2];
           if(_zP_)
            {var _zQ_=_zP_[2];
             if(_zQ_)
              {var
                tl$1=_zQ_[2],
                x3=_zQ_[1],
                x2$0=_zP_[1],
                x1$0=l[1],
                s$0=
                 0 < caml_call2(cmp,x1$0,x2$0)
                  ?0 < caml_call2(cmp,x1$0,x3)
                    ?0 < caml_call2(cmp,x2$0,x3)
                      ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                      :[0,x2$0,[0,x3,[0,x1$0,0]]]
                    :[0,x2$0,[0,x1$0,[0,x3,0]]]
                  :0 < caml_call2(cmp,x2$0,x3)
                    ?0 < caml_call2(cmp,x1$0,x3)
                      ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                      :[0,x1$0,[0,x3,[0,x2$0,0]]]
                    :[0,x1$0,[0,x2$0,[0,x3,0]]];
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1];
              if(0 < caml_call2(cmp,h1,h2))
               {var accu$0=[0,h1,accu],l1=t1,accu=accu$0;continue}
              var accu$1=[0,h2,accu],l2=t2,accu=accu$1;
              continue}
            var _zO_=rev_append(l1,accu)}
          else
           var _zO_=rev_append(l2,accu);
          return [0,_zO_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function sort_uniq(cmp,l)
     {function rev_sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zE_=l[2];
            if(_zE_)
             {var
               tl=_zE_[2],
               x2=_zE_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 < c$0?[0,x1,[0,x2,0]]:[0,x2,[0,x1,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zG_=l[2];
           if(_zG_)
            {var _zH_=_zG_[2];
             if(_zH_)
              {var
                tl$1=_zH_[2],
                x3=_zH_[1],
                x2$0=_zG_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _zI_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 < c$2?[0,x2$0,[0,x3,0]]:[0,x3,[0,x2$0,0]],
                 s$0=_zI_;
               else
                if(0 < c$1)
                 {var c$3=caml_call2(cmp,x2$0,x3);
                  if(0 === c$3)
                   var _zJ_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 < c$3)
                    var _zJ_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                   else
                    var
                     c$4=caml_call2(cmp,x1$0,x3),
                     _zK_=
                      0 === c$4
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 < c$4
                         ?[0,x1$0,[0,x3,[0,x2$0,0]]]
                         :[0,x3,[0,x1$0,[0,x2$0,0]]],
                     _zJ_=_zK_;
                  var s$0=_zJ_}
                else
                 {var c$5=caml_call2(cmp,x1$0,x3);
                  if(0 === c$5)
                   var _zL_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 < c$5)
                    var _zL_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                   else
                    var
                     c$6=caml_call2(cmp,x2$0,x3),
                     _zM_=
                      0 === c$6
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 < c$6
                         ?[0,x2$0,[0,x3,[0,x1$0,0]]]
                         :[0,x3,[0,x2$0,[0,x1$0,0]]],
                     _zL_=_zM_;
                  var s$0=_zL_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 <= c){var accu$1=[0,h2,accu],l2=t2,accu=accu$1;continue}
              var accu$2=[0,h1,accu],l1=t1,accu=accu$2;
              continue}
            var _zF_=rev_append(l1,accu)}
          else
           var _zF_=rev_append(l2,accu);
          return [0,_zF_,tl$0]}}
      function sort(n,l)
       {if(2 === n)
         {if(l)
           {var _zv_=l[2];
            if(_zv_)
             {var
               tl=_zv_[2],
               x2=_zv_[1],
               x1=l[1],
               c$0=caml_call2(cmp,x1,x2),
               s=0 === c$0?[0,x1,0]:0 <= c$0?[0,x2,[0,x1,0]]:[0,x1,[0,x2,0]];
              return [0,s,tl]}}}
        else
         if(3 === n && l)
          {var _zx_=l[2];
           if(_zx_)
            {var _zy_=_zx_[2];
             if(_zy_)
              {var
                tl$1=_zy_[2],
                x3=_zy_[1],
                x2$0=_zx_[1],
                x1$0=l[1],
                c$1=caml_call2(cmp,x1$0,x2$0);
               if(0 === c$1)
                var
                 c$2=caml_call2(cmp,x2$0,x3),
                 _zz_=
                  0 === c$2
                   ?[0,x2$0,0]
                   :0 <= c$2?[0,x3,[0,x2$0,0]]:[0,x2$0,[0,x3,0]],
                 s$0=_zz_;
               else
                if(0 <= c$1)
                 {var c$3=caml_call2(cmp,x1$0,x3);
                  if(0 === c$3)
                   var _zA_=[0,x2$0,[0,x1$0,0]];
                  else
                   if(0 <= c$3)
                    var
                     c$4=caml_call2(cmp,x2$0,x3),
                     _zB_=
                      0 === c$4
                       ?[0,x2$0,[0,x1$0,0]]
                       :0 <= c$4
                         ?[0,x3,[0,x2$0,[0,x1$0,0]]]
                         :[0,x2$0,[0,x3,[0,x1$0,0]]],
                     _zA_=_zB_;
                   else
                    var _zA_=[0,x2$0,[0,x1$0,[0,x3,0]]];
                  var s$0=_zA_}
                else
                 {var c$5=caml_call2(cmp,x2$0,x3);
                  if(0 === c$5)
                   var _zC_=[0,x1$0,[0,x2$0,0]];
                  else
                   if(0 <= c$5)
                    var
                     c$6=caml_call2(cmp,x1$0,x3),
                     _zD_=
                      0 === c$6
                       ?[0,x1$0,[0,x2$0,0]]
                       :0 <= c$6
                         ?[0,x3,[0,x1$0,[0,x2$0,0]]]
                         :[0,x1$0,[0,x3,[0,x2$0,0]]],
                     _zC_=_zD_;
                   else
                    var _zC_=[0,x1$0,[0,x2$0,[0,x3,0]]];
                  var s$0=_zC_}
               return [0,s$0,tl$1]}}}
        var
         n1=n >> 1,
         n2=n - n1 | 0,
         match=rev_sort(n1,l),
         l2$0=match[2],
         s1=match[1],
         match$0=rev_sort(n2,l2$0),
         tl$0=match$0[2],
         s2=match$0[1],
         l1=s1,
         l2=s2,
         accu=0;
        for(;;)
         {if(l1)
           {if(l2)
             {var t2=l2[2],h2=l2[1],t1=l1[2],h1=l1[1],c=caml_call2(cmp,h1,h2);
              if(0 === c)
               {var accu$0=[0,h1,accu],l1=t1,l2=t2,accu=accu$0;continue}
              if(0 < c){var accu$1=[0,h1,accu],l1=t1,accu=accu$1;continue}
              var accu$2=[0,h2,accu],l2=t2,accu=accu$2;
              continue}
            var _zw_=rev_append(l1,accu)}
          else
           var _zw_=rev_append(l2,accu);
          return [0,_zw_,tl$0]}}
      var len=length(l);
      return 2 <= len?sort(len,l)[1]:l}
    function compare_lengths(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0){var l2$1=l2$0[2],l1$1=l1$0[2],l1$0=l1$1,l2$0=l2$1;continue}
          return 1}
        return l2$0?-1:0}}
    function compare_length_with(l,n)
     {var l$0=l,n$0=n;
      for(;;)
       {if(l$0)
         {var l$1=l$0[2];
          if(0 < n$0){var n$1=n$0 - 1 | 0,l$0=l$1,n$0=n$1;continue}
          return 1}
        return 0 === n$0?0:0 < n$0?-1:1}}
    function to_seq$1(l)
     {function aux(l,param)
       {if(l)
         {var tail=l[2],x=l[1];
          return [0,x,function(_zu_){return aux(tail,_zu_)}]}
        return 0}
      return function(_zt_){return aux(l,_zt_)}}
    function of_seq(seq)
     {function direct(depth,seq)
       {if(0 === depth)
         {var _zs_=0;
          return rev(fold_left(function(acc,x){return [0,x,acc]},_zs_,seq))}
        var match=caml_call1(seq,0);
        if(match)
         {var next=match[2],x=match[1];
          return [0,x,direct(depth - 1 | 0,next)]}
        return 0}
      return direct(500,seq)}
    var
     include=
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons$0,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(762,include,"Stdlib__list");
    function make(n,c)
     {var s=caml_create_bytes(n);caml_fill_bytes(s,0,n,c);return s}
    function init$0(n,f)
     {var s=caml_create_bytes(n),_zq_=n - 1 | 0,_zp_=0;
      if(! (_zq_ < 0))
       {var i=_zp_;
        for(;;)
         {caml_bytes_unsafe_set(s,i,caml_call1(f,i));
          var _zr_=i + 1 | 0;
          if(_zq_ !== i){var i=_zr_;continue}
          break}}
      return s}
    var empty$0=caml_create_bytes(0);
    function copy(s)
     {var len=caml_ml_bytes_length(s),r=caml_create_bytes(len);
      caml_blit_bytes(s,0,r,0,len);
      return r}
    function to_string$1(b){return caml_string_of_bytes(copy(b))}
    function of_string(s){return copy(caml_bytes_of_string(s))}
    function sub(s,ofs,len)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       {var r=caml_create_bytes(len);caml_blit_bytes(s,ofs,r,0,len);return r}
      return invalid_arg(cst_String_sub_Bytes_sub)}
    function sub_string(b,ofs,len)
     {return caml_string_of_bytes(sub(b,ofs,len))}
    function symbol$1(a,b)
     {var c=a + b | 0,_zo_=b < 0?1:0,match=c < 0?1:0,switch$0=0;
      if(a < 0)
       {if(_zo_ && ! match)switch$0 = 1}
      else
       if(! _zo_ && match)switch$0 = 1;
      return switch$0?invalid_arg(cst_Bytes_extend):c}
    function extend(s,left,right)
     {var
       len=symbol$1(symbol$1(caml_ml_bytes_length(s),left),right),
       r=caml_create_bytes(len);
      if(0 <= left)
       var dstoff=left,srcoff=0;
      else
       var dstoff=0,srcoff=- left | 0;
      var cpylen=min(caml_ml_bytes_length(s) - srcoff | 0,len - dstoff | 0);
      if(0 < cpylen)caml_blit_bytes(s,srcoff,r,dstoff,cpylen);
      return r}
    function fill(s,ofs,len,c)
     {if
       (0 <= ofs && 0 <= len && ! ((caml_ml_bytes_length(s) - len | 0) < ofs))
       return caml_fill_bytes(s,ofs,len,c);
      return invalid_arg(cst_String_fill_Bytes_fill)}
    function blit(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_bytes_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_bytes(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_Bytes_blit)}
    function blit$0(s1,ofs1,s2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((caml_ml_string_length(s1) - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((caml_ml_bytes_length(s2) - len | 0) < ofs2))
       return caml_blit_string(s1,ofs1,s2,ofs2,len);
      return invalid_arg(cst_String_blit_Bytes_blit_str)}
    function iter$3(f,a)
     {var _zm_=caml_ml_bytes_length(a) - 1 | 0,_zl_=0;
      if(! (_zm_ < 0))
       {var i=_zl_;
        for(;;)
         {caml_call1(f,caml_bytes_unsafe_get(a,i));
          var _zn_=i + 1 | 0;
          if(_zm_ !== i){var i=_zn_;continue}
          break}}
      return 0}
    function iteri$0(f,a)
     {var _zj_=caml_ml_bytes_length(a) - 1 | 0,_zi_=0;
      if(! (_zj_ < 0))
       {var i=_zi_;
        for(;;)
         {caml_call2(f,i,caml_bytes_unsafe_get(a,i));
          var _zk_=i + 1 | 0;
          if(_zj_ !== i){var i=_zk_;continue}
          break}}
      return 0}
    function concat(sep,l)
     {if(l)
       {var seplen=caml_ml_bytes_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _zf_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_bytes_length(_zf_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_Bytes_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _zh_=caml_ml_bytes_length(_zf_) + acc | 0}
          else
           var _zh_=acc;
          var dst=caml_create_bytes(_zh_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _zg_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_bytes(_zg_,0,dst,pos,caml_ml_bytes_length(_zg_));
                caml_blit_bytes
                 (sep,0,dst,pos + caml_ml_bytes_length(_zg_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_bytes_length(_zg_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_bytes(_zg_,0,dst,pos,caml_ml_bytes_length(_zg_));
              return dst}
            return dst}}}
      return empty$0}
    function cat(s1,s2)
     {var
       l1=caml_ml_bytes_length(s1),
       l2=caml_ml_bytes_length(s2),
       r=caml_create_bytes(l1 + l2 | 0);
      caml_blit_bytes(s1,0,r,0,l1);
      caml_blit_bytes(s2,0,r,l1,l2);
      return r}
    function is_space(param)
     {var _ze_=param - 9 | 0,switch$0=0;
      if(4 < _ze_ >>> 0)
       {if(23 === _ze_)switch$0 = 1}
      else
       if(2 !== _ze_)switch$0 = 1;
      return switch$0?1:0}
    function trim(s)
     {var len=caml_ml_bytes_length(s),i=[0,0];
      for(;;)
       {if(i[1] < len && is_space(caml_bytes_unsafe_get(s,i[1])))
         {i[1]++;continue}
        var j=[0,len - 1 | 0];
        for(;;)
         {if(i[1] <= j[1] && is_space(caml_bytes_unsafe_get(s,j[1])))
           {j[1] += -1;continue}
          return i[1] <= j[1]?sub(s,i[1],(j[1] - i[1] | 0) + 1 | 0):empty$0}}}
    function escaped$0(s)
     {var n=[0,0],_y9_=caml_ml_bytes_length(s) - 1 | 0,_y8_=0;
      if(! (_y9_ < 0))
       {var i$0=_y8_;
        for(;;)
         {var match=caml_bytes_unsafe_get(s,i$0),switch$0=0;
          if(32 <= match)
           {var _zb_=match - 34 | 0,switch$1=0;
            if(58 < _zb_ >>> 0)
             {if(93 <= _zb_)switch$1 = 1}
            else
             if(56 < (_zb_ - 1 | 0) >>> 0){switch$0 = 1;switch$1 = 1}
            if(! switch$1){var _zc_=1;switch$0 = 2}}
          else
           if(11 <= match)
            {if(13 === match)switch$0 = 1}
           else
            if(8 <= match)switch$0 = 1;
          switch(switch$0){case 0:var _zc_=4;break;case 1:var _zc_=2;break}
          n[1] = n[1] + _zc_ | 0;
          var _zd_=i$0 + 1 | 0;
          if(_y9_ !== i$0){var i$0=_zd_;continue}
          break}}
      if(n[1] === caml_ml_bytes_length(s))return copy(s);
      var s$0=caml_create_bytes(n[1]);
      n[1] = 0;
      var _y$_=caml_ml_bytes_length(s) - 1 | 0,_y__=0;
      if(! (_y$_ < 0))
       {var i=_y__;
        for(;;)
         {var c=caml_bytes_unsafe_get(s,i),switch$2=0;
          if(35 <= c)
           if(92 === c)
            switch$2 = 2;
           else
            if(127 <= c)switch$2 = 1;else switch$2 = 3;
          else
           if(32 <= c)
            if(34 <= c)switch$2 = 2;else switch$2 = 3;
           else
            if(14 <= c)
             switch$2 = 1;
            else
             switch(c)
              {case 8:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],98);
                break;
               case 9:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],116);
                break;
               case 10:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],110);
                break;
               case 13:
                caml_bytes_unsafe_set(s$0,n[1],92);
                n[1]++;
                caml_bytes_unsafe_set(s$0,n[1],114);
                break;
               default:switch$2 = 1}
          switch(switch$2)
           {case 1:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c / 100 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + ((c / 10 | 0) % 10 | 0) | 0);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],48 + (c % 10 | 0) | 0);
             break;
            case 2:
             caml_bytes_unsafe_set(s$0,n[1],92);
             n[1]++;
             caml_bytes_unsafe_set(s$0,n[1],c);
             break;
            case 3:caml_bytes_unsafe_set(s$0,n[1],c);break
            }
          n[1]++;
          var _za_=i + 1 | 0;
          if(_y$_ !== i){var i=_za_;continue}
          break}}
      return s$0}
    function map$3(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_y6_=l - 1 | 0,_y5_=0;
      if(! (_y6_ < 0))
       {var i=_y5_;
        for(;;)
         {caml_bytes_unsafe_set(r,i,caml_call1(f,caml_bytes_unsafe_get(s,i)));
          var _y7_=i + 1 | 0;
          if(_y6_ !== i){var i=_y7_;continue}
          break}}
      return r}
    function mapi$0(f,s)
     {var l=caml_ml_bytes_length(s);
      if(0 === l)return s;
      var r=caml_create_bytes(l),_y3_=l - 1 | 0,_y2_=0;
      if(! (_y3_ < 0))
       {var i=_y2_;
        for(;;)
         {caml_bytes_unsafe_set
           (r,i,caml_call2(f,i,caml_bytes_unsafe_get(s,i)));
          var _y4_=i + 1 | 0;
          if(_y3_ !== i){var i=_y4_;continue}
          break}}
      return r}
    function uppercase_ascii$0(s){return map$3(uppercase_ascii,s)}
    function lowercase_ascii$0(s){return map$3(lowercase_ascii,s)}
    function apply1(f,s)
     {if(0 === caml_ml_bytes_length(s))return s;
      var r=copy(s);
      caml_bytes_unsafe_set(r,0,caml_call1(f,caml_bytes_unsafe_get(s,0)));
      return r}
    function capitalize_ascii(s){return apply1(uppercase_ascii,s)}
    function uncapitalize_ascii(s){return apply1(lowercase_ascii,s)}
    function index_rec(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index(s,c){return index_rec(s,caml_ml_bytes_length(s),0,c)}
    function index_rec_opt(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt(s,c)
     {return index_rec_opt(s,caml_ml_bytes_length(s),0,c)}
    function index_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in)}
    function index_from_opt(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte)}
    function rindex_rec(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex(s,c)
     {return rindex_rec(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))return rindex_rec(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r)}
    function rindex_rec_opt(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_bytes_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt(s,c)
     {return rindex_rec_opt(s,caml_ml_bytes_length(s) - 1 | 0,c)}
    function rindex_from_opt(s,i,c)
     {if(-1 <= i && ! (caml_ml_bytes_length(s) <= i))
       return rindex_rec_opt(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt)}
    function contains_from(s,i,c)
     {var l=caml_ml_bytes_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec(s,l,i,c);var _y0_=1;return _y0_}
       catch(_y1_)
        {_y1_ = caml_wrap_exception(_y1_);
         if(_y1_ === Not_found)return 0;
         throw _y1_}
      return invalid_arg(cst_String_contains_from_Bytes)}
    function contains(s,c){return contains_from(s,0,c)}
    function rcontains_from(s,i,c)
     {if(0 <= i && ! (caml_ml_bytes_length(s) <= i))
       try
        {rindex_rec(s,i,c);var _yY_=1;return _yY_}
       catch(_yZ_)
        {_yZ_ = caml_wrap_exception(_yZ_);
         if(_yZ_ === Not_found)return 0;
         throw _yZ_}
      return invalid_arg(cst_String_rcontains_from_Byte)}
    function compare$4(x,y){return runtime.caml_bytes_compare(x,y)}
    function uppercase$0(s){return map$3(uppercase,s)}
    function lowercase$0(s){return map$3(lowercase,s)}
    function capitalize(s){return apply1(uppercase,s)}
    function uncapitalize(s){return apply1(lowercase,s)}
    function to_seq$2(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yW_=i + 1 | 0;
        return [0,x,function(_yX_){return aux(_yW_,_yX_)}]}
      var _yU_=0;
      return function(_yV_){return aux(_yU_,_yV_)}}
    function to_seqi(s)
     {function aux(i,param)
       {if(i === caml_ml_bytes_length(s))return 0;
        var x=caml_bytes_get(s,i),_yS_=i + 1 | 0;
        return [0,[0,i,x],function(_yT_){return aux(_yS_,_yT_)}]}
      var _yQ_=0;
      return function(_yR_){return aux(_yQ_,_yR_)}}
    function of_seq$0(i)
     {var n=[0,0],buf=[0,make(256,0)];
      iter
       (function(c)
         {if(n[1] === caml_ml_bytes_length(buf[1]))
           {var
             new_len=
              min(2 * caml_ml_bytes_length(buf[1]) | 0,max_string_length);
            if(caml_ml_bytes_length(buf[1]) === new_len)
             failwith(cst_Bytes_of_seq_cannot_grow_b);
            var new_buf=make(new_len,0);
            blit(buf[1],0,new_buf,0,n[1]);
            buf[1] = new_buf}
          caml_bytes_set(buf[1],n[1],c);
          n[1]++;
          return 0},
        i);
      return sub(buf[1],0,n[1])}
    function get_int8(b,i){return caml_bytes_get(b,i) << 24 >> 24}
    function get_uint16_le(b,i){return caml_bytes_get16(b,i)}
    function get_uint16_be(b,i){return caml_bswap16(caml_bytes_get16(b,i))}
    function get_int16_ne(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_le(b,i){return caml_bytes_get16(b,i) << 16 >> 16}
    function get_int16_be(b,i){return get_uint16_be(b,i) << 16 >> 16}
    function get_int32_le(b,i){return caml_bytes_get32(b,i)}
    function get_int32_be(b,i){return caml_int32_bswap(caml_bytes_get32(b,i))}
    function get_int64_le(b,i){return caml_bytes_get64(b,i)}
    function get_int64_be(b,i){return caml_int64_bswap(caml_bytes_get64(b,i))}
    function set_int16_le(b,i,x){return caml_bytes_set16(b,i,x)}
    function set_int16_be(b,i,x){return caml_bytes_set16(b,i,caml_bswap16(x))}
    function set_int32_le(b,i,x){return caml_bytes_set32(b,i,x)}
    function set_int32_be(b,i,x)
     {return caml_bytes_set32(b,i,caml_int32_bswap(x))}
    function set_int64_le(b,i,x){return caml_bytes_set64(b,i,x)}
    function set_int64_be(b,i,x)
     {return caml_bytes_set64(b,i,caml_int64_bswap(x))}
    var
     set_uint8=caml_bytes_set,
     set_uint16_ne=caml_bytes_set16,
     set_int64_ne=caml_bytes_set64,
     set_int32_ne=caml_bytes_set32,
     set_int16_ne=caml_bytes_set16,
     set_int8=caml_bytes_set,
     get_int64_ne=caml_bytes_get64,
     get_int32_ne=caml_bytes_get32,
     get_uint16_ne=caml_bytes_get16,
     get_uint8=caml_bytes_get,
     unsafe_of_string=caml_bytes_of_string,
     unsafe_to_string=caml_string_of_bytes,
     equal$4=runtime.caml_bytes_equal,
     include$0=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       unsafe_to_string,
       unsafe_of_string,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le];
    caml_register_global(763,include$0,"Stdlib__bytes");
    function make$0(n,c){return caml_string_of_bytes(make(n,c))}
    function init$1(n,f){return caml_string_of_bytes(init$0(n,f))}
    function copy$0(s)
     {return caml_string_of_bytes(copy(caml_bytes_of_string(s)))}
    function sub$0(s,ofs,len)
     {return caml_string_of_bytes(sub(caml_bytes_of_string(s),ofs,len))}
    function concat$0(sep,l)
     {if(l)
       {var seplen=caml_ml_string_length(sep),acc=0,param=l,pos$1=0;
        for(;;)
         {if(param)
           {var _yN_=param[1];
            if(param[2])
             {var
               tl=param[2],
               x=(caml_ml_string_length(_yN_) + seplen | 0) + acc | 0,
               acc$0=acc <= x?x:invalid_arg(cst_String_concat),
               acc=acc$0,
               param=tl;
              continue}
            var _yP_=caml_ml_string_length(_yN_) + acc | 0}
          else
           var _yP_=acc;
          var dst=caml_create_bytes(_yP_),pos=pos$1,param$0=l;
          for(;;)
           {if(param$0)
             {var _yO_=param$0[1];
              if(param$0[2])
               {var tl$0=param$0[2];
                caml_blit_string(_yO_,0,dst,pos,caml_ml_string_length(_yO_));
                caml_blit_string
                 (sep,0,dst,pos + caml_ml_string_length(_yO_) | 0,seplen);
                var
                 pos$0=(pos + caml_ml_string_length(_yO_) | 0) + seplen | 0,
                 pos=pos$0,
                 param$0=tl$0;
                continue}
              caml_blit_string(_yO_,0,dst,pos,caml_ml_string_length(_yO_))}
            return caml_string_of_bytes(dst)}}}
      return cst$3}
    function iter$4(f,s)
     {var _yL_=caml_ml_string_length(s) - 1 | 0,_yK_=0;
      if(! (_yL_ < 0))
       {var i=_yK_;
        for(;;)
         {caml_call1(f,caml_string_unsafe_get(s,i));
          var _yM_=i + 1 | 0;
          if(_yL_ !== i){var i=_yM_;continue}
          break}}
      return 0}
    function iteri$1(f,s)
     {var _yI_=caml_ml_string_length(s) - 1 | 0,_yH_=0;
      if(! (_yI_ < 0))
       {var i=_yH_;
        for(;;)
         {caml_call2(f,i,caml_string_unsafe_get(s,i));
          var _yJ_=i + 1 | 0;
          if(_yI_ !== i){var i=_yJ_;continue}
          break}}
      return 0}
    function map$4(f,s)
     {return caml_string_of_bytes(map$3(f,caml_bytes_of_string(s)))}
    function mapi$1(f,s)
     {return caml_string_of_bytes(mapi$0(f,caml_bytes_of_string(s)))}
    function is_space$0(param)
     {var _yG_=param - 9 | 0,switch$0=0;
      if(4 < _yG_ >>> 0)
       {if(23 === _yG_)switch$0 = 1}
      else
       if(2 !== _yG_)switch$0 = 1;
      return switch$0?1:0}
    function trim$0(s)
     {if(caml_string_equal(s,cst$4))return s;
      if
       (!
        is_space$0(caml_string_unsafe_get(s,0))
        &&
        !
        is_space$0(caml_string_unsafe_get(s,caml_ml_string_length(s) - 1 | 0)))
       return s;
      return caml_string_of_bytes(trim(caml_bytes_of_string(s)))}
    function escaped$1(s)
     {var n=caml_ml_string_length(s),i=0;
      for(;;)
       {if(n <= i)return s;
        var match=caml_string_unsafe_get(s,i),_yF_=match - 32 | 0,switch$0=0;
        if(59 < _yF_ >>> 0)
         {if(33 < (_yF_ - 61 | 0) >>> 0)switch$0 = 1}
        else
         if(2 === _yF_)switch$0 = 1;
        if(switch$0)
         return caml_string_of_bytes(escaped$0(caml_bytes_of_string(s)));
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function index_rec$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)throw Not_found;
        if(caml_string_unsafe_get(s,i$0) === c)return i$0;
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index$0(s,c){return index_rec$0(s,caml_ml_string_length(s),0,c)}
    function index_rec_opt$0(s,lim,i,c)
     {var i$0=i;
      for(;;)
       {if(lim <= i$0)return 0;
        if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
        var i$1=i$0 + 1 | 0,i$0=i$1;
        continue}}
    function index_opt$0(s,c)
     {return index_rec_opt$0(s,caml_ml_string_length(s),0,c)}
    function index_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_Bytes_in$0)}
    function index_from_opt$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))return index_rec_opt$0(s,l,i,c);
      return invalid_arg(cst_String_index_from_opt_Byte$0)}
    function rindex_rec$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return i$0;
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        throw Not_found}}
    function rindex$0(s,c)
     {return rindex_rec$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_Bytes_r$0)}
    function rindex_rec_opt$0(s,i,c)
     {var i$0=i;
      for(;;)
       {if(0 <= i$0)
         {if(caml_string_unsafe_get(s,i$0) === c)return [0,i$0];
          var i$1=i$0 - 1 | 0,i$0=i$1;
          continue}
        return 0}}
    function rindex_opt$0(s,c)
     {return rindex_rec_opt$0(s,caml_ml_string_length(s) - 1 | 0,c)}
    function rindex_from_opt$0(s,i,c)
     {if(-1 <= i && ! (caml_ml_string_length(s) <= i))
       return rindex_rec_opt$0(s,i,c);
      return invalid_arg(cst_String_rindex_from_opt_Byt$0)}
    function contains_from$0(s,i,c)
     {var l=caml_ml_string_length(s);
      if(0 <= i && ! (l < i))
       try
        {index_rec$0(s,l,i,c);var _yD_=1;return _yD_}
       catch(_yE_)
        {_yE_ = caml_wrap_exception(_yE_);
         if(_yE_ === Not_found)return 0;
         throw _yE_}
      return invalid_arg(cst_String_contains_from_Bytes$0)}
    function contains$0(s,c){return contains_from$0(s,0,c)}
    function rcontains_from$0(s,i,c)
     {if(0 <= i && ! (caml_ml_string_length(s) <= i))
       try
        {rindex_rec$0(s,i,c);var _yB_=1;return _yB_}
       catch(_yC_)
        {_yC_ = caml_wrap_exception(_yC_);
         if(_yC_ === Not_found)return 0;
         throw _yC_}
      return invalid_arg(cst_String_rcontains_from_Byte$0)}
    function uppercase_ascii$1(s)
     {return caml_string_of_bytes(uppercase_ascii$0(caml_bytes_of_string(s)))}
    function lowercase_ascii$1(s)
     {return caml_string_of_bytes(lowercase_ascii$0(caml_bytes_of_string(s)))}
    function capitalize_ascii$0(s)
     {return caml_string_of_bytes(capitalize_ascii(caml_bytes_of_string(s)))}
    function uncapitalize_ascii$0(s)
     {return caml_string_of_bytes(uncapitalize_ascii(caml_bytes_of_string(s)))}
    function compare$5(x,y){return caml_string_compare(x,y)}
    function split_on_char(sep,s)
     {var
       r=[0,0],
       j=[0,caml_ml_string_length(s)],
       _yx_=caml_ml_string_length(s) - 1 | 0;
      if(! (_yx_ < 0))
       {var i=_yx_;
        for(;;)
         {if(caml_string_unsafe_get(s,i) === sep)
           {var _yz_=r[1];
            r[1] = [0,sub$0(s,i + 1 | 0,(j[1] - i | 0) - 1 | 0),_yz_];
            j[1] = i}
          var _yA_=i - 1 | 0;
          if(0 !== i){var i=_yA_;continue}
          break}}
      var _yy_=r[1];
      return [0,sub$0(s,0,j[1]),_yy_]}
    function uppercase$1(s)
     {return caml_string_of_bytes(uppercase$0(caml_bytes_of_string(s)))}
    function lowercase$1(s)
     {return caml_string_of_bytes(lowercase$0(caml_bytes_of_string(s)))}
    function capitalize$0(s)
     {return caml_string_of_bytes(capitalize(caml_bytes_of_string(s)))}
    function uncapitalize$0(s)
     {return caml_string_of_bytes(uncapitalize(caml_bytes_of_string(s)))}
    function to_seq$3(s){return to_seq$2(caml_bytes_of_string(s))}
    function to_seqi$0(s){return to_seqi(caml_bytes_of_string(s))}
    function of_seq$1(g){return caml_string_of_bytes(of_seq$0(g))}
    var
     equal$5=caml_string_equal,
     include$1=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(764,include$1,"Stdlib__string");
    function equal$6(param,_yw_){return 1}
    function compare$6(param,_yv_){return 0}
    function to_string$2(param){return cst$5}
    var Stdlib_unit=[0,equal$6,compare$6,to_string$2];
    caml_register_global(765,Stdlib_unit,"Stdlib__unit");
    function to_buffer(buff,ofs,len,v,flags)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_bytes_length(buff) - len | 0) < ofs))
       return runtime.caml_output_value_to_buffer(buff,ofs,len,v,flags);
      return invalid_arg(cst_Marshal_to_buffer_substrin)}
    var header_size=20;
    function data_size(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       return caml_marshal_data_size(buff,ofs);
      return invalid_arg(cst_Marshal_data_size)}
    function total_size(buff,ofs){return 20 + data_size(buff,ofs) | 0}
    function from_bytes(buff,ofs)
     {if(0 <= ofs && ! ((caml_ml_bytes_length(buff) - 20 | 0) < ofs))
       {var len=caml_marshal_data_size(buff,ofs);
        return (caml_ml_bytes_length(buff) - (20 + len | 0) | 0) < ofs
                ?invalid_arg(cst_Marshal_from_bytes$0)
                :runtime.caml_input_value_from_bytes(buff,ofs)}
      return invalid_arg(cst_Marshal_from_bytes)}
    function from_string(buff,ofs)
     {return from_bytes(caml_bytes_of_string(buff),ofs)}
    var
     Stdlib_marshal=
      [0,
       caml_output_value,
       to_buffer,
       caml_input_value,
       from_bytes,
       from_string,
       header_size,
       data_size,
       total_size];
    caml_register_global(766,Stdlib_marshal,"Stdlib__marshal");
    function is_block(a){return 1 - (typeof a === "number"?1:0)}
    function double_field(x,i){return caml_array_get(x,i)}
    function set_double_field(x,i,v){return caml_array_set(x,i,v)}
    function marshal(obj){return runtime.caml_output_value_to_bytes(obj,0)}
    function unmarshal(str,pos)
     {var _yu_=pos + total_size(str,pos) | 0;
      return [0,from_bytes(str,pos),_yu_]}
    var
     first_non_constant_constructor=0,
     last_non_constant_constructor_=245,
     lazy_tag=246,
     closure_tag=247,
     object_tag=248,
     infix_tag=249,
     forward_tag=250,
     no_scan_tag=251,
     abstract_tag=251,
     string_tag=252,
     double_tag=253,
     double_array_tag=254,
     custom_tag=255,
     int_tag=1000,
     out_of_heap_tag=1001,
     unaligned_tag=1002;
    function of_val(x)
     {var switch$0=0;
      if(is_block(x) && caml_obj_tag(x) !== 248 && 1 <= x.length - 1)
       {var slot=x[1];switch$0 = 1}
      if(! switch$0)var slot=x;
      var switch$1=0;
      if(is_block(slot) && caml_obj_tag(slot) === 248)
       {var name=slot[1];switch$1 = 1}
      if(! switch$1)var name=invalid_arg(cst_Obj_extension_constructor$0);
      return caml_obj_tag(name) === 252
              ?slot
              :invalid_arg(cst_Obj_extension_constructor)}
    function name(slot){return slot[1]}
    function id(slot){return slot[2]}
    var
     Extension_constructor=[0,of_val,name,id],
     extension_constructor=Extension_constructor[1],
     extension_name=Extension_constructor[2],
     extension_id=Extension_constructor[3],
     max_ephe_length=max_array_length - 2 | 0;
    function create(l)
     {var _ys_=0 <= l?1:0,_yt_=_ys_?l <= max_ephe_length?1:0:_ys_;
      if(1 - _yt_)invalid_arg(cst_Obj_Ephemeron_create);
      return runtime.caml_ephe_create(l)}
    function length$0(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset(e,o,msg)
     {var _yp_=0 <= o?1:0,_yq_=_yp_?o < length$0(e)?1:0:_yp_,_yr_=1 - _yq_;
      return _yr_?invalid_arg(msg):_yr_}
    function get_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key);
      return runtime.caml_ephe_get_key(e,o)}
    function get_key_copy(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_get_key_copy);
      return runtime.caml_ephe_get_key_copy(e,o)}
    function set_key(e,o,x)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_set_key);
      return caml_ephe_set_key(e,o,x)}
    function unset_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_unset_key);
      return caml_ephe_unset_key(e,o)}
    function check_key(e,o)
     {raise_if_invalid_offset(e,o,cst_Obj_Ephemeron_check_key);
      return runtime.caml_ephe_check_key(e,o)}
    function blit_key(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$0(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$0(e2) - l | 0) < o2))
       {var
         _yn_=0 !== l?1:0,
         _yo_=_yn_?runtime.caml_ephe_blit_key(e1,o1,e2,o2,l):_yn_;
        return _yo_}
      return invalid_arg(cst_Obj_Ephemeron_blit_key)}
    var
     _q_=runtime.caml_ephe_blit_data,
     _r_=runtime.caml_ephe_check_data,
     _s_=
      [0,
       create,
       length$0,
       get_key,
       get_key_copy,
       set_key,
       unset_key,
       check_key,
       blit_key,
       runtime.caml_ephe_get_data,
       runtime.caml_ephe_get_data_copy,
       runtime.caml_ephe_set_data,
       function(_ym_){return runtime.caml_ephe_unset_data(_ym_)},
       _r_,
       _q_,
       max_ephe_length],
     Stdlib_obj=
      [0,
       is_block,
       double_field,
       set_double_field,
       first_non_constant_constructor,
       last_non_constant_constructor_,
       lazy_tag,
       closure_tag,
       object_tag,
       infix_tag,
       forward_tag,
       no_scan_tag,
       abstract_tag,
       string_tag,
       double_tag,
       double_array_tag,
       custom_tag,
       custom_tag,
       int_tag,
       out_of_heap_tag,
       unaligned_tag,
       Extension_constructor,
       extension_constructor,
       extension_name,
       extension_id,
       marshal,
       unmarshal,
       _s_];
    caml_register_global(767,Stdlib_obj,"Stdlib__obj");
    var make_float=runtime.caml_make_float_vect,Floatarray=[0];
    function init$2(l,f)
     {if(0 === l)return [0];
      if(0 <= l)
       {var res=caml_make_vect(l,caml_call1(f,0)),_yk_=l - 1 | 0,_yj_=1;
        if(! (_yk_ < 1))
         {var i=_yj_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _yl_=i + 1 | 0;
            if(_yk_ !== i){var i=_yl_;continue}
            break}}
        return res}
      return invalid_arg(cst_Array_init)}
    function create_matrix(sx,sy,init)
     {var res=caml_make_vect(sx,[0]),_yh_=sx - 1 | 0,_yg_=0;
      if(! (_yh_ < 0))
       {var x=_yg_;
        for(;;)
         {res[1 + x] = caml_make_vect(sy,init);
          var _yi_=x + 1 | 0;
          if(_yh_ !== x){var x=_yi_;continue}
          break}}
      return res}
    function copy$1(a)
     {var l=a.length - 1;return 0 === l?[0]:caml_array_sub(a,0,l)}
    function append$1(a1,a2)
     {var l1=a1.length - 1;
      return 0 === l1
              ?copy$1(a2)
              :0 === a2.length - 1
                ?caml_array_sub(a1,0,l1)
                :runtime.caml_array_append(a1,a2)}
    function sub$1(a,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return caml_array_sub(a,ofs,len);
      return invalid_arg(cst_Array_sub)}
    function fill$0(a,ofs,len,v)
     {if(0 <= ofs && 0 <= len && ! ((a.length - 1 - len | 0) < ofs))
       return runtime.caml_array_fill(a,ofs,len,v);
      return invalid_arg(cst_Array_fill)}
    function blit$1(a1,ofs1,a2,ofs2,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        ofs1
        &&
        !
        ((a1.length - 1 - len | 0) < ofs1)
        &&
        0
        <=
        ofs2
        &&
        !
        ((a2.length - 1 - len | 0) < ofs2))
       return runtime.caml_array_blit(a1,ofs1,a2,ofs2,len);
      return invalid_arg(cst_Array_blit)}
    function iter$5(f,a)
     {var _ye_=a.length - 1 - 1 | 0,_yd_=0;
      if(! (_ye_ < 0))
       {var i=_yd_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _yf_=i + 1 | 0;
          if(_ye_ !== i){var i=_yf_;continue}
          break}}
      return 0}
    function iter2$0(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Array_iter2_arrays_must_ha);
      var _yb_=a.length - 1 - 1 | 0,_ya_=0;
      if(! (_yb_ < 0))
       {var i=_ya_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _yc_=i + 1 | 0;
          if(_yb_ !== i){var i=_yc_;continue}
          break}}
      return 0}
    function map$5(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_x__=l - 1 | 0,_x9_=1;
      if(! (_x__ < 1))
       {var i=_x9_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _x$_=i + 1 | 0;
          if(_x__ !== i){var i=_x$_;continue}
          break}}
      return r}
    function map2$0(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Array_map2_arrays_must_hav);
      if(0 === la)return [0];
      var r=caml_make_vect(la,caml_call2(f,a[1],b[1])),_x7_=la - 1 | 0,_x6_=1;
      if(! (_x7_ < 1))
       {var i=_x6_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _x8_=i + 1 | 0;
          if(_x7_ !== i){var i=_x8_;continue}
          break}}
      return r}
    function iteri$2(f,a)
     {var _x4_=a.length - 1 - 1 | 0,_x3_=0;
      if(! (_x4_ < 0))
       {var i=_x3_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _x5_=i + 1 | 0;
          if(_x4_ !== i){var i=_x5_;continue}
          break}}
      return 0}
    function mapi$2(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call2(f,0,a[1])),_x1_=l - 1 | 0,_x0_=1;
      if(! (_x1_ < 1))
       {var i=_x0_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _x2_=i + 1 | 0;
          if(_x1_ !== i){var i=_x2_;continue}
          break}}
      return r}
    function to_list$1(a)
     {var i$1=a.length - 1 - 1 | 0,i=i$1,res=0;
      for(;;)
       {if(0 <= i)
         {var res$0=[0,a[1 + i],res],i$0=i - 1 | 0,i=i$0,res=res$0;continue}
        return res}}
    function list_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[2],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function of_list(l)
     {if(l)
       {var
         tl=l[2],
         hd=l[1],
         a=caml_make_vect(list_length(0,l),hd),
         i=1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i + 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    function fold_left$1(f,x,a)
     {var r=[0,x],_xY_=a.length - 1 - 1 | 0,_xX_=0;
      if(! (_xY_ < 0))
       {var i=_xX_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _xZ_=i + 1 | 0;
          if(_xY_ !== i){var i=_xZ_;continue}
          break}}
      return r[1]}
    function fold_right$0(f,a,x)
     {var r=[0,x],_xV_=a.length - 1 - 1 | 0;
      if(! (_xV_ < 0))
       {var i=_xV_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _xW_=i - 1 | 0;
          if(0 !== i){var i=_xW_;continue}
          break}}
      return r[1]}
    function exists$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$0(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function for_all2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_for_all2);
      var i=0;
      for(;;)
       {if(i === n1)return 1;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))
         {var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function exists2$0(p,l1,l2)
     {var n1=l1.length - 1,n2=l2.length - 1;
      if(n1 !== n2)return invalid_arg(cst_Array_exists2);
      var i=0;
      for(;;)
       {if(i === n1)return 0;
        if(caml_call2(p,l1[1 + i],l2[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function memq$0(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x === a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom=[248,cst_Stdlib_Array_Bottom,caml_fresh_oo_id(0)];
    function sort(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {var _xO_=i31 + 1 | 0,_xP_=caml_check_bound(a,_xO_)[1 + _xO_];
          if(caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_xP_) < 0)
           x[1] = i31 + 1 | 0;
          var
           _xQ_=i31 + 2 | 0,
           _xR_=caml_check_bound(a,_xQ_)[1 + _xQ_],
           _xS_=x[1];
          if(caml_call2(cmp,caml_check_bound(a,_xS_)[1 + _xS_],_xR_) < 0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if((i31 + 1 | 0) < l)
         {var _xT_=i31 + 1 | 0,_xU_=caml_check_bound(a,_xT_)[1 + _xT_];
          if(! (0 <= caml_call2(cmp,caml_check_bound(a,i31)[1 + i31],_xU_)))
           return i31 + 1 | 0}
        if(i31 < l)return i31;
        throw [0,Bottom,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_check_bound(a,j)[1 + j],e))
           {var _xN_=caml_check_bound(a,j)[1 + j];
            caml_check_bound(a,i$0)[1 + i$0] = _xN_;
            var i$0=j;
            continue}
          caml_check_bound(a,i$0)[1 + i$0] = e;
          return 0}}
      function trickle(l,i,e)
       {try
         {var _xM_=trickledown(l,i,e);return _xM_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom)
           {var i$0=exn[2];caml_check_bound(a,i$0)[1 + i$0] = e;return 0}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0),_xL_=caml_check_bound(a,i$1)[1 + i$1];
          caml_check_bound(a,i$0)[1 + i$0] = _xL_;
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _xK_=bubbledown(l,i);return _xK_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_xC_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_xC_ < 0))
       {var i$2=_xC_;
        for(;;)
         {trickle(l,i$2,caml_check_bound(a,i$2)[1 + i$2]);
          var _xJ_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_xJ_;continue}
          break}}
      var _xD_=l - 1 | 0;
      if(! (_xD_ < 2))
       {var i$0=_xD_;
        a:
        for(;;)
         {var
           e$0=caml_check_bound(a,i$0)[1 + i$0],
           _xH_=caml_check_bound(a,0)[1];
          caml_check_bound(a,i$0)[1 + i$0] = _xH_;
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_t_];
            if
             (0 <= caml_call2(cmp,caml_check_bound(a,father)[1 + father],e$0))
             caml_check_bound(a,i)[1 + i] = e$0;
            else
             {var _xB_=caml_check_bound(a,father)[1 + father];
              caml_check_bound(a,i)[1 + i] = _xB_;
              if(0 < father){var i=father;continue}
              caml_check_bound(a,0)[1] = e$0}
            var _xI_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_xI_;continue a}
            break}
          break}}
      var _xE_=1 < l?1:0;
      if(_xE_)
       {var e=caml_check_bound(a,1)[2],_xF_=caml_check_bound(a,0)[1];
        caml_check_bound(a,1)[2] = _xF_;
        caml_check_bound(a,0)[1] = e;
        var _xG_=0}
      else
       var _xG_=_xE_;
      return _xG_}
    function fast_sort$0(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_check_bound(src2,src2ofs)[1 + src2ofs],
         s1$1=caml_check_bound(a,src1ofs)[1 + src1ofs],
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_check_bound(dst,d)[1 + d] = s2;
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_check_bound(src2,i2$0)[1 + i2$0],
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$1(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_check_bound(dst,d)[1 + d] = s1;
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_check_bound(a,i1$0)[1 + i1$0],
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$1(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _xt_=len - 1 | 0,_xs_=0;
        if(! (_xt_ < 0))
         {var i=_xs_;
          a:
          for(;;)
           {var
             _xu_=srcofs + i | 0,
             e=caml_check_bound(a,_xu_)[1 + _xu_],
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if(dstofs <= j[1])
               {var _xv_=j[1];
                if(0 < caml_call2(cmp,caml_check_bound(dst,_xv_)[1 + _xv_],e))
                 {var
                   _xw_=j[1],
                   _xx_=caml_check_bound(dst,_xw_)[1 + _xw_],
                   _xy_=j[1] + 1 | 0;
                  caml_check_bound(dst,_xy_)[1 + _xy_] = _xx_;
                  j[1] += -1;
                  continue}}
              var _xz_=j[1] + 1 | 0;
              caml_check_bound(dst,_xz_)[1 + _xz_] = e;
              var _xA_=i + 1 | 0;
              if(_xt_ !== i){var i=_xA_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var
       l1=l / 2 | 0,
       l2=l - l1 | 0,
       t=caml_make_vect(l2,caml_check_bound(a,0)[1]);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$4(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xq_=i + 1 | 0;
          return [0,x,function(_xr_){return aux(_xq_,_xr_)}]}
        return 0}
      var _xo_=0;
      return function(_xp_){return aux(_xo_,_xp_)}}
    function to_seqi$1(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_xm_=i + 1 | 0;
          return [0,[0,i,x],function(_xn_){return aux(_xm_,_xn_)}]}
        return 0}
      var _xk_=0;
      return function(_xl_){return aux(_xk_,_xl_)}}
    function of_seq$2(i$2)
     {var _xj_=0,l=fold_left(function(acc,x){return [0,x,acc]},_xj_,i$2);
      if(l)
       {var
         tl=l[2],
         hd=l[1],
         len=list_length(0,l),
         a=caml_make_vect(len,hd),
         i$1=len - 2 | 0,
         i=i$1,
         param=tl;
        for(;;)
         {if(param)
           {var tl$0=param[2],hd$0=param[1];
            a[1 + i] = hd$0;
            var i$0=i - 1 | 0,i=i$0,param=tl$0;
            continue}
          return a}}
      return [0]}
    var
     concat$1=caml_array_concat,
     include$2=
      [0,
       make_float,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       iteri$2,
       map$5,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       for_all$0,
       exists$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(768,include$2,"Stdlib__array");
    var zero=0.,one=1.,minus_one=-1.;
    function is_finite(x){return x - x == 0.?1:0}
    function is_infinite(x){return 1. / x == 0.?1:0}
    function is_nan(x){return x != x?1:0}
    var pi=3.14159265358979312;
    function is_integer(x)
     {var _xi_=x == runtime.caml_trunc_float(x)?1:0;
      return _xi_?is_finite(x):_xi_}
    function succ$0(x){return caml_nextafter_float(x,infinity)}
    function pred$0(x){return caml_nextafter_float(x,neg_infinity)}
    function equal$7(x,y){return 0 === caml_float_compare(x,y)?1:0}
    function min$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?x:y}
      return y != y?y:x}
    function max$1(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?y:x}
      return x != x?x:y}
    function min_max(x,y)
     {if(x == x && y == y)
       {if(! (x < y))
         {var switch$0=0;
          if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
          if(switch$0)return [0,y,x]}
        return [0,x,y]}
      return [0,nan,nan]}
    function min_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return y != y?x:y}
      return x != x?y:x}
    function max_num(x,y)
     {if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return x != x?y:x}
      return y != y?x:y}
    function min_max_num(x,y)
     {if(x != x)return [0,y,y];
      if(y != y)return [0,x,x];
      if(! (x < y))
       {var switch$0=0;
        if(caml_signbit_float(y) || ! caml_signbit_float(x))switch$0 = 1;
        if(switch$0)return [0,y,x]}
      return [0,x,y]}
    function hash$0(x){return caml_hash(10,100,0,x)}
    function unsafe_fill(a,ofs,len,v)
     {var _xg_=(ofs + len | 0) - 1 | 0;
      if(! (_xg_ < ofs))
       {var i=ofs;
        for(;;)
         {a[1 + i] = v;
          var _xh_=i + 1 | 0;
          if(_xg_ !== i){var i=_xh_;continue}
          break}}
      return 0}
    function unsafe_blit(src,sofs,dst,dofs,len)
     {var _xe_=len - 1 | 0,_xd_=0;
      if(! (_xe_ < 0))
       {var i=_xd_;
        for(;;)
         {dst[1 + (dofs + i | 0)] = src[1 + (sofs + i | 0)];
          var _xf_=i + 1 | 0;
          if(_xe_ !== i){var i=_xf_;continue}
          break}}
      return 0}
    function check(a,ofs,len,msg)
     {var _w$_=ofs < 0?1:0;
      if(_w$_)
       var _xa_=_w$_;
      else
       {var _xb_=len < 0?1:0;
        if(_xb_)
         var _xa_=_xb_;
        else
         var
          _xc_=(ofs + len | 0) < 0?1:0,
          _xa_=_xc_ || (a.length - 1 < (ofs + len | 0)?1:0)}
      return _xa_?invalid_arg(msg):_xa_}
    function make$1(n,v)
     {var result=caml_floatarray_create(n);
      unsafe_fill(result,0,n,v);
      return result}
    function init$3(l,f)
     {if(0 <= l)
       {var res=caml_floatarray_create(l),_w9_=l - 1 | 0,_w8_=0;
        if(! (_w9_ < 0))
         {var i=_w8_;
          for(;;)
           {res[1 + i] = caml_call1(f,i);
            var _w__=i + 1 | 0;
            if(_w9_ !== i){var i=_w__;continue}
            break}}
        return res}
      return invalid_arg(cst_Float_Array_init)}
    function append$2(a1,a2)
     {var
       l1=a1.length - 1,
       l2=a2.length - 1,
       result=caml_floatarray_create(l1 + l2 | 0);
      unsafe_blit(a1,0,result,0,l1);
      unsafe_blit(a2,0,result,l1,l2);
      return result}
    function concat$2(l)
     {var acc=0,param=l;
      for(;;)
       {if(param)
         {var
           tl=param[2],
           hd=param[1],
           x=hd.length - 1 + acc | 0,
           acc$0=acc <= x?x:invalid_arg(cst_Float_Array_concat),
           acc=acc$0,
           param=tl;
          continue}
        var result=caml_floatarray_create(acc),l$0=l,i=0;
        for(;;)
         {if(l$0)
           {var tl$0=l$0[2],hd$0=l$0[1],hlen=hd$0.length - 1;
            unsafe_blit(hd$0,0,result,i,hlen);
            var i$0=i + hlen | 0,l$0=tl$0,i=i$0;
            continue}
          if(i === acc)return result;
          throw [0,Assert_failure,_u_]}}}
    function sub$2(a,ofs,len)
     {check(a,ofs,len,cst_Float_Array_sub);
      var result=caml_floatarray_create(len);
      unsafe_blit(a,ofs,result,0,len);
      return result}
    function copy$2(a)
     {var l=a.length - 1,result=caml_floatarray_create(l);
      unsafe_blit(a,0,result,0,l);
      return result}
    function fill$1(a,ofs,len,v)
     {check(a,ofs,len,cst_Float_Array_fill);return unsafe_fill(a,ofs,len,v)}
    function blit$2(src,sofs,dst,dofs,len)
     {check(src,sofs,len,cst_Float_array_blit);
      check(dst,dofs,len,cst_Float_array_blit$0);
      return unsafe_blit(src,sofs,dst,dofs,len)}
    function to_list$2(a)
     {return init(a.length - 1,function(_w7_){return a[1 + _w7_]})}
    function of_list$0(l)
     {var result=caml_floatarray_create(length(l)),i=0,l$0=l;
      for(;;)
       {if(l$0)
         {var t=l$0[2],h=l$0[1];
          result[1 + i] = h;
          var i$0=i + 1 | 0,i=i$0,l$0=t;
          continue}
        return result}}
    function iter$6(f,a)
     {var _w5_=a.length - 1 - 1 | 0,_w4_=0;
      if(! (_w5_ < 0))
       {var i=_w4_;
        for(;;)
         {caml_call1(f,a[1 + i]);
          var _w6_=i + 1 | 0;
          if(_w5_ !== i){var i=_w6_;continue}
          break}}
      return 0}
    function iter2$1(f,a,b)
     {if(a.length - 1 !== b.length - 1)
       return invalid_arg(cst_Float_Array_iter2_arrays_m);
      var _w2_=a.length - 1 - 1 | 0,_w1_=0;
      if(! (_w2_ < 0))
       {var i=_w1_;
        for(;;)
         {caml_call2(f,a[1 + i],b[1 + i]);
          var _w3_=i + 1 | 0;
          if(_w2_ !== i){var i=_w3_;continue}
          break}}
      return 0}
    function map$6(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wZ_=l - 1 | 0,_wY_=0;
      if(! (_wZ_ < 0))
       {var i=_wY_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _w0_=i + 1 | 0;
          if(_wZ_ !== i){var i=_w0_;continue}
          break}}
      return r}
    function map2$1(f,a,b)
     {var la=a.length - 1,lb=b.length - 1;
      if(la !== lb)return invalid_arg(cst_Float_Array_map2_arrays_mu);
      var r=caml_floatarray_create(la),_wW_=la - 1 | 0,_wV_=0;
      if(! (_wW_ < 0))
       {var i=_wV_;
        for(;;)
         {r[1 + i] = caml_call2(f,a[1 + i],b[1 + i]);
          var _wX_=i + 1 | 0;
          if(_wW_ !== i){var i=_wX_;continue}
          break}}
      return r}
    function iteri$3(f,a)
     {var _wT_=a.length - 1 - 1 | 0,_wS_=0;
      if(! (_wT_ < 0))
       {var i=_wS_;
        for(;;)
         {caml_call2(f,i,a[1 + i]);
          var _wU_=i + 1 | 0;
          if(_wT_ !== i){var i=_wU_;continue}
          break}}
      return 0}
    function mapi$3(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wQ_=l - 1 | 0,_wP_=0;
      if(! (_wQ_ < 0))
       {var i=_wP_;
        for(;;)
         {r[1 + i] = caml_call2(f,i,a[1 + i]);
          var _wR_=i + 1 | 0;
          if(_wQ_ !== i){var i=_wR_;continue}
          break}}
      return r}
    function fold_left$2(f,x,a)
     {var r=[0,x],_wN_=a.length - 1 - 1 | 0,_wM_=0;
      if(! (_wN_ < 0))
       {var i=_wM_;
        for(;;)
         {r[1] = caml_call2(f,r[1],a[1 + i]);
          var _wO_=i + 1 | 0;
          if(_wN_ !== i){var i=_wO_;continue}
          break}}
      return r[1]}
    function fold_right$1(f,a,x)
     {var r=[0,x],_wK_=a.length - 1 - 1 | 0;
      if(! (_wK_ < 0))
       {var i=_wK_;
        for(;;)
         {r[1] = caml_call2(f,a[1 + i],r[1]);
          var _wL_=i - 1 | 0;
          if(0 !== i){var i=_wL_;continue}
          break}}
      return r[1]}
    function exists$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(caml_call1(p,a[1 + i]))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function for_all$1(p,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 1;
        if(caml_call1(p,a[1 + i])){var i$0=i + 1 | 0,i=i$0;continue}
        return 0}}
    function mem$1(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(0 === caml_float_compare(a[1 + i],x))return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    function mem_ieee(x,a)
     {var n=a.length - 1,i=0;
      for(;;)
       {if(i === n)return 0;
        if(x == a[1 + i])return 1;
        var i$0=i + 1 | 0,i=i$0;
        continue}}
    var Bottom$0=[248,cst_Stdlib_Float_Array_Bottom,caml_fresh_oo_id(0)];
    function sort$0(cmp,a)
     {function maxson(l,i)
       {var i31=((i + i | 0) + i | 0) + 1 | 0,x=[0,i31];
        if((i31 + 2 | 0) < l)
         {if
           (caml_call2
             (cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))
            <
            0)
           x[1] = i31 + 1 | 0;
          if
           (caml_call2
             (cmp,caml_array_get(a,x[1]),caml_array_get(a,i31 + 2 | 0))
            <
            0)
           x[1] = i31 + 2 | 0;
          return x[1]}
        if
         ((i31 + 1 | 0)
          <
          l
          &&
          !
          (0
           <=
           caml_call2(cmp,caml_array_get(a,i31),caml_array_get(a,i31 + 1 | 0))))
         return i31 + 1 | 0;
        if(i31 < l)return i31;
        throw [0,Bottom$0,i]}
      function trickledown(l,i,e)
       {var i$0=i;
        for(;;)
         {var j=maxson(l,i$0);
          if(0 < caml_call2(cmp,caml_array_get(a,j),e))
           {caml_array_set(a,i$0,caml_array_get(a,j));var i$0=j;continue}
          return caml_array_set(a,i$0,e)}}
      function trickle(l,i,e)
       {try
         {var _wJ_=trickledown(l,i,e);return _wJ_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0)
           {var i$0=exn[2];return caml_array_set(a,i$0,e)}
          throw exn}}
      function bubbledown(l,i)
       {var i$0=i;
        for(;;)
         {var i$1=maxson(l,i$0);
          caml_array_set(a,i$0,caml_array_get(a,i$1));
          var i$0=i$1;
          continue}}
      function bubble(l,i)
       {try
         {var _wI_=bubbledown(l,i);return _wI_}
        catch(exn)
         {exn = caml_wrap_exception(exn);
          if(exn[1] === Bottom$0){var i$0=exn[2];return i$0}
          throw exn}}
      var l=a.length - 1,_wC_=((l + 1 | 0) / 3 | 0) - 1 | 0;
      if(! (_wC_ < 0))
       {var i$2=_wC_;
        for(;;)
         {trickle(l,i$2,caml_array_get(a,i$2));
          var _wH_=i$2 - 1 | 0;
          if(0 !== i$2){var i$2=_wH_;continue}
          break}}
      var _wD_=l - 1 | 0;
      if(! (_wD_ < 2))
       {var i$0=_wD_;
        a:
        for(;;)
         {var e$0=caml_array_get(a,i$0);
          caml_array_set(a,i$0,caml_array_get(a,0));
          var i$1=bubble(i$0,0),i=i$1;
          for(;;)
           {var father=(i - 1 | 0) / 3 | 0;
            if(i === father)throw [0,Assert_failure,_v_];
            if(0 <= caml_call2(cmp,caml_array_get(a,father),e$0))
             caml_array_set(a,i,e$0);
            else
             {caml_array_set(a,i,caml_array_get(a,father));
              if(0 < father){var i=father;continue}
              caml_array_set(a,0,e$0)}
            var _wG_=i$0 - 1 | 0;
            if(2 !== i$0){var i$0=_wG_;continue a}
            break}
          break}}
      var _wE_=1 < l?1:0;
      if(_wE_)
       {var e=caml_array_get(a,1);
        caml_array_set(a,1,caml_array_get(a,0));
        var _wF_=caml_array_set(a,0,e)}
      else
       var _wF_=_wE_;
      return _wF_}
    function stable_sort(cmp,a)
     {function merge(src1ofs,src1len,src2,src2ofs,src2len,dst,dstofs)
       {var
         src1r=src1ofs + src1len | 0,
         src2r=src2ofs + src2len | 0,
         s2$1=caml_array_get(src2,src2ofs),
         s1$1=caml_array_get(a,src1ofs),
         i1=src1ofs,
         s1=s1$1,
         i2=src2ofs,
         s2=s2$1,
         d=dstofs;
        for(;;)
         {if(0 < caml_call2(cmp,s1,s2))
           {caml_array_set(dst,d,s2);
            var i2$0=i2 + 1 | 0;
            if(i2$0 < src2r)
             {var
               d$0=d + 1 | 0,
               s2$0=caml_array_get(src2,i2$0),
               i2=i2$0,
               s2=s2$0,
               d=d$0;
              continue}
            return blit$2(a,i1,dst,d + 1 | 0,src1r - i1 | 0)}
          caml_array_set(dst,d,s1);
          var i1$0=i1 + 1 | 0;
          if(i1$0 < src1r)
           {var
             d$1=d + 1 | 0,
             s1$0=caml_array_get(a,i1$0),
             i1=i1$0,
             s1=s1$0,
             d=d$1;
            continue}
          return blit$2(src2,i2,dst,d + 1 | 0,src2r - i2 | 0)}}
      function isortto(srcofs,dst,dstofs,len)
       {var _wA_=len - 1 | 0,_wz_=0;
        if(! (_wA_ < 0))
         {var i=_wz_;
          a:
          for(;;)
           {var
             e=caml_array_get(a,srcofs + i | 0),
             j=[0,(dstofs + i | 0) - 1 | 0];
            for(;;)
             {if
               (dstofs
                <=
                j[1]
                &&
                0
                <
                caml_call2(cmp,caml_array_get(dst,j[1]),e))
               {caml_array_set(dst,j[1] + 1 | 0,caml_array_get(dst,j[1]));
                j[1] += -1;
                continue}
              caml_array_set(dst,j[1] + 1 | 0,e);
              var _wB_=i + 1 | 0;
              if(_wA_ !== i){var i=_wB_;continue a}
              break}
            break}}
        return 0}
      function sortto(srcofs,dst,dstofs,len)
       {if(len <= 5)return isortto(srcofs,dst,dstofs,len);
        var l1=len / 2 | 0,l2=len - l1 | 0;
        sortto(srcofs + l1 | 0,dst,dstofs + l1 | 0,l2);
        sortto(srcofs,a,srcofs + l2 | 0,l1);
        return merge(srcofs + l2 | 0,l1,dst,dstofs + l1 | 0,l2,dst,dstofs)}
      var l=a.length - 1;
      if(l <= 5)return isortto(0,a,0,l);
      var l1=l / 2 | 0,l2=l - l1 | 0,t=caml_floatarray_create(l2);
      sortto(l1,t,0,l2);
      sortto(0,a,l2,l1);
      return merge(l2,l1,t,0,l2,a,0)}
    function to_seq$5(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_wx_=i + 1 | 0;
          return [0,x,function(_wy_){return aux(_wx_,_wy_)}]}
        return 0}
      var _wv_=0;
      return function(_ww_){return aux(_wv_,_ww_)}}
    function to_seqi$2(a)
     {function aux(i,param)
       {if(i < a.length - 1)
         {var x=a[1 + i],_wt_=i + 1 | 0;
          return [0,[0,i,x],function(_wu_){return aux(_wt_,_wu_)}]}
        return 0}
      var _wr_=0;
      return function(_ws_){return aux(_wr_,_ws_)}}
    function of_seq$3(i$2)
     {var
       _wq_=0,
       param$0=fold_left(function(acc,x){return [0,x,acc]},_wq_,i$2),
       len=length(param$0),
       a=caml_floatarray_create(len),
       i$1=len - 1 | 0,
       i=i$1,
       param=param$0;
      for(;;)
       {if(param)
         {var tl=param[2],hd=param[1];
          a[1 + i] = hd;
          var i$0=i - 1 | 0,i=i$0,param=tl;
          continue}
        return a}}
    function map_to_array(f,a)
     {var l=a.length - 1;
      if(0 === l)return [0];
      var r=caml_make_vect(l,caml_call1(f,a[1])),_wo_=l - 1 | 0,_wn_=1;
      if(! (_wo_ < 1))
       {var i=_wn_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _wp_=i + 1 | 0;
          if(_wo_ !== i){var i=_wp_;continue}
          break}}
      return r}
    function map_from_array(f,a)
     {var l=a.length - 1,r=caml_floatarray_create(l),_wl_=l - 1 | 0,_wk_=0;
      if(! (_wl_ < 0))
       {var i=_wk_;
        for(;;)
         {r[1 + i] = caml_call1(f,a[1 + i]);
          var _wm_=i + 1 | 0;
          if(_wl_ !== i){var i=_wm_;continue}
          break}}
      return r}
    var
     _w_=caml_floatarray_create,
     _x_=caml_array_set,
     _y_=caml_array_get,
     _z_=
      [0,
       function(_wj_){return _wj_.length - 1},
       _y_,
       _x_,
       make$1,
       _w_,
       init$3,
       append$2,
       concat$2,
       sub$2,
       copy$2,
       fill$1,
       blit$2,
       to_list$2,
       of_list$0,
       iter$6,
       iteri$3,
       map$6,
       mapi$3,
       fold_left$2,
       fold_right$1,
       iter2$1,
       map2$1,
       for_all$1,
       exists$1,
       mem$1,
       mem_ieee,
       sort$0,
       stable_sort,
       stable_sort,
       to_seq$5,
       to_seqi$2,
       of_seq$3,
       map_to_array,
       map_from_array],
     _A_=caml_floatarray_create,
     _B_=caml_array_set,
     _C_=caml_array_get,
     Stdlib_float=
      [0,
       zero,
       one,
       minus_one,
       succ$0,
       pred$0,
       infinity,
       neg_infinity,
       nan,
       pi,
       max_float,
       min_float,
       epsilon,
       is_finite,
       is_infinite,
       is_nan,
       is_integer,
       of_string_opt,
       to_string,
       caml_float_compare,
       equal$7,
       min$1,
       max$1,
       min_max,
       min_num,
       max_num,
       min_max_num,
       hash$0,
       [0,
        function(_wi_){return _wi_.length - 1},
        _C_,
        _B_,
        make$1,
        _A_,
        init$3,
        append$2,
        concat$2,
        sub$2,
        copy$2,
        fill$1,
        blit$2,
        to_list$2,
        of_list$0,
        iter$6,
        iteri$3,
        map$6,
        mapi$3,
        fold_left$2,
        fold_right$1,
        iter2$1,
        map2$1,
        for_all$1,
        exists$1,
        mem$1,
        mem_ieee,
        sort$0,
        stable_sort,
        stable_sort,
        to_seq$5,
        to_seqi$2,
        of_seq$3,
        map_to_array,
        map_from_array],
       _z_];
    caml_register_global(769,Stdlib_float,"Stdlib__float");
    var zero$0=0,one$0=1,minus_one$0=-1;
    function abs$0(x){return 0 <= x?x:- x | 0}
    var max_int$0=2147483647,min_int$0=-2147483648;
    function lognot(x){return x ^ -1}
    function equal$8(_wh_,_wg_){return _wh_ === _wg_?1:0}
    var compare$7=caml_int_compare;
    function to_string$3(x){return caml_string_of_jsbytes("" + x)}
    var
     Stdlib_int=
      [0,
       zero$0,
       one$0,
       minus_one$0,
       abs$0,
       max_int$0,
       min_int$0,
       lognot,
       equal$8,
       compare$7,
       to_string$3];
    caml_register_global(770,Stdlib_int,"Stdlib__int");
    var zero$1=0,one$1=1,minus_one$1=-1;
    function succ$1(n){return n + 1 | 0}
    function pred$1(n){return n - 1 | 0}
    function abs$1(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$1=-2147483648,max_int$1=2147483647;
    function lognot$0(n){return n ^ -1}
    function unsigned_to_int(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$4(n){return caml_format_int(cst_d,n)}
    function of_string_opt$0(s)
     {try
       {var _we_=[0,caml_int_of_string(s)];return _we_}
      catch(_wf_)
       {_wf_ = caml_wrap_exception(_wf_);
        if(_wf_[1] === Failure)return 0;
        throw _wf_}}
    function compare$8(x,y){return caml_int_compare(x,y)}
    function equal$9(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare(n,d)?one$1:zero$1;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare(r,d)?q + 1 | 0:q}
    function unsigned_rem(n,d){return n - caml_mul(unsigned_div(n,d),d) | 0}
    var
     Stdlib_int32=
      [0,
       zero$1,
       one$1,
       minus_one$1,
       unsigned_div,
       unsigned_rem,
       succ$1,
       pred$1,
       abs$1,
       max_int$1,
       min_int$1,
       lognot$0,
       unsigned_to_int,
       of_string_opt$0,
       to_string$4,
       compare$8,
       unsigned_compare,
       equal$9];
    caml_register_global(771,Stdlib_int32,"Stdlib__int32");
    function succ$2(n){return caml_int64_add(n,_D_)}
    function pred$2(n){return caml_int64_sub(n,_E_)}
    function abs$2(n)
     {return caml_greaterequal(n,_F_)?n:runtime.caml_int64_neg(n)}
    function lognot$1(n){return runtime.caml_int64_xor(n,_G_)}
    var max_int$3=caml_int64_of_int32(2147483647);
    function unsigned_to_int$0(n)
     {if
       (!
        (0 < caml_int64_compare(zero$2,n))
        &&
        !
        (0 < caml_int64_compare(n,max_int$3)))
       return [0,runtime.caml_int64_to_int32(n)];
      return 0}
    function to_string$5(n){return caml_int64_format(cst_d$0,n)}
    function of_string_opt$1(s)
     {try
       {var _wc_=[0,caml_int64_of_string(s)];return _wc_}
      catch(_wd_)
       {_wd_ = caml_wrap_exception(_wd_);
        if(_wd_[1] === Failure)return 0;
        throw _wd_}}
    function compare$9(x,y){return caml_int64_compare(x,y)}
    function equal$10(x,y){return 0 === caml_int64_compare(x,y)?1:0}
    function unsigned_compare$0(n,m)
     {return caml_int64_compare
              (caml_int64_sub(n,min_int$2),caml_int64_sub(m,min_int$2))}
    function unsigned_div$0(n,d)
     {if(caml_lessthan(d,zero$2))
       return 0 <= unsigned_compare$0(n,d)?one$2:zero$2;
      var
       q=
        caml_int64_shift_left
         (runtime.caml_int64_div
           (runtime.caml_int64_shift_right_unsigned(n,1),d),
          1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare$0(r,d)?succ$2(q):q}
    function unsigned_rem$0(n,d)
     {return caml_int64_sub(n,caml_int64_mul(unsigned_div$0(n,d),d))}
    var
     Stdlib_int64=
      [0,
       zero$2,
       one$2,
       minus_one$2,
       unsigned_div$0,
       unsigned_rem$0,
       succ$2,
       pred$2,
       abs$2,
       max_int$2,
       min_int$2,
       lognot$1,
       unsigned_to_int$0,
       of_string_opt$1,
       to_string$5,
       compare$9,
       unsigned_compare$0,
       equal$10];
    caml_register_global(772,Stdlib_int64,"Stdlib__int64");
    var zero$3=0,one$3=1,minus_one$3=-1;
    function succ$3(n){return n + 1 | 0}
    function pred$3(n){return n - 1 | 0}
    function abs$3(n){return caml_greaterequal(n,0)?n:- n | 0}
    var min_int$3=-2147483648,max_int$4=2147483647;
    function lognot$2(n){return n ^ -1}
    function unsigned_to_int$1(n)
     {if
       (!
        (0 < caml_int_compare(0,n))
        &&
        !
        (0 < caml_int_compare(n,2147483647)))
       return [0,n];
      return 0}
    function to_string$6(n){return caml_format_int(cst_d$1,n)}
    function of_string_opt$2(s)
     {try
       {var _wa_=[0,caml_int_of_string(s)];return _wa_}
      catch(_wb_)
       {_wb_ = caml_wrap_exception(_wb_);
        if(_wb_[1] === Failure)return 0;
        throw _wb_}}
    function compare$10(x,y){return caml_int_compare(x,y)}
    function equal$11(x,y){return 0 === caml_int_compare(x,y)?1:0}
    function unsigned_compare$1(n,m)
     {return caml_int_compare(n + 2147483648 | 0,m + 2147483648 | 0)}
    function unsigned_div$1(n,d)
     {if(caml_lessthan(d,0))return 0 <= unsigned_compare$1(n,d)?one$3:zero$3;
      var q=caml_div(n >>> 1 | 0,d) << 1,r=n - caml_mul(q,d) | 0;
      return 0 <= unsigned_compare$1(r,d)?q + 1 | 0:q}
    function unsigned_rem$1(n,d)
     {return n - caml_mul(unsigned_div$1(n,d),d) | 0}
    var
     Stdlib_nativeint=
      [0,
       zero$3,
       one$3,
       minus_one$3,
       unsigned_div$1,
       unsigned_rem$1,
       succ$3,
       pred$3,
       abs$3,
       match$1,
       max_int$4,
       min_int$3,
       lognot$2,
       unsigned_to_int$1,
       of_string_opt$2,
       to_string$6,
       compare$10,
       unsigned_compare$1,
       equal$11];
    caml_register_global(773,Stdlib_nativeint,"Stdlib__nativeint");
    function engine(tbl,state,buf)
     {var
       result=runtime.caml_lex_engine(tbl,state,buf),
       _v9_=0 <= result?1:0,
       _v__=_v9_?buf[12] !== dummy_pos?1:0:_v9_;
      if(_v__)
       {buf[11] = buf[12];
        var _v$_=buf[12];
        buf[12] = [0,_v$_[1],_v$_[2],_v$_[3],buf[4] + buf[6] | 0]}
      return result}
    function new_engine(tbl,state,buf)
     {var
       result=runtime.caml_new_lex_engine(tbl,state,buf),
       _v6_=0 <= result?1:0,
       _v7_=_v6_?buf[12] !== dummy_pos?1:0:_v6_;
      if(_v7_)
       {buf[11] = buf[12];
        var _v8_=buf[12];
        buf[12] = [0,_v8_[1],_v8_[2],_v8_[3],buf[4] + buf[6] | 0]}
      return result}
    function from_function(opt,f)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vS_=with_positions?zero_pos:dummy_pos,
       _vT_=with_positions?zero_pos:dummy_pos,
       aux_buffer=caml_create_bytes(512),
       _vU_=[0],
       _vV_=0,
       _vW_=0,
       _vX_=0,
       _vY_=0,
       _vZ_=0,
       _v0_=0,
       _v1_=0,
       _v2_=caml_create_bytes(1024);
      return [0,
              function(lexbuf)
               {var
                 read=
                  caml_call2(f,aux_buffer,caml_ml_bytes_length(aux_buffer)),
                 n=0 < read?read:(lexbuf[9] = 1,0);
                if(caml_ml_bytes_length(lexbuf[2]) < (lexbuf[3] + n | 0))
                 {if
                   (((lexbuf[3] - lexbuf[5] | 0) + n | 0)
                    <=
                    caml_ml_bytes_length(lexbuf[2]))
                   blit
                    (lexbuf[2],lexbuf[5],lexbuf[2],0,lexbuf[3] - lexbuf[5] | 0);
                  else
                   {var
                     newlen=
                      min
                       (2 * caml_ml_bytes_length(lexbuf[2]) | 0,max_string_length);
                    if(newlen < ((lexbuf[3] - lexbuf[5] | 0) + n | 0))
                     failwith(cst_Lexing_lex_refill_cannot_g);
                    var newbuf=caml_create_bytes(newlen);
                    blit(lexbuf[2],lexbuf[5],newbuf,0,lexbuf[3] - lexbuf[5] | 0);
                    lexbuf[2] = newbuf}
                  var s=lexbuf[5];
                  lexbuf[4] = lexbuf[4] + s | 0;
                  lexbuf[6] = lexbuf[6] - s | 0;
                  lexbuf[5] = 0;
                  lexbuf[7] = lexbuf[7] - s | 0;
                  lexbuf[3] = lexbuf[3] - s | 0;
                  var t=lexbuf[10],_v4_=t.length - 1 - 1 | 0,_v3_=0;
                  if(! (_v4_ < 0))
                   {var i=_v3_;
                    for(;;)
                     {var v=caml_check_bound(t,i)[1 + i];
                      if(0 <= v)caml_check_bound(t,i)[1 + i] = v - s | 0;
                      var _v5_=i + 1 | 0;
                      if(_v4_ !== i){var i=_v5_;continue}
                      break}}}
                blit(aux_buffer,0,lexbuf[2],lexbuf[3],n);
                lexbuf[3] = lexbuf[3] + n | 0;
                return 0},
              _v2_,
              _v1_,
              _v0_,
              _vZ_,
              _vY_,
              _vX_,
              _vW_,
              _vV_,
              _vU_,
              _vT_,
              _vS_]}
    function from_channel(with_positions,ic)
     {return from_function
              (with_positions,function(buf,n){return input(ic,buf,0,n)})}
    function from_string$0(opt,s)
     {if(opt)var sth=opt[1],with_positions=sth;else var with_positions=1;
      var
       _vH_=with_positions?zero_pos:dummy_pos,
       _vI_=with_positions?zero_pos:dummy_pos,
       _vJ_=[0],
       _vK_=1,
       _vL_=0,
       _vM_=0,
       _vN_=0,
       _vO_=0,
       _vP_=0,
       _vQ_=caml_ml_string_length(s),
       _vR_=of_string(s);
      return [0,
              function(lexbuf){lexbuf[9] = 1;return 0},
              _vR_,
              _vQ_,
              _vP_,
              _vO_,
              _vN_,
              _vM_,
              _vL_,
              _vK_,
              _vJ_,
              _vI_,
              _vH_]}
    function set_position(lexbuf,position)
     {lexbuf[12] = [0,lexbuf[12][1],position[2],position[3],position[4]];
      lexbuf[4] = position[4];
      return 0}
    function set_filename(lexbuf,fname)
     {var _vG_=lexbuf[12];
      lexbuf[12] = [0,fname,_vG_[2],_vG_[3],_vG_[4]];
      return 0}
    function with_positions(lexbuf){return lexbuf[12] !== dummy_pos?1:0}
    function lexeme(lexbuf)
     {var len=lexbuf[6] - lexbuf[5] | 0;
      return sub_string(lexbuf[2],lexbuf[5],len)}
    function sub_lexeme(lexbuf,i1,i2)
     {var len=i2 - i1 | 0;return sub_string(lexbuf[2],i1,len)}
    function sub_lexeme_opt(lexbuf,i1,i2)
     {if(0 <= i1){var len=i2 - i1 | 0;return [0,sub_string(lexbuf[2],i1,len)]}
      return 0}
    function sub_lexeme_char(lexbuf,i){return caml_bytes_get(lexbuf[2],i)}
    function sub_lexeme_char_opt(lexbuf,i)
     {return 0 <= i?[0,caml_bytes_get(lexbuf[2],i)]:0}
    function lexeme_char(lexbuf,i)
     {return caml_bytes_get(lexbuf[2],lexbuf[5] + i | 0)}
    function lexeme_start(lexbuf){return lexbuf[11][4]}
    function lexeme_end(lexbuf){return lexbuf[12][4]}
    function lexeme_start_p(lexbuf){return lexbuf[11]}
    function lexeme_end_p(lexbuf){return lexbuf[12]}
    function new_line(lexbuf)
     {var
       lcp=lexbuf[12],
       _vE_=lcp !== dummy_pos?1:0,
       _vF_=_vE_?(lexbuf[12] = [0,lcp[1],lcp[2] + 1 | 0,lcp[4],lcp[4]],0):_vE_;
      return _vF_}
    function flush_input(lb)
     {lb[6] = 0;
      lb[4] = 0;
      var lcp=lb[12];
      if(lcp !== dummy_pos)
       lb[12] = [0,lcp[1],zero_pos[2],zero_pos[3],zero_pos[4]];
      lb[3] = 0;
      return 0}
    var
     Stdlib_lexing=
      [0,
       dummy_pos,
       from_channel,
       from_string$0,
       from_function,
       set_position,
       set_filename,
       with_positions,
       lexeme,
       lexeme_char,
       lexeme_start,
       lexeme_end,
       lexeme_start_p,
       lexeme_end_p,
       new_line,
       flush_input,
       sub_lexeme,
       sub_lexeme_opt,
       sub_lexeme_char,
       sub_lexeme_char_opt,
       engine,
       new_engine];
    caml_register_global(774,Stdlib_lexing,"Stdlib__lexing");
    var
     YYexit=[248,cst_Stdlib_Parsing_YYexit,caml_fresh_oo_id(0)],
     Parse_error=[248,cst_Stdlib_Parsing_Parse_error,caml_fresh_oo_id(0)],
     env=
      [0,
       caml_make_vect(100,0),
       caml_make_vect(100,0),
       caml_make_vect(100,dummy_pos),
       caml_make_vect(100,dummy_pos),
       100,
       0,
       0,
       0,
       dummy_pos,
       dummy_pos,
       0,
       0,
       0,
       0,
       0,
       0];
    function grow_stacks(param)
     {var
       oldsize=env[5],
       newsize=oldsize * 2 | 0,
       new_s=caml_make_vect(newsize,0),
       new_v=caml_make_vect(newsize,0),
       new_start=caml_make_vect(newsize,dummy_pos),
       new_end=caml_make_vect(newsize,dummy_pos);
      blit$1(env[1],0,new_s,0,oldsize);
      env[1] = new_s;
      blit$1(env[2],0,new_v,0,oldsize);
      env[2] = new_v;
      blit$1(env[3],0,new_start,0,oldsize);
      env[3] = new_start;
      blit$1(env[4],0,new_end,0,oldsize);
      env[4] = new_end;
      env[5] = newsize;
      return 0}
    function clear_parser(param)
     {fill$0(env[2],0,env[5],0);env[8] = 0;return 0}
    var current_lookahead_fun=[0,function(param){return 0}];
    function yyparse(tables,start,lexer,lexbuf)
     {var
       init_asp=env[11],
       init_sp=env[14],
       init_stackbase=env[6],
       init_state=env[15],
       init_curr_char=env[7],
       init_lval=env[8],
       init_errflag=env[16];
      env[6] = env[14] + 1 | 0;
      env[7] = start;
      env[10] = lexbuf[12];
      try
       {var cmd=0,arg=0;
        for(;;)
         {var match=runtime.caml_parse_engine(tables,env,cmd,arg);
          switch(match)
           {case 0:
             var arg$0=caml_call1(lexer,lexbuf);
             env[9] = lexbuf[11];
             env[10] = lexbuf[12];
             var cmd=1,arg=arg$0;
             continue;
            case 1:throw Parse_error;
            case 2:grow_stacks(0);var cmd=2,arg=0;continue;
            case 3:grow_stacks(0);var cmd=3,arg=0;continue;
            case 4:
             try
              {var
                _vy_=env[13],
                _vz_=
                 caml_call1(caml_check_bound(tables[1],_vy_)[1 + _vy_],env),
                _vA_=4,
                arg$1=_vz_,
                cmd$0=_vA_}
             catch(_vD_)
              {_vD_ = caml_wrap_exception(_vD_);
               if(_vD_ !== Parse_error)throw _vD_;
               var arg$1=0,cmd$0=5,_vB_=_vD_}
             var cmd=cmd$0,arg=arg$1;
             continue;
            default:
             caml_call1(tables[14],cst_syntax_error);var cmd=5,arg=0;continue}}}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        var curr_char=env[7];
        env[11] = init_asp;
        env[14] = init_sp;
        env[6] = init_stackbase;
        env[15] = init_state;
        env[7] = init_curr_char;
        env[8] = init_lval;
        env[16] = init_errflag;
        if(exn[1] === YYexit){var v=exn[2];return v}
        current_lookahead_fun[1]
        =
        function(tok)
         {if(is_block(tok))
           {var _vC_=caml_obj_tag(tok);
            return caml_check_bound(tables[3],_vC_)[1 + _vC_] === curr_char
                    ?1
                    :0}
          return caml_check_bound(tables[2],tok)[1 + tok] === curr_char?1:0};
        throw exn}}
    function peek_val(env,n)
     {var _vx_=env[11] - n | 0;return caml_check_bound(env[2],_vx_)[1 + _vx_]}
    function symbol_start_pos(param)
     {var i=env[12];
      for(;;)
       {if(0 < i)
         {var
           _vu_=(env[11] - i | 0) + 1 | 0,
           st=caml_check_bound(env[3],_vu_)[1 + _vu_],
           _vv_=(env[11] - i | 0) + 1 | 0,
           en=caml_check_bound(env[4],_vv_)[1 + _vv_];
          if(caml_notequal(st,en))return st;
          var i$0=i - 1 | 0,i=i$0;
          continue}
        var _vw_=env[11];
        return caml_check_bound(env[4],_vw_)[1 + _vw_]}}
    function symbol_end_pos(param)
     {var _vt_=env[11];return caml_check_bound(env[4],_vt_)[1 + _vt_]}
    function rhs_start_pos(n)
     {var _vs_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[3],_vs_)[1 + _vs_]}
    function rhs_end_pos(n)
     {var _vr_=env[11] - (env[12] - n | 0) | 0;
      return caml_check_bound(env[4],_vr_)[1 + _vr_]}
    function symbol_start(param){return symbol_start_pos(0)[4]}
    function symbol_end(param){return symbol_end_pos(0)[4]}
    function rhs_start(n){return rhs_start_pos(n)[4]}
    function rhs_end(n){return rhs_end_pos(n)[4]}
    function is_current_lookahead(tok)
     {return caml_call1(current_lookahead_fun[1],tok)}
    function parse_error(param){return 0}
    var
     Stdlib_parsing=
      [0,
       symbol_start,
       symbol_end,
       rhs_start,
       rhs_end,
       symbol_start_pos,
       symbol_end_pos,
       rhs_start_pos,
       rhs_end_pos,
       clear_parser,
       Parse_error,
       function(_vq_){return runtime.caml_set_parser_trace(_vq_)},
       YYexit,
       yyparse,
       peek_val,
       is_current_lookahead,
       parse_error];
    caml_register_global(775,Stdlib_parsing,"Stdlib__parsing");
    var
     Stdlib_set=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[4];return h}return 0}
         function create(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           var _vp_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_vp_]}
         function bal(l,v,r)
          {if(l)var h=l[4],hl=h;else var hl=0;
           if(r)var h$0=r[4],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[3],lv=l[2],ll=l[1],_vk_=height(lr);
               if(_vk_ <= height(ll))return create(ll,lv,create(lr,v,r));
               if(lr)
                {var lrr=lr[3],lrv=lr[2],lrl=lr[1],_vl_=create(lrr,v,r);
                 return create(create(ll,lv,lrl),lrv,_vl_)}
               return invalid_arg(cst_Set_bal)}
             return invalid_arg(cst_Set_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[3],rv=r[2],rl=r[1],_vm_=height(rl);
               if(_vm_ <= height(rr))return create(create(l,v,rl),rv,rr);
               if(rl)
                {var rlr=rl[3],rlv=rl[2],rll=rl[1],_vn_=create(rlr,rv,rr);
                 return create(create(l,v,rll),rlv,_vn_)}
               return invalid_arg(cst_Set_bal$1)}
             return invalid_arg(cst_Set_bal$2)}
           var _vo_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,v,r,_vo_]}
         function add(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return t;
             if(0 <= c){var rr=add(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=add(x,l);
             return l === ll?t:bal(ll,v,r)}
           return [0,0,x,0,1]}
         function singleton(x){return [0,0,x,0,1]}
         function add_min_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(add_min_element(x,l),v,r)}
           return singleton(x)}
         function add_max_element(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1];
             return bal(l,v,add_max_element(x,r))}
           return singleton(x)}
         function join(l,v,r)
          {if(l)
            {if(r)
              {var
                rh=r[4],
                rr=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[4],
                lr=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,join(lr,v,r))
                       :(lh + 2 | 0) < rh?bal(join(l,v,rl),rv,rr):create(l,v,r)}
             return add_max_element(v,l)}
           return add_min_element(v,r)}
         function min_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vj_=param$0[1];
               if(_vj_){var param$0=_vj_;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function min_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _vi_=param$0[1];
               if(_vi_){var param$0=_vi_;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function max_elt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return v}
             throw Not_found}}
         function max_elt_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[3]){var param$1=param$0[3],param$0=param$1;continue}
               var v=param$0[2];
               return [0,v]}
             return 0}}
         function remove_min_elt(param)
          {if(param)
            {var _vh_=param[1];
             if(_vh_)
              {var r=param[3],v=param[2];return bal(remove_min_elt(_vh_),v,r)}
             var r$0=param[3];
             return r$0}
           return invalid_arg(cst_Set_remove_min_elt)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var _vg_=remove_min_elt(match);
               return join(t,min_elt(match),_vg_)}
             return t}
           return match}
         function split(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,1,r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,r)]}
           return _H_}
         var empty=0;
         function is_empty(param){return param?0:1}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _vf_=0 === c?1:0;
               if(_vf_)return _vf_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function remove(x,t)
          {if(t)
            {var r=t[3],v=t[2],l=t[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {if(l)
                {if(r)
                  {var _ve_=remove_min_elt(r);return bal(l,min_elt(r),_ve_)}
                 return l}
               return r}
             if(0 <= c){var rr=remove(x,r);return r === rr?t:bal(l,v,rr)}
             var ll=remove(x,l);
             return l === ll?t:bal(ll,v,r)}
           return 0}
         function union(t1,match)
          {if(t1)
            {if(match)
              {var
                h2=match[4],
                r2=match[3],
                v2=match[2],
                l2=match[1],
                h1=t1[4],
                r1=t1[3],
                v1=t1[2],
                l1=t1[1];
               if(h2 <= h1)
                {if(1 === h2)return add(v2,t1);
                 var
                  match$0=split(v1,match),
                  r2$0=match$0[3],
                  l2$0=match$0[1],
                  _vc_=union(r1,r2$0);
                 return join(union(l1,l2$0),v1,_vc_)}
               if(1 === h1)return add(v1,match);
               var
                match$1=split(v2,t1),
                r1$0=match$1[3],
                l1$0=match$1[1],
                _vd_=union(r1$0,r2);
               return join(union(l1$0,l2),v2,_vd_)}
             return t1}
           return match}
         function inter(s1,match)
          {if(s1)
            {if(match)
              {var
                r1=s1[3],
                v1=s1[2],
                l1=s1[1],
                _u__=split(v1,match),
                _u$_=_u__[1];
               if(_u__[2])
                {var r2=_u__[3],_va_=inter(r1,r2);
                 return join(inter(l1,_u$_),v1,_va_)}
               var r2$0=_u__[3],_vb_=inter(r1,r2$0);
               return concat(inter(l1,_u$_),_vb_)}
             return 0}
           return 0}
         function split_bis(x,param)
          {if(param)
            {var r=param[3],v=param[2],l=param[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return 0;
             if(0 <= c)
              {var match=split_bis(x,r);
               if(match)
                {var rr=match[2],lr=match[1];return [0,join(l,v,lr),rr]}
               return 0}
             var match$0=split_bis(x,l);
             if(match$0)
              {var rl=match$0[2],ll=match$0[1];
               return [0,
                       ll,
                       function(param){return join(caml_call1(rl,0),v,r)}]}
             return 0}
           return [0,0,function(param){return 0}]}
         function disjoint(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0 && s2$0)
              {var r1=s1$0[3],v1=s1$0[2],l1=s1$0[1];
               if(s1$0 === s2$0)return 0;
               var match=split_bis(v1,s2$0);
               if(match)
                {var r2=match[2],l2=match[1],_u9_=disjoint(l1,l2);
                 if(_u9_)
                  {var s2$1=caml_call1(r2,0),s1$0=r1,s2$0=s2$1;continue}
                 return _u9_}
               return 0}
             return 1}}
         function diff(t1,match)
          {if(t1)
            {if(match)
              {var
                r1=t1[3],
                v1=t1[2],
                l1=t1[1],
                _u5_=split(v1,match),
                _u6_=_u5_[1];
               if(_u5_[2])
                {var r2=_u5_[3],_u7_=diff(r1,r2);
                 return concat(diff(l1,_u6_),_u7_)}
               var r2$0=_u5_[3],_u8_=diff(r1,r2$0);
               return join(diff(l1,_u6_),v1,_u8_)}
             return t1}
           return 0}
         function cons_enum(s,e)
          {var s$0=s,e$0=e;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                s$1=s$0[1],
                e$1=[0,v,r,e$0],
                s$0=s$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(s1,s2)
          {var e2$2=cons_enum(s2,0),e1$2=cons_enum(s1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[3],
                  r2=e2[2],
                  v2=e2[1],
                  e1$0=e1[3],
                  r1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var
                    e2$1=cons_enum(r2,e2$0),
                    e1$1=cons_enum(r1,e1$0),
                    e1=e1$1,
                    e2=e2$1;
                   continue}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(s1,s2){return 0 === compare(s1,s2)?1:0}
         function subset(s1,s2)
          {var s1$0=s1,s2$0=s2;
           for(;;)
            {if(s1$0)
              {if(s2$0)
                {var
                  r2=s2$0[3],
                  v2=s2$0[2],
                  l2=s2$0[1],
                  r1=s1$0[3],
                  v1=s1$0[2],
                  l1=s1$0[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var _u2_=subset(l1,l2);
                   if(_u2_){var s1$0=r1,s2$0=r2;continue}
                   return _u2_}
                 if(0 <= c)
                  {var _u3_=subset([0,0,v1,r1,0],r2);
                   if(_u3_){var s1$0=l1;continue}
                   return _u3_}
                 var _u4_=subset([0,l1,v1,0,0],l2);
                 if(_u4_){var s1$0=r1;continue}
                 return _u4_}
               return 0}
             return 1}}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call1(f,v);
               var param$0=r;
               continue}
             return 0}}
         function fold(f,s,accu)
          {var s$0=s,accu$0=accu;
           for(;;)
            {if(s$0)
              {var
                r=s$0[3],
                v=s$0[2],
                l=s$0[1],
                accu$1=caml_call2(f,v,fold(f,l,accu$0)),
                s$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uZ_=caml_call1(p,v);
               if(_uZ_)
                {var _u0_=for_all(p,l);
                 if(_u0_){var param$0=r;continue}
                 var _u1_=_u0_}
               else
                var _u1_=_uZ_;
               return _u1_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uW_=caml_call1(p,v);
               if(_uW_)
                var _uX_=_uW_;
               else
                {var _uY_=exists(p,l);
                 if(! _uY_){var param$0=r;continue}
                 var _uX_=_uY_}
               return _uX_}
             return 0}}
         function filter(p,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=filter(p,l),
              pv=caml_call1(p,v),
              r$0=filter(p,r);
             if(pv){if(l === l$0 && r === r$0)return t;return join(l$0,v,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pv=caml_call1(p,v),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pv){var _uU_=concat(lf,rf);return [0,join(lt,v,rt),_uU_]}
             var _uV_=join(lf,v,rf);
             return [0,concat(lt,rt),_uV_]}
           return _I_}
         function cardinal(param)
          {if(param)
            {var r=param[3],l=param[1],_uT_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _uT_ | 0}
           return 0}
         function elements_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,v,elements_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function elements(s){return elements_aux(0,s)}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return v;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return v0}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return v0}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var r$0=param$1[3],v$0=param$1[2],l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,v];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function try_join(l,v,r)
          {var switch$0=0;
           if(0 !== l)
            {var _uS_=max_elt(l);
             if(0 <= caml_call2(Ord[1],_uS_,v))switch$0 = 1}
           if(! switch$0)
            {var switch$1=0;
             if(0 !== r)
              {var _uR_=min_elt(r);
               if(0 <= caml_call2(Ord[1],v,_uR_))switch$1 = 1}
             if(! switch$1)return join(l,v,r)}
           return union(l,add(v,r))}
         function map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              l$0=map(f,l),
              v$0=caml_call1(f,v),
              r$0=map(f,r);
             if(l === l$0 && v === v$0 && r === r$0)return t;
             return try_join(l$0,v$0,r$0)}
           return 0}
         function filter_map(f,t)
          {if(t)
            {var
              r=t[3],
              v=t[2],
              l=t[1],
              t$0=filter_map(f,l),
              v$0=caml_call1(f,v),
              match=filter_map(f,r);
             if(v$0)
              {var v$1=v$0[1];
               if(l === t$0 && v === v$1 && r === match)return t;
               return try_join(t$0,v$1,match)}
             if(t$0)
              {if(match)
                {var _uQ_=remove_min_elt(match);
                 return try_join(t$0,min_elt(match),_uQ_)}
               return t$0}
             return match}
           return 0}
         function of_list(l)
          {if(l)
            {var _uF_=l[2],_uG_=l[1];
             if(_uF_)
              {var _uH_=_uF_[2],_uI_=_uF_[1];
               if(_uH_)
                {var _uJ_=_uH_[2],_uK_=_uH_[1];
                 if(_uJ_)
                  {var _uL_=_uJ_[2],_uM_=_uJ_[1];
                   if(_uL_)
                    {if(_uL_[2])
                      {var
                        l$0=sort_uniq(Ord[1],l),
                        sub=
                         function(n,l)
                          {if(! (3 < n >>> 0))
                            switch(n)
                             {case 0:return [0,0,l];
                              case 1:
                               if(l){var l$3=l[2],x0=l[1];return [0,[0,0,x0,0,1],l$3]}
                               break;
                              case 2:
                               if(l)
                                {var _uN_=l[2];
                                 if(_uN_)
                                  {var l$4=_uN_[2],x1=_uN_[1],x0$0=l[1];
                                   return [0,[0,[0,0,x0$0,0,1],x1,0,2],l$4]}}
                               break;
                              default:
                               if(l)
                                {var _uO_=l[2];
                                 if(_uO_)
                                  {var _uP_=_uO_[2];
                                   if(_uP_)
                                    {var l$5=_uP_[2],x2=_uP_[1],x1$0=_uO_[1],x0$1=l[1];
                                     return [0,[0,[0,0,x0$1,0,1],x1$0,[0,0,x2,0,1],2],l$5]}}}}
                           var nl=n / 2 | 0,match=sub(nl,l),l$0=match[2],left=match[1];
                           if(l$0)
                            {var
                              l$1=l$0[2],
                              mid=l$0[1],
                              match$0=sub((n - nl | 0) - 1 | 0,l$1),
                              l$2=match$0[2],
                              right=match$0[1];
                             return [0,create(left,mid,right),l$2]}
                           throw [0,Assert_failure,_J_]};
                       return sub(length(l$0),l$0)[1]}
                     var x4=_uL_[1];
                     return add(x4,add(_uM_,add(_uK_,add(_uI_,singleton(_uG_)))))}
                   return add(_uM_,add(_uK_,add(_uI_,singleton(_uG_))))}
                 return add(_uK_,add(_uI_,singleton(_uG_)))}
               return add(_uI_,singleton(_uG_))}
             return singleton(_uG_)}
           return empty}
         function add_seq(i,m)
          {return fold_left(function(s,x){return add(x,s)},m,i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[3],t=c[2],x=c[1],_uD_=cons_enum(t,rest);
             return [0,x,function(_uE_){return seq_of_enum(_uD_,_uE_)}]}
           return 0}
         function to_seq(c)
          {var _uB_=cons_enum(c,0);
           return function(_uC_){return seq_of_enum(_uB_,_uC_)}}
         function to_seq_from(low,s)
          {var s$0=s,c=0;
           for(;;)
            {if(s$0)
              {var r=s$0[3],v=s$0[2],l=s$0[1],n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,r,c],s$0=l,c=c$0;continue}
                 var s$0=r;
                 continue}
               var _uz_=[0,v,r,c]}
             else
              var _uz_=c;
             return function(_uA_){return seq_of_enum(_uz_,_uA_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 singleton,
                 remove,
                 union,
                 inter,
                 disjoint,
                 diff,
                 compare,
                 equal,
                 subset,
                 iter,
                 map,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 elements,
                 min_elt,
                 min_elt_opt,
                 max_elt,
                 max_elt_opt,
                 min_elt,
                 min_elt_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 of_list,
                 to_seq_from,
                 to_seq,
                 add_seq,
                 of_seq]}];
    caml_register_global(776,Stdlib_set,"Stdlib__set");
    var
     Stdlib_map=
      [0,
       function(Ord)
        {function height(param){if(param){var h=param[5];return h}return 0}
         function create(l,x,d,r)
          {var hl=height(l),hr=height(r),_uy_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_uy_]}
         function singleton(x,d){return [0,0,x,d,0,1]}
         function bal(l,x,d,r)
          {if(l)var h=l[5],hl=h;else var hl=0;
           if(r)var h$0=r[5],hr=h$0;else var hr=0;
           if((hr + 2 | 0) < hl)
            {if(l)
              {var lr=l[4],ld=l[3],lv=l[2],ll=l[1],_ut_=height(lr);
               if(_ut_ <= height(ll))return create(ll,lv,ld,create(lr,x,d,r));
               if(lr)
                {var
                  lrr=lr[4],
                  lrd=lr[3],
                  lrv=lr[2],
                  lrl=lr[1],
                  _uu_=create(lrr,x,d,r);
                 return create(create(ll,lv,ld,lrl),lrv,lrd,_uu_)}
               return invalid_arg(cst_Map_bal)}
             return invalid_arg(cst_Map_bal$0)}
           if((hl + 2 | 0) < hr)
            {if(r)
              {var rr=r[4],rd=r[3],rv=r[2],rl=r[1],_uv_=height(rl);
               if(_uv_ <= height(rr))return create(create(l,x,d,rl),rv,rd,rr);
               if(rl)
                {var
                  rlr=rl[4],
                  rld=rl[3],
                  rlv=rl[2],
                  rll=rl[1],
                  _uw_=create(rlr,rv,rd,rr);
                 return create(create(l,x,d,rll),rlv,rld,_uw_)}
               return invalid_arg(cst_Map_bal$1)}
             return invalid_arg(cst_Map_bal$2)}
           var _ux_=hr <= hl?hl + 1 | 0:hr + 1 | 0;
           return [0,l,x,d,r,_ux_]}
         var empty=0;
         function is_empty(param){return param?0:1}
         function add(x,data,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return d === data?m:[0,l,x,data,r,h];
             if(0 <= c){var rr=add(x,data,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=add(x,data,l);
             return l === ll?m:bal(ll,v,d,r)}
           return [0,0,x,data,0,1]}
         function find(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return d;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             throw Not_found}}
         function find_first(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,v0,d0]}}
               var param$1=r$0;
               continue}
             throw Not_found}}
         function find_first_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=l$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=l;continue}
                     var param=r;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=r$0;
               continue}
             return 0}}
         function find_last(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,v0,d0]}}
               var param$1=l$0;
               continue}
             throw Not_found}}
         function find_last_opt(f,param$0)
          {var param$1=param$0;
           for(;;)
            {if(param$1)
              {var
                r$0=param$1[4],
                d$0=param$1[3],
                v$0=param$1[2],
                l$0=param$1[1];
               if(caml_call1(f,v$0))
                {var v0=v$0,d0=d$0,param=r$0;
                 for(;;)
                  {if(param)
                    {var r=param[4],d=param[3],v=param[2],l=param[1];
                     if(caml_call1(f,v)){var v0=v,d0=d,param=r;continue}
                     var param=l;
                     continue}
                   return [0,[0,v0,d0]]}}
               var param$1=l$0;
               continue}
             return 0}}
         function find_opt(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v);
               if(0 === c)return [0,d];
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function mem(x,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                v=param$0[2],
                l=param$0[1],
                c=caml_call2(Ord[1],x,v),
                _us_=0 === c?1:0;
               if(_us_)return _us_;
               var param$1=0 <= c?r:l,param$0=param$1;
               continue}
             return 0}}
         function min_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _ur_=param$0[1];
               if(_ur_){var param$0=_ur_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function min_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var _uq_=param$0[1];
               if(_uq_){var param$0=_uq_;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function max_binding(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,v,d]}
             throw Not_found}}
         function max_binding_opt(param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {if(param$0[4]){var param$1=param$0[4],param$0=param$1;continue}
               var d=param$0[3],v=param$0[2];
               return [0,[0,v,d]]}
             return 0}}
         function remove_min_binding(param)
          {if(param)
            {var _up_=param[1];
             if(_up_)
              {var r=param[4],d=param[3],v=param[2];
               return bal(remove_min_binding(_up_),v,d,r)}
             var r$0=param[4];
             return r$0}
           return invalid_arg(cst_Map_remove_min_elt)}
         function _t4_(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return bal(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function remove(x,m)
          {if(m)
            {var r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)return _t4_(l,r);
             if(0 <= c){var rr=remove(x,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=remove(x,l);
             return l === ll?m:bal(ll,v,d,r)}
           return 0}
         function update(x,f,m)
          {if(m)
            {var h=m[5],r=m[4],d=m[3],v=m[2],l=m[1],c=caml_call2(Ord[1],x,v);
             if(0 === c)
              {var match=caml_call1(f,[0,d]);
               if(match)
                {var data=match[1];return d === data?m:[0,l,x,data,r,h]}
               return _t4_(l,r)}
             if(0 <= c){var rr=update(x,f,r);return r === rr?m:bal(l,v,d,rr)}
             var ll=update(x,f,l);
             return l === ll?m:bal(ll,v,d,r)}
           var match$0=caml_call1(f,0);
           if(match$0){var data$0=match$0[1];return [0,0,x,data$0,0,1]}
           return 0}
         function iter(f,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var r=param$0[4],d=param$0[3],v=param$0[2],l=param$0[1];
               iter(f,l);
               caml_call2(f,v,d);
               var param$0=r;
               continue}
             return 0}}
         function map(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=map(f,l),
              d$0=caml_call1(f,d),
              r$0=map(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function mapi(f,param)
          {if(param)
            {var
              h=param[5],
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=mapi(f,l),
              d$0=caml_call2(f,v,d),
              r$0=mapi(f,r);
             return [0,l$0,v,d$0,r$0,h]}
           return 0}
         function fold(f,m,accu)
          {var m$0=m,accu$0=accu;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                accu$1=caml_call3(f,v,d,fold(f,l,accu$0)),
                m$0=r,
                accu$0=accu$1;
               continue}
             return accu$0}}
         function for_all(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _um_=caml_call2(p,v,d);
               if(_um_)
                {var _un_=for_all(p,l);
                 if(_un_){var param$0=r;continue}
                 var _uo_=_un_}
               else
                var _uo_=_um_;
               return _uo_}
             return 1}}
         function exists(p,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                _uj_=caml_call2(p,v,d);
               if(_uj_)
                var _uk_=_uj_;
               else
                {var _ul_=exists(p,l);
                 if(! _ul_){var param$0=r;continue}
                 var _uk_=_ul_}
               return _uk_}
             return 0}}
         function add_min_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(add_min_binding(k,x,l),v,d,r)}
           return singleton(k,x)}
         function add_max_binding(k,x,param)
          {if(param)
            {var r=param[4],d=param[3],v=param[2],l=param[1];
             return bal(l,v,d,add_max_binding(k,x,r))}
           return singleton(k,x)}
         function join(l,v,d,r)
          {if(l)
            {if(r)
              {var
                rh=r[5],
                rr=r[4],
                rd=r[3],
                rv=r[2],
                rl=r[1],
                lh=l[5],
                lr=l[4],
                ld=l[3],
                lv=l[2],
                ll=l[1];
               return (rh + 2 | 0) < lh
                       ?bal(ll,lv,ld,join(lr,v,d,r))
                       :(lh + 2 | 0) < rh
                         ?bal(join(l,v,d,rl),rv,rd,rr)
                         :create(l,v,d,r)}
             return add_max_binding(v,d,l)}
           return add_min_binding(v,d,r)}
         function concat(t,match)
          {if(t)
            {if(match)
              {var match$0=min_binding(match),d=match$0[2],x=match$0[1];
               return join(t,x,d,remove_min_binding(match))}
             return t}
           return match}
         function concat_or_join(t1,v,d,t2)
          {if(d){var d$0=d[1];return join(t1,v,d$0,t2)}return concat(t1,t2)}
         function split(x,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              c=caml_call2(Ord[1],x,v);
             if(0 === c)return [0,l,[0,d],r];
             if(0 <= c)
              {var match=split(x,r),rr=match[3],pres=match[2],lr=match[1];
               return [0,join(l,v,d,lr),pres,rr]}
             var
              match$0=split(x,l),
              rl=match$0[3],
              pres$0=match$0[2],
              ll=match$0[1];
             return [0,ll,pres$0,join(rl,v,d,r)]}
           return _K_}
         function merge(f,s1,s2)
          {if(s1)
            {var h1=s1[5],r1=s1[4],d1=s1[3],v1=s1[2],l1=s1[1];
             if(height(s2) <= h1)
              {var
                match=split(v1,s2),
                r2=match[3],
                d2=match[2],
                l2=match[1],
                _uf_=merge(f,r1,r2),
                _ug_=caml_call3(f,v1,[0,d1],d2);
               return concat_or_join(merge(f,l1,l2),v1,_ug_,_uf_)}}
           else
            if(! s2)return 0;
           if(s2)
            {var
              r2$0=s2[4],
              d2$0=s2[3],
              v2=s2[2],
              l2$0=s2[1],
              match$0=split(v2,s1),
              r1$0=match$0[3],
              d1$0=match$0[2],
              l1$0=match$0[1],
              _uh_=merge(f,r1$0,r2$0),
              _ui_=caml_call3(f,v2,d1$0,[0,d2$0]);
             return concat_or_join(merge(f,l1$0,l2$0),v2,_ui_,_uh_)}
           throw [0,Assert_failure,_L_]}
         function union(f,s1,s2)
          {if(s1)
            {if(s2)
              {var
                h2=s2[5],
                r2=s2[4],
                d2=s2[3],
                v2=s2[2],
                l2=s2[1],
                h1=s1[5],
                r1=s1[4],
                d1=s1[3],
                v1=s1[2],
                l1=s1[1];
               if(h2 <= h1)
                {var
                  match=split(v1,s2),
                  r2$0=match[3],
                  d2$0=match[2],
                  l2$0=match[1],
                  l=union(f,l1,l2$0),
                  r=union(f,r1,r2$0);
                 if(d2$0)
                  {var d2$1=d2$0[1];
                   return concat_or_join(l,v1,caml_call3(f,v1,d1,d2$1),r)}
                 return join(l,v1,d1,r)}
               var
                match$0=split(v2,s1),
                r1$0=match$0[3],
                d1$0=match$0[2],
                l1$0=match$0[1],
                l$0=union(f,l1$0,l2),
                r$0=union(f,r1$0,r2);
               if(d1$0)
                {var d1$1=d1$0[1];
                 return concat_or_join(l$0,v2,caml_call3(f,v2,d1$1,d2),r$0)}
               return join(l$0,v2,d2,r$0)}
             var s=s1}
           else
            var s=s2;
           return s}
         function filter(p,m)
          {if(m)
            {var
              r=m[4],
              d=m[3],
              v=m[2],
              l=m[1],
              l$0=filter(p,l),
              pvd=caml_call2(p,v,d),
              r$0=filter(p,r);
             if(pvd)
              {if(l === l$0 && r === r$0)return m;return join(l$0,v,d,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function filter_map(f,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              l$0=filter_map(f,l),
              fvd=caml_call2(f,v,d),
              r$0=filter_map(f,r);
             if(fvd){var d$0=fvd[1];return join(l$0,v,d$0,r$0)}
             return concat(l$0,r$0)}
           return 0}
         function partition(p,param)
          {if(param)
            {var
              r=param[4],
              d=param[3],
              v=param[2],
              l=param[1],
              match=partition(p,l),
              lf=match[2],
              lt=match[1],
              pvd=caml_call2(p,v,d),
              match$0=partition(p,r),
              rf=match$0[2],
              rt=match$0[1];
             if(pvd){var _ud_=concat(lf,rf);return [0,join(lt,v,d,rt),_ud_]}
             var _ue_=join(lf,v,d,rf);
             return [0,concat(lt,rt),_ue_]}
           return _M_}
         function cons_enum(m,e)
          {var m$0=m,e$0=e;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                m$1=m$0[1],
                e$1=[0,v,d,r,e$0],
                m$0=m$1,
                e$0=e$1;
               continue}
             return e$0}}
         function compare(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  c=caml_call2(Ord[1],v1,v2);
                 if(0 === c)
                  {var c$0=caml_call2(cmp,d1,d2);
                   if(0 === c$0)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   return c$0}
                 return c}
               return 1}
             return e2?-1:0}}
         function equal(cmp,m1,m2)
          {var e2$2=cons_enum(m2,0),e1$2=cons_enum(m1,0),e1=e1$2,e2=e2$2;
           for(;;)
            {if(e1)
              {if(e2)
                {var
                  e2$0=e2[4],
                  r2=e2[3],
                  d2=e2[2],
                  v2=e2[1],
                  e1$0=e1[4],
                  r1=e1[3],
                  d1=e1[2],
                  v1=e1[1],
                  _ua_=0 === caml_call2(Ord[1],v1,v2)?1:0;
                 if(_ua_)
                  {var _ub_=caml_call2(cmp,d1,d2);
                   if(_ub_)
                    {var
                      e2$1=cons_enum(r2,e2$0),
                      e1$1=cons_enum(r1,e1$0),
                      e1=e1$1,
                      e2=e2$1;
                     continue}
                   var _uc_=_ub_}
                 else
                  var _uc_=_ua_;
                 return _uc_}
               return 0}
             return e2?0:1}}
         function cardinal(param)
          {if(param)
            {var r=param[4],l=param[1],_t$_=cardinal(r);
             return (cardinal(l) + 1 | 0) + _t$_ | 0}
           return 0}
         function bindings_aux(accu,param)
          {var accu$0=accu,param$0=param;
           for(;;)
            {if(param$0)
              {var
                r=param$0[4],
                d=param$0[3],
                v=param$0[2],
                l=param$0[1],
                accu$1=[0,[0,v,d],bindings_aux(accu$0,r)],
                accu$0=accu$1,
                param$0=l;
               continue}
             return accu$0}}
         function bindings(s){return bindings_aux(0,s)}
         function add_seq(i,m)
          {return fold_left
                   (function(m,param)
                     {var v=param[2],k=param[1];return add(k,v,m)},
                    m,
                    i)}
         function of_seq(i){return add_seq(i,empty)}
         function seq_of_enum(c,param)
          {if(c)
            {var rest=c[4],t=c[3],v=c[2],k=c[1],_t9_=cons_enum(t,rest);
             return [0,[0,k,v],function(_t__){return seq_of_enum(_t9_,_t__)}]}
           return 0}
         function to_seq(m)
          {var _t7_=cons_enum(m,0);
           return function(_t8_){return seq_of_enum(_t7_,_t8_)}}
         function to_seq_from(low,m)
          {var m$0=m,c=0;
           for(;;)
            {if(m$0)
              {var
                r=m$0[4],
                d=m$0[3],
                v=m$0[2],
                l=m$0[1],
                n=caml_call2(Ord[1],v,low);
               if(0 !== n)
                {if(0 <= n){var c$0=[0,v,d,r,c],m$0=l,c=c$0;continue}
                 var m$0=r;
                 continue}
               var _t5_=[0,v,d,r,c]}
             else
              var _t5_=c;
             return function(_t6_){return seq_of_enum(_t5_,_t6_)}}}
         return [0,
                 empty,
                 is_empty,
                 mem,
                 add,
                 update,
                 singleton,
                 remove,
                 merge,
                 union,
                 compare,
                 equal,
                 iter,
                 fold,
                 for_all,
                 exists,
                 filter,
                 filter_map,
                 partition,
                 cardinal,
                 bindings,
                 min_binding,
                 min_binding_opt,
                 max_binding,
                 max_binding_opt,
                 min_binding,
                 min_binding_opt,
                 split,
                 find,
                 find_opt,
                 find_first,
                 find_first_opt,
                 find_last,
                 find_last_opt,
                 map,
                 mapi,
                 to_seq,
                 to_seq_from,
                 add_seq,
                 of_seq]}];
    caml_register_global(777,Stdlib_map,"Stdlib__map");
    var Empty=[248,cst_Stdlib_Stack_Empty,caml_fresh_oo_id(0)];
    function create$0(param){return [0,0,0]}
    function clear(s){s[1] = 0;s[2] = 0;return 0}
    function copy$3(s){return [0,s[1],s[2]]}
    function push(x,s){s[1] = [0,x,s[1]];s[2] = s[2] + 1 | 0;return 0}
    function pop(s)
     {var _t3_=s[1];
      if(_t3_)
       {var tl=_t3_[2],hd=_t3_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return hd}
      throw Empty}
    function pop_opt(s)
     {var _t2_=s[1];
      if(_t2_)
       {var tl=_t2_[2],hd=_t2_[1];s[1] = tl;s[2] = s[2] - 1 | 0;return [0,hd]}
      return 0}
    function top(s)
     {var _t1_=s[1];if(_t1_){var hd=_t1_[1];return hd}throw Empty}
    function top_opt(s)
     {var _t0_=s[1];if(_t0_){var hd=_t0_[1];return [0,hd]}return 0}
    function is_empty(s){return 0 === s[1]?1:0}
    function length$1(s){return s[2]}
    function iter$7(f,s){return iter$2(f,s[1])}
    function fold$1(f,acc,s){return fold_left$0(f,acc,s[1])}
    function to_seq$6(s){return to_seq$1(s[1])}
    function add_seq(q,i){return iter(function(x){return push(x,q)},i)}
    function of_seq$4(g){var s=create$0(0);add_seq(s,g);return s}
    var
     Stdlib_stack=
      [0,
       Empty,
       create$0,
       push,
       pop,
       pop_opt,
       top,
       top_opt,
       clear,
       copy$3,
       is_empty,
       length$1,
       iter$7,
       fold$1,
       to_seq$6,
       add_seq,
       of_seq$4];
    caml_register_global(778,Stdlib_stack,"Stdlib__stack");
    var Empty$0=[248,cst_Stdlib_Queue_Empty,caml_fresh_oo_id(0)];
    function create$1(param){return [0,0,0,0]}
    function clear$0(q){q[1] = 0;q[2] = 0;q[3] = 0;return 0}
    function add(x,q)
     {var cell=[0,x,0],_tZ_=q[3];
      return _tZ_
              ?(q[1] = q[1] + 1 | 0,_tZ_[2] = cell,q[3] = cell,0)
              :(q[1] = 1,q[2] = cell,q[3] = cell,0)}
    function peek(q)
     {var _tY_=q[2];if(_tY_){var content=_tY_[1];return content}throw Empty$0}
    function peek_opt(q)
     {var _tX_=q[2];if(_tX_){var content=_tX_[1];return [0,content]}return 0}
    function take(q)
     {var _tV_=q[2];
      if(_tV_)
       {var _tW_=_tV_[1];
        if(_tV_[2])
         {var next=_tV_[2];q[1] = q[1] - 1 | 0;q[2] = next;return _tW_}
        clear$0(q);
        return _tW_}
      throw Empty$0}
    function take_opt(q)
     {var _tT_=q[2];
      if(_tT_)
       {var _tU_=_tT_[1];
        if(_tT_[2])
         {var next=_tT_[2];q[1] = q[1] - 1 | 0;q[2] = next;return [0,_tU_]}
        clear$0(q);
        return [0,_tU_]}
      return 0}
    function copy$4(q)
     {var q_res=[0,q[1],0,0],prev=0,cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2],res=[0,content,0];
          if(prev)prev[2] = res;else q_res[2] = res;
          var prev=res,cell=next;
          continue}
        q_res[3] = prev;
        return q_res}}
    function is_empty$0(q){return 0 === q[1]?1:0}
    function length$2(q){return q[1]}
    function iter$8(f,q)
     {var cell=q[2];
      for(;;)
       {if(cell)
         {var content=cell[1],next=cell[2];
          caml_call1(f,content);
          var cell=next;
          continue}
        return 0}}
    function fold$2(f,accu$1,q)
     {var accu=accu$1,cell=q[2];
      for(;;)
       {if(cell)
         {var
           content=cell[1],
           next=cell[2],
           accu$0=caml_call2(f,accu,content),
           accu=accu$0,
           cell=next;
          continue}
        return accu}}
    function transfer(q1,q2)
     {var _tR_=0 < q1[1]?1:0;
      if(_tR_)
       {var _tS_=q2[3];
        return _tS_
                ?(q2[1]
                  =
                  q2[1]
                  +
                  q1[1]
                  |
                  0,
                  _tS_[2]
                  =
                  q1[2],
                  q2[3]
                  =
                  q1[3],
                  clear$0(q1))
                :(q2[1] = q1[1],q2[2] = q1[2],q2[3] = q1[3],clear$0(q1))}
      return _tR_}
    function to_seq$7(q)
     {function aux(c,param)
       {if(c)
         {var x=c[1],next=c[2];
          return [0,x,function(_tQ_){return aux(next,_tQ_)}]}
        return 0}
      var _tO_=q[2];
      return function(_tP_){return aux(_tO_,_tP_)}}
    function add_seq$0(q,i){return iter(function(x){return add(x,q)},i)}
    function of_seq$5(g){var q=create$1(0);add_seq$0(q,g);return q}
    var
     Stdlib_queue=
      [0,
       Empty$0,
       create$1,
       add,
       add,
       take,
       take_opt,
       take,
       peek,
       peek_opt,
       peek,
       clear$0,
       copy$4,
       is_empty$0,
       length$2,
       iter$8,
       fold$2,
       transfer,
       to_seq$7,
       add_seq$0,
       of_seq$5];
    caml_register_global(779,Stdlib_queue,"Stdlib__queue");
    var Undefined=[248,cst_CamlinternalLazy_Undefined,caml_fresh_oo_id(0)];
    function raise_undefined(param){throw Undefined}
    function force_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      try
       {var result=caml_call1(closure,0);
        caml_obj_make_forward(blk,result);
        return result}
      catch(e)
       {e = caml_wrap_exception(e);blk[1] = function(param){throw e};throw e}}
    function force_val_lazy_block(blk)
     {var closure=blk[1];
      blk[1] = raise_undefined;
      var result=caml_call1(closure,0);
      caml_obj_make_forward(blk,result);
      return result}
    function force(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_lazy_block(lzv)}
    function force_val(lzv)
     {var t=caml_obj_tag(lzv);
      return t === 250?lzv[1]:t !== 246?lzv:force_val_lazy_block(lzv)}
    var
     CamlinternalLazy=
      [0,Undefined,force_lazy_block,force_val_lazy_block,force,force_val];
    caml_register_global(780,CamlinternalLazy,"CamlinternalLazy");
    function from_fun(f){var x=caml_obj_block(246,1);x[1] = f;return x}
    function from_val(v)
     {var t=caml_obj_tag(v);
      if(t !== 250 && t !== 246 && t !== 253)return v;
      return runtime.caml_lazy_make_forward(v)}
    function is_val(l){return caml_obj_tag(l) !== 246?1:0}
    var
     Stdlib_lazy=
      [0,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       from_fun,
       from_val,
       is_val];
    caml_register_global(781,Stdlib_lazy,"Stdlib__lazy");
    var
     Failure$0=[248,cst_Stdlib_Stream_Failure,caml_fresh_oo_id(0)],
     Error=[248,cst_Stdlib_Stream_Error,caml_fresh_oo_id(0)];
    function count(param)
     {if(param){var match=param[1],count=match[1];return count}return 0}
    function data(param)
     {if(param){var match=param[1],data=match[2];return data}return 0}
    function fill_buff(b)
     {b[3] = input(b[1],b[2],0,caml_ml_bytes_length(b[2]));b[4] = 0;return 0}
    function get_data(count,d)
     {var d$0=d;
      for(;;)
       {if(typeof d$0 !== "number")
         switch(d$0[0])
          {case 1:
            var d2=d$0[2],d1=d$0[1],match=get_data(count,d1);
            if(typeof match === "number")
             {var d$0=d2;continue}
            else
             {if(0 === match[0])
               {var d11=match[2],a=match[1];return [0,a,[1,d11,d2]]}
              throw [0,Assert_failure,_N_]}
           case 2:
            var
             f=d$0[1],
             _tK_=caml_obj_tag(f),
             d$1=250 === _tK_?f[1]:246 === _tK_?force_lazy_block(f):f,
             d$0=d$1;
            continue;
           case 3:
            var _tL_=d$0[1],_tM_=_tL_[1];
            if(_tM_)
             {var _tN_=_tM_[1];
              if(_tN_){var a$0=_tN_[1];_tL_[1] = 0;return [0,a$0,d$0]}
              return 0}
            var match$0=caml_call1(_tL_[2],count);
            if(match$0){var a$1=match$0[1];return [0,a$1,d$0]}
            _tL_[1] = _O_;
            return 0;
           case 4:
            var b=d$0[1];
            if(b[3] <= b[4])fill_buff(b);
            if(0 === b[3])return 0;
            var r=caml_bytes_unsafe_get(b[2],b[4]);
            b[4] = b[4] + 1 | 0;
            return [0,r,d$0]
           }
        return d$0}}
    function peek_data(s)
     {for(;;)
       {var _tF_=s[2];
        if(typeof _tF_ === "number")
         return 0;
        else
         switch(_tF_[0])
          {case 0:var a=_tF_[1];return [0,a];
           case 1:
            var d=get_data(s[1],s[2]);
            if(typeof d === "number")
             return 0;
            else
             {if(0 === d[0]){var a$0=d[1];s[2] = d;return [0,a$0]}
              throw [0,Assert_failure,_P_]}
           case 2:
            var
             f=_tF_[1],
             _tG_=caml_obj_tag(f),
             _tH_=250 === _tG_?f[1]:246 === _tG_?force_lazy_block(f):f;
            s[2] = _tH_;
            continue;
           case 3:
            var _tI_=_tF_[1],_tJ_=_tI_[1];
            if(_tJ_){var a$1=_tJ_[1];return a$1}
            var x=caml_call1(_tI_[2],s[1]);
            _tI_[1] = [0,x];
            return x;
           default:
            var b=_tF_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :[0,caml_bytes_unsafe_get(b[2],b[4])]}}}
    function peek$0(param)
     {if(param){var s=param[1];return peek_data(s)}return 0}
    function junk_data(s)
     {for(;;)
       {var _tD_=s[2];
        if(typeof _tD_ !== "number")
         switch(_tD_[0])
          {case 0:var d=_tD_[2];s[1] = s[1] + 1 | 0;s[2] = d;return 0;
           case 3:
            var _tE_=_tD_[1];
            if(_tE_[1]){s[1] = s[1] + 1 | 0;_tE_[1] = 0;return 0}
            break;
           case 4:
            var b=_tD_[1];
            if(b[3] <= b[4])fill_buff(b);
            return 0 === b[3]
                    ?(s[2] = 0,0)
                    :(s[1] = s[1] + 1 | 0,b[4] = b[4] + 1 | 0,0)
           }
        var match=peek_data(s);
        if(match)continue;
        return 0}}
    function junk(param)
     {if(param){var data=param[1];return junk_data(data)}return 0}
    function nget_data(n,s)
     {if(0 < n)
       {var match=peek_data(s);
        if(match)
         {var a=match[1];
          junk_data(s);
          var
           match$0=nget_data(n - 1 | 0,s),
           k=match$0[3],
           d=match$0[2],
           al=match$0[1];
          return [0,[0,a,al],[0,a,d],k + 1 | 0]}
        return [0,0,s[2],0]}
      return [0,0,s[2],0]}
    function npeek(n,param)
     {if(param)
       {var
         d$0=param[1],
         match=nget_data(n,d$0),
         len=match[3],
         d=match[2],
         al=match[1];
        d$0[1] = d$0[1] - len | 0;
        d$0[2] = d;
        return al}
      return 0}
    function next(s)
     {var match=peek$0(s);
      if(match){var a=match[1];junk(s);return a}
      throw Failure$0}
    function empty$1(s){var match=peek$0(s);if(match)throw Failure$0;return 0}
    function iter$9(f,strm)
     {for(;;)
       {var match=peek$0(strm);
        if(match){var a=match[1];junk(strm);caml_call1(f,a);continue}
        return 0}}
    function from(f){return [0,[0,0,[3,[0,0,f]]]]}
    function of_list$1(l)
     {var _tC_=0;
      return [0,[0,0,fold_right(function(x,l){return [0,x,l]},l,_tC_)]]}
    function of_string$0(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_string_length(s)
                         ?(count[1]++,[0,caml_string_get(s,c)])
                         :0})}
    function of_bytes(s)
     {var count=[0,0];
      return from
              (function(param)
                {var c=count[1];
                 return c < caml_ml_bytes_length(s)
                         ?(count[1]++,[0,caml_bytes_get(s,c)])
                         :0})}
    function of_channel(ic)
     {return [0,[0,0,[4,[0,ic,caml_create_bytes(4096),0,0]]]]}
    function iapp(i,s){var _tB_=data(s);return [0,[0,0,[1,data(i),_tB_]]]}
    function icons(i,s){return [0,[0,0,[0,i,data(s)]]]}
    function ising(i){return [0,[0,0,[0,i,0]]]}
    function lapp(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tz_)
                  {var _tA_=data(s);return [1,data(caml_call1(f,0)),_tA_]}]]]]}
    function lcons(f,s)
     {return [0,
              [0,
               0,
               [2,
                [246,
                 function(_tx_)
                  {var _ty_=data(s);return [0,caml_call1(f,0),_ty_]}]]]]}
    function lsing(f)
     {return [0,[0,0,[2,[246,function(_tw_){return [0,caml_call1(f,0),0]}]]]]}
    var sempty=0;
    function slazy(f)
     {return [0,[0,0,[2,[246,function(_tv_){return data(caml_call1(f,0))}]]]]}
    function dump_data(f,param)
     {if(typeof param === "number")
       return print_string(cst_Sempty);
      else
       switch(param[0])
        {case 0:
          var d=param[2],a=param[1];
          print_string(cst_Scons);
          caml_call1(f,a);
          print_string(cst$7);
          dump_data(f,d);
          return print_string(cst$8);
         case 1:
          var d2=param[2],d1=param[1];
          print_string(cst_Sapp);
          dump_data(f,d1);
          print_string(cst$9);
          dump_data(f,d2);
          return print_string(cst$10);
         case 2:return print_string(cst_Slazy);
         case 3:return print_string(cst_Sgen);
         default:return print_string(cst_Sbuffio)}}
    function dump(f,s)
     {print_string(cst_count);
      print_int(count(s));
      print_string(cst_data);
      dump_data(f,data(s));
      print_string(cst$6);
      return print_newline(0)}
    var
     Stdlib_stream=
      [0,
       Failure$0,
       Error,
       from,
       of_list$1,
       of_string$0,
       of_bytes,
       of_channel,
       iter$9,
       next,
       empty$1,
       peek$0,
       junk,
       count,
       npeek,
       iapp,
       icons,
       ising,
       lapp,
       lcons,
       lsing,
       sempty,
       slazy,
       dump];
    caml_register_global(782,Stdlib_stream,"Stdlib__stream");
    function create$2(n)
     {var
       n$0=1 <= n?n:1,
       n$1=max_string_length < n$0?max_string_length:n$0,
       s=caml_create_bytes(n$1);
      return [0,s,0,n$1,s]}
    function contents(b){return sub_string(b[1],0,b[2])}
    function to_bytes(b){return sub(b[1],0,b[2])}
    function sub$3(b,ofs,len)
     {if(0 <= ofs && 0 <= len && ! ((b[2] - len | 0) < ofs))
       return sub_string(b[1],ofs,len);
      return invalid_arg(cst_Buffer_sub)}
    function blit$3(src,srcoff,dst,dstoff,len)
     {if
       (0
        <=
        len
        &&
        0
        <=
        srcoff
        &&
        !
        ((src[2] - len | 0) < srcoff)
        &&
        0
        <=
        dstoff
        &&
        !
        ((caml_ml_bytes_length(dst) - len | 0) < dstoff))
       return caml_blit_bytes(src[1],srcoff,dst,dstoff,len);
      return invalid_arg(cst_Buffer_blit)}
    function nth$0(b,ofs)
     {if(0 <= ofs && ! (b[2] <= ofs))return caml_bytes_unsafe_get(b[1],ofs);
      return invalid_arg(cst_Buffer_nth)}
    function length$3(b){return b[2]}
    function clear$1(b){b[2] = 0;return 0}
    function reset(b)
     {b[2] = 0;b[1] = b[4];b[3] = caml_ml_bytes_length(b[1]);return 0}
    function resize(b,more)
     {var old_pos=b[2],old_len=b[3],new_len=[0,old_len];
      for(;;)
       {if(new_len[1] < (old_pos + more | 0))
         {new_len[1] = 2 * new_len[1] | 0;continue}
        if(max_string_length < new_len[1])
         if((old_pos + more | 0) <= max_string_length)
          new_len[1] = max_string_length;
         else
          failwith(cst_Buffer_add_cannot_grow_buf);
        var new_buffer=caml_create_bytes(new_len[1]);
        blit(b[1],0,new_buffer,0,b[2]);
        b[1] = new_buffer;
        b[3] = new_len[1];
        if((b[2] + more | 0) <= b[3])
         {if((old_pos + more | 0) <= b[3])return 0;
          throw [0,Assert_failure,_Q_]}
        throw [0,Assert_failure,_R_]}}
    function add_char(b,c)
     {var pos=b[2];
      if(b[3] <= pos)resize(b,1);
      caml_bytes_unsafe_set(b[1],pos,c);
      b[2] = pos + 1 | 0;
      return 0}
    function add_utf_8_uchar(b,u)
     {if(0 <= u)
       {if(127 < u)
         {if(2047 < u)
           {if(65535 < u)
             {if(1114111 < u)throw [0,Assert_failure,_S_];
              var pos=b[2];
              if(b[3] < (pos + 4 | 0))resize(b,4);
              caml_bytes_unsafe_set(b[1],pos,240 | u >>> 18 | 0);
              caml_bytes_unsafe_set
               (b[1],pos + 1 | 0,128 | (u >>> 12 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 2 | 0,128 | (u >>> 6 | 0) & 63);
              caml_bytes_unsafe_set(b[1],pos + 3 | 0,128 | u & 63);
              b[2] = pos + 4 | 0;
              return 0}
            var pos$0=b[2];
            if(b[3] < (pos$0 + 3 | 0))resize(b,3);
            caml_bytes_unsafe_set(b[1],pos$0,224 | u >>> 12 | 0);
            caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,128 | (u >>> 6 | 0) & 63);
            caml_bytes_unsafe_set(b[1],pos$0 + 2 | 0,128 | u & 63);
            b[2] = pos$0 + 3 | 0;
            return 0}
          var pos$1=b[2];
          if(b[3] < (pos$1 + 2 | 0))resize(b,2);
          caml_bytes_unsafe_set(b[1],pos$1,192 | u >>> 6 | 0);
          caml_bytes_unsafe_set(b[1],pos$1 + 1 | 0,128 | u & 63);
          b[2] = pos$1 + 2 | 0;
          return 0}
        return add_char(b,u)}
      throw [0,Assert_failure,_T_]}
    function add_utf_16be_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_U_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo & 255);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u >>> 8 | 0);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u & 255);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_V_]}
    function add_utf_16le_uchar(b,u)
     {if(0 <= u)
       {if(65535 < u)
         {if(1114111 < u)throw [0,Assert_failure,_W_];
          var
           u$0=u - 65536 | 0,
           hi=55296 | u$0 >>> 10 | 0,
           lo=56320 | u$0 & 1023,
           pos=b[2];
          if(b[3] < (pos + 4 | 0))resize(b,4);
          caml_bytes_unsafe_set(b[1],pos,hi & 255);
          caml_bytes_unsafe_set(b[1],pos + 1 | 0,hi >>> 8 | 0);
          caml_bytes_unsafe_set(b[1],pos + 2 | 0,lo & 255);
          caml_bytes_unsafe_set(b[1],pos + 3 | 0,lo >>> 8 | 0);
          b[2] = pos + 4 | 0;
          return 0}
        var pos$0=b[2];
        if(b[3] < (pos$0 + 2 | 0))resize(b,2);
        caml_bytes_unsafe_set(b[1],pos$0,u & 255);
        caml_bytes_unsafe_set(b[1],pos$0 + 1 | 0,u >>> 8 | 0);
        b[2] = pos$0 + 2 | 0;
        return 0}
      throw [0,Assert_failure,_X_]}
    function add_substring(b,s,offset,len)
     {var _ts_=offset < 0?1:0;
      if(_ts_)
       var _tt_=_ts_;
      else
       var
        _tu_=len < 0?1:0,
        _tt_=_tu_ || ((caml_ml_string_length(s) - len | 0) < offset?1:0);
      if(_tt_)invalid_arg(cst_Buffer_add_substring_add_s);
      var new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,offset,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_subbytes(b,s,offset,len)
     {return add_substring(b,caml_string_of_bytes(s),offset,len)}
    function add_string(b,s)
     {var len=caml_ml_string_length(s),new_position=b[2] + len | 0;
      if(b[3] < new_position)resize(b,len);
      caml_blit_string(s,0,b[1],b[2],len);
      b[2] = new_position;
      return 0}
    function add_bytes(b,s){return add_string(b,caml_string_of_bytes(s))}
    function add_buffer(b,bs){return add_subbytes(b,bs[1],0,bs[2])}
    function add_channel(b,ic,len)
     {var _tq_=len < 0?1:0,_tr_=_tq_ || (max_string_length < len?1:0);
      if(_tr_)invalid_arg(cst_Buffer_add_channel);
      if(b[3] < (b[2] + len | 0))resize(b,len);
      var already_read=0,ofs=b[2],to_read=len,_tp_=b[1];
      for(;;)
       {if(0 !== to_read)
         {var r=input(ic,_tp_,ofs,to_read);
          if(0 !== r)
           {var
             already_read$0=already_read + r | 0,
             ofs$0=ofs + r | 0,
             to_read$0=to_read - r | 0,
             already_read=already_read$0,
             ofs=ofs$0,
             to_read=to_read$0;
            continue}}
        if((b[2] + already_read | 0) <= b[3])
         {b[2] = b[2] + already_read | 0;
          if(already_read < len)throw End_of_file;
          return 0}
        throw [0,Assert_failure,_Y_]}}
    function output_buffer(oc,b){return output(oc,b[1],0,b[2])}
    function add_substitute(b,f,s)
     {var lim$1=caml_ml_string_length(s),previous=32,i$7=0;
      for(;;)
       {if(i$7 < lim$1)
         {var current=caml_string_get(s,i$7);
          if(36 === current)
           {if(92 === previous)
             {add_char(b,current);
              var i$8=i$7 + 1 | 0,previous=32,i$7=i$8;
              continue}
            var start=i$7 + 1 | 0;
            if(lim$1 <= start)throw Not_found;
            var opening=caml_string_get(s,start),switch$0=0;
            if(40 !== opening && 123 !== opening)
             {var i$6=start + 1 | 0,lim$0=caml_ml_string_length(s),i$3=i$6;
              for(;;)
               {if(lim$0 <= i$3)
                 var stop=lim$0;
                else
                 {var match=caml_string_get(s,i$3),switch$1=0;
                  if(91 <= match)
                   {if(97 <= match)
                     {if(! (123 <= match))switch$1 = 1}
                    else
                     if(95 === match)switch$1 = 1}
                  else
                   if(58 <= match)
                    {if(65 <= match)switch$1 = 1}
                   else
                    if(48 <= match)switch$1 = 1;
                  if(switch$1){var i$4=i$3 + 1 | 0,i$3=i$4;continue}
                  var stop=i$3}
                var match$0=[0,sub$0(s,start,stop - start | 0),stop];
                switch$0 = 1;
                break}}
            if(! switch$0)
             {var i$5=start + 1 | 0,k$2=0;
              if(40 === opening)
               var _tn_=41;
              else
               {if(123 !== opening)throw [0,Assert_failure,_Z_];var _tn_=125}
              var lim=caml_ml_string_length(s),k=k$2,i=i$5;
              for(;;)
               {if(lim <= i)throw Not_found;
                if(caml_string_get(s,i) === opening)
                 {var i$0=i + 1 | 0,k$0=k + 1 | 0,k=k$0,i=i$0;continue}
                if(caml_string_get(s,i) !== _tn_)
                 {var i$2=i + 1 | 0,i=i$2;continue}
                if(0 !== k)
                 {var i$1=i + 1 | 0,k$1=k - 1 | 0,k=k$1,i=i$1;continue}
                var
                 match$0=
                  [0,sub$0(s,i$5,(i - start | 0) - 1 | 0),i + 1 | 0];
                break}}
            var next_i=match$0[2],ident=match$0[1];
            add_string(b,caml_call1(f,ident));
            var previous=32,i$7=next_i;
            continue}
          if(92 === previous)
           {add_char(b,92);
            add_char(b,current);
            var i$9=i$7 + 1 | 0,previous=32,i$7=i$9;
            continue}
          if(92 === current)
           {var i$10=i$7 + 1 | 0,previous=current,i$7=i$10;continue}
          add_char(b,current);
          var i$11=i$7 + 1 | 0,previous=current,i$7=i$11;
          continue}
        var _to_=92 === previous?1:0;
        return _to_?add_char(b,previous):_to_}}
    function truncate(b,len)
     {if(0 <= len && ! (b[2] < len)){b[2] = len;return 0}
      return invalid_arg(cst_Buffer_truncate)}
    function to_seq$8(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_tl_=i + 1 | 0;
        return [0,x,function(_tm_){return aux(_tl_,_tm_)}]}
      var _tj_=0;
      return function(_tk_){return aux(_tj_,_tk_)}}
    function to_seqi$3(b)
     {function aux(i,param)
       {if(b[2] <= i)return 0;
        var x=caml_bytes_unsafe_get(b[1],i),_th_=i + 1 | 0;
        return [0,[0,i,x],function(_ti_){return aux(_th_,_ti_)}]}
      var _tf_=0;
      return function(_tg_){return aux(_tf_,_tg_)}}
    function add_seq$1(b,seq)
     {return iter(function(_te_){return add_char(b,_te_)},seq)}
    function of_seq$6(i){var b=create$2(32);add_seq$1(b,i);return b}
    function add_int8(b,x)
     {var new_position=b[2] + 1 | 0;
      if(b[3] < new_position)resize(b,1);
      caml_bytes_unsafe_set(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_ne(b,x)
     {var new_position=b[2] + 2 | 0;
      if(b[3] < new_position)resize(b,2);
      caml_bytes_set16(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int32_ne(b,x)
     {var new_position=b[2] + 4 | 0;
      if(b[3] < new_position)resize(b,4);
      caml_bytes_set32(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int64_ne(b,x)
     {var new_position=b[2] + 8 | 0;
      if(b[3] < new_position)resize(b,8);
      caml_bytes_set64(b[1],b[2],x);
      b[2] = new_position;
      return 0}
    function add_int16_le(b,x){return add_int16_ne(b,x)}
    function add_int16_be(b,x)
     {var x$0=caml_bswap16(x);return add_int16_ne(b,x$0)}
    function add_int32_le(b,x){return add_int32_ne(b,x)}
    function add_int32_be(b,x)
     {var x$0=caml_int32_bswap(x);return add_int32_ne(b,x$0)}
    function add_int64_le(b,x){return add_int64_ne(b,x)}
    function add_int64_be(b,x)
     {var x$0=caml_int64_bswap(x);return add_int64_ne(b,x$0)}
    var
     Stdlib_buffer=
      [0,
       create$2,
       contents,
       to_bytes,
       sub$3,
       blit$3,
       nth$0,
       length$3,
       clear$1,
       reset,
       add_char,
       add_utf_8_uchar,
       add_utf_16le_uchar,
       add_utf_16be_uchar,
       add_string,
       add_bytes,
       add_substring,
       add_subbytes,
       add_substitute,
       add_buffer,
       add_channel,
       output_buffer,
       truncate,
       to_seq$8,
       to_seqi$3,
       add_seq$1,
       of_seq$6,
       add_int8,
       add_int8,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int16_ne,
       add_int16_be,
       add_int16_le,
       add_int32_ne,
       add_int32_be,
       add_int32_le,
       add_int64_ne,
       add_int64_be,
       add_int64_le];
    caml_register_global(783,Stdlib_buffer,"Stdlib__buffer");
    function create_char_set(param){return make(32,0)}
    function add_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return caml_bytes_set
              (char_set,
               str_ind,
               char_of_int(caml_bytes_get(char_set,str_ind) | mask))}
    function freeze_char_set(char_set){return to_string$1(char_set)}
    function rev_char_set(char_set)
     {var char_set$0=create_char_set(0),i=0;
      for(;;)
       {caml_bytes_set
         (char_set$0,i,char_of_int(caml_string_get(char_set,i) ^ 255));
        var _td_=i + 1 | 0;
        if(31 !== i){var i=_td_;continue}
        return caml_string_of_bytes(char_set$0)}}
    function is_in_char_set(char_set,c)
     {var str_ind=c >>> 3 | 0,mask=1 << (c & 7);
      return 0 !== (caml_string_get(char_set,str_ind) & mask)?1:0}
    function pad_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return [0,1,width]}return 0}
    function param_format_of_ignored_format(ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:return [0,[0,fmt]];
         case 1:return [0,[1,fmt]];
         case 2:return [0,[19,fmt]];
         default:return [0,[22,fmt]]}
      else
       switch(ign[0])
        {case 0:var pad_opt=ign[1];return [0,[2,pad_of_pad_opt(pad_opt),fmt]];
         case 1:
          var pad_opt$0=ign[1];return [0,[3,pad_of_pad_opt(pad_opt$0),fmt]];
         case 2:
          var pad_opt$1=ign[2],iconv=ign[1];
          return [0,[4,iconv,pad_of_pad_opt(pad_opt$1),0,fmt]];
         case 3:
          var pad_opt$2=ign[2],iconv$0=ign[1];
          return [0,[5,iconv$0,pad_of_pad_opt(pad_opt$2),0,fmt]];
         case 4:
          var pad_opt$3=ign[2],iconv$1=ign[1];
          return [0,[6,iconv$1,pad_of_pad_opt(pad_opt$3),0,fmt]];
         case 5:
          var pad_opt$4=ign[2],iconv$2=ign[1];
          return [0,[7,iconv$2,pad_of_pad_opt(pad_opt$4),0,fmt]];
         case 6:
          var prec_opt=ign[2],pad_opt$5=ign[1];
          if(prec_opt)var ndec=prec_opt[1],_tc_=[0,ndec];else var _tc_=0;
          return [0,[8,___,pad_of_pad_opt(pad_opt$5),_tc_,fmt]];
         case 7:
          var pad_opt$6=ign[1];return [0,[9,pad_of_pad_opt(pad_opt$6),fmt]];
         case 8:
          var fmtty=ign[2],pad_opt$7=ign[1];
          return [0,[13,pad_opt$7,fmtty,fmt]];
         case 9:
          var fmtty$0=ign[2],pad_opt$8=ign[1];
          return [0,[14,pad_opt$8,fmtty$0,fmt]];
         case 10:
          var char_set=ign[2],width_opt=ign[1];
          return [0,[20,width_opt,char_set,fmt]];
         default:var counter=ign[1];return [0,[21,counter,fmt]]}}
    function default_float_precision(fconv){return 5 === fconv[2]?12:-6}
    function buffer_create(init_size)
     {return [0,0,caml_create_bytes(init_size)]}
    function buffer_check_size(buf,overhead)
     {var
       len=caml_ml_bytes_length(buf[2]),
       min_len=buf[1] + overhead | 0,
       _ta_=len < min_len?1:0;
      if(_ta_)
       {var
         new_len=max(len * 2 | 0,min_len),
         new_str=caml_create_bytes(new_len);
        blit(buf[2],0,new_str,0,len);
        buf[2] = new_str;
        var _tb_=0}
      else
       var _tb_=_ta_;
      return _tb_}
    function buffer_add_char(buf,c)
     {buffer_check_size(buf,1);
      caml_bytes_set(buf[2],buf[1],c);
      buf[1] = buf[1] + 1 | 0;
      return 0}
    function buffer_add_string(buf,s)
     {var str_len=caml_ml_string_length(s);
      buffer_check_size(buf,str_len);
      blit$0(s,0,buf[2],buf[1],str_len);
      buf[1] = buf[1] + str_len | 0;
      return 0}
    function buffer_contents(buf){return sub_string(buf[2],0,buf[1])}
    function char_of_iconv(iconv)
     {switch(iconv)
       {case 6:
        case 7:return 120;
        case 8:
        case 9:return 88;
        case 10:
        case 11:return 111;
        case 12:
        case 15:return 117;
        case 0:
        case 1:
        case 2:
        case 13:return 100;
        default:return 105}}
    function char_of_fconv(opt,fconv)
     {if(opt)var sth=opt[1],cF=sth;else var cF=70;
      switch(fconv[2])
       {case 0:return 102;
        case 1:return 101;
        case 2:return 69;
        case 3:return 103;
        case 4:return 71;
        case 5:return cF;
        case 6:return 104;
        case 7:return 72;
        default:return 70}}
    function bprint_padty(buf,padty)
     {switch(padty)
       {case 0:return buffer_add_char(buf,45);
        case 1:return 0;
        default:return buffer_add_char(buf,48)}}
    function bprint_ignored_flag(buf,ign_flag)
     {return ign_flag?buffer_add_char(buf,95):ign_flag}
    function bprint_pad_opt(buf,pad_opt)
     {if(pad_opt)
       {var width=pad_opt[1];
        return buffer_add_string(buf,caml_string_of_jsbytes("" + width))}
      return 0}
    function bprint_padding(buf,pad)
     {if(typeof pad === "number")
       return 0;
      else
       {if(0 === pad[0])
         {var n=pad[2],padty=pad[1];
          bprint_padty(buf,padty);
          return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
        var padty$0=pad[1];
        bprint_padty(buf,padty$0);
        return buffer_add_char(buf,42)}}
    function bprint_precision(buf,prec)
     {if(typeof prec === "number")return prec?buffer_add_string(buf,cst$11):0;
      var n=prec[1];
      buffer_add_char(buf,46);
      return buffer_add_string(buf,caml_string_of_jsbytes("" + n))}
    function bprint_iconv_flag(buf,iconv)
     {switch(iconv)
       {case 1:
        case 4:return buffer_add_char(buf,43);
        case 2:
        case 5:return buffer_add_char(buf,32);
        case 7:
        case 9:
        case 11:
        case 13:
        case 14:
        case 15:return buffer_add_char(buf,35);
        default:return 0}}
    function bprint_altint_fmt(buf,ign_flag,iconv,pad,prec,c)
     {buffer_add_char(buf,37);
      bprint_ignored_flag(buf,ign_flag);
      bprint_iconv_flag(buf,iconv);
      bprint_padding(buf,pad);
      bprint_precision(buf,prec);
      buffer_add_char(buf,c);
      return buffer_add_char(buf,char_of_iconv(iconv))}
    function bprint_fconv_flag(buf,fconv)
     {switch(fconv[1])
       {case 0:break;
        case 1:buffer_add_char(buf,43);break;
        default:buffer_add_char(buf,32)}
      return 8 <= fconv[2]?buffer_add_char(buf,35):0}
    function string_of_formatting_lit(formatting_lit)
     {if(typeof formatting_lit === "number")
       switch(formatting_lit)
        {case 0:return cst$12;
         case 1:return cst$13;
         case 2:return cst$14;
         case 3:return cst$15;
         case 4:return cst$16;
         case 5:return cst$17;
         default:return cst$18}
      else
       switch(formatting_lit[0])
        {case 0:var str=formatting_lit[1];return str;
         case 1:var str$0=formatting_lit[1];return str$0;
         default:var c=formatting_lit[1];return symbol(cst$19,make$0(1,c))}}
    function bprint_char_literal(buf,chr)
     {return 37 === chr?buffer_add_string(buf,cst$20):buffer_add_char(buf,chr)}
    function bprint_string_literal(buf,str)
     {var _s__=caml_ml_string_length(str) - 1 | 0,_s9_=0;
      if(! (_s__ < 0))
       {var i=_s9_;
        for(;;)
         {bprint_char_literal(buf,caml_string_get(str,i));
          var _s$_=i + 1 | 0;
          if(_s__ !== i){var i=_s$_;continue}
          break}}
      return 0}
    function bprint_fmtty(buf,fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:
           var rest=fmtty$0[1];
           buffer_add_string(buf,cst_c);
           var fmtty$0=rest;
           continue;
          case 1:
           var rest$0=fmtty$0[1];
           buffer_add_string(buf,cst_s);
           var fmtty$0=rest$0;
           continue;
          case 2:
           var rest$1=fmtty$0[1];
           buffer_add_string(buf,cst_i);
           var fmtty$0=rest$1;
           continue;
          case 3:
           var rest$2=fmtty$0[1];
           buffer_add_string(buf,cst_li);
           var fmtty$0=rest$2;
           continue;
          case 4:
           var rest$3=fmtty$0[1];
           buffer_add_string(buf,cst_ni);
           var fmtty$0=rest$3;
           continue;
          case 5:
           var rest$4=fmtty$0[1];
           buffer_add_string(buf,cst_Li);
           var fmtty$0=rest$4;
           continue;
          case 6:
           var rest$5=fmtty$0[1];
           buffer_add_string(buf,cst_f);
           var fmtty$0=rest$5;
           continue;
          case 7:
           var rest$6=fmtty$0[1];
           buffer_add_string(buf,cst_B);
           var fmtty$0=rest$6;
           continue;
          case 8:
           var rest$7=fmtty$0[2],sub_fmtty=fmtty$0[1];
           buffer_add_string(buf,cst$21);
           bprint_fmtty(buf,sub_fmtty);
           buffer_add_string(buf,cst$22);
           var fmtty$0=rest$7;
           continue;
          case 9:
           var rest$8=fmtty$0[3],sub_fmtty$0=fmtty$0[1];
           buffer_add_string(buf,cst$23);
           bprint_fmtty(buf,sub_fmtty$0);
           buffer_add_string(buf,cst$24);
           var fmtty$0=rest$8;
           continue;
          case 10:
           var rest$9=fmtty$0[1];
           buffer_add_string(buf,cst_a);
           var fmtty$0=rest$9;
           continue;
          case 11:
           var rest$10=fmtty$0[1];
           buffer_add_string(buf,cst_t$0);
           var fmtty$0=rest$10;
           continue;
          case 12:
           var rest$11=fmtty$0[1];
           buffer_add_string(buf,cst$25);
           var fmtty$0=rest$11;
           continue;
          case 13:
           var rest$12=fmtty$0[1];
           buffer_add_string(buf,cst_r$0);
           var fmtty$0=rest$12;
           continue;
          default:
           var rest$13=fmtty$0[1];
           buffer_add_string(buf,cst_r$1);
           var fmtty$0=rest$13;
           continue}}
    function int_of_custom_arity(param)
     {if(param){var x=param[1];return 1 + int_of_custom_arity(x) | 0}return 0}
    function string_of_fmt(fmt$1)
     {var buf=buffer_create(16),fmt=fmt$1,ign_flag=0;
      a:
      for(;;)
       if(typeof fmt === "number")
        return buffer_contents(buf);
       else
        switch(fmt[0])
         {case 0:
           var rest=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,99);
           var fmt=rest,ign_flag=0;
           continue;
          case 1:
           var rest$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,67);
           var fmt=rest$0,ign_flag=0;
           continue;
          case 2:
           var rest$1=fmt[2],pad=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad);
           buffer_add_char(buf,115);
           var fmt=rest$1,ign_flag=0;
           continue;
          case 3:
           var rest$2=fmt[2],pad$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$0);
           buffer_add_char(buf,83);
           var fmt=rest$2,ign_flag=0;
           continue;
          case 4:
           var rest$3=fmt[4],prec=fmt[3],pad$1=fmt[2],iconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_iconv_flag(buf,iconv);
           bprint_padding(buf,pad$1);
           bprint_precision(buf,prec);
           buffer_add_char(buf,char_of_iconv(iconv));
           var fmt=rest$3,ign_flag=0;
           continue;
          case 5:
           var rest$4=fmt[4],prec$0=fmt[3],pad$2=fmt[2],iconv$0=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$0,pad$2,prec$0,108);
           var fmt=rest$4,ign_flag=0;
           continue;
          case 6:
           var rest$5=fmt[4],prec$1=fmt[3],pad$3=fmt[2],iconv$1=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$1,pad$3,prec$1,110);
           var fmt=rest$5,ign_flag=0;
           continue;
          case 7:
           var rest$6=fmt[4],prec$2=fmt[3],pad$4=fmt[2],iconv$2=fmt[1];
           bprint_altint_fmt(buf,ign_flag,iconv$2,pad$4,prec$2,76);
           var fmt=rest$6,ign_flag=0;
           continue;
          case 8:
           var rest$7=fmt[4],prec$3=fmt[3],pad$5=fmt[2],fconv=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_fconv_flag(buf,fconv);
           bprint_padding(buf,pad$5);
           bprint_precision(buf,prec$3);
           buffer_add_char(buf,char_of_fconv(0,fconv));
           var fmt=rest$7,ign_flag=0;
           continue;
          case 9:
           var rest$8=fmt[2],pad$6=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_padding(buf,pad$6);
           buffer_add_char(buf,66);
           var fmt=rest$8,ign_flag=0;
           continue;
          case 10:
           var rest$9=fmt[1];
           buffer_add_string(buf,cst$26);
           var fmt=rest$9;
           continue;
          case 11:
           var rest$10=fmt[2],str=fmt[1];
           bprint_string_literal(buf,str);
           var fmt=rest$10;
           continue;
          case 12:
           var rest$11=fmt[2],chr$0=fmt[1];
           bprint_char_literal(buf,chr$0);
           var fmt=rest$11;
           continue;
          case 13:
           var rest$12=fmt[3],fmtty=fmt[2],pad_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt);
           buffer_add_char(buf,123);
           bprint_fmtty(buf,fmtty);
           buffer_add_char(buf,37);
           buffer_add_char(buf,125);
           var fmt=rest$12,ign_flag=0;
           continue;
          case 14:
           var rest$13=fmt[3],fmtty$0=fmt[2],pad_opt$0=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,pad_opt$0);
           buffer_add_char(buf,40);
           bprint_fmtty(buf,fmtty$0);
           buffer_add_char(buf,37);
           buffer_add_char(buf,41);
           var fmt=rest$13,ign_flag=0;
           continue;
          case 15:
           var rest$14=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,97);
           var fmt=rest$14,ign_flag=0;
           continue;
          case 16:
           var rest$15=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,116);
           var fmt=rest$15,ign_flag=0;
           continue;
          case 17:
           var rest$16=fmt[2],fmting_lit=fmt[1];
           bprint_string_literal(buf,string_of_formatting_lit(fmting_lit));
           var fmt=rest$16;
           continue;
          case 18:
           var rest$17=fmt[2],fmting_gen=fmt[1];
           if(0 === fmting_gen[0])
            {var match$1=fmting_gen[1],str$0=match$1[2];
             buffer_add_string(buf,cst$27);
             buffer_add_string(buf,str$0)}
           else
            {var match$2=fmting_gen[1],str$1=match$2[2];
             buffer_add_string(buf,cst$28);
             buffer_add_string(buf,str$1)}
           var fmt=rest$17;
           continue;
          case 19:
           var rest$18=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           buffer_add_char(buf,114);
           var fmt=rest$18,ign_flag=0;
           continue;
          case 20:
           var rest$19=fmt[3],char_set=fmt[2],width_opt=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_pad_opt(buf,width_opt);
           var
            print_char=
             function(buf,i)
              {var c=char_of_int(i);
               return 37 === c
                       ?(buffer_add_char(buf,37),buffer_add_char(buf,37))
                       :64 === c
                         ?(buffer_add_char(buf,37),buffer_add_char(buf,64))
                         :buffer_add_char(buf,c)};
           buffer_add_char(buf,91);
           var
            _sZ_=
             is_in_char_set(char_set,0)
              ?(buffer_add_char(buf,94),rev_char_set(char_set))
              :char_set,
            is_alone$0=
             function(_s4_)
              {function is_alone(c)
                {var
                  after=chr(c + 1 | 0),
                  before=chr(c - 1 | 0),
                  _s5_=is_in_char_set(_s4_,c);
                 if(_s5_)
                  var
                   _s6_=is_in_char_set(_s4_,before),
                   _s7_=_s6_?is_in_char_set(_s4_,after):_s6_,
                   _s8_=1 - _s7_;
                 else
                  var _s8_=_s5_;
                 return _s8_}
               return is_alone},
            is_alone=is_alone$0(_sZ_);
           if(is_alone(93))buffer_add_char(buf,93);
           var i=1;
           b:
           for(;;)
            {if(i < 256)
              {if(! is_in_char_set(_sZ_,char_of_int(i)))
                {var i$0=i + 1 | 0,i=i$0;continue}
               var match=char_of_int(i),switcher=match - 45 | 0,switch$0=0;
               if(48 < switcher >>> 0)
                if(210 <= switcher)print_char(buf,255);else switch$0 = 1;
               else
                {var switcher$0=switcher - 1 | 0;
                 if(46 < switcher$0 >>> 0){var i$2=i + 1 | 0,i=i$2;continue}
                 switch$0 = 1}
               if(switch$0)
                {var i$1=i + 1 | 0;
                 if(! is_in_char_set(_sZ_,char_of_int(i$1)))
                  {print_char(buf,i$1 - 1 | 0);
                   var i$6=i$1 + 1 | 0,i=i$6;
                   continue}
                 var
                  match$0=char_of_int(i$1),
                  switcher$1=match$0 - 45 | 0,
                  switch$1=0;
                 if(48 < switcher$1 >>> 0)
                  if(210 <= switcher$1)
                   {print_char(buf,254);print_char(buf,255)}
                  else
                   switch$1 = 1;
                 else
                  {var switcher$2=switcher$1 - 1 | 0;
                   if(46 < switcher$2 >>> 0)
                    {if(! is_in_char_set(_sZ_,char_of_int(i$1 + 1 | 0)))
                      {print_char(buf,i$1 - 1 | 0);
                       var i$5=i$1 + 1 | 0,i=i$5;
                       continue}
                     switch$1 = 1}
                   else
                    switch$1 = 1}
                 if(switch$1)
                  {if(! is_in_char_set(_sZ_,char_of_int(i$1 + 1 | 0)))
                    {print_char(buf,i$1 - 1 | 0);
                     print_char(buf,i$1);
                     var i$4=i$1 + 2 | 0,i=i$4;
                     continue}
                   var j=i$1 + 2 | 0,i$3=i$1 - 1 | 0,j$0=j;
                   for(;;)
                    {if(256 !== j$0 && is_in_char_set(_sZ_,char_of_int(j$0)))
                      {var j$1=j$0 + 1 | 0,j$0=j$1;continue}
                     print_char(buf,i$3);
                     print_char(buf,45);
                     print_char(buf,j$0 - 1 | 0);
                     if(j$0 < 256){var i$7=j$0 + 1 | 0,i=i$7;continue b}
                     break}}}}
             if(is_alone(45))buffer_add_char(buf,45);
             buffer_add_char(buf,93);
             var fmt=rest$19,ign_flag=0;
             continue a}
          case 21:
           var rest$20=fmt[2],counter=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           switch(counter)
            {case 0:var _s0_=108;break;
             case 1:var _s0_=110;break;
             default:var _s0_=78}
           buffer_add_char(buf,_s0_);
           var fmt=rest$20,ign_flag=0;
           continue;
          case 22:
           var rest$21=fmt[1];
           buffer_add_char(buf,37);
           bprint_ignored_flag(buf,ign_flag);
           bprint_string_literal(buf,cst_0c);
           var fmt=rest$21,ign_flag=0;
           continue;
          case 23:
           var
            rest$22=fmt[2],
            ign=fmt[1],
            match$3=param_format_of_ignored_format(ign,rest$22),
            fmt$0=match$3[1],
            fmt=fmt$0,
            ign_flag=1;
           continue;
          default:
           var
            rest$23=fmt[3],
            arity=fmt[1],
            _s2_=int_of_custom_arity(arity),
            _s1_=1;
           if(! (_s2_ < 1))
            {var i$8=_s1_;
             for(;;)
              {buffer_add_char(buf,37);
               bprint_ignored_flag(buf,ign_flag);
               buffer_add_char(buf,63);
               var _s3_=i$8 + 1 | 0;
               if(_s2_ !== i$8){var i$8=_s3_;continue}
               break}}
           var fmt=rest$23,ign_flag=0;
           continue}}
    function symm(param)
     {if(typeof param === "number")
       return 0;
      else
       switch(param[0])
        {case 0:var rest=param[1];return [0,symm(rest)];
         case 1:var rest$0=param[1];return [1,symm(rest$0)];
         case 2:var rest$1=param[1];return [2,symm(rest$1)];
         case 3:var rest$2=param[1];return [3,symm(rest$2)];
         case 4:var rest$3=param[1];return [4,symm(rest$3)];
         case 5:var rest$4=param[1];return [5,symm(rest$4)];
         case 6:var rest$5=param[1];return [6,symm(rest$5)];
         case 7:var rest$6=param[1];return [7,symm(rest$6)];
         case 8:var rest$7=param[2],ty=param[1];return [8,ty,symm(rest$7)];
         case 9:
          var rest$8=param[3],ty2=param[2],ty1=param[1];
          return [9,ty2,ty1,symm(rest$8)];
         case 10:var rest$9=param[1];return [10,symm(rest$9)];
         case 11:var rest$10=param[1];return [11,symm(rest$10)];
         case 12:var rest$11=param[1];return [12,symm(rest$11)];
         case 13:var rest$12=param[1];return [13,symm(rest$12)];
         default:var rest$13=param[1];return [14,symm(rest$13)]}}
    function trans(ty1,match)
     {var switch$0=0;
      if(typeof ty1 === "number")
       if(typeof match === "number")
        return 0;
       else
        switch(match[0])
         {case 10:break;
          case 11:switch$0 = 1;break;
          case 12:switch$0 = 2;break;
          case 13:switch$0 = 3;break;
          case 14:switch$0 = 4;break;
          case 8:switch$0 = 5;break;
          case 9:switch$0 = 6;break;
          default:throw [0,Assert_failure,_$_]}
      else
       switch(ty1[0])
        {case 0:
          var switch$1=0,_sG_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 0:var rest2=match[1];return [0,trans(_sG_,rest2)];
             case 8:switch$0 = 5;switch$1 = 1;break;
             case 9:switch$0 = 6;switch$1 = 1;break;
             case 10:switch$1 = 1;break;
             case 11:switch$0 = 1;switch$1 = 1;break;
             case 12:switch$0 = 2;switch$1 = 1;break;
             case 13:switch$0 = 3;switch$1 = 1;break;
             case 14:switch$0 = 4;switch$1 = 1;break
             }
          if(! switch$1)switch$0 = 7;
          break;
         case 1:
          var switch$2=0,_sH_=ty1[1];
          if(typeof match !== "number")
           switch(match[0])
            {case 1:var rest2$0=match[1];return [1,trans(_sH_,rest2$0)];
             case 8:switch$0 = 5;switch$2 = 1;break;
             case 9:switch$0 = 6;switch$2 = 1;break;
             case 10:switch$2 = 1;break;
             case 11:switch$0 = 1;switch$2 = 1;break;
             case 12:switch$0 = 2;switch$2 = 1;break;
             case 13:switch$0 = 3;switch$2 = 1;break;
             case 14:switch$0 = 4;switch$2 = 1;break
             }
          if(! switch$2)switch$0 = 7;
          break;
         case 2:
          var switch$3=0,_sI_=ty1[1];
          if(typeof match === "number")
           switch$3 = 1;
          else
           switch(match[0])
            {case 2:var rest2$1=match[1];return [2,trans(_sI_,rest2$1)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$3 = 1}
          if(switch$3)switch$0 = 7;
          break;
         case 3:
          var switch$4=0,_sJ_=ty1[1];
          if(typeof match === "number")
           switch$4 = 1;
          else
           switch(match[0])
            {case 3:var rest2$2=match[1];return [3,trans(_sJ_,rest2$2)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$4 = 1}
          if(switch$4)switch$0 = 7;
          break;
         case 4:
          var switch$5=0,_sK_=ty1[1];
          if(typeof match === "number")
           switch$5 = 1;
          else
           switch(match[0])
            {case 4:var rest2$3=match[1];return [4,trans(_sK_,rest2$3)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$5 = 1}
          if(switch$5)switch$0 = 7;
          break;
         case 5:
          var switch$6=0,_sL_=ty1[1];
          if(typeof match === "number")
           switch$6 = 1;
          else
           switch(match[0])
            {case 5:var rest2$4=match[1];return [5,trans(_sL_,rest2$4)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$6 = 1}
          if(switch$6)switch$0 = 7;
          break;
         case 6:
          var switch$7=0,_sM_=ty1[1];
          if(typeof match === "number")
           switch$7 = 1;
          else
           switch(match[0])
            {case 6:var rest2$5=match[1];return [6,trans(_sM_,rest2$5)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$7 = 1}
          if(switch$7)switch$0 = 7;
          break;
         case 7:
          var switch$8=0,_sN_=ty1[1];
          if(typeof match === "number")
           switch$8 = 1;
          else
           switch(match[0])
            {case 7:var rest2$6=match[1];return [7,trans(_sN_,rest2$6)];
             case 8:switch$0 = 5;break;
             case 9:switch$0 = 6;break;
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$8 = 1}
          if(switch$8)switch$0 = 7;
          break;
         case 8:
          var switch$9=0,_sO_=ty1[2],_sP_=ty1[1];
          if(typeof match === "number")
           switch$9 = 1;
          else
           switch(match[0])
            {case 8:
              var rest2$7=match[2],ty2=match[1],_sQ_=trans(_sO_,rest2$7);
              return [8,trans(_sP_,ty2),_sQ_];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$9 = 1}
          if(switch$9)throw [0,Assert_failure,_ai_];
          break;
         case 9:
          var switch$10=0,_sR_=ty1[3],_sS_=ty1[2],_sT_=ty1[1];
          if(typeof match === "number")
           switch$10 = 1;
          else
           switch(match[0])
            {case 8:switch$0 = 5;break;
             case 9:
              var
               rest2$8=match[3],
               ty22=match[2],
               ty21=match[1],
               ty=trans(symm(_sS_),ty21),
               match$0=fmtty_rel_det(ty),
               f4=match$0[4],
               f2=match$0[2];
              caml_call1(f2,0);
              caml_call1(f4,0);
              return [9,_sT_,ty22,trans(_sR_,rest2$8)];
             case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:switch$0 = 4;break;
             default:switch$10 = 1}
          if(switch$10)throw [0,Assert_failure,_aj_];
          break;
         case 10:
          var _sU_=ty1[1];
          if(typeof match !== "number" && 10 === match[0])
           {var rest2$9=match[1];return [10,trans(_sU_,rest2$9)]}
          throw [0,Assert_failure,_ak_];
         case 11:
          var switch$11=0,_sV_=ty1[1];
          if(typeof match === "number")
           switch$11 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:var rest2$10=match[1];return [11,trans(_sV_,rest2$10)];
             default:switch$11 = 1}
          if(switch$11)throw [0,Assert_failure,_al_];
          break;
         case 12:
          var switch$12=0,_sW_=ty1[1];
          if(typeof match === "number")
           switch$12 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:var rest2$11=match[1];return [12,trans(_sW_,rest2$11)];
             default:switch$12 = 1}
          if(switch$12)throw [0,Assert_failure,_am_];
          break;
         case 13:
          var switch$13=0,_sX_=ty1[1];
          if(typeof match === "number")
           switch$13 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:var rest2$12=match[1];return [13,trans(_sX_,rest2$12)];
             default:switch$13 = 1}
          if(switch$13)throw [0,Assert_failure,_an_];
          break;
         default:
          var switch$14=0,_sY_=ty1[1];
          if(typeof match === "number")
           switch$14 = 1;
          else
           switch(match[0])
            {case 10:break;
             case 11:switch$0 = 1;break;
             case 12:switch$0 = 2;break;
             case 13:switch$0 = 3;break;
             case 14:var rest2$13=match[1];return [14,trans(_sY_,rest2$13)];
             default:switch$14 = 1}
          if(switch$14)throw [0,Assert_failure,_ao_]}
      switch(switch$0)
       {case 0:throw [0,Assert_failure,_ac_];
        case 1:throw [0,Assert_failure,_ad_];
        case 2:throw [0,Assert_failure,_ae_];
        case 3:throw [0,Assert_failure,_af_];
        case 4:throw [0,Assert_failure,_ag_];
        case 5:throw [0,Assert_failure,_aa_];
        case 6:throw [0,Assert_failure,_ab_];
        default:throw [0,Assert_failure,_ah_]}}
    function fmtty_rel_det(param)
     {if(typeof param === "number")
       {var
         _si_=function(param){return 0},
         _sj_=function(param){return 0},
         _sk_=function(param){return 0};
        return [0,function(param){return 0},_sk_,_sj_,_si_]}
      else
       switch(param[0])
        {case 0:
          var
           rest=param[1],
           match=fmtty_rel_det(rest),
           de=match[4],
           ed=match[3],
           af=match[2],
           fa=match[1],
           _sl_=function(param){caml_call1(af,0);return 0};
          return [0,function(param){caml_call1(fa,0);return 0},_sl_,ed,de];
         case 1:
          var
           rest$0=param[1],
           match$0=fmtty_rel_det(rest$0),
           de$0=match$0[4],
           ed$0=match$0[3],
           af$0=match$0[2],
           fa$0=match$0[1],
           _sm_=function(param){caml_call1(af$0,0);return 0};
          return [0,
                  function(param){caml_call1(fa$0,0);return 0},
                  _sm_,
                  ed$0,
                  de$0];
         case 2:
          var
           rest$1=param[1],
           match$1=fmtty_rel_det(rest$1),
           de$1=match$1[4],
           ed$1=match$1[3],
           af$1=match$1[2],
           fa$1=match$1[1],
           _sn_=function(param){caml_call1(af$1,0);return 0};
          return [0,
                  function(param){caml_call1(fa$1,0);return 0},
                  _sn_,
                  ed$1,
                  de$1];
         case 3:
          var
           rest$2=param[1],
           match$2=fmtty_rel_det(rest$2),
           de$2=match$2[4],
           ed$2=match$2[3],
           af$2=match$2[2],
           fa$2=match$2[1],
           _so_=function(param){caml_call1(af$2,0);return 0};
          return [0,
                  function(param){caml_call1(fa$2,0);return 0},
                  _so_,
                  ed$2,
                  de$2];
         case 4:
          var
           rest$3=param[1],
           match$3=fmtty_rel_det(rest$3),
           de$3=match$3[4],
           ed$3=match$3[3],
           af$3=match$3[2],
           fa$3=match$3[1],
           _sp_=function(param){caml_call1(af$3,0);return 0};
          return [0,
                  function(param){caml_call1(fa$3,0);return 0},
                  _sp_,
                  ed$3,
                  de$3];
         case 5:
          var
           rest$4=param[1],
           match$4=fmtty_rel_det(rest$4),
           de$4=match$4[4],
           ed$4=match$4[3],
           af$4=match$4[2],
           fa$4=match$4[1],
           _sq_=function(param){caml_call1(af$4,0);return 0};
          return [0,
                  function(param){caml_call1(fa$4,0);return 0},
                  _sq_,
                  ed$4,
                  de$4];
         case 6:
          var
           rest$5=param[1],
           match$5=fmtty_rel_det(rest$5),
           de$5=match$5[4],
           ed$5=match$5[3],
           af$5=match$5[2],
           fa$5=match$5[1],
           _sr_=function(param){caml_call1(af$5,0);return 0};
          return [0,
                  function(param){caml_call1(fa$5,0);return 0},
                  _sr_,
                  ed$5,
                  de$5];
         case 7:
          var
           rest$6=param[1],
           match$6=fmtty_rel_det(rest$6),
           de$6=match$6[4],
           ed$6=match$6[3],
           af$6=match$6[2],
           fa$6=match$6[1],
           _ss_=function(param){caml_call1(af$6,0);return 0};
          return [0,
                  function(param){caml_call1(fa$6,0);return 0},
                  _ss_,
                  ed$6,
                  de$6];
         case 8:
          var
           rest$7=param[2],
           match$7=fmtty_rel_det(rest$7),
           de$7=match$7[4],
           ed$7=match$7[3],
           af$7=match$7[2],
           fa$7=match$7[1],
           _st_=function(param){caml_call1(af$7,0);return 0};
          return [0,
                  function(param){caml_call1(fa$7,0);return 0},
                  _st_,
                  ed$7,
                  de$7];
         case 9:
          var
           rest$8=param[3],
           ty2=param[2],
           ty1=param[1],
           match$8=fmtty_rel_det(rest$8),
           de$8=match$8[4],
           ed$8=match$8[3],
           af$8=match$8[2],
           fa$8=match$8[1],
           ty=trans(symm(ty1),ty2),
           match$9=fmtty_rel_det(ty),
           jd=match$9[4],
           dj=match$9[3],
           ga=match$9[2],
           ag=match$9[1],
           _su_=function(param){caml_call1(jd,0);caml_call1(de$8,0);return 0},
           _sv_=function(param){caml_call1(ed$8,0);caml_call1(dj,0);return 0},
           _sw_=function(param){caml_call1(ga,0);caml_call1(af$8,0);return 0};
          return [0,
                  function(param)
                   {caml_call1(fa$8,0);caml_call1(ag,0);return 0},
                  _sw_,
                  _sv_,
                  _su_];
         case 10:
          var
           rest$9=param[1],
           match$10=fmtty_rel_det(rest$9),
           de$9=match$10[4],
           ed$9=match$10[3],
           af$9=match$10[2],
           fa$9=match$10[1],
           _sx_=function(param){caml_call1(af$9,0);return 0};
          return [0,
                  function(param){caml_call1(fa$9,0);return 0},
                  _sx_,
                  ed$9,
                  de$9];
         case 11:
          var
           rest$10=param[1],
           match$11=fmtty_rel_det(rest$10),
           de$10=match$11[4],
           ed$10=match$11[3],
           af$10=match$11[2],
           fa$10=match$11[1],
           _sy_=function(param){caml_call1(af$10,0);return 0};
          return [0,
                  function(param){caml_call1(fa$10,0);return 0},
                  _sy_,
                  ed$10,
                  de$10];
         case 12:
          var
           rest$11=param[1],
           match$12=fmtty_rel_det(rest$11),
           de$11=match$12[4],
           ed$11=match$12[3],
           af$11=match$12[2],
           fa$11=match$12[1],
           _sz_=function(param){caml_call1(af$11,0);return 0};
          return [0,
                  function(param){caml_call1(fa$11,0);return 0},
                  _sz_,
                  ed$11,
                  de$11];
         case 13:
          var
           rest$12=param[1],
           match$13=fmtty_rel_det(rest$12),
           de$12=match$13[4],
           ed$12=match$13[3],
           af$12=match$13[2],
           fa$12=match$13[1],
           _sA_=function(param){caml_call1(de$12,0);return 0},
           _sB_=function(param){caml_call1(ed$12,0);return 0},
           _sC_=function(param){caml_call1(af$12,0);return 0};
          return [0,
                  function(param){caml_call1(fa$12,0);return 0},
                  _sC_,
                  _sB_,
                  _sA_];
         default:
          var
           rest$13=param[1],
           match$14=fmtty_rel_det(rest$13),
           de$13=match$14[4],
           ed$13=match$14[3],
           af$13=match$14[2],
           fa$13=match$14[1],
           _sD_=function(param){caml_call1(de$13,0);return 0},
           _sE_=function(param){caml_call1(ed$13,0);return 0},
           _sF_=function(param){caml_call1(af$13,0);return 0};
          return [0,
                  function(param){caml_call1(fa$13,0);return 0},
                  _sF_,
                  _sE_,
                  _sD_]}}
    function fmtty_of_precision_fmtty(prec,fmtty)
     {return typeof prec === "number"?prec?[2,fmtty]:fmtty:fmtty}
    function fmtty_of_padding_fmtty(pad,fmtty)
     {return typeof pad === "number"?fmtty:0 === pad[0]?fmtty:[2,fmtty]}
    function fmtty_of_custom(arity,fmtty)
     {if(arity)
       {var arity$0=arity[1];return [12,fmtty_of_custom(arity$0,fmtty)]}
      return fmtty}
    function fmtty_of_fmt(fmtty)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        return 0;
       else
        switch(fmtty$0[0])
         {case 0:var rest=fmtty$0[1];return [0,fmtty_of_fmt(rest)];
          case 1:var rest$0=fmtty$0[1];return [0,fmtty_of_fmt(rest$0)];
          case 2:
           var rest$1=fmtty$0[2],pad=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad,[1,fmtty_of_fmt(rest$1)]);
          case 3:
           var rest$2=fmtty$0[2],pad$0=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$0,[1,fmtty_of_fmt(rest$2)]);
          case 4:
           var
            rest$3=fmtty$0[4],
            prec=fmtty$0[3],
            pad$1=fmtty$0[2],
            ty_rest=fmtty_of_fmt(rest$3),
            prec_ty=fmtty_of_precision_fmtty(prec,[2,ty_rest]);
           return fmtty_of_padding_fmtty(pad$1,prec_ty);
          case 5:
           var
            rest$4=fmtty$0[4],
            prec$0=fmtty$0[3],
            pad$2=fmtty$0[2],
            ty_rest$0=fmtty_of_fmt(rest$4),
            prec_ty$0=fmtty_of_precision_fmtty(prec$0,[3,ty_rest$0]);
           return fmtty_of_padding_fmtty(pad$2,prec_ty$0);
          case 6:
           var
            rest$5=fmtty$0[4],
            prec$1=fmtty$0[3],
            pad$3=fmtty$0[2],
            ty_rest$1=fmtty_of_fmt(rest$5),
            prec_ty$1=fmtty_of_precision_fmtty(prec$1,[4,ty_rest$1]);
           return fmtty_of_padding_fmtty(pad$3,prec_ty$1);
          case 7:
           var
            rest$6=fmtty$0[4],
            prec$2=fmtty$0[3],
            pad$4=fmtty$0[2],
            ty_rest$2=fmtty_of_fmt(rest$6),
            prec_ty$2=fmtty_of_precision_fmtty(prec$2,[5,ty_rest$2]);
           return fmtty_of_padding_fmtty(pad$4,prec_ty$2);
          case 8:
           var
            rest$7=fmtty$0[4],
            prec$3=fmtty$0[3],
            pad$5=fmtty$0[2],
            ty_rest$3=fmtty_of_fmt(rest$7),
            prec_ty$3=fmtty_of_precision_fmtty(prec$3,[6,ty_rest$3]);
           return fmtty_of_padding_fmtty(pad$5,prec_ty$3);
          case 9:
           var rest$8=fmtty$0[2],pad$6=fmtty$0[1];
           return fmtty_of_padding_fmtty(pad$6,[7,fmtty_of_fmt(rest$8)]);
          case 10:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 11:var fmtty$2=fmtty$0[2],fmtty$0=fmtty$2;continue;
          case 12:var fmtty$3=fmtty$0[2],fmtty$0=fmtty$3;continue;
          case 13:
           var rest$9=fmtty$0[3],ty=fmtty$0[2];
           return [8,ty,fmtty_of_fmt(rest$9)];
          case 14:
           var rest$10=fmtty$0[3],ty$0=fmtty$0[2];
           return [9,ty$0,ty$0,fmtty_of_fmt(rest$10)];
          case 15:var rest$11=fmtty$0[1];return [10,fmtty_of_fmt(rest$11)];
          case 16:var rest$12=fmtty$0[1];return [11,fmtty_of_fmt(rest$12)];
          case 17:var fmtty$4=fmtty$0[2],fmtty$0=fmtty$4;continue;
          case 18:
           var
            rest$13=fmtty$0[2],
            fmting_gen=fmtty$0[1],
            _sg_=fmtty_of_fmt(rest$13);
           if(0 === fmting_gen[0])
            var match=fmting_gen[1],fmt=match[1],_sh_=fmtty_of_fmt(fmt);
           else
            var
             match$0=fmting_gen[1],
             fmt$0=match$0[1],
             _sh_=fmtty_of_fmt(fmt$0);
           return concat_fmtty(_sh_,_sg_);
          case 19:var rest$14=fmtty$0[1];return [13,fmtty_of_fmt(rest$14)];
          case 20:var rest$15=fmtty$0[3];return [1,fmtty_of_fmt(rest$15)];
          case 21:var rest$16=fmtty$0[2];return [2,fmtty_of_fmt(rest$16)];
          case 22:var rest$17=fmtty$0[1];return [0,fmtty_of_fmt(rest$17)];
          case 23:
           var rest$18=fmtty$0[2],ign=fmtty$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:return [14,fmtty_of_fmt(rest$18)];
              default:var fmtty$0=rest$18;continue}
           else
            switch(ign[0])
             {case 0:var fmtty$0=rest$18;continue;
              case 1:var fmtty$0=rest$18;continue;
              case 2:var fmtty$0=rest$18;continue;
              case 3:var fmtty$0=rest$18;continue;
              case 4:var fmtty$0=rest$18;continue;
              case 5:var fmtty$0=rest$18;continue;
              case 6:var fmtty$0=rest$18;continue;
              case 7:var fmtty$0=rest$18;continue;
              case 8:var fmtty$0=rest$18;continue;
              case 9:
               var fmtty$5=ign[2];
               return concat_fmtty(fmtty$5,fmtty_of_fmt(rest$18));
              case 10:var fmtty$0=rest$18;continue;
              default:var fmtty$0=rest$18;continue}
          default:
           var rest$19=fmtty$0[3],arity=fmtty$0[1];
           return fmtty_of_custom(arity,fmtty_of_fmt(rest$19))}}
    var
     Type_mismatch=
      [248,cst_CamlinternalFormat_Type_mi,caml_fresh_oo_id(0)];
    function type_padding(pad,match)
     {if(typeof pad === "number")
       return [0,0,match];
      else
       {if(0 === pad[0])
         {var w=pad[2],padty=pad[1];return [0,[0,padty,w],match]}
        if(typeof match !== "number" && 2 === match[0])
         {var rest=match[1],padty$0=pad[1];return [0,[1,padty$0],rest]}
        throw Type_mismatch}}
    function type_padprec(pad,prec,fmtty)
     {var match=type_padding(pad,fmtty);
      if(typeof prec === "number")
       {if(prec)
         {var _sf_=match[2];
          if(typeof _sf_ !== "number" && 2 === _sf_[0])
           {var rest=_sf_[1],pad$0=match[1];return [0,pad$0,1,rest]}
          throw Type_mismatch}
        var rest$0=match[2],pad$1=match[1];
        return [0,pad$1,0,rest$0]}
      var rest$1=match[2],pad$2=match[1],p=prec[1];
      return [0,pad$2,[0,p],rest$1]}
    function type_ignored_format_substituti(sub_fmtty,fmt,match)
     {if(typeof sub_fmtty === "number")
       return [0,0,type_format_gen(fmt,match)];
      else
       switch(sub_fmtty[0])
        {case 0:
          if(typeof match !== "number" && 0 === match[0])
           {var
             fmtty_rest=match[1],
             sub_fmtty_rest=sub_fmtty[1],
             match$0=
              type_ignored_format_substituti(sub_fmtty_rest,fmt,fmtty_rest),
             fmt$0=match$0[2],
             sub_fmtty_rest$0=match$0[1];
            return [0,[0,sub_fmtty_rest$0],fmt$0]}
          break;
         case 1:
          if(typeof match !== "number" && 1 === match[0])
           {var
             fmtty_rest$0=match[1],
             sub_fmtty_rest$1=sub_fmtty[1],
             match$1=
              type_ignored_format_substituti
               (sub_fmtty_rest$1,fmt,fmtty_rest$0),
             fmt$1=match$1[2],
             sub_fmtty_rest$2=match$1[1];
            return [0,[1,sub_fmtty_rest$2],fmt$1]}
          break;
         case 2:
          if(typeof match !== "number" && 2 === match[0])
           {var
             fmtty_rest$1=match[1],
             sub_fmtty_rest$3=sub_fmtty[1],
             match$2=
              type_ignored_format_substituti
               (sub_fmtty_rest$3,fmt,fmtty_rest$1),
             fmt$2=match$2[2],
             sub_fmtty_rest$4=match$2[1];
            return [0,[2,sub_fmtty_rest$4],fmt$2]}
          break;
         case 3:
          if(typeof match !== "number" && 3 === match[0])
           {var
             fmtty_rest$2=match[1],
             sub_fmtty_rest$5=sub_fmtty[1],
             match$3=
              type_ignored_format_substituti
               (sub_fmtty_rest$5,fmt,fmtty_rest$2),
             fmt$3=match$3[2],
             sub_fmtty_rest$6=match$3[1];
            return [0,[3,sub_fmtty_rest$6],fmt$3]}
          break;
         case 4:
          if(typeof match !== "number" && 4 === match[0])
           {var
             fmtty_rest$3=match[1],
             sub_fmtty_rest$7=sub_fmtty[1],
             match$4=
              type_ignored_format_substituti
               (sub_fmtty_rest$7,fmt,fmtty_rest$3),
             fmt$4=match$4[2],
             sub_fmtty_rest$8=match$4[1];
            return [0,[4,sub_fmtty_rest$8],fmt$4]}
          break;
         case 5:
          if(typeof match !== "number" && 5 === match[0])
           {var
             fmtty_rest$4=match[1],
             sub_fmtty_rest$9=sub_fmtty[1],
             match$5=
              type_ignored_format_substituti
               (sub_fmtty_rest$9,fmt,fmtty_rest$4),
             fmt$5=match$5[2],
             sub_fmtty_rest$10=match$5[1];
            return [0,[5,sub_fmtty_rest$10],fmt$5]}
          break;
         case 6:
          if(typeof match !== "number" && 6 === match[0])
           {var
             fmtty_rest$5=match[1],
             sub_fmtty_rest$11=sub_fmtty[1],
             match$6=
              type_ignored_format_substituti
               (sub_fmtty_rest$11,fmt,fmtty_rest$5),
             fmt$6=match$6[2],
             sub_fmtty_rest$12=match$6[1];
            return [0,[6,sub_fmtty_rest$12],fmt$6]}
          break;
         case 7:
          if(typeof match !== "number" && 7 === match[0])
           {var
             fmtty_rest$6=match[1],
             sub_fmtty_rest$13=sub_fmtty[1],
             match$7=
              type_ignored_format_substituti
               (sub_fmtty_rest$13,fmt,fmtty_rest$6),
             fmt$7=match$7[2],
             sub_fmtty_rest$14=match$7[1];
            return [0,[7,sub_fmtty_rest$14],fmt$7]}
          break;
         case 8:
          if(typeof match !== "number" && 8 === match[0])
           {var
             fmtty_rest$7=match[2],
             sub2_fmtty=match[1],
             sub_fmtty_rest$15=sub_fmtty[2],
             sub2_fmtty$0=sub_fmtty[1];
            if(caml_notequal([0,sub2_fmtty$0],[0,sub2_fmtty]))
             throw Type_mismatch;
            var
             match$8=
              type_ignored_format_substituti
               (sub_fmtty_rest$15,fmt,fmtty_rest$7),
             fmt$8=match$8[2],
             sub_fmtty_rest$16=match$8[1];
            return [0,[8,sub2_fmtty,sub_fmtty_rest$16],fmt$8]}
          break;
         case 9:
          if(typeof match !== "number" && 9 === match[0])
           {var
             fmtty_rest$8=match[3],
             sub2_fmtty$1=match[2],
             sub1_fmtty=match[1],
             sub_fmtty_rest$17=sub_fmtty[3],
             sub2_fmtty$2=sub_fmtty[2],
             sub1_fmtty$0=sub_fmtty[1],
             _sd_=[0,erase_rel(sub1_fmtty)];
            if(caml_notequal([0,erase_rel(sub1_fmtty$0)],_sd_))
             throw Type_mismatch;
            var _se_=[0,erase_rel(sub2_fmtty$1)];
            if(caml_notequal([0,erase_rel(sub2_fmtty$2)],_se_))
             throw Type_mismatch;
            var
             sub_fmtty$0=trans(symm(sub1_fmtty),sub2_fmtty$1),
             match$9=fmtty_rel_det(sub_fmtty$0),
             f4=match$9[4],
             f2=match$9[2];
            caml_call1(f2,0);
            caml_call1(f4,0);
            var
             match$10=
              type_ignored_format_substituti
               (erase_rel(sub_fmtty_rest$17),fmt,fmtty_rest$8),
             fmt$9=match$10[2],
             sub_fmtty_rest$18=match$10[1];
            return [0,
                    [9,sub1_fmtty,sub2_fmtty$1,symm(sub_fmtty_rest$18)],
                    fmt$9]}
          break;
         case 10:
          if(typeof match !== "number" && 10 === match[0])
           {var
             fmtty_rest$9=match[1],
             sub_fmtty_rest$19=sub_fmtty[1],
             match$11=
              type_ignored_format_substituti
               (sub_fmtty_rest$19,fmt,fmtty_rest$9),
             fmt$10=match$11[2],
             sub_fmtty_rest$20=match$11[1];
            return [0,[10,sub_fmtty_rest$20],fmt$10]}
          break;
         case 11:
          if(typeof match !== "number" && 11 === match[0])
           {var
             fmtty_rest$10=match[1],
             sub_fmtty_rest$21=sub_fmtty[1],
             match$12=
              type_ignored_format_substituti
               (sub_fmtty_rest$21,fmt,fmtty_rest$10),
             fmt$11=match$12[2],
             sub_fmtty_rest$22=match$12[1];
            return [0,[11,sub_fmtty_rest$22],fmt$11]}
          break;
         case 13:
          if(typeof match !== "number" && 13 === match[0])
           {var
             fmtty_rest$11=match[1],
             sub_fmtty_rest$23=sub_fmtty[1],
             match$13=
              type_ignored_format_substituti
               (sub_fmtty_rest$23,fmt,fmtty_rest$11),
             fmt$12=match$13[2],
             sub_fmtty_rest$24=match$13[1];
            return [0,[13,sub_fmtty_rest$24],fmt$12]}
          break;
         case 14:
          if(typeof match !== "number" && 14 === match[0])
           {var
             fmtty_rest$12=match[1],
             sub_fmtty_rest$25=sub_fmtty[1],
             match$14=
              type_ignored_format_substituti
               (sub_fmtty_rest$25,fmt,fmtty_rest$12),
             fmt$13=match$14[2],
             sub_fmtty_rest$26=match$14[1];
            return [0,[14,sub_fmtty_rest$26],fmt$13]}
          break
         }
      throw Type_mismatch}
    function type_format_gen(fmt,fmtty)
     {if(typeof fmt === "number")
       return [0,0,fmtty];
      else
       switch(fmt[0])
        {case 0:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest=fmtty[1],
             fmt_rest=fmt[1],
             match=type_format_gen(fmt_rest,fmtty_rest),
             fmtty$0=match[2],
             fmt$0=match[1];
            return [0,[0,fmt$0],fmtty$0]}
          break;
         case 1:
          if(typeof fmtty !== "number" && 0 === fmtty[0])
           {var
             fmtty_rest$0=fmtty[1],
             fmt_rest$0=fmt[1],
             match$0=type_format_gen(fmt_rest$0,fmtty_rest$0),
             fmtty$1=match$0[2],
             fmt$1=match$0[1];
            return [0,[1,fmt$1],fmtty$1]}
          break;
         case 2:
          var
           fmt_rest$1=fmt[2],
           pad=fmt[1],
           match$1=type_padding(pad,fmtty),
           _rY_=match$1[2],
           _rX_=match$1[1];
          if(typeof _rY_ !== "number" && 1 === _rY_[0])
           {var
             fmtty_rest$1=_rY_[1],
             match$2=type_format_gen(fmt_rest$1,fmtty_rest$1),
             fmtty$2=match$2[2],
             fmt$2=match$2[1];
            return [0,[2,_rX_,fmt$2],fmtty$2]}
          throw Type_mismatch;
         case 3:
          var
           fmt_rest$2=fmt[2],
           pad$0=fmt[1],
           match$3=type_padding(pad$0,fmtty),
           _r0_=match$3[2],
           _rZ_=match$3[1];
          if(typeof _r0_ !== "number" && 1 === _r0_[0])
           {var
             fmtty_rest$2=_r0_[1],
             match$4=type_format_gen(fmt_rest$2,fmtty_rest$2),
             fmtty$3=match$4[2],
             fmt$3=match$4[1];
            return [0,[3,_rZ_,fmt$3],fmtty$3]}
          throw Type_mismatch;
         case 4:
          var
           fmt_rest$3=fmt[4],
           prec=fmt[3],
           pad$1=fmt[2],
           iconv=fmt[1],
           match$5=type_padprec(pad$1,prec,fmtty),
           _r2_=match$5[3],
           _r1_=match$5[1];
          if(typeof _r2_ !== "number" && 2 === _r2_[0])
           {var
             fmtty_rest$3=_r2_[1],
             prec$0=match$5[2],
             match$6=type_format_gen(fmt_rest$3,fmtty_rest$3),
             fmtty$4=match$6[2],
             fmt$4=match$6[1];
            return [0,[4,iconv,_r1_,prec$0,fmt$4],fmtty$4]}
          throw Type_mismatch;
         case 5:
          var
           fmt_rest$4=fmt[4],
           prec$1=fmt[3],
           pad$2=fmt[2],
           iconv$0=fmt[1],
           match$7=type_padprec(pad$2,prec$1,fmtty),
           _r4_=match$7[3],
           _r3_=match$7[1];
          if(typeof _r4_ !== "number" && 3 === _r4_[0])
           {var
             fmtty_rest$4=_r4_[1],
             prec$2=match$7[2],
             match$8=type_format_gen(fmt_rest$4,fmtty_rest$4),
             fmtty$5=match$8[2],
             fmt$5=match$8[1];
            return [0,[5,iconv$0,_r3_,prec$2,fmt$5],fmtty$5]}
          throw Type_mismatch;
         case 6:
          var
           fmt_rest$5=fmt[4],
           prec$3=fmt[3],
           pad$3=fmt[2],
           iconv$1=fmt[1],
           match$9=type_padprec(pad$3,prec$3,fmtty),
           _r6_=match$9[3],
           _r5_=match$9[1];
          if(typeof _r6_ !== "number" && 4 === _r6_[0])
           {var
             fmtty_rest$5=_r6_[1],
             prec$4=match$9[2],
             match$10=type_format_gen(fmt_rest$5,fmtty_rest$5),
             fmtty$6=match$10[2],
             fmt$6=match$10[1];
            return [0,[6,iconv$1,_r5_,prec$4,fmt$6],fmtty$6]}
          throw Type_mismatch;
         case 7:
          var
           fmt_rest$6=fmt[4],
           prec$5=fmt[3],
           pad$4=fmt[2],
           iconv$2=fmt[1],
           match$11=type_padprec(pad$4,prec$5,fmtty),
           _r8_=match$11[3],
           _r7_=match$11[1];
          if(typeof _r8_ !== "number" && 5 === _r8_[0])
           {var
             fmtty_rest$6=_r8_[1],
             prec$6=match$11[2],
             match$12=type_format_gen(fmt_rest$6,fmtty_rest$6),
             fmtty$7=match$12[2],
             fmt$7=match$12[1];
            return [0,[7,iconv$2,_r7_,prec$6,fmt$7],fmtty$7]}
          throw Type_mismatch;
         case 8:
          var
           fmt_rest$7=fmt[4],
           prec$7=fmt[3],
           pad$5=fmt[2],
           fconv=fmt[1],
           match$13=type_padprec(pad$5,prec$7,fmtty),
           _r__=match$13[3],
           _r9_=match$13[1];
          if(typeof _r__ !== "number" && 6 === _r__[0])
           {var
             fmtty_rest$7=_r__[1],
             prec$8=match$13[2],
             match$14=type_format_gen(fmt_rest$7,fmtty_rest$7),
             fmtty$8=match$14[2],
             fmt$8=match$14[1];
            return [0,[8,fconv,_r9_,prec$8,fmt$8],fmtty$8]}
          throw Type_mismatch;
         case 9:
          var
           fmt_rest$8=fmt[2],
           pad$6=fmt[1],
           match$15=type_padding(pad$6,fmtty),
           _sa_=match$15[2],
           _r$_=match$15[1];
          if(typeof _sa_ !== "number" && 7 === _sa_[0])
           {var
             fmtty_rest$8=_sa_[1],
             match$16=type_format_gen(fmt_rest$8,fmtty_rest$8),
             fmtty$9=match$16[2],
             fmt$9=match$16[1];
            return [0,[9,_r$_,fmt$9],fmtty$9]}
          throw Type_mismatch;
         case 10:
          var
           fmt_rest$9=fmt[1],
           match$17=type_format_gen(fmt_rest$9,fmtty),
           fmtty$10=match$17[2],
           fmt$10=match$17[1];
          return [0,[10,fmt$10],fmtty$10];
         case 11:
          var
           fmt_rest$10=fmt[2],
           str=fmt[1],
           match$18=type_format_gen(fmt_rest$10,fmtty),
           fmtty$11=match$18[2],
           fmt$11=match$18[1];
          return [0,[11,str,fmt$11],fmtty$11];
         case 12:
          var
           fmt_rest$11=fmt[2],
           chr=fmt[1],
           match$19=type_format_gen(fmt_rest$11,fmtty),
           fmtty$12=match$19[2],
           fmt$12=match$19[1];
          return [0,[12,chr,fmt$12],fmtty$12];
         case 13:
          if(typeof fmtty !== "number" && 8 === fmtty[0])
           {var
             fmtty_rest$9=fmtty[2],
             sub_fmtty=fmtty[1],
             fmt_rest$12=fmt[3],
             sub_fmtty$0=fmt[2],
             pad_opt=fmt[1];
            if(caml_notequal([0,sub_fmtty$0],[0,sub_fmtty]))
             throw Type_mismatch;
            var
             match$20=type_format_gen(fmt_rest$12,fmtty_rest$9),
             fmtty$13=match$20[2],
             fmt$13=match$20[1];
            return [0,[13,pad_opt,sub_fmtty,fmt$13],fmtty$13]}
          break;
         case 14:
          if(typeof fmtty !== "number" && 9 === fmtty[0])
           {var
             fmtty_rest$10=fmtty[3],
             sub_fmtty1=fmtty[1],
             fmt_rest$13=fmt[3],
             sub_fmtty$1=fmt[2],
             pad_opt$0=fmt[1],
             _sb_=[0,erase_rel(sub_fmtty1)];
            if(caml_notequal([0,erase_rel(sub_fmtty$1)],_sb_))
             throw Type_mismatch;
            var
             match$21=type_format_gen(fmt_rest$13,erase_rel(fmtty_rest$10)),
             fmtty$14=match$21[2],
             fmt$14=match$21[1];
            return [0,[14,pad_opt$0,sub_fmtty1,fmt$14],fmtty$14]}
          break;
         case 15:
          if(typeof fmtty !== "number" && 10 === fmtty[0])
           {var
             fmtty_rest$11=fmtty[1],
             fmt_rest$14=fmt[1],
             match$22=type_format_gen(fmt_rest$14,fmtty_rest$11),
             fmtty$15=match$22[2],
             fmt$15=match$22[1];
            return [0,[15,fmt$15],fmtty$15]}
          break;
         case 16:
          if(typeof fmtty !== "number" && 11 === fmtty[0])
           {var
             fmtty_rest$12=fmtty[1],
             fmt_rest$15=fmt[1],
             match$23=type_format_gen(fmt_rest$15,fmtty_rest$12),
             fmtty$16=match$23[2],
             fmt$16=match$23[1];
            return [0,[16,fmt$16],fmtty$16]}
          break;
         case 17:
          var
           fmt_rest$16=fmt[2],
           formatting_lit=fmt[1],
           match$24=type_format_gen(fmt_rest$16,fmtty),
           fmtty$17=match$24[2],
           fmt$17=match$24[1];
          return [0,[17,formatting_lit,fmt$17],fmtty$17];
         case 18:
          var fmt_rest$17=fmt[2],formatting_gen=fmt[1];
          if(0 === formatting_gen[0])
           {var
             match$28=formatting_gen[1],
             str$0=match$28[2],
             fmt1=match$28[1],
             match$29=type_format_gen(fmt1,fmtty),
             fmtty2=match$29[2],
             fmt2=match$29[1],
             match$30=type_format_gen(fmt_rest$17,fmtty2),
             fmtty3=match$30[2],
             fmt3=match$30[1];
            return [0,[18,[0,[0,fmt2,str$0]],fmt3],fmtty3]}
          var
           match$31=formatting_gen[1],
           str$1=match$31[2],
           fmt1$0=match$31[1],
           match$32=type_format_gen(fmt1$0,fmtty),
           fmtty2$0=match$32[2],
           fmt2$0=match$32[1],
           match$33=type_format_gen(fmt_rest$17,fmtty2$0),
           fmtty3$0=match$33[2],
           fmt3$0=match$33[1];
          return [0,[18,[1,[0,fmt2$0,str$1]],fmt3$0],fmtty3$0];
         case 19:
          if(typeof fmtty !== "number" && 13 === fmtty[0])
           {var
             fmtty_rest$13=fmtty[1],
             fmt_rest$18=fmt[1],
             match$25=type_format_gen(fmt_rest$18,fmtty_rest$13),
             fmtty$18=match$25[2],
             fmt$18=match$25[1];
            return [0,[19,fmt$18],fmtty$18]}
          break;
         case 20:
          if(typeof fmtty !== "number" && 1 === fmtty[0])
           {var
             fmtty_rest$14=fmtty[1],
             fmt_rest$19=fmt[3],
             char_set=fmt[2],
             width_opt=fmt[1],
             match$26=type_format_gen(fmt_rest$19,fmtty_rest$14),
             fmtty$19=match$26[2],
             fmt$19=match$26[1];
            return [0,[20,width_opt,char_set,fmt$19],fmtty$19]}
          break;
         case 21:
          if(typeof fmtty !== "number" && 2 === fmtty[0])
           {var
             fmtty_rest$15=fmtty[1],
             fmt_rest$20=fmt[2],
             counter=fmt[1],
             match$27=type_format_gen(fmt_rest$20,fmtty_rest$15),
             fmtty$20=match$27[2],
             fmt$20=match$27[1];
            return [0,[21,counter,fmt$20],fmtty$20]}
          break;
         case 23:
          var rest=fmt[2],ign=fmt[1];
          if(typeof ign === "number")
           switch(ign)
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:
              if(typeof fmtty !== "number" && 14 === fmtty[0])
               {var
                 fmtty_rest$16=fmtty[1],
                 match$34=type_format_gen(rest,fmtty_rest$16),
                 fmtty$21=match$34[2],
                 fmt$21=match$34[1];
                return [0,[23,2,fmt$21],fmtty$21]}
              throw Type_mismatch;
             default:return type_ignored_param_one(ign,rest,fmtty)}
          else
           switch(ign[0])
            {case 0:return type_ignored_param_one(ign,rest,fmtty);
             case 1:return type_ignored_param_one(ign,rest,fmtty);
             case 2:return type_ignored_param_one(ign,rest,fmtty);
             case 3:return type_ignored_param_one(ign,rest,fmtty);
             case 4:return type_ignored_param_one(ign,rest,fmtty);
             case 5:return type_ignored_param_one(ign,rest,fmtty);
             case 6:return type_ignored_param_one(ign,rest,fmtty);
             case 7:return type_ignored_param_one(ign,rest,fmtty);
             case 8:
              var sub_fmtty$2=ign[2],pad_opt$1=ign[1];
              return type_ignored_param_one
                      ([8,pad_opt$1,sub_fmtty$2],rest,fmtty);
             case 9:
              var
               sub_fmtty$3=ign[2],
               pad_opt$2=ign[1],
               _sc_=type_ignored_format_substituti(sub_fmtty$3,rest,fmtty),
               match$35=_sc_[2],
               fmtty$22=match$35[2],
               fmt$22=match$35[1],
               sub_fmtty$4=_sc_[1];
              return [0,[23,[9,pad_opt$2,sub_fmtty$4],fmt$22],fmtty$22];
             case 10:return type_ignored_param_one(ign,rest,fmtty);
             default:return type_ignored_param_one(ign,rest,fmtty)}
         }
      throw Type_mismatch}
    function type_ignored_param_one(ign,fmt,fmtty)
     {var match=type_format_gen(fmt,fmtty),fmtty$0=match[2],fmt$0=match[1];
      return [0,[23,ign,fmt$0],fmtty$0]}
    function type_format(fmt,fmtty)
     {var _rW_=type_format_gen(fmt,fmtty);
      if(typeof _rW_[2] === "number"){var fmt$0=_rW_[1];return fmt$0}
      throw Type_mismatch}
    function recast(fmt,fmtty){return type_format(fmt,erase_rel(symm(fmtty)))}
    function fix_padding(padty,width,str)
     {var
       len=caml_ml_string_length(str),
       padty$0=0 <= width?padty:0,
       width$0=abs(width);
      if(width$0 <= len)return str;
      var _rV_=2 === padty$0?48:32,res=make(width$0,_rV_);
      switch(padty$0)
       {case 0:blit$0(str,0,res,0,len);break;
        case 1:blit$0(str,0,res,width$0 - len | 0,len);break;
        default:
         var switch$0=0;
         if(0 < len)
          {var switch$1=0;
           if
            (43
             !==
             caml_string_get(str,0)
             &&
             45
             !==
             caml_string_get(str,0)
             &&
             32
             !==
             caml_string_get(str,0))
            {switch$0 = 1;switch$1 = 1}
           if(! switch$1)
            {caml_bytes_set(res,0,caml_string_get(str,0));
             blit$0(str,1,res,(width$0 - len | 0) + 1 | 0,len - 1 | 0)}}
         else
          switch$0 = 1;
         if(switch$0)
          {var switch$2=0;
           if(1 < len && 48 === caml_string_get(str,0))
            {var switch$3=0;
             if
              (120
               !==
               caml_string_get(str,1)
               &&
               88
               !==
               caml_string_get(str,1))
              {switch$2 = 1;switch$3 = 1}
             if(! switch$3)
              {caml_bytes_set(res,1,caml_string_get(str,1));
               blit$0(str,2,res,(width$0 - len | 0) + 2 | 0,len - 2 | 0)}}
           else
            switch$2 = 1;
           if(switch$2)blit$0(str,0,res,width$0 - len | 0,len)}}
      return caml_string_of_bytes(res)}
    function fix_int_precision(prec,str)
     {var
       prec$0=abs(prec),
       len=caml_ml_string_length(str),
       c=caml_string_get(str,0),
       switch$0=0;
      if(58 <= c)
       {if(71 <= c)
         {if(! (5 < (c - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= c)switch$0 = 1}
      else
       {var switch$1=0;
        if(32 !== c)
         if(43 <= c)
          {var switcher=c - 43 | 0;
           switch(switcher)
            {case 5:
              if(len < (prec$0 + 2 | 0) && 1 < len)
               {var switch$2=0;
                if
                 (120
                  ===
                  caml_string_get(str,1)
                  ||
                  88
                  ===
                  caml_string_get(str,1))
                 switch$2 = 1;
                if(switch$2)
                 {var res$1=make(prec$0 + 2 | 0,48);
                  caml_bytes_set(res$1,1,caml_string_get(str,1));
                  blit$0(str,2,res$1,(prec$0 - len | 0) + 4 | 0,len - 2 | 0);
                  return caml_string_of_bytes(res$1)}}
              switch$0 = 1;
              switch$1 = 1;
              break;
             case 0:
             case 2:break;
             case 1:
             case 3:
             case 4:switch$1 = 1;break;
             default:switch$0 = 1;switch$1 = 1}}
         else
          switch$1 = 1;
        if(! switch$1 && len < (prec$0 + 1 | 0))
         {var res$0=make(prec$0 + 1 | 0,48);
          caml_bytes_set(res$0,0,c);
          blit$0(str,1,res$0,(prec$0 - len | 0) + 2 | 0,len - 1 | 0);
          return caml_string_of_bytes(res$0)}}
      if(switch$0 && len < prec$0)
       {var res=make(prec$0,48);
        blit$0(str,0,res,prec$0 - len | 0,len);
        return caml_string_of_bytes(res)}
      return str}
    function string_to_caml_string(str)
     {var
       str$0=escaped$1(str),
       l=caml_ml_string_length(str$0),
       res=make(l + 2 | 0,34);
      caml_blit_string(str$0,0,res,1,l);
      return caml_string_of_bytes(res)}
    function format_of_fconv(fconv,prec)
     {var
       prec$0=abs(prec),
       symb=char_of_fconv(_ap_,fconv),
       buf=buffer_create(16);
      buffer_add_char(buf,37);
      bprint_fconv_flag(buf,fconv);
      buffer_add_char(buf,46);
      buffer_add_string(buf,caml_string_of_jsbytes("" + prec$0));
      buffer_add_char(buf,symb);
      return buffer_contents(buf)}
    function transform_int_alt(iconv,s)
     {if(13 <= iconv)
       {var n=[0,0],_rQ_=caml_ml_string_length(s) - 1 | 0,_rP_=0;
        if(! (_rQ_ < 0))
         {var i$0=_rP_;
          for(;;)
           {var match=caml_string_unsafe_get(s,i$0),switcher$0=match - 48 | 0;
            if(! (9 < switcher$0 >>> 0))n[1]++;
            var _rU_=i$0 + 1 | 0;
            if(_rQ_ !== i$0){var i$0=_rU_;continue}
            break}}
        var
         digits=n[1],
         buf=
          caml_create_bytes
           (caml_ml_string_length(s) + ((digits - 1 | 0) / 3 | 0) | 0),
         pos=[0,0],
         put=function(c){caml_bytes_set(buf,pos[1],c);pos[1]++;return 0},
         left=[0,((digits - 1 | 0) % 3 | 0) + 1 | 0],
         _rS_=caml_ml_string_length(s) - 1 | 0,
         _rR_=0;
        if(! (_rS_ < 0))
         {var i=_rR_;
          for(;;)
           {var c=caml_string_unsafe_get(s,i),switcher=c - 48 | 0;
            if(9 < switcher >>> 0)
             put(c);
            else
             {if(0 === left[1]){put(95);left[1] = 3}left[1] += -1;put(c)}
            var _rT_=i + 1 | 0;
            if(_rS_ !== i){var i=_rT_;continue}
            break}}
        return caml_string_of_bytes(buf)}
      return s}
    function convert_int(iconv,n)
     {switch(iconv)
       {case 1:var _rO_=cst_d$3;break;
        case 2:var _rO_=cst_d$4;break;
        case 4:var _rO_=cst_i$1;break;
        case 5:var _rO_=cst_i$2;break;
        case 6:var _rO_=cst_x;break;
        case 7:var _rO_=cst_x$0;break;
        case 8:var _rO_=cst_X$0;break;
        case 9:var _rO_=cst_X$1;break;
        case 10:var _rO_=cst_o;break;
        case 11:var _rO_=cst_o$0;break;
        case 0:
        case 13:var _rO_=cst_d$2;break;
        case 3:
        case 14:var _rO_=cst_i$0;break;
        default:var _rO_=cst_u}
      return transform_int_alt(iconv,caml_format_int(_rO_,n))}
    function convert_int32(iconv,n)
     {switch(iconv)
       {case 1:var _rN_=cst_ld$0;break;
        case 2:var _rN_=cst_ld$1;break;
        case 4:var _rN_=cst_li$1;break;
        case 5:var _rN_=cst_li$2;break;
        case 6:var _rN_=cst_lx;break;
        case 7:var _rN_=cst_lx$0;break;
        case 8:var _rN_=cst_lX;break;
        case 9:var _rN_=cst_lX$0;break;
        case 10:var _rN_=cst_lo;break;
        case 11:var _rN_=cst_lo$0;break;
        case 0:
        case 13:var _rN_=cst_ld;break;
        case 3:
        case 14:var _rN_=cst_li$0;break;
        default:var _rN_=cst_lu}
      return transform_int_alt(iconv,caml_format_int(_rN_,n))}
    function convert_nativeint(iconv,n)
     {switch(iconv)
       {case 1:var _rM_=cst_nd$0;break;
        case 2:var _rM_=cst_nd$1;break;
        case 4:var _rM_=cst_ni$1;break;
        case 5:var _rM_=cst_ni$2;break;
        case 6:var _rM_=cst_nx;break;
        case 7:var _rM_=cst_nx$0;break;
        case 8:var _rM_=cst_nX;break;
        case 9:var _rM_=cst_nX$0;break;
        case 10:var _rM_=cst_no;break;
        case 11:var _rM_=cst_no$0;break;
        case 0:
        case 13:var _rM_=cst_nd;break;
        case 3:
        case 14:var _rM_=cst_ni$0;break;
        default:var _rM_=cst_nu}
      return transform_int_alt(iconv,caml_format_int(_rM_,n))}
    function convert_int64(iconv,n)
     {switch(iconv)
       {case 1:var _rL_=cst_Ld$0;break;
        case 2:var _rL_=cst_Ld$1;break;
        case 4:var _rL_=cst_Li$1;break;
        case 5:var _rL_=cst_Li$2;break;
        case 6:var _rL_=cst_Lx;break;
        case 7:var _rL_=cst_Lx$0;break;
        case 8:var _rL_=cst_LX;break;
        case 9:var _rL_=cst_LX$0;break;
        case 10:var _rL_=cst_Lo;break;
        case 11:var _rL_=cst_Lo$0;break;
        case 0:
        case 13:var _rL_=cst_Ld;break;
        case 3:
        case 14:var _rL_=cst_Li$0;break;
        default:var _rL_=cst_Lu}
      return transform_int_alt(iconv,caml_int64_format(_rL_,n))}
    function convert_float(fconv,prec,x)
     {function hex(param)
       {switch(fconv[1])
         {case 0:var sign=45;break;
          case 1:var sign=43;break;
          default:var sign=32}
        return runtime.caml_hexstring_of_float(x,prec,sign)}
      function caml_special_val(str)
       {var match=runtime.caml_classify_float(x);
        return 3 === match
                ?x < 0.?cst_neg_infinity:cst_infinity
                :4 <= match?cst_nan:str}
      switch(fconv[2])
       {case 5:
         var
          str=caml_format_float(format_of_fconv(fconv,prec),x),
          len=caml_ml_string_length(str),
          i=0;
         for(;;)
          {if(i === len)
            var _rJ_=0;
           else
            {var match=caml_string_get(str,i),_rI_=match - 46 | 0,switch$0=0;
             if(23 < _rI_ >>> 0)
              {if(55 === _rI_)switch$0 = 1}
             else
              if(21 < (_rI_ - 1 | 0) >>> 0)switch$0 = 1;
             if(! switch$0){var i$0=i + 1 | 0,i=i$0;continue}
             var _rJ_=1}
           var _rK_=_rJ_?str:symbol(str,cst$29);
           return caml_special_val(_rK_)}
        case 6:return hex(0);
        case 7:return uppercase_ascii$1(hex(0));
        case 8:return caml_special_val(hex(0));
        default:return caml_format_float(format_of_fconv(fconv,prec),x)}}
    function string_of_fmtty(fmtty)
     {var buf=buffer_create(16);
      bprint_fmtty(buf,fmtty);
      return buffer_contents(buf)}
    function make_printf$0(counter,k,acc,fmt)
     {var k$0=k,acc$0=acc,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,acc$0);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest)};
          case 1:
           var rest$0=fmt$0[1];
           return function(c)
            {var
              str=escaped(c),
              l=caml_ml_string_length(str),
              res=make(l + 2 | 0,39);
             caml_blit_string(str,0,res,1,l);
             var new_acc=[4,acc$0,caml_string_of_bytes(res)];
             return make_printf(k$0,new_acc,rest$0)};
          case 2:
           var rest$1=fmt$0[2],pad=fmt$0[1];
           return make_padding(k$0,acc$0,rest$1,pad,function(str){return str});
          case 3:
           var rest$2=fmt$0[2],pad$0=fmt$0[1];
           return make_padding(k$0,acc$0,rest$2,pad$0,string_to_caml_string);
          case 4:
           var rest$3=fmt$0[4],prec=fmt$0[3],pad$1=fmt$0[2],iconv=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$3,pad$1,prec,convert_int,iconv);
          case 5:
           var
            rest$4=fmt$0[4],
            prec$0=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$0=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$4,pad$2,prec$0,convert_int32,iconv$0);
          case 6:
           var
            rest$5=fmt$0[4],
            prec$1=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$1=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$5,pad$3,prec$1,convert_nativeint,iconv$1);
          case 7:
           var
            rest$6=fmt$0[4],
            prec$2=fmt$0[3],
            pad$4=fmt$0[2],
            iconv$2=fmt$0[1];
           return make_int_padding_precision
                   (k$0,acc$0,rest$6,pad$4,prec$2,convert_int64,iconv$2);
          case 8:
           var rest$7=fmt$0[4],prec$3=fmt$0[3],pad$5=fmt$0[2],fconv=fmt$0[1];
           if(typeof pad$5 === "number")
            {if(typeof prec$3 === "number")
              return prec$3
                      ?function(p,x)
                        {var str=convert_float(fconv,p,x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(x)
                        {var
                          str=
                           convert_float(fconv,default_float_precision(fconv),x);
                         return make_printf(k$0,[4,acc$0,str],rest$7)};
             var p=prec$3[1];
             return function(x)
              {var str=convert_float(fconv,p,x);
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
           else
            {if(0 === pad$5[0])
              {var _rF_=pad$5[2],_rG_=pad$5[1];
               if(typeof prec$3 === "number")
                return prec$3
                        ?function(p,x)
                          {var str=fix_padding(_rG_,_rF_,convert_float(fconv,p,x));
                           return make_printf(k$0,[4,acc$0,str],rest$7)}
                        :function(x)
                          {var
                            str=convert_float(fconv,default_float_precision(fconv),x),
                            str$0=fix_padding(_rG_,_rF_,str);
                           return make_printf(k$0,[4,acc$0,str$0],rest$7)};
               var p$0=prec$3[1];
               return function(x)
                {var str=fix_padding(_rG_,_rF_,convert_float(fconv,p$0,x));
                 return make_printf(k$0,[4,acc$0,str],rest$7)}}
             var _rH_=pad$5[1];
             if(typeof prec$3 === "number")
              return prec$3
                      ?function(w,p,x)
                        {var str=fix_padding(_rH_,w,convert_float(fconv,p,x));
                         return make_printf(k$0,[4,acc$0,str],rest$7)}
                      :function(w,x)
                        {var
                          str=convert_float(fconv,default_float_precision(fconv),x),
                          str$0=fix_padding(_rH_,w,str);
                         return make_printf(k$0,[4,acc$0,str$0],rest$7)};
             var p$1=prec$3[1];
             return function(w,x)
              {var str=fix_padding(_rH_,w,convert_float(fconv,p$1,x));
               return make_printf(k$0,[4,acc$0,str],rest$7)}}
          case 9:
           var rest$8=fmt$0[2],pad$6=fmt$0[1];
           return make_padding(k$0,acc$0,rest$8,pad$6,string_of_bool);
          case 10:
           var fmt$1=fmt$0[1],acc$1=[7,acc$0],acc$0=acc$1,fmt$0=fmt$1;
           continue;
          case 11:
           var
            fmt$2=fmt$0[2],
            str=fmt$0[1],
            acc$2=[2,acc$0,str],
            acc$0=acc$2,
            fmt$0=fmt$2;
           continue;
          case 12:
           var
            fmt$3=fmt$0[2],
            chr=fmt$0[1],
            acc$3=[3,acc$0,chr],
            acc$0=acc$3,
            fmt$0=fmt$3;
           continue;
          case 13:
           var
            rest$9=fmt$0[3],
            sub_fmtty=fmt$0[2],
            ty=string_of_fmtty(sub_fmtty);
           return function(str){return make_printf(k$0,[4,acc$0,ty],rest$9)};
          case 14:
           var rest$10=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_printf
                     (k$0,acc$0,concat_fmt(recast(fmt,fmtty),rest$10))};
          case 15:
           var rest$11=fmt$0[1];
           return function(f,x)
            {return make_printf
                     (k$0,
                      [6,acc$0,function(o){return caml_call2(f,o,x)}],
                      rest$11)};
          case 16:
           var rest$12=fmt$0[1];
           return function(f){return make_printf(k$0,[6,acc$0,f],rest$12)};
          case 17:
           var
            fmt$4=fmt$0[2],
            fmting_lit=fmt$0[1],
            acc$4=[0,acc$0,fmting_lit],
            acc$0=acc$4,
            fmt$0=fmt$4;
           continue;
          case 18:
           var _rD_=fmt$0[1];
           if(0 === _rD_[0])
            {var
              rest$13=fmt$0[2],
              match=_rD_[1],
              fmt$5=match[1],
              k$3=
               function(acc,k,rest)
                {function k$0(kacc)
                  {return make_printf(k,[1,acc,[0,kacc]],rest)}
                 return k$0},
              k$1=k$3(acc$0,k$0,rest$13),
              k$0=k$1,
              acc$0=0,
              fmt$0=fmt$5;
             continue}
           var
            rest$14=fmt$0[2],
            match$0=_rD_[1],
            fmt$6=match$0[1],
            k$4=
             function(acc,k,rest)
              {function k$0(kacc){return make_printf(k,[1,acc,[1,kacc]],rest)}
               return k$0},
            k$2=k$4(acc$0,k$0,rest$14),
            k$0=k$2,
            acc$0=0,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_aq_];
          case 20:
           var rest$15=fmt$0[3],new_acc=[8,acc$0,cst_Printf_bad_conversion];
           return function(param){return make_printf(k$0,new_acc,rest$15)};
          case 21:
           var rest$16=fmt$0[2];
           return function(n)
            {var new_acc=[4,acc$0,caml_format_int(cst_u$0,n)];
             return make_printf(k$0,new_acc,rest$16)};
          case 22:
           var rest$17=fmt$0[1];
           return function(c)
            {var new_acc=[5,acc$0,c];return make_printf(k$0,new_acc,rest$17)};
          case 23:
           var rest$18=fmt$0[2],ign=fmt$0[1];
           if(counter < 50)
            {var counter$1=counter + 1 | 0;
             return make_ignored_param$0(counter$1,k$0,acc$0,ign,rest$18)}
           return caml_trampoline_return
                   (make_ignored_param$0,[0,k$0,acc$0,ign,rest$18]);
          default:
           var
            rest$19=fmt$0[3],
            f=fmt$0[2],
            arity=fmt$0[1],
            _rE_=caml_call1(f,0);
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return make_custom$0(counter$0,k$0,acc$0,rest$19,arity,_rE_)}
           return caml_trampoline_return
                   (make_custom$0,[0,k$0,acc$0,rest$19,arity,_rE_])}}
    function make_ignored_param$0(counter,k,acc,ign,fmt)
     {if(typeof ign === "number")
       switch(ign)
        {case 0:
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return make_invalid_arg(counter$0,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return make_invalid_arg(counter$1,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:throw [0,Assert_failure,_ar_];
         default:
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return make_invalid_arg(counter$2,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(ign[0])
        {case 0:
          if(counter < 50)
           {var counter$3=counter + 1 | 0;
            return make_invalid_arg(counter$3,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 1:
          if(counter < 50)
           {var counter$4=counter + 1 | 0;
            return make_invalid_arg(counter$4,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 2:
          if(counter < 50)
           {var counter$5=counter + 1 | 0;
            return make_invalid_arg(counter$5,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 3:
          if(counter < 50)
           {var counter$6=counter + 1 | 0;
            return make_invalid_arg(counter$6,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 4:
          if(counter < 50)
           {var counter$7=counter + 1 | 0;
            return make_invalid_arg(counter$7,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 5:
          if(counter < 50)
           {var counter$8=counter + 1 | 0;
            return make_invalid_arg(counter$8,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 6:
          if(counter < 50)
           {var counter$9=counter + 1 | 0;
            return make_invalid_arg(counter$9,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 7:
          if(counter < 50)
           {var counter$10=counter + 1 | 0;
            return make_invalid_arg(counter$10,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 8:
          if(counter < 50)
           {var counter$11=counter + 1 | 0;
            return make_invalid_arg(counter$11,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         case 9:
          var fmtty=ign[2];
          if(counter < 50)
           {var counter$14=counter + 1 | 0;
            return make_from_fmtty$0(counter$14,k,acc,fmtty,fmt)}
          return caml_trampoline_return(make_from_fmtty$0,[0,k,acc,fmtty,fmt]);
         case 10:
          if(counter < 50)
           {var counter$12=counter + 1 | 0;
            return make_invalid_arg(counter$12,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt]);
         default:
          if(counter < 50)
           {var counter$13=counter + 1 | 0;
            return make_invalid_arg(counter$13,k,acc,fmt)}
          return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}}
    function make_from_fmtty$0(counter,k,acc,fmtty,fmt)
     {if(typeof fmtty === "number")
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return make_invalid_arg(counter$0,k,acc,fmt)}
        return caml_trampoline_return(make_invalid_arg,[0,k,acc,fmt])}
      else
       switch(fmtty[0])
        {case 0:
          var rest=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest,fmt)};
         case 1:
          var rest$0=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$0,fmt)};
         case 2:
          var rest$1=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$1,fmt)};
         case 3:
          var rest$2=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$2,fmt)};
         case 4:
          var rest$3=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$3,fmt)};
         case 5:
          var rest$4=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$4,fmt)};
         case 6:
          var rest$5=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$5,fmt)};
         case 7:
          var rest$6=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$6,fmt)};
         case 8:
          var rest$7=fmtty[2];
          return function(param){return make_from_fmtty(k,acc,rest$7,fmt)};
         case 9:
          var
           rest$8=fmtty[3],
           ty2=fmtty[2],
           ty1=fmtty[1],
           ty=trans(symm(ty1),ty2);
          return function(param)
           {return make_from_fmtty(k,acc,concat_fmtty(ty,rest$8),fmt)};
         case 10:
          var rest$9=fmtty[1];
          return function(param,_rC_)
           {return make_from_fmtty(k,acc,rest$9,fmt)};
         case 11:
          var rest$10=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$10,fmt)};
         case 12:
          var rest$11=fmtty[1];
          return function(param){return make_from_fmtty(k,acc,rest$11,fmt)};
         case 13:throw [0,Assert_failure,_as_];
         default:throw [0,Assert_failure,_at_]}}
    function make_invalid_arg(counter,k,acc,fmt)
     {var _rB_=[8,acc,cst_Printf_bad_conversion$0];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_rB_,fmt)}
      return caml_trampoline_return(make_printf$0,[0,k,_rB_,fmt])}
    function make_custom$0(counter,k,acc,rest,arity,f)
     {if(arity)
       {var arity$0=arity[1];
        return function(x)
         {return make_custom(k,acc,rest,arity$0,caml_call1(f,x))}}
      var _rA_=[4,acc,f];
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_printf$0(counter$0,k,_rA_,rest)}
      return caml_trampoline_return(make_printf$0,[0,k,_rA_,rest])}
    function make_printf(k,acc,fmt)
     {return caml_trampoline(make_printf$0(0,k,acc,fmt))}
    function make_ignored_param(k,acc,ign,fmt)
     {return caml_trampoline(make_ignored_param$0(0,k,acc,ign,fmt))}
    function make_from_fmtty(k,acc,fmtty,fmt)
     {return caml_trampoline(make_from_fmtty$0(0,k,acc,fmtty,fmt))}
    function make_custom(k,acc,rest,arity,f)
     {return caml_trampoline(make_custom$0(0,k,acc,rest,arity,f))}
    function make_padding(k,acc,fmt,pad,trans)
     {if(typeof pad === "number")
       return function(x)
        {var new_acc=[4,acc,caml_call1(trans,x)];
         return make_printf(k,new_acc,fmt)};
      else
       {if(0 === pad[0])
         {var width=pad[2],padty=pad[1];
          return function(x)
           {var new_acc=[4,acc,fix_padding(padty,width,caml_call1(trans,x))];
            return make_printf(k,new_acc,fmt)}}
        var padty$0=pad[1];
        return function(w,x)
         {var new_acc=[4,acc,fix_padding(padty$0,w,caml_call1(trans,x))];
          return make_printf(k,new_acc,fmt)}}}
    function make_int_padding_precision(k,acc,fmt,pad,match,trans,iconv)
     {if(typeof pad === "number")
       {if(typeof match === "number")
         return match
                 ?function(p,x)
                   {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(x)
                   {var str=caml_call2(trans,iconv,x);
                    return make_printf(k,[4,acc,str],fmt)};
        var p=match[1];
        return function(x)
         {var str=fix_int_precision(p,caml_call2(trans,iconv,x));
          return make_printf(k,[4,acc,str],fmt)}}
      else
       {if(0 === pad[0])
         {var _rx_=pad[2],_ry_=pad[1];
          if(typeof match === "number")
           return match
                   ?function(p,x)
                     {var
                       str=
                        fix_padding
                         (_ry_,_rx_,fix_int_precision(p,caml_call2(trans,iconv,x)));
                      return make_printf(k,[4,acc,str],fmt)}
                   :function(x)
                     {var str=fix_padding(_ry_,_rx_,caml_call2(trans,iconv,x));
                      return make_printf(k,[4,acc,str],fmt)};
          var p$0=match[1];
          return function(x)
           {var
             str=
              fix_padding
               (_ry_,_rx_,fix_int_precision(p$0,caml_call2(trans,iconv,x)));
            return make_printf(k,[4,acc,str],fmt)}}
        var _rz_=pad[1];
        if(typeof match === "number")
         return match
                 ?function(w,p,x)
                   {var
                     str=
                      fix_padding
                       (_rz_,w,fix_int_precision(p,caml_call2(trans,iconv,x)));
                    return make_printf(k,[4,acc,str],fmt)}
                 :function(w,x)
                   {var str=fix_padding(_rz_,w,caml_call2(trans,iconv,x));
                    return make_printf(k,[4,acc,str],fmt)};
        var p$1=match[1];
        return function(w,x)
         {var
           str=
            fix_padding
             (_rz_,w,fix_int_precision(p$1,caml_call2(trans,iconv,x)));
          return make_printf(k,[4,acc,str],fmt)}}}
    function make_iprintf$0(counter,k,o,fmt)
     {var k$0=k,fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k$0,o);
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1],_qO_=make_iprintf(k$0,o,rest);
           return function(_rw_){return _qO_};
          case 1:
           var rest$0=fmt$0[1],_qP_=make_iprintf(k$0,o,rest$0);
           return function(_rv_){return _qP_};
          case 2:
           var _qQ_=fmt$0[1];
           if(typeof _qQ_ === "number")
            {var rest$1=fmt$0[2],_qR_=make_iprintf(k$0,o,rest$1);
             return function(_rr_){return _qR_}}
           else
            {if(0 === _qQ_[0])
              {var rest$2=fmt$0[2],_qS_=make_iprintf(k$0,o,rest$2);
               return function(_ru_){return _qS_}}
             var
              rest$3=fmt$0[2],
              _qT_=make_iprintf(k$0,o,rest$3),
              _qU_=function(_rt_){return _qT_};
             return function(_rs_){return _qU_}}
          case 3:
           var _qV_=fmt$0[1];
           if(typeof _qV_ === "number")
            {var rest$4=fmt$0[2],_qW_=make_iprintf(k$0,o,rest$4);
             return function(_rn_){return _qW_}}
           else
            {if(0 === _qV_[0])
              {var rest$5=fmt$0[2],_qX_=make_iprintf(k$0,o,rest$5);
               return function(_rq_){return _qX_}}
             var
              rest$6=fmt$0[2],
              _qY_=make_iprintf(k$0,o,rest$6),
              _qZ_=function(_rp_){return _qY_};
             return function(_ro_){return _qZ_}}
          case 4:
           var rest$7=fmt$0[4],prec=fmt$0[3],pad=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$7,pad,prec);
          case 5:
           var rest$8=fmt$0[4],prec$0=fmt$0[3],pad$0=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$8,pad$0,prec$0);
          case 6:
           var rest$9=fmt$0[4],prec$1=fmt$0[3],pad$1=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$9,pad$1,prec$1);
          case 7:
           var rest$10=fmt$0[4],prec$2=fmt$0[3],pad$2=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$10,pad$2,prec$2);
          case 8:
           var rest$11=fmt$0[4],prec$3=fmt$0[3],pad$3=fmt$0[2];
           return fn_of_padding_precision(k$0,o,rest$11,pad$3,prec$3);
          case 9:
           var _q0_=fmt$0[1];
           if(typeof _q0_ === "number")
            {var rest$12=fmt$0[2],_q1_=make_iprintf(k$0,o,rest$12);
             return function(_rj_){return _q1_}}
           else
            {if(0 === _q0_[0])
              {var rest$13=fmt$0[2],_q2_=make_iprintf(k$0,o,rest$13);
               return function(_rm_){return _q2_}}
             var
              rest$14=fmt$0[2],
              _q3_=make_iprintf(k$0,o,rest$14),
              _q4_=function(_rl_){return _q3_};
             return function(_rk_){return _q4_}}
          case 10:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 11:var fmt$2=fmt$0[2],fmt$0=fmt$2;continue;
          case 12:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 13:
           var rest$15=fmt$0[3],_q5_=make_iprintf(k$0,o,rest$15);
           return function(_ri_){return _q5_};
          case 14:
           var rest$16=fmt$0[3],fmtty=fmt$0[2];
           return function(param)
            {var fmt=param[1];
             return make_iprintf(k$0,o,concat_fmt(recast(fmt,fmtty),rest$16))};
          case 15:
           var
            rest$17=fmt$0[1],
            _q6_=make_iprintf(k$0,o,rest$17),
            _q7_=function(_rh_){return _q6_};
           return function(_rg_){return _q7_};
          case 16:
           var rest$18=fmt$0[1],_q8_=make_iprintf(k$0,o,rest$18);
           return function(_rf_){return _q8_};
          case 17:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 18:
           var _q9_=fmt$0[1];
           if(0 === _q9_[0])
            {var
              rest$19=fmt$0[2],
              match=_q9_[1],
              fmt$5=match[1],
              k$3=
               function(k,rest)
                {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
              k$1=k$3(k$0,rest$19),
              k$0=k$1,
              fmt$0=fmt$5;
             continue}
           var
            rest$20=fmt$0[2],
            match$0=_q9_[1],
            fmt$6=match$0[1],
            k$4=
             function(k,rest)
              {function k$0(koc){return make_iprintf(k,koc,rest)}return k$0},
            k$2=k$4(k$0,rest$20),
            k$0=k$2,
            fmt$0=fmt$6;
           continue;
          case 19:throw [0,Assert_failure,_au_];
          case 20:
           var rest$21=fmt$0[3],_q__=make_iprintf(k$0,o,rest$21);
           return function(_re_){return _q__};
          case 21:
           var rest$22=fmt$0[2],_q$_=make_iprintf(k$0,o,rest$22);
           return function(_rd_){return _q$_};
          case 22:
           var rest$23=fmt$0[1],_ra_=make_iprintf(k$0,o,rest$23);
           return function(_rc_){return _ra_};
          case 23:
           var rest$24=fmt$0[2],ign=fmt$0[1],_rb_=0;
           return make_ignored_param
                   (function(param){return caml_call1(k$0,o)},_rb_,ign,rest$24);
          default:
           var rest$25=fmt$0[3],arity=fmt$0[1];
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return fn_of_custom_arity$0(counter$0,k$0,o,rest$25,arity)}
           return caml_trampoline_return
                   (fn_of_custom_arity$0,[0,k$0,o,rest$25,arity])}}
    function fn_of_custom_arity$0(counter,k,o,fmt,param)
     {if(param)
       {var arity=param[1],_qM_=fn_of_custom_arity(k,o,fmt,arity);
        return function(_qN_){return _qM_}}
      if(counter < 50)
       {var counter$0=counter + 1 | 0;
        return make_iprintf$0(counter$0,k,o,fmt)}
      return caml_trampoline_return(make_iprintf$0,[0,k,o,fmt])}
    function make_iprintf(k,o,fmt)
     {return caml_trampoline(make_iprintf$0(0,k,o,fmt))}
    function fn_of_custom_arity(k,o,fmt,param)
     {return caml_trampoline(fn_of_custom_arity$0(0,k,o,fmt,param))}
    function fn_of_padding_precision(k,o,fmt,pad,prec)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)
           {var _qi_=make_iprintf(k,o,fmt),_qj_=function(_qA_){return _qi_};
            return function(_qz_){return _qj_}}
          var _qk_=make_iprintf(k,o,fmt);
          return function(_qy_){return _qk_}}
        var _ql_=make_iprintf(k,o,fmt);
        return function(_qx_){return _ql_}}
      else
       {if(0 === pad[0])
         {if(typeof prec === "number")
           {if(prec)
             {var _qm_=make_iprintf(k,o,fmt),_qn_=function(_qL_){return _qm_};
              return function(_qK_){return _qn_}}
            var _qo_=make_iprintf(k,o,fmt);
            return function(_qJ_){return _qo_}}
          var _qp_=make_iprintf(k,o,fmt);
          return function(_qI_){return _qp_}}
        if(typeof prec === "number")
         {if(prec)
           {var
             _qq_=make_iprintf(k,o,fmt),
             _qr_=function(_qH_){return _qq_},
             _qs_=function(_qG_){return _qr_};
            return function(_qF_){return _qs_}}
          var _qt_=make_iprintf(k,o,fmt),_qu_=function(_qE_){return _qt_};
          return function(_qD_){return _qu_}}
        var _qv_=make_iprintf(k,o,fmt),_qw_=function(_qC_){return _qv_};
        return function(_qB_){return _qw_}}}
    function output_acc(o,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           output_acc(o,p);
           return output_string(o,s);
          case 1:
           var _qg_=acc$0[2],_qh_=acc$0[1];
           if(0 === _qg_[0])
            {var acc$1=_qg_[1];
             output_acc(o,_qh_);
             output_string(o,cst$30);
             var acc$0=acc$1;
             continue}
           var acc$2=_qg_[1];
           output_acc(o,_qh_);
           output_string(o,cst$31);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           output_acc(o,p$2);
           return caml_call1(f,o);
          case 7:var p$3=acc$0[1];output_acc(o,p$3);return caml_ml_flush(o);
          case 8:
           var msg=acc$0[2],p$4=acc$0[1];
           output_acc(o,p$4);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           output_acc(o,p$0);
           return output_string(o,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];
           output_acc(o,p$1);
           return caml_ml_output_char(o,c)}}
    function bufput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           bufput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _qe_=acc$0[2],_qf_=acc$0[1];
           if(0 === _qe_[0])
            {var acc$1=_qe_[1];
             bufput_acc(b,_qf_);
             add_string(b,cst$32);
             var acc$0=acc$1;
             continue}
           var acc$2=_qe_[1];
           bufput_acc(b,_qf_);
           add_string(b,cst$33);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           bufput_acc(b,p$2);
           return caml_call1(f,b);
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           bufput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           bufput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];bufput_acc(b,p$1);return add_char(b,c)}}
    function strput_acc(b,acc)
     {var acc$0=acc;
      for(;;)
       if(typeof acc$0 === "number")
        return 0;
       else
        switch(acc$0[0])
         {case 0:
           var
            fmting_lit=acc$0[2],
            p=acc$0[1],
            s=string_of_formatting_lit(fmting_lit);
           strput_acc(b,p);
           return add_string(b,s);
          case 1:
           var _qc_=acc$0[2],_qd_=acc$0[1];
           if(0 === _qc_[0])
            {var acc$1=_qc_[1];
             strput_acc(b,_qd_);
             add_string(b,cst$34);
             var acc$0=acc$1;
             continue}
           var acc$2=_qc_[1];
           strput_acc(b,_qd_);
           add_string(b,cst$35);
           var acc$0=acc$2;
           continue;
          case 6:
           var f=acc$0[2],p$2=acc$0[1];
           strput_acc(b,p$2);
           return add_string(b,caml_call1(f,0));
          case 7:var acc$3=acc$0[1],acc$0=acc$3;continue;
          case 8:
           var msg=acc$0[2],p$3=acc$0[1];
           strput_acc(b,p$3);
           return invalid_arg(msg);
          case 2:
          case 4:
           var s$0=acc$0[2],p$0=acc$0[1];
           strput_acc(b,p$0);
           return add_string(b,s$0);
          default:
           var c=acc$0[2],p$1=acc$0[1];strput_acc(b,p$1);return add_char(b,c)}}
    function failwith_message(param)
     {var fmt=param[1],buf=create$2(256);
      function k(acc){strput_acc(buf,acc);return failwith(contents(buf))}
      return make_printf(k,0,fmt)}
    function open_box_of_string(str)
     {if(caml_string_equal(str,cst$36))return _av_;
      var len=caml_ml_string_length(str);
      function invalid_box(param)
       {return caml_call1(failwith_message(_aw_),str)}
      function parse_spaces(i)
       {var i$0=i;
        for(;;)
         {if(i$0 === len)return i$0;
          var match=caml_string_get(str,i$0);
          if(9 !== match && 32 !== match)return i$0;
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function parse_lword(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switcher=match - 97 | 0;
          if(25 < switcher >>> 0)return j$0;
          var j$1=j$0 + 1 | 0,j$0=j$1;
          continue}}
      function parse_int(i,j)
       {var j$0=j;
        for(;;)
         {if(j$0 === len)return j$0;
          var match=caml_string_get(str,j$0),switch$0=0;
          if(48 <= match)
           {if(! (58 <= match))switch$0 = 1}
          else
           if(45 === match)switch$0 = 1;
          if(switch$0){var j$1=j$0 + 1 | 0,j$0=j$1;continue}
          return j$0}}
      var
       wstart=parse_spaces(0),
       wend=parse_lword(wstart,wstart),
       box_name=sub$0(str,wstart,wend - wstart | 0),
       nstart=parse_spaces(wend),
       nend=parse_int(nstart,nstart);
      if(nstart === nend)
       var indent=0;
      else
       try
        {var
          _qa_=caml_int_of_string(sub$0(str,nstart,nend - nstart | 0)),
          indent=_qa_}
       catch(_qb_)
        {_qb_ = caml_wrap_exception(_qb_);
         if(_qb_[1] !== Failure)throw _qb_;
         var indent=invalid_box(0)}
      var exp_end=parse_spaces(nend);
      if(exp_end !== len)invalid_box(0);
      var switch$0=0;
      if
       (caml_string_notequal(box_name,cst$37)
        &&
        caml_string_notequal(box_name,cst_b$0))
       var
        box_type=
         caml_string_notequal(box_name,cst_h)
          ?caml_string_notequal(box_name,cst_hov)
            ?caml_string_notequal(box_name,cst_hv)
              ?caml_string_notequal(box_name,cst_v)?invalid_box(0):1
              :2
            :3
          :0;
      else
       switch$0 = 1;
      if(switch$0)var box_type=4;
      return [0,indent,box_type]}
    function make_padding_fmt_ebb(pad,fmt)
     {if(typeof pad === "number")
       return [0,0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],fmt]}}
    function make_padprec_fmt_ebb(pad,prec,fmt)
     {if(typeof prec === "number")
       var match=prec?[0,1,fmt]:[0,0,fmt];
      else
       var p=prec[1],match=[0,[0,p],fmt];
      var prec$0=match[1];
      if(typeof pad === "number")
       return [0,0,prec$0,fmt];
      else
       {if(0 === pad[0]){var w=pad[2],s=pad[1];return [0,[0,s,w],prec$0,fmt]}
        var s$0=pad[1];
        return [0,[1,s$0],prec$0,fmt]}}
    function fmt_ebb_of_string(legacy_behavior,str)
     {if(legacy_behavior)
       var flag=legacy_behavior[1],legacy_behavior$0=flag;
      else
       var legacy_behavior$0=1;
      function invalid_format_message(str_ind,msg)
       {return caml_call3(failwith_message(_ax_),str,str_ind,msg)}
      function unexpected_end_of_format(end_ind)
       {return invalid_format_message(end_ind,cst_unexpected_end_of_format)}
      function invalid_format_without(str_ind,c,s)
       {return caml_call4(failwith_message(_ay_),str,str_ind,c,s)}
      function expected_character(str_ind,expected,read)
       {return caml_call4(failwith_message(_az_),str,str_ind,expected,read)}
      function add_literal(lit_start,str_ind,fmt)
       {var size=str_ind - lit_start | 0;
        return 0 === size
                ?[0,fmt]
                :1 === size
                  ?[0,[12,caml_string_get(str,lit_start),fmt]]
                  :[0,[11,sub$0(str,lit_start,size),fmt]]}
      function parse_positive(str_ind,end_ind,acc)
       {var str_ind$0=str_ind,acc$0=acc;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var c=caml_string_get(str,str_ind$0),switcher=c - 48 | 0;
          if(9 < switcher >>> 0)return [0,str_ind$0,acc$0];
          var acc$1=(acc$0 * 10 | 0) + (c - 48 | 0) | 0;
          if(max_string_length < acc$1)
           return caml_call3
                   (failwith_message(_aQ_),str,acc$1,max_string_length);
          var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,acc$0=acc$1;
          continue}}
      function parse_integer(str_ind,end_ind)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var match=caml_string_get(str,str_ind);
        if(48 <= match)
         {if(! (58 <= match))return parse_positive(str_ind,end_ind,0)}
        else
         if(45 === match)
          {if((str_ind + 1 | 0) === end_ind)unexpected_end_of_format(end_ind);
           var c=caml_string_get(str,str_ind + 1 | 0),switcher=c - 48 | 0;
           if(9 < switcher >>> 0)
            return expected_character(str_ind + 1 | 0,cst_digit,c);
           var
            match$0=parse_positive(str_ind + 1 | 0,end_ind,0),
            n=match$0[2],
            next_ind=match$0[1];
           return [0,next_ind,- n | 0]}
        throw [0,Assert_failure,_aR_]}
      function parse_spaces(str_ind,end_ind)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          if(32 === caml_string_get(str,str_ind$0))
           {var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;continue}
          return str_ind$0}}
      function incompatible_flag(pct_ind,str_ind,symb,option)
       {var subfmt=sub$0(str,pct_ind,str_ind - pct_ind | 0);
        return caml_call5
                (failwith_message(_aW_),str,pct_ind,option,symb,subfmt)}
      function compute_int_conv(pct_ind,str_ind,plus,hash,space,symb)
       {var plus$0=plus,hash$0=hash,space$0=space;
        for(;;)
         {var switch$0=0;
          if(plus$0)
           {if(hash$0)
             switch$0 = 1;
            else
             if(! space$0){if(100 === symb)return 1;if(105 === symb)return 4}}
          else
           if(hash$0)
            if(space$0)
             switch$0 = 1;
            else
             {var switcher$0=symb - 88 | 0;
              if(32 < switcher$0 >>> 0)
               switch$0 = 1;
              else
               switch(switcher$0)
                {case 0:return 9;
                 case 12:return 13;
                 case 17:return 14;
                 case 23:return 11;
                 case 29:return 15;
                 case 32:return 7;
                 default:switch$0 = 1}}
           else
            if(space$0)
             {if(100 === symb)return 2;if(105 === symb)return 5}
            else
             {var switcher$1=symb - 88 | 0;
              if(! (32 < switcher$1 >>> 0))
               switch(switcher$1)
                {case 0:return 8;
                 case 12:return 0;
                 case 17:return 3;
                 case 23:return 10;
                 case 29:return 12;
                 case 32:return 6
                 }}
          if(switch$0)
           {var switcher=symb - 88 | 0;
            if(! (32 < switcher >>> 0))
             switch(switcher)
              {case 0:if(legacy_behavior$0)return 9;break;
               case 23:if(legacy_behavior$0)return 11;break;
               case 32:if(legacy_behavior$0)return 7;break;
               case 12:
               case 17:
               case 29:
                if(legacy_behavior$0){var hash$0=0;continue}
                return incompatible_flag(pct_ind,str_ind,symb,cst$49)
               }}
          if(plus$0)
           {if(space$0)
             {if(legacy_behavior$0){var space$0=0;continue}
              return incompatible_flag(pct_ind,str_ind,32,cst$46)}
            if(legacy_behavior$0){var plus$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$47)}
          if(space$0)
           {if(legacy_behavior$0){var space$0=0;continue}
            return incompatible_flag(pct_ind,str_ind,symb,cst$48)}
          throw [0,Assert_failure,_aU_]}}
      function search_subformat_end(str_ind,end_ind,c)
       {var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)
           caml_call3(failwith_message(_aS_),str,c,end_ind);
          var match=caml_string_get(str,str_ind$0);
          if(37 === match)
           {if((str_ind$0 + 1 | 0) === end_ind)
             unexpected_end_of_format(end_ind);
            if(caml_string_get(str,str_ind$0 + 1 | 0) === c)return str_ind$0;
            var match$0=caml_string_get(str,str_ind$0 + 1 | 0);
            if(95 <= match$0)
             {if(123 <= match$0)
               {if(! (126 <= match$0))
                 {var switcher=match$0 - 123 | 0;
                  switch(switcher)
                   {case 0:
                     var
                      sub_end=search_subformat_end(str_ind$0 + 2 | 0,end_ind,125),
                      str_ind$2=sub_end + 2 | 0,
                      str_ind$0=str_ind$2;
                     continue;
                    case 1:break;
                    default:
                     return expected_character
                             (str_ind$0 + 1 | 0,cst_character,125)}}}
              else
               if(! (96 <= match$0))
                {if((str_ind$0 + 2 | 0) === end_ind)
                  unexpected_end_of_format(end_ind);
                 var match$1=caml_string_get(str,str_ind$0 + 2 | 0);
                 if(40 === match$1)
                  {var
                    sub_end$0=search_subformat_end(str_ind$0 + 3 | 0,end_ind,41),
                    str_ind$3=sub_end$0 + 2 | 0,
                    str_ind$0=str_ind$3;
                   continue}
                 if(123 === match$1)
                  {var
                    sub_end$1=
                     search_subformat_end(str_ind$0 + 3 | 0,end_ind,125),
                    str_ind$4=sub_end$1 + 2 | 0,
                    str_ind$0=str_ind$4;
                   continue}
                 var str_ind$5=str_ind$0 + 3 | 0,str_ind$0=str_ind$5;
                 continue}}
            else
             {if(40 === match$0)
               {var
                 sub_end$2=search_subformat_end(str_ind$0 + 2 | 0,end_ind,41),
                 str_ind$6=sub_end$2 + 2 | 0,
                 str_ind$0=str_ind$6;
                continue}
              if(41 === match$0)
               return expected_character(str_ind$0 + 1 | 0,cst_character$0,41)}
            var str_ind$1=str_ind$0 + 2 | 0,str_ind$0=str_ind$1;
            continue}
          var str_ind$7=str_ind$0 + 1 | 0,str_ind$0=str_ind$7;
          continue}}
      function parse_magic_size(str_ind,end_ind)
       {try
         {var
           str_ind_1=parse_spaces(str_ind,end_ind),
           match$2=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$2)
           {if(! (58 <= match$2))switch$0 = 1}
          else
           if(45 === match$2)switch$0 = 1;
          if(switch$0)
           {var
             match$3=parse_integer(str_ind_1,end_ind),
             size=match$3[2],
             str_ind_2=match$3[1],
             str_ind_3=parse_spaces(str_ind_2,end_ind);
            if(62 !== caml_string_get(str,str_ind_3))throw Not_found;
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _p__=[0,[0,str_ind_3 + 1 | 0,[1,s,size]]]}
          else
           var _p__=0;
          var _p9_=_p__}
        catch(_p$_)
         {_p$_ = caml_wrap_exception(_p$_);
          if(_p$_ !== Not_found && _p$_[1] !== Failure)throw _p$_;
          var _p9_=0}
        if(_p9_)
         {var
           match=_p9_[1],
           formatting_lit=match[2],
           next_ind=match[1],
           match$0=parse(next_ind,end_ind),
           fmt_rest=match$0[1];
          return [0,[17,formatting_lit,fmt_rest]]}
        var match$1=parse(str_ind,end_ind),fmt_rest$0=match$1[1];
        return [0,[17,_aO_,fmt_rest$0]]}
      function parse_good_break(str_ind,end_ind)
       {try
         {var
           _p2_=str_ind === end_ind?1:0,
           _p3_=_p2_ || (60 !== caml_string_get(str,str_ind)?1:0);
          if(_p3_)throw Not_found;
          var
           str_ind_1=parse_spaces(str_ind + 1 | 0,end_ind),
           match$0=caml_string_get(str,str_ind_1),
           switch$0=0;
          if(48 <= match$0)
           {if(! (58 <= match$0))switch$0 = 1}
          else
           if(45 === match$0)switch$0 = 1;
          if(! switch$0)throw Not_found;
          var
           match$1=parse_integer(str_ind_1,end_ind),
           width=match$1[2],
           str_ind_2=match$1[1],
           str_ind_3=parse_spaces(str_ind_2,end_ind),
           match$2=caml_string_get(str,str_ind_3),
           switcher=match$2 - 45 | 0,
           switch$1=0;
          if(12 < switcher >>> 0)
           if(17 === switcher)
            var
             s=sub$0(str,str_ind - 2 | 0,(str_ind_3 - str_ind | 0) + 3 | 0),
             _p4_=[0,s,width,0],
             _p5_=str_ind_3 + 1 | 0,
             formatting_lit$0=_p4_,
             next_ind=_p5_;
           else
            switch$1 = 1;
          else
           {var switcher$0=switcher - 1 | 0;
            if(1 < switcher$0 >>> 0)
             {var
               match$3=parse_integer(str_ind_3,end_ind),
               offset=match$3[2],
               str_ind_4=match$3[1],
               str_ind_5=parse_spaces(str_ind_4,end_ind);
              if(62 !== caml_string_get(str,str_ind_5))throw Not_found;
              var
               s$0=
                sub$0(str,str_ind - 2 | 0,(str_ind_5 - str_ind | 0) + 3 | 0),
               _p6_=[0,s$0,width,offset],
               _p7_=str_ind_5 + 1 | 0,
               formatting_lit$0=_p6_,
               next_ind=_p7_}
            else
             switch$1 = 1}
          if(switch$1)throw Not_found}
        catch(_p8_)
         {_p8_ = caml_wrap_exception(_p8_);
          if(_p8_ !== Not_found && _p8_[1] !== Failure)throw _p8_;
          var formatting_lit$0=formatting_lit,next_ind=str_ind}
        var match=parse(next_ind,end_ind),fmt_rest=match[1];
        return [0,[17,formatting_lit$0,fmt_rest]]}
      function parse_tag(is_open_tag,str_ind,end_ind)
       {try
         {if(str_ind === end_ind)throw Not_found;
          var match$0=caml_string_get(str,str_ind);
          if(60 === match$0)
           {var ind=index_from$0(str,str_ind + 1 | 0,62);
            if(end_ind <= ind)throw Not_found;
            var
             sub_str=sub$0(str,str_ind,(ind - str_ind | 0) + 1 | 0),
             match$1=parse(ind + 1 | 0,end_ind),
             fmt_rest$0=match$1[1],
             match$2=parse(str_ind,ind + 1 | 0),
             sub_fmt=match$2[1],
             sub_format$0=[0,sub_fmt,sub_str],
             formatting$0=is_open_tag?[0,sub_format$0]:[1,sub_format$0],
             _p0_=[0,[18,formatting$0,fmt_rest$0]];
            return _p0_}
          throw Not_found}
        catch(_p1_)
         {_p1_ = caml_wrap_exception(_p1_);
          if(_p1_ === Not_found)
           {var
             match=parse(str_ind,end_ind),
             fmt_rest=match[1],
             formatting=is_open_tag?[0,sub_format]:[1,sub_format];
            return [0,[18,formatting,fmt_rest]]}
          throw _p1_}}
      function parse_flags(pct_ind,str_ind,end_ind,ign)
       {var zero=[0,0],minus=[0,0],plus=[0,0],space=[0,0],hash=[0,0];
        function set_flag(str_ind,flag)
         {var _pX_=flag[1],_pY_=_pX_?1 - legacy_behavior$0:_pX_;
          if(_pY_)
           {var _pZ_=caml_string_get(str,str_ind);
            caml_call3(failwith_message(_aA_),str,str_ind,_pZ_)}
          flag[1] = 1;
          return 0}
        var str_ind$0=str_ind;
        for(;;)
         {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var match=caml_string_get(str,str_ind$0),switcher=match - 32 | 0;
          if(! (16 < switcher >>> 0))
           switch(switcher)
            {case 0:
              set_flag(str_ind$0,space);
              var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
              continue;
             case 3:
              set_flag(str_ind$0,hash);
              var str_ind$2=str_ind$0 + 1 | 0,str_ind$0=str_ind$2;
              continue;
             case 11:
              set_flag(str_ind$0,plus);
              var str_ind$3=str_ind$0 + 1 | 0,str_ind$0=str_ind$3;
              continue;
             case 13:
              set_flag(str_ind$0,minus);
              var str_ind$4=str_ind$0 + 1 | 0,str_ind$0=str_ind$4;
              continue;
             case 16:
              set_flag(str_ind$0,zero);
              var str_ind$5=str_ind$0 + 1 | 0,str_ind$0=str_ind$5;
              continue
             }
          var
           _pS_=space[1],
           _pT_=hash[1],
           _pU_=plus[1],
           _pV_=minus[1],
           _pW_=zero[1];
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           padty=
            _pW_
             ?_pV_
               ?legacy_behavior$0
                 ?0
                 :incompatible_flag(pct_ind,str_ind$0,45,cst_0)
               :2
             :_pV_?0:1,
           match$0=caml_string_get(str,str_ind$0);
          if(48 <= match$0)
           {if(! (58 <= match$0))
             {var
               match$1=parse_positive(str_ind$0,end_ind,0),
               width=match$1[2],
               new_ind=match$1[1];
              return parse_after_padding
                      (pct_ind,
                       new_ind,
                       end_ind,
                       _pV_,
                       _pU_,
                       _pT_,
                       _pS_,
                       ign,
                       [0,padty,width])}}
          else
           if(42 === match$0)
            return parse_after_padding
                    (pct_ind,
                     str_ind$0 + 1 | 0,
                     end_ind,
                     _pV_,
                     _pU_,
                     _pT_,
                     _pS_,
                     ign,
                     [1,padty]);
          switch(padty)
           {case 0:
             if(1 - legacy_behavior$0)
              invalid_format_without(str_ind$0 - 1 | 0,45,cst_padding);
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_pV_,_pU_,_pT_,_pS_,ign,0);
            case 1:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_pV_,_pU_,_pT_,_pS_,ign,0);
            default:
             return parse_after_padding
                     (pct_ind,str_ind$0,end_ind,_pV_,_pU_,_pT_,_pS_,ign,_aB_)}}}
      function parse_after_padding
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        var symb=caml_string_get(str,str_ind);
        if(46 === symb)
         {var str_ind$0=str_ind + 1 | 0;
          if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
          var
           parse_literal=
            function(minus,str_ind)
             {var
               match=parse_positive(str_ind,end_ind,0),
               prec=match[2],
               new_ind=match[1];
              return parse_after_precision
                      (pct_ind,
                       new_ind,
                       end_ind,
                       minus,
                       plus,
                       hash,
                       space,
                       ign,
                       pad,
                       [0,prec])},
           symb$0=caml_string_get(str,str_ind$0);
          if(48 <= symb$0)
           {if(! (58 <= symb$0))return parse_literal(minus,str_ind$0)}
          else
           if(42 <= symb$0)
            {var switcher=symb$0 - 42 | 0;
             switch(switcher)
              {case 0:
                return parse_after_precision
                        (pct_ind,
                         str_ind$0 + 1 | 0,
                         end_ind,
                         minus,
                         plus,
                         hash,
                         space,
                         ign,
                         pad,
                         1);
               case 1:
               case 3:
                if(legacy_behavior$0)
                 {var
                   _pR_=str_ind$0 + 1 | 0,
                   minus$0=minus || (45 === symb$0?1:0);
                  return parse_literal(minus$0,_pR_)}
                break
               }}
          return legacy_behavior$0
                  ?parse_after_precision
                    (pct_ind,
                     str_ind$0,
                     end_ind,
                     minus,
                     plus,
                     hash,
                     space,
                     ign,
                     pad,
                     _aC_)
                  :invalid_format_without(str_ind$0 - 1 | 0,46,cst_precision)}
        return parse_conversion
                (pct_ind,
                 str_ind + 1 | 0,
                 end_ind,
                 plus,
                 hash,
                 space,
                 ign,
                 pad,
                 0,
                 pad,
                 symb)}
      function parse_after_precision
       (pct_ind,str_ind,end_ind,minus,plus,hash,space,ign,pad,match)
       {if(str_ind === end_ind)unexpected_end_of_format(end_ind);
        function parse_conv(padprec)
         {return parse_conversion
                  (pct_ind,
                   str_ind + 1 | 0,
                   end_ind,
                   plus,
                   hash,
                   space,
                   ign,
                   pad,
                   match,
                   padprec,
                   caml_string_get(str,str_ind))}
        if(typeof pad === "number")
         {if(typeof match === "number" && ! match)return parse_conv(0);
          if(minus)
           {if(typeof match === "number")return parse_conv(_aD_);
            var n=match[1];
            return parse_conv([0,0,n])}
          if(typeof match === "number")return parse_conv(_aE_);
          var n$0=match[1];
          return parse_conv([0,1,n$0])}
        return parse_conv(pad)}
      function parse_conversion
       (pct_ind,str_ind,end_ind,plus,hash,space,ign,pad,prec,padprec,symb)
       {var
         plus_used=[0,0],
         hash_used=[0,0],
         space_used=[0,0],
         ign_used=[0,0],
         pad_used=[0,0],
         prec_used=[0,0];
        function get_plus(param){plus_used[1] = 1;return plus}
        function get_hash(param){hash_used[1] = 1;return hash}
        function get_space(param){space_used[1] = 1;return space}
        function get_ign(param){ign_used[1] = 1;return ign}
        function get_pad(param){pad_used[1] = 1;return pad}
        function get_prec(param){prec_used[1] = 1;return prec}
        function get_padprec(param){pad_used[1] = 1;return padprec}
        function get_int_pad(param)
         {var pad=get_pad(0),match=get_prec(0);
          if(typeof match === "number" && ! match)return pad;
          if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var n=pad[2];
                return legacy_behavior$0
                        ?[0,1,n]
                        :incompatible_flag(pct_ind,str_ind,48,cst_precision$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aF_
                      :incompatible_flag(pct_ind,str_ind,48,cst_precision$1)
                    :pad}}
        function check_no_0(symb,pad)
         {if(typeof pad === "number")
           return pad;
          else
           {if(0 === pad[0])
             {if(2 <= pad[1])
               {var width=pad[2];
                return legacy_behavior$0
                        ?[0,1,width]
                        :incompatible_flag(pct_ind,str_ind,symb,cst_0$0)}
              return pad}
            return 2 <= pad[1]
                    ?legacy_behavior$0
                      ?_aG_
                      :incompatible_flag(pct_ind,str_ind,symb,cst_0$1)
                    :pad}}
        function opt_of_pad(c,pad)
         {if(typeof pad === "number")
           return 0;
          else
           {if(0 === pad[0])
             switch(pad[1])
              {case 0:
                var width=pad[2];
                return legacy_behavior$0
                        ?[0,width]
                        :incompatible_flag(pct_ind,str_ind,c,cst$38);
               case 1:var width$0=pad[2];return [0,width$0];
               default:
                var width$1=pad[2];
                return legacy_behavior$0
                        ?[0,width$1]
                        :incompatible_flag(pct_ind,str_ind,c,cst_0$2)}
            return incompatible_flag(pct_ind,str_ind,c,cst$39)}}
        function get_pad_opt(c){return opt_of_pad(c,get_pad(0))}
        function get_padprec_opt(c){return opt_of_pad(c,get_padprec(0))}
        var switch$0=0;
        if(124 <= symb)
         switch$0 = 1;
        else
         switch(symb)
          {case 33:
            var
             match$6=parse(str_ind,end_ind),
             fmt_rest$5=match$6[1],
             fmt_result=[0,[10,fmt_rest$5]];
            break;
           case 40:
            var
             sub_end=search_subformat_end(str_ind,end_ind,41),
             match$8=parse(sub_end + 2 | 0,end_ind),
             fmt_rest$7=match$8[1],
             match$9=parse(str_ind,sub_end),
             sub_fmt=match$9[1],
             sub_fmtty=fmtty_of_fmt(sub_fmt);
            if(get_ign(0))
             var
              ignored$2=[9,get_pad_opt(95),sub_fmtty],
              _po_=[0,[23,ignored$2,fmt_rest$7]];
            else
             var _po_=[0,[14,get_pad_opt(40),sub_fmtty,fmt_rest$7]];
            var fmt_result=_po_;
            break;
           case 44:var fmt_result=parse(str_ind,end_ind);break;
           case 67:
            var
             match$12=parse(str_ind,end_ind),
             fmt_rest$10=match$12[1],
             _pq_=get_ign(0)?[0,[23,1,fmt_rest$10]]:[0,[1,fmt_rest$10]],
             fmt_result=_pq_;
            break;
           case 78:
            var
             match$16=parse(str_ind,end_ind),
             fmt_rest$14=match$16[1],
             counter$0=2;
            if(get_ign(0))
             var ignored$6=[11,counter$0],_pw_=[0,[23,ignored$6,fmt_rest$14]];
            else
             var _pw_=[0,[21,counter$0,fmt_rest$14]];
            var fmt_result=_pw_;
            break;
           case 83:
            var
             pad$6=check_no_0(symb,get_padprec(0)),
             match$17=parse(str_ind,end_ind),
             fmt_rest$15=match$17[1];
            if(get_ign(0))
             var
              ignored$7=[1,get_padprec_opt(95)],
              _px_=[0,[23,ignored$7,fmt_rest$15]];
            else
             var
              match$18=make_padding_fmt_ebb(pad$6,fmt_rest$15),
              fmt_rest$16=match$18[2],
              pad$7=match$18[1],
              _px_=[0,[3,pad$7,fmt_rest$16]];
            var fmt_result=_px_;
            break;
           case 91:
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var
             char_set=create_char_set(0),
             add_char=function(c){return add_in_char_set(char_set,c)},
             add_range=
              function(c$0,c)
               {if(! (c < c$0))
                 {var i=c$0;
                  for(;;)
                   {add_in_char_set(char_set,char_of_int(i));
                    var _pQ_=i + 1 | 0;
                    if(c !== i){var i=_pQ_;continue}
                    break}}
                return 0},
             fail_single_percent=
              function(str_ind)
               {return caml_call2(failwith_message(_aP_),str,str_ind)},
             parse_char_set_content=
              function(counter,str_ind,end_ind)
               {var str_ind$0=str_ind;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c=caml_string_get(str,str_ind$0);
                  if(45 === c)
                   {add_char(45);
                    var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1;
                    continue}
                  if(93 === c)return str_ind$0 + 1 | 0;
                  var _pP_=str_ind$0 + 1 | 0;
                  if(counter < 50)
                   {var counter$0=counter + 1 | 0;
                    return parse_char_set_after_char$0(counter$0,_pP_,end_ind,c)}
                  return caml_trampoline_return
                          (parse_char_set_after_char$0,[0,_pP_,end_ind,c])}},
             parse_char_set_after_char$0=
              function(counter,str_ind,end_ind,c)
               {var str_ind$0=str_ind,c$0=c;
                for(;;)
                 {if(str_ind$0 === end_ind)unexpected_end_of_format(end_ind);
                  var c$1=caml_string_get(str,str_ind$0),switch$0=0;
                  if(46 <= c$1)
                   {if(64 === c$1)
                     switch$0 = 1;
                    else
                     if(93 === c$1){add_char(c$0);return str_ind$0 + 1 | 0}}
                  else
                   if(37 === c$1)
                    switch$0 = 1;
                   else
                    if(45 <= c$1)
                     {var str_ind$2=str_ind$0 + 1 | 0;
                      if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
                      var c$2=caml_string_get(str,str_ind$2);
                      if(37 === c$2)
                       {if((str_ind$2 + 1 | 0) === end_ind)
                         unexpected_end_of_format(end_ind);
                        var c$3=caml_string_get(str,str_ind$2 + 1 | 0);
                        if(37 !== c$3 && 64 !== c$3)
                         return fail_single_percent(str_ind$2);
                        add_range(c$0,c$3);
                        var _pN_=str_ind$2 + 2 | 0;
                        if(counter < 50)
                         {var counter$2=counter + 1 | 0;
                          return parse_char_set_content(counter$2,_pN_,end_ind)}
                        return caml_trampoline_return
                                (parse_char_set_content,[0,_pN_,end_ind])}
                      if(93 === c$2)
                       {add_char(c$0);add_char(45);return str_ind$2 + 1 | 0}
                      add_range(c$0,c$2);
                      var _pO_=str_ind$2 + 1 | 0;
                      if(counter < 50)
                       {var counter$1=counter + 1 | 0;
                        return parse_char_set_content(counter$1,_pO_,end_ind)}
                      return caml_trampoline_return
                              (parse_char_set_content,[0,_pO_,end_ind])}
                  if(switch$0 && 37 === c$0)
                   {add_char(c$1);
                    var _pM_=str_ind$0 + 1 | 0;
                    if(counter < 50)
                     {var counter$0=counter + 1 | 0;
                      return parse_char_set_content(counter$0,_pM_,end_ind)}
                    return caml_trampoline_return
                            (parse_char_set_content,[0,_pM_,end_ind])}
                  if(37 === c$0)fail_single_percent(str_ind$0);
                  add_char(c$0);
                  var str_ind$1=str_ind$0 + 1 | 0,str_ind$0=str_ind$1,c$0=c$1;
                  continue}},
             parse_char_set_after_char=
              function(str_ind,end_ind,c)
               {return caml_trampoline
                        (parse_char_set_after_char$0(0,str_ind,end_ind,c))};
            if(str_ind === end_ind)unexpected_end_of_format(end_ind);
            var match$31=caml_string_get(str,str_ind);
            if(94 === match$31)
             var str_ind$0=str_ind + 1 | 0,reverse=1,str_ind$1=str_ind$0;
            else
             var reverse=0,str_ind$1=str_ind;
            if(str_ind$1 === end_ind)unexpected_end_of_format(end_ind);
            var
             c=caml_string_get(str,str_ind$1),
             next_ind=parse_char_set_after_char(str_ind$1 + 1 | 0,end_ind,c),
             char_set$0=freeze_char_set(char_set),
             char_set$1=reverse?rev_char_set(char_set$0):char_set$0,
             match$21=parse(next_ind,end_ind),
             fmt_rest$19=match$21[1];
            if(get_ign(0))
             var
              ignored$9=[10,get_pad_opt(95),char_set$1],
              _pC_=[0,[23,ignored$9,fmt_rest$19]];
            else
             var _pC_=[0,[20,get_pad_opt(91),char_set$1,fmt_rest$19]];
            var fmt_result=_pC_;
            break;
           case 97:
            var
             match$22=parse(str_ind,end_ind),
             fmt_rest$20=match$22[1],
             fmt_result=[0,[15,fmt_rest$20]];
            break;
           case 99:
            var
             char_format=
              function(fmt_rest)
               {return get_ign(0)?[0,[23,0,fmt_rest]]:[0,[0,fmt_rest]]},
             match$23=parse(str_ind,end_ind),
             fmt_rest$21=match$23[1],
             match$24=get_pad_opt(99);
            if(match$24)
             {if(0 === match$24[1])
               var
                _pD_=get_ign(0)?[0,[23,3,fmt_rest$21]]:[0,[22,fmt_rest$21]],
                _pE_=_pD_;
              else
               var
                _pE_=
                 legacy_behavior$0
                  ?char_format(fmt_rest$21)
                  :invalid_format_message
                    (str_ind,cst_non_zero_widths_are_unsupp);
              var _pF_=_pE_}
            else
             var _pF_=char_format(fmt_rest$21);
            var fmt_result=_pF_;
            break;
           case 114:
            var
             match$25=parse(str_ind,end_ind),
             fmt_rest$22=match$25[1],
             _pG_=get_ign(0)?[0,[23,2,fmt_rest$22]]:[0,[19,fmt_rest$22]],
             fmt_result=_pG_;
            break;
           case 115:
            var
             pad$9=check_no_0(symb,get_padprec(0)),
             match$26=parse(str_ind,end_ind),
             fmt_rest$23=match$26[1];
            if(get_ign(0))
             var
              ignored$10=[0,get_padprec_opt(95)],
              _pH_=[0,[23,ignored$10,fmt_rest$23]];
            else
             var
              match$27=make_padding_fmt_ebb(pad$9,fmt_rest$23),
              fmt_rest$24=match$27[2],
              pad$10=match$27[1],
              _pH_=[0,[2,pad$10,fmt_rest$24]];
            var fmt_result=_pH_;
            break;
           case 116:
            var
             match$28=parse(str_ind,end_ind),
             fmt_rest$25=match$28[1],
             fmt_result=[0,[16,fmt_rest$25]];
            break;
           case 123:
            var
             sub_end$0=search_subformat_end(str_ind,end_ind,125),
             match$29=parse(str_ind,sub_end$0),
             sub_fmt$0=match$29[1],
             match$30=parse(sub_end$0 + 2 | 0,end_ind),
             fmt_rest$26=match$30[1],
             sub_fmtty$0=fmtty_of_fmt(sub_fmt$0);
            if(get_ign(0))
             var
              ignored$11=[8,get_pad_opt(95),sub_fmtty$0],
              _pI_=[0,[23,ignored$11,fmt_rest$26]];
            else
             var _pI_=[0,[13,get_pad_opt(123),sub_fmtty$0,fmt_rest$26]];
            var fmt_result=_pI_;
            break;
           case 66:
           case 98:
            var
             pad$3=check_no_0(symb,get_padprec(0)),
             match$10=parse(str_ind,end_ind),
             fmt_rest$8=match$10[1];
            if(get_ign(0))
             var
              ignored$3=[7,get_padprec_opt(95)],
              _pp_=[0,[23,ignored$3,fmt_rest$8]];
            else
             var
              match$11=make_padding_fmt_ebb(pad$3,fmt_rest$8),
              fmt_rest$9=match$11[2],
              pad$4=match$11[1],
              _pp_=[0,[9,pad$4,fmt_rest$9]];
            var fmt_result=_pp_;
            break;
           case 37:
           case 64:
            var
             match$7=parse(str_ind,end_ind),
             fmt_rest$6=match$7[1],
             fmt_result=[0,[12,symb,fmt_rest$6]];
            break;
           case 76:
           case 108:
           case 110:
            var switch$1=0;
            if(str_ind !== end_ind)
             {var
               symb$0=caml_string_get(str,str_ind),
               _pJ_=symb$0 - 88 | 0,
               switch$2=0;
              if(! (32 < _pJ_ >>> 0))
               switch(_pJ_)
                {case 0:
                 case 12:
                 case 17:
                 case 23:
                 case 29:
                 case 32:var _pv_=1;switch$2 = 1;break
                 }
              if(! switch$2)var _pv_=0;
              if(_pv_){switch$0 = 1;switch$1 = 1}}
            if(! switch$1)
             {var
               match$15=parse(str_ind,end_ind),
               fmt_rest$13=match$15[1],
               switch$3=0;
              if(108 <= symb)
               {if(! (111 <= symb))
                 {var switcher$0=symb - 108 | 0;
                  switch(switcher$0)
                   {case 0:var counter=0;switch$3 = 1;break;
                    case 1:break;
                    default:var counter=1;switch$3 = 1}}}
              else
               if(76 === symb){var counter=2;switch$3 = 1}
              if(! switch$3)throw [0,Assert_failure,_aT_];
              if(get_ign(0))
               var ignored$5=[11,counter],_pu_=[0,[23,ignored$5,fmt_rest$13]];
              else
               var _pu_=[0,[21,counter,fmt_rest$13]];
              var fmt_result=_pu_}
            break;
           case 32:
           case 35:
           case 43:
           case 45:
           case 95:
            var
             fmt_result=
              caml_call3(failwith_message(_aK_),str,pct_ind,symb);
            break;
           case 88:
           case 100:
           case 105:
           case 111:
           case 117:
           case 120:
            var
             _py_=get_space(0),
             _pz_=get_hash(0),
             iconv$2=
              compute_int_conv(pct_ind,str_ind,get_plus(0),_pz_,_py_,symb),
             match$19=parse(str_ind,end_ind),
             fmt_rest$17=match$19[1];
            if(get_ign(0))
             var
              ignored$8=[2,iconv$2,get_pad_opt(95)],
              _pA_=[0,[23,ignored$8,fmt_rest$17]];
            else
             var
              _pB_=get_prec(0),
              match$20=make_padprec_fmt_ebb(get_int_pad(0),_pB_,fmt_rest$17),
              fmt_rest$18=match$20[3],
              prec$4=match$20[2],
              pad$8=match$20[1],
              _pA_=[0,[4,iconv$2,pad$8,prec$4,fmt_rest$18]];
            var fmt_result=_pA_;
            break;
           case 69:
           case 70:
           case 71:
           case 72:
           case 101:
           case 102:
           case 103:
           case 104:
            var
             space$1=get_space(0),
             hash$1=get_hash(0),
             plus$2=get_plus(0),
             flag=
              plus$2
               ?space$1
                 ?legacy_behavior$0
                   ?1
                   :incompatible_flag(pct_ind,str_ind,32,cst$50)
                 :1
               :space$1?2:0,
             switch$4=0;
            if(73 <= symb)
             {var switcher$1=symb - 101 | 0;
              if(3 < switcher$1 >>> 0)
               switch$4 = 1;
              else
               {switch(switcher$1)
                 {case 0:var _pK_=1;break;
                  case 1:var _pK_=0;break;
                  case 2:var _pK_=3;break;
                  default:var _pK_=6}
                var kind=_pK_}}
            else
             if(69 <= symb)
              {var switcher$2=symb - 69 | 0,switch$5=0;
               switch(switcher$2)
                {case 0:var _pL_=2;break;
                 case 1:switch$4 = 1;switch$5 = 1;break;
                 case 2:var _pL_=4;break;
                 default:var _pL_=7}
               if(! switch$5)var kind=_pL_}
             else
              switch$4 = 1;
            if(switch$4)
             {var switch$6=0;
              if(hash$1)
               if(70 === symb)var kind=8;else switch$6 = 1;
              else
               if(70 === symb)var kind=5;else switch$6 = 1;
              if(switch$6)throw [0,Assert_failure,_aV_]}
            var
             fconv=[0,flag,kind],
             match$13=parse(str_ind,end_ind),
             fmt_rest$11=match$13[1];
            if(get_ign(0))
             {var match=get_prec(0);
              if(typeof match === "number")
               var _pr_=match?incompatible_flag(pct_ind,str_ind,95,cst$40):0;
              else
               var ndec=match[1],_pr_=[0,ndec];
              var
               ignored$4=[6,get_pad_opt(95),_pr_],
               _ps_=[0,[23,ignored$4,fmt_rest$11]]}
            else
             var
              _pt_=get_prec(0),
              match$14=make_padprec_fmt_ebb(get_pad(0),_pt_,fmt_rest$11),
              fmt_rest$12=match$14[3],
              prec$3=match$14[2],
              pad$5=match$14[1],
              _ps_=[0,[8,fconv,pad$5,prec$3,fmt_rest$12]];
            var fmt_result=_ps_;
            break;
           default:switch$0 = 1}
        if(switch$0)
         {var switch$7=0;
          if(108 <= symb)
           if(111 <= symb)
            switch$7 = 1;
           else
            {var switcher=symb - 108 | 0,switch$8=0;
             switch(switcher)
              {case 0:
                var
                 _o__=caml_string_get(str,str_ind),
                 _o$_=get_space(0),
                 _pa_=get_hash(0),
                 iconv=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pa_,_o$_,_o__),
                 match$0=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest=match$0[1];
                if(get_ign(0))
                 var
                  ignored=[3,iconv,get_pad_opt(95)],
                  _pb_=[0,[23,ignored,fmt_rest]];
                else
                 var
                  _pd_=get_prec(0),
                  match$1=make_padprec_fmt_ebb(get_int_pad(0),_pd_,fmt_rest),
                  fmt_rest$0=match$1[3],
                  prec$0=match$1[2],
                  pad$0=match$1[1],
                  _pb_=[0,[5,iconv,pad$0,prec$0,fmt_rest$0]];
                var _pc_=_pb_;
                break;
               case 1:switch$7 = 1;switch$8 = 1;break;
               default:
                var
                 _pe_=caml_string_get(str,str_ind),
                 _pf_=get_space(0),
                 _pg_=get_hash(0),
                 iconv$0=
                  compute_int_conv
                   (pct_ind,str_ind + 1 | 0,get_plus(0),_pg_,_pf_,_pe_),
                 match$2=parse(str_ind + 1 | 0,end_ind),
                 fmt_rest$1=match$2[1];
                if(get_ign(0))
                 var
                  ignored$0=[4,iconv$0,get_pad_opt(95)],
                  _ph_=[0,[23,ignored$0,fmt_rest$1]];
                else
                 var
                  _pi_=get_prec(0),
                  match$3=make_padprec_fmt_ebb(get_int_pad(0),_pi_,fmt_rest$1),
                  fmt_rest$2=match$3[3],
                  prec$1=match$3[2],
                  pad$1=match$3[1],
                  _ph_=[0,[6,iconv$0,pad$1,prec$1,fmt_rest$2]];
                var _pc_=_ph_}
             if(! switch$8)var fmt_result=_pc_}
          else
           if(76 === symb)
            {var
              _pj_=caml_string_get(str,str_ind),
              _pk_=get_space(0),
              _pl_=get_hash(0),
              iconv$1=
               compute_int_conv
                (pct_ind,str_ind + 1 | 0,get_plus(0),_pl_,_pk_,_pj_),
              match$4=parse(str_ind + 1 | 0,end_ind),
              fmt_rest$3=match$4[1];
             if(get_ign(0))
              var
               ignored$1=[5,iconv$1,get_pad_opt(95)],
               _pm_=[0,[23,ignored$1,fmt_rest$3]];
             else
              var
               _pn_=get_prec(0),
               match$5=make_padprec_fmt_ebb(get_int_pad(0),_pn_,fmt_rest$3),
               fmt_rest$4=match$5[3],
               prec$2=match$5[2],
               pad$2=match$5[1],
               _pm_=[0,[7,iconv$1,pad$2,prec$2,fmt_rest$4]];
             var fmt_result=_pm_}
           else
            switch$7 = 1;
          if(switch$7)
           var
            fmt_result=
             caml_call3(failwith_message(_aH_),str,str_ind - 1 | 0,symb)}
        if(1 - legacy_behavior$0)
         {var _o1_=1 - plus_used[1],plus$0=_o1_?plus:_o1_;
          if(plus$0)incompatible_flag(pct_ind,str_ind,symb,cst$41);
          var _o2_=1 - hash_used[1],hash$0=_o2_?hash:_o2_;
          if(hash$0)incompatible_flag(pct_ind,str_ind,symb,cst$42);
          var _o3_=1 - space_used[1],space$0=_o3_?space:_o3_;
          if(space$0)incompatible_flag(pct_ind,str_ind,symb,cst$43);
          var _o4_=1 - pad_used[1],_o5_=_o4_?caml_notequal([0,pad],_aI_):_o4_;
          if(_o5_)incompatible_flag(pct_ind,str_ind,symb,cst_padding$0);
          var
           _o6_=1 - prec_used[1],
           _o7_=_o6_?caml_notequal([0,prec],_aJ_):_o6_;
          if(_o7_)
           {var _o8_=ign?95:symb;
            incompatible_flag(pct_ind,str_ind,_o8_,cst_precision$2)}
          var plus$1=ign?plus:ign;
          if(plus$1)incompatible_flag(pct_ind,str_ind,95,cst$44)}
        var _o9_=1 - ign_used[1],ign$0=_o9_?ign:_o9_;
        if(ign$0)
         {var switch$9=0;
          if(38 <= symb)
           {if(44 !== symb && 64 !== symb)switch$9 = 1}
          else
           if(33 !== symb && ! (37 <= symb))switch$9 = 1;
          var switch$10=0;
          if(switch$9 || ! legacy_behavior$0)switch$10 = 1;
          if(switch$10)incompatible_flag(pct_ind,str_ind,symb,cst$45)}
        return fmt_result}
      function parse(lit_start,end_ind)
       {var str_ind=lit_start;
        for(;;)
         {if(str_ind === end_ind)return add_literal(lit_start,str_ind,0);
          var match=caml_string_get(str,str_ind);
          if(37 === match)
           {var str_ind$2=str_ind + 1 | 0;
            if(str_ind$2 === end_ind)unexpected_end_of_format(end_ind);
            var
             match$1=caml_string_get(str,str_ind$2),
             _o0_=
              95 === match$1
               ?parse_flags(str_ind,str_ind$2 + 1 | 0,end_ind,1)
               :parse_flags(str_ind,str_ind$2,end_ind,0),
             fmt_rest=_o0_[1];
            return add_literal(lit_start,str_ind,fmt_rest)}
          if(64 === match)
           {var str_ind$0=str_ind + 1 | 0;
            if(str_ind$0 === end_ind)
             var match$0=_aL_;
            else
             {var c=caml_string_get(str,str_ind$0),switch$0=0;
              if(65 <= c)
               if(94 <= c)
                {var switcher=c - 123 | 0;
                 if(2 < switcher >>> 0)
                  switch$0 = 1;
                 else
                  switch(switcher)
                   {case 0:
                     var match$0=parse_tag(1,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$3=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$2=match$3[1],
                      match$0=[0,[17,1,fmt_rest$2]]}}
               else
                if(91 <= c)
                 {var switcher$0=c - 91 | 0;
                  switch(switcher$0)
                   {case 0:
                     var match$0=parse_tag(0,str_ind$0 + 1 | 0,end_ind);break;
                    case 1:switch$0 = 1;break;
                    default:
                     var
                      match$4=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$3=match$4[1],
                      match$0=[0,[17,0,fmt_rest$3]]}}
                else
                 switch$0 = 1;
              else
               if(10 === c)
                var
                 match$5=parse(str_ind$0 + 1 | 0,end_ind),
                 fmt_rest$4=match$5[1],
                 match$0=[0,[17,3,fmt_rest$4]];
               else
                if(32 <= c)
                 {var switcher$1=c - 32 | 0;
                  switch(switcher$1)
                   {case 0:
                     var
                      match$6=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$5=match$6[1],
                      match$0=[0,[17,_aM_,fmt_rest$5]];
                     break;
                    case 5:
                     var switch$1=0;
                     if
                      ((str_ind$0 + 1 | 0)
                       <
                       end_ind
                       &&
                       37
                       ===
                       caml_string_get(str,str_ind$0 + 1 | 0))
                      {var
                        match$7=parse(str_ind$0 + 2 | 0,end_ind),
                        fmt_rest$6=match$7[1],
                        match$0=[0,[17,6,fmt_rest$6]];
                       switch$1 = 1}
                     if(! switch$1)
                      var
                       match$8=parse(str_ind$0,end_ind),
                       fmt_rest$7=match$8[1],
                       match$0=[0,[12,64,fmt_rest$7]];
                     break;
                    case 12:
                     var
                      match$9=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$8=match$9[1],
                      match$0=[0,[17,_aN_,fmt_rest$8]];
                     break;
                    case 14:
                     var
                      match$10=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$9=match$10[1],
                      match$0=[0,[17,4,fmt_rest$9]];
                     break;
                    case 27:
                     var match$0=parse_good_break(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 28:
                     var match$0=parse_magic_size(str_ind$0 + 1 | 0,end_ind);
                     break;
                    case 31:
                     var
                      match$11=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$10=match$11[1],
                      match$0=[0,[17,2,fmt_rest$10]];
                     break;
                    case 32:
                     var
                      match$12=parse(str_ind$0 + 1 | 0,end_ind),
                      fmt_rest$11=match$12[1],
                      match$0=[0,[17,5,fmt_rest$11]];
                     break;
                    default:switch$0 = 1}}
                else
                 switch$0 = 1;
              if(switch$0)
               var
                match$2=parse(str_ind$0 + 1 | 0,end_ind),
                fmt_rest$1=match$2[1],
                match$0=[0,[17,[2,c],fmt_rest$1]]}
            var fmt_rest$0=match$0[1];
            return add_literal(lit_start,str_ind,fmt_rest$0)}
          var str_ind$1=str_ind + 1 | 0,str_ind=str_ind$1;
          continue}}
      return parse(0,caml_ml_string_length(str))}
    function format_of_string_fmtty(str,fmtty)
     {var match=fmt_ebb_of_string(0,str),fmt=match[1];
      try
       {var _oY_=[0,type_format(fmt,fmtty),str];return _oY_}
      catch(_oZ_)
       {_oZ_ = caml_wrap_exception(_oZ_);
        if(_oZ_ === Type_mismatch)
         {var _oX_=string_of_fmtty(fmtty);
          return caml_call2(failwith_message(_aX_),str,_oX_)}
        throw _oZ_}}
    function format_of_string_format(str,param)
     {var
       str$0=param[2],
       fmt=param[1],
       match=fmt_ebb_of_string(0,str),
       fmt$0=match[1];
      try
       {var _oV_=[0,type_format(fmt$0,fmtty_of_fmt(fmt)),str];return _oV_}
      catch(_oW_)
       {_oW_ = caml_wrap_exception(_oW_);
        if(_oW_ === Type_mismatch)
         return caml_call2(failwith_message(_aY_),str,str$0);
        throw _oW_}}
    var
     CamlinternalFormat=
      [0,
       is_in_char_set,
       rev_char_set,
       create_char_set,
       add_in_char_set,
       freeze_char_set,
       param_format_of_ignored_format,
       make_printf,
       make_iprintf,
       output_acc,
       bufput_acc,
       strput_acc,
       type_format,
       fmt_ebb_of_string,
       format_of_string_fmtty,
       format_of_string_format,
       char_of_iconv,
       string_of_formatting_lit,
       string_of_fmtty,
       string_of_fmt,
       open_box_of_string,
       symm,
       trans,
       recast];
    caml_register_global(784,CamlinternalFormat,"CamlinternalFormat");
    function kfprintf(k,o,param)
     {var fmt=param[1],_oU_=0;
      return make_printf
              (function(acc){output_acc(o,acc);return caml_call1(k,o)},
               _oU_,
               fmt)}
    function kbprintf(k,b,param)
     {var fmt=param[1],_oT_=0;
      return make_printf
              (function(acc){bufput_acc(b,acc);return caml_call1(k,b)},
               _oT_,
               fmt)}
    function ikfprintf(k,oc,param)
     {var fmt=param[1];return make_iprintf(k,oc,fmt)}
    function fprintf(oc,fmt){return kfprintf(function(_oS_){return 0},oc,fmt)}
    function bprintf(b,fmt){return kbprintf(function(_oR_){return 0},b,fmt)}
    function ifprintf(oc,fmt)
     {return ikfprintf(function(_oQ_){return 0},oc,fmt)}
    function ibprintf(b,fmt){return ikfprintf(function(_oP_){return 0},b,fmt)}
    function printf(fmt){return fprintf(stdout,fmt)}
    function eprintf(fmt){return fprintf(stderr,fmt)}
    function ksprintf(k,param)
     {var fmt=param[1];
      function k$0(acc)
       {var buf=create$2(64);
        strput_acc(buf,acc);
        return caml_call1(k,contents(buf))}
      return make_printf(k$0,0,fmt)}
    function sprintf(fmt){return ksprintf(function(s){return s},fmt)}
    var
     Stdlib_printf=
      [0,
       fprintf,
       printf,
       eprintf,
       sprintf,
       bprintf,
       ifprintf,
       ibprintf,
       kfprintf,
       ikfprintf,
       ksprintf,
       kbprintf,
       ikfprintf,
       ksprintf];
    caml_register_global(785,Stdlib_printf,"Stdlib__printf");
    var
     Bad=[248,cst_Stdlib_Arg_Bad,caml_fresh_oo_id(0)],
     Help=[248,cst_Stdlib_Arg_Help,caml_fresh_oo_id(0)],
     Stop=[248,cst_Stdlib_Arg_Stop,caml_fresh_oo_id(0)];
    function assoc3(x,l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var match=l$0[1],y2=match[2],y1=match[1];
          if(caml_equal(y1,x))return y2;
          var l$1=l$0[2],l$0=l$1;
          continue}
        throw Not_found}}
    function split$0(s)
     {var
       i=index$0(s,61),
       len=caml_ml_string_length(s),
       _oO_=sub$0(s,i + 1 | 0,len - (i + 1 | 0) | 0);
      return [0,sub$0(s,0,i),_oO_]}
    function make_symlist(prefix,sep,suffix,l)
     {if(l)
       {var t=l[2],h=l[1],_oN_=symbol(prefix,h);
        return symbol
                (fold_left$0
                  (function(x,y){return symbol(x,symbol(sep,y))},_oN_,t),
                 suffix)}
      return cst_none}
    function help_action(param){throw [0,Stop,_a1_]}
    function add_help(speclist)
     {try
       {assoc3(cst_help$2,speclist);var _oK_=0,_oI_=_oK_}
      catch(_oM_)
       {_oM_ = caml_wrap_exception(_oM_);
        if(_oM_ !== Not_found)throw _oM_;
        var
         _oI_=
          [0,[0,cst_help,[0,help_action],cst_Display_this_list_of_optio],0]}
      try
       {assoc3(cst_help$1,speclist);var _oJ_=0,add2=_oJ_}
      catch(_oL_)
       {_oL_ = caml_wrap_exception(_oL_);
        if(_oL_ !== Not_found)throw _oL_;
        var
         add2=
          [0,
           [0,cst_help$0,[0,help_action],cst_Display_this_list_of_optio$0],
           0]}
      return append(speclist,append(_oI_,add2))}
    function usage_b(buf,speclist,errmsg)
     {caml_call1(bprintf(buf,_a2_),errmsg);
      var _oF_=add_help(speclist);
      return iter$2
              (function(param)
                {var
                  doc=param[3],
                  spec=param[2],
                  key=param[1],
                  _oG_=0 < caml_ml_string_length(doc)?1:0;
                 if(_oG_)
                  {if(11 === spec[0])
                    {var l=spec[1],_oH_=make_symlist(cst$53,cst$52,cst$51,l);
                     return caml_call3(bprintf(buf,_a0_),key,_oH_,doc)}
                   return caml_call2(bprintf(buf,_aZ_),key,doc)}
                 return _oG_},
               _oF_)}
    function usage_string(speclist,errmsg)
     {var b=create$2(200);usage_b(b,speclist,errmsg);return contents(b)}
    function usage(speclist,errmsg)
     {var _oE_=usage_string(speclist,errmsg);
      return caml_call1(eprintf(_a3_),_oE_)}
    var current=[0,0];
    function bool_of_string_opt$0(x)
     {try
       {var _oC_=[0,bool_of_string(x)];return _oC_}
      catch(_oD_)
       {_oD_ = caml_wrap_exception(_oD_);
        if(_oD_[1] === Invalid_argument)return 0;
        throw _oD_}}
    function int_of_string_opt$0(x)
     {try
       {var _oA_=[0,caml_int_of_string(x)];return _oA_}
      catch(_oB_)
       {_oB_ = caml_wrap_exception(_oB_);
        if(_oB_[1] === Failure)return 0;
        throw _oB_}}
    function float_of_string_opt(x)
     {try
       {var _oy_=[0,caml_float_of_string(x)];return _oy_}
      catch(_oz_)
       {_oz_ = caml_wrap_exception(_oz_);
        if(_oz_[1] === Failure)return 0;
        throw _oz_}}
    function parse_and_expand_argv_dynamic_
     (allow_expand,current,argv,speclist,anonfun,errmsg)
     {var initpos=current[1];
      function convert_error(error)
       {var
         b=create$2(200),
         progname=
          initpos < argv[1].length - 1
           ?caml_check_bound(argv[1],initpos)[1 + initpos]
           :cst$54;
        switch(error[0])
         {case 0:
           var _ox_=error[1];
           if
            (caml_string_notequal(_ox_,cst_help$3)
             &&
             caml_string_notequal(_ox_,cst_help$4))
            caml_call2(bprintf(b,_a4_),progname,_ox_);
           break;
          case 1:
           var expected=error[3],arg=error[2],opt=error[1];
           caml_call4(bprintf(b,_a7_),progname,arg,opt,expected);
           break;
          case 2:var s=error[1];caml_call2(bprintf(b,_a8_),progname,s);break;
          default:var s$0=error[1];caml_call2(bprintf(b,_a9_),progname,s$0)}
        usage_b(b,speclist[1],errmsg);
        if(! caml_equal(error,_a5_) && ! caml_equal(error,_a6_))
         return [0,Bad,contents(b)];
        return [0,Help,contents(b)]}
      current[1]++;
      for(;;)
       {if(current[1] < argv[1].length - 1)
         {try
           {var
             _oo_=current[1],
             s=caml_check_bound(argv[1],_oo_)[1 + _oo_],
             switch$0=0;
            if(1 <= caml_ml_string_length(s) && 45 === caml_string_get(s,0))
             {try
               {var
                 follow$1=0,
                 _oq_=assoc3(s,speclist[1]),
                 follow$0=follow$1,
                 action=_oq_}
              catch(_ov_)
               {_ov_ = caml_wrap_exception(_ov_);
                if(_ov_ !== Not_found)throw _ov_;
                try
                 {var
                   match=split$0(s),
                   arg=match[2],
                   keyword=match[1],
                   follow=[0,arg],
                   _op_=assoc3(keyword,speclist[1])}
                catch(_ow_)
                 {_ow_ = caml_wrap_exception(_ow_);
                  if(_ow_ === Not_found)throw [0,Stop,[0,s]];
                  throw _ow_;
                  var _or_=_ow_}
                var follow$0=follow,action=_op_,_os_=_ov_}
              var
               no_arg$0=
                function(s,follow)
                 {function no_arg(param)
                   {if(follow)
                     {var arg=follow[1];throw [0,Stop,[1,s,arg,cst_no_argument]]}
                    return 0}
                  return no_arg},
               no_arg=no_arg$0(s,follow$0),
               get_arg$0=
                function(s,follow)
                 {function get_arg(param)
                   {if(follow){var arg=follow[1];return arg}
                    if((current[1] + 1 | 0) < argv[1].length - 1)
                     {var _ou_=current[1] + 1 | 0;
                      return caml_check_bound(argv[1],_ou_)[1 + _ou_]}
                    throw [0,Stop,[2,s]]}
                  return get_arg},
               get_arg=get_arg$0(s,follow$0),
               consume_arg$0=
                function(follow)
                 {function consume_arg(param)
                   {return follow?0:(current[1]++,0)}
                  return consume_arg},
               consume_arg=consume_arg$0(follow$0),
               treat_action$0=
                function(s,no_arg,get_arg,consume_arg)
                 {function treat_action(param)
                   {switch(param[0])
                     {case 0:var f=param[1];no_arg(0);return caml_call1(f,0);
                      case 1:
                       var
                        f$0=param[1],
                        arg=get_arg(0),
                        match=bool_of_string_opt$0(arg);
                       if(match)
                        {var s$0=match[1];caml_call1(f$0,s$0);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg,cst_a_boolean]];
                      case 2:var r=param[1];no_arg(0);r[1] = 1;return 0;
                      case 3:var r$0=param[1];no_arg(0);r$0[1] = 0;return 0;
                      case 4:
                       var f$1=param[1],arg$0=get_arg(0);
                       caml_call1(f$1,arg$0);
                       return consume_arg(0);
                      case 5:
                       var r$1=param[1];r$1[1] = get_arg(0);return consume_arg(0);
                      case 6:
                       var
                        f$2=param[1],
                        arg$1=get_arg(0),
                        match$0=int_of_string_opt$0(arg$1);
                       if(match$0)
                        {var x=match$0[1];caml_call1(f$2,x);return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$1,cst_an_integer]];
                      case 7:
                       var
                        r$2=param[1],
                        arg$2=get_arg(0),
                        match$1=int_of_string_opt$0(arg$2);
                       if(match$1)
                        {var x$0=match$1[1];r$2[1] = x$0;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$2,cst_an_integer$0]];
                      case 8:
                       var
                        f$3=param[1],
                        arg$3=get_arg(0),
                        match$2=float_of_string_opt(arg$3);
                       if(match$2)
                        {var x$1=match$2[1];
                         caml_call1(f$3,x$1);
                         return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$3,cst_a_float]];
                      case 9:
                       var
                        r$3=param[1],
                        arg$4=get_arg(0),
                        match$3=float_of_string_opt(arg$4);
                       if(match$3)
                        {var x$2=match$3[1];r$3[1] = x$2;return consume_arg(0)}
                       throw [0,Stop,[1,s,arg$4,cst_a_float$0]];
                      case 10:
                       var specs=param[1];
                       no_arg(0);
                       return iter$2(treat_action,specs);
                      case 11:
                       var f$4=param[2],symb=param[1],arg$5=get_arg(0);
                       if(mem(arg$5,symb))
                        {caml_call1(f$4,arg$5);return consume_arg(0)}
                       throw [0,
                              Stop,
                              [1,
                               s,
                               arg$5,
                               symbol(cst_one_of,make_symlist(cst$57,cst$56,cst$55,symb))]];
                      case 12:
                       var f$5=param[1];
                       no_arg(0);
                       for(;;)
                        {if(current[1] < (argv[1].length - 1 - 1 | 0))
                          {var _ot_=current[1] + 1 | 0;
                           caml_call1(f$5,caml_check_bound(argv[1],_ot_)[1 + _ot_]);
                           consume_arg(0);
                           continue}
                         return 0}
                      default:
                       var f$6=param[1];
                       if(1 - allow_expand)
                        throw [0,Invalid_argument,cst_Arg_Expand_is_is_only_allo];
                       var arg$6=get_arg(0),newarg=caml_call1(f$6,arg$6);
                       consume_arg(0);
                       var
                        before=sub$1(argv[1],0,current[1] + 1 | 0),
                        after=
                         sub$1
                          (argv[1],
                           current[1] + 1 | 0,
                           (argv[1].length - 1 - current[1] | 0) - 1 | 0);
                       argv[1]
                       =
                       caml_array_concat([0,before,[0,newarg,[0,after,0]]]);
                       return 0}}
                  return treat_action},
               treat_action=treat_action$0(s,no_arg,get_arg,consume_arg);
              treat_action(action);
              switch$0 = 1}
            if(! switch$0)caml_call1(anonfun,s)}
          catch(exn$0)
           {exn$0 = caml_wrap_exception(exn$0);
            if(exn$0[1] === Bad){var m=exn$0[2];throw convert_error([3,m])}
            if(exn$0[1] === Stop){var e=exn$0[2];throw convert_error(e)}
            throw exn$0;
            var exn=exn$0}
          current[1]++;
          continue}
        return 0}}
    function parse_and_expand_argv_dynamic
     (current,argv,speclist,anonfun,errmsg)
     {return parse_and_expand_argv_dynamic_
              (1,current,argv,speclist,anonfun,errmsg)}
    function parse_argv_dynamic(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_and_expand_argv_dynamic_
              (0,current$0,[0,argv],speclist,anonfun,errmsg)}
    function parse_argv(opt,argv,speclist,anonfun,errmsg)
     {if(opt)var sth=opt[1],current$0=sth;else var current$0=current;
      return parse_argv_dynamic
              ([0,current$0],argv,[0,speclist],anonfun,errmsg)}
    function parse(l,f,msg)
     {try
       {var _on_=parse_argv(0,caml_sys_argv(0),l,f,msg);return _on_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_a__),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_a$_),msg$1);return exit(0)}
        throw exn}}
    function parse_dynamic(l,f,msg)
     {try
       {var _om_=parse_argv_dynamic(0,caml_sys_argv(0),l,f,msg);return _om_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_ba_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bb_),msg$1);return exit(0)}
        throw exn}}
    function parse_expand(l,f,msg)
     {try
       {var
         argv=[0,caml_sys_argv(0)],
         spec=[0,l],
         current$0=[0,current[1]],
         _ol_=parse_and_expand_argv_dynamic(current$0,argv,spec,f,msg);
        return _ol_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Bad)
         {var msg$0=exn[2];caml_call1(eprintf(_bc_),msg$0);return exit(2)}
        if(exn[1] === Help)
         {var msg$1=exn[2];caml_call1(printf(_bd_),msg$1);return exit(0)}
        throw exn}}
    function second_word(s)
     {var len=caml_ml_string_length(s);
      function loop(n)
       {var n$0=n;
        for(;;)
         {if(len <= n$0)return len;
          if(32 === caml_string_get(s,n$0))
           {var n$1=n$0 + 1 | 0,n$0=n$1;continue}
          return n$0}}
      try
       {var n$0=index$0(s,9)}
      catch(_oj_)
       {_oj_ = caml_wrap_exception(_oj_);
        if(_oj_ === Not_found)
         {try
           {var n=index$0(s,32)}
          catch(_ok_)
           {_ok_ = caml_wrap_exception(_ok_);
            if(_ok_ === Not_found)return len;
            throw _ok_}
          return loop(n + 1 | 0)}
        throw _oj_}
      return loop(n$0 + 1 | 0)}
    function max_arg_len(cur,param)
     {var doc=param[3],spec=param[2],kwd=param[1];
      return 11 === spec[0]
              ?max(cur,caml_ml_string_length(kwd))
              :max(cur,caml_ml_string_length(kwd) + second_word(doc) | 0)}
    function replace_leading_tab(s)
     {var seen=[0,0];
      return map$4
              (function(c)
                {if(9 === c && ! seen[1]){seen[1] = 1;return 32}return c},
               s)}
    function align(opt,speclist)
     {if(opt)var sth=opt[1],limit=sth;else var limit=max_int;
      var
       completed=add_help(speclist),
       len=fold_left$0(max_arg_len,0,completed),
       len$0=min(len,limit);
      return map$2
              (function(ksd)
                {var _oh_=ksd[1],_oi_=ksd[2];
                 if(caml_string_notequal(ksd[3],cst$58))
                  {if(11 === _oi_[0])
                    {var
                      msg$0=ksd[3],
                      cutcol$0=second_word(msg$0),
                      spaces$0=make$0(max(0,len$0 - cutcol$0 | 0) + 3 | 0,32);
                     return [0,
                             _oh_,
                             _oi_,
                             symbol(cst$59,symbol(spaces$0,replace_leading_tab(msg$0)))]}
                   var
                    msg=ksd[3],
                    spec=ksd[2],
                    cutcol=second_word(msg),
                    kwd_len=caml_ml_string_length(_oh_),
                    diff=(len$0 - kwd_len | 0) - cutcol | 0;
                   if(0 < diff)
                    {var
                      spaces=make$0(diff,32),
                      prefix=sub$0(replace_leading_tab(msg),0,cutcol),
                      suffix=
                       sub$0(msg,cutcol,caml_ml_string_length(msg) - cutcol | 0);
                     return [0,_oh_,spec,symbol(prefix,symbol(spaces,suffix))]}
                   return [0,_oh_,spec,replace_leading_tab(msg)]}
                 return ksd},
               completed)}
    function read_aux(trim,sep,file)
     {var ic=open_in_bin(file),buf=create$2(200),words=[0,0];
      function stash(param)
       {var s=contents(buf);
        if(trim)
         {var len=caml_ml_string_length(s),switch$0=0;
          if(0 < len && 13 === caml_string_get(s,len - 1 | 0))
           {var _og_=sub$0(s,0,len - 1 | 0);switch$0 = 1}
          if(! switch$0)var _og_=s;
          var word=_og_}
        else
         var word=s;
        words[1] = [0,word,words[1]];
        return clear$1(buf)}
      try
       {for(;;)
         {var c=caml_ml_input_char(ic);
          if(c === sep)stash(0);else add_char(buf,c);
          continue}}
      catch(_of_)
       {_of_ = caml_wrap_exception(_of_);
        if(_of_ === End_of_file)
         {if(0 < buf[2])stash(0);
          caml_ml_close_channel(ic);
          return of_list(rev(words[1]))}
        throw _of_}}
    var _be_=10,_bf_=1;
    function read_arg(_oe_){return read_aux(_bf_,_be_,_oe_)}
    var _bg_=0,_bh_=0;
    function read_arg0(_od_){return read_aux(_bh_,_bg_,_od_)}
    function write_aux(sep,file,args)
     {var oc=open_out_bin(file);
      iter$5(function(s){return caml_call2(fprintf(oc,_bi_),s,sep)},args);
      return close_out(oc)}
    var _bj_=10;
    function write_arg(_ob_,_oc_){return write_aux(_bj_,_ob_,_oc_)}
    var _bk_=0;
    function write_arg0(_n$_,_oa_){return write_aux(_bk_,_n$_,_oa_)}
    var
     Stdlib_arg=
      [0,
       parse,
       parse_dynamic,
       parse_argv,
       parse_argv_dynamic,
       parse_and_expand_argv_dynamic,
       parse_expand,
       Help,
       Bad,
       usage,
       usage_string,
       align,
       current,
       read_arg,
       read_arg0,
       write_arg,
       write_arg0];
    caml_register_global(786,Stdlib_arg,"Stdlib__arg");
    var printers=[0,0];
    function field(x,i)
     {var f=x[1 + i];
      return is_block(f)
              ?caml_obj_tag(f) === 252
                ?caml_call1(sprintf(_bl_),f)
                :caml_obj_tag(f) === 253?to_string(f):cst$60
              :caml_call1(sprintf(_bm_),f)}
    function other_fields(x,i)
     {if(x.length - 1 <= i)return cst$61;
      var _n9_=other_fields(x,i + 1 | 0),_n__=field(x,i);
      return caml_call2(sprintf(_bn_),_n__,_n9_)}
    function use_printers(x)
     {function conv(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var tl=param$0[2],hd=param$0[1];
            try
             {var switch$0=0,val=caml_call1(hd,x);switch$0 = 1}
            catch(_n8_){}
            if(switch$0 && val){var s=val[1];return [0,s]}
            var param$0=tl;
            continue}
          return 0}}
      return conv(printers[1])}
    function to_string_default(x)
     {if(x === Out_of_memory)return cst_Out_of_memory;
      if(x === Stack_overflow)return cst_Stack_overflow;
      if(x[1] === Match_failure)
       {var match$0=x[2],char$0=match$0[3],line=match$0[2],file=match$0[1];
        return caml_call5
                (sprintf(locfmt),
                 file,
                 line,
                 char$0,
                 char$0 + 5 | 0,
                 cst_Pattern_matching_failed)}
      if(x[1] === Assert_failure)
       {var
         match$1=x[2],
         char$1=match$1[3],
         line$0=match$1[2],
         file$0=match$1[1];
        return caml_call5
                (sprintf(locfmt),
                 file$0,
                 line$0,
                 char$1,
                 char$1 + 6 | 0,
                 cst_Assertion_failed)}
      if(x[1] === Undefined_recursive_module)
       {var
         match$2=x[2],
         char$2=match$2[3],
         line$1=match$2[2],
         file$1=match$2[1];
        return caml_call5
                (sprintf(locfmt),
                 file$1,
                 line$1,
                 char$2,
                 char$2 + 6 | 0,
                 cst_Undefined_recursive_module)}
      if(0 === caml_obj_tag(x))
       {var constructor=x[1][1],match=x.length - 1;
        if(2 < match >>> 0)
         var
          _n4_=other_fields(x,2),
          _n5_=field(x,1),
          _n7_=caml_call2(sprintf(_bo_),_n5_,_n4_);
        else
         switch(match)
          {case 0:var _n7_=cst$62;break;
           case 1:var _n7_=cst$63;break;
           default:var _n6_=field(x,1),_n7_=caml_call1(sprintf(_bp_),_n6_)}
        return symbol(constructor,_n7_)}
      return x[1]}
    function to_string$7(e)
     {var match=use_printers(e);
      if(match){var s=match[1];return s}
      return to_string_default(e)}
    function print(fct,arg)
     {try
       {var _n3_=caml_call1(fct,arg);return _n3_}
      catch(x)
       {x = caml_wrap_exception(x);
        var _n2_=to_string$7(x);
        caml_call1(eprintf(_bq_),_n2_);
        caml_ml_flush(stderr);
        throw x}}
    function catch$0(fct,arg)
     {try
       {var _n1_=caml_call1(fct,arg);return _n1_}
      catch(x)
       {x = caml_wrap_exception(x);
        caml_ml_flush(stdout);
        var _n0_=to_string$7(x);
        caml_call1(eprintf(_br_),_n0_);
        return exit(2)}}
    function convert_raw_backtrace(bt)
     {return [0,runtime.caml_convert_raw_backtrace(bt)]}
    function format_backtrace_slot(pos,slot)
     {function info(is_raise)
       {return is_raise
                ?0 === pos?cst_Raised_at:cst_Re_raised_at
                :0 === pos?cst_Raised_by_primitive_operat:cst_Called_from}
      if(0 === slot[0])
       {var
         _nS_=slot[5],
         _nT_=slot[4],
         _nU_=slot[3],
         _nV_=slot[6]?cst_inlined:cst$64,
         _nW_=slot[2],
         _nX_=slot[7],
         _nY_=info(slot[1]);
        return [0,
                caml_call7(sprintf(_bs_),_nY_,_nX_,_nW_,_nV_,_nU_,_nT_,_nS_)]}
      if(slot[1])return 0;
      var _nZ_=info(0);
      return [0,caml_call1(sprintf(_bt_),_nZ_)]}
    function print_raw_backtrace(outchan,raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],_nQ_=a.length - 1 - 1 | 0,_nP_=0;
        if(! (_nQ_ < 0))
         {var i=_nP_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(fprintf(outchan,_bu_),str)}
            var _nR_=i + 1 | 0;
            if(_nQ_ !== i){var i=_nR_;continue}
            break}}
        return 0}
      return fprintf(outchan,_bv_)}
    function print_backtrace(outchan)
     {return print_raw_backtrace(outchan,caml_get_exception_raw_backtra(0))}
    function raw_backtrace_to_string(raw_backtrace)
     {var backtrace=convert_raw_backtrace(raw_backtrace);
      if(backtrace)
       {var a=backtrace[1],b=create$2(1024),_nN_=a.length - 1 - 1 | 0,_nM_=0;
        if(! (_nN_ < 0))
         {var i=_nM_;
          for(;;)
           {var match=format_backtrace_slot(i,caml_check_bound(a,i)[1 + i]);
            if(match){var str=match[1];caml_call1(bprintf(b,_bw_),str)}
            var _nO_=i + 1 | 0;
            if(_nN_ !== i){var i=_nO_;continue}
            break}}
        return contents(b)}
      return cst_Program_not_linked_with_g_}
    function backtrace_slot_is_raise(param)
     {return 0 === param[0]?param[1]:param[1]}
    function backtrace_slot_is_inline(param){return 0 === param[0]?param[6]:0}
    function backtrace_slot_location(param)
     {return 0 === param[0]?[0,[0,param[2],param[3],param[4],param[5]]]:0}
    function backtrace_slot_defname(param)
     {if(0 === param[0] && caml_string_notequal(param[7],cst$65))
       return [0,param[7]];
      return 0}
    function backtrace_slots(raw_backtrace)
     {var match=convert_raw_backtrace(raw_backtrace);
      if(match)
       {var backtrace=match[1],i$1=backtrace.length - 1 - 1 | 0,i=i$1;
        for(;;)
         {if(-1 === i)
           var _nL_=0;
          else
           {var
             param=caml_check_bound(backtrace,i)[1 + i],
             _nK_=0 === param[0]?1:0;
            if(! _nK_){var i$0=i - 1 | 0,i=i$0;continue}
            var _nL_=_nK_}
          return _nL_?[0,backtrace]:0}}
      return 0}
    function get_backtrace(param)
     {return raw_backtrace_to_string(caml_get_exception_raw_backtra(0))}
    function register_printer(fn){printers[1] = [0,fn,printers[1]];return 0}
    function exn_slot(x){return 0 === caml_obj_tag(x)?x[1]:x}
    function exn_slot_id(x){var slot=exn_slot(x);return slot[2]}
    function exn_slot_name(x){var slot=exn_slot(x);return slot[1]}
    function default_uncaught_exception_han(exn,raw_backtrace)
     {var _nJ_=to_string$7(exn);
      caml_call1(eprintf(_bx_),_nJ_);
      print_raw_backtrace(stderr,raw_backtrace);
      return caml_ml_flush(stderr)}
    var uncaught_exception_handler=[0,default_uncaught_exception_han];
    function set_uncaught_exception_handler(fn)
     {uncaught_exception_handler[1] = fn;return 0}
    function _by_(_nI_){return runtime.caml_raw_backtrace_next_slot(_nI_)}
    function _bz_(_nH_){return runtime.caml_convert_raw_backtrace_slot(_nH_)}
    function _bA_(_nG_,_nF_)
     {return runtime.caml_raw_backtrace_slot(_nG_,_nF_)}
    function _bB_(_nE_){return runtime.caml_raw_backtrace_length(_nE_)}
    var
     _bC_=
      [0,
       backtrace_slot_is_raise,
       backtrace_slot_is_inline,
       backtrace_slot_location,
       backtrace_slot_defname,
       format_backtrace_slot];
    function _bD_(_nD_){return caml_get_exception_raw_backtra(_nD_)}
    function _bE_(_nC_){return runtime.caml_backtrace_status(_nC_)}
    var
     Stdlib_printexc=
      [0,
       to_string$7,
       to_string_default,
       print,
       catch$0,
       print_backtrace,
       get_backtrace,
       function(_nB_){return runtime.caml_record_backtrace(_nB_)},
       _bE_,
       register_printer,
       use_printers,
       _bD_,
       print_raw_backtrace,
       raw_backtrace_to_string,
       default_uncaught_exception_han,
       set_uncaught_exception_handler,
       backtrace_slots,
       _bC_,
       _bB_,
       _bA_,
       _bz_,
       _by_,
       exn_slot_id,
       exn_slot_name];
    caml_register_global(787,Stdlib_printexc,"Stdlib__printexc");
    function const$0(c,param){return c}
    function flip(f,x,y){return caml_call2(f,y,x)}
    function negate(p,v){return 1 - caml_call1(p,v)}
    var
     Finally_raised=
      [248,cst_Stdlib_Fun_Finally_raised,caml_fresh_oo_id(0)];
    register_printer
     (function(param)
       {if(param[1] === Finally_raised)
         {var exn=param[2];
          return [0,symbol(cst_Fun_Finally_raised,to_string$7(exn))]}
        return 0});
    function protect(finally$0,work)
     {function finally_no_exn(param)
       {try
         {var _nA_=caml_call1(finally$0,0);return _nA_}
        catch(e)
         {e = caml_wrap_exception(e);
          var bt=caml_get_exception_raw_backtra(0),exn=[0,Finally_raised,e];
          caml_restore_raw_backtrace(exn,bt);
          throw exn}}
      try
       {var result=caml_call1(work,0)}
      catch(work_exn)
       {work_exn = caml_wrap_exception(work_exn);
        var work_bt=caml_get_exception_raw_backtra(0);
        finally_no_exn(0);
        caml_restore_raw_backtrace(work_exn,work_bt);
        throw work_exn}
      finally_no_exn(0);
      return result}
    var Stdlib_fun=[0,const$0,flip,negate,protect,Finally_raised];
    caml_register_global(788,Stdlib_fun,"Stdlib__fun");
    function print_stat(c)
     {var st=runtime.caml_gc_stat(0),_nj_=st[4];
      caml_call1(fprintf(c,_bF_),_nj_);
      var _nk_=st[5];
      caml_call1(fprintf(c,_bG_),_nk_);
      var _nl_=st[14];
      caml_call1(fprintf(c,_bH_),_nl_);
      fprintf(c,_bI_);
      var
       _nm_=st[1],
       l1=caml_ml_string_length(caml_call1(sprintf(_bJ_),_nm_)),
       _nn_=st[1];
      caml_call2(fprintf(c,_bK_),l1,_nn_);
      var _no_=st[2];
      caml_call2(fprintf(c,_bL_),l1,_no_);
      var _np_=st[3];
      caml_call2(fprintf(c,_bM_),l1,_np_);
      fprintf(c,_bN_);
      var
       _nq_=st[15],
       l2=caml_ml_string_length(caml_call1(sprintf(_bO_),_nq_)),
       _nr_=st[15];
      caml_call2(fprintf(c,_bP_),l2,_nr_);
      var _ns_=st[6];
      caml_call2(fprintf(c,_bQ_),l2,_ns_);
      var _nt_=st[8];
      caml_call2(fprintf(c,_bR_),l2,_nt_);
      var _nu_=st[10];
      caml_call2(fprintf(c,_bS_),l2,_nu_);
      var _nv_=st[12];
      caml_call2(fprintf(c,_bT_),l2,_nv_);
      var _nw_=st[13];
      caml_call2(fprintf(c,_bU_),l2,_nw_);
      fprintf(c,_bV_);
      var _nx_=st[9];
      caml_call1(fprintf(c,_bW_),_nx_);
      var _ny_=st[11];
      caml_call1(fprintf(c,_bX_),_ny_);
      var _nz_=st[7];
      return caml_call1(fprintf(c,_bY_),_nz_)}
    function allocated_bytes(param)
     {var
       match=runtime.caml_gc_counters(0),
       ma=match[3],
       pro=match[2],
       mi=match[1];
      return (mi + ma - pro) * 4}
    function create_alarm(f){return [0,1]}
    function delete_alarm(a){a[1] = 0;return 0}
    function _bZ_(param){return 0}
    function _b0_(param){return 0}
    function _b1_(param){return 0}
    function _b2_(param){return 0}
    var null_tracker=[0,function(param){return 0},_b2_,_b1_,_b0_,_bZ_];
    function start(sampling_rate,opt,tracker)
     {if(opt)
       var sth=opt[1],callstack_size=sth;
      else
       var callstack_size=max_int;
      return runtime.caml_memprof_start(sampling_rate,callstack_size,tracker)}
    var _b3_=[0,null_tracker,start,runtime.caml_memprof_stop];
    function _b4_(_ni_){return runtime.caml_final_release(_ni_)}
    function _b5_(_nh_,_ng_)
     {return runtime.caml_final_register_called_without_value(_nh_,_ng_)}
    var
     Stdlib_gc=
      [0,
       print_stat,
       allocated_bytes,
       function(_nf_,_ne_){return runtime.caml_final_register(_nf_,_ne_)},
       _b5_,
       _b4_,
       create_alarm,
       delete_alarm,
       _b3_];
    caml_register_global(789,Stdlib_gc,"Stdlib__gc");
    function string(str)
     {return caml_md5_string(str,0,caml_ml_string_length(str))}
    function bytes(b){return string(caml_string_of_bytes(b))}
    function substring(str,ofs,len)
     {if
       (0
        <=
        ofs
        &&
        0
        <=
        len
        &&
        !
        ((caml_ml_string_length(str) - len | 0) < ofs))
       return caml_md5_string(str,ofs,len);
      return invalid_arg(cst_Digest_substring)}
    function subbytes(b,ofs,len)
     {return substring(caml_string_of_bytes(b),ofs,len)}
    function file(filename)
     {var ic=open_in_bin(filename);
      try
       {var d=runtime.caml_md5_chan(ic,-1)}
      catch(e){e = caml_wrap_exception(e);caml_ml_close_channel(ic);throw e}
      caml_ml_close_channel(ic);
      return d}
    function output$0(chan,digest){return output_string(chan,digest)}
    function input$0(chan){return really_input_string(chan,16)}
    function char_hex(n){var _nd_=10 <= n?87:48;return n + _nd_ | 0}
    function to_hex(d)
     {if(16 !== caml_ml_string_length(d))invalid_arg(cst_Digest_to_hex);
      var result=caml_create_bytes(32),i=0;
      for(;;)
       {var x=caml_string_get(d,i);
        caml_bytes_unsafe_set(result,i * 2 | 0,char_hex(x >>> 4 | 0));
        caml_bytes_unsafe_set(result,(i * 2 | 0) + 1 | 0,char_hex(x & 15));
        var _nc_=i + 1 | 0;
        if(15 !== i){var i=_nc_;continue}
        return caml_string_of_bytes(result)}}
    function from_hex(s)
     {if(32 !== caml_ml_string_length(s))invalid_arg(cst_Digest_from_hex);
      function digit(c)
       {if(65 <= c)
         {if(97 <= c)
           {if(! (103 <= c))return (c - 97 | 0) + 10 | 0}
          else
           if(! (71 <= c))return (c - 65 | 0) + 10 | 0}
        else
         {var switcher=c - 48 | 0;if(! (9 < switcher >>> 0))return c - 48 | 0}
        throw [0,Invalid_argument,cst_Digest_from_hex$0]}
      var result=caml_create_bytes(16),i=0;
      for(;;)
       {var i$0=2 * i | 0,_na_=digit(caml_string_get(s,i$0 + 1 | 0));
        caml_bytes_set
         (result,i,chr((digit(caml_string_get(s,i$0)) << 4) + _na_ | 0));
        var _nb_=i + 1 | 0;
        if(15 !== i){var i=_nb_;continue}
        return caml_string_of_bytes(result)}}
    var
     Stdlib_digest=
      [0,
       compare$5,
       equal$5,
       string,
       bytes,
       substring,
       subbytes,
       file,
       output$0,
       input$0,
       to_hex,
       from_hex];
    caml_register_global(790,Stdlib_digest,"Stdlib__digest");
    function new_state(param){return [0,caml_make_vect(55,0),0]}
    function assign(st1,st2)
     {blit$1(st2[1],0,st1[1],0,55);st1[2] = st2[2];return 0}
    function full_init(s,seed)
     {var seed$0=0 === seed.length - 1?[0,0]:seed,l=seed$0.length - 1,i$0=0;
      for(;;)
       {caml_check_bound(s[1],i$0)[1 + i$0] = i$0;
        var _m$_=i$0 + 1 | 0;
        if(54 !== i$0){var i$0=_m$_;continue}
        var accu=[0,cst_x$1],_m7_=54 + max(55,l) | 0,_m6_=0;
        if(! (_m7_ < 0))
         {var i=_m6_;
          for(;;)
           {var
             j=i % 55 | 0,
             k=caml_mod(i,l),
             x=caml_check_bound(seed$0,k)[1 + k];
            accu[1] = string(symbol(accu[1],caml_string_of_jsbytes("" + x)));
            var
             _m8_=accu[1],
             _m2_=caml_string_get(_m8_,3) << 24,
             _m3_=caml_string_get(_m8_,2) << 16,
             _m4_=caml_string_get(_m8_,1) << 8,
             _m5_=((caml_string_get(_m8_,0) + _m4_ | 0) + _m3_ | 0) + _m2_ | 0,
             _m9_=(caml_check_bound(s[1],j)[1 + j] ^ _m5_) & 1073741823;
            caml_check_bound(s[1],j)[1 + j] = _m9_;
            var _m__=i + 1 | 0;
            if(_m7_ !== i){var i=_m__;continue}
            break}}
        s[2] = 0;
        return 0}}
    function make$2(seed)
     {var result=new_state(0);full_init(result,seed);return result}
    function make_self_init(param){return make$2(caml_sys_random_seed(0))}
    function copy$5(s){var result=new_state(0);assign(result,s);return result}
    function bits(s)
     {s[2] = (s[2] + 1 | 0) % 55 | 0;
      var
       _mZ_=s[2],
       curval=caml_check_bound(s[1],_mZ_)[1 + _mZ_],
       _m0_=(s[2] + 24 | 0) % 55 | 0,
       newval=
        caml_check_bound(s[1],_m0_)[1 + _m0_]
        +
        (curval ^ (curval >>> 25 | 0) & 31)
        |
        0,
       newval30=newval & 1073741823,
       _m1_=s[2];
      caml_check_bound(s[1],_m1_)[1 + _m1_] = newval30;
      return newval30}
    function int$0(s,bound)
     {if(! (1073741823 < bound) && 0 < bound)
       for(;;)
        {var r=bits(s),v=caml_mod(r,bound);
         if(((1073741823 - bound | 0) + 1 | 0) < (r - v | 0))continue;
         return v}
      return invalid_arg(cst_Random_int)}
    function int32(s,bound)
     {if(caml_lessequal(bound,0))return invalid_arg(cst_Random_int32);
      for(;;)
       {var b1=bits(s),b2=(bits(s) & 1) << 30,r=b1 | b2,v=caml_mod(r,bound);
        if(caml_greaterthan(r - v | 0,(2147483647 - bound | 0) + 1 | 0))
         continue;
        return v}}
    function int64(s,bound)
     {if(caml_lessequal(bound,_b7_))return invalid_arg(cst_Random_int64);
      for(;;)
       {var
         b1=caml_int64_of_int32(bits(s)),
         b2=caml_int64_shift_left(caml_int64_of_int32(bits(s)),30),
         b3=caml_int64_shift_left(caml_int64_of_int32(bits(s) & 7),60),
         r=caml_int64_or(b1,caml_int64_or(b2,b3)),
         v=runtime.caml_int64_mod(r,bound);
        if
         (caml_greaterthan
           (caml_int64_sub(r,v),
            caml_int64_add(caml_int64_sub(max_int$2,bound),_b6_)))
         continue;
        return v}}
    function nativeint(s,bound){return int32(s,bound)}
    function float$0(s,bound)
     {var r1=bits(s),r2=bits(s);
      return (r1 / 1073741824. + r2) / 1073741824. * bound}
    function bool(s){return 0 === (bits(s) & 1)?1:0}
    var default$0=[0,_b8_.slice(),0];
    function bits$0(param){return bits(default$0)}
    function int$1(bound){return int$0(default$0,bound)}
    function int32$0(bound){return int32(default$0,bound)}
    function nativeint$0(bound){return nativeint(default$0,bound)}
    function int64$0(bound){return int64(default$0,bound)}
    function float$1(scale){return float$0(default$0,scale)}
    function bool$0(param){return bool(default$0)}
    function full_init$0(seed){return full_init(default$0,seed)}
    function init$4(seed){return full_init(default$0,[0,seed])}
    function self_init(param){return full_init$0(caml_sys_random_seed(0))}
    function get_state(param){return copy$5(default$0)}
    function set_state(s){return assign(default$0,s)}
    var
     _b9_=
      [0,
       make$2,
       make_self_init,
       copy$5,
       bits,
       int$0,
       int32,
       nativeint,
       int64,
       float$0,
       bool],
     Stdlib_random=
      [0,
       init$4,
       full_init$0,
       self_init,
       bits$0,
       int$1,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       bool$0,
       _b9_,
       get_state,
       set_state];
    caml_register_global(791,Stdlib_random,"Stdlib__random");
    function ongoing_traversal(h)
     {var _mX_=h.length - 1 < 4?1:0,_mY_=_mX_ || (h[4] < 0?1:0);return _mY_}
    function flip_ongoing_traversal(h){h[4] = - h[4] | 0;return 0}
    try
     {var _cS_=caml_sys_getenv(cst_OCAMLRUNPARAM),params=_cS_}
    catch(_mV_)
     {_mV_ = caml_wrap_exception(_mV_);
      if(_mV_ !== Not_found)throw _mV_;
      try
       {var _cR_=caml_sys_getenv(cst_CAMLRUNPARAM),_b__=_cR_}
      catch(_mW_)
       {_mW_ = caml_wrap_exception(_mW_);
        if(_mW_ !== Not_found)throw _mW_;
        var _b__=cst$66}
      var params=_b__}
    var
     randomized_default=contains$0(params,82),
     randomized=[0,randomized_default];
    function randomize(param){randomized[1] = 1;return 0}
    function is_randomized(param){return randomized[1]}
    var prng=[246,function(_mU_){return caml_call1(_b9_[2],0)}];
    function create$3(opt,initial_size)
     {if(opt)var sth=opt[1],random=sth;else var random=randomized[1];
      var x=16;
      for(;;)
       {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
         {var x$0=x * 2 | 0,x=x$0;continue}
        if(random)
         var
          _mS_=caml_obj_tag(prng),
          _mT_=250 === _mS_?prng[1]:246 === _mS_?force_lazy_block(prng):prng,
          seed=caml_call1(_b9_[4],_mT_);
        else
         var seed=0;
        return [0,0,caml_make_vect(x,0),seed,x]}}
    function clear$2(h)
     {var _mR_=0 < h[1]?1:0;
      return _mR_?(h[1] = 0,fill$0(h[2],0,h[2].length - 1,0)):_mR_}
    function reset$0(h)
     {var len=h[2].length - 1;
      if(4 <= h.length - 1 && len !== abs(h[4]))
       {h[1] = 0;h[2] = caml_make_vect(abs(h[4]),0);return 0}
      return clear$2(h)}
    function copy_bucketlist(param)
     {if(param)
       {var
         key=param[1],
         data=param[2],
         next=param[3],
         prec$0=[0,key,data,next],
         prec=prec$0,
         param$0=next;
        for(;;)
         {if(param$0)
           {var
             key$0=param$0[1],
             data$0=param$0[2],
             next$0=param$0[3],
             r=[0,key$0,data$0,next$0];
            if(prec){prec[3] = r;var prec=r,param$0=next$0;continue}
            throw [0,Assert_failure,_b$_]}
          return prec$0}}
      return 0}
    function copy$6(init)
     {var _mO_=init[4],_mP_=init[3],_mQ_=map$5(copy_bucketlist,init[2]);
      return [0,init[1],_mQ_,_mP_,_mO_]}
    function length$4(h){return h[1]}
    function resize$0(indexfun,h)
     {var
       odata=h[2],
       osize=odata.length - 1,
       nsize=osize * 2 | 0,
       _mF_=nsize < max_array_length?1:0;
      if(_mF_)
       {var
         ndata=caml_make_vect(nsize,0),
         ndata_tail=caml_make_vect(nsize,0),
         inplace=1 - ongoing_traversal(h);
        h[2] = ndata;
        var _mH_=osize - 1 | 0,_mG_=0;
        if(! (_mH_ < 0))
         {var i$0=_mG_;
          a:
          for(;;)
           {var cell$1=caml_check_bound(odata,i$0)[1 + i$0],cell=cell$1;
            for(;;)
             {if(cell)
               {var
                 key=cell[1],
                 data=cell[2],
                 next=cell[3],
                 cell$0=inplace?cell:[0,key,data,0],
                 nidx=caml_call2(indexfun,h,key),
                 match=caml_check_bound(ndata_tail,nidx)[1 + nidx];
                if(match)
                 match[3] = cell$0;
                else
                 caml_check_bound(ndata,nidx)[1 + nidx] = cell$0;
                caml_check_bound(ndata_tail,nidx)[1 + nidx] = cell$0;
                var cell=next;
                continue}
              var _mN_=i$0 + 1 | 0;
              if(_mH_ !== i$0){var i$0=_mN_;continue a}
              break}
            break}}
        if(inplace)
         {var _mJ_=nsize - 1 | 0,_mI_=0;
          if(! (_mJ_ < 0))
           {var i=_mI_;
            for(;;)
             {var match$0=caml_check_bound(ndata_tail,i)[1 + i];
              if(match$0)match$0[3] = 0;
              var _mM_=i + 1 | 0;
              if(_mJ_ !== i){var i=_mM_;continue}
              break}}
          var _mK_=0}
        else
         var _mK_=inplace;
        var _mL_=_mK_}
      else
       var _mL_=_mF_;
      return _mL_}
    function iter$10(f,h)
     {function do_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var key=param$0[1],data=param$0[2],next=param$0[3];
            caml_call2(f,key,data);
            var param$0=next;
            continue}
          return 0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],_mB_=d.length - 1 - 1 | 0,_mA_=0;
        if(! (_mB_ < 0))
         {var i=_mA_;
          for(;;)
           {do_bucket(caml_check_bound(d,i)[1 + i]);
            var _mE_=i + 1 | 0;
            if(_mB_ !== i){var i=_mE_;continue}
            break}}
        var _mC_=1 - old_trav,_mD_=_mC_?flip_ongoing_traversal(h):_mC_;
        return _mD_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function filter_map_inplace_bucket(f,h,i,prec,slot)
     {var prec$0=prec,slot$0=slot;
      for(;;)
       {if(slot$0)
         {var
           key=slot$0[1],
           data=slot$0[2],
           next=slot$0[3],
           match=caml_call2(f,key,data);
          if(match)
           {var data$0=match[1];
            if(prec$0)
             prec$0[3] = slot$0;
            else
             caml_check_bound(h[2],i)[1 + i] = slot$0;
            slot$0[2] = data$0;
            var prec$0=slot$0,slot$0=next;
            continue}
          h[1] = h[1] - 1 | 0;
          var slot$0=next;
          continue}
        return prec$0
                ?(prec$0[3] = 0,0)
                :(caml_check_bound(h[2],i)[1 + i] = 0,0)}}
    function filter_map_inplace(f,h)
     {var d=h[2],old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var _mx_=d.length - 1 - 1 | 0,_mw_=0;
        if(! (_mx_ < 0))
         {var i=_mw_;
          for(;;)
           {filter_map_inplace_bucket(f,h,i,0,caml_check_bound(h[2],i)[1 + i]);
            var _mz_=i + 1 | 0;
            if(_mx_ !== i){var i=_mz_;continue}
            break}}
        var _my_=0;
        return _my_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function fold$3(f,h,init)
     {function do_bucket(b,accu)
       {var b$0=b,accu$0=accu;
        for(;;)
         {if(b$0)
           {var
             key=b$0[1],
             data=b$0[2],
             next=b$0[3],
             accu$1=caml_call3(f,key,data,accu$0),
             b$0=next,
             accu$0=accu$1;
            continue}
          return accu$0}}
      var old_trav=ongoing_traversal(h);
      if(1 - old_trav)flip_ongoing_traversal(h);
      try
       {var d=h[2],accu=[0,init],_ms_=d.length - 1 - 1 | 0,_mr_=0;
        if(! (_ms_ < 0))
         {var i=_mr_;
          for(;;)
           {var _mu_=accu[1];
            accu[1] = do_bucket(caml_check_bound(d,i)[1 + i],_mu_);
            var _mv_=i + 1 | 0;
            if(_ms_ !== i){var i=_mv_;continue}
            break}}
        if(1 - old_trav)flip_ongoing_traversal(h);
        var _mt_=accu[1];
        return _mt_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(old_trav)throw exn;
        flip_ongoing_traversal(h);
        throw exn}}
    function bucket_length(accu,param)
     {var accu$0=accu,param$0=param;
      for(;;)
       {if(param$0)
         {var
           param$1=param$0[3],
           accu$1=accu$0 + 1 | 0,
           accu$0=accu$1,
           param$0=param$1;
          continue}
        return accu$0}}
    function stats(h)
     {var
       _mn_=h[2],
       _mo_=0,
       mbl=
        fold_left$1(function(m,b){return max(m,bucket_length(0,b))},_mo_,_mn_),
       histo=caml_make_vect(mbl + 1 | 0,0),
       _mp_=h[2];
      iter$5
       (function(b)
         {var
           l=bucket_length(0,b),
           _mq_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
          caml_check_bound(histo,l)[1 + l] = _mq_;
          return 0},
        _mp_);
      return [0,h[1],h[2].length - 1,mbl,histo]}
    function to_seq$9(tbl)
     {var tbl_data=tbl[2];
      function aux(i,buck,param)
       {var i$0=i,buck$0=buck;
        for(;;)
         {if(buck$0)
           {var key=buck$0[1],data=buck$0[2],next=buck$0[3];
            return [0,[0,key,data],function(_mm_){return aux(i$0,next,_mm_)}]}
          if(i$0 === tbl_data.length - 1)return 0;
          var
           buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           buck$0=buck$1;
          continue}}
      var _mj_=0,_mk_=0;
      return function(_ml_){return aux(_mk_,_mj_,_ml_)}}
    function to_seq_keys(m)
     {var _mf_=to_seq$9(m);
      function _mg_(_mi_){return _mi_[1]}
      return function(_mh_){return map(_mg_,_mf_,_mh_)}}
    function to_seq_values(m)
     {var _mb_=to_seq$9(m);
      function _mc_(_me_){return _me_[2]}
      return function(_md_){return map(_mc_,_mb_,_md_)}}
    function MakeSeeded(H)
     {function key_index(h,key)
       {var _ma_=h[2].length - 1 - 1 | 0;
        return caml_call2(H[2],h[3],key) & _ma_}
      function add(h,key,data)
       {var
         i=key_index(h,key),
         bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _l$_=h[2].length - 1 << 1 < h[1]?1:0;
        return _l$_?resize$0(key_index,h):_l$_}
      function remove(h,key)
       {var
         i=key_index(h,key),
         c$0=caml_check_bound(h[2],i)[1 + i],
         prec=0,
         c=c$0;
        for(;;)
         {if(c)
           {var k=c[1],next=c[3];
            if(caml_call2(H[1],k,key))
             {h[1] = h[1] - 1 | 0;
              return prec
                      ?(prec[3] = next,0)
                      :(caml_check_bound(h[2],i)[1 + i] = next,0)}
            var prec=c,c=next;
            continue}
          return 0}}
      function find(h,key)
       {var _l__=key_index(h,key),match=caml_check_bound(h[2],_l__)[1 + _l__];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return d1;
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return d2;
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return d3;
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return data;
                  var param=next;
                  continue}
                throw Not_found}}
            throw Not_found}
          throw Not_found}
        throw Not_found}
      function find_opt(h,key)
       {var _l9_=key_index(h,key),match=caml_check_bound(h[2],_l9_)[1 + _l9_];
        if(match)
         {var k1=match[1],d1=match[2],next1=match[3];
          if(caml_call2(H[1],key,k1))return [0,d1];
          if(next1)
           {var k2=next1[1],d2=next1[2],next2=next1[3];
            if(caml_call2(H[1],key,k2))return [0,d2];
            if(next2)
             {var k3=next2[1],d3=next2[2],next3=next2[3];
              if(caml_call2(H[1],key,k3))return [0,d3];
              var param=next3;
              for(;;)
               {if(param)
                 {var k=param[1],data=param[2],next=param[3];
                  if(caml_call2(H[1],key,k))return [0,data];
                  var param=next;
                  continue}
                return 0}}
            return 0}
          return 0}
        return 0}
      function find_all(h,key)
       {function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var k=param$0[1],d=param$0[2],next=param$0[3];
              if(caml_call2(H[1],k,key))return [0,d,find_in_bucket(next)];
              var param$0=next;
              continue}
            return 0}}
        var _l8_=key_index(h,key);
        return find_in_bucket(caml_check_bound(h[2],_l8_)[1 + _l8_])}
      function replace(h,key,data)
       {var
         i=key_index(h,key),
         param$0=caml_check_bound(h[2],i)[1 + i],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3];
            if(! caml_call2(H[1],k,key)){var param=next;continue}
            param[1] = key;
            param[2] = data;
            var _l5_=0}
          else
           var _l5_=1;
          if(_l5_)
           {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
            h[1] = h[1] + 1 | 0;
            var _l6_=h[2].length - 1 << 1 < h[1]?1:0;
            if(_l6_)return resize$0(key_index,h);
            var _l7_=_l6_}
          else
           var _l7_=_l5_;
          return _l7_}}
      function mem(h,key)
       {var
         _l4_=key_index(h,key),
         param$0=caml_check_bound(h[2],_l4_)[1 + _l4_],
         param=param$0;
        for(;;)
         {if(param)
           {var k=param[1],next=param[3],_l3_=caml_call2(H[1],k,key);
            if(_l3_)return _l3_;
            var param=next;
            continue}
          return 0}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create$3,
              clear$2,
              reset$0,
              copy$6,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$10,
              filter_map_inplace,
              fold$3,
              length$4,
              stats,
              to_seq$9,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function Make$0(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       _l2_=include[1];
      function create(sz){return caml_call2(_l2_,_ca_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq]}
    function hash$1(x){return caml_hash(10,100,0,x)}
    function hash_param(n1,n2,x){return caml_hash(n1,n2,0,x)}
    function seeded_hash(seed,x){return caml_hash(10,100,seed,x)}
    function key_index(h,key)
     {return 3 <= h.length - 1
              ?caml_hash(10,100,h[3],key) & (h[2].length - 1 - 1 | 0)
              :caml_mod
                (runtime.caml_hash_univ_param(10,100,key),h[2].length - 1)}
    function add$0(h,key,data)
     {var
       i=key_index(h,key),
       bucket=[0,key,data,caml_check_bound(h[2],i)[1 + i]];
      caml_check_bound(h[2],i)[1 + i] = bucket;
      h[1] = h[1] + 1 | 0;
      var _l1_=h[2].length - 1 << 1 < h[1]?1:0;
      return _l1_?resize$0(key_index,h):_l1_}
    function remove(h,key)
     {var i=key_index(h,key),c$0=caml_check_bound(h[2],i)[1 + i],prec=0,c=c$0;
      for(;;)
       {if(c)
         {var k=c[1],next=c[3];
          if(0 === caml_compare(k,key))
           {h[1] = h[1] - 1 | 0;
            return prec
                    ?(prec[3] = next,0)
                    :(caml_check_bound(h[2],i)[1 + i] = next,0)}
          var prec=c,c=next;
          continue}
        return 0}}
    function find$0(h,key)
     {var _l0_=key_index(h,key),match=caml_check_bound(h[2],_l0_)[1 + _l0_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return d1;
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return d2;
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return d3;
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return data;
                var param=next;
                continue}
              throw Not_found}}
          throw Not_found}
        throw Not_found}
      throw Not_found}
    function find_opt$0(h,key)
     {var _lZ_=key_index(h,key),match=caml_check_bound(h[2],_lZ_)[1 + _lZ_];
      if(match)
       {var k1=match[1],d1=match[2],next1=match[3];
        if(0 === caml_compare(key,k1))return [0,d1];
        if(next1)
         {var k2=next1[1],d2=next1[2],next2=next1[3];
          if(0 === caml_compare(key,k2))return [0,d2];
          if(next2)
           {var k3=next2[1],d3=next2[2],next3=next2[3];
            if(0 === caml_compare(key,k3))return [0,d3];
            var param=next3;
            for(;;)
             {if(param)
               {var k=param[1],data=param[2],next=param[3];
                if(0 === caml_compare(key,k))return [0,data];
                var param=next;
                continue}
              return 0}}
          return 0}
        return 0}
      return 0}
    function find_all$0(h,key)
     {function find_in_bucket(param)
       {var param$0=param;
        for(;;)
         {if(param$0)
           {var k=param$0[1],data=param$0[2],next=param$0[3];
            if(0 === caml_compare(k,key))return [0,data,find_in_bucket(next)];
            var param$0=next;
            continue}
          return 0}}
      var _lY_=key_index(h,key);
      return find_in_bucket(caml_check_bound(h[2],_lY_)[1 + _lY_])}
    function replace(h,key,data)
     {var
       i=key_index(h,key),
       param$0=caml_check_bound(h[2],i)[1 + i],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3];
          if(0 !== caml_compare(k,key)){var param=next;continue}
          param[1] = key;
          param[2] = data;
          var _lV_=0}
        else
         var _lV_=1;
        if(_lV_)
         {caml_check_bound(h[2],i)[1 + i] = [0,key,data,param$0];
          h[1] = h[1] + 1 | 0;
          var _lW_=h[2].length - 1 << 1 < h[1]?1:0;
          if(_lW_)return resize$0(key_index,h);
          var _lX_=_lW_}
        else
         var _lX_=_lV_;
        return _lX_}}
    function mem$2(h,key)
     {var
       _lU_=key_index(h,key),
       param$0=caml_check_bound(h[2],_lU_)[1 + _lU_],
       param=param$0;
      for(;;)
       {if(param)
         {var k=param[1],next=param[3],_lT_=0 === caml_compare(k,key)?1:0;
          if(_lT_)return _lT_;
          var param=next;
          continue}
        return 0}}
    function add_seq$2(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return add$0(tbl,k,v)},
               i)}
    function replace_seq(tbl,i)
     {return iter
              (function(param)
                {var v=param[2],k=param[1];return replace(tbl,k,v)},
               i)}
    function of_seq$7(i){var tbl=create$3(0,16);replace_seq(tbl,i);return tbl}
    var
     Stdlib_hashtbl=
      [0,
       create$3,
       clear$2,
       reset$0,
       copy$6,
       add$0,
       find$0,
       find_opt$0,
       find_all$0,
       mem$2,
       remove,
       replace,
       iter$10,
       filter_map_inplace,
       fold$3,
       length$4,
       randomize,
       is_randomized,
       stats,
       to_seq$9,
       to_seq_keys,
       to_seq_values,
       add_seq$2,
       replace_seq,
       of_seq$7,
       Make$0,
       MakeSeeded,
       hash$1,
       seeded_hash,
       hash_param,
       caml_hash];
    caml_register_global(792,Stdlib_hashtbl,"Stdlib__hashtbl");
    function weak_create(l)
     {var _lR_=0 <= l?1:0,_lS_=_lR_?l <= _s_[15]?1:0:_lR_;
      if(1 - _lS_)invalid_arg(cst_Weak_create);
      return runtime.caml_weak_create(l)}
    function length$5(x){return x.length - 1 - 2 | 0}
    function raise_if_invalid_offset$0(e,o,msg)
     {var _lO_=0 <= o?1:0,_lP_=_lO_?o < length$5(e)?1:0:_lO_,_lQ_=1 - _lP_;
      return _lQ_?invalid_arg(msg):_lQ_}
    function set(e,o,x)
     {raise_if_invalid_offset$0(e,o,cst_Weak_set);
      if(x){var x$0=x[1];return caml_ephe_set_key(e,o,x$0)}
      return caml_ephe_unset_key(e,o)}
    function get$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get);
      return runtime.caml_weak_get(e,o)}
    function get_copy(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_get_copy);
      return runtime.caml_weak_get_copy(e,o)}
    function check$0(e,o)
     {raise_if_invalid_offset$0(e,o,cst_Weak_check);
      return runtime.caml_weak_check(e,o)}
    function blit$4(e1,o1,e2,o2,l)
     {if
       (0
        <=
        l
        &&
        0
        <=
        o1
        &&
        !
        ((length$5(e1) - l | 0) < o1)
        &&
        0
        <=
        o2
        &&
        !
        ((length$5(e2) - l | 0) < o2))
       {var
         _lM_=0 !== l?1:0,
         _lN_=_lM_?runtime.caml_weak_blit(e1,o1,e2,o2,l):_lM_;
        return _lN_}
      return invalid_arg(cst_Weak_blit)}
    function fill$2(ar,ofs,len,x)
     {if(0 <= ofs && 0 <= len && ! ((length$5(ar) - len | 0) < ofs))
       {var _lK_=(ofs + len | 0) - 1 | 0;
        if(! (_lK_ < ofs))
         {var i=ofs;
          for(;;)
           {set(ar,i,x);
            var _lL_=i + 1 | 0;
            if(_lK_ !== i){var i=_lL_;continue}
            break}}
        return 0}
      throw [0,Invalid_argument,cst_Weak_fill]}
    function Make$1(H)
     {var emptybucket=weak_create(0);
      function get_index(t,h){return caml_mod(h & 2147483647,t[1].length - 1)}
      var limit=7;
      function create(sz)
       {var
         sz$0=7 <= sz?sz:7,
         sz$1=max_array_length < sz$0?max_array_length:sz$0;
        return [0,
                caml_make_vect(sz$1,emptybucket),
                caml_make_vect(sz$1,[0]),
                limit,
                0,
                0]}
      function clear(t)
       {var _lI_=t[1].length - 1 - 1 | 0,_lH_=0;
        if(! (_lI_ < 0))
         {var i=_lH_;
          for(;;)
           {caml_check_bound(t[1],i)[1 + i] = emptybucket;
            caml_check_bound(t[2],i)[1 + i] = [0];
            var _lJ_=i + 1 | 0;
            if(_lI_ !== i){var i=_lJ_;continue}
            break}}
        t[3] = limit;
        t[4] = 0;
        return 0}
      function fold(f,t,init)
       {var _lG_=t[1],i=0;
        return fold_right$0
                (function(b,accu$1)
                  {var i$0=i,accu=accu$1;
                   for(;;)
                    {if(length$5(b) <= i$0)return accu;
                     var match=get$0(b,i$0);
                     if(match)
                      {var
                        v=match[1],
                        accu$0=caml_call2(f,v,accu),
                        i$1=i$0 + 1 | 0,
                        i$0=i$1,
                        accu=accu$0;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lG_,
                 init)}
      function iter(f,t)
       {var _lF_=t[1],i=0;
        return iter$5
                (function(b)
                  {var i$0=i;
                   for(;;)
                    {if(length$5(b) <= i$0)return 0;
                     var match=get$0(b,i$0);
                     if(match)
                      {var v=match[1];
                       caml_call1(f,v);
                       var i$1=i$0 + 1 | 0,i$0=i$1;
                       continue}
                     var i$2=i$0 + 1 | 0,i$0=i$2;
                     continue}},
                 _lF_)}
      function count_bucket(i,b,accu)
       {var i$0=i,accu$0=accu;
        for(;;)
         {if(length$5(b) <= i$0)return accu$0;
          var
           _lE_=check$0(b,i$0)?1:0,
           accu$1=accu$0 + _lE_ | 0,
           i$1=i$0 + 1 | 0,
           i$0=i$1,
           accu$0=accu$1;
          continue}}
      function count(t)
       {var _lz_=0,_lA_=t[1],_lB_=0;
        return fold_right$0
                (function(_lC_,_lD_){return count_bucket(_lB_,_lC_,_lD_)},
                 _lA_,
                 _lz_)}
      function add_aux(t,setter,d,h,index)
       {var
         bucket$0=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket$0),
         i$3=0;
        for(;;)
         {if(sz <= i$3)
           {var
             newsz=
              min(((3 * sz | 0) / 2 | 0) + 3 | 0,max_array_length - 2 | 0);
            if(newsz <= sz)failwith(cst_Weak_Make_hash_bucket_cann);
            var
             newbucket$0=weak_create(newsz),
             newhashes=caml_make_vect(newsz,0);
            blit$4(bucket$0,0,newbucket$0,0,sz);
            blit$1(hashes,0,newhashes,0,sz);
            caml_call3(setter,newbucket$0,sz,d);
            caml_check_bound(newhashes,sz)[1 + sz] = h;
            caml_check_bound(t[1],index)[1 + index] = newbucket$0;
            caml_check_bound(t[2],index)[1 + index] = newhashes;
            var _lv_=sz <= t[3]?1:0,_lw_=_lv_?t[3] < newsz?1:0:_lv_;
            if(_lw_)
             {t[4] = t[4] + 1 | 0;
              var i$4=0;
              for(;;)
               {var
                 _ll_=t[5],
                 bucket=caml_check_bound(t[1],_ll_)[1 + _ll_],
                 _lm_=t[5],
                 hbucket=caml_check_bound(t[2],_lm_)[1 + _lm_],
                 n=length$5(bucket),
                 prev_len=(((n - 3 | 0) * 2 | 0) + 2 | 0) / 3 | 0,
                 live=count_bucket(0,bucket,0);
                if(live <= prev_len)
                 {var j$2=length$5(bucket) - 1 | 0,i$0=0,j=j$2;
                  for(;;)
                   {if(prev_len <= j)
                     {if(check$0(bucket,i$0))
                       {var i$1=i$0 + 1 | 0,i$0=i$1;continue}
                      if(check$0(bucket,j))
                       {blit$4(bucket,j,bucket,i$0,1);
                        var _ln_=caml_check_bound(hbucket,j)[1 + j];
                        caml_check_bound(hbucket,i$0)[1 + i$0] = _ln_;
                        var j$0=j - 1 | 0,i$2=i$0 + 1 | 0,i$0=i$2,j=j$0;
                        continue}
                      var j$1=j - 1 | 0,j=j$1;
                      continue}
                    if(0 === prev_len)
                     {var _lo_=t[5];
                      caml_check_bound(t[1],_lo_)[1 + _lo_] = emptybucket;
                      var _lp_=t[5];
                      caml_check_bound(t[2],_lp_)[1 + _lp_] = [0]}
                    else
                     {var newbucket=weak_create(prev_len);
                      blit$4(bucket,0,newbucket,0,prev_len);
                      var _ls_=t[5];
                      caml_check_bound(t[1],_ls_)[1 + _ls_] = newbucket;
                      var _lt_=sub$1(hbucket,0,prev_len),_lu_=t[5];
                      caml_check_bound(t[2],_lu_)[1 + _lu_] = _lt_}
                    var _lq_=t[3] < n?1:0,_lr_=_lq_?prev_len <= t[3]?1:0:_lq_;
                    if(_lr_)t[4] = t[4] - 1 | 0;
                    break}}
                t[5] = caml_mod(t[5] + 1 | 0,t[1].length - 1);
                var _ly_=i$4 + 1 | 0;
                if(2 !== i$4){var i$4=_ly_;continue}
                break}}
            var _lx_=((t[1].length - 1) / 2 | 0) < t[4]?1:0;
            if(_lx_)
             {var
               n$0=t[1].length - 1,
               newlen=min(((3 * n$0 | 0) / 2 | 0) + 3 | 0,max_array_length);
              if(n$0 < newlen)
               {var newt=create(newlen),_lk_=t[1],i=0;
                iteri$2
                 (function(j,ob)
                   {var i$0=i;
                    for(;;)
                     {if(length$5(ob) <= i$0)return 0;
                      var match=check$0(ob,i$0);
                      if(match)
                       {var
                         oh=caml_check_bound(t[2],j)[1 + j],
                         setter$0=
                          function(i)
                           {function setter(nb,ni,param){return blit$4(ob,i,nb,ni,1)}
                            return setter},
                         setter=setter$0(i$0),
                         h=caml_check_bound(oh,i$0)[1 + i$0];
                        add_aux(newt,setter,0,h,get_index(newt,h));
                        var i$1=i$0 + 1 | 0,i$0=i$1;
                        continue}
                      var i$2=i$0 + 1 | 0,i$0=i$2;
                      continue}},
                  _lk_);
                t[1] = newt[1];
                t[2] = newt[2];
                t[3] = newt[3];
                t[4] = newt[4];
                t[5] = caml_mod(t[5],newt[1].length - 1);
                return 0}
              t[3] = max_int;
              t[4] = 0;
              return 0}
            return _lx_}
          if(check$0(bucket$0,i$3)){var i$5=i$3 + 1 | 0,i$3=i$5;continue}
          caml_call3(setter,bucket$0,i$3,d);
          caml_check_bound(hashes,i$3)[1 + i$3] = h;
          return 0}}
      function add(t,d)
       {var h=caml_call1(H[2],d);return add_aux(t,set,[0,d],h,get_index(t,h))}
      function find_or(t,d,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return caml_call2(ifnotfound,h,index);
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0){var v$0=match$0[1];return v$0}
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function merge(t,d)
       {return find_or
                (t,d,function(h,index){add_aux(t,set,[0,d],h,index);return d})}
      function find(t,d)
       {return find_or(t,d,function(h,index){throw Not_found})}
      function find_opt(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return 0;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var v$0=get$0(bucket,i);
                if(v$0)return v$0;
                var i$0=i + 1 | 0,i=i$0;
                continue}}
            var i$1=i + 1 | 0,i=i$1;
            continue}
          var i$2=i + 1 | 0,i=i$2;
          continue}}
      function find_shadow(t,d,iffound,ifnotfound)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0;
        for(;;)
         {if(sz <= i)return ifnotfound;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))return caml_call2(iffound,bucket,i)}
            var i$0=i + 1 | 0,i=i$0;
            continue}
          var i$1=i + 1 | 0,i=i$1;
          continue}}
      function remove(t,d)
       {var _lj_=0;
        return find_shadow(t,d,function(w,i){return set(w,i,0)},_lj_)}
      function mem(t,d)
       {var _li_=0;return find_shadow(t,d,function(w,i){return 1},_li_)}
      function find_all(t,d)
       {var
         h=caml_call1(H[2],d),
         index=get_index(t,h),
         bucket=caml_check_bound(t[1],index)[1 + index],
         hashes=caml_check_bound(t[2],index)[1 + index],
         sz=length$5(bucket),
         i=0,
         accu=0;
        for(;;)
         {if(sz <= i)return accu;
          if(h === caml_check_bound(hashes,i)[1 + i])
           {var match=get_copy(bucket,i);
            if(match)
             {var v=match[1];
              if(caml_call2(H[1],v,d))
               {var match$0=get$0(bucket,i);
                if(match$0)
                 {var
                   v$0=match$0[1],
                   accu$0=[0,v$0,accu],
                   i$0=i + 1 | 0,
                   i=i$0,
                   accu=accu$0;
                  continue}
                var i$1=i + 1 | 0,i=i$1;
                continue}}
            var i$2=i + 1 | 0,i=i$2;
            continue}
          var i$3=i + 1 | 0,i=i$3;
          continue}}
      function stats(t)
       {var len=t[1].length - 1,lens=map$5(length$5,t[1]);
        sort(caml_int_compare,lens);
        var
         _la_=0,
         totlen=
          fold_left$1(function(_lh_,_lg_){return _lh_ + _lg_ | 0},_la_,lens),
         _lb_=len - 1 | 0,
         _ld_=len / 2 | 0,
         _lc_=caml_check_bound(lens,_lb_)[1 + _lb_],
         _le_=caml_check_bound(lens,_ld_)[1 + _ld_],
         _lf_=caml_check_bound(lens,0)[1];
        return [0,len,count(t),totlen,_lf_,_le_,_lc_]}
      return [0,
              create,
              clear,
              merge,
              add,
              remove,
              find,
              find_opt,
              find_all,
              mem,
              iter,
              fold,
              count,
              stats]}
    var
     Stdlib_weak=
      [0,weak_create,length$5,set,get$0,get_copy,check$0,fill$2,blit$4,Make$1];
    caml_register_global(793,Stdlib_weak,"Stdlib__weak");
    function id$0(x){return x}
    var
     String_tag=[248,cst_Stdlib_Format_String_tag,caml_fresh_oo_id(0)],
     size=0,
     unknown=-1;
    function pp_enqueue(state,token)
     {state[13] = state[13] + token[3] | 0;return add(token,state[28])}
    var pp_infinity=1000000010;
    function pp_output_string(state,s)
     {return caml_call3(state[17],s,0,caml_ml_string_length(s))}
    function pp_output_newline(state){return caml_call1(state[19],0)}
    function format_pp_text(state,size,text)
     {state[9] = state[9] - size | 0;
      pp_output_string(state,text);
      state[11] = 0;
      return 0}
    function format_string(state,s)
     {var _k$_=caml_string_notequal(s,cst$67);
      return _k$_?format_pp_text(state,caml_ml_string_length(s),s):_k$_}
    function break_new_line(state,param,width)
     {var after=param[3],offset=param[2],before=param[1];
      format_string(state,before);
      pp_output_newline(state);
      state[11] = 1;
      var
       indent=(state[6] - width | 0) + offset | 0,
       real_indent=min(state[8],indent);
      state[10] = real_indent;
      state[9] = state[6] - state[10] | 0;
      caml_call1(state[21],state[10]);
      return format_string(state,after)}
    function break_line(state,width){return break_new_line(state,_cb_,width)}
    function break_same_line(state,param)
     {var after=param[3],width=param[2],before=param[1];
      format_string(state,before);
      state[9] = state[9] - width | 0;
      caml_call1(state[20],width);
      return format_string(state,after)}
    function advance_left(state)
     {for(;;)
       {var match$12=peek_opt(state[28]);
        if(match$12)
         {var
           match$13=match$12[1],
           size$0=match$13[1],
           length$0=match$13[3],
           token=match$13[2],
           pending_count=state[13] - state[12] | 0,
           _k9_=0 <= size$0?1:0,
           _k__=_k9_ || (state[9] <= pending_count?1:0);
          if(_k__)
           {take(state[28]);
            var size$1=0 <= size$0?size$0:pp_infinity;
            if(typeof token === "number")
             switch(token)
              {case 0:
                var match$3=top_opt(state[3]);
                if(match$3)
                 {var
                   match$4=match$3[1],
                   tabs=match$4[1],
                   add_tab=
                    function(n,ls)
                     {if(ls)
                       {var l=ls[2],x=ls[1];
                        return caml_lessthan(n,x)?[0,n,ls]:[0,x,add_tab(n,l)]}
                      return [0,n,0]};
                  tabs[1] = add_tab(state[6] - state[9] | 0,tabs[1])}
                break;
               case 1:pop_opt(state[2]);break;
               case 2:pop_opt(state[3]);break;
               case 3:
                var match$5=top_opt(state[2]);
                if(match$5)
                 {var match$6=match$5[1],width$0=match$6[2];
                  break_line(state,width$0)}
                else
                 pp_output_newline(state);
                break;
               case 4:
                if(state[10] !== (state[6] - state[9] | 0))
                 {var match$1=take_opt(state[28]);
                  if(match$1)
                   {var match$2=match$1[1],size=match$2[1],length=match$2[3];
                    state[12] = state[12] - length | 0;
                    state[9] = state[9] + size | 0}}
                break;
               default:
                var match$7=pop_opt(state[5]);
                if(match$7)
                 {var
                   tag_name=match$7[1],
                   marker=caml_call1(state[25],tag_name);
                  pp_output_string(state,marker)}}
            else
             switch(token[0])
              {case 0:var s=token[1];format_pp_text(state,size$1,s);break;
               case 1:
                var
                 breaks=token[2],
                 fits=token[1],
                 off=breaks[2],
                 before=breaks[1],
                 match$8=top_opt(state[2]);
                if(match$8)
                 {var
                   match$9=match$8[1],
                   width$1=match$9[2],
                   box_type$0=match$9[1];
                  switch(box_type$0)
                   {case 0:break_same_line(state,fits);break;
                    case 1:break_new_line(state,breaks,width$1);break;
                    case 2:break_new_line(state,breaks,width$1);break;
                    case 3:
                     if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                      break_new_line(state,breaks,width$1);
                     else
                      break_same_line(state,fits);
                     break;
                    case 4:
                     if(state[11])
                      break_same_line(state,fits);
                     else
                      if(state[9] < (size$1 + caml_ml_string_length(before) | 0))
                       break_new_line(state,breaks,width$1);
                      else
                       if(((state[6] - width$1 | 0) + off | 0) < state[10])
                        break_new_line(state,breaks,width$1);
                       else
                        break_same_line(state,fits);
                     break;
                    default:break_same_line(state,fits)}}
                break;
               case 2:
                var
                 off$0=token[2],
                 n=token[1],
                 insertion_point=state[6] - state[9] | 0,
                 match$10=top_opt(state[3]);
                if(match$10)
                 {var match$11=match$10[1],tabs$0=match$11[1],_k7_=tabs$0[1];
                  if(_k7_)
                   {var first=_k7_[1],param=tabs$0[1];
                    for(;;)
                     {if(param)
                       {var tail=param[2],head=param[1];
                        if(! (insertion_point <= head)){var param=tail;continue}
                        var _k8_=head}
                      else
                       var _k8_=first;
                      var tab=_k8_;
                      break}}
                  else
                   var tab=insertion_point;
                  var offset=tab - insertion_point | 0;
                  if(0 <= offset)
                   break_same_line(state,[0,cst$69,offset + n | 0,cst$68]);
                  else
                   break_new_line
                    (state,[0,cst$71,tab + off$0 | 0,cst$70],state[6])}
                break;
               case 3:
                var
                 ty=token[2],
                 off$1=token[1],
                 insertion_point$0=state[6] - state[9] | 0;
                if(state[8] < insertion_point$0)
                 {var match=top_opt(state[2]);
                  if(match)
                   {var match$0=match[1],width=match$0[2],box_type=match$0[1];
                    if(state[9] < width)
                     {var switcher=box_type - 1 | 0;
                      if(! (3 < switcher >>> 0))break_line(state,width)}}
                  else
                   pp_output_newline(state)}
                var
                 width$2=state[9] - off$1 | 0,
                 box_type$1=1 === ty?1:state[9] < size$1?ty:5;
                push([0,box_type$1,width$2],state[2]);
                break;
               case 4:var tbox=token[1];push(tbox,state[3]);break;
               default:
                var
                 tag_name$0=token[1],
                 marker$0=caml_call1(state[24],tag_name$0);
                pp_output_string(state,marker$0);
                push(tag_name$0,state[5])}
            state[12] = length$0 + state[12] | 0;
            continue}
          return _k__}
        return 0}}
    function enqueue_advance(state,tok)
     {pp_enqueue(state,tok);return advance_left(state)}
    function enqueue_string_as(state,size,s)
     {return enqueue_advance(state,[0,size,[0,s],size])}
    function initialize_scan_stack(stack)
     {clear(stack);
      var queue_elem=[0,unknown,_cc_,0];
      return push([0,-1,queue_elem],stack)}
    function set_size(state,ty)
     {var match=top_opt(state[1]);
      if(match)
       {var
         match$0=match[1],
         queue_elem=match$0[2],
         left_total=match$0[1],
         _k4_=queue_elem[1];
        if(left_total < state[12])return initialize_scan_stack(state[1]);
        var _k5_=queue_elem[2];
        if(typeof _k5_ !== "number")
         switch(_k5_[0])
          {case 3:
            var _k6_=1 - ty;
            return _k6_
                    ?(queue_elem[1] = state[13] + _k4_ | 0,pop_opt(state[1]),0)
                    :_k6_;
           case 1:
           case 2:
            return ty
                    ?(queue_elem[1] = state[13] + _k4_ | 0,pop_opt(state[1]),0)
                    :ty
           }
        return 0}
      return 0}
    function scan_push(state,b,token)
     {pp_enqueue(state,token);
      if(b)set_size(state,1);
      var elem=[0,state[13],token];
      return push(elem,state[1])}
    function pp_open_box_gen(state,indent,br_ty)
     {state[14] = state[14] + 1 | 0;
      if(state[14] < state[15])
       {var size=- state[13] | 0,elem=[0,size,[3,indent,br_ty],0];
        return scan_push(state,0,elem)}
      var _k2_=state[14] === state[15]?1:0;
      if(_k2_)
       {var _k3_=state[16];
        return enqueue_string_as(state,caml_ml_string_length(_k3_),_k3_)}
      return _k2_}
    function pp_close_box(state,param)
     {var _k0_=1 < state[14]?1:0;
      if(_k0_)
       {if(state[14] < state[15])
         {pp_enqueue(state,[0,size,1,0]);set_size(state,1);set_size(state,0)}
        state[14] = state[14] - 1 | 0;
        var _k1_=0}
      else
       var _k1_=_k0_;
      return _k1_}
    function pp_open_stag(state,tag_name)
     {if(state[22]){push(tag_name,state[4]);caml_call1(state[26],tag_name)}
      var _kZ_=state[23];
      if(_kZ_)
       {var token=[5,tag_name];return pp_enqueue(state,[0,size,token,0])}
      return _kZ_}
    function pp_close_stag(state,param)
     {if(state[23])pp_enqueue(state,[0,size,5,0]);
      var _kX_=state[22];
      if(_kX_)
       {var match=pop_opt(state[4]);
        if(match){var tag_name=match[1];return caml_call1(state[27],tag_name)}
        var _kY_=0}
      else
       var _kY_=_kX_;
      return _kY_}
    function pp_open_tag(state,s){return pp_open_stag(state,[0,String_tag,s])}
    function pp_close_tag(state,param){return pp_close_stag(state,0)}
    function pp_set_print_tags(state,b){state[22] = b;return 0}
    function pp_set_mark_tags(state,b){state[23] = b;return 0}
    function pp_get_print_tags(state,param){return state[22]}
    function pp_get_mark_tags(state,param){return state[23]}
    function pp_set_tags(state,b)
     {pp_set_print_tags(state,b);return pp_set_mark_tags(state,b)}
    function pp_get_formatter_stag_function(state,param)
     {return [0,state[24],state[25],state[26],state[27]]}
    function pp_set_formatter_stag_function(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      state[24] = mot;
      state[25] = mct;
      state[26] = pot;
      state[27] = pct;
      return 0}
    function pp_rinit(state)
     {state[12] = 1;
      state[13] = 1;
      clear$0(state[28]);
      initialize_scan_stack(state[1]);
      clear(state[2]);
      clear(state[3]);
      clear(state[4]);
      clear(state[5]);
      state[10] = 0;
      state[14] = 0;
      state[9] = state[6];
      return pp_open_box_gen(state,0,3)}
    function pp_flush_queue(state,b)
     {var _kW_=state[4];
      iter$7(function(param){return pp_close_tag(state,0)},_kW_);
      for(;;)
       {if(1 < state[14]){pp_close_box(state,0);continue}
        state[13] = pp_infinity;
        advance_left(state);
        if(b)pp_output_newline(state);
        return pp_rinit(state)}}
    function pp_print_as_size(state,size,s)
     {var _kV_=state[14] < state[15]?1:0;
      return _kV_?enqueue_string_as(state,size,s):_kV_}
    function pp_print_as(state,isize,s)
     {return pp_print_as_size(state,isize,s)}
    function pp_print_string(state,s)
     {return pp_print_as(state,caml_ml_string_length(s),s)}
    function pp_print_int(state,i)
     {return pp_print_string(state,caml_string_of_jsbytes("" + i))}
    function pp_print_float(state,f)
     {return pp_print_string(state,to_string(f))}
    function pp_print_bool(state,b)
     {return pp_print_string(state,string_of_bool(b))}
    function pp_print_char(state,c){return pp_print_as(state,1,make$0(1,c))}
    function pp_open_hbox(state,param){return pp_open_box_gen(state,0,0)}
    function pp_open_vbox(state,indent)
     {return pp_open_box_gen(state,indent,1)}
    function pp_open_hvbox(state,indent)
     {return pp_open_box_gen(state,indent,2)}
    function pp_open_hovbox(state,indent)
     {return pp_open_box_gen(state,indent,3)}
    function pp_open_box(state,indent){return pp_open_box_gen(state,indent,4)}
    function pp_print_newline(state,param)
     {pp_flush_queue(state,1);return caml_call1(state[18],0)}
    function pp_print_flush(state,param)
     {pp_flush_queue(state,0);return caml_call1(state[18],0)}
    function pp_force_newline(state,param)
     {var _kU_=state[14] < state[15]?1:0;
      return _kU_?enqueue_advance(state,[0,size,3,0]):_kU_}
    function pp_print_if_newline(state,param)
     {var _kT_=state[14] < state[15]?1:0;
      return _kT_?enqueue_advance(state,[0,size,4,0]):_kT_}
    function pp_print_custom_break(state,fits,breaks)
     {var
       after=fits[3],
       width=fits[2],
       before=fits[1],
       _kS_=state[14] < state[15]?1:0;
      if(_kS_)
       {var
         size=- state[13] | 0,
         token=[1,fits,breaks],
         length=
          (caml_ml_string_length(before) + width | 0)
          +
          caml_ml_string_length(after)
          |
          0,
         elem=[0,size,token,length];
        return scan_push(state,1,elem)}
      return _kS_}
    function pp_print_break(state,width,offset)
     {return pp_print_custom_break
              (state,[0,cst$75,width,cst$74],[0,cst$73,offset,cst$72])}
    function pp_print_space(state,param){return pp_print_break(state,1,0)}
    function pp_print_cut(state,param){return pp_print_break(state,0,0)}
    function pp_open_tbox(state,param)
     {state[14] = state[14] + 1 | 0;
      var _kR_=state[14] < state[15]?1:0;
      if(_kR_)
       {var elem=[0,size,[4,[0,[0,0]]],0];return enqueue_advance(state,elem)}
      return _kR_}
    function pp_close_tbox(state,param)
     {var _kO_=1 < state[14]?1:0;
      if(_kO_)
       {var _kP_=state[14] < state[15]?1:0;
        if(_kP_)
         {var elem=[0,size,2,0];
          enqueue_advance(state,elem);
          state[14] = state[14] - 1 | 0;
          var _kQ_=0}
        else
         var _kQ_=_kP_}
      else
       var _kQ_=_kO_;
      return _kQ_}
    function pp_print_tbreak(state,width,offset)
     {var _kN_=state[14] < state[15]?1:0;
      if(_kN_)
       {var size=- state[13] | 0,elem=[0,size,[2,width,offset],width];
        return scan_push(state,1,elem)}
      return _kN_}
    function pp_print_tab(state,param){return pp_print_tbreak(state,0,0)}
    function pp_set_tab(state,param)
     {var _kM_=state[14] < state[15]?1:0;
      if(_kM_){var elem=[0,size,0,0];return enqueue_advance(state,elem)}
      return _kM_}
    function pp_set_max_boxes(state,n)
     {var _kK_=1 < n?1:0,_kL_=_kK_?(state[15] = n,0):_kK_;return _kL_}
    function pp_get_max_boxes(state,param){return state[15]}
    function pp_over_max_boxes(state,param)
     {return state[14] === state[15]?1:0}
    function pp_set_ellipsis_text(state,s){state[16] = s;return 0}
    function pp_get_ellipsis_text(state,param){return state[16]}
    function pp_limit(n){return n < 1000000010?n:1000000009}
    function pp_set_max_indent(state,n$0)
     {var _kJ_=1 < n$0?1:0;
      if(_kJ_)
       {var n$1=state[6] - n$0 | 0,_kI_=1 <= n$1?1:0;
        if(_kI_)
         {var n=pp_limit(n$1);
          state[7] = n;
          state[8] = state[6] - state[7] | 0;
          return pp_rinit(state)}
        return _kI_}
      return _kJ_}
    function pp_get_max_indent(state,param){return state[8]}
    function pp_set_margin(state,n)
     {var _kH_=1 <= n?1:0;
      if(_kH_)
       {var n$0=pp_limit(n);
        state[6] = n$0;
        var
         new_max_indent=
          state[8] <= state[6]
           ?state[8]
           :max(max(state[6] - state[7] | 0,state[6] / 2 | 0),1);
        return pp_set_max_indent(state,new_max_indent)}
      return _kH_}
    function validate_geometry(param)
     {var margin=param[2],max_indent=param[1];
      return 2 <= max_indent?margin <= max_indent?_cd_:_ce_:_cf_}
    function check_geometry(geometry)
     {var match=validate_geometry(geometry);return 0 === match[0]?1:0}
    function pp_get_margin(state,param){return state[6]}
    function pp_set_full_geometry(state,param)
     {var margin=param[2],max_indent=param[1];
      pp_set_margin(state,margin);
      pp_set_max_indent(state,max_indent);
      return 0}
    function pp_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      if(0 === match[0])return pp_set_full_geometry(state,geometry);
      var msg=match[1];
      throw [0,Invalid_argument,symbol(cst_Format_pp_set_geometry,msg)]}
    function pp_safe_set_geometry(state,max_indent,margin)
     {var geometry=[0,max_indent,margin],match=validate_geometry(geometry);
      return 0 === match[0]?pp_set_full_geometry(state,geometry):0}
    function pp_get_geometry(state,param){return [0,state[8],state[6]]}
    function pp_update_geometry(state,update)
     {var geometry=pp_get_geometry(state,0);
      return pp_set_full_geometry(state,caml_call1(update,geometry))}
    function pp_set_formatter_out_functions(state,param)
     {var j=param[5],i=param[4],h=param[3],g=param[2],f=param[1];
      state[17] = f;
      state[18] = g;
      state[19] = h;
      state[20] = i;
      state[21] = j;
      return 0}
    function pp_get_formatter_out_functions(state,param)
     {return [0,state[17],state[18],state[19],state[20],state[21]]}
    function pp_set_formatter_output_functi(state,f,g)
     {state[17] = f;state[18] = g;return 0}
    function pp_get_formatter_output_functi(state,param)
     {return [0,state[17],state[18]]}
    function display_newline(state,param)
     {return caml_call3(state[17],cst$76,0,1)}
    var blank_line=make$0(80,32);
    function display_indent(state,n)
     {var n$0=n;
      for(;;)
       {var _kG_=0 < n$0?1:0;
        if(_kG_)
         {if(80 < n$0)
           {caml_call3(state[17],blank_line,0,80);
            var n$1=n$0 - 80 | 0,n$0=n$1;
            continue}
          return caml_call3(state[17],blank_line,0,n$0)}
        return _kG_}}
    function pp_set_formatter_out_channel(state,oc)
     {state[17]
      =
      function(_kD_,_kE_,_kF_){return output_substring(oc,_kD_,_kE_,_kF_)};
      state[18] = function(param){return caml_ml_flush(oc)};
      state[19] = function(_kC_){return display_newline(state,_kC_)};
      state[20] = function(_kB_){return display_indent(state,_kB_)};
      state[21] = function(_kA_){return display_indent(state,_kA_)};
      return 0}
    function default_pp_mark_open_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$78,symbol(s,cst$77))}
      return cst$79}
    function default_pp_mark_close_tag(param)
     {if(param[1] === String_tag)
       {var s=param[2];return symbol(cst$81,symbol(s,cst$80))}
      return cst$82}
    function default_pp_print_open_tag(_kz_){return 0}
    function default_pp_print_close_tag(_ky_){return 0}
    function pp_make_formatter(f,g,h,i,j)
     {var pp_queue=create$1(0),sys_tok=[0,unknown,_cg_,0];
      add(sys_tok,pp_queue);
      var scan_stack=create$0(0);
      initialize_scan_stack(scan_stack);
      push([0,1,sys_tok],scan_stack);
      var _kv_=create$0(0),_kw_=create$0(0),_kx_=create$0(0);
      return [0,
              scan_stack,
              create$0(0),
              _kx_,
              _kw_,
              _kv_,
              78,
              10,
              68,
              78,
              0,
              1,
              1,
              1,
              1,
              max_int,
              cst$83,
              f,
              g,
              h,
              i,
              j,
              0,
              0,
              default_pp_mark_open_tag,
              default_pp_mark_close_tag,
              default_pp_print_open_tag,
              default_pp_print_close_tag,
              pp_queue]}
    function formatter_of_out_functions(out_funs)
     {return pp_make_formatter
              (out_funs[1],out_funs[2],out_funs[3],out_funs[4],out_funs[5])}
    function make_formatter(output,flush)
     {function _kn_(_ku_){return 0}
      function _ko_(_kt_){return 0}
      var
       ppf=
        pp_make_formatter(output,flush,function(_ks_){return 0},_ko_,_kn_);
      ppf[19] = function(_kr_){return display_newline(ppf,_kr_)};
      ppf[20] = function(_kq_){return display_indent(ppf,_kq_)};
      ppf[21] = function(_kp_){return display_indent(ppf,_kp_)};
      return ppf}
    function formatter_of_out_channel(oc)
     {function _kj_(param){return caml_ml_flush(oc)}
      return make_formatter
              (function(_kk_,_kl_,_km_)
                {return output_substring(oc,_kk_,_kl_,_km_)},
               _kj_)}
    function formatter_of_buffer(b)
     {function _ke_(_ki_){return 0}
      return make_formatter
              (function(_kf_,_kg_,_kh_)
                {return add_substring(b,_kf_,_kg_,_kh_)},
               _ke_)}
    var pp_buffer_size=512;
    function pp_make_buffer(param){return create$2(pp_buffer_size)}
    var
     stdbuf=pp_make_buffer(0),
     std_formatter=formatter_of_out_channel(stdout),
     err_formatter=formatter_of_out_channel(stderr),
     str_formatter=formatter_of_buffer(stdbuf);
    function flush_buffer_formatter(buf,ppf)
     {pp_flush_queue(ppf,0);var s=contents(buf);reset(buf);return s}
    function flush_str_formatter(param)
     {return flush_buffer_formatter(stdbuf,str_formatter)}
    function make_symbolic_output_buffer(param){return [0,0]}
    function clear_symbolic_output_buffer(sob){sob[1] = 0;return 0}
    function get_symbolic_output_buffer(sob){return rev(sob[1])}
    function flush_symbolic_output_buffer(sob)
     {var items=get_symbolic_output_buffer(sob);
      clear_symbolic_output_buffer(sob);
      return items}
    function add_symbolic_output_item(sob,item)
     {sob[1] = [0,item,sob[1]];return 0}
    function formatter_of_symbolic_output_b(sob)
     {function f(s,i,n){return add_symbolic_output_item(sob,[0,sub$0(s,i,n)])}
      function g(_kd_){return add_symbolic_output_item(sob,0)}
      function h(_kc_){return add_symbolic_output_item(sob,1)}
      function i(n){return add_symbolic_output_item(sob,[1,n])}
      function j(n){return add_symbolic_output_item(sob,[2,n])}
      return pp_make_formatter(f,g,h,i,j)}
    function open_hbox(_kb_){return pp_open_hbox(std_formatter,_kb_)}
    function open_vbox(_ka_){return pp_open_vbox(std_formatter,_ka_)}
    function open_hvbox(_j$_){return pp_open_hvbox(std_formatter,_j$_)}
    function open_hovbox(_j__){return pp_open_hovbox(std_formatter,_j__)}
    function open_box(_j9_){return pp_open_box(std_formatter,_j9_)}
    function close_box(_j8_){return pp_close_box(std_formatter,_j8_)}
    function open_tag(_j7_){return pp_open_tag(std_formatter,_j7_)}
    function close_tag(_j6_){return pp_close_tag(std_formatter,_j6_)}
    function open_stag(_j5_){return pp_open_stag(std_formatter,_j5_)}
    function close_stag(_j4_){return pp_close_stag(std_formatter,_j4_)}
    function print_as(_j2_,_j3_){return pp_print_as(std_formatter,_j2_,_j3_)}
    function print_string$0(_j1_){return pp_print_string(std_formatter,_j1_)}
    function print_int$0(_j0_){return pp_print_int(std_formatter,_j0_)}
    function print_float$0(_jZ_){return pp_print_float(std_formatter,_jZ_)}
    function print_char$0(_jY_){return pp_print_char(std_formatter,_jY_)}
    function print_bool(_jX_){return pp_print_bool(std_formatter,_jX_)}
    function print_break(_jV_,_jW_)
     {return pp_print_break(std_formatter,_jV_,_jW_)}
    function print_cut(_jU_){return pp_print_cut(std_formatter,_jU_)}
    function print_space(_jT_){return pp_print_space(std_formatter,_jT_)}
    function force_newline(_jS_){return pp_force_newline(std_formatter,_jS_)}
    function print_flush(_jR_){return pp_print_flush(std_formatter,_jR_)}
    function print_newline$0(_jQ_)
     {return pp_print_newline(std_formatter,_jQ_)}
    function print_if_newline(_jP_)
     {return pp_print_if_newline(std_formatter,_jP_)}
    function open_tbox(_jO_){return pp_open_tbox(std_formatter,_jO_)}
    function close_tbox(_jN_){return pp_close_tbox(std_formatter,_jN_)}
    function print_tbreak(_jL_,_jM_)
     {return pp_print_tbreak(std_formatter,_jL_,_jM_)}
    function set_tab(_jK_){return pp_set_tab(std_formatter,_jK_)}
    function print_tab(_jJ_){return pp_print_tab(std_formatter,_jJ_)}
    function set_margin(_jI_){return pp_set_margin(std_formatter,_jI_)}
    function get_margin(_jH_){return std_formatter[6]}
    function set_max_indent(_jG_)
     {return pp_set_max_indent(std_formatter,_jG_)}
    function get_max_indent(_jF_){return std_formatter[8]}
    function set_geometry(_jD_,_jE_)
     {return pp_set_geometry(std_formatter,_jD_,_jE_)}
    function safe_set_geometry(_jB_,_jC_)
     {return pp_safe_set_geometry(std_formatter,_jB_,_jC_)}
    function get_geometry(_jA_){return pp_get_geometry(std_formatter,_jA_)}
    function update_geometry(_jz_)
     {return pp_update_geometry(std_formatter,_jz_)}
    function set_max_boxes(_jy_){return pp_set_max_boxes(std_formatter,_jy_)}
    function get_max_boxes(_jx_){return std_formatter[15]}
    function over_max_boxes(_jw_)
     {return pp_over_max_boxes(std_formatter,_jw_)}
    function set_ellipsis_text(_jv_)
     {return pp_set_ellipsis_text(std_formatter,_jv_)}
    function get_ellipsis_text(_ju_){return std_formatter[16]}
    function set_formatter_out_channel(_jt_)
     {return pp_set_formatter_out_channel(std_formatter,_jt_)}
    function set_formatter_out_functions(_js_)
     {return pp_set_formatter_out_functions(std_formatter,_js_)}
    function get_formatter_out_functions(_jr_)
     {return pp_get_formatter_out_functions(std_formatter,_jr_)}
    function set_formatter_output_functions(_jp_,_jq_)
     {return pp_set_formatter_output_functi(std_formatter,_jp_,_jq_)}
    function get_formatter_output_functions(_jo_)
     {return pp_get_formatter_output_functi(std_formatter,_jo_)}
    function set_formatter_stag_functions(_jn_)
     {return pp_set_formatter_stag_function(std_formatter,_jn_)}
    function get_formatter_stag_functions(_jm_)
     {return pp_get_formatter_stag_function(std_formatter,_jm_)}
    function set_print_tags(_jl_)
     {return pp_set_print_tags(std_formatter,_jl_)}
    function get_print_tags(_jk_){return std_formatter[22]}
    function set_mark_tags(_jj_){return pp_set_mark_tags(std_formatter,_jj_)}
    function get_mark_tags(_ji_){return std_formatter[23]}
    function set_tags(_jh_){return pp_set_tags(std_formatter,_jh_)}
    function pp_print_list(opt,pp_v,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=pp_print_cut;
        if(param$0)
         {var _jg_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp_v,ppf,_jg_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp_v,ppf,_jg_)}
        return 0}}
    function pp_print_text(ppf,s)
     {var len=caml_ml_string_length(s),left=[0,0],right=[0,0];
      function flush(param)
       {pp_print_string(ppf,sub$0(s,left[1],right[1] - left[1] | 0));
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {var match=caml_string_get(s,right[1]);
          if(10 === match)
           {flush(0);pp_force_newline(ppf,0)}
          else
           if(32 === match){flush(0);pp_print_space(ppf,0)}else right[1]++;
          continue}
        var _jf_=left[1] !== len?1:0;
        return _jf_?flush(0):_jf_}}
    function pp_print_option(opt,pp_v,ppf,param)
     {if(opt)
       var sth=opt[1],none=sth;
      else
       var none=function(param,_je_){return 0};
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(none,ppf,0)}
    function pp_print_result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function compute_tag(output,tag_acc)
     {var buf=create$2(16),ppf=formatter_of_buffer(buf);
      caml_call2(output,ppf,tag_acc);
      pp_print_flush(ppf,0);
      var len=buf[2];
      return 2 <= len?sub$3(buf,1,len - 2 | 0):contents(buf)}
    function output_formatting_lit(ppf,fmting_lit)
     {if(typeof fmting_lit === "number")
       switch(fmting_lit)
        {case 0:return pp_close_box(ppf,0);
         case 1:return pp_close_tag(ppf,0);
         case 2:return pp_print_flush(ppf,0);
         case 3:return pp_force_newline(ppf,0);
         case 4:return pp_print_newline(ppf,0);
         case 5:return pp_print_char(ppf,64);
         default:return pp_print_char(ppf,37)}
      else
       switch(fmting_lit[0])
        {case 0:
          var offset=fmting_lit[3],width=fmting_lit[2];
          return pp_print_break(ppf,width,offset);
         case 1:return 0;
         default:
          var c=fmting_lit[1];
          pp_print_char(ppf,64);
          return pp_print_char(ppf,c)}}
    function output_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          output_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _i6_=acc[2],_i7_=acc[1];
          if(0 === _i6_[0])
           {var acc$0=_i6_[1];
            output_acc$0(ppf,_i7_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(output_acc$0,acc$0)])}
          var acc$1=_i6_[1];
          output_acc$0(ppf,_i7_);
          var
           match=open_box_of_string(compute_tag(output_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _i8_=acc[1],switch$1=0;
          if(typeof _i8_ !== "number" && 0 === _i8_[0])
           {var _i9_=_i8_[2],switch$2=0;
            if(typeof _i9_ !== "number" && 1 === _i9_[0])
             {var s$0=acc[2],size=_i9_[2],p$1=_i8_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_i8_;switch$0 = 2}
          break;
         case 3:
          var _i__=acc[1],switch$3=0;
          if(typeof _i__ !== "number" && 0 === _i__[0])
           {var _i$_=_i__[2],switch$4=0;
            if(typeof _i$_ !== "number" && 1 === _i$_[0])
             {var c$0=acc[2],size$0=_i$_[2],p$3=_i__[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_i__;switch$0 = 3}
          break;
         case 4:
          var _ja_=acc[1],switch$5=0;
          if(typeof _ja_ !== "number" && 0 === _ja_[0])
           {var _jb_=_ja_[2],switch$6=0;
            if(typeof _jb_ !== "number" && 1 === _jb_[0])
             {var s$0=acc[2],size=_jb_[2],p$1=_ja_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_ja_;switch$0 = 2}
          break;
         case 5:
          var _jc_=acc[1],switch$7=0;
          if(typeof _jc_ === "number" || ! (0 === _jc_[0]))
           switch$7 = 1;
          else
           {var _jd_=_jc_[2],switch$8=0;
            if(typeof _jd_ !== "number" && 1 === _jd_[0])
             {var c$0=acc[2],size$0=_jd_[2],p$3=_jc_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_jc_;switch$0 = 3}
          break;
         case 6:
          var f$0=acc[2],p$4=acc[1];
          output_acc$0(ppf,p$4);
          return caml_call1(f$0,ppf);
         case 7:
          var p$5=acc[1];output_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          output_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:output_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         output_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:output_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:output_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function strput_acc$0(ppf,acc)
     {var switch$0=0;
      if(typeof acc === "number")
       return 0;
      else
       switch(acc[0])
        {case 0:
          var f=acc[2],p=acc[1];
          strput_acc$0(ppf,p);
          return output_formatting_lit(ppf,f);
         case 1:
          var _iU_=acc[2],_iV_=acc[1];
          if(0 === _iU_[0])
           {var acc$0=_iU_[1];
            strput_acc$0(ppf,_iV_);
            return pp_open_stag
                    (ppf,[0,String_tag,compute_tag(strput_acc$0,acc$0)])}
          var acc$1=_iU_[1];
          strput_acc$0(ppf,_iV_);
          var
           match=open_box_of_string(compute_tag(strput_acc$0,acc$1)),
           bty=match[2],
           indent=match[1];
          return pp_open_box_gen(ppf,indent,bty);
         case 2:
          var _iW_=acc[1],switch$1=0;
          if(typeof _iW_ !== "number" && 0 === _iW_[0])
           {var _iX_=_iW_[2],switch$2=0;
            if(typeof _iX_ !== "number" && 1 === _iX_[0])
             {var s$0=acc[2],size=_iX_[2],p$1=_iW_[1];
              switch$1 = 1;
              switch$2 = 1}}
          if(! switch$1){var s=acc[2],p$0=_iW_;switch$0 = 2}
          break;
         case 3:
          var _iY_=acc[1],switch$3=0;
          if(typeof _iY_ !== "number" && 0 === _iY_[0])
           {var _iZ_=_iY_[2],switch$4=0;
            if(typeof _iZ_ !== "number" && 1 === _iZ_[0])
             {var c$0=acc[2],size$0=_iZ_[2],p$3=_iY_[1];
              switch$0 = 1;
              switch$3 = 1;
              switch$4 = 1}}
          if(! switch$3){var c=acc[2],p$2=_iY_;switch$0 = 3}
          break;
         case 4:
          var _i0_=acc[1],switch$5=0;
          if(typeof _i0_ !== "number" && 0 === _i0_[0])
           {var _i1_=_i0_[2],switch$6=0;
            if(typeof _i1_ !== "number" && 1 === _i1_[0])
             {var s$0=acc[2],size=_i1_[2],p$1=_i0_[1];
              switch$5 = 1;
              switch$6 = 1}}
          if(! switch$5){var s=acc[2],p$0=_i0_;switch$0 = 2}
          break;
         case 5:
          var _i2_=acc[1],switch$7=0;
          if(typeof _i2_ === "number" || ! (0 === _i2_[0]))
           switch$7 = 1;
          else
           {var _i3_=_i2_[2],switch$8=0;
            if(typeof _i3_ !== "number" && 1 === _i3_[0])
             {var c$0=acc[2],size$0=_i3_[2],p$3=_i2_[1];
              switch$0 = 1;
              switch$8 = 1}
            if(! switch$8)switch$7 = 1}
          if(switch$7){var c=acc[2],p$2=_i2_;switch$0 = 3}
          break;
         case 6:
          var _i4_=acc[1];
          if(typeof _i4_ !== "number" && 0 === _i4_[0])
           {var _i5_=_i4_[2];
            if(typeof _i5_ !== "number" && 1 === _i5_[0])
             {var f$1=acc[2],size$1=_i5_[2],p$4=_i4_[1];
              strput_acc$0(ppf,p$4);
              return pp_print_as_size(ppf,size$1,caml_call1(f$1,0))}}
          var f$0=acc[2];
          strput_acc$0(ppf,_i4_);
          return pp_print_string(ppf,caml_call1(f$0,0));
         case 7:
          var p$5=acc[1];strput_acc$0(ppf,p$5);return pp_print_flush(ppf,0);
         default:
          var msg=acc[2],p$6=acc[1];
          strput_acc$0(ppf,p$6);
          return invalid_arg(msg)}
      switch(switch$0)
       {case 0:strput_acc$0(ppf,p$1);return pp_print_as_size(ppf,size,s$0);
        case 1:
         strput_acc$0(ppf,p$3);
         return pp_print_as_size(ppf,size$0,make$0(1,c$0));
        case 2:strput_acc$0(ppf,p$0);return pp_print_string(ppf,s);
        default:strput_acc$0(ppf,p$2);return pp_print_char(ppf,c)}}
    function kfprintf$0(k,ppf,param)
     {var fmt=param[1],_iT_=0;
      return make_printf
              (function(acc){output_acc$0(ppf,acc);return caml_call1(k,ppf)},
               _iT_,
               fmt)}
    function ikfprintf$0(k,ppf,param)
     {var fmt=param[1];return make_iprintf(k,ppf,fmt)}
    function ifprintf$0(ppf,param)
     {var fmt=param[1],_iR_=0;
      return make_iprintf(function(_iS_){return 0},_iR_,fmt)}
    function fprintf$0(ppf)
     {function _iO_(_iQ_){return 0}
      return function(_iP_){return kfprintf$0(_iO_,ppf,_iP_)}}
    function printf$0(fmt){return caml_call1(fprintf$0(std_formatter),fmt)}
    function eprintf$0(fmt){return caml_call1(fprintf$0(err_formatter),fmt)}
    function kdprintf(k,param)
     {var fmt=param[1],_iN_=0;
      return make_printf
              (function(acc)
                {return caml_call1
                         (k,function(ppf){return output_acc$0(ppf,acc)})},
               _iN_,
               fmt)}
    function dprintf(fmt){return kdprintf(function(i){return i},fmt)}
    function kprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {strput_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function sprintf$0(fmt){return kprintf(id$0,fmt)}
    function kasprintf(k,param)
     {var fmt=param[1],b=pp_make_buffer(0),ppf=formatter_of_buffer(b);
      function k$0(acc)
       {output_acc$0(ppf,acc);
        return caml_call1(k,flush_buffer_formatter(b,ppf))}
      return make_printf(k$0,0,fmt)}
    function asprintf(fmt){return kasprintf(id$0,fmt)}
    function flush_standard_formatters(param)
     {pp_print_flush(std_formatter,0);return pp_print_flush(err_formatter,0)}
    at_exit(flush_standard_formatters);
    function pp_set_all_formatter_output_fu(state,f,g,h,i)
     {pp_set_formatter_output_functi(state,f,g);
      state[19] = h;
      state[20] = i;
      return 0}
    function pp_get_all_formatter_output_fu(state,param)
     {return [0,state[17],state[18],state[19],state[20]]}
    function set_all_formatter_output_funct(_iJ_,_iK_,_iL_,_iM_)
     {return pp_set_all_formatter_output_fu(std_formatter,_iJ_,_iK_,_iL_,_iM_)}
    function get_all_formatter_output_funct(_iI_)
     {return pp_get_all_formatter_output_fu(std_formatter,_iI_)}
    function bprintf$0(b,param)
     {var fmt=param[1],ppf=formatter_of_buffer(b);
      function k(acc){output_acc$0(ppf,acc);return pp_flush_queue(ppf,0)}
      return make_printf(k,0,fmt)}
    function pp_set_formatter_tag_functions(state,param)
     {var pct=param[4],pot=param[3],mct=param[2],mot=param[1];
      function stringify(f,e,param)
       {if(param[1] === String_tag){var s=param[2];return caml_call1(f,s)}
        return e}
      state[24] = function(_iH_){return stringify(mot,cst$84,_iH_)};
      state[25] = function(_iG_){return stringify(mct,cst$85,_iG_)};
      var _iC_=0;
      state[26] = function(_iF_){return stringify(pot,_iC_,_iF_)};
      var _iD_=0;
      state[27] = function(_iE_){return stringify(pct,_iD_,_iE_)};
      return 0}
    function pp_get_formatter_tag_functions(fmt,param)
     {var funs=pp_get_formatter_stag_function(fmt,0);
      function mark_open_tag(s){return caml_call1(funs[1],[0,String_tag,s])}
      function mark_close_tag(s){return caml_call1(funs[2],[0,String_tag,s])}
      function print_open_tag(s){return caml_call1(funs[3],[0,String_tag,s])}
      function print_close_tag(s){return caml_call1(funs[4],[0,String_tag,s])}
      return [0,mark_open_tag,mark_close_tag,print_open_tag,print_close_tag]}
    function set_formatter_tag_functions(_iB_)
     {return pp_set_formatter_tag_functions(std_formatter,_iB_)}
    function get_formatter_tag_functions(_iA_)
     {return pp_get_formatter_tag_functions(std_formatter,_iA_)}
    var
     Stdlib_format=
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string$0,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int$0,
       pp_print_float,
       print_float$0,
       pp_print_char,
       print_char$0,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline$0,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       fprintf$0,
       printf$0,
       eprintf$0,
       sprintf$0,
       asprintf,
       dprintf,
       ifprintf$0,
       kfprintf$0,
       kdprintf,
       ikfprintf$0,
       kprintf,
       kasprintf,
       bprintf$0,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions];
    caml_register_global(794,Stdlib_format,"Stdlib__format");
    var null_char=0;
    function next_char(ib)
     {try
       {var c=caml_call1(ib[7],0);
        ib[2] = c;
        ib[3] = 1;
        ib[4] = ib[4] + 1 | 0;
        if(10 === c)ib[5] = ib[5] + 1 | 0;
        return c}
      catch(_iz_)
       {_iz_ = caml_wrap_exception(_iz_);
        if(_iz_ === End_of_file)
         {ib[2] = null_char;ib[3] = 0;ib[1] = 1;return null_char}
        throw _iz_}}
    function peek_char(ib){return ib[3]?ib[2]:next_char(ib)}
    function checked_peek_char(ib)
     {var c=peek_char(ib);if(ib[1])throw End_of_file;return c}
    function end_of_input(ib){peek_char(ib);return ib[1]}
    function beginning_of_input(ib){return 0 === ib[4]?1:0}
    function name_of_input(ib)
     {var _iy_=ib[9];
      if(typeof _iy_ === "number")
       return 0 === _iy_?cst_unnamed_function:cst_unnamed_character_string;
      else
       {if(0 === _iy_[0])return cst_unnamed_Stdlib_input_chann;
        var fname=_iy_[1];
        return fname}}
    function char_count(ib){return ib[3]?ib[4] - 1 | 0:ib[4]}
    function reset_token(ib){return reset(ib[8])}
    function invalidate_current_char(ib){ib[3] = 0;return 0}
    function token_string(ib)
     {var token_buffer=ib[8],tok=contents(token_buffer);
      clear$1(token_buffer);
      ib[6] = ib[6] + 1 | 0;
      return tok}
    function skip_char(width,ib){invalidate_current_char(ib);return width}
    function ignore_char(width,ib){return skip_char(width - 1 | 0,ib)}
    function store_char(width,ib,c)
     {add_char(ib[8],c);return ignore_char(width,ib)}
    var default_token_buffer_size=1024;
    function create$4(iname,next)
     {return [0,
              0,
              null_char,
              0,
              0,
              0,
              0,
              next,
              create$2(default_token_buffer_size),
              iname]}
    function from_string$1(s)
     {var i=[0,0],len=caml_ml_string_length(s);
      function next(param)
       {if(len <= i[1])throw End_of_file;
        var c=caml_string_get(s,i[1]);
        i[1]++;
        return c}
      return create$4(1,next)}
    var _ch_=0;
    function from_function$0(_ix_){return create$4(_ch_,_ix_)}
    var len=1024;
    function scan_close_at_end(ic)
     {caml_ml_close_channel(ic);throw End_of_file}
    function scan_raise_at_end(ic){throw End_of_file}
    function from_ic(scan_close_ic,iname,ic)
     {var buf=caml_create_bytes(1024),i=[0,0],lim=[0,0],eof=[0,0];
      function next(param)
       {if(i[1] < lim[1]){var c=caml_bytes_get(buf,i[1]);i[1]++;return c}
        if(eof[1])throw End_of_file;
        lim[1] = input(ic,buf,0,len);
        return 0 === lim[1]
                ?(eof[1] = 1,caml_call1(scan_close_ic,ic))
                :(i[1] = 1,caml_bytes_get(buf,0))}
      return create$4(iname,next)}
    var stdib=from_ic(scan_raise_at_end,[1,cst$86,stdin],stdin);
    function open_in_file(open_in,fname)
     {if(caml_string_notequal(fname,cst$87))
       {var ic=caml_call1(open_in,fname);
        return from_ic(scan_close_at_end,[1,fname,ic],ic)}
      return stdib}
    function from_file(_iw_){return open_in_file(open_in,_iw_)}
    function from_file_bin(_iv_){return open_in_file(open_in_bin,_iv_)}
    function from_channel$0(ic){return from_ic(scan_raise_at_end,[0,ic],ic)}
    function close_in$0(ib)
     {var _iu_=ib[9];
      if(typeof _iu_ === "number")
       return 0;
      else
       {if(0 === _iu_[0]){var ic=_iu_[1];return caml_ml_close_channel(ic)}
        var ic$0=_iu_[2];
        return caml_ml_close_channel(ic$0)}}
    var memo=[0,0];
    function memo_from_ic(scan_close_ic,ic)
     {try
       {var _is_=assq(ic,memo[1]);return _is_}
      catch(_it_)
       {_it_ = caml_wrap_exception(_it_);
        if(_it_ === Not_found)
         {var ib=from_ic(scan_close_ic,[0,ic],ic);
          memo[1] = [0,[0,ic,ib],memo[1]];
          return ib}
        throw _it_}}
    function memo_from_channel(_ir_)
     {return memo_from_ic(scan_raise_at_end,_ir_)}
    var Scan_failure=[248,cst_Stdlib_Scanf_Scan_failure,caml_fresh_oo_id(0)];
    function bad_input(s){throw [0,Scan_failure,s]}
    function bad_input_escape(c)
     {return bad_input(caml_call1(sprintf(_ci_),c))}
    function bad_token_length(message)
     {return bad_input(caml_call1(sprintf(_cj_),message))}
    function bad_float(param)
     {return bad_input(cst_no_dot_or_exponent_part_fo)}
    function bad_hex_float(param)
     {return bad_input(cst_not_a_valid_float_in_hexad)}
    function character_mismatch(c,ci)
     {return bad_input(caml_call2(sprintf(_cl_),c,ci))}
    function check_this_char(ib,c)
     {var ci=checked_peek_char(ib);
      return ci === c?invalidate_current_char(ib):character_mismatch(c,ci)}
    function check_char(ib,c$0)
     {if(10 === c$0)
       {var ci=checked_peek_char(ib);
        return 10 === ci
                ?invalidate_current_char(ib)
                :13 === ci
                  ?(invalidate_current_char(ib),check_this_char(ib,10))
                  :character_mismatch(10,ci)}
      if(32 === c$0)
       for(;;)
        {var c=peek_char(ib),_ip_=1 - ib[1];
         if(_ip_)
          {var _iq_=c - 9 | 0,switch$0=0;
           if(4 < _iq_ >>> 0)
            {if(23 === _iq_)switch$0 = 1}
           else
            if(1 < (_iq_ - 2 | 0) >>> 0)switch$0 = 1;
           if(switch$0){invalidate_current_char(ib);continue}
           return 0}
         return _ip_}
      return check_this_char(ib,c$0)}
    function token_char(ib){return caml_string_get(token_string(ib),0)}
    function token_bool(ib)
     {var s=token_string(ib);
      return caml_string_notequal(s,cst_false$3)
              ?caml_string_notequal(s,cst_true$3)
                ?bad_input(caml_call1(sprintf(_cm_),s))
                :1
              :0}
    function integer_conversion_of_char(param)
     {var switcher=param - 88 | 0;
      if(! (32 < switcher >>> 0))
       switch(switcher)
        {case 10:return 0;
         case 12:return 1;
         case 17:return 2;
         case 23:return 3;
         case 29:return 4;
         case 0:
         case 32:return 5
         }
      throw [0,Assert_failure,_cn_]}
    function token_int_literal(conv,ib)
     {switch(conv)
       {case 0:var tok=symbol(cst_0b,token_string(ib));break;
        case 3:var tok=symbol(cst_0o,token_string(ib));break;
        case 4:var tok=symbol(cst_0u,token_string(ib));break;
        case 5:var tok=symbol(cst_0x,token_string(ib));break;
        default:var tok=token_string(ib)}
      var l=caml_ml_string_length(tok);
      if(0 !== l && 43 === caml_string_get(tok,0))
       return sub$0(tok,1,l - 1 | 0);
      return tok}
    function token_float(ib){return caml_float_of_string(token_string(ib))}
    function scan_decimal_digit_star(width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(58 <= c)
         {if(95 === c)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}}
        else
         if(48 <= c)
          {var width$2=store_char(width$0,ib,c),width$0=width$2;continue}
        return width$0}}
    function scan_unsigned_decimal_int(width,ib)
     {if(0 === width)return bad_token_length(cst_decimal_digits);
      var c=checked_peek_char(ib),switcher=c - 48 | 0;
      if(9 < switcher >>> 0)return bad_input(caml_call1(sprintf(_co_),c));
      var width$0=store_char(width,ib,c);
      return scan_decimal_digit_star(width$0,ib)}
    function scan_digit_plus(basis,digitp,width$2,ib)
     {if(0 === width$2)return bad_token_length(cst_digits);
      var c$0=checked_peek_char(ib);
      if(caml_call1(digitp,c$0))
       {var width$3=store_char(width$2,ib,c$0),width=width$3;
        for(;;)
         {if(0 === width)return width;
          var c=peek_char(ib);
          if(ib[1])return width;
          if(caml_call1(digitp,c))
           {var width$0=store_char(width,ib,c),width=width$0;continue}
          if(95 === c)
           {var width$1=ignore_char(width,ib),width=width$1;continue}
          return width}}
      return bad_input(caml_call2(sprintf(_cp_),c$0,basis))}
    function is_binary_digit(param)
     {var switcher=param - 48 | 0;return 1 < switcher >>> 0?0:1}
    function scan_binary_int(_in_,_io_)
     {return scan_digit_plus(cst_binary,is_binary_digit,_in_,_io_)}
    function is_octal_digit(param)
     {var switcher=param - 48 | 0;return 7 < switcher >>> 0?0:1}
    function scan_octal_int(_il_,_im_)
     {return scan_digit_plus(cst_octal,is_octal_digit,_il_,_im_)}
    function is_hexa_digit(param)
     {var _ik_=param - 48 | 0,switch$0=0;
      if(22 < _ik_ >>> 0)
       {if(! (5 < (_ik_ - 49 | 0) >>> 0))switch$0 = 1}
      else
       if(6 < (_ik_ - 10 | 0) >>> 0)switch$0 = 1;
      return switch$0?1:0}
    function scan_hexadecimal_int(_ii_,_ij_)
     {return scan_digit_plus(cst_hexadecimal,is_hexa_digit,_ii_,_ij_)}
    function scan_sign(width,ib)
     {var c=checked_peek_char(ib),switcher=c - 43 | 0;
      if(! (2 < switcher >>> 0))
       switch(switcher)
        {case 0:return store_char(width,ib,c);
         case 1:break;
         default:return store_char(width,ib,c)}
      return width}
    function scan_optionally_signed_decimal(width,ib)
     {var width$0=scan_sign(width,ib);
      return scan_unsigned_decimal_int(width$0,ib)}
    function scan_int_conversion(conv,width$1,ib)
     {switch(conv)
       {case 0:return scan_binary_int(width$1,ib);
        case 1:return scan_optionally_signed_decimal(width$1,ib);
        case 2:
         var width$0=scan_sign(width$1,ib),c=checked_peek_char(ib);
         if(48 === c)
          {var width=store_char(width$0,ib,c);
           if(0 === width)return width;
           var c$0=peek_char(ib);
           if(ib[1])return width;
           var switch$0=0;
           if(99 <= c$0)
            {if(111 === c$0)
              return scan_octal_int(store_char(width,ib,c$0),ib);
             if(120 === c$0)switch$0 = 1}
           else
            if(88 === c$0)
             switch$0 = 1;
            else
             if(98 <= c$0)return scan_binary_int(store_char(width,ib,c$0),ib);
           return switch$0
                   ?scan_hexadecimal_int(store_char(width,ib,c$0),ib)
                   :scan_decimal_digit_star(width,ib)}
         return scan_unsigned_decimal_int(width$0,ib);
        case 3:return scan_octal_int(width$1,ib);
        case 4:return scan_unsigned_decimal_int(width$1,ib);
        default:return scan_hexadecimal_int(width$1,ib)}}
    function scan_fractional_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      var switcher=c - 48 | 0;
      return 9 < switcher >>> 0
              ?width
              :scan_decimal_digit_star(store_char(width,ib,c),ib)}
    function scan_exponent_part(width,ib)
     {if(0 === width)return width;
      var c=peek_char(ib);
      if(ib[1])return width;
      if(69 !== c && 101 !== c)return width;
      return scan_optionally_signed_decimal(store_char(width,ib,c),ib)}
    function scan_float(width$1,precision,ib)
     {var
       width=scan_sign(width$1,ib),
       width$0=scan_decimal_digit_star(width,ib);
      if(0 === width$0)return [0,width$0,precision];
      var c=peek_char(ib);
      if(ib[1])return [0,width$0,precision];
      if(46 === c)
       {var
         width$2=store_char(width$0,ib,c),
         precision$0=min(width$2,precision),
         width$3=
          width$2
          -
          (precision$0 - scan_fractional_part(precision$0,ib) | 0)
          |
          0;
        return [0,scan_exponent_part(width$3,ib),precision$0]}
      return [0,scan_exponent_part(width$0,ib),precision]}
    function check_case_insensitive_string(width,ib,error,str)
     {function lowercase(c)
       {var switcher=c - 65 | 0;
        return 25 < switcher >>> 0?c:char_of_int((c - 65 | 0) + 97 | 0)}
      var
       len=caml_ml_string_length(str),
       width$0=[0,width],
       _if_=len - 1 | 0,
       _ie_=0;
      if(! (_if_ < 0))
       {var i=_ie_;
        for(;;)
         {var c=peek_char(ib),_ig_=lowercase(caml_string_get(str,i));
          if(lowercase(c) !== _ig_)caml_call1(error,0);
          if(0 === width$0[1])caml_call1(error,0);
          width$0[1] = store_char(width$0[1],ib,c);
          var _ih_=i + 1 | 0;
          if(_if_ !== i){var i=_ih_;continue}
          break}}
      return width$0[1]}
    function scan_hex_float(width,precision,ib)
     {var _h3_=0 === width?1:0,_h4_=_h3_ || end_of_input(ib);
      if(_h4_)bad_hex_float(0);
      var
       width$0=scan_sign(width,ib),
       _h5_=0 === width$0?1:0,
       _h6_=_h5_ || end_of_input(ib);
      if(_h6_)bad_hex_float(0);
      var c=peek_char(ib),switch$0=0;
      if(78 <= c)
       {var switcher=c - 79 | 0;
        if(30 < switcher >>> 0)
         {if(! (32 <= switcher))
           {var
             width$1=store_char(width$0,ib,c),
             _h7_=0 === width$1?1:0,
             _h8_=_h7_ || end_of_input(ib);
            if(_h8_)bad_hex_float(0);
            return check_case_insensitive_string
                    (width$1,ib,bad_hex_float,cst_an)}}
        else
         if(26 === switcher)switch$0 = 1}
      else
       {if(48 === c)
         {var
           width$3=store_char(width$0,ib,c),
           _h$_=0 === width$3?1:0,
           _ia_=_h$_ || end_of_input(ib);
          if(_ia_)bad_hex_float(0);
          var
           width$4=
            check_case_insensitive_string(width$3,ib,bad_hex_float,cst_x$2);
          if(0 !== width$4 && ! end_of_input(ib))
           {var match=peek_char(ib),_ib_=match - 46 | 0,switch$1=0;
            if(34 < _ib_ >>> 0)
             {if(66 === _ib_)switch$1 = 1}
            else
             if(32 < (_ib_ - 1 | 0) >>> 0)switch$1 = 1;
            var width$5=switch$1?width$4:scan_hexadecimal_int(width$4,ib);
            if(0 !== width$5 && ! end_of_input(ib))
             {var c$0=peek_char(ib);
              if(46 === c$0)
               {var width$6=store_char(width$5,ib,c$0),switch$2=0;
                if(0 !== width$6 && ! end_of_input(ib))
                 {var match$0=peek_char(ib),switch$3=0;
                  if(80 !== match$0 && 112 !== match$0)
                   {var
                     precision$0=min(width$6,precision),
                     width$10=
                      width$6
                      -
                      (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                      |
                      0;
                    switch$3 = 1}
                  if(! switch$3)var width$10=width$6;
                  var width$7=width$10;
                  switch$2 = 1}
                if(! switch$2)var width$7=width$6;
                var width$8=width$7}
              else
               var width$8=width$5;
              if(0 !== width$8 && ! end_of_input(ib))
               {var c$1=peek_char(ib);
                if(80 !== c$1 && 112 !== c$1)return width$8;
                var
                 width$9=store_char(width$8,ib,c$1),
                 _ic_=0 === width$9?1:0,
                 _id_=_ic_ || end_of_input(ib);
                if(_id_)bad_hex_float(0);
                return scan_optionally_signed_decimal(width$9,ib)}
              return width$8}
            return width$5}
          return width$4}
        if(73 === c)switch$0 = 1}
      if(switch$0)
       {var
         width$2=store_char(width$0,ib,c),
         _h9_=0 === width$2?1:0,
         _h__=_h9_ || end_of_input(ib);
        if(_h__)bad_hex_float(0);
        return check_case_insensitive_string
                (width$2,ib,bad_hex_float,cst_nfinity)}
      return bad_hex_float(0)}
    function scan_caml_float_rest(width,precision,ib)
     {var _hZ_=0 === width?1:0,_h0_=_hZ_ || end_of_input(ib);
      if(_h0_)bad_float(0);
      var
       width$0=scan_decimal_digit_star(width,ib),
       _h1_=0 === width$0?1:0,
       _h2_=_h1_ || end_of_input(ib);
      if(_h2_)bad_float(0);
      var c=peek_char(ib),switcher=c - 69 | 0;
      if(32 < switcher >>> 0)
       {if(-23 === switcher)
         {var
           width$1=store_char(width$0,ib,c),
           precision$0=min(width$1,precision),
           width_precision=scan_fractional_part(precision$0,ib),
           frac_width=precision$0 - width_precision | 0,
           width$2=width$1 - frac_width | 0;
          return scan_exponent_part(width$2,ib)}}
      else
       {var switcher$0=switcher - 1 | 0;
        if(30 < switcher$0 >>> 0)return scan_exponent_part(width$0,ib)}
      return bad_float(0)}
    function scan_caml_float(width,precision,ib)
     {var _hL_=0 === width?1:0,_hM_=_hL_ || end_of_input(ib);
      if(_hM_)bad_float(0);
      var
       width$0=scan_sign(width,ib),
       _hN_=0 === width$0?1:0,
       _hO_=_hN_ || end_of_input(ib);
      if(_hO_)bad_float(0);
      var c=peek_char(ib);
      if(49 <= c)
       {if(! (58 <= c))
         {var
           width$1=store_char(width$0,ib,c),
           _hP_=0 === width$1?1:0,
           _hQ_=_hP_ || end_of_input(ib);
          if(_hQ_)bad_float(0);
          return scan_caml_float_rest(width$1,precision,ib)}}
      else
       if(48 <= c)
        {var
          width$2=store_char(width$0,ib,c),
          _hR_=0 === width$2?1:0,
          _hS_=_hR_ || end_of_input(ib);
         if(_hS_)bad_float(0);
         var c$0=peek_char(ib);
         if(88 !== c$0 && 120 !== c$0)
          return scan_caml_float_rest(width$2,precision,ib);
         var
          width$3=store_char(width$2,ib,c$0),
          _hT_=0 === width$3?1:0,
          _hU_=_hT_ || end_of_input(ib);
         if(_hU_)bad_float(0);
         var
          width$4=scan_hexadecimal_int(width$3,ib),
          _hV_=0 === width$4?1:0,
          _hW_=_hV_ || end_of_input(ib);
         if(_hW_)bad_float(0);
         var c$1=peek_char(ib),switcher=c$1 - 80 | 0,switch$0=0;
         if(32 < switcher >>> 0)
          if(-34 === switcher)
           {var width$5=store_char(width$4,ib,c$1),switch$1=0;
            if(0 !== width$5 && ! end_of_input(ib))
             {var match=peek_char(ib),switch$2=0;
              if(80 !== match && 112 !== match)
               {var
                 precision$0=min(width$5,precision),
                 width$10=
                  width$5
                  -
                  (precision$0 - scan_hexadecimal_int(precision$0,ib) | 0)
                  |
                  0;
                switch$2 = 1}
              if(! switch$2)var width$10=width$5;
              var width$6=width$10;
              switch$1 = 1}
            if(! switch$1)var width$6=width$5;
            var width$7=width$6}
          else
           switch$0 = 1;
         else
          {var switcher$0=switcher - 1 | 0;
           if(30 < switcher$0 >>> 0)var width$7=width$4;else switch$0 = 1}
         var width$8=switch$0?bad_float(0):width$7;
         if(0 !== width$8 && ! end_of_input(ib))
          {var c$2=peek_char(ib);
           if(80 !== c$2 && 112 !== c$2)return width$8;
           var
            width$9=store_char(width$8,ib,c$2),
            _hX_=0 === width$9?1:0,
            _hY_=_hX_ || end_of_input(ib);
           if(_hY_)bad_hex_float(0);
           return scan_optionally_signed_decimal(width$9,ib)}
         return width$8}
      return bad_float(0)}
    function scan_string(stp,width,ib)
     {var width$0=width;
      for(;;)
       {if(0 === width$0)return width$0;
        var c=peek_char(ib);
        if(ib[1])return width$0;
        if(stp)
         {var c$0=stp[1];
          if(c === c$0)return skip_char(width$0,ib);
          var width$1=store_char(width$0,ib,c),width$0=width$1;
          continue}
        var _hK_=c - 9 | 0,switch$0=0;
        if(4 < _hK_ >>> 0)
         {if(23 === _hK_)switch$0 = 1}
        else
         if(1 < (_hK_ - 2 | 0) >>> 0)switch$0 = 1;
        if(switch$0)return width$0;
        var width$2=store_char(width$0,ib,c),width$0=width$2;
        continue}}
    function scan_char(width,ib)
     {return store_char(width,ib,checked_peek_char(ib))}
    function hexadecimal_value_of_char(d)
     {return 97 <= d?d - 87 | 0:65 <= d?d - 55 | 0:d - 48 | 0}
    function check_next_char(message,width,ib)
     {if(0 === width)return bad_token_length(message);
      var c=peek_char(ib);
      return ib[1]?bad_input(caml_call1(sprintf(_ck_),message)):c}
    function check_next_char_for_char(_hI_,_hJ_)
     {return check_next_char(cst_a_Char,_hI_,_hJ_)}
    function check_next_char_for_string(_hG_,_hH_)
     {return check_next_char(cst_a_String,_hG_,_hH_)}
    function scan_backslash_char(width,ib)
     {var c0=check_next_char_for_char(width,ib),switch$0=0;
      if(40 <= c0)
       {if(58 <= c0)
         {var switcher$0=c0 - 92 | 0;
          if(! (28 < switcher$0 >>> 0))
           switch(switcher$0)
            {case 28:
              var
               get_digit=
                function(param)
                 {var c=next_char(ib),_hF_=c - 48 | 0,switch$0=0;
                  if(22 < _hF_ >>> 0)
                   {if(! (5 < (_hF_ - 49 | 0) >>> 0))switch$0 = 1}
                  else
                   if(6 < (_hF_ - 10 | 0) >>> 0)switch$0 = 1;
                  return switch$0?c:bad_input_escape(c)},
               c1=get_digit(0),
               c2=get_digit(0),
               _hB_=hexadecimal_value_of_char(c2),
               c$0=(16 * hexadecimal_value_of_char(c1) | 0) + _hB_ | 0,
               switch$1=0;
              if(0 <= c$0 && ! (255 < c$0))
               {var _hD_=char_of_int(c$0);switch$1 = 1}
              if(! switch$1)
               var _hD_=bad_input(caml_call2(sprintf(_cr_),c1,c2));
              return store_char(width - 2 | 0,ib,_hD_);
             case 0:
             case 6:
             case 18:
             case 22:
             case 24:switch$0 = 1;break
             }}
        else
         if(48 <= c0)
          {var
            get_digit$0=
             function(param)
              {var c=next_char(ib),switcher=c - 48 | 0;
               return 9 < switcher >>> 0?bad_input_escape(c):c},
            c1$0=get_digit$0(0),
            c2$0=get_digit$0(0),
            c=
             ((100 * (c0 - 48 | 0) | 0) + (10 * (c1$0 - 48 | 0) | 0) | 0)
             +
             (c2$0 - 48 | 0)
             |
             0,
            switch$2=0;
           if(0 <= c && ! (255 < c)){var _hE_=char_of_int(c);switch$2 = 1}
           if(! switch$2)
            var _hE_=bad_input(caml_call3(sprintf(_cq_),c0,c1$0,c2$0));
           return store_char(width - 2 | 0,ib,_hE_)}}
      else
       if(34 === c0 || 39 <= c0)switch$0 = 1;
      if(switch$0)
       {var switch$3=0;
        if(110 <= c0)
         if(117 <= c0)
          switch$3 = 1;
         else
          {var switcher=c0 - 110 | 0;
           switch(switcher)
            {case 0:var _hC_=10;break;
             case 4:var _hC_=13;break;
             case 6:var _hC_=9;break;
             default:switch$3 = 1}}
        else
         if(98 === c0)var _hC_=8;else switch$3 = 1;
        if(switch$3)var _hC_=c0;
        return store_char(width,ib,_hC_)}
      return bad_input_escape(c0)}
    function scan_caml_char(width,ib)
     {function find_stop(width)
       {var c=check_next_char_for_char(width,ib);
        return 39 === c?ignore_char(width,ib):character_mismatch(39,c)}
      var c=checked_peek_char(ib);
      if(39 === c)
       {var
         width$0=ignore_char(width,ib),
         c$0=check_next_char_for_char(width$0,ib);
        return 92 === c$0
                ?find_stop(scan_backslash_char(ignore_char(width$0,ib),ib))
                :find_stop(store_char(width$0,ib,c$0))}
      return character_mismatch(39,c)}
    function scan_caml_string(width,ib)
     {function find_stop$0(counter,width)
       {var width$0=width;
        for(;;)
         {var c=check_next_char_for_string(width$0,ib);
          if(34 === c)return ignore_char(width$0,ib);
          if(92 === c)
           {var
             width$1=ignore_char(width$0,ib),
             match=check_next_char_for_string(width$1,ib);
            if(10 === match)
             {var _hz_=ignore_char(width$1,ib);
              if(counter < 50)
               {var counter$0=counter + 1 | 0;
                return skip_spaces(counter$0,_hz_)}
              return caml_trampoline_return(skip_spaces,[0,_hz_])}
            if(13 === match)
             {var
               width$3=ignore_char(width$1,ib),
               match$0=check_next_char_for_string(width$3,ib);
              if(10 === match$0)
               {var _hA_=ignore_char(width$3,ib);
                if(counter < 50)
                 {var counter$1=counter + 1 | 0;
                  return skip_spaces(counter$1,_hA_)}
                return caml_trampoline_return(skip_spaces,[0,_hA_])}
              var width$5=store_char(width$3,ib,13),width$0=width$5;
              continue}
            var width$4=scan_backslash_char(width$1,ib),width$0=width$4;
            continue}
          var width$2=store_char(width$0,ib,c),width$0=width$2;
          continue}}
      function skip_spaces(counter,width)
       {var width$0=width;
        for(;;)
         {var match=check_next_char_for_string(width$0,ib);
          if(32 === match)
           {var width$1=ignore_char(width$0,ib),width$0=width$1;continue}
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return find_stop$0(counter$0,width$0)}
          return caml_trampoline_return(find_stop$0,[0,width$0])}}
      function find_stop(width){return caml_trampoline(find_stop$0(0,width))}
      var c=checked_peek_char(ib);
      return 34 === c
              ?find_stop(ignore_char(width,ib))
              :character_mismatch(34,c)}
    function scan_chars_in_char_set(char_set,scan_indic,width,ib)
     {function scan_chars(i,stp)
       {var i$0=i;
        for(;;)
         {var c=peek_char(ib),_hv_=0 < i$0?1:0;
          if(_hv_)
           {var _hw_=1 - ib[1];
            if(_hw_)
             var _hx_=is_in_char_set(char_set,c),_hy_=_hx_?c !== stp?1:0:_hx_;
            else
             var _hy_=_hw_}
          else
           var _hy_=_hv_;
          if(_hy_)
           {store_char(max_int,ib,c);var i$1=i$0 - 1 | 0,i$0=i$1;continue}
          return _hy_}}
      if(scan_indic)
       {var c=scan_indic[1];
        scan_chars(width,c);
        var _hu_=1 - ib[1];
        if(_hu_)
         {var ci=peek_char(ib);
          return c === ci?invalidate_current_char(ib):character_mismatch(c,ci)}
        return _hu_}
      return scan_chars(width,-1)}
    function scanf_bad_input(ib,x)
     {if(x[1] === Scan_failure)
       var s=x[2];
      else
       {if(x[1] !== Failure)throw x;var s=x[2]}
      var i=char_count(ib);
      return bad_input(caml_call2(sprintf(_ct_),i,s))}
    function get_counter(ib,counter)
     {switch(counter)
       {case 0:return ib[5];case 1:return char_count(ib);default:return ib[6]}}
    function width_of_pad_opt(pad_opt)
     {if(pad_opt){var width=pad_opt[1];return width}return max_int}
    function stopper_of_formatting_lit(fmting)
     {if(6 === fmting)return _cu_;
      var
       str=string_of_formatting_lit(fmting),
       stp=caml_string_get(str,1),
       sub_str=sub$0(str,2,caml_ml_string_length(str) - 2 | 0);
      return [0,stp,sub_str]}
    function take_format_readers$0(counter,k,fmt)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return caml_call1(k,0);
       else
        switch(fmt$0[0])
         {case 0:var fmt$1=fmt$0[1],fmt$0=fmt$1;continue;
          case 1:var fmt$2=fmt$0[1],fmt$0=fmt$2;continue;
          case 2:var fmt$3=fmt$0[2],fmt$0=fmt$3;continue;
          case 3:var fmt$4=fmt$0[2],fmt$0=fmt$4;continue;
          case 4:var fmt$5=fmt$0[4],fmt$0=fmt$5;continue;
          case 5:var fmt$6=fmt$0[4],fmt$0=fmt$6;continue;
          case 6:var fmt$7=fmt$0[4],fmt$0=fmt$7;continue;
          case 7:var fmt$8=fmt$0[4],fmt$0=fmt$8;continue;
          case 8:var fmt$9=fmt$0[4],fmt$0=fmt$9;continue;
          case 9:var fmt$10=fmt$0[2],fmt$0=fmt$10;continue;
          case 10:var fmt$11=fmt$0[1],fmt$0=fmt$11;continue;
          case 11:var fmt$12=fmt$0[2],fmt$0=fmt$12;continue;
          case 12:var fmt$13=fmt$0[2],fmt$0=fmt$13;continue;
          case 13:var fmt$14=fmt$0[3],fmt$0=fmt$14;continue;
          case 14:
           var rest=fmt$0[3],fmtty=fmt$0[2],_hs_=erase_rel(symm(fmtty));
           if(counter < 50)
            {var counter$0=counter + 1 | 0;
             return take_fmtty_format_readers$0(counter$0,k,_hs_,rest)}
           return caml_trampoline_return
                   (take_fmtty_format_readers$0,[0,k,_hs_,rest]);
          case 15:var fmt$15=fmt$0[1],fmt$0=fmt$15;continue;
          case 16:var fmt$16=fmt$0[1],fmt$0=fmt$16;continue;
          case 17:var fmt$17=fmt$0[2],fmt$0=fmt$17;continue;
          case 18:
           var _ht_=fmt$0[1];
           if(0 === _ht_[0])
            {var
              rest$0=fmt$0[2],
              match=_ht_[1],
              fmt$18=match[1],
              fmt$19=concat_fmt(fmt$18,rest$0),
              fmt$0=fmt$19;
             continue}
           var
            rest$1=fmt$0[2],
            match$0=_ht_[1],
            fmt$20=match$0[1],
            fmt$21=concat_fmt(fmt$20,rest$1),
            fmt$0=fmt$21;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_format_readers(new_k,fmt_rest)};
          case 20:var fmt$22=fmt$0[3],fmt$0=fmt$22;continue;
          case 21:var fmt$23=fmt$0[2],fmt$0=fmt$23;continue;
          case 22:var fmt$24=fmt$0[1],fmt$0=fmt$24;continue;
          case 23:
           var rest$2=fmt$0[2],ign=fmt$0[1];
           if(typeof ign === "number")
            switch(ign)
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:
               return function(reader)
                {function new_k(readers_rest)
                  {return caml_call1(k,[0,reader,readers_rest])}
                 return take_format_readers(new_k,rest$2)};
              default:var fmt$0=rest$2;continue}
           else
            switch(ign[0])
             {case 0:var fmt$0=rest$2;continue;
              case 1:var fmt$0=rest$2;continue;
              case 2:var fmt$0=rest$2;continue;
              case 3:var fmt$0=rest$2;continue;
              case 4:var fmt$0=rest$2;continue;
              case 5:var fmt$0=rest$2;continue;
              case 6:var fmt$0=rest$2;continue;
              case 7:var fmt$0=rest$2;continue;
              case 8:var fmt$0=rest$2;continue;
              case 9:
               var fmtty$0=ign[2];
               if(counter < 50)
                {var counter$1=counter + 1 | 0;
                 return take_fmtty_format_readers$0
                         (counter$1,k,fmtty$0,rest$2)}
               return caml_trampoline_return
                       (take_fmtty_format_readers$0,[0,k,fmtty$0,rest$2]);
              case 10:var fmt$0=rest$2;continue;
              default:var fmt$0=rest$2;continue}
          default:var fmt$25=fmt$0[3],fmt$0=fmt$25;continue}}
    function take_fmtty_format_readers$0(counter,k,fmtty,fmt)
     {var fmtty$0=fmtty;
      for(;;)
       if(typeof fmtty$0 === "number")
        {if(counter < 50)
          {var counter$0=counter + 1 | 0;
           return take_format_readers$0(counter$0,k,fmt)}
         return caml_trampoline_return(take_format_readers$0,[0,k,fmt])}
       else
        switch(fmtty$0[0])
         {case 0:var fmtty$1=fmtty$0[1],fmtty$0=fmtty$1;continue;
          case 1:var fmtty$2=fmtty$0[1],fmtty$0=fmtty$2;continue;
          case 2:var fmtty$3=fmtty$0[1],fmtty$0=fmtty$3;continue;
          case 3:var fmtty$4=fmtty$0[1],fmtty$0=fmtty$4;continue;
          case 4:var fmtty$5=fmtty$0[1],fmtty$0=fmtty$5;continue;
          case 5:var fmtty$6=fmtty$0[1],fmtty$0=fmtty$6;continue;
          case 6:var fmtty$7=fmtty$0[1],fmtty$0=fmtty$7;continue;
          case 7:var fmtty$8=fmtty$0[1],fmtty$0=fmtty$8;continue;
          case 8:var fmtty$9=fmtty$0[2],fmtty$0=fmtty$9;continue;
          case 9:
           var
            rest=fmtty$0[3],
            ty2=fmtty$0[2],
            ty1=fmtty$0[1],
            ty=trans(symm(ty1),ty2),
            fmtty$10=concat_fmtty(ty,rest),
            fmtty$0=fmtty$10;
           continue;
          case 10:var fmtty$11=fmtty$0[1],fmtty$0=fmtty$11;continue;
          case 11:var fmtty$12=fmtty$0[1],fmtty$0=fmtty$12;continue;
          case 12:var fmtty$13=fmtty$0[1],fmtty$0=fmtty$13;continue;
          case 13:
           var fmt_rest=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest,fmt)};
          default:
           var fmt_rest$0=fmtty$0[1];
           return function(reader)
            {function new_k(readers_rest)
              {return caml_call1(k,[0,reader,readers_rest])}
             return take_fmtty_format_readers(new_k,fmt_rest$0,fmt)}}}
    function take_format_readers(k,fmt)
     {return caml_trampoline(take_format_readers$0(0,k,fmt))}
    function take_fmtty_format_readers(k,fmtty,fmt)
     {return caml_trampoline(take_fmtty_format_readers$0(0,k,fmtty,fmt))}
    function make_scanf(ib,fmt,readers)
     {var fmt$0=fmt;
      for(;;)
       if(typeof fmt$0 === "number")
        return 0;
       else
        switch(fmt$0[0])
         {case 0:
           var rest=fmt$0[1];
           scan_char(0,ib);
           var c=token_char(ib);
           return [0,c,make_scanf(ib,rest,readers)];
          case 1:
           var rest$0=fmt$0[1];
           scan_caml_char(0,ib);
           var c$0=token_char(ib);
           return [0,c$0,make_scanf(ib,rest$0,readers)];
          case 2:
           var _hf_=fmt$0[1],_hg_=fmt$0[2];
           if(typeof _hg_ !== "number")
            switch(_hg_[0])
             {case 17:
               var
                rest$2=_hg_[2],
                fmting_lit=_hg_[1],
                match=stopper_of_formatting_lit(fmting_lit),
                str=match[2],
                stp=match[1],
                scan$0=
                 function(width,param,ib)
                  {return scan_string([0,stp],width,ib)},
                str_rest=[11,str,rest$2];
               return pad_prec_scanf
                       (ib,str_rest,readers,_hf_,0,scan$0,token_string);
              case 18:
               var _hh_=_hg_[1];
               if(0 === _hh_[0])
                {var
                  rest$3=_hg_[2],
                  match$0=_hh_[1],
                  fmt$1=match$0[1],
                  scan$1=
                   function(width,param,ib){return scan_string(_cv_,width,ib)};
                 return pad_prec_scanf
                         (ib,
                          concat_fmt(fmt$1,rest$3),
                          readers,
                          _hf_,
                          0,
                          scan$1,
                          token_string)}
               var
                rest$4=_hg_[2],
                match$1=_hh_[1],
                fmt$2=match$1[1],
                scan$2=
                 function(width,param,ib){return scan_string(_cw_,width,ib)};
               return pad_prec_scanf
                       (ib,
                        concat_fmt(fmt$2,rest$4),
                        readers,
                        _hf_,
                        0,
                        scan$2,
                        token_string)
              }
           var
            rest$1=fmt$0[2],
            scan=function(width,param,ib){return scan_string(0,width,ib)};
           return pad_prec_scanf(ib,rest$1,readers,_hf_,0,scan,token_string);
          case 3:
           var
            rest$5=fmt$0[2],
            pad=fmt$0[1],
            scan$3=function(width,param,ib){return scan_caml_string(width,ib)};
           return pad_prec_scanf(ib,rest$5,readers,pad,0,scan$3,token_string);
          case 4:
           var
            rest$6=fmt$0[4],
            prec=fmt$0[3],
            pad$0=fmt$0[2],
            iconv=fmt$0[1],
            conv=integer_conversion_of_char(char_of_iconv(iconv)),
            scan$4=
             function(width,param,ib)
              {return scan_int_conversion(conv,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$6,
                    readers,
                    pad$0,
                    prec,
                    scan$4,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv,ib))});
          case 5:
           var
            rest$7=fmt$0[4],
            prec$0=fmt$0[3],
            pad$1=fmt$0[2],
            iconv$0=fmt$0[1],
            conv$0=integer_conversion_of_char(char_of_iconv(iconv$0)),
            scan$5=
             function(width,param,ib)
              {return scan_int_conversion(conv$0,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$7,
                    readers,
                    pad$1,
                    prec$0,
                    scan$5,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$0,ib))});
          case 6:
           var
            rest$8=fmt$0[4],
            prec$1=fmt$0[3],
            pad$2=fmt$0[2],
            iconv$1=fmt$0[1],
            conv$1=integer_conversion_of_char(char_of_iconv(iconv$1)),
            scan$6=
             function(width,param,ib)
              {return scan_int_conversion(conv$1,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$8,
                    readers,
                    pad$2,
                    prec$1,
                    scan$6,
                    function(ib)
                     {return caml_int_of_string(token_int_literal(conv$1,ib))});
          case 7:
           var
            rest$9=fmt$0[4],
            prec$2=fmt$0[3],
            pad$3=fmt$0[2],
            iconv$2=fmt$0[1],
            conv$2=integer_conversion_of_char(char_of_iconv(iconv$2)),
            scan$7=
             function(width,param,ib)
              {return scan_int_conversion(conv$2,width,ib)};
           return pad_prec_scanf
                   (ib,
                    rest$9,
                    readers,
                    pad$3,
                    prec$2,
                    scan$7,
                    function(ib)
                     {return caml_int64_of_string(token_int_literal(conv$2,ib))});
          case 8:
           switch(fmt$0[1][2])
            {case 5:
             case 8:
              var rest$11=fmt$0[4],prec$4=fmt$0[3],pad$5=fmt$0[2];
              return pad_prec_scanf
                      (ib,
                       rest$11,
                       readers,
                       pad$5,
                       prec$4,
                       scan_caml_float,
                       token_float);
             case 6:
             case 7:
              var rest$12=fmt$0[4],prec$5=fmt$0[3],pad$6=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$12,readers,pad$6,prec$5,scan_hex_float,token_float);
             default:
              var rest$10=fmt$0[4],prec$3=fmt$0[3],pad$4=fmt$0[2];
              return pad_prec_scanf
                      (ib,rest$10,readers,pad$4,prec$3,scan_float,token_float)}
          case 9:
           var
            rest$13=fmt$0[2],
            pad$7=fmt$0[1],
            scan$8=
             function(param,_hr_,ib)
              {var
                c=checked_peek_char(ib),
                m=
                 102 === c
                  ?5
                  :116 === c?4:bad_input(caml_call1(sprintf(_cs_),c));
               return scan_string(0,m,ib)};
           return pad_prec_scanf(ib,rest$13,readers,pad$7,0,scan$8,token_bool);
          case 10:
           var rest$14=fmt$0[1];
           if(end_of_input(ib)){var fmt$0=rest$14;continue}
           return bad_input(cst_end_of_input_not_found);
          case 11:
           var rest$15=fmt$0[2],str$0=fmt$0[1];
           iter$4(function(_hq_){return check_char(ib,_hq_)},str$0);
           var fmt$0=rest$15;
           continue;
          case 12:
           var rest$16=fmt$0[2],chr=fmt$0[1];
           check_char(ib,chr);
           var fmt$0=rest$16;
           continue;
          case 13:
           var rest$17=fmt$0[3],fmtty=fmt$0[2],pad_opt=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt),ib);
           var s=token_string(ib);
           try
            {var _hi_=format_of_string_fmtty(s,fmtty),fmt$3=_hi_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var msg=exn[2],fmt$3=bad_input(msg)}
           return [0,fmt$3,make_scanf(ib,rest$17,readers)];
          case 14:
           var rest$18=fmt$0[3],fmtty$0=fmt$0[2],pad_opt$0=fmt$0[1];
           scan_caml_string(width_of_pad_opt(pad_opt$0),ib);
           var s$0=token_string(ib);
           try
            {var
              match$2=fmt_ebb_of_string(0,s$0),
              fmt$6=match$2[1],
              match$3=fmt_ebb_of_string(0,s$0),
              fmt$7=match$3[1],
              fmt$8=type_format(fmt$7,erase_rel(symm(fmtty$0))),
              _hk_=type_format(fmt$6,erase_rel(fmtty$0)),
              fmt$5=fmt$8,
              fmt$4=_hk_}
           catch(exn)
            {exn = caml_wrap_exception(exn);
             if(exn[1] !== Failure)throw exn;
             var
              msg$0=exn[2],
              _hj_=bad_input(msg$0),
              fmt$5=_hj_[2],
              fmt$4=_hj_[1]}
           return [0,
                   [0,fmt$4,s$0],
                   make_scanf(ib,concat_fmt(fmt$5,rest$18),readers)];
          case 15:return invalid_arg(cst_scanf_bad_conversion_a);
          case 16:return invalid_arg(cst_scanf_bad_conversion_t);
          case 17:
           var
            rest$19=fmt$0[2],
            formatting_lit=fmt$0[1],
            _hl_=string_of_formatting_lit(formatting_lit);
           iter$4(function(_hp_){return check_char(ib,_hp_)},_hl_);
           var fmt$0=rest$19;
           continue;
          case 18:
           var _hm_=fmt$0[1];
           if(0 === _hm_[0])
            {var rest$20=fmt$0[2],match$4=_hm_[1],fmt$9=match$4[1];
             check_char(ib,64);
             check_char(ib,123);
             var fmt$10=concat_fmt(fmt$9,rest$20),fmt$0=fmt$10;
             continue}
           var rest$21=fmt$0[2],match$5=_hm_[1],fmt$11=match$5[1];
           check_char(ib,64);
           check_char(ib,91);
           var fmt$12=concat_fmt(fmt$11,rest$21),fmt$0=fmt$12;
           continue;
          case 19:
           var fmt_rest=fmt$0[1];
           if(readers)
            {var
              readers_rest=readers[2],
              reader=readers[1],
              x=caml_call1(reader,ib);
             return [0,x,make_scanf(ib,fmt_rest,readers_rest)]}
           return invalid_arg(cst_scanf_missing_reader);
          case 20:
           var _hn_=fmt$0[1],_ho_=fmt$0[3];
           if(typeof _ho_ !== "number" && 17 === _ho_[0])
            {var
              rest$23=_ho_[2],
              fmting_lit$0=_ho_[1],
              char_set$0=fmt$0[2],
              match$6=stopper_of_formatting_lit(fmting_lit$0),
              str$1=match$6[2],
              stp$0=match$6[1],
              width$0=width_of_pad_opt(_hn_);
             scan_chars_in_char_set(char_set$0,[0,stp$0],width$0,ib);
             var s$2=token_string(ib),str_rest$0=[11,str$1,rest$23];
             return [0,s$2,make_scanf(ib,str_rest$0,readers)]}
           var
            rest$22=fmt$0[3],
            char_set=fmt$0[2],
            width=width_of_pad_opt(_hn_);
           scan_chars_in_char_set(char_set,0,width,ib);
           var s$1=token_string(ib);
           return [0,s$1,make_scanf(ib,rest$22,readers)];
          case 21:
           var
            rest$24=fmt$0[2],
            counter=fmt$0[1],
            count=get_counter(ib,counter);
           return [0,count,make_scanf(ib,rest$24,readers)];
          case 22:
           var rest$25=fmt$0[1],c$1=checked_peek_char(ib);
           return [0,c$1,make_scanf(ib,rest$25,readers)];
          case 23:
           var
            rest$26=fmt$0[2],
            ign=fmt$0[1],
            match$7=param_format_of_ignored_format(ign,rest$26),
            fmt$13=match$7[1],
            match$8=make_scanf(ib,fmt$13,readers);
           if(match$8){var arg_rest=match$8[2];return arg_rest}
           throw [0,Assert_failure,_cx_];
          default:return invalid_arg(cst_scanf_bad_conversion_custo)}}
    function pad_prec_scanf(ib,fmt,readers,pad,prec,scan,token)
     {if(typeof pad === "number")
       {if(typeof prec === "number")
         {if(prec)return invalid_arg(cst_scanf_bad_conversion);
          caml_call3(scan,max_int,max_int,ib);
          var x=caml_call1(token,ib);
          return [0,x,make_scanf(ib,fmt,readers)]}
        var p=prec[1];
        caml_call3(scan,max_int,p,ib);
        var x$0=caml_call1(token,ib);
        return [0,x$0,make_scanf(ib,fmt,readers)]}
      else
       {if(0 === pad[0])
         {if(pad[1])
           {var _he_=pad[2];
            if(typeof prec === "number")
             {if(prec)return invalid_arg(cst_scanf_bad_conversion$0);
              caml_call3(scan,_he_,max_int,ib);
              var x$1=caml_call1(token,ib);
              return [0,x$1,make_scanf(ib,fmt,readers)]}
            var p$0=prec[1];
            caml_call3(scan,_he_,p$0,ib);
            var x$2=caml_call1(token,ib);
            return [0,x$2,make_scanf(ib,fmt,readers)]}
          return invalid_arg(cst_scanf_bad_conversion$1)}
        return invalid_arg(cst_scanf_bad_conversion$2)}}
    function kscanf(ib,ef,param)
     {var str=param[2],fmt=param[1];
      function apply(f,args)
       {var f$0=f,args$0=args;
        for(;;)
         {if(args$0)
           {var
             r=args$0[2],
             x=args$0[1],
             f$1=caml_call1(f$0,x),
             f$0=f$1,
             args$0=r;
            continue}
          return f$0}}
      function k(readers,f)
       {reset_token(ib);
        try
         {var _hd_=[0,make_scanf(ib,fmt,readers)],_hc_=_hd_}
        catch(exc)
         {exc = caml_wrap_exception(exc);
          var switch$0=0;
          if
           (exc[1]
            !==
            Scan_failure
            &&
            exc[1]
            !==
            Failure
            &&
            exc
            !==
            End_of_file)
           {if(exc[1] !== Invalid_argument)throw exc;
            var
             msg=exc[2],
             _hb_=
              invalid_arg
               (symbol
                 (msg,symbol(cst_in_format,symbol(escaped$1(str),cst$88))));
            switch$0 = 1}
          if(! switch$0)var _hb_=[1,exc];
          var _hc_=_hb_}
        if(0 === _hc_[0]){var args=_hc_[1];return apply(f,args)}
        var exc=_hc_[1];
        return caml_call2(ef,ib,exc)}
      return take_format_readers(k,fmt)}
    function bscanf(ib,fmt){return kscanf(ib,scanf_bad_input,fmt)}
    function ksscanf(s,ef,fmt){return kscanf(from_string$1(s),ef,fmt)}
    function sscanf(s,fmt)
     {return kscanf(from_string$1(s),scanf_bad_input,fmt)}
    function scanf(fmt){return kscanf(stdib,scanf_bad_input,fmt)}
    function bscanf_format(ib,format,f)
     {scan_caml_string(max_int,ib);
      var str=token_string(ib);
      try
       {var _ha_=format_of_string_format(str,format),fmt=_ha_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] !== Failure)throw exn;
        var msg=exn[2],fmt=bad_input(msg)}
      return caml_call1(f,fmt)}
    function sscanf_format(s,format,f)
     {return bscanf_format(from_string$1(s),format,f)}
    function format_from_string(s,fmt)
     {function _g$_(x){return x}
      return sscanf_format
              (symbol(cst$90,symbol(escaped$1(s),cst$89)),fmt,_g$_)}
    function unescaped(s)
     {function _g__(x){return x}
      return caml_call1(sscanf(symbol(cst$92,symbol(s,cst$91)),_cy_),_g__)}
    function kfscanf(ic,ef,fmt){return kscanf(memo_from_channel(ic),ef,fmt)}
    function fscanf(ic,fmt)
     {return kscanf(memo_from_channel(ic),scanf_bad_input,fmt)}
    var
     Stdlib_scanf=
      [0,
       [0,
        stdib,
        from_file,
        from_file_bin,
        close_in$0,
        from_file,
        from_file_bin,
        from_string$1,
        from_function$0,
        from_channel$0,
        end_of_input,
        beginning_of_input,
        name_of_input,
        stdib],
       Scan_failure,
       bscanf,
       sscanf,
       scanf,
       kscanf,
       ksscanf,
       bscanf_format,
       sscanf_format,
       format_from_string,
       unescaped,
       fscanf,
       kfscanf];
    caml_register_global(795,Stdlib_scanf,"Stdlib__scanf");
    function register(name,v){return caml_register_named_value(name,v)}
    function register_exception(name,exn)
     {var slot=caml_obj_tag(exn) === 248?exn:exn[1];
      return caml_register_named_value(name,slot)}
    var Stdlib_callback=[0,register,register_exception];
    caml_register_global(796,Stdlib_callback,"Stdlib__callback");
    function copy$7(o){var o$0=o.slice();return caml_set_oo_id(o$0)}
    var params$0=[0,1,1,1,3,16],initial_object_size=2,dummy_item=0;
    function public_method_label(s)
     {var accu=[0,0],_g7_=caml_ml_string_length(s) - 1 | 0,_g6_=0;
      if(! (_g7_ < 0))
       {var i=_g6_;
        for(;;)
         {var _g8_=caml_string_get(s,i);
          accu[1] = (223 * accu[1] | 0) + _g8_ | 0;
          var _g9_=i + 1 | 0;
          if(_g7_ !== i){var i=_g9_;continue}
          break}}
      accu[1] = accu[1] & 2147483647;
      var tag=1073741823 < accu[1]?accu[1] + 2147483648 | 0:accu[1];
      return tag}
    function compare$11(x,y){return caml_string_compare(x,y)}
    var Vars=caml_call1(Stdlib_map[1],[0,compare$11]);
    function compare$12(x,y){return caml_string_compare(x,y)}
    var
     Meths=caml_call1(Stdlib_map[1],[0,compare$12]),
     compare$13=caml_int_compare,
     Labs=caml_call1(Stdlib_map[1],[0,compare$13]),
     dummy_table=[0,0,[0,dummy_item],Meths[1],Labs[1],0,0,Vars[1],0],
     table_count=[0,0],
     dummy_met=caml_obj_block(0,0);
    function fit_size(n){return 2 < n?fit_size((n + 1 | 0) / 2 | 0) * 2 | 0:n}
    function new_table(pub_labels)
     {table_count[1]++;
      var
       len=pub_labels.length - 1,
       methods=caml_make_vect((len * 2 | 0) + 2 | 0,dummy_met);
      caml_check_bound(methods,0)[1] = len;
      var _g0_=((fit_size(len) * 32 | 0) / 8 | 0) - 1 | 0;
      caml_check_bound(methods,1)[2] = _g0_;
      var _g2_=len - 1 | 0,_g1_=0;
      if(! (_g2_ < 0))
       {var i=_g1_;
        for(;;)
         {var
           _g4_=(i * 2 | 0) + 3 | 0,
           _g3_=caml_check_bound(pub_labels,i)[1 + i];
          caml_check_bound(methods,_g4_)[1 + _g4_] = _g3_;
          var _g5_=i + 1 | 0;
          if(_g2_ !== i){var i=_g5_;continue}
          break}}
      return [0,initial_object_size,methods,Meths[1],Labs[1],0,0,Vars[1],0]}
    function resize$1(array,new_size)
     {var old_size=array[2].length - 1,_gY_=old_size < new_size?1:0;
      if(_gY_)
       {var new_buck=caml_make_vect(new_size,dummy_met);
        blit$1(array[2],0,new_buck,0,old_size);
        array[2] = new_buck;
        var _gZ_=0}
      else
       var _gZ_=_gY_;
      return _gZ_}
    var method_count=[0,0],inst_var_count=[0,0];
    function new_method(table)
     {var index=table[2].length - 1;
      resize$1(table,index + 1 | 0);
      return index}
    function get_method_label(table,name)
     {try
       {var _gW_=caml_call2(Meths[28],name,table[3]);return _gW_}
      catch(_gX_)
       {_gX_ = caml_wrap_exception(_gX_);
        if(_gX_ === Not_found)
         {var label=new_method(table);
          table[3] = caml_call3(Meths[4],name,label,table[3]);
          table[4] = caml_call3(Labs[4],label,1,table[4]);
          return label}
        throw _gX_}}
    function get_method_labels(table,names)
     {return map$5(function(_gV_){return get_method_label(table,_gV_)},names)}
    function set_method(table,label,element)
     {method_count[1]++;
      return caml_call2(Labs[28],label,table[4])
              ?(resize$1(table,label + 1 | 0),
                caml_check_bound(table[2],label)[1 + label]
                =
                element,
                0)
              :(table[6] = [0,[0,label,element],table[6]],0)}
    function get_method(table,label)
     {try
       {var _gT_=assoc(label,table[6]);return _gT_}
      catch(_gU_)
       {_gU_ = caml_wrap_exception(_gU_);
        if(_gU_ === Not_found)
         return caml_check_bound(table[2],label)[1 + label];
        throw _gU_}}
    function to_list$3(arr){return 0 === arr?0:to_list$1(arr)}
    function narrow(table,vars,virt_meths,concr_meths)
     {var
       vars$0=to_list$3(vars),
       virt_meths$0=to_list$3(virt_meths),
       concr_meths$0=to_list$3(concr_meths),
       virt_meth_labs=
        map$2
         (function(_gS_){return get_method_label(table,_gS_)},virt_meths$0),
       concr_meth_labs=
        map$2
         (function(_gR_){return get_method_label(table,_gR_)},concr_meths$0);
      table[5]
      =
      [0,
       [0,table[3],table[4],table[6],table[7],virt_meth_labs,vars$0],
       table[5]];
      var _gI_=Vars[1],_gJ_=table[7];
      function _gK_(lab,info,tvars)
       {return mem(lab,vars$0)?caml_call3(Vars[4],lab,info,tvars):tvars}
      table[7] = caml_call3(Vars[13],_gK_,_gJ_,_gI_);
      var by_name=[0,Meths[1]],by_label=[0,Labs[1]];
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          var _gN_=by_label[1];
          try
           {var _gP_=caml_call2(Labs[28],label,table[4]),_gO_=_gP_}
          catch(_gQ_)
           {_gQ_ = caml_wrap_exception(_gQ_);
            if(_gQ_ !== Not_found)throw _gQ_;
            var _gO_=1}
          by_label[1] = caml_call3(Labs[4],label,_gO_,_gN_);
          return 0},
        concr_meths$0,
        concr_meth_labs);
      iter2
       (function(met,label)
         {by_name[1] = caml_call3(Meths[4],met,label,by_name[1]);
          by_label[1] = caml_call3(Labs[4],label,0,by_label[1]);
          return 0},
        virt_meths$0,
        virt_meth_labs);
      table[3] = by_name[1];
      table[4] = by_label[1];
      var _gL_=0,_gM_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meth_labs)?hm:[0,met,hm]},
        _gM_,
        _gL_);
      return 0}
    function widen(table)
     {var
       match=hd(table[5]),
       vars=match[6],
       virt_meths=match[5],
       saved_vars=match[4],
       saved_hidden_meths=match[3],
       by_label=match[2],
       by_name=match[1];
      table[5] = tl(table[5]);
      table[7]
      =
      fold_left$0
       (function(s,v)
         {var _gH_=caml_call2(Vars[28],v,table[7]);
          return caml_call3(Vars[4],v,_gH_,s)},
        saved_vars,
        vars);
      table[3] = by_name;
      table[4] = by_label;
      var _gG_=table[6];
      table[6]
      =
      fold_right
       (function(met,hm)
         {var lab=met[1];return mem(lab,virt_meths)?hm:[0,met,hm]},
        _gG_,
        saved_hidden_meths);
      return 0}
    function new_slot(table)
     {var index=table[1];table[1] = index + 1 | 0;return index}
    function new_variable(table,name)
     {try
       {var _gE_=caml_call2(Vars[28],name,table[7]);return _gE_}
      catch(_gF_)
       {_gF_ = caml_wrap_exception(_gF_);
        if(_gF_ === Not_found)
         {var index=new_slot(table);
          if(caml_string_notequal(name,cst$93))
           table[7] = caml_call3(Vars[4],name,index,table[7]);
          return index}
        throw _gF_}}
    function to_array(arr){return caml_equal(arr,0)?[0]:arr}
    function new_methods_variables(table,meths,vals)
     {var
       meths$0=to_array(meths),
       nmeths=meths$0.length - 1,
       nvals=vals.length - 1,
       res=caml_make_vect(nmeths + nvals | 0,0),
       _gw_=nmeths - 1 | 0,
       _gv_=0;
      if(! (_gw_ < 0))
       {var i$0=_gv_;
        for(;;)
         {var
           _gC_=
            get_method_label(table,caml_check_bound(meths$0,i$0)[1 + i$0]);
          caml_check_bound(res,i$0)[1 + i$0] = _gC_;
          var _gD_=i$0 + 1 | 0;
          if(_gw_ !== i$0){var i$0=_gD_;continue}
          break}}
      var _gy_=nvals - 1 | 0,_gx_=0;
      if(! (_gy_ < 0))
       {var i=_gx_;
        for(;;)
         {var
           _gA_=i + nmeths | 0,
           _gz_=new_variable(table,caml_check_bound(vals,i)[1 + i]);
          caml_check_bound(res,_gA_)[1 + _gA_] = _gz_;
          var _gB_=i + 1 | 0;
          if(_gy_ !== i){var i=_gB_;continue}
          break}}
      return res}
    function get_variable(table,name)
     {try
       {var _gt_=caml_call2(Vars[28],name,table[7]);return _gt_}
      catch(_gu_)
       {_gu_ = caml_wrap_exception(_gu_);
        if(_gu_ === Not_found)throw [0,Assert_failure,_cz_];
        throw _gu_}}
    function get_variables(table,names)
     {return map$5(function(_gs_){return get_variable(table,_gs_)},names)}
    function add_initializer(table,f){table[8] = [0,f,table[8]];return 0}
    function create_table(public_methods)
     {if(0 === public_methods)return new_table([0]);
      var
       tags=map$5(public_method_label,public_methods),
       table=new_table(tags);
      iteri$2
       (function(i,met)
         {var lab=(i * 2 | 0) + 2 | 0;
          table[3] = caml_call3(Meths[4],met,lab,table[3]);
          table[4] = caml_call3(Labs[4],lab,1,table[4]);
          return 0},
        public_methods);
      return table}
    function init_class(table)
     {inst_var_count[1] = (inst_var_count[1] + table[1] | 0) - 1 | 0;
      table[8] = rev(table[8]);
      return resize$1
              (table,
               3 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0)}
    function inherits(cla,vals,virt_meths,concr_meths,param,top)
     {var env=param[4],super$0=param[2];
      narrow(cla,vals,virt_meths,concr_meths);
      var init=top?caml_call2(super$0,cla,env):caml_call1(super$0,cla);
      widen(cla);
      var
       _gn_=0,
       _go_=to_array(concr_meths),
       _gp_=
        [0,
         map$5
          (function(nm){return get_method(cla,get_method_label(cla,nm))},_go_),
         _gn_],
       _gq_=to_array(vals);
      return caml_array_concat
              ([0,
                [0,init],
                [0,
                 map$5(function(_gr_){return get_variable(cla,_gr_)},_gq_),
                 _gp_]])}
    function make_class(pub_meths,class_init)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      return [0,caml_call1(env_init,0),class_init,env_init,0]}
    function make_class_store(pub_meths,class_init,init_table)
     {var table=create_table(pub_meths),env_init=caml_call1(class_init,table);
      init_class(table);
      init_table[2] = class_init;
      init_table[1] = env_init;
      return 0}
    function dummy_class(loc)
     {function undef(param){throw [0,Undefined_recursive_module,loc]}
      return [0,undef,undef,undef,0]}
    function create_object(table)
     {var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function create_object_opt(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=caml_obj_block(248,table[1]);
      obj[1] = table[2];
      return caml_set_oo_id(obj)}
    function iter_f(obj,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var l=param$0[2],f=param$0[1];
          caml_call1(f,obj);
          var param$0=l;
          continue}
        return 0}}
    function run_initializers(obj,table)
     {var inits=table[8],_gm_=0 !== inits?1:0;
      return _gm_?iter_f(obj,inits):_gm_}
    function run_initializers_opt(obj_0,obj,table)
     {if(obj_0)return obj;
      var inits=table[8];
      if(0 !== inits)iter_f(obj,inits);
      return obj}
    function create_object_and_run_initiali(obj_0,table)
     {if(obj_0)return obj_0;
      var obj=create_object(table);
      run_initializers(obj,table);
      return obj}
    function get_data$0(param)
     {if(param)return param[2];throw [0,Assert_failure,_cD_]}
    function build_path(n,keys,tables)
     {var res=[0,0,0,0],r=[0,res],_gi_=0;
      if(! (n < 0))
       {var i=_gi_;
        for(;;)
         {var _gk_=r[1];
          r[1] = [0,caml_check_bound(keys,i)[1 + i],_gk_,0];
          var _gl_=i + 1 | 0;
          if(n !== i){var i=_gl_;continue}
          break}}
      var _gj_=r[1];
      if(tables){tables[2] = _gj_;return res}
      throw [0,Assert_failure,_cA_]}
    function lookup_tables(root,keys)
     {var tables$2=get_data$0(root);
      if(tables$2)
       {var i$1=keys.length - 1 - 1 | 0,i=i$1,tables=tables$2;
        a:
        for(;;)
         {if(0 <= i)
           {var key=caml_check_bound(keys,i)[1 + i],tables$0=tables;
            for(;;)
             {if(tables$0)
               {if(tables$0[1] === key)
                 {var tables$1=get_data$0(tables$0);
                  if(tables$1)
                   {var i$0=i - 1 | 0,i=i$0,tables=tables$1;continue a}
                  throw [0,Assert_failure,_cF_]}
                if(tables$0)
                 {var _gh_=tables$0[3];
                  if(_gh_){var tables$0=_gh_;continue}
                  var v=[0,key,0,0];
                  if(tables$0)
                   {tables$0[3] = v;return build_path(i - 1 | 0,keys,v)}
                  throw [0,Assert_failure,_cB_]}
                throw [0,Assert_failure,_cE_]}
              throw [0,Assert_failure,_cC_]}}
          return tables}}
      return build_path(keys.length - 1 - 1 | 0,keys,root)}
    function new_cache(table)
     {var n=new_method(table),switch$0=0;
      if
       (0
        !==
        (n % 2 | 0)
        &&
        !
        ((2 + ((caml_check_bound(table[2],1)[2] * 16 | 0) / 32 | 0) | 0) < n))
       {var n$0=new_method(table);switch$0 = 1}
      if(! switch$0)var n$0=n;
      caml_check_bound(table[2],n$0)[1 + n$0] = 0;
      return n$0}
    function set_methods(table,methods)
     {var len=methods.length - 1,i=[0,0];
      for(;;)
       {if(i[1] < len)
         {var
           _gb_=i[1],
           label=caml_check_bound(methods,_gb_)[1 + _gb_],
           next=
            function(param)
             {i[1]++;
              var _gg_=i[1];
              return caml_check_bound(methods,_gg_)[1 + _gg_]},
           clo=next(0);
          if(typeof clo === "number")
           switch(clo)
            {case 0:
              var
               x=next(0),
               clo$0=function(x){return function(obj){return x}}(x);
              break;
             case 1:
              var
               n=next(0),
               clo$0=function(n){return function(obj){return obj[1 + n]}}(n);
              break;
             case 2:
              var
               e=next(0),
               n$0=next(0),
               clo$0=
                function(e,n){return function(obj){return obj[1 + e][1 + n]}}
                 (e,n$0);
              break;
             case 3:
              var
               n$1=next(0),
               clo$0=
                function(n)
                  {return function(obj){return caml_call1(obj[1][1 + n],obj)}}
                 (n$1);
              break;
             case 4:
              var
               n$2=next(0),
               clo$0=
                function(n){return function(obj,x){obj[1 + n] = x;return 0}}
                 (n$2);
              break;
             case 5:
              var
               f=next(0),
               x$0=next(0),
               clo$0=
                function(f,x){return function(obj){return caml_call1(f,x)}}
                 (f,x$0);
              break;
             case 6:
              var
               f$0=next(0),
               n$3=next(0),
               clo$0=
                function(f,n)
                  {return function(obj){return caml_call1(f,obj[1 + n])}}
                 (f$0,n$3);
              break;
             case 7:
              var
               f$1=next(0),
               e$0=next(0),
               n$4=next(0),
               clo$0=
                function(f,e,n)
                  {return function(obj)
                    {return caml_call1(f,obj[1 + e][1 + n])}}
                 (f$1,e$0,n$4);
              break;
             case 8:
              var
               f$2=next(0),
               n$5=next(0),
               clo$0=
                function(f,n)
                  {return function(obj)
                    {return caml_call1(f,caml_call1(obj[1][1 + n],obj))}}
                 (f$2,n$5);
              break;
             case 9:
              var
               f$3=next(0),
               x$1=next(0),
               y=next(0),
               clo$0=
                function(f,x,y)
                  {return function(obj){return caml_call2(f,x,y)}}
                 (f$3,x$1,y);
              break;
             case 10:
              var
               f$4=next(0),
               x$2=next(0),
               n$6=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj){return caml_call2(f,x,obj[1 + n])}}
                 (f$4,x$2,n$6);
              break;
             case 11:
              var
               f$5=next(0),
               x$3=next(0),
               e$1=next(0),
               n$7=next(0),
               clo$0=
                function(f,x,e,n)
                  {return function(obj)
                    {return caml_call2(f,x,obj[1 + e][1 + n])}}
                 (f$5,x$3,e$1,n$7);
              break;
             case 12:
              var
               f$6=next(0),
               x$4=next(0),
               n$8=next(0),
               clo$0=
                function(f,x,n)
                  {return function(obj)
                    {return caml_call2(f,x,caml_call1(obj[1][1 + n],obj))}}
                 (f$6,x$4,n$8);
              break;
             case 13:
              var
               f$7=next(0),
               n$9=next(0),
               x$5=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj){return caml_call2(f,obj[1 + n],x)}}
                 (f$7,n$9,x$5);
              break;
             case 14:
              var
               f$8=next(0),
               e$2=next(0),
               n$10=next(0),
               x$6=next(0),
               clo$0=
                function(f,e,n,x)
                  {return function(obj)
                    {return caml_call2(f,obj[1 + e][1 + n],x)}}
                 (f$8,e$2,n$10,x$6);
              break;
             case 15:
              var
               f$9=next(0),
               n$11=next(0),
               x$7=next(0),
               clo$0=
                function(f,n,x)
                  {return function(obj)
                    {return caml_call2(f,caml_call1(obj[1][1 + n],obj),x)}}
                 (f$9,n$11,x$7);
              break;
             case 16:
              var
               n$12=next(0),
               x$8=next(0),
               clo$0=
                function(n,x)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,x)}}
                 (n$12,x$8);
              break;
             case 17:
              var
               n$13=next(0),
               m=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + m])}}
                 (n$13,m);
              break;
             case 18:
              var
               n$14=next(0),
               e$3=next(0),
               m$0=next(0),
               clo$0=
                function(n,e,m)
                  {return function(obj)
                    {return caml_call2(obj[1][1 + n],obj,obj[1 + e][1 + m])}}
                 (n$14,e$3,m$0);
              break;
             case 19:
              var
               n$15=next(0),
               m$1=next(0),
               clo$0=
                function(n,m)
                  {return function(obj)
                    {var _ge_=caml_call1(obj[1][1 + m],obj);
                     return caml_call2(obj[1][1 + n],obj,_ge_)}}
                 (n$15,m$1);
              break;
             case 20:
              var
               m$2=next(0),
               x$9=next(0),
               c=new_cache(table),
               clo$0=
                function(m,x,c)
                  {return function(obj)
                    {return caml_call2(caml_get_public_method(x,m,0),x,c)}}
                 (m$2,x$9,c);
              break;
             case 21:
              var
               m$3=next(0),
               n$16=next(0),
               c$0=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gd_=obj[1 + n];
                     return caml_call2(caml_get_public_method(_gd_,m,0),_gd_,c)}}
                 (m$3,n$16,c$0);
              break;
             case 22:
              var
               m$4=next(0),
               e$4=next(0),
               n$17=next(0),
               c$1=new_cache(table),
               clo$0=
                function(m,e,n,c)
                  {return function(obj)
                    {var _gc_=obj[1 + e][1 + n];
                     return caml_call2(caml_get_public_method(_gc_,m,0),_gc_,c)}}
                 (m$4,e$4,n$17,c$1);
              break;
             default:
              var
               m$5=next(0),
               n$18=next(0),
               c$2=new_cache(table),
               clo$0=
                function(m,n,c)
                  {return function(obj)
                    {var _gf_=caml_call1(obj[1][1 + n],obj);
                     return caml_call2(caml_get_public_method(_gf_,m,0),_gf_,c)}}
                 (m$5,n$18,c$2)}
          else
           var clo$0=clo;
          set_method(table,label,clo$0);
          i[1]++;
          continue}
        return 0}}
    function stats$0(param)
     {return [0,table_count[1],method_count[1],inst_var_count[1]]}
    var
     CamlinternalOO=
      [0,
       public_method_label,
       new_method,
       new_variable,
       new_methods_variables,
       get_variable,
       get_variables,
       get_method_label,
       get_method_labels,
       get_method,
       set_method,
       set_methods,
       narrow,
       widen,
       add_initializer,
       dummy_table,
       create_table,
       init_class,
       inherits,
       make_class,
       make_class_store,
       dummy_class,
       copy$7,
       create_object,
       create_object_opt,
       run_initializers,
       run_initializers_opt,
       create_object_and_run_initiali,
       lookup_tables,
       params$0,
       stats$0];
    caml_register_global(797,CamlinternalOO,"CamlinternalOO");
    var Stdlib_oo=[0,copy$7,public_method_label,public_method_label];
    caml_register_global(798,Stdlib_oo,"Stdlib__oo");
    var
     update_mod=runtime.caml_CamlinternalMod_update_mod,
     init_mod=runtime.caml_CamlinternalMod_init_mod,
     CamlinternalMod=[0,init_mod,update_mod];
    caml_register_global(799,CamlinternalMod,"CamlinternalMod");
    var
     initial_buffer=caml_create_bytes(32),
     buffer=[0,initial_buffer],
     bufpos=[0,0];
    function reset_buffer(param)
     {buffer[1] = initial_buffer;bufpos[1] = 0;return 0}
    function store(c)
     {if(caml_ml_bytes_length(buffer[1]) <= bufpos[1])
       {var newbuffer=caml_create_bytes(2 * bufpos[1] | 0);
        blit(buffer[1],0,newbuffer,0,bufpos[1]);
        buffer[1] = newbuffer}
      caml_bytes_set(buffer[1],bufpos[1],c);
      bufpos[1]++;
      return 0}
    function get_string(param)
     {var s=sub_string(buffer[1],0,bufpos[1]);
      buffer[1] = initial_buffer;
      return s}
    function make_lexer(keywords)
     {var kwd_table=caml_call2(Stdlib_hashtbl[1],0,17);
      iter$2
       (function(s){return caml_call3(Stdlib_hashtbl[5],kwd_table,s,[0,s])},
        keywords);
      function ident_or_keyword(id)
       {try
         {var _f$_=caml_call2(Stdlib_hashtbl[6],kwd_table,id);return _f$_}
        catch(_ga_)
         {_ga_ = caml_wrap_exception(_ga_);
          if(_ga_ === Not_found)return [1,id];
          throw _ga_}}
      function keyword_or_error(c)
       {var s=make$0(1,c);
        try
         {var _f9_=caml_call2(Stdlib_hashtbl[6],kwd_table,s);return _f9_}
        catch(_f__)
         {_f__ = caml_wrap_exception(_f__);
          if(_f__ === Not_found)
           throw [0,Error,symbol(cst_Illegal_character,s)];
          throw _f__}}
      function comment(strm)
       {a:
        for(;;)
         {var match=peek$0(strm);
          if(match)
           {var switcher=match[1] - 40 | 0;
            if(! (2 < switcher >>> 0))
             switch(switcher)
              {case 0:
                junk(strm);
                var match$0=peek$0(strm);
                if(match$0)
                 {if(42 === match$0[1]){junk(strm);comment(strm);continue}
                  junk(strm);
                  continue}
                throw Failure$0;
               case 1:break;
               default:
                junk(strm);
                for(;;)
                 {var match$1=peek$0(strm);
                  if(match$1)
                   {var _f8_=match$1[1];
                    if(41 === _f8_){junk(strm);return 0}
                    if(42 === _f8_){junk(strm);continue}
                    junk(strm);
                    continue a}
                  throw Failure$0}}
            junk(strm);
            continue}
          throw Failure$0}}
      function escape(strm)
       {var match=peek$0(strm);
        if(match)
         {var _f5_=match[1];
          if(58 <= _f5_)
           {var switcher=_f5_ - 110 | 0;
            if(! (6 < switcher >>> 0))
             switch(switcher)
              {case 0:junk(strm);return 10;
               case 4:junk(strm);return 13;
               case 6:junk(strm);return 9
               }}
          else
           if(48 <= _f5_)
            {junk(strm);
             var match$0=peek$0(strm);
             if(match$0)
              {var _f6_=match$0[1],switcher$0=_f6_ - 48 | 0;
               if(! (9 < switcher$0 >>> 0))
                {junk(strm);
                 var match$1=peek$0(strm);
                 if(match$1)
                  {var _f7_=match$1[1],switcher$1=_f7_ - 48 | 0;
                   if(! (9 < switcher$1 >>> 0))
                    {junk(strm);
                     return chr
                             ((((_f5_ - 48 | 0) * 100 | 0)
                               +
                               ((_f6_ - 48 | 0) * 10 | 0)
                               |
                               0)
                              +
                              (_f7_ - 48 | 0)
                              |
                              0)}}
                 throw [0,Error,cst$99]}}
             throw [0,Error,cst$98]}
          junk(strm);
          return _f5_}
        throw Failure$0}
      function end_exponent_part(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _f4_=match[1],switcher=_f4_ - 48 | 0;
            if(! (9 < switcher >>> 0)){junk(strm);store(_f4_);continue}}
          return [0,[3,caml_float_of_string(get_string(0))]]}}
      function exponent_part(strm)
       {var match=peek$0(strm);
        if(match)
         {var _f3_=match[1],switch$0=0;
          if(43 !== _f3_ && 45 !== _f3_)switch$0 = 1;
          if(! switch$0)
           {junk(strm);store(_f3_);return end_exponent_part(strm)}}
        return end_exponent_part(strm)}
      function number(s)
       {for(;;)
         {var match=peek$0(s);
          if(match)
           {var _f0_=match[1];
            if(58 <= _f0_)
             {var switch$0=0;
              if(69 === _f0_ || 101 === _f0_)switch$0 = 1;
              if(switch$0){junk(s);store(69);return exponent_part(s)}}
            else
             {if(46 === _f0_)
               {junk(s);
                store(46);
                for(;;)
                 {var match$0=peek$0(s);
                  if(match$0)
                   {var _f1_=match$0[1],_f2_=_f1_ - 69 | 0;
                    if(32 < _f2_ >>> 0)
                     {var switcher=_f2_ + 21 | 0;
                      if(! (9 < switcher >>> 0)){junk(s);store(_f1_);continue}}
                    else
                     {var switcher$0=_f2_ - 1 | 0;
                      if(30 < switcher$0 >>> 0)
                       {junk(s);store(69);return exponent_part(s)}}}
                  return [0,[3,caml_float_of_string(get_string(0))]]}}
              if(48 <= _f0_){junk(s);store(_f0_);continue}}}
          return [0,[2,caml_int_of_string(get_string(0))]]}}
      function ident2(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fY_=match[1],switch$0=0;
            if(94 <= _fY_)
             {var _fZ_=_fY_ - 95 | 0;
              if(30 < _fZ_ >>> 0)
               {if(! (32 <= _fZ_))switch$0 = 1}
              else
               if(29 === _fZ_)switch$0 = 1}
            else
             if(65 <= _fY_)
              {if(92 === _fY_)switch$0 = 1}
             else
              if(33 <= _fY_)
               switch(_fY_ - 33 | 0)
                {case 0:
                 case 2:
                 case 3:
                 case 4:
                 case 5:
                 case 9:
                 case 10:
                 case 12:
                 case 14:
                 case 25:
                 case 27:
                 case 28:
                 case 29:
                 case 30:
                 case 31:switch$0 = 1;break
                 }
            if(switch$0){junk(strm);store(_fY_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function neg_number(s)
       {var match=peek$0(s);
        if(match)
         {var _fX_=match[1],switcher=_fX_ - 48 | 0;
          if(! (9 < switcher >>> 0))
           {junk(s);reset_buffer(0);store(45);store(_fX_);return number(s)}}
        reset_buffer(0);
        store(45);
        return ident2(s)}
      function ident(strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fV_=match[1],switch$0=0;
            if(91 <= _fV_)
             {var _fW_=_fV_ - 95 | 0;
              if(27 < _fW_ >>> 0)
               {if(97 <= _fW_)switch$0 = 1}
              else
               if(1 !== _fW_)switch$0 = 1}
            else
             if(48 <= _fV_)
              {if(6 < (_fV_ - 58 | 0) >>> 0)switch$0 = 1}
             else
              if(39 === _fV_)switch$0 = 1;
            if(switch$0){junk(strm);store(_fV_);continue}}
          return [0,ident_or_keyword(get_string(0))]}}
      function next_token$0(counter,strm)
       {for(;;)
         {var match=peek$0(strm);
          if(match)
           {var _fL_=match[1],switch$0=0;
            if(124 <= _fL_)
             {if(127 <= _fL_)
               {if(192 <= _fL_)switch$0 = 1}
              else
               if(125 !== _fL_)switch$0 = 2}
            else
             {var _fM_=_fL_ - 65 | 0;
              if(57 < _fM_ >>> 0)
               {if(! (58 <= _fM_))
                 {var switcher=_fM_ + 65 | 0;
                  switch(switcher)
                   {case 34:
                     junk(strm);
                     reset_buffer(0);
                     for(;;)
                      {var match$1=peek$0(strm);
                       if(match$1)
                        {var _fO_=match$1[1];
                         if(34 === _fO_){junk(strm);return [0,[4,get_string(0)]]}
                         if(92 === _fO_)
                          {junk(strm);
                           try
                            {var c$0=escape(strm)}
                           catch(_fU_)
                            {_fU_ = caml_wrap_exception(_fU_);
                             if(_fU_ === Failure$0)throw [0,Error,cst$96];
                             throw _fU_;
                             var _fR_=_fU_}
                           store(c$0);
                           continue}
                         junk(strm);
                         store(_fO_);
                         continue}
                       throw Failure$0}
                    case 39:
                     junk(strm);
                     try
                      {var match$2=peek$0(strm);
                       if(! match$2)throw Failure$0;
                       var _fP_=match$2[1];
                       if(92 === _fP_)
                        {junk(strm);
                         try
                          {var _fQ_=escape(strm)}
                         catch(_fT_)
                          {_fT_ = caml_wrap_exception(_fT_);
                           if(_fT_ === Failure$0)throw [0,Error,cst$97];
                           throw _fT_}
                         var c=_fQ_}
                       else
                        {junk(strm);var c=_fP_}}
                     catch(_fS_)
                      {_fS_ = caml_wrap_exception(_fS_);
                       if(_fS_ === Failure$0)throw [0,Error,cst$94];
                       throw _fS_}
                     var match$0=peek$0(strm);
                     if(match$0 && 39 === match$0[1])
                      {junk(strm);return [0,[5,c]]}
                     throw [0,Error,cst$95];
                    case 40:
                     junk(strm);
                     if(counter < 50)
                      {var counter$0=counter + 1 | 0;
                       return maybe_comment(counter$0,strm)}
                     return caml_trampoline_return(maybe_comment,[0,strm]);
                    case 45:junk(strm);return neg_number(strm);
                    case 9:
                    case 10:
                    case 12:
                    case 13:
                    case 26:
                    case 32:junk(strm);continue;
                    case 48:
                    case 49:
                    case 50:
                    case 51:
                    case 52:
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 57:
                     junk(strm);reset_buffer(0);store(_fL_);return number(strm);
                    case 33:
                    case 35:
                    case 36:
                    case 37:
                    case 38:
                    case 42:
                    case 43:
                    case 47:
                    case 58:
                    case 60:
                    case 61:
                    case 62:
                    case 63:
                    case 64:switch$0 = 2;break
                    }}}
              else
               {var _fN_=_fM_ - 26 | 0;
                if(5 < _fN_ >>> 0)
                 switch$0 = 1;
                else
                 switch(_fN_)
                  {case 4:switch$0 = 1;break;case 1:case 3:switch$0 = 2;break}}}
            switch(switch$0)
             {case 0:junk(strm);return [0,keyword_or_error(_fL_)];
              case 1:
               junk(strm);reset_buffer(0);store(_fL_);return ident(strm);
              default:
               junk(strm);reset_buffer(0);store(_fL_);return ident2(strm)}}
          return 0}}
      function maybe_comment(counter,strm)
       {var match=peek$0(strm);
        if(match && 42 === match[1])
         {junk(strm);
          comment(strm);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return next_token$0(counter$0,strm)}
          return caml_trampoline_return(next_token$0,[0,strm])}
        return [0,keyword_or_error(40)]}
      function next_token(strm){return caml_trampoline(next_token$0(0,strm))}
      return function(input)
       {return from(function(count){return next_token(input)})}}
    var Stdlib_genlex=[0,make_lexer];
    caml_register_global(800,Stdlib_genlex,"Stdlib__genlex");
    function MakeSeeded$0(H)
     {var prng=[246,function(_fK_){return caml_call1(_b9_[2],0)}];
      function create(opt,initial_size)
       {if(opt)
         var sth=opt[1],random=sth;
        else
         var random=caml_call1(Stdlib_hashtbl[17],0);
        var x=16;
        for(;;)
         {if(! (initial_size <= x) && ! (max_array_length < (x * 2 | 0)))
           {var x$0=x * 2 | 0,x=x$0;continue}
          if(random)
           var
            _fI_=caml_obj_tag(prng),
            _fJ_=250 === _fI_?prng[1]:246 === _fI_?force_lazy_block(prng):prng,
            seed=caml_call1(_b9_[4],_fJ_);
          else
           var seed=0;
          return [0,0,caml_make_vect(x,0),seed,x]}}
      function clear(h)
       {h[1] = 0;
        var len=h[2].length - 1,_fG_=len - 1 | 0,_fF_=0;
        if(! (_fG_ < 0))
         {var i=_fF_;
          for(;;)
           {caml_check_bound(h[2],i)[1 + i] = 0;
            var _fH_=i + 1 | 0;
            if(_fG_ !== i){var i=_fH_;continue}
            break}}
        return 0}
      function reset(h)
       {var len=h[2].length - 1;
        return len === h[4]
                ?clear(h)
                :(h[1] = 0,h[2] = caml_make_vect(h[4],0),0)}
      function copy(init)
       {var _fC_=init[4],_fD_=init[3],_fE_=copy$1(init[2]);
        return [0,init[1],_fE_,_fD_,_fC_]}
      function key_index(h,hkey){return hkey & (h[2].length - 1 - 1 | 0)}
      function clean(h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hkey=param$0[1],rest=param$0[3],c=param$0[2];
              if(caml_call1(H[7],c))
               {var rest$0=param$0[3],c$0=param$0[2];
                return [0,hkey,c$0,do_bucket(rest$0)]}
              h[1] = h[1] - 1 | 0;
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_fz_=d.length - 1 - 1 | 0,_fy_=0;
        if(! (_fz_ < 0))
         {var i=_fy_;
          for(;;)
           {var _fA_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _fA_;
            var _fB_=i + 1 | 0;
            if(_fz_ !== i){var i=_fB_;continue}
            break}}
        return 0}
      function resize(h)
       {var odata=h[2],osize=odata.length - 1,nsize=osize * 2 | 0;
        clean(h);
        var
         _fr_=nsize < max_array_length?1:0,
         _fs_=_fr_?(osize >>> 1 | 0) <= h[1]?1:0:_fr_;
        if(_fs_)
         {var ndata=caml_make_vect(nsize,0);
          h[2] = ndata;
          var
           insert_bucket=
            function(param)
             {if(param)
               {var rest=param[3],data=param[2],hkey=param[1];
                insert_bucket(rest);
                var
                 nidx=key_index(h,hkey),
                 _fx_=[0,hkey,data,caml_check_bound(ndata,nidx)[1 + nidx]];
                caml_check_bound(ndata,nidx)[1 + nidx] = _fx_;
                return 0}
              return 0},
           _fu_=osize - 1 | 0,
           _ft_=0;
          if(! (_fu_ < 0))
           {var i=_ft_;
            for(;;)
             {insert_bucket(caml_check_bound(odata,i)[1 + i]);
              var _fw_=i + 1 | 0;
              if(_fu_ !== i){var i=_fw_;continue}
              break}}
          var _fv_=0}
        else
         var _fv_=_fs_;
        return _fv_}
      function add(h,key,info)
       {var
         hkey=caml_call2(H[2],h[3],key),
         i=key_index(h,hkey),
         container=caml_call2(H[1],key,info),
         bucket=[0,hkey,container,caml_check_bound(h[2],i)[1 + i]];
        caml_check_bound(h[2],i)[1 + i] = bucket;
        h[1] = h[1] + 1 | 0;
        var _fq_=h[2].length - 1 << 1 < h[1]?1:0;
        return _fq_?resize(h):_fq_}
      function remove(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function remove_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:h[1] = h[1] - 1 | 0;return next;
                  case 1:return [0,hk,c,remove_bucket(next)];
                  default:h[1] = h[1] - 1 | 0;var param$0=next;continue}}
              var next$0=param$0[3],c$0=param$0[2];
              return [0,hk,c$0,remove_bucket(next$0)]}
            return 0}}
        var
         i=key_index(h,hkey),
         _fp_=remove_bucket(caml_check_bound(h[2],i)[1 + i]);
        caml_check_bound(h[2],i)[1 + i] = _fp_;
        return 0}
      function find(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fo_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fo_)[1 + _fo_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var match$0=caml_call1(H[4],c);
                 if(match$0){var d=match$0[1];return d}
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          throw Not_found}}
      function find_opt(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fn_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fn_)[1 + _fn_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hkey === hk)
             {var match=caml_call2(H[3],c,key);
              switch(match)
               {case 0:
                 var d=caml_call1(H[4],c);
                 if(d)return d;
                 var param=rest;
                 continue;
                case 1:var param=rest;continue;
                default:var param=rest;continue}}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function find_all(h,key)
       {var hkey=caml_call2(H[2],h[3],key);
        function find_in_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],rest=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                switch(match)
                 {case 0:
                   var match$0=caml_call1(H[4],c);
                   if(match$0)
                    {var d=match$0[1];return [0,d,find_in_bucket(rest)]}
                   var param$0=rest;
                   continue;
                  case 1:var param$0=rest;continue;
                  default:var param$0=rest;continue}}
              var param$1=param$0[3],param$0=param$1;
              continue}
            return 0}}
        var _fm_=key_index(h,hkey);
        return find_in_bucket(caml_check_bound(h[2],_fm_)[1 + _fm_])}
      function replace(h,key,info)
       {var hkey=caml_call2(H[2],h[3],key);
        function replace_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var hk=param$0[1],next=param$0[3],c=param$0[2];
              if(hkey === hk)
               {var match=caml_call2(H[3],c,key);
                if(match){var param$0=next;continue}
                return caml_call3(H[6],c,key,info)}
              var param$1=param$0[3],param$0=param$1;
              continue}
            throw Not_found}}
        var i=key_index(h,hkey),l=caml_check_bound(h[2],i)[1 + i];
        try
         {var _fk_=replace_bucket(l);return _fk_}
        catch(_fl_)
         {_fl_ = caml_wrap_exception(_fl_);
          if(_fl_ === Not_found)
           {var container=caml_call2(H[1],key,info);
            caml_check_bound(h[2],i)[1 + i] = [0,hkey,container,l];
            h[1] = h[1] + 1 | 0;
            var _fj_=h[2].length - 1 << 1 < h[1]?1:0;
            return _fj_?resize(h):_fj_}
          throw _fl_}}
      function mem(h,key)
       {var
         hkey=caml_call2(H[2],h[3],key),
         _fi_=key_index(h,hkey),
         param$1=caml_check_bound(h[2],_fi_)[1 + _fi_],
         param=param$1;
        for(;;)
         {if(param)
           {var hk=param[1],rest=param[3],c=param[2];
            if(hk === hkey)
             {var match=caml_call2(H[3],c,key);
              if(match){var param=rest;continue}
              return 1}
            var param$0=param[3],param=param$0;
            continue}
          return 0}}
      function iter$0(f,h)
       {var d$0=h[2],_fg_=d$0.length - 1 - 1 | 0,_ff_=0;
        if(! (_fg_ < 0))
         {var i=_ff_;
          a:
          for(;;)
           {var param$0=caml_check_bound(d$0,i)[1 + i],param=param$0;
            for(;;)
             {if(param)
               {var
                 rest=param[3],
                 c=param[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1];caml_call2(f,k,d);switch$0 = 1}
                var param=rest;
                continue}
              var _fh_=i + 1 | 0;
              if(_fg_ !== i){var i=_fh_;continue a}
              break}
            break}}
        return 0}
      function fold(f,h,init)
       {var d$0=h[2],accu$1=[0,init],_fc_=d$0.length - 1 - 1 | 0,_fb_=0;
        if(! (_fc_ < 0))
         {var i=_fb_;
          a:
          for(;;)
           {var
             _fd_=accu$1[1],
             b$0=caml_check_bound(d$0,i)[1 + i],
             b=b$0,
             accu=_fd_;
            for(;;)
             {if(b)
               {var
                 rest=b[3],
                 c=b[2],
                 match=caml_call1(H[5],c),
                 match$0=caml_call1(H[4],c),
                 switch$0=0;
                if(match && match$0)
                 {var d=match$0[1],k=match[1],accu$0=caml_call3(f,k,d,accu);
                  switch$0 = 1}
                if(! switch$0)var accu$0=accu;
                var b=rest,accu=accu$0;
                continue}
              accu$1[1] = accu;
              var _fe_=i + 1 | 0;
              if(_fc_ !== i){var i=_fe_;continue a}
              break}
            break}}
        return accu$1[1]}
      function filter_map_inplace(f,h)
       {function do_bucket(param)
         {var param$0=param;
          for(;;)
           {if(param$0)
             {var
               rest=param$0[3],
               c=param$0[2],
               hk=param$0[1],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var d=match$0[1],k=match[1],match$1=caml_call2(f,k,d);
                if(match$1)
                 {var new_d=match$1[1];
                  caml_call3(H[6],c,k,new_d);
                  return [0,hk,c,do_bucket(rest)]}
                var param$0=rest;
                continue}
              var param$0=rest;
              continue}
            return 0}}
        var d=h[2],_e__=d.length - 1 - 1 | 0,_e9_=0;
        if(! (_e__ < 0))
         {var i=_e9_;
          for(;;)
           {var _e$_=do_bucket(caml_check_bound(d,i)[1 + i]);
            caml_check_bound(d,i)[1 + i] = _e$_;
            var _fa_=i + 1 | 0;
            if(_e__ !== i){var i=_fa_;continue}
            break}}
        return 0}
      function length(h){return h[1]}
      function bucket_length(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var
             param$1=param$0[3],
             accu$1=accu$0 + 1 | 0,
             accu$0=accu$1,
             param$0=param$1;
            continue}
          return accu$0}}
      function stats(h)
       {var
         _e5_=h[2],
         _e6_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length(0,b))},_e6_,_e5_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _e7_=h[2];
        iter$5
         (function(b)
           {var
             l=bucket_length(0,b),
             _e8_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _e8_;
            return 0},
          _e7_);
        return [0,h[1],h[2].length - 1,mbl,histo]}
      function bucket_length_alive(accu,param)
       {var accu$0=accu,param$0=param;
        for(;;)
         {if(param$0)
           {var rest=param$0[3],c=param$0[2];
            if(caml_call1(H[7],c))
             {var accu$1=accu$0 + 1 | 0,accu$0=accu$1,param$0=rest;continue}
            var param$1=param$0[3],param$0=param$1;
            continue}
          return accu$0}}
      function stats_alive(h)
       {var
         size=[0,0],
         _e1_=h[2],
         _e2_=0,
         mbl=
          fold_left$1
           (function(m,b){return max(m,bucket_length_alive(0,b))},_e2_,_e1_),
         histo=caml_make_vect(mbl + 1 | 0,0),
         _e3_=h[2];
        iter$5
         (function(b)
           {var l=bucket_length_alive(0,b);
            size[1] = size[1] + l | 0;
            var _e4_=caml_check_bound(histo,l)[1 + l] + 1 | 0;
            caml_check_bound(histo,l)[1 + l] = _e4_;
            return 0},
          _e3_);
        return [0,size[1],h[2].length - 1,mbl,histo]}
      function to_seq(tbl)
       {var tbl_data=tbl[2];
        function aux(i,buck,param)
         {var i$0=i,buck$0=buck;
          for(;;)
           {if(buck$0)
             {var
               next=buck$0[3],
               c=buck$0[2],
               match=caml_call1(H[5],c),
               match$0=caml_call1(H[4],c);
              if(match && match$0)
               {var data=match$0[1],key=match[1];
                return [0,
                        [0,key,data],
                        function(_e0_){return aux(i$0,next,_e0_)}]}
              var buck$0=next;
              continue}
            if(i$0 === tbl_data.length - 1)return 0;
            var
             buck$1=caml_check_bound(tbl_data,i$0)[1 + i$0],
             i$1=i$0 + 1 | 0,
             i$0=i$1,
             buck$0=buck$1;
            continue}}
        var _eX_=0,_eY_=0;
        return function(_eZ_){return aux(_eY_,_eX_,_eZ_)}}
      function to_seq_keys(m)
       {var _eT_=to_seq(m);
        function _eU_(_eW_){return _eW_[1]}
        return function(_eV_){return map(_eU_,_eT_,_eV_)}}
      function to_seq_values(m)
       {var _eP_=to_seq(m);
        function _eQ_(_eS_){return _eS_[2]}
        return function(_eR_){return map(_eQ_,_eP_,_eR_)}}
      function add_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return add(tbl,k,v)},
                 i)}
      function replace_seq(tbl,i)
       {return iter
                (function(param)
                  {var v=param[2],k=param[1];return replace(tbl,k,v)},
                 i)}
      function of_seq(i){var tbl=create(0,16);replace_seq(tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter$0,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$5(param){return caml_call1(_s_[1],1)}
    function get_key$0(t){return caml_call2(_s_[3],t,0)}
    function get_key_copy$0(t){return caml_call2(_s_[4],t,0)}
    function set_key$0(t,k){return caml_call3(_s_[5],t,0,k)}
    function unset_key$0(t){return caml_call2(_s_[6],t,0)}
    function check_key$0(t){return caml_call2(_s_[7],t,0)}
    function blit_key$0(t1,t2){return caml_call5(_s_[8],t1,0,t2,0,1)}
    function get_data$1(t){return caml_call1(_s_[9],t)}
    function get_data_copy(t){return caml_call1(_s_[10],t)}
    function set_data(t,d){return caml_call2(_s_[11],t,d)}
    function unset_data(t){return caml_call1(_s_[12],t)}
    function check_data(t){return caml_call1(_s_[13],t)}
    function blit_data(t1,t2){return caml_call2(_s_[14],t1,t2)}
    function MakeSeeded$1(H)
     {function create(k,d)
       {var c=create$5(0);set_data(c,d);set_key$0(c,k);return c}
      var hash=H[2];
      function equal(c,k)
       {var match=get_key$0(c);
        if(match){var k$0=match[1];return caml_call2(H[1],k,k$0)?0:1}
        return 2}
      function set_key_data(c,k,d)
       {unset_data(c);set_key$0(c,k);return set_data(c,d)}
      return MakeSeeded$0
              ([0,
                create,
                hash,
                equal,
                get_data$1,
                get_key$0,
                set_key_data,
                check_key$0])}
    function Make$2(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$1([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eO_=include[1];
      function create(sz){return caml_call2(_eO_,_cG_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$6(param){return caml_call1(_s_[1],2)}
    function get_key1(t){return caml_call2(_s_[3],t,0)}
    function get_key1_copy(t){return caml_call2(_s_[4],t,0)}
    function set_key1(t,k){return caml_call3(_s_[5],t,0,k)}
    function unset_key1(t){return caml_call2(_s_[6],t,0)}
    function check_key1(t){return caml_call2(_s_[7],t,0)}
    function get_key2(t){return caml_call2(_s_[3],t,1)}
    function get_key2_copy(t){return caml_call2(_s_[4],t,1)}
    function set_key2(t,k){return caml_call3(_s_[5],t,1,k)}
    function unset_key2(t){return caml_call2(_s_[6],t,1)}
    function check_key2(t){return caml_call2(_s_[7],t,1)}
    function blit_key1(t1,t2){return caml_call5(_s_[8],t1,0,t2,0,1)}
    function blit_key2(t1,t2){return caml_call5(_s_[8],t1,1,t2,1,1)}
    function blit_key12(t1,t2){return caml_call5(_s_[8],t1,0,t2,0,2)}
    function get_data$2(t){return caml_call1(_s_[9],t)}
    function get_data_copy$0(t){return caml_call1(_s_[10],t)}
    function set_data$0(t,d){return caml_call2(_s_[11],t,d)}
    function unset_data$0(t){return caml_call1(_s_[12],t)}
    function check_data$0(t){return caml_call1(_s_[13],t)}
    function blit_data$0(t1,t2){return caml_call2(_s_[14],t1,t2)}
    function MakeSeeded$2(H1,H2)
     {function create(param,d)
       {var k2=param[2],k1=param[1],c=create$6(0);
        set_data$0(c,d);
        set_key1(c,k1);
        set_key2(c,k2);
        return c}
      function hash(seed,param)
       {var
         k2=param[2],
         k1=param[1],
         _eN_=caml_call2(H2[2],seed,k2) * 65599 | 0;
        return caml_call2(H1[2],seed,k1) + _eN_ | 0}
      function equal(c,param)
       {var k2=param[2],k1=param[1],match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2$0=match$0[1],k1$0=match[1];
          if(caml_call2(H1[1],k1,k1$0) && caml_call2(H2[1],k2,k2$0))return 0;
          return 1}
        return 2}
      function get_key(c)
       {var match=get_key1(c),match$0=get_key2(c);
        if(match && match$0)
         {var k2=match$0[1],k1=match[1];return [0,[0,k1,k2]]}
        return 0}
      function set_key_data(c,param,d)
       {var k2=param[2],k1=param[1];
        unset_data$0(c);
        set_key1(c,k1);
        set_key2(c,k2);
        return set_data$0(c,d)}
      function check_key(c)
       {var _eM_=check_key1(c);return _eM_?check_key2(c):_eM_}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$2,get_key,set_key_data,check_key])}
    function Make$3(H1,H2)
     {var equal=H2[1];
      function hash(seed,x){return caml_call1(H2[2],x)}
      var equal$0=H1[1],_eK_=[0,equal,hash];
      function hash$0(seed,x){return caml_call1(H1[2],x)}
      var
       include=MakeSeeded$2([0,equal$0,hash$0],_eK_),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eL_=include[1];
      function create(sz){return caml_call2(_eL_,_cH_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    function create$7(n){return caml_call1(_s_[1],n)}
    function length$6(k){return caml_call1(_s_[2],k)}
    function get_key$1(t,n){return caml_call2(_s_[3],t,n)}
    function get_key_copy$1(t,n){return caml_call2(_s_[4],t,n)}
    function set_key$1(t,n,k){return caml_call3(_s_[5],t,n,k)}
    function unset_key$1(t,n){return caml_call2(_s_[6],t,n)}
    function check_key$1(t,n){return caml_call2(_s_[7],t,n)}
    function blit_key$1(t1,o1,t2,o2,l)
     {return caml_call5(_s_[8],t1,o1,t2,o2,l)}
    function get_data$3(t){return caml_call1(_s_[9],t)}
    function get_data_copy$1(t){return caml_call1(_s_[10],t)}
    function set_data$1(t,d){return caml_call2(_s_[11],t,d)}
    function unset_data$1(t){return caml_call1(_s_[12],t)}
    function check_data$1(t){return caml_call1(_s_[13],t)}
    function blit_data$1(t1,t2){return caml_call2(_s_[14],t1,t2)}
    function MakeSeeded$3(H)
     {function create(k,d)
       {var c=create$7(k.length - 1);
        set_data$1(c,d);
        var _eI_=k.length - 1 - 1 | 0,_eH_=0;
        if(! (_eI_ < 0))
         {var i=_eH_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _eJ_=i + 1 | 0;
            if(_eI_ !== i){var i=_eJ_;continue}
            break}}
        return c}
      function hash(seed,k)
       {var h=[0,0],_eD_=k.length - 1 - 1 | 0,_eC_=0;
        if(! (_eD_ < 0))
         {var i=_eC_;
          for(;;)
           {var _eE_=h[1],_eF_=caml_check_bound(k,i)[1 + i];
            h[1] = (caml_call2(H[2],seed,_eF_) * 65599 | 0) + _eE_ | 0;
            var _eG_=i + 1 | 0;
            if(_eD_ !== i){var i=_eG_;continue}
            break}}
        return h[1]}
      function equal(c,k)
       {var len=k.length - 1,len$0=length$6(c);
        if(len !== len$0)return 1;
        var i$1=len - 1 | 0,i=i$1;
        for(;;)
         {if(0 <= i)
           {var match=get_key$1(c,i);
            if(match)
             {var ki=match[1],_eB_=caml_check_bound(k,i)[1 + i];
              if(caml_call2(H[1],_eB_,ki)){var i$0=i - 1 | 0,i=i$0;continue}
              return 1}
            return 2}
          return 0}}
      function get_key(c)
       {var len=length$6(c);
        if(0 === len)return [0,[0]];
        var match=get_key$1(c,0);
        if(match)
         {var k0=match[1],a=caml_make_vect(len,k0),i$1=len - 1 | 0,i=i$1;
          for(;;)
           {if(1 <= i)
             {var match$0=get_key$1(c,i);
              if(match$0)
               {var ki=match$0[1];
                caml_check_bound(a,i)[1 + i] = ki;
                var i$0=i - 1 | 0,i=i$0;
                continue}
              return 0}
            return [0,a]}}
        return 0}
      function set_key_data(c,k,d)
       {unset_data$1(c);
        var _ez_=k.length - 1 - 1 | 0,_ey_=0;
        if(! (_ez_ < 0))
         {var i=_ey_;
          for(;;)
           {set_key$1(c,i,caml_check_bound(k,i)[1 + i]);
            var _eA_=i + 1 | 0;
            if(_ez_ !== i){var i=_eA_;continue}
            break}}
        return set_data$1(c,d)}
      function check_key(c)
       {var i$1=length$6(c) - 1 | 0,i=i$1;
        for(;;)
         {var _ev_=i < 0?1:0;
          if(_ev_)
           var _ew_=_ev_;
          else
           {var _ex_=check_key$1(c,i);
            if(_ex_){var i$0=i - 1 | 0,i=i$0;continue}
            var _ew_=_ex_}
          return _ew_}}
      return MakeSeeded$0
              ([0,create,hash,equal,get_data$3,get_key,set_key_data,check_key])}
    function Make$4(H)
     {var equal=H[1];
      function hash(seed,x){return caml_call1(H[2],x)}
      var
       include=MakeSeeded$3([0,equal,hash]),
       clear=include[2],
       reset=include[3],
       copy=include[4],
       add=include[5],
       remove=include[6],
       find=include[7],
       find_opt=include[8],
       find_all=include[9],
       replace=include[10],
       mem=include[11],
       iter=include[12],
       filter_map_inplace=include[13],
       fold=include[14],
       length=include[15],
       stats=include[16],
       to_seq=include[17],
       to_seq_keys=include[18],
       to_seq_values=include[19],
       add_seq=include[20],
       replace_seq=include[21],
       clean=include[23],
       stats_alive=include[24],
       _eu_=include[1];
      function create(sz){return caml_call2(_eu_,_cI_,sz)}
      function of_seq(i)
       {var tbl=create(16);caml_call2(replace_seq,tbl,i);return tbl}
      return [0,
              create,
              clear,
              reset,
              copy,
              add,
              remove,
              find,
              find_opt,
              find_all,
              replace,
              mem,
              iter,
              filter_map_inplace,
              fold,
              length,
              stats,
              to_seq,
              to_seq_keys,
              to_seq_values,
              add_seq,
              replace_seq,
              of_seq,
              clean,
              stats_alive]}
    var
     Stdlib_ephemeron=
      [0,
       [0,
        create$5,
        get_key$0,
        get_key_copy$0,
        set_key$0,
        unset_key$0,
        check_key$0,
        blit_key$0,
        get_data$1,
        get_data_copy,
        set_data,
        unset_data,
        check_data,
        blit_data,
        Make$2,
        MakeSeeded$1],
       [0,
        create$6,
        get_key1,
        get_key1_copy,
        set_key1,
        unset_key1,
        check_key1,
        get_key2,
        get_key2_copy,
        set_key2,
        unset_key2,
        check_key2,
        blit_key1,
        blit_key2,
        blit_key12,
        get_data$2,
        get_data_copy$0,
        set_data$0,
        unset_data$0,
        check_data$0,
        blit_data$0,
        Make$3,
        MakeSeeded$2],
       [0,
        create$7,
        get_key$1,
        get_key_copy$1,
        set_key$1,
        unset_key$1,
        check_key$1,
        blit_key$1,
        get_data$3,
        get_data_copy$1,
        set_data$1,
        unset_data$1,
        check_data$1,
        blit_data$1,
        Make$4,
        MakeSeeded$3],
       [0,
        function(_et_)
         {return MakeSeeded$0
                  ([0,_et_[3],_et_[1],_et_[2],_et_[5],_et_[4],_et_[6],_et_[7]])}]];
    caml_register_global(801,Stdlib_ephemeron,"Stdlib__ephemeron");
    function generic_basename(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$100))return current_dir_name;
      var n$3=caml_ml_string_length(name) - 1 | 0,n=n$3;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var p=n + 1 | 0,n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               return sub$0(name,n$1 + 1 | 0,(p - n$1 | 0) - 1 | 0);
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return sub$0(name,0,p)}}
        return sub$0(name,0,1)}}
    function generic_dirname(is_dir_sep,current_dir_name,name)
     {if(caml_string_equal(name,cst$101))return current_dir_name;
      var n$5=caml_ml_string_length(name) - 1 | 0,n=n$5;
      for(;;)
       {if(0 <= n)
         {if(caml_call2(is_dir_sep,name,n)){var n$0=n - 1 | 0,n=n$0;continue}
          var n$1=n;
          for(;;)
           {if(0 <= n$1)
             {if(caml_call2(is_dir_sep,name,n$1))
               {var n$3=n$1;
                for(;;)
                 {if(0 <= n$3)
                   {if(caml_call2(is_dir_sep,name,n$3))
                     {var n$4=n$3 - 1 | 0,n$3=n$4;continue}
                    return sub$0(name,0,n$3 + 1 | 0)}
                  return sub$0(name,0,1)}}
              var n$2=n$1 - 1 | 0,n$1=n$2;
              continue}
            return current_dir_name}}
        return sub$0(name,0,1)}}
    function is_dir_sep(s,i){return 47 === caml_string_get(s,i)?1:0}
    function is_relative(n)
     {var
       _er_=caml_ml_string_length(n) < 1?1:0,
       _es_=_er_ || (47 !== caml_string_get(n,0)?1:0);
      return _es_}
    function is_implicit(n)
     {var _em_=is_relative(n);
      if(_em_)
       {var
         _en_=caml_ml_string_length(n) < 2?1:0,
         _eo_=_en_ || caml_string_notequal(sub$0(n,0,2),cst$103);
        if(_eo_)
         var
          _ep_=caml_ml_string_length(n) < 3?1:0,
          _eq_=_ep_ || caml_string_notequal(sub$0(n,0,3),cst$102);
        else
         var _eq_=_eo_}
      else
       var _eq_=_em_;
      return _eq_}
    function check_suffix(name,suff)
     {var
       _ek_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0,
       _el_=
        _ek_
         ?caml_string_equal
           (sub$0
             (name,
              caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
              caml_ml_string_length(suff)),
            suff)
         :_ek_;
      return _el_}
    function chop_suffix_opt(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var r=sub$0(filename,len_f - len_s | 0,len_s);
        return caml_string_equal(r,suffix)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cQ_=caml_sys_getenv(cst_TMPDIR),_cJ_=_cQ_}
    catch(_ej_)
     {_ej_ = caml_wrap_exception(_ej_);
      if(_ej_ !== Not_found)throw _ej_;
      var _cJ_=cst_tmp}
    function quote(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,39);
      var _eh_=l - 1 | 0,_eg_=0;
      if(! (_eh_ < 0))
       {var i=_eg_;
        for(;;)
         {if(39 === caml_string_get(s,i))
           add_string(b,quotequote);
          else
           add_char(b,caml_string_get(s,i));
          var _ei_=i + 1 | 0;
          if(_eh_ !== i){var i=_ei_;continue}
          break}}
      add_char(b,39);
      return contents(b)}
    function quote_command(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _ea_=caml_equal(stderr,stdout)?cst_2_1:symbol(cst_2,quote(f)),
        _eb_=_ea_;
      else
       var _eb_=cst$109;
      if(stdout)
       var f$0=stdout[1],_ec_=symbol(cst$104,quote(f$0));
      else
       var _ec_=cst$108;
      var _ed_=symbol(_ec_,_eb_);
      if(stdin)
       var f$1=stdin[1],_ee_=symbol(cst$105,quote(f$1));
      else
       var _ee_=cst$107;
      var _ef_=symbol(_ee_,_ed_);
      return symbol(concat$0(cst$106,map$2(quote,[0,cmd,args])),_ef_)}
    function basename(_d$_)
     {return generic_basename(is_dir_sep,current_dir_name,_d$_)}
    function dirname(_d__)
     {return generic_dirname(is_dir_sep,current_dir_name,_d__)}
    var
     Unix=
      [0,
       null$0,
       current_dir_name,
       parent_dir_name,
       dir_sep,
       is_dir_sep,
       is_relative,
       is_implicit,
       check_suffix,
       chop_suffix_opt,
       _cJ_,
       quote,
       quote_command,
       basename,
       dirname];
    function is_dir_sep$0(s,i)
     {var c=caml_string_get(s,i),_d7_=47 === c?1:0;
      if(_d7_)
       var _d8_=_d7_;
      else
       var _d9_=92 === c?1:0,_d8_=_d9_ || (58 === c?1:0);
      return _d8_}
    function is_relative$0(n)
     {var
       _d1_=caml_ml_string_length(n) < 1?1:0,
       _d2_=_d1_ || (47 !== caml_string_get(n,0)?1:0);
      if(_d2_)
       {var
         _d3_=caml_ml_string_length(n) < 1?1:0,
         _d4_=_d3_ || (92 !== caml_string_get(n,0)?1:0);
        if(_d4_)
         var
          _d5_=caml_ml_string_length(n) < 2?1:0,
          _d6_=_d5_ || (58 !== caml_string_get(n,1)?1:0);
        else
         var _d6_=_d4_}
      else
       var _d6_=_d2_;
      return _d6_}
    function is_implicit$0(n)
     {var _dS_=is_relative$0(n);
      if(_dS_)
       {var
         _dT_=caml_ml_string_length(n) < 2?1:0,
         _dU_=_dT_ || caml_string_notequal(sub$0(n,0,2),cst$113);
        if(_dU_)
         {var
           _dV_=caml_ml_string_length(n) < 2?1:0,
           _dW_=_dV_ || caml_string_notequal(sub$0(n,0,2),cst$112);
          if(_dW_)
           {var
             _dX_=caml_ml_string_length(n) < 3?1:0,
             _dY_=_dX_ || caml_string_notequal(sub$0(n,0,3),cst$111);
            if(_dY_)
             var
              _dZ_=caml_ml_string_length(n) < 3?1:0,
              _d0_=_dZ_ || caml_string_notequal(sub$0(n,0,3),cst$110);
            else
             var _d0_=_dY_}
          else
           var _d0_=_dW_}
        else
         var _d0_=_dU_}
      else
       var _d0_=_dS_;
      return _d0_}
    function check_suffix$0(name,suff)
     {var _dP_=caml_ml_string_length(suff) <= caml_ml_string_length(name)?1:0;
      if(_dP_)
       var
        s=
         sub$0
          (name,
           caml_ml_string_length(name) - caml_ml_string_length(suff) | 0,
           caml_ml_string_length(suff)),
        _dQ_=lowercase_ascii$1(suff),
        _dR_=caml_string_equal(lowercase_ascii$1(s),_dQ_);
      else
       var _dR_=_dP_;
      return _dR_}
    function chop_suffix_opt$0(suffix,filename)
     {var
       len_s=caml_ml_string_length(suffix),
       len_f=caml_ml_string_length(filename);
      if(len_s <= len_f)
       {var
         r=sub$0(filename,len_f - len_s | 0,len_s),
         _dO_=lowercase_ascii$1(suffix);
        return caml_string_equal(lowercase_ascii$1(r),_dO_)
                ?[0,sub$0(filename,0,len_f - len_s | 0)]
                :0}
      return 0}
    try
     {var _cP_=caml_sys_getenv(cst_TEMP),temp_dir_name=_cP_}
    catch(_dN_)
     {_dN_ = caml_wrap_exception(_dN_);
      if(_dN_ !== Not_found)throw _dN_;
      var temp_dir_name=cst$114}
    function quote$0(s)
     {var l=caml_ml_string_length(s),b=create$2(l + 20 | 0);
      add_char(b,34);
      function add_bs(n)
       {var _dL_=1;
        if(! (n < 1))
         {var j=_dL_;
          for(;;)
           {add_char(b,92);
            var _dM_=j + 1 | 0;
            if(n !== j){var j=_dM_;continue}
            break}}
        return 0}
      function loop$0(counter,i)
       {var i$0=i;
        for(;;)
         {if(i$0 === l)return add_char(b,34);
          var c=caml_string_get(s,i$0);
          if(34 === c)
           {var _dJ_=0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return loop_bs(counter$1,_dJ_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dJ_,i$0])}
          if(92 === c)
           {var _dK_=0;
            if(counter < 50)
             {var counter$0=counter + 1 | 0;
              return loop_bs(counter$0,_dK_,i$0)}
            return caml_trampoline_return(loop_bs,[0,_dK_,i$0])}
          add_char(b,c);
          var i$1=i$0 + 1 | 0,i$0=i$1;
          continue}}
      function loop_bs(counter,n,i)
       {var n$0=n,i$0=i;
        for(;;)
         {if(i$0 === l){add_char(b,34);return add_bs(n$0)}
          var match=caml_string_get(s,i$0);
          if(34 === match)
           {add_bs((2 * n$0 | 0) + 1 | 0);
            add_char(b,34);
            var _dI_=i$0 + 1 | 0;
            if(counter < 50)
             {var counter$1=counter + 1 | 0;return loop$0(counter$1,_dI_)}
            return caml_trampoline_return(loop$0,[0,_dI_])}
          if(92 === match)
           {var i$1=i$0 + 1 | 0,n$1=n$0 + 1 | 0,n$0=n$1,i$0=i$1;continue}
          add_bs(n$0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;return loop$0(counter$0,i$0)}
          return caml_trampoline_return(loop$0,[0,i$0])}}
      function loop(i){return caml_trampoline(loop$0(0,i))}
      loop(0);
      return contents(b)}
    function quote_cmd_filename(f)
     {if(! contains$0(f,34) && ! contains$0(f,37))
       return contains$0(f,32)?symbol(cst$116,symbol(f,cst$115)):f;
      return failwith(symbol(cst_Filename_quote_command_bad,f))}
    function quote_command$0(cmd,stdin,stdout,stderr,args)
     {if(stderr)
       var
        f=stderr[1],
        _dz_=
         caml_equal(stderr,stdout)
          ?cst_2_1$0
          :symbol(cst_2$0,quote_cmd_filename(f)),
        _dA_=_dz_;
      else
       var _dA_=cst$125;
      var _dB_=[0,_dA_,_cK_];
      if(stdout)
       var f$0=stdout[1],_dC_=symbol(cst$117,quote_cmd_filename(f$0));
      else
       var _dC_=cst$124;
      var _dD_=[0,_dC_,_dB_];
      if(stdin)
       var f$1=stdin[1],_dE_=symbol(cst$118,quote_cmd_filename(f$1));
      else
       var _dE_=cst$123;
      var
       s=concat$0(cst$119,map$2(quote$0,args)),
       b=create$2(caml_ml_string_length(s) + 20 | 0),
       _dF_=[0,_dE_,_dD_];
      iter$4
       (function(c)
         {var switch$0=0;
          if(62 <= c)
           {var _dH_=c - 63 | 0;
            if(60 < _dH_ >>> 0)
             {if(! (62 <= _dH_))switch$0 = 1}
            else
             if(31 === _dH_)switch$0 = 1}
          else
           if(42 <= c)
            {if(60 === c)switch$0 = 1}
           else
            if(33 <= c)
             switch(c - 33 | 0)
              {case 2:case 3:case 6:break;default:switch$0 = 1}
          return switch$0?(add_char(b,94),add_char(b,c)):add_char(b,c)},
        s);
      var _dG_=[0,cst$120,[0,contents(b),_dF_]];
      return concat$0(cst$122,[0,cst$121,[0,quote_cmd_filename(cmd),_dG_]])}
    function drive_and_path(s)
     {var _dv_=2 <= caml_ml_string_length(s)?1:0;
      if(_dv_)
       {var param=caml_string_get(s,0),switch$0=0;
        if(91 <= param)
         {if(! (25 < (param - 97 | 0) >>> 0))switch$0 = 1}
        else
         if(65 <= param)switch$0 = 1;
        var _dw_=switch$0?1:0,_dx_=_dw_?58 === caml_string_get(s,1)?1:0:_dw_}
      else
       var _dx_=_dv_;
      if(_dx_)
       {var _dy_=sub$0(s,2,caml_ml_string_length(s) - 2 | 0);
        return [0,sub$0(s,0,2),_dy_]}
      return [0,cst$126,s]}
    function dirname$0(s)
     {var
       match=drive_and_path(s),
       path=match[2],
       drive=match[1],
       dir=generic_dirname(is_dir_sep$0,current_dir_name$0,path);
      return symbol(drive,dir)}
    function basename$0(s)
     {var match=drive_and_path(s),path=match[2];
      return generic_basename(is_dir_sep$0,current_dir_name$0,path)}
    var
     Win32=
      [0,
       null$1,
       current_dir_name$0,
       parent_dir_name$0,
       dir_sep$0,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       temp_dir_name,
       quote$0,
       quote_command$0,
       basename$0,
       dirname$0];
    function basename$1(_du_)
     {return generic_basename(is_dir_sep$0,current_dir_name$1,_du_)}
    function dirname$1(_dt_)
     {return generic_dirname(is_dir_sep$0,current_dir_name$1,_dt_)}
    var
     Cygwin=
      [0,
       null$2,
       current_dir_name$1,
       parent_dir_name$1,
       dir_sep$1,
       is_dir_sep$0,
       is_relative$0,
       is_implicit$0,
       check_suffix$0,
       chop_suffix_opt$0,
       _cJ_,
       quote,
       quote_command,
       basename$1,
       dirname$1],
     Sysdeps=
      caml_string_notequal(os_type,cst_Cygwin)
       ?caml_string_notequal(os_type,cst_Win32)?Unix:Win32
       :Cygwin,
     null$3=Sysdeps[1],
     current_dir_name$2=Sysdeps[2],
     parent_dir_name$2=Sysdeps[3],
     dir_sep$2=Sysdeps[4],
     is_dir_sep$1=Sysdeps[5],
     is_relative$1=Sysdeps[6],
     is_implicit$1=Sysdeps[7],
     check_suffix$1=Sysdeps[8],
     chop_suffix_opt$1=Sysdeps[9],
     temp_dir_name$0=Sysdeps[10],
     quote$1=Sysdeps[11],
     quote_command$1=Sysdeps[12],
     basename$2=Sysdeps[13],
     dirname$2=Sysdeps[14];
    function concat$3(dirname,filename)
     {var l=caml_ml_string_length(dirname);
      if(0 !== l && ! is_dir_sep$1(dirname,l - 1 | 0))
       return symbol(dirname,symbol(dir_sep$2,filename));
      return symbol(dirname,filename)}
    function chop_suffix(name,suff)
     {var n=caml_ml_string_length(name) - caml_ml_string_length(suff) | 0;
      return 0 <= n?sub$0(name,0,n):invalid_arg(cst_Filename_chop_suffix)}
    function extension_len(name)
     {var i$4=caml_ml_string_length(name) - 1 | 0,i$1=i$4;
      for(;;)
       {if(0 <= i$1 && ! is_dir_sep$1(name,i$1))
         {if(46 === caml_string_get(name,i$1))
           {var i$2=i$1 - 1 | 0,i=i$2;
            for(;;)
             {if(0 <= i && ! is_dir_sep$1(name,i))
               {if(46 === caml_string_get(name,i))
                 {var i$0=i - 1 | 0,i=i$0;continue}
                return caml_ml_string_length(name) - i$1 | 0}
              return 0}}
          var i$3=i$1 - 1 | 0,i$1=i$3;
          continue}
        return 0}}
    function extension(name)
     {var l=extension_len(name);
      return 0 === l?cst$127:sub$0(name,caml_ml_string_length(name) - l | 0,l)}
    function chop_extension(name)
     {var l=extension_len(name);
      return 0 === l
              ?invalid_arg(cst_Filename_chop_extension)
              :sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    function remove_extension(name)
     {var l=extension_len(name);
      return 0 === l?name:sub$0(name,0,caml_ml_string_length(name) - l | 0)}
    var prng$0=[246,function(_ds_){return caml_call1(_b9_[2],0)}];
    function temp_file_name(temp_dir,prefix,suffix)
     {var
       _dq_=caml_obj_tag(prng$0),
       _dr_=
        250 === _dq_?prng$0[1]:246 === _dq_?force_lazy_block(prng$0):prng$0,
       rnd=caml_call1(_b9_[4],_dr_) & 16777215;
      return concat$3(temp_dir,caml_call3(sprintf(_cL_),prefix,rnd,suffix))}
    var current_temp_dir_name=[0,temp_dir_name$0];
    function set_temp_dir_name(s){current_temp_dir_name[1] = s;return 0}
    function get_temp_dir_name(param){return current_temp_dir_name[1]}
    function temp_file(opt,prefix,suffix)
     {if(opt)
       var sth=opt[1],temp_dir=sth;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {runtime.caml_sys_close(caml_sys_open(name,_cM_,384));return name}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    function open_temp_file(opt,_do_,_dn_,prefix,suffix)
     {if(opt)var sth=opt[1],mode=sth;else var mode=_cN_;
      if(_do_)var sth$0=_do_[1],perms=sth$0;else var perms=384;
      if(_dn_)
       var sth$1=_dn_[1],temp_dir=sth$1;
      else
       var temp_dir=current_temp_dir_name[1];
      function try_name(counter)
       {var counter$0=counter;
        for(;;)
         {var name=temp_file_name(temp_dir,prefix,suffix);
          try
           {var _dp_=[0,name,open_out_gen([0,1,[0,3,[0,5,mode]]],perms,name)];
            return _dp_}
          catch(e)
           {e = caml_wrap_exception(e);
            if(e[1] === Sys_error)
             {if(1000 <= counter$0)throw e;
              var counter$1=counter$0 + 1 | 0,counter$0=counter$1;
              continue}
            throw e}}}
      return try_name(0)}
    var
     Stdlib_filename=
      [0,
       current_dir_name$2,
       parent_dir_name$2,
       dir_sep$2,
       concat$3,
       is_relative$1,
       is_implicit$1,
       check_suffix$1,
       chop_suffix,
       chop_suffix_opt$1,
       extension,
       remove_extension,
       chop_extension,
       basename$2,
       dirname$2,
       null$3,
       temp_file,
       open_temp_file,
       get_temp_dir_name,
       set_temp_dir_name,
       temp_dir_name$0,
       quote$1,
       quote_command$1];
    caml_register_global(802,Stdlib_filename,"Stdlib__filename");
    function add$1(x,y){return [254,x[1] + y[1],x[2] + y[2]]}
    function sub$4(x,y){return [254,x[1] - y[1],x[2] - y[2]]}
    function neg(x){return [254,- x[1],- x[2]]}
    function conj(x){return [254,x[1],- x[2]]}
    function mul(x,y)
     {return [254,x[1] * y[1] - x[2] * y[2],x[1] * y[2] + x[2] * y[1]]}
    function div(x,y)
     {if(Math.abs(y[2]) <= Math.abs(y[1]))
       {var r=y[2] / y[1],d=y[1] + r * y[2];
        return [254,(x[1] + r * x[2]) / d,(x[2] - r * x[1]) / d]}
      var r$0=y[1] / y[2],d$0=y[2] + r$0 * y[1];
      return [254,(r$0 * x[1] + x[2]) / d$0,(r$0 * x[2] - x[1]) / d$0]}
    function inv(x){return div(one$4,x)}
    function norm2(x){return x[1] * x[1] + x[2] * x[2]}
    function norm(x)
     {var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(r == 0.)return i;
      if(i == 0.)return r;
      if(i <= r){var q=i / r;return r * Math.sqrt(1. + q * q)}
      var q$0=r / i;
      return i * Math.sqrt(1. + q$0 * q$0)}
    function arg(x){return Math.atan2(x[2],x[1])}
    function polar(n,a){return [254,Math.cos(a) * n,Math.sin(a) * n]}
    function sqrt(x)
     {if(x[1] == 0. && x[2] == 0.)return _cO_;
      var r=Math.abs(x[1]),i=Math.abs(x[2]);
      if(i <= r)
       var
        q=i / r,
        w=Math.sqrt(r) * Math.sqrt(0.5 * (1. + Math.sqrt(1. + q * q)));
      else
       var
        q$0=r / i,
        w=Math.sqrt(i) * Math.sqrt(0.5 * (q$0 + Math.sqrt(1. + q$0 * q$0)));
      if(0. <= x[1])return [254,w,0.5 * x[2] / w];
      var w$0=0. <= x[2]?w:- w;
      return [254,0.5 * i / w,w$0]}
    function exp(x)
     {var e=Math.exp(x[1]);return [254,e * Math.cos(x[2]),e * Math.sin(x[2])]}
    function log(x)
     {var _dm_=Math.atan2(x[2],x[1]);return [254,Math.log(norm(x)),_dm_]}
    function pow(x,y){return exp(mul(y,log(x)))}
    var
     Stdlib_complex=
      [0,
       zero$4,
       one$4,
       i,
       neg,
       conj,
       add$1,
       sub$4,
       mul,
       inv,
       div,
       sqrt,
       norm2,
       norm,
       arg,
       polar,
       exp,
       log,
       pow];
    caml_register_global(803,Stdlib_complex,"Stdlib__complex");
    var
     Stdlib_arrayLabels=
      [0,
       init$2,
       create_matrix,
       create_matrix,
       append$1,
       concat$1,
       sub$1,
       copy$1,
       fill$0,
       blit$1,
       to_list$1,
       of_list,
       iter$5,
       map$5,
       iteri$2,
       mapi$2,
       fold_left$1,
       fold_right$0,
       iter2$0,
       map2$0,
       exists$0,
       for_all$0,
       for_all2$0,
       exists2$0,
       mem$0,
       memq$0,
       make_float,
       sort,
       fast_sort$0,
       fast_sort$0,
       to_seq$4,
       to_seqi$1,
       of_seq$2,
       Floatarray];
    caml_register_global(804,Stdlib_arrayLabels,"Stdlib__arrayLabels");
    var
     Stdlib_listLabels=
      [0,
       length,
       hd,
       compare_lengths,
       compare_length_with,
       cons$0,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       flatten,
       flatten,
       iter$2,
       iteri,
       map$2,
       mapi,
       rev_map,
       filter_map$0,
       concat_map,
       fold_left_map,
       fold_left$0,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       find_all,
       find_all,
       filteri,
       partition,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       fast_sort,
       fast_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq$1,
       of_seq];
    caml_register_global(805,Stdlib_listLabels,"Stdlib__listLabels");
    var
     Stdlib_bytesLabels=
      [0,
       make,
       init$0,
       empty$0,
       copy,
       of_string,
       to_string$1,
       sub,
       sub_string,
       extend,
       fill,
       blit,
       blit$0,
       concat,
       cat,
       iter$3,
       iteri$0,
       map$3,
       mapi$0,
       trim,
       escaped$0,
       index,
       index_opt,
       rindex,
       rindex_opt,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       contains,
       contains_from,
       rcontains_from,
       uppercase$0,
       lowercase$0,
       capitalize,
       uncapitalize,
       uppercase_ascii$0,
       lowercase_ascii$0,
       capitalize_ascii,
       uncapitalize_ascii,
       compare$4,
       equal$4,
       to_seq$2,
       to_seqi,
       of_seq$0,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       set_uint8,
       set_int8,
       set_uint16_ne,
       set_int16_be,
       set_int16_le,
       set_int16_ne,
       set_int16_be,
       set_int16_le,
       set_int32_ne,
       set_int32_be,
       set_int32_le,
       set_int64_ne,
       set_int64_be,
       set_int64_le,
       unsafe_to_string,
       unsafe_of_string];
    caml_register_global(806,Stdlib_bytesLabels,"Stdlib__bytesLabels");
    var
     Stdlib_stringLabels=
      [0,
       make$0,
       init$1,
       copy$0,
       sub$0,
       fill,
       blit$0,
       concat$0,
       iter$4,
       iteri$1,
       map$4,
       mapi$1,
       trim$0,
       escaped$1,
       index$0,
       index_opt$0,
       rindex$0,
       rindex_opt$0,
       index_from$0,
       index_from_opt$0,
       rindex_from$0,
       rindex_from_opt$0,
       contains$0,
       contains_from$0,
       rcontains_from$0,
       uppercase$1,
       lowercase$1,
       capitalize$0,
       uncapitalize$0,
       uppercase_ascii$1,
       lowercase_ascii$1,
       capitalize_ascii$0,
       uncapitalize_ascii$0,
       compare$5,
       equal$5,
       split_on_char,
       to_seq$3,
       to_seqi$0,
       of_seq$1];
    caml_register_global(807,Stdlib_stringLabels,"Stdlib__stringLabels");
    var Stdlib_moreLabels=[0,Stdlib_hashtbl,Stdlib_map,Stdlib_set];
    caml_register_global(808,Stdlib_moreLabels,"Stdlib__moreLabels");
    var Stdlib_stdLabels=[0];
    caml_register_global(809,Stdlib_stdLabels,"Stdlib__stdLabels");
    var enabled=caml_spacetime_enabled(0);
    function if_spacetime_enabled(f){return enabled?caml_call1(f,0):0}
    function create$8(path)
     {if(caml_spacetime_enabled(0))
       {var channel=open_out(path),t=[0,channel,0];
        caml_spacetime_only_works_for_(t[1]);
        return t}
      return [0,stdout,1]}
    function save_event(time,t,event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_(time,t[1],event_name)})}
    function save_and_close(time,t)
     {return if_spacetime_enabled
              (function(param)
                {if(t[2])failwith(cst_Series_is_closed);
                 caml_spacetime_only_works_for_(time,t[1]);
                 close_out(t[1]);
                 t[2] = 1;
                 return 0})}
    var Series=[0,create$8,save_event,save_and_close];
    function take$0(time,param)
     {var channel=param[1],closed=param[2];
      return if_spacetime_enabled
              (function(param)
                {if(closed)failwith(cst_Series_is_closed$0);
                 runtime.caml_gc_minor(0);
                 return caml_spacetime_only_works_for_(time,channel)})}
    var Snapshot=[0,take$0];
    function save_event_for_automatic_snaps(event_name)
     {return if_spacetime_enabled
              (function(param)
                {return caml_spacetime_only_works_for_(event_name)})}
    var
     Stdlib_spacetime=
      [0,enabled,Series,Snapshot,save_event_for_automatic_snaps];
    caml_register_global(810,Stdlib_spacetime,"Stdlib__spacetime");
    var
     float32=0,
     float64=1,
     int8_signed=2,
     int8_unsigned=3,
     int16_signed=4,
     int16_unsigned=5,
     int32$1=6,
     int64$1=7,
     int$2=8,
     nativeint$1=9,
     complex32=10,
     complex64=11,
     char$0=12;
    function kind_size_in_bytes(param)
     {switch(param)
       {case 0:return 4;
        case 1:return 8;
        case 2:return 1;
        case 3:return 1;
        case 4:return 2;
        case 5:return 2;
        case 6:return 4;
        case 7:return 8;
        case 8:return 4;
        case 9:return 4;
        case 10:return 8;
        case 11:return 16;
        default:return 1}}
    var c_layout=0,fortran_layout=1;
    function dims(a)
     {var n=caml_ba_num_dims(a),d=caml_make_vect(n,0),_dj_=n - 1 | 0,_di_=0;
      if(! (_dj_ < 0))
       {var i=_di_;
        for(;;)
         {var _dk_=runtime.caml_ba_dim(a,i);
          caml_check_bound(d,i)[1 + i] = _dk_;
          var _dl_=i + 1 | 0;
          if(_dj_ !== i){var i=_dl_;continue}
          break}}
      return d}
    function size_in_bytes(arr)
     {var _dh_=fold_left$1(caml_mul,1,dims(arr));
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_dh_)}
    var Genarray=[0,dims,size_in_bytes];
    function create$9(kind,layout){return caml_ba_create(kind,layout,[0])}
    function get$1(arr){return runtime.caml_ba_get_generic(arr,[0])}
    function set$0(arr)
     {var _df_=[0];
      return function(_dg_){return runtime.caml_ba_set_generic(arr,_df_,_dg_)}}
    function size_in_bytes$0(arr)
     {return kind_size_in_bytes(caml_ba_kind(arr))}
    function of_value(kind,layout,v)
     {var a=create$9(kind,layout);caml_call1(set$0(a),v);return a}
    function create$10(kind,layout,dim)
     {return caml_ba_create(kind,layout,[0,dim])}
    function size_in_bytes$1(arr)
     {var _de_=caml_ba_dim_1(arr);
      return caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_de_)}
    function slice(a,n)
     {var match=runtime.caml_ba_layout(a);
      return match?caml_ba_slice(a,[0,n]):caml_ba_slice(a,[0,n])}
    function of_array(kind,layout,data)
     {var
       ba=create$10(kind,layout,data.length - 1),
       ofs=layout?1:0,
       _dc_=data.length - 1 - 1 | 0,
       _db_=0;
      if(! (_dc_ < 0))
       {var i=_db_;
        for(;;)
         {runtime.caml_ba_set_1
           (ba,i + ofs | 0,caml_check_bound(data,i)[1 + i]);
          var _dd_=i + 1 | 0;
          if(_dc_ !== i){var i=_dd_;continue}
          break}}
      return ba}
    function create$11(kind,layout,dim1,dim2)
     {return caml_ba_create(kind,layout,[0,dim1,dim2])}
    function size_in_bytes$2(arr)
     {var _c$_=caml_ba_dim_2(arr),_da_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_da_),_c$_)}
    function slice_left(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$0(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       ba=create$11(kind,layout,dim1,dim2),
       ofs=layout?1:0,
       _c6_=dim1 - 1 | 0,
       _c5_=0;
      if(! (_c6_ < 0))
       {var i=_c5_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array2_of_array_n);
          var _c8_=dim2 - 1 | 0,_c7_=0;
          if(! (_c8_ < 0))
           {var j=_c7_;
            for(;;)
             {runtime.caml_ba_set_2
               (ba,i + ofs | 0,j + ofs | 0,caml_check_bound(row,j)[1 + j]);
              var _c__=j + 1 | 0;
              if(_c8_ !== j){var j=_c__;continue}
              break}}
          var _c9_=i + 1 | 0;
          if(_c6_ !== i){var i=_c9_;continue}
          break}}
      return ba}
    function create$12(kind,layout,dim1,dim2,dim3)
     {return caml_ba_create(kind,layout,[0,dim1,dim2,dim3])}
    function size_in_bytes$3(arr)
     {var
       _c2_=runtime.caml_ba_dim_3(arr),
       _c3_=caml_ba_dim_2(arr),
       _c4_=caml_ba_dim_1(arr);
      return caml_mul
              (caml_mul
                (caml_mul(kind_size_in_bytes(caml_ba_kind(arr)),_c4_),_c3_),
               _c2_)}
    function slice_left_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_right_1(a,n,m){return caml_ba_slice(a,[0,n,m])}
    function slice_left_2(a,n){return caml_ba_slice(a,[0,n])}
    function slice_right_2(a,n){return caml_ba_slice(a,[0,n])}
    function of_array$1(kind,layout,data)
     {var
       dim1=data.length - 1,
       dim2=0 === dim1?0:caml_check_bound(data,0)[1].length - 1,
       dim3=
        0 === dim2
         ?0
         :caml_check_bound(caml_check_bound(data,0)[1],0)[1].length - 1,
       ba=create$12(kind,layout,dim1,dim2,dim3),
       ofs=layout?1:0,
       _cU_=dim1 - 1 | 0,
       _cT_=0;
      if(! (_cU_ < 0))
       {var i=_cT_;
        for(;;)
         {var row=caml_check_bound(data,i)[1 + i];
          if(row.length - 1 !== dim2)
           invalid_arg(cst_Bigarray_Array3_of_array_n);
          var _cW_=dim2 - 1 | 0,_cV_=0;
          if(! (_cW_ < 0))
           {var j=_cV_;
            for(;;)
             {var col=caml_check_bound(row,j)[1 + j];
              if(col.length - 1 !== dim3)
               invalid_arg(cst_Bigarray_Array3_of_array_n$0);
              var _cZ_=dim3 - 1 | 0,_cY_=0;
              if(! (_cZ_ < 0))
               {var k=_cY_;
                for(;;)
                 {runtime.caml_ba_set_3
                   (ba,
                    i + ofs | 0,
                    j + ofs | 0,
                    k + ofs | 0,
                    caml_check_bound(col,k)[1 + k]);
                  var _c1_=k + 1 | 0;
                  if(_cZ_ !== k){var k=_c1_;continue}
                  break}}
              var _c0_=j + 1 | 0;
              if(_cW_ !== j){var j=_c0_;continue}
              break}}
          var _cX_=i + 1 | 0;
          if(_cU_ !== i){var i=_cX_;continue}
          break}}
      return ba}
    function array0_of_genarray(a)
     {return 0 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array0_of_genarra)}
    function array1_of_genarray(a)
     {return 1 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array1_of_genarra)}
    function array2_of_genarray(a)
     {return 2 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array2_of_genarra)}
    function array3_of_genarray(a)
     {return 3 === caml_ba_num_dims(a)
              ?a
              :invalid_arg(cst_Bigarray_array3_of_genarra)}
    function reshape_0(a){return caml_ba_reshape(a,[0])}
    function reshape_1(a,dim1){return caml_ba_reshape(a,[0,dim1])}
    function reshape_2(a,dim1,dim2){return caml_ba_reshape(a,[0,dim1,dim2])}
    function reshape_3(a,dim1,dim2,dim3)
     {return caml_ba_reshape(a,[0,dim1,dim2,dim3])}
    var
     Stdlib_bigarray=
      [0,
       float32,
       float64,
       complex32,
       complex64,
       int8_signed,
       int8_unsigned,
       int16_signed,
       int16_unsigned,
       int$2,
       int32$1,
       int64$1,
       nativeint$1,
       char$0,
       kind_size_in_bytes,
       c_layout,
       fortran_layout,
       Genarray,
       [0,create$9,caml_ba_change_layout,size_in_bytes$0,get$1,set$0,of_value],
       [0,create$10,caml_ba_change_layout,size_in_bytes$1,slice,of_array],
       [0,
        create$11,
        caml_ba_change_layout,
        size_in_bytes$2,
        slice_left,
        slice_right,
        of_array$0],
       [0,
        create$12,
        caml_ba_change_layout,
        size_in_bytes$3,
        slice_left_1,
        slice_right_1,
        slice_left_2,
        slice_right_2,
        of_array$1],
       array0_of_genarray,
       array1_of_genarray,
       array2_of_genarray,
       array3_of_genarray,
       caml_ba_reshape,
       reshape_0,
       reshape_1,
       reshape_2,
       reshape_3];
    caml_register_global(811,Stdlib_bigarray,"Stdlib__bigarray");
    return}
  (function(){return this}()));


//# 1 "../.js/result/result.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     global_data=runtime.caml_get_global_data(),
     Stdlib_result=global_data.Stdlib__result,
     ok=Stdlib_result[1],
     error=Stdlib_result[2],
     value=Stdlib_result[3],
     get_ok=Stdlib_result[4],
     get_error=Stdlib_result[5],
     bind=Stdlib_result[6],
     join=Stdlib_result[7],
     map=Stdlib_result[8],
     map_error=Stdlib_result[9],
     fold=Stdlib_result[10],
     iter=Stdlib_result[11],
     iter_error=Stdlib_result[12],
     is_ok=Stdlib_result[13],
     is_error=Stdlib_result[14],
     equal=Stdlib_result[15],
     compare=Stdlib_result[16],
     to_option=Stdlib_result[17],
     to_list=Stdlib_result[18],
     to_seq=Stdlib_result[19],
     Result=
      [0,
       ok,
       error,
       value,
       get_ok,
       get_error,
       bind,
       join,
       map,
       map_error,
       fold,
       iter,
       iter_error,
       is_ok,
       is_error,
       equal,
       compare,
       to_option,
       to_list,
       to_seq];
    runtime.caml_register_global(1,Result,"Result");
    return}
  (function(){return this}()));


//# 1 "../.js/rresult/rresult.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     err_error=caml_string_of_jsbytes("result value is (Error _)"),
     err_ok=caml_string_of_jsbytes("result value is (Ok _)"),
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Stdlib=global_data.Stdlib,
     Stdlib_string=global_data.Stdlib__string,
     _e_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Ok"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<2>Ok@ @[%a@]@]")],
     _f_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Error"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<2>Error@ @[%a@]@]")],
     _d_=
      [0,
       [11,caml_string_of_jsbytes("Unexpected exception:"),[17,3,[15,0]]],
       caml_string_of_jsbytes("Unexpected exception:@\n%a")],
     _c_=[0,[2,0,[17,3,0]],caml_string_of_jsbytes("%s@\n")],
     _b_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _a_=[0,[2,0,[12,10,[2,0,0]]],caml_string_of_jsbytes("%s\n%s")];
    function ok(v){return [0,v]}
    function error(e){return [1,e]}
    function get_ok(param)
     {if(0 === param[0]){var v=param[1];return v}
      return caml_call1(Stdlib[1],err_error)}
    function get_error(param)
     {if(0 === param[0])return caml_call1(Stdlib[1],err_ok);
      var e=param[1];
      return e}
    function reword_error(reword,r)
     {if(0 === r[0])return r;var e=r[1];return [1,caml_call1(reword,e)]}
    function bind(v,f)
     {if(0 === v[0]){var v$0=v[1];return caml_call1(f,v$0)}return v}
    function map(f,v)
     {if(0 === v[0]){var v$0=v[1];return [0,caml_call1(f,v$0)]}return v}
    function join(r){if(0 === r[0]){var v=r[1];return v}return r}
    function symbol_map(v,f)
     {if(0 === v[0]){var v$0=v[1];return [0,caml_call1(f,v$0)]}return v}
    var include=[0,bind,symbol_map];
    function pp_lines(ppf,s)
     {var left=[0,0],right=[0,0],len=runtime.caml_ml_string_length(s);
      function flush(param)
       {var _n_=caml_call3(Stdlib_string[4],s,left[1],right[1] - left[1] | 0);
        caml_call2(Stdlib_format[13],ppf,_n_);
        right[1]++;
        left[1] = right[1];
        return 0}
      for(;;)
       {if(right[1] !== len)
         {if(10 === runtime.caml_string_get(s,right[1]))
           {flush(0);caml_call2(Stdlib_format[32],ppf,0);continue}
          right[1]++;
          continue}
        var _m_=left[1] !== len?1:0;
        return _m_?flush(0):_m_}}
    function msg(s){return [0,3854881,s]}
    function msgf(fmt)
     {function kmsg(param)
       {return [0,3854881,caml_call1(Stdlib_format[112],0)]}
      return caml_call3(Stdlib_format[132],kmsg,Stdlib_format[111],fmt)}
    function pp_msg(ppf,param){var msg=param[2];return pp_lines(ppf,msg)}
    function error_msg(s){return [1,[0,3854881,s]]}
    function error_msgf(fmt)
     {function kerr(param)
       {return [1,[0,3854881,caml_call1(Stdlib_format[112],0)]]}
      return caml_call3(Stdlib_format[132],kerr,Stdlib_format[111],fmt)}
    function reword_error_msg(opt,reword,r)
     {if(opt)var sth=opt[1],replace=sth;else var replace=0;
      if(0 === r[0])return r;
      var match=r[1],e=match[2],v=caml_call1(reword,e),e$0=v[2];
      return replace?[1,v]:caml_call2(error_msgf(_a_),e,e$0)}
    function error_to_msg(pp_error,r)
     {if(0 === r[0])return r;
      var e=r[1];
      return caml_call2(error_msgf(_b_),pp_error,e)}
    function error_msg_to_invalid_arg(param)
     {if(0 === param[0]){var v=param[1];return v}
      var match=param[1],m=match[2];
      return caml_call1(Stdlib[1],m)}
    function open_error_msg(r){return 0 === r[0]?r:r}
    function failwith_error_msg(param)
     {if(0 === param[0]){var v=param[1];return v}
      var match=param[1],m=match[2];
      return caml_call1(Stdlib[2],m)}
    function pp_exn_trap(ppf,param)
     {var
       match=param[2],
       bt=match[2],
       exn=match[1],
       _l_=caml_call1(Stdlib_printexc[1],exn);
      caml_call3(Stdlib_format[125],ppf,_c_,_l_);
      return pp_lines(ppf,caml_call1(Stdlib_printexc[13],bt))}
    function trap_exn(f,v)
     {try
       {var _k_=[0,caml_call1(f,v)];return _k_}
      catch(e)
       {e = caml_wrap_exception(e);
        var bt=caml_call1(Stdlib_printexc[11],0);
        return [1,[0,-469840015,[0,e,bt]]]}}
    function error_exn_trap_to_msg(r)
     {if(0 === r[0])return r;
      var trap=r[1];
      return caml_call2(error_msgf(_d_),pp_exn_trap,trap)}
    function open_error_exn_trap(r){return 0 === r[0]?r:r}
    function pp(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function dump(ok,error,ppf,param)
     {if(0 === param[0])
       {var v=param[1];return caml_call4(Stdlib_format[125],ppf,_e_,ok,v)}
      var e=param[1];
      return caml_call4(Stdlib_format[125],ppf,_f_,error,e)}
    function is_ok(param){return 0 === param[0]?1:0}
    function is_error(param){return 0 === param[0]?0:1}
    function equal(ok,error,r,match)
     {if(0 === r[0])
       {var _i_=r[1];
        if(0 === match[0]){var v=match[1];return caml_call2(ok,_i_,v)}}
      else
       {var _j_=r[1];
        if(0 !== match[0]){var e=match[1];return caml_call2(error,_j_,e)}}
      return 0}
    function compare(ok,error,r,match)
     {if(0 === r[0])
       {var _g_=r[1];
        if(0 === match[0]){var v=match[1];return caml_call2(ok,_g_,v)}
        return -1}
      var _h_=r[1];
      if(0 === match[0])return 1;
      var v$0=match[1];
      return caml_call2(error,_h_,v$0)}
    function to_option(param)
     {if(0 === param[0]){var v=param[1];return [0,v]}return 0}
    function of_option(none,param)
     {if(param){var v=param[1];return [0,v]}return caml_call1(none,0)}
    function to_presult(param)
     {if(0 === param[0]){var v=param[1];return [0,17724,v]}
      var e=param[1];
      return [0,106380200,e]}
    function of_presult(param)
     {if(106380200 <= param[1]){var e=param[2];return [1,e]}
      var v=param[2];
      return [0,v]}
    function ignore_error(use,param)
     {if(0 === param[0]){var v=param[1];return v}
      var e=param[1];
      return caml_call1(use,e)}
    function kignore_error(use,r)
     {if(0 === r[0])return r;var e=r[1];return caml_call1(use,e)}
    var
     symbol_bind=include[1],
     symbol_map$0=include[2],
     Rresult=
      [0,
       symbol_bind,
       symbol_map$0,
       [0,
        ok,
        error,
        reword_error,
        get_ok,
        get_error,
        ok,
        error,
        bind,
        map,
        join,
        bind,
        symbol_map,
        include,
        msg,
        msgf,
        pp_msg,
        error_msg,
        error_msgf,
        reword_error_msg,
        error_to_msg,
        error_msg_to_invalid_arg,
        open_error_msg,
        failwith_error_msg,
        pp_exn_trap,
        trap_exn,
        error_exn_trap_to_msg,
        open_error_exn_trap,
        pp,
        dump,
        is_ok,
        is_error,
        equal,
        compare,
        to_option,
        of_option,
        to_presult,
        of_presult,
        ignore_error,
        kignore_error]];
    runtime.caml_register_global(12,Rresult,"Rresult");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib-shims/stdlib_shims.cma.js"
(function(joo_global_object)
   {"use strict";var runtime=joo_global_object.jsoo_runtime;return}
  (function(){return this}()));


//# 1 "../.js/fmt/fmt.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_check_bound=runtime.caml_check_bound,
     caml_div=runtime.caml_div,
     caml_int64_add=runtime.caml_int64_add,
     caml_int64_div=runtime.caml_int64_div,
     caml_int64_mul=runtime.caml_int64_mul,
     caml_int64_sub=runtime.caml_int64_sub,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_mod=runtime.caml_mod,
     caml_mul=runtime.caml_mul,
     caml_notequal=runtime.caml_notequal,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call8(f,a0,a1,a2,a3,a4,a5,a6,a7)
     {return f.length == 8
              ?f(a0,a1,a2,a3,a4,a5,a6,a7)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7])}
    function caml_call9(f,a0,a1,a2,a3,a4,a5,a6,a7,a8)
     {return f.length == 9
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8])}
    function caml_call11(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
     {return f.length == 11
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_us=caml_string_of_jsbytes("us"),
     cst_ms=caml_string_of_jsbytes("ms"),
     cst_s=caml_string_of_jsbytes("s"),
     _av_=runtime.caml_int64_create_lo_mi_hi(60,0,0),
     cst_s$0=caml_string_of_jsbytes("s"),
     cst_min=caml_string_of_jsbytes("min"),
     _aw_=runtime.caml_int64_create_lo_mi_hi(60,0,0),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_h=caml_string_of_jsbytes("h"),
     _ax_=runtime.caml_int64_create_lo_mi_hi(24,0,0),
     cst_h$0=caml_string_of_jsbytes("h"),
     cst_d=caml_string_of_jsbytes("d"),
     y=runtime.caml_int64_create_lo_mi_hi(366,0,0),
     cst_0$0=caml_string_of_jsbytes("0"),
     cst$17=caml_string_of_jsbytes(";"),
     cst$16=caml_string_of_jsbytes("\x1b["),
     cst_m=caml_string_of_jsbytes("m"),
     cst_3=caml_string_of_jsbytes("3"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_32=caml_string_of_jsbytes("32"),
     cst_36=caml_string_of_jsbytes("36"),
     cst_1=caml_string_of_jsbytes("1"),
     cst_4=caml_string_of_jsbytes("4"),
     cst_34=caml_string_of_jsbytes("34"),
     cst_2=caml_string_of_jsbytes("2"),
     cst_33=caml_string_of_jsbytes("33"),
     cst_31=caml_string_of_jsbytes("31"),
     cst_7=caml_string_of_jsbytes("7"),
     cst_37=caml_string_of_jsbytes("37"),
     cst_30=caml_string_of_jsbytes("30"),
     cst_35=caml_string_of_jsbytes("35"),
     cst_32$0=caml_string_of_jsbytes("32"),
     cst_36$0=caml_string_of_jsbytes("36"),
     cst_34$0=caml_string_of_jsbytes("34"),
     cst_33$0=caml_string_of_jsbytes("33"),
     cst_31$0=caml_string_of_jsbytes("31"),
     cst_37$0=caml_string_of_jsbytes("37"),
     cst_35$0=caml_string_of_jsbytes("35"),
     cst_30$0=caml_string_of_jsbytes("30"),
     cst_92=caml_string_of_jsbytes("92"),
     cst_96=caml_string_of_jsbytes("96"),
     cst_94=caml_string_of_jsbytes("94"),
     cst_93=caml_string_of_jsbytes("93"),
     cst_91=caml_string_of_jsbytes("91"),
     cst_97=caml_string_of_jsbytes("97"),
     cst_95=caml_string_of_jsbytes("95"),
     cst_90=caml_string_of_jsbytes("90"),
     cst_42=caml_string_of_jsbytes("42"),
     cst_46=caml_string_of_jsbytes("46"),
     cst_44=caml_string_of_jsbytes("44"),
     cst_43=caml_string_of_jsbytes("43"),
     cst_41=caml_string_of_jsbytes("41"),
     cst_47=caml_string_of_jsbytes("47"),
     cst_45=caml_string_of_jsbytes("45"),
     cst_40=caml_string_of_jsbytes("40"),
     cst_102=caml_string_of_jsbytes("102"),
     cst_106=caml_string_of_jsbytes("106"),
     cst_104=caml_string_of_jsbytes("104"),
     cst_103=caml_string_of_jsbytes("103"),
     cst_101=caml_string_of_jsbytes("101"),
     cst_107=caml_string_of_jsbytes("107"),
     cst_105=caml_string_of_jsbytes("105"),
     cst_100=caml_string_of_jsbytes("100"),
     cst_K=caml_string_of_jsbytes("K"),
     partial=[15,[11,caml_string_of_jsbytes(" ?"),[17,0,0]]],
     cst$15=caml_string_of_jsbytes("..."),
     cst$14=caml_string_of_jsbytes(""),
     cst$13=caml_string_of_jsbytes(": "),
     kstr$0=caml_string_of_jsbytes("K"),
     i=caml_string_of_jsbytes("i"),
     cst_B=caml_string_of_jsbytes("B"),
     cst$11=caml_string_of_jsbytes(" }"),
     cst$12=caml_string_of_jsbytes("{ "),
     cst$10=caml_string_of_jsbytes(""),
     cst_No_backtrace_available=
      caml_string_of_jsbytes("No backtrace available."),
     cst$9=caml_string_of_jsbytes('"'),
     cst$7=caml_string_of_jsbytes("}"),
     cst$8=caml_string_of_jsbytes("{"),
     cst$5=caml_string_of_jsbytes("|]"),
     cst$6=caml_string_of_jsbytes("[|"),
     cst$3=caml_string_of_jsbytes("]"),
     cst$4=caml_string_of_jsbytes("["),
     cst$1=caml_string_of_jsbytes(")"),
     cst$2=caml_string_of_jsbytes("("),
     cst$0=caml_string_of_jsbytes(";"),
     cst=caml_string_of_jsbytes(","),
     err_str_formatter=
      caml_string_of_jsbytes("Format.str_formatter can't be set."),
     cst_SIGXFSZ=caml_string_of_jsbytes("SIGXFSZ"),
     cst_SIGXCPU=caml_string_of_jsbytes("SIGXCPU"),
     cst_SIGURG=caml_string_of_jsbytes("SIGURG"),
     cst_SIGTRAP=caml_string_of_jsbytes("SIGTRAP"),
     cst_SIGSYS=caml_string_of_jsbytes("SIGSYS"),
     cst_SIGPOLL=caml_string_of_jsbytes("SIGPOLL"),
     cst_SIGBUS=caml_string_of_jsbytes("SIGBUS"),
     cst_SIGPROF=caml_string_of_jsbytes("SIGPROF"),
     cst_SIGVTALRM=caml_string_of_jsbytes("SIGVTALRM"),
     cst_SIGTTOU=caml_string_of_jsbytes("SIGTTOU"),
     cst_SIGTTIN=caml_string_of_jsbytes("SIGTTIN"),
     cst_SIGTSTP=caml_string_of_jsbytes("SIGTSTP"),
     cst_SIGSTOP=caml_string_of_jsbytes("SIGSTOP"),
     cst_SIGCONT=caml_string_of_jsbytes("SIGCONT"),
     cst_SIGCHLD=caml_string_of_jsbytes("SIGCHLD"),
     cst_SIGUSR2=caml_string_of_jsbytes("SIGUSR2"),
     cst_SIGUSR1=caml_string_of_jsbytes("SIGUSR1"),
     cst_SIGTERM=caml_string_of_jsbytes("SIGTERM"),
     cst_SIGSEGV=caml_string_of_jsbytes("SIGSEGV"),
     cst_SIGQUIT=caml_string_of_jsbytes("SIGQUIT"),
     cst_SIGPIPE=caml_string_of_jsbytes("SIGPIPE"),
     cst_SIGKILL=caml_string_of_jsbytes("SIGKILL"),
     cst_SIGINT=caml_string_of_jsbytes("SIGINT"),
     cst_SIGILL=caml_string_of_jsbytes("SIGILL"),
     cst_SIGHUP=caml_string_of_jsbytes("SIGHUP"),
     cst_SIGFPE=caml_string_of_jsbytes("SIGFPE"),
     cst_SIGALRM=caml_string_of_jsbytes("SIGALRM"),
     cst_SIGABRT=caml_string_of_jsbytes("SIGABRT"),
     us_span=runtime.caml_int64_create_lo_mi_hi(1000,0,0),
     ms_span=runtime.caml_int64_create_lo_mi_hi(1000000,0,0),
     sec_span=runtime.caml_int64_create_lo_mi_hi(10144256,59,0),
     min_span=runtime.caml_int64_create_lo_mi_hi(4675584,3576,0),
     hour_span=runtime.caml_int64_create_lo_mi_hi(12099584,214576,0),
     day_span=runtime.caml_int64_create_lo_mi_hi(5177344,5149841,0),
     year_span=runtime.caml_int64_create_lo_mi_hi(16171008,1931345,112),
     Stdlib_int64=global_data.Stdlib__int64,
     Stdlib=global_data.Stdlib,
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_ephemeron=global_data.Stdlib__ephemeron,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_queue=global_data.Stdlib__queue,
     Stdlib_stack=global_data.Stdlib__stack,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_seq=global_data.Stdlib__seq,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_printexc=global_data.Stdlib__printexc,
     Stdlib_sys=global_data.Stdlib__sys,
     Stdlib_map=global_data.Stdlib__map,
     invalid_arg=Stdlib[1],
     stdout=Stdlib_format[107],
     stderr=Stdlib_format[108],
     pf=Stdlib_format[125],
     pr=Stdlib_format[126],
     epr=Stdlib_format[127],
     str=Stdlib_format[129],
     kpf=Stdlib_format[132],
     kstr=Stdlib_format[136],
     _F_=[0,[4,0,0,0,[2,0,[2,0,0]]],caml_string_of_jsbytes("%d%s%s")],
     _H_=
      [0,
       [4,0,0,0,[12,46,[4,0,0,0,[2,0,[2,0,0]]]]],
       caml_string_of_jsbytes("%d.%d%s%s")],
     _G_=[0,[4,0,0,0,[2,0,[2,0,0]]],caml_string_of_jsbytes("%d%s%s")],
     _J_=
      [0,
       [4,0,0,0,[12,46,[4,0,0,0,[2,0,[2,0,0]]]]],
       caml_string_of_jsbytes("%d.%d%s%s")],
     _K_=
      [0,
       [4,0,0,0,[12,46,[4,0,[0,2,2],0,[2,0,[2,0,0]]]]],
       caml_string_of_jsbytes("%d.%02d%s%s")],
     _I_=[0,[4,0,0,0,[2,0,[2,0,0]]],caml_string_of_jsbytes("%d%s%s")],
     _L_=
      [0,
       [11,
        caml_string_of_jsbytes("~scale is "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", must be in [-8;8]"),0]]],
       caml_string_of_jsbytes("~scale is %d, must be in [-8;8]")],
     _M_=[0,[4,0,0,0,[2,0,[2,0,0]]],caml_string_of_jsbytes("%d%s%s")],
     _Y_=runtime.caml_int64_create_lo_mi_hi(100,0,0),
     _Z_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     ___=[0,[7,0,0,0,[2,0,0]],caml_string_of_jsbytes("%Ld%s")],
     _$_=runtime.caml_int64_create_lo_mi_hi(10,0,0),
     _aa_=runtime.caml_int64_create_lo_mi_hi(10,0,0),
     _ab_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ac_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ad_=runtime.caml_int64_create_lo_mi_hi(10,0,0),
     _ae_=
      [0,
       [7,0,0,0,[12,46,[7,0,0,0,[2,0,0]]]],
       caml_string_of_jsbytes("%Ld.%Ld%s")],
     _af_=[0,[7,0,0,0,[2,0,0]],caml_string_of_jsbytes("%Ld%s")],
     _ag_=runtime.caml_int64_create_lo_mi_hi(100,0,0),
     _ah_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ai_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _aj_=runtime.caml_int64_create_lo_mi_hi(100,0,0),
     _ak_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _al_=runtime.caml_int64_create_lo_mi_hi(10,0,0),
     _am_=runtime.caml_int64_create_lo_mi_hi(10,0,0),
     _an_=
      [0,
       [7,0,0,0,[12,46,[7,0,0,0,[2,0,0]]]],
       caml_string_of_jsbytes("%Ld.%Ld%s")],
     _ao_=
      [0,
       [7,0,0,0,[12,46,[7,0,[0,2,2],0,[2,0,0]]]],
       caml_string_of_jsbytes("%Ld.%02Ld%s")],
     _ap_=[0,[7,0,0,0,[2,0,0]],caml_string_of_jsbytes("%Ld%s")],
     _aq_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _ar_=[0,[7,0,0,0,[2,0,0]],caml_string_of_jsbytes("%Ld%s")],
     _as_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _at_=
      [0,
       [7,0,0,0,[2,0,[7,0,0,0,[2,0,0]]]],
       caml_string_of_jsbytes("%Ld%s%Ld%s")],
     _au_=
      [0,
       [7,0,0,0,[11,caml_string_of_jsbytes("ns"),0]],
       caml_string_of_jsbytes("%Ldns")],
     _ay_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _az_=[0,[7,0,0,0,[12,97,0]],caml_string_of_jsbytes("%Lda")],
     _aA_=runtime.caml_int64_create_lo_mi_hi(0,0,0),
     _aB_=[0,[7,0,0,0,[12,97,0]],caml_string_of_jsbytes("%Lda")],
     _aC_=
      [0,
       [7,0,0,0,[12,97,[7,0,0,0,[12,100,0]]]],
       caml_string_of_jsbytes("%Lda%Ldd")],
     _a$_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _a__=
      [0,
       [12,58,[17,[0,caml_string_of_jsbytes("@ "),1,0],0]],
       caml_string_of_jsbytes(":@ ")],
     _a9_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<1>"),0],
          caml_string_of_jsbytes("<1>")]],
        [15,[15,[15,[17,0,0]]]]],
       caml_string_of_jsbytes("@[<1>%a%a%a@]")],
     _a7_=[0,caml_string_of_jsbytes("src/fmt.ml"),627,59],
     _a6_=[0,caml_string_of_jsbytes("src/fmt.ml"),610,53],
     _a5_=
      [0,
       [11,caml_string_of_jsbytes("Unknown"),0],
       caml_string_of_jsbytes("Unknown")],
     _a3_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [15,
         [12,
          32,
          [2,
           0,
           [12,
            32,
            [15,
             [15,
              [12,
               46,
               [17,
                [0,caml_string_of_jsbytes("@ "),1,0],
                [11,caml_string_of_jsbytes("Did you mean "),partial]]]]]]]]]],
       caml_string_of_jsbytes("@[%a %s %a%a.@ Did you mean %a ?@]")],
     _a4_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [15,[12,32,[2,0,[12,32,[15,[15,[12,46,[17,0,0]]]]]]]]],
       caml_string_of_jsbytes("@[%a %s %a%a.@]")],
     _aY_=
      [0,
       [15,[12,44,[17,[0,caml_string_of_jsbytes("@ "),1,0],0]]],
       caml_string_of_jsbytes("%a,@ ")],
     _aZ_=
      [0,
       [11,
        caml_string_of_jsbytes("or"),
        [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,0]]],
       caml_string_of_jsbytes("or@ %a")],
     _a0_=[0,caml_string_of_jsbytes("src/fmt.ml"),588,12],
     _a1_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,
         caml_string_of_jsbytes("one"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [11,
           caml_string_of_jsbytes("of"),
           [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[one@ of@ %a@]")],
     _a2_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,
         caml_string_of_jsbytes("either "),
         [15,
          [11,
           caml_string_of_jsbytes(" or"),
           [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[either %a or@ %a@]")],
     _aW_=[0,[4,0,0,0,[12,46,[4,0,0,0,0]]],caml_string_of_jsbytes("%d.%d")],
     _aX_=
      [0,
       [4,0,0,0,[12,46,[4,0,0,0,[12,45,[4,0,0,0,[12,46,[4,0,0,0,0]]]]]]],
       caml_string_of_jsbytes("%d.%d-%d.%d")],
     _aV_=[0,caml_string_of_jsbytes("src/fmt.ml"),550,13],
     _aU_=[0,[4,6,[0,2,2],0,0],caml_string_of_jsbytes("%02x")],
     _aT_=[0,[4,6,[0,2,8],0,0],caml_string_of_jsbytes("%08x")],
     _N_=[0,[4,0,0,0,[12,66,0]],caml_string_of_jsbytes("%dB")],
     _P_=[0,[15,[2,0,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%a%s%sB")],
     _O_=[0,[4,0,0,0,[2,0,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%d%s%sB")],
     _R_=[0,[15,[12,77,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%aM%sB")],
     _Q_=
      [0,[4,0,0,0,[12,77,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%dM%sB")],
     _T_=[0,[15,[12,71,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%aG%sB")],
     _S_=
      [0,[4,0,0,0,[12,71,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%dG%sB")],
     _V_=[0,[15,[12,84,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%aT%sB")],
     _U_=
      [0,[4,0,0,0,[12,84,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%dT%sB")],
     _X_=[0,[15,[12,80,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%aP%sB")],
     _W_=
      [0,[4,0,0,0,[12,80,[2,0,[12,66,0]]]],caml_string_of_jsbytes("%dP%sB")],
     _C_=
      [0,
       [12,59,[17,[0,caml_string_of_jsbytes("@,"),0,0],0]],
       caml_string_of_jsbytes(";@,")],
     _D_=[0,2],
     _B_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<1>"),0],
          caml_string_of_jsbytes("<1>")]],
        [15,
         [11,
          caml_string_of_jsbytes(" ="),
          [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[17,0,0]]]]]],
       caml_string_of_jsbytes("@[<1>%a =@ %a@]")],
     _A_=
      [0,
       [11,caml_string_of_jsbytes("queue"),0],
       caml_string_of_jsbytes("queue")],
     _z_=
      [0,
       [11,caml_string_of_jsbytes("stack"),0],
       caml_string_of_jsbytes("stack")],
     _y_=
      [0,
       [11,caml_string_of_jsbytes("hashtbl"),0],
       caml_string_of_jsbytes("hashtbl")],
     _w_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Ok"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<2>Ok@ @[%a@]@]")],
     _x_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Error"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<2>Error@ @[%a@]@]")],
     _u_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("Some"),
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<2>Some@ @[%a@]@]")],
     _v_=
      [0,[11,caml_string_of_jsbytes("None"),0],caml_string_of_jsbytes("None")],
     _t_=[0,[3,0,0],caml_string_of_jsbytes("%S")],
     _s_=
      [0,
       [11,caml_string_of_jsbytes("U+"),[4,8,[0,2,4],0,0]],
       caml_string_of_jsbytes("U+%04X")],
     _r_=
      [0,
       [11,caml_string_of_jsbytes("SIG("),[4,0,0,0,[12,41,0]]],
       caml_string_of_jsbytes("SIG(%d)")],
     _q_=[0,[8,[0,0,3],0,0,0],caml_string_of_jsbytes("%g")],
     _p_=[0,[8,[0,0,3],0,0,0],caml_string_of_jsbytes("%g")],
     _o_=[0,[8,[0,0,3],0,0,0],caml_string_of_jsbytes("%g")],
     _n_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<v>"),0],
          caml_string_of_jsbytes("<v>")]],
        [11,
         caml_string_of_jsbytes("Exception: "),
         [15,[17,[0,caml_string_of_jsbytes("@,"),0,0],[15,[17,0,0]]]]]],
       caml_string_of_jsbytes("@[<v>Exception: %a@,%a@]")],
     _l_=[0,[6,12,0,0,0],caml_string_of_jsbytes("%nu")],
     _k_=[0,[7,12,0,0,0],caml_string_of_jsbytes("%Lu")],
     _j_=[0,[5,12,0,0,0],caml_string_of_jsbytes("%lu")],
     _i_=[0,[4,12,0,0,0],caml_string_of_jsbytes("%u")],
     _h_=[0,[7,0,0,0,0],caml_string_of_jsbytes("%Ld")],
     _g_=[0,[5,0,0,0,0],caml_string_of_jsbytes("%ld")],
     _f_=[0,[6,0,0,0,0],caml_string_of_jsbytes("%nd")],
     _e_=[0,1],
     _d_=[0,1],
     _c_=[0,2],
     _b_=[0,1],
     _a_=[0,1],
     _E_=
      [0,
       caml_string_of_jsbytes("y"),
       caml_string_of_jsbytes("z"),
       caml_string_of_jsbytes("a"),
       caml_string_of_jsbytes("f"),
       caml_string_of_jsbytes("p"),
       caml_string_of_jsbytes("n"),
       caml_string_of_jsbytes("u"),
       caml_string_of_jsbytes("m"),
       caml_string_of_jsbytes(""),
       caml_string_of_jsbytes("k"),
       caml_string_of_jsbytes("M"),
       caml_string_of_jsbytes("G"),
       caml_string_of_jsbytes("T"),
       caml_string_of_jsbytes("P"),
       caml_string_of_jsbytes("E"),
       caml_string_of_jsbytes("Z"),
       caml_string_of_jsbytes("Y")],
     _aG_=[0,[4,6,[0,2,7],0,0],caml_string_of_jsbytes("%07x")],
     _aI_=[0,[4,6,[0,2,6],0,0],caml_string_of_jsbytes("%06x")],
     _aK_=[0,[4,6,[0,2,5],0,0],caml_string_of_jsbytes("%05x")],
     _aM_=[0,[4,6,[0,2,4],0,0],caml_string_of_jsbytes("%04x")],
     _aO_=[0,[4,6,[0,2,3],0,0],caml_string_of_jsbytes("%03x")],
     _aQ_=[0,[4,6,[0,2,2],0,0],caml_string_of_jsbytes("%02x")],
     _aS_=[0,[4,6,[0,2,1],0,0],caml_string_of_jsbytes("%01x")],
     _a8_=[0,15713,82908052];
    function failwith(fmt){return caml_call2(kstr,Stdlib[2],fmt)}
    function failwith_notrace(fmt)
     {return caml_call2(kstr,function(s){throw [0,Stdlib[7],s]},fmt)}
    function invalid_arg$0(fmt){return caml_call2(kstr,Stdlib[1],fmt)}
    function error(fmt){return caml_call2(kstr,function(s){return [1,s]},fmt)}
    function error_msg(fmt)
     {return caml_call2(kstr,function(s){return [1,[0,3854881,s]]},fmt)}
    function flush(ppf,param){return caml_call2(Stdlib_format[36],ppf,0)}
    function nop(fmt,ppf){return 0}
    function any(fmt,ppf,param){return caml_call2(pf,ppf,fmt)}
    function using(f,pp,ppf,v){return caml_call2(pp,ppf,caml_call1(f,v))}
    function const$0(pp_v,v,ppf,param){return caml_call2(pp_v,ppf,v)}
    function fmt(fmt,ppf){return caml_call2(pf,ppf,fmt)}
    function cut(ppf,param){return caml_call2(Stdlib_format[27],ppf,0)}
    function sp(ppf,param){return caml_call2(Stdlib_format[25],ppf,0)}
    function sps(n,ppf,param){return caml_call3(Stdlib_format[29],ppf,n,0)}
    function comma(ppf,param)
     {caml_call2(Stdlib_format[13],ppf,cst);return sp(ppf,0)}
    function semi(ppf,param)
     {caml_call2(Stdlib_format[13],ppf,cst$0);return sp(ppf,0)}
    function iter(opt,iter,pp_elt,ppf,v)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=cut;
      var is_first=[0,1];
      function pp_elt$0(v)
       {if(is_first[1])is_first[1] = 0;else caml_call2(pp_sep,ppf,0);
        return caml_call2(pp_elt,ppf,v)}
      return caml_call2(iter,pp_elt$0,v)}
    function iter_bindings(opt,iter,pp_binding,ppf,v)
     {if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=cut;
      var is_first=[0,1];
      function pp_binding$0(k,v)
       {if(is_first[1])is_first[1] = 0;else caml_call2(pp_sep,ppf,0);
        return caml_call2(pp_binding,ppf,[0,k,v])}
      return caml_call2(iter,pp_binding$0,v)}
    function symbol(pp_v0,pp_v1,ppf,v)
     {caml_call2(pp_v0,ppf,v);return caml_call2(pp_v1,ppf,v)}
    function concat(sep,pps,ppf,v)
     {function _fj_(ppf,pp){return caml_call2(pp,ppf,v)}
      return iter(sep,Stdlib_list[15],_fj_,ppf,pps)}
    function box(opt,pp_v,ppf,v)
     {if(opt)var sth=opt[1],indent=sth;else var indent=0;
      caml_call2(Stdlib_format[1],ppf,indent);
      caml_call2(pp_v,ppf,v);
      return caml_call2(Stdlib_format[3],ppf,0)}
    function hbox(pp_v,ppf,v)
     {caml_call2(Stdlib_format[5],ppf,0);
      caml_call2(pp_v,ppf,v);
      return caml_call2(Stdlib_format[3],ppf,0)}
    function vbox(opt,pp_v,ppf,v)
     {if(opt)var sth=opt[1],indent=sth;else var indent=0;
      caml_call2(Stdlib_format[7],ppf,indent);
      caml_call2(pp_v,ppf,v);
      return caml_call2(Stdlib_format[3],ppf,0)}
    function hvbox(opt,pp_v,ppf,v)
     {if(opt)var sth=opt[1],indent=sth;else var indent=0;
      caml_call2(Stdlib_format[9],ppf,indent);
      caml_call2(pp_v,ppf,v);
      return caml_call2(Stdlib_format[3],ppf,0)}
    function hovbox(opt,pp_v,ppf,v)
     {if(opt)var sth=opt[1],indent=sth;else var indent=0;
      caml_call2(Stdlib_format[11],ppf,indent);
      caml_call2(pp_v,ppf,v);
      return caml_call2(Stdlib_format[3],ppf,0)}
    function surround(s1,s2,pp_v,ppf,v)
     {caml_call2(Stdlib_format[13],ppf,s1);
      caml_call2(pp_v,ppf,v);
      return caml_call2(Stdlib_format[13],ppf,s2)}
    function parens(pp_v)
     {function _fe_(_fh_,_fi_){return surround(cst$2,cst$1,pp_v,_fh_,_fi_)}
      return function(_ff_,_fg_){return box(_a_,_fe_,_ff_,_fg_)}}
    function brackets(pp_v)
     {function _e$_(_fc_,_fd_){return surround(cst$4,cst$3,pp_v,_fc_,_fd_)}
      return function(_fa_,_fb_){return box(_b_,_e$_,_fa_,_fb_)}}
    function braces(pp_v)
     {function _e6_(_e9_,_e__){return surround(cst$8,cst$7,pp_v,_e9_,_e__)}
      return function(_e7_,_e8_){return box(_d_,_e6_,_e7_,_e8_)}}
    function quote(opt,pp_v)
     {if(opt)var sth=opt[1],mark=sth;else var mark=cst$9;
      function pp_mark(ppf,param)
       {return caml_call3(Stdlib_format[15],ppf,1,mark)}
      function _eY_(_e4_,_e5_){return symbol(pp_mark,pp_v,_e4_,_e5_)}
      function _eZ_(_e2_,_e3_){return symbol(_eY_,pp_mark,_e2_,_e3_)}
      return function(_e0_,_e1_){return box(_e_,_eZ_,_e0_,_e1_)}}
    var bool=Stdlib_format[23],int$0=Stdlib_format[17];
    function nativeint(ppf,v){return caml_call3(pf,ppf,_f_,v)}
    function int32(ppf,v){return caml_call3(pf,ppf,_g_,v)}
    function int64(ppf,v){return caml_call3(pf,ppf,_h_,v)}
    function uint(ppf,v){return caml_call3(pf,ppf,_i_,v)}
    function uint32(ppf,v){return caml_call3(pf,ppf,_j_,v)}
    function uint64(ppf,v){return caml_call3(pf,ppf,_k_,v)}
    function unativeint(ppf,v){return caml_call3(pf,ppf,_l_,v)}
    var char$0=Stdlib_format[21],_m_=Stdlib_format[13];
    function buffer(ppf,b)
     {return caml_call2(_m_,ppf,caml_call1(Stdlib_buffer[2],b))}
    function exn(ppf,e)
     {return caml_call2(_m_,ppf,caml_call1(Stdlib_printexc[1],e))}
    function exn_backtrace(ppf,param)
     {var bt=param[2],e=param[1];
      function pp_backtrace_str(ppf,s)
       {var stop=caml_ml_string_length(s) - 1 | 0;
        if(runtime.caml_string_equal(s,cst$10))
         return caml_call2(_m_,ppf,cst_No_backtrace_available);
        var left=0,right=0;
        for(;;)
         {if(right === stop)
           return caml_call2
                   (_m_,
                    ppf,
                    caml_call3(Stdlib_string[4],s,left,right - left | 0));
          if(10 === caml_string_get(s,right))
           {caml_call2
             (_m_,ppf,caml_call3(Stdlib_string[4],s,left,right - left | 0));
            cut(ppf,0);
            var
             right$0=right + 1 | 0,
             left$0=right + 1 | 0,
             left=left$0,
             right=right$0;
            continue}
          var right$1=right + 1 | 0,right=right$1;
          continue}}
      return caml_call6
              (pf,
               ppf,
               _n_,
               exn,
               e,
               pp_backtrace_str,
               caml_call1(Stdlib_printexc[13],bt))}
    function float$0(ppf,v){return caml_call3(pf,ppf,_o_,v)}
    function round_dfrac(d,x)
     {if(x - Math.floor(x + 0.5) == 0.)return x;
      var m=Math.pow(10.,d);
      return Math.floor(x * m + 0.5) / m}
    function float_dfrac(d,ppf,f)
     {return caml_call3(pf,ppf,_p_,round_dfrac(d,f))}
    function float_dsig(d,ppf,f)
     {if(f == 0.)
       var _eX_=0.;
      else
       var
        m=Math.pow(10.,Math.floor(runtime.caml_log10_float(Math.abs(f)))),
        _eX_=round_dfrac(d,f / m) * m;
      return caml_call3(pf,ppf,_q_,_eX_)}
    function pair(opt,pp_fst,pp_snd,ppf,param)
     {var snd=param[2],fst=param[1];
      if(opt)var sth=opt[1],pp_sep=sth;else var pp_sep=cut;
      caml_call2(pp_fst,ppf,fst);
      caml_call2(pp_sep,ppf,0);
      return caml_call2(pp_snd,ppf,snd)}
    function option(opt,pp_v,ppf,param)
     {if(opt)var sth=opt[1],pp_none=sth;else var pp_none=nop;
      if(param){var v=param[1];return caml_call2(pp_v,ppf,v)}
      return caml_call2(pp_none,ppf,0)}
    function result(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call2(ok,ppf,v)}
      var e=param[1];
      return caml_call2(error,ppf,e)}
    function list(sep,pp_elt)
     {var _eU_=Stdlib_list[15];
      return function(_eV_,_eW_){return iter(sep,_eU_,pp_elt,_eV_,_eW_)}}
    function array(sep,pp_elt)
     {var _eR_=Stdlib_array[13];
      return function(_eS_,_eT_){return iter(sep,_eR_,pp_elt,_eS_,_eT_)}}
    function seq(sep,pp_elt)
     {var _eO_=Stdlib_seq[10];
      return function(_eP_,_eQ_){return iter(sep,_eO_,pp_elt,_eP_,_eQ_)}}
    function hashtbl(sep,pp_binding)
     {var _eL_=Stdlib_hashtbl[12];
      return function(_eM_,_eN_)
       {return iter_bindings(sep,_eL_,pp_binding,_eM_,_eN_)}}
    function queue(sep,pp_elt)
     {var _eH_=Stdlib_queue[15],_eI_=0;
      return function(_eJ_,_eK_){return iter(_eI_,_eH_,pp_elt,_eJ_,_eK_)}}
    function stack(sep,pp_elt)
     {var _eD_=Stdlib_stack[12],_eE_=0;
      return function(_eF_,_eG_){return iter(_eE_,_eD_,pp_elt,_eF_,_eG_)}}
    var
     sig_names=
      [0,
       [0,Stdlib_sys[16],cst_SIGABRT],
       [0,
        [0,Stdlib_sys[17],cst_SIGALRM],
        [0,
         [0,Stdlib_sys[18],cst_SIGFPE],
         [0,
          [0,Stdlib_sys[19],cst_SIGHUP],
          [0,
           [0,Stdlib_sys[20],cst_SIGILL],
           [0,
            [0,Stdlib_sys[21],cst_SIGINT],
            [0,
             [0,Stdlib_sys[22],cst_SIGKILL],
             [0,
              [0,Stdlib_sys[23],cst_SIGPIPE],
              [0,
               [0,Stdlib_sys[24],cst_SIGQUIT],
               [0,
                [0,Stdlib_sys[25],cst_SIGSEGV],
                [0,
                 [0,Stdlib_sys[26],cst_SIGTERM],
                 [0,
                  [0,Stdlib_sys[27],cst_SIGUSR1],
                  [0,
                   [0,Stdlib_sys[28],cst_SIGUSR2],
                   [0,
                    [0,Stdlib_sys[29],cst_SIGCHLD],
                    [0,
                     [0,Stdlib_sys[30],cst_SIGCONT],
                     [0,
                      [0,Stdlib_sys[31],cst_SIGSTOP],
                      [0,
                       [0,Stdlib_sys[32],cst_SIGTSTP],
                       [0,
                        [0,Stdlib_sys[33],cst_SIGTTIN],
                        [0,
                         [0,Stdlib_sys[34],cst_SIGTTOU],
                         [0,
                          [0,Stdlib_sys[35],cst_SIGVTALRM],
                          [0,
                           [0,Stdlib_sys[36],cst_SIGPROF],
                           [0,
                            [0,Stdlib_sys[37],cst_SIGBUS],
                            [0,
                             [0,Stdlib_sys[38],cst_SIGPOLL],
                             [0,
                              [0,Stdlib_sys[39],cst_SIGSYS],
                              [0,
                               [0,Stdlib_sys[40],cst_SIGTRAP],
                               [0,
                                [0,Stdlib_sys[41],cst_SIGURG],
                                [0,
                                 [0,Stdlib_sys[42],cst_SIGXCPU],
                                 [0,[0,Stdlib_sys[43],cst_SIGXFSZ],0]]]]]]]]]]]]]]]]]]]]]]]]]]]];
    function signal(ppf,s)
     {var match=caml_call2(Stdlib_list[46],s,sig_names);
      if(match){var name=match[1];return caml_call2(_m_,ppf,name)}
      return caml_call3(pf,ppf,_r_,s)}
    function uchar(ppf,u)
     {return caml_call3(pf,ppf,_s_,caml_call1(Stdlib_uchar[10],u))}
    function string(ppf,s){return caml_call3(pf,ppf,_t_,s)}
    function pair$0(pp_fst,pp_snd)
     {var _eg_=0;
      function _eh_(_eB_,_eC_){return box(_eg_,pp_snd,_eB_,_eC_)}
      function _ei_(_eA_){return _eA_[2]}
      function _ej_(_ey_,_ez_){return using(_ei_,_eh_,_ey_,_ez_)}
      var _ek_=0;
      function _el_(_ew_,_ex_){return box(_ek_,pp_fst,_ew_,_ex_)}
      function _em_(_ev_){return _ev_[1]}
      function _en_(_et_,_eu_){return using(_em_,_el_,_et_,_eu_)}
      function _eo_(_er_,_es_){return symbol(_en_,comma,_er_,_es_)}
      return parens(function(_ep_,_eq_){return symbol(_eo_,_ej_,_ep_,_eq_)})}
    function option$0(pp_v,ppf,param)
     {if(param){var v=param[1];return caml_call4(pf,ppf,_u_,pp_v,v)}
      return caml_call2(pf,ppf,_v_)}
    function result$0(ok,error,ppf,param)
     {if(0 === param[0]){var v=param[1];return caml_call4(pf,ppf,_w_,ok,v)}
      var e=param[1];
      return caml_call4(pf,ppf,_x_,error,e)}
    function iter$0(iter_f,pp_name,pp_elt)
     {var _d6_=0;
      function _d7_(_ee_,_ef_){return box(_d6_,pp_elt,_ee_,_ef_)}
      var _d8_=[0,sp];
      function pp_v(_ec_,_ed_){return iter(_d8_,iter_f,_d7_,_ec_,_ed_)}
      function _d9_(_ea_,_eb_){return symbol(pp_name,sp,_ea_,_eb_)}
      return parens(function(_d__,_d$_){return symbol(_d9_,pp_v,_d__,_d$_)})}
    function iter_bindings$0(iter_f,pp_name,pp_k,pp_v)
     {var _dX_=pair$0(pp_k,pp_v),_dY_=[0,sp];
      function pp_v$0(_d4_,_d5_)
       {return iter_bindings(_dY_,iter_f,_dX_,_d4_,_d5_)}
      function _dZ_(_d2_,_d3_){return symbol(pp_name,sp,_d2_,_d3_)}
      return parens(function(_d0_,_d1_){return symbol(_dZ_,pp_v$0,_d0_,_d1_)})}
    function list$0(pp_elt)
     {var _dU_=0;
      return brackets
              (list
                ([0,semi],
                 function(_dV_,_dW_){return box(_dU_,pp_elt,_dV_,_dW_)}))}
    function array$0(pp_elt)
     {var
       _dN_=0,
       pp_v=
        array([0,semi],function(_dS_,_dT_){return box(_dN_,pp_elt,_dS_,_dT_)});
      function _dM_(_dQ_,_dR_){return surround(cst$6,cst$5,pp_v,_dQ_,_dR_)}
      return function(_dO_,_dP_){return box(_c_,_dM_,_dO_,_dP_)}}
    function seq$0(pp_elt)
     {var _dJ_=0;
      return brackets
              (seq
                ([0,semi],
                 function(_dK_,_dL_){return box(_dJ_,pp_elt,_dK_,_dL_)}))}
    function hashtbl$0(pp_k,pp_v)
     {function _dG_(_dH_,_dI_){return any(_y_,_dH_,_dI_)}
      return iter_bindings$0(Stdlib_hashtbl[12],_dG_,pp_k,pp_v)}
    function stack$0(pp_elt)
     {function _dD_(_dE_,_dF_){return any(_z_,_dE_,_dF_)}
      return iter$0(Stdlib_stack[12],_dD_,pp_elt)}
    function queue$0(pp_elt)
     {function _dA_(_dB_,_dC_){return any(_A_,_dB_,_dC_)}
      return iter$0(Stdlib_queue[15],_dA_,pp_elt)}
    function field(opt,l,prj,pp_v,ppf,v)
     {if(opt)var sth=opt[1],label=sth;else var label=string;
      return caml_call6(pf,ppf,_B_,label,l,pp_v,caml_call1(prj,v))}
    function record(pps)
     {var _dl_=[0,function(_dy_,_dz_){return any(_C_,_dy_,_dz_)}];
      function _dm_(_dw_,_dx_){return concat(_dl_,pps,_dw_,_dx_)}
      var _dn_=0;
      function _do_(_du_,_dv_){return vbox(_dn_,_dm_,_du_,_dv_)}
      function _dp_(_ds_,_dt_){return surround(cst$12,cst$11,_do_,_ds_,_dt_)}
      return function(_dq_,_dr_){return box(_D_,_dp_,_dq_,_dr_)}}
    function ipow10(n)
     {var acc=1,n$0=n;
      for(;;)
       {if(0 === n$0)return acc;
        var n$1=n$0 - 1 | 0,acc$0=acc * 10 | 0,acc=acc$0,n$0=n$1;
        continue}}
    var si_symb=_E_.slice(),si_symb_max=16;
    function si_size(scale,u,ppf,s$2)
     {var s$3=s$2;
      for(;;)
       {var _dj_=scale < -8?1:0,_dk_=_dj_ || (8 < scale?1:0);
        if(_dk_)return caml_call1(invalid_arg$0(_L_),scale);
        if(0 === s$3)
         var pow_div_3=0;
        else
         {var p=-1,x=s$3;
          for(;;)
           {if(0 !== x){var x$0=x / 10 | 0,p$0=p + 1 | 0,p=p$0,x=x$0;continue}
            var pow_div_3=p / 3 | 0;
            break}}
        var symb=(scale + 8 | 0) + pow_div_3 | 0,match=16 < symb?1:0;
        if(match)
         var factor=ipow10((8 - scale | 0) * 3 | 0),symb$0=si_symb_max;
        else
         var factor$0=ipow10(pow_div_3 * 3 | 0),factor=factor$0,symb$0=symb;
        if(1 === factor)
         return caml_call5
                 (pf,
                  ppf,
                  _M_,
                  s$3,
                  caml_check_bound(si_symb,symb$0)[1 + symb$0],
                  u);
        var
         symb$1=caml_check_bound(si_symb,symb$0)[1 + symb$0],
         m=caml_div(s$3,factor),
         n=caml_mod(s$3,factor);
        if(100 <= m)
         {var m_up=0 < n?m + 1 | 0:m;
          if(1000 <= m_up){var s=caml_mul(m_up,factor),s$3=s;continue}
          return caml_call5(pf,ppf,_F_,m_up,symb$1,u)}
        if(10 <= m)
         {var
           f_factor=factor / 10 | 0,
           f_m=caml_div(n,f_factor),
           f_n=caml_mod(n,f_factor),
           f_m_up=0 < f_n?f_m + 1 | 0:f_m;
          if(0 === f_m_up)return caml_call5(pf,ppf,_G_,m,symb$1,u);
          if(10 <= f_m_up)
           {var
             s$0=caml_mul(m,factor) + caml_mul(f_m_up,f_factor) | 0,
             s$3=s$0;
            continue}
          return caml_call6(pf,ppf,_H_,m,f_m_up,symb$1,u)}
        var
         f_factor$0=factor / 100 | 0,
         f_m$0=caml_div(n,f_factor$0),
         f_n$0=caml_mod(n,f_factor$0),
         f_m_up$0=0 < f_n$0?f_m$0 + 1 | 0:f_m$0;
        if(0 === f_m_up$0)return caml_call5(pf,ppf,_I_,m,symb$1,u);
        if(100 <= f_m_up$0)
         {var
           s$1=caml_mul(m,factor) + caml_mul(f_m_up$0,f_factor$0) | 0,
           s$3=s$1;
          continue}
        return 0 === (f_m_up$0 % 10 | 0)
                ?caml_call6(pf,ppf,_J_,m,f_m_up$0 / 10 | 0,symb$1,u)
                :caml_call6(pf,ppf,_K_,m,f_m_up$0,symb$1,u)}}
    function byte_size(ppf,s){return si_size(0,cst_B,ppf,s)}
    function bi_byte_size(ppf,s)
     {var k=1024,_dg_=1;
      function pp_frac(_dh_,_di_){return float_dfrac(_dg_,_dh_,_di_)}
      function div_round_up(m,n){return caml_div((m + n | 0) - 1 | 0,n)}
      if(s < 1024)return caml_call3(pf,ppf,_N_,s);
      var m=1048576;
      if(s < 1048576)
       {var sk=s / 1024 | 0;
        return 10 <= sk
                ?caml_call5(pf,ppf,_O_,div_round_up(s,k),kstr$0,i)
                :caml_call6(pf,ppf,_P_,pp_frac,s / 1024,kstr$0,i)}
      var g=1073741824;
      if(s < 1073741824)
       {var sm=s / 1048576 | 0;
        return 10 <= sm
                ?caml_call4(pf,ppf,_Q_,div_round_up(s,m),i)
                :caml_call5(pf,ppf,_R_,pp_frac,s / 1048576,i)}
      var t=0;
      if(s < 0)
       {var sg=s / 1073741824 | 0;
        return 10 <= sg
                ?caml_call4(pf,ppf,_S_,div_round_up(s,g),i)
                :caml_call5(pf,ppf,_T_,pp_frac,s / 1073741824,i)}
      var p=0;
      if(s < 0)
       {var st=caml_div(s,0);
        return 10 <= st
                ?caml_call4(pf,ppf,_U_,div_round_up(s,t),i)
                :caml_call5(pf,ppf,_V_,pp_frac,s / 0,i)}
      var sp=caml_div(s,0);
      return 10 <= sp
              ?caml_call4(pf,ppf,_W_,div_round_up(s,p),i)
              :caml_call5(pf,ppf,_X_,pp_frac,s / 0,i)}
    function unsigned_compare(x0,x1)
     {return caml_call2
              (Stdlib_int64[15],
               caml_int64_sub(x0,Stdlib_int64[10]),
               caml_int64_sub(x1,Stdlib_int64[10]))}
    function unsigned_div(n,d)
     {var match=runtime.caml_lessthan(d,Stdlib_int64[1]);
      if(match)
       return 0 <= unsigned_compare(n,d)?Stdlib_int64[2]:Stdlib_int64[1];
      var
       q=
        runtime.caml_int64_shift_left
         (caml_int64_div(runtime.caml_int64_shift_right_unsigned(n,1),d),1),
       r=caml_int64_sub(n,caml_int64_mul(q,d));
      return 0 <= unsigned_compare(r,d)?caml_call1(Stdlib_int64[6],q):q}
    function unsigned_rem(n,d)
     {return caml_int64_sub
              (n,caml_int64_mul(caml_call2(Stdlib_int64[4],n,d),d))}
    function pp_si_span(counter,unit_str,si_unit,si_higher_unit,ppf,span)
     {function geq(x,y){return 0 <= unsigned_compare(x,y)?1:0}
      var m=unsigned_div(span,si_unit),n=unsigned_rem(span,si_unit);
      if(geq(m,_Y_))
       {var
         m_up=
          caml_call2(Stdlib_int64[17],n,_Z_)?m:caml_call1(Stdlib_int64[6],m),
         span$0=caml_int64_mul(m_up,si_unit);
        if(geq(span$0,si_higher_unit))
         {if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return uint64_ns_span$0(counter$0,ppf,span$0)}
          return caml_trampoline_return(uint64_ns_span$0,[0,ppf,span$0])}
        return caml_call4(pf,ppf,___,m_up,unit_str)}
      if(geq(m,_$_))
       {var
         f_factor=unsigned_div(si_unit,_aa_),
         f_m=unsigned_div(n,f_factor),
         f_n=unsigned_rem(n,f_factor),
         f_m_up=
          caml_call2(Stdlib_int64[17],f_n,_ab_)
           ?f_m
           :caml_call1(Stdlib_int64[6],f_m);
        if(caml_notequal(f_m_up,_ac_))
         {if(geq(f_m_up,_ad_))
           {var
             _de_=
              caml_int64_add
               (caml_int64_mul(m,si_unit),caml_int64_mul(f_m_up,f_factor));
            if(counter < 50)
             {var counter$1=counter + 1 | 0;
              return uint64_ns_span$0(counter$1,ppf,_de_)}
            return caml_trampoline_return(uint64_ns_span$0,[0,ppf,_de_])}
          return caml_call5(pf,ppf,_ae_,m,f_m_up,unit_str)}
        return caml_call4(pf,ppf,_af_,m,unit_str)}
      var
       f_factor$0=unsigned_div(si_unit,_ag_),
       f_m$0=unsigned_div(n,f_factor$0),
       f_n$0=unsigned_rem(n,f_factor$0),
       f_m_up$0=
        caml_call2(Stdlib_int64[17],f_n$0,_ah_)
         ?f_m$0
         :caml_call1(Stdlib_int64[6],f_m$0);
      if(caml_notequal(f_m_up$0,_ai_))
       {if(geq(f_m_up$0,_aj_))
         {var
           _df_=
            caml_int64_add
             (caml_int64_mul(m,si_unit),caml_int64_mul(f_m_up$0,f_factor$0));
          if(counter < 50)
           {var counter$2=counter + 1 | 0;
            return uint64_ns_span$0(counter$2,ppf,_df_)}
          return caml_trampoline_return(uint64_ns_span$0,[0,ppf,_df_])}
        return caml_call2
                 (Stdlib_int64[17],runtime.caml_int64_mod(f_m_up$0,_al_),_ak_)
                ?caml_call5
                  (pf,ppf,_an_,m,caml_int64_div(f_m_up$0,_am_),unit_str)
                :caml_call5(pf,ppf,_ao_,m,f_m_up$0,unit_str)}
      return caml_call4(pf,ppf,_ap_,m,unit_str)}
    function pp_non_si
     (counter,unit_str,unit,unit_lo_str,unit_lo,unit_lo_size,ppf,span)
     {var m=unsigned_div(span,unit),n=unsigned_rem(span,unit);
      if(caml_call2(Stdlib_int64[17],n,_aq_))
       return caml_call4(pf,ppf,_ar_,m,unit_str);
      var
       f_m=unsigned_div(n,unit_lo),
       f_n=unsigned_rem(n,unit_lo),
       f_m_up=
        caml_call2(Stdlib_int64[17],f_n,_as_)
         ?f_m
         :caml_call1(Stdlib_int64[6],f_m);
      if(0 <= unsigned_compare(f_m_up,unit_lo_size))
       {var
         _dd_=
          caml_int64_add
           (caml_int64_mul(m,unit),caml_int64_mul(f_m_up,unit_lo));
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return uint64_ns_span$0(counter$0,ppf,_dd_)}
        return caml_trampoline_return(uint64_ns_span$0,[0,ppf,_dd_])}
      return caml_call6(pf,ppf,_at_,m,unit_str,f_m_up,unit_lo_str)}
    function uint64_ns_span$0(counter,ppf,s)
     {function lt(x,y){return -1 === unsigned_compare(x,y)?1:0}
      if(lt(s,us_span))return caml_call3(pf,ppf,_au_,s);
      if(lt(s,ms_span))
       {if(counter < 50)
         {var counter$3=counter + 1 | 0;
          return pp_si_span(counter$3,cst_us,us_span,ms_span,ppf,s)}
        return caml_trampoline_return
                (pp_si_span,[0,cst_us,us_span,ms_span,ppf,s])}
      if(lt(s,sec_span))
       {if(counter < 50)
         {var counter$4=counter + 1 | 0;
          return pp_si_span(counter$4,cst_ms,ms_span,sec_span,ppf,s)}
        return caml_trampoline_return
                (pp_si_span,[0,cst_ms,ms_span,sec_span,ppf,s])}
      if(lt(s,min_span))
       {if(counter < 50)
         {var counter$5=counter + 1 | 0;
          return pp_si_span(counter$5,cst_s,sec_span,min_span,ppf,s)}
        return caml_trampoline_return
                (pp_si_span,[0,cst_s,sec_span,min_span,ppf,s])}
      if(lt(s,hour_span))
       {if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return pp_non_si
                  (counter$0,cst_min,min_span,cst_s$0,sec_span,_av_,ppf,s)}
        return caml_trampoline_return
                (pp_non_si,[0,cst_min,min_span,cst_s$0,sec_span,_av_,ppf,s])}
      if(lt(s,day_span))
       {if(counter < 50)
         {var counter$1=counter + 1 | 0;
          return pp_non_si
                  (counter$1,cst_h,hour_span,cst_min$0,min_span,_aw_,ppf,s)}
        return caml_trampoline_return
                (pp_non_si,[0,cst_h,hour_span,cst_min$0,min_span,_aw_,ppf,s])}
      if(lt(s,year_span))
       {if(counter < 50)
         {var counter$2=counter + 1 | 0;
          return pp_non_si
                  (counter$2,cst_d,day_span,cst_h$0,hour_span,_ax_,ppf,s)}
        return caml_trampoline_return
                (pp_non_si,[0,cst_d,day_span,cst_h$0,hour_span,_ax_,ppf,s])}
      var m=unsigned_div(s,year_span),n=unsigned_rem(s,year_span);
      if(caml_call2(Stdlib_int64[17],n,_ay_))return caml_call3(pf,ppf,_az_,m);
      var
       f_m=unsigned_div(n,day_span),
       f_n=unsigned_rem(n,day_span),
       f_m_up=
        caml_call2(Stdlib_int64[17],f_n,_aA_)
         ?f_m
         :caml_call1(Stdlib_int64[6],f_m);
      return 0 <= unsigned_compare(f_m_up,y)
              ?caml_call3(pf,ppf,_aB_,caml_call1(Stdlib_int64[6],m))
              :caml_call4(pf,ppf,_aC_,m,f_m_up)}
    function uint64_ns_span(ppf,s)
     {return caml_trampoline(uint64_ns_span$0(0,ppf,s))}
    function iter_vec(f,param)
     {var get=param[2],n=param[1],_db_=n - 1 | 0,_da_=0;
      if(! (_db_ < 0))
       {var i=_da_;
        for(;;)
         {caml_call2(f,i,caml_call1(get,i));
          var _dc_=i + 1 | 0;
          if(_db_ !== i){var i=_dc_;continue}
          break}}
      return 0}
    function vec(sep)
     {return function(_c9_,_c__,_c$_)
       {return iter_bindings(sep,iter_vec,_c9_,_c__,_c$_)}}
    function _aD_(s)
     {return [0,
              caml_ml_string_length(s),
              function(_c8_){return caml_string_get(s,_c8_)}]}
    function on_string(_c5_,_c6_,_c7_){return using(_aD_,_c5_,_c6_,_c7_)}
    function _aE_(b)
     {return [0,
              runtime.caml_ml_bytes_length(b),
              function(_c4_){return runtime.caml_bytes_get(b,_c4_)}]}
    function on_bytes(_c1_,_c2_,_c3_){return using(_aE_,_c1_,_c2_,_c3_)}
    var
     _aF_=0,
     _aH_=[0,[0,268435455,function(_c0_){return fmt(_aG_,_c0_)}],_aF_],
     _aJ_=[0,[0,16777215,function(_cZ_){return fmt(_aI_,_cZ_)}],_aH_],
     _aL_=[0,[0,1048575,function(_cY_){return fmt(_aK_,_cY_)}],_aJ_],
     _aN_=[0,[0,65535,function(_cX_){return fmt(_aM_,_cX_)}],_aL_],
     _aP_=[0,[0,4095,function(_cW_){return fmt(_aO_,_cW_)}],_aN_],
     _aR_=[0,[0,255,function(_cV_){return fmt(_aQ_,_cV_)}],_aP_],
     prefix0x=[0,[0,15,function(_cU_){return fmt(_aS_,_cU_)}],_aR_];
    function ascii(opt,_cP_,param,ppf,v)
     {var n=v[1];
      if(opt)var sth=opt[1],w=sth;else var w=0;
      if(_cP_)
       var sth$0=_cP_[1],subst=sth$0;
      else
       var
        _cR_=46,
        subst=function(_cS_,_cT_){return const$0(char$0,_cR_,_cS_,_cT_)};
      function pp_char(ppf,param)
       {var c=param[2];
        if(32 <= c && ! (127 <= c))return caml_call2(char$0,ppf,c);
        return caml_call2(subst,ppf,0)}
      caml_call3(vec(0),pp_char,ppf,v);
      var _cQ_=n < w?1:0;
      return _cQ_?sps(w - n | 0,ppf,0):_cQ_}
    function octets(opt,_cK_,param,ppf,v)
     {var n=v[1];
      if(opt)var sth=opt[1],w=sth;else var w=0;
      if(_cK_)var sth$0=_cK_[1],sep=sth$0;else var sep=sp;
      function pp_sep(ppf,i)
       {var _cN_=0 < i?1:0,_cO_=_cN_?0 === (i % 2 | 0)?1:0:_cN_;
        return _cO_?caml_call2(sep,ppf,0):_cO_}
      function pp_char(ppf,param)
       {var c=param[2],i=param[1];
        pp_sep(ppf,i);
        return caml_call3(pf,ppf,_aU_,c)}
      caml_call3(vec([0,nop]),pp_char,ppf,v);
      var _cL_=w - 1 | 0;
      if(! (_cL_ < n))
       {var i=n;
        for(;;)
         {pp_sep(ppf,i);
          sps(2,ppf,0);
          var _cM_=i + 1 | 0;
          if(_cL_ !== i){var i=_cM_;continue}
          break}}
      return 0}
    function addresses(addr,opt,pp_vec,ppf,v)
     {var n$0=v[1];
      if(opt)var sth=opt[1],w=sth;else var w=16;
      if(addr)
       var pp$0=addr[1],addr$0=pp$0;
      else
       {var
         _cC_=function(_cI_,_cJ_){return const$0(_m_,cst$13,_cI_,_cJ_)},
         max=caml_mul(caml_div(n$0 - 1 | 0,w),w),
         _cB_=function(param){var x=param[1];return max <= x?1:0},
         match=caml_call2(Stdlib_list[37],_cB_,prefix0x);
        if(match)
         var match$0=match[1],pp=match$0[2],_cD_=pp;
        else
         var _cD_=function(_cH_){return fmt(_aT_,_cH_)};
        var addr$0=function(_cF_,_cG_){return symbol(_cD_,_cC_,_cF_,_cG_)}}
      function pp_sub(ppf,param)
       {var sub=param[2],i=param[1];
        caml_call2(addr$0,ppf,caml_mul(i,w));
        return box(0,pp_vec,ppf,sub)}
      var get=v[2],n=v[1];
      function _cz_(j)
       {var off=caml_mul(w,j);
        function _cE_(i){return caml_call1(get,i + off | 0)}
        return [0,caml_call2(Stdlib[16],w,n - off | 0),_cE_]}
      var _cA_=[0,caml_div(n - 1 | 0,w) + 1 | 0,_cz_];
      return vbox(0,caml_call1(vec(0),pp_sub),ppf,_cA_)}
    function hex(opt,param)
     {if(opt)var sth=opt[1],w=sth;else var w=16;
      var _b5_=0,_b6_=0,_b7_=[0,w];
      function eta(_cx_,_cy_){return ascii(_b7_,_b6_,_b5_,_cx_,_cy_)}
      var _b8_=0;
      function _b9_(_cv_,_cw_){return box(_b8_,eta,_cv_,_cw_)}
      var _b__=2;
      function _b$_(_ct_,_cu_){return sps(_b__,_ct_,_cu_)}
      var _ca_=0,_cb_=0,_cc_=[0,w];
      function eta$0(_cr_,_cs_){return octets(_cc_,_cb_,_ca_,_cr_,_cs_)}
      var _cd_=0;
      function _ce_(_cp_,_cq_){return box(_cd_,eta$0,_cp_,_cq_)}
      function _cf_(_cn_,_co_){return symbol(_ce_,_b$_,_cn_,_co_)}
      function _cg_(_cl_,_cm_){return symbol(_cf_,_b9_,_cl_,_cm_)}
      var _ch_=[0,w],_ci_=0;
      return function(_cj_,_ck_){return addresses(_ci_,_ch_,_cg_,_cj_,_ck_)}}
    function is_nl(c){return 10 === c?1:0}
    function is_nl_or_sp(c)
     {var _b3_=10 === c?1:0,_b4_=_b3_ || (32 === c?1:0);return _b4_}
    function is_white(param)
     {var switch$0=0;
      if(14 <= param)
       {if(32 === param)switch$0 = 1}
      else
       if(9 <= param)switch$0 = 1;
      return switch$0?1:0}
    function not_white(c){return 1 - is_white(c)}
    function not_white_or_nl(c)
     {var _b2_=10 === c?1:0;return _b2_?_b2_:not_white(c)}
    function stop_at(sat,start,max,s)
     {var start$0=start;
      for(;;)
       {if(max < start$0)return start$0;
        if(caml_call1(sat,caml_string_get(s,start$0)))return start$0;
        var start$1=start$0 + 1 | 0,start$0=start$1;
        continue}}
    function sub(s,start,stop,max)
     {if(start === stop)return cst$14;
      if(0 === start && max < stop)return s;
      return caml_call3(Stdlib_string[4],s,start,stop - start | 0)}
    function words(ppf,s)
     {var
       max=caml_ml_string_length(s) - 1 | 0,
       start$1=stop_at(not_white,0,max,s);
      if(max < start$1)return 0;
      var start=start$1;
      for(;;)
       {var stop=stop_at(is_white,start,max,s);
        if(max < stop)
         {var _b0_=sub(s,start,stop,max);
          return caml_call2(Stdlib_format[13],ppf,_b0_)}
        var _b1_=sub(s,start,stop,max);
        caml_call2(Stdlib_format[13],ppf,_b1_);
        var start$0=stop_at(not_white,stop,max,s);
        if(max < start$0)return 0;
        caml_call2(Stdlib_format[25],ppf,0);
        var start=start$0;
        continue}}
    function paragraphs(ppf,s)
     {var
       max=caml_ml_string_length(s) - 1 | 0,
       start$3=stop_at(not_white,0,max,s);
      if(max < start$3)return 0;
      var start=start$3;
      for(;;)
       {var stop=stop_at(is_white,start,max,s);
        if(max < stop)
         {var _bY_=sub(s,start,stop,max);
          return caml_call2(Stdlib_format[13],ppf,_bY_)}
        var _bZ_=sub(s,start,stop,max);
        caml_call2(Stdlib_format[13],ppf,_bZ_);
        var start$0=stop_at(not_white_or_nl,stop,max,s);
        if(max < start$0)return 0;
        if(10 === caml_string_get(s,start$0))
         {var start$1=stop_at(not_white_or_nl,start$0 + 1 | 0,max,s);
          if(max < start$1)return 0;
          if(10 === caml_string_get(s,start$1))
           {var start$2=stop_at(not_white,start$1 + 1 | 0,max,s);
            if(max < start$2)return 0;
            caml_call2(Stdlib_format[32],ppf,0);
            caml_call2(Stdlib_format[32],ppf,0);
            var start=start$2;
            continue}
          caml_call2(Stdlib_format[25],ppf,0);
          var start=start$1;
          continue}
        caml_call2(Stdlib_format[25],ppf,0);
        var start=start$0;
        continue}}
    function text(ppf,s)
     {var max=caml_ml_string_length(s) - 1 | 0,start=0;
      for(;;)
       {var stop=stop_at(is_nl_or_sp,start,max,s);
        if(max < stop)
         {var _bW_=sub(s,start,stop,max);
          return caml_call2(Stdlib_format[13],ppf,_bW_)}
        var _bX_=sub(s,start,stop,max);
        caml_call2(Stdlib_format[13],ppf,_bX_);
        var match=caml_string_get(s,stop);
        if(10 === match)
         caml_call2(Stdlib_format[32],ppf,0);
        else
         {if(32 !== match)throw [0,Assert_failure,_aV_];
          caml_call2(Stdlib_format[25],ppf,0)}
        var start$0=stop + 1 | 0,start=start$0;
        continue}}
    function lines(ppf,s)
     {var max=caml_ml_string_length(s) - 1 | 0,start=0;
      for(;;)
       {var stop=stop_at(is_nl,start,max,s);
        if(max < stop)
         {var _bU_=sub(s,start,stop,max);
          return caml_call2(Stdlib_format[13],ppf,_bU_)}
        var _bV_=sub(s,start,stop,max);
        caml_call2(Stdlib_format[13],ppf,_bV_);
        caml_call2(Stdlib_format[32],ppf,0);
        var start$0=stop + 1 | 0,start=start$0;
        continue}}
    function truncated(max,ppf,s)
     {var match=caml_ml_string_length(s) <= max?1:0;
      if(match)return caml_call2(Stdlib_format[13],ppf,s);
      var _bR_=max - 4 | 0,_bQ_=0;
      if(! (_bR_ < 0))
       {var i=_bQ_;
        for(;;)
         {var _bS_=caml_string_get(s,i);
          caml_call2(Stdlib_format[21],ppf,_bS_);
          var _bT_=i + 1 | 0;
          if(_bR_ !== i){var i=_bT_;continue}
          break}}
      return caml_call2(Stdlib_format[13],ppf,cst$15)}
    function text_loc(ppf,param)
     {var
       _bP_=param[2],
       c1=_bP_[2],
       l1=_bP_[1],
       match=param[1],
       c0=match[2],
       l0=match[1];
      if(l0 === l1 && c0 === c1)return caml_call4(pf,ppf,_aW_,l0,c0);
      return caml_call6(pf,ppf,_aX_,l0,c0,l1,c1)}
    function one_of(opt,pp_v,ppf,vs)
     {if(opt)var sth=opt[1],empty=sth;else var empty=nop;
      if(vs)
       {var _bM_=vs[1],_bN_=vs[2];
        if(_bN_)
         {if(_bN_[2])
           {var
             loop=
              function(ppf,param)
               {var param$0=param;
                for(;;)
                 {if(param$0)
                   {var _bO_=param$0[1];
                    if(param$0[2])
                     {var vs=param$0[2];
                      caml_call4(pf,ppf,_aY_,pp_v,_bO_);
                      var param$0=vs;
                      continue}
                    return caml_call4(pf,ppf,_aZ_,pp_v,_bO_)}
                  throw [0,Assert_failure,_a0_]}};
            return caml_call4(pf,ppf,_a1_,loop,vs)}
          var v1=_bN_[1];
          return caml_call6(pf,ppf,_a2_,pp_v,_bM_,pp_v,v1)}
        return caml_call2(pp_v,ppf,_bM_)}
      return caml_call2(empty,ppf,0)}
    function did_you_mean(opt,_bG_,kind,pp_v,ppf,param)
     {var hints=param[2],v=param[1];
      if(opt)
       var sth=opt[1],pre=sth;
      else
       var pre=function(_bK_,_bL_){return any(_a5_,_bK_,_bL_)};
      if(_bG_)var sth$0=_bG_[1],post=sth$0;else var post=nop;
      if(hints)
       {var _bH_=0;
        return caml_call11
                (pf,
                 ppf,
                 _a3_,
                 pre,
                 0,
                 kind,
                 pp_v,
                 v,
                 post,
                 0,
                 function(_bI_,_bJ_){return one_of(_bH_,pp_v,_bI_,_bJ_)},
                 hints)}
      return caml_call9(pf,ppf,_a4_,pre,0,kind,pp_v,v,post,0)}
    var id=[0,0];
    function attr(param)
     {id[1]++;
      var K=[248,cst_K,runtime.caml_fresh_oo_id(0)];
      function _bE_(param)
       {if(param[1] === K){var x=param[2];return x}
        throw [0,Assert_failure,_a6_]}
      function _bF_(x){return [0,K,x]}
      return [0,id[1],_bF_,_bE_]}
    var
     compare=runtime.caml_int_compare,
     Int=[0,compare],
     Imap=caml_call1(Stdlib_map[1],Int),
     attrs=[0,0];
    function store(ppf)
     {var top=0,param=attrs[1];
      for(;;)
       {if(param)
         {var
           es=param[2],
           e=param[1],
           match=caml_call1(Stdlib_ephemeron[1][2],e);
          if(match)
           {var k=match[1];
            if(k === ppf)
             {var match$0=caml_call1(Stdlib_ephemeron[1][8],e);
              if(match$0)
               {var v=match$0[1];
                if(1 - (0 === top?1:0))
                 attrs[1] = [0,e,caml_call2(Stdlib_list[12],top,es)];
                return v}
              throw [0,Assert_failure,_a7_]}
            var top$0=[0,e,top],top=top$0,param=es;
            continue}
          var param=es;
          continue}
        var e$0=caml_call1(Stdlib_ephemeron[1][1],0),v$0=[0,Imap[1]];
        attrs[1] = [0,e$0,caml_call1(Stdlib_list[9],top)];
        caml_call2(Stdlib_ephemeron[1][4],e$0,ppf);
        caml_call2(Stdlib_ephemeron[1][10],e$0,v$0);
        return v$0}}
    function get(param,ppf)
     {var
       prj=param[3],
       k=param[1],
       _bD_=store(ppf)[1],
       match=caml_call2(Imap[29],k,_bD_);
      if(match){var x=match[1];return [0,caml_call1(prj,x)]}
      return 0}
    function set(param,v,ppf)
     {var inj=param[2],k=param[1];
      if(ppf === Stdlib_format[111])
       return caml_call1(invalid_arg,err_str_formatter);
      var s=store(ppf),_bB_=s[1],_bC_=caml_call1(inj,v);
      s[1] = caml_call3(Imap[4],k,_bC_,_bB_);
      return 0}
    function def(x,param){if(param){var y=param[1];return y}return x}
    var utf_8_attr=attr(0);
    function utf_8(ppf){return def(1,get(utf_8_attr,ppf))}
    function set_utf_8(ppf,x){return set(utf_8_attr,x,ppf)}
    var style_renderer_attr=attr(0);
    function style_renderer(ppf)
     {return def(870530776,get(style_renderer_attr,ppf))}
    function set_style_renderer(ppf,x){return set(style_renderer_attr,x,ppf)}
    function with_buffer(like,buf)
     {var ppf=caml_call1(Stdlib_format[109],buf);
      if(like){var like$0=like[1],_bA_=store(like$0)[1];store(ppf)[1] = _bA_}
      return ppf}
    function str_like(ppf,fmt)
     {var buf=caml_call1(Stdlib_buffer[1],64),bppf=with_buffer([0,ppf],buf);
      function flush(ppf)
       {caml_call2(Stdlib_format[36],ppf,0);
        var s=caml_call1(Stdlib_buffer[2],buf);
        caml_call1(Stdlib_buffer[9],buf);
        return s}
      return caml_call3(Stdlib_format[132],flush,bppf,fmt)}
    function if_utf_8(pp_u,pp,ppf,v)
     {var pp_u$0=utf_8(ppf)?pp_u:pp;return caml_call2(pp_u$0,ppf,v)}
    function ansi_style_code(param)
     {if(typeof param === "number")
       return 698610924 <= param
               ?749039939 <= param
                 ?870530776 <= param
                   ?989373200 <= param?cst_3:cst_0
                   :756711075 <= param?cst_32:cst_36
                 :737308346 === param?cst_34:737455525 <= param?cst_1:cst_4
               :-397582078 <= param
                 ?82908052 <= param
                   ?242899572 <= param?cst_2:cst_33
                   :4100401 <= param?cst_31:cst_7
                 :-605101559 === param
                   ?cst_35
                   :-588596599 <= param?cst_37:cst_30;
      if(15713 <= param[1])
       {var _bw_=param[2];
        if(typeof _bw_ === "number")
         return 82908052 <= _bw_
                 ?749039939 <= _bw_
                   ?756711075 <= _bw_?cst_32$0:cst_36$0
                   :737308346 <= _bw_?cst_34$0:cst_33$0
                 :-588596599 <= _bw_
                   ?4100401 <= _bw_?cst_31$0:cst_37$0
                   :-605101559 <= _bw_?cst_35$0:cst_30$0;
        var _bx_=_bw_[2];
        return 82908052 <= _bx_
                ?749039939 <= _bx_
                  ?756711075 <= _bx_?cst_92:cst_96
                  :737308346 <= _bx_?cst_94:cst_93
                :-588596599 <= _bx_
                  ?4100401 <= _bx_?cst_91:cst_97
                  :-605101559 <= _bx_?cst_95:cst_90}
      var _by_=param[2];
      if(typeof _by_ === "number")
       return 82908052 <= _by_
               ?749039939 <= _by_
                 ?756711075 <= _by_?cst_42:cst_46
                 :737308346 <= _by_?cst_44:cst_43
               :-588596599 <= _by_
                 ?4100401 <= _by_?cst_41:cst_47
                 :-605101559 <= _by_?cst_45:cst_40;
      var _bz_=_by_[2];
      return 82908052 <= _bz_
              ?749039939 <= _bz_
                ?756711075 <= _bz_?cst_102:cst_106
                :737308346 <= _bz_?cst_104:cst_103
              :-588596599 <= _bz_
                ?4100401 <= _bz_?cst_101:cst_107
                :-605101559 <= _bz_?cst_105:cst_100}
    function pp_sgr(ppf,style)
     {caml_call3(Stdlib_format[15],ppf,0,cst$16);
      caml_call3(Stdlib_format[15],ppf,0,style);
      return caml_call3(Stdlib_format[15],ppf,0,cst_m)}
    var curr_style=attr(0);
    function styled(style,pp_v,ppf,v)
     {var match=style_renderer(ppf);
      if(870530776 <= match)return caml_call2(pp_v,ppf,v);
      var match$0=get(curr_style,ppf);
      if(match$0)
       var s=match$0[1],curr=s;
      else
       {var s$0=[0,cst_0$0];set(curr_style,s$0,ppf);var curr=s$0}
      var _bt_=curr[1],here=ansi_style_code(style);
      if(870530776 === style)
       var here$0=here;
      else
       var
        _bv_=caml_call2(Stdlib[28],cst$17,here),
        here$0=caml_call2(Stdlib[28],_bt_,_bv_);
      curr[1] = here$0;
      try
       {pp_sgr(ppf,here);
        caml_call2(pp_v,ppf,v);
        pp_sgr(ppf,_bt_);
        curr[1] = _bt_;
        var _bu_=0;
        return _bu_}
      catch(e){e = caml_wrap_exception(e);curr[1] = _bt_;throw e}}
    function label(_br_,_bs_){return styled(_a8_,_m_,_br_,_bs_)}
    function field$0(opt,_bo_,l,prj,pp_v,ppf,v)
     {if(opt)var sth=opt[1],label$0=sth;else var label$0=label;
      if(_bo_)
       var sth$0=_bo_[1],sep=sth$0;
      else
       var sep=function(_bp_,_bq_){return any(_a__,_bp_,_bq_)};
      return caml_call8(pf,ppf,_a9_,label$0,l,sep,0,pp_v,caml_call1(prj,v))}
    function record$0(opt,pps)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cut;
      var _bh_=[0,sep];
      function _bi_(_bm_,_bn_){return concat(_bh_,pps,_bm_,_bn_)}
      var _bj_=0;
      return function(_bk_,_bl_){return vbox(_bj_,_bi_,_bk_,_bl_)}}
    function of_to_string(f,ppf,v){return caml_call2(_m_,ppf,caml_call1(f,v))}
    function to_to_string(pp_v,v){return caml_call3(str,_a$_,pp_v,v)}
    function prefix(pp_p,pp_v,ppf,v)
     {caml_call2(pp_p,ppf,0);return caml_call2(pp_v,ppf,v)}
    function suffix(pp_s,pp_v,ppf,v)
     {caml_call2(pp_v,ppf,v);return caml_call2(pp_s,ppf,0)}
    function styled_unit(style,fmt)
     {function _bc_(_bf_,_bg_){return any(fmt,_bf_,_bg_)}
      return function(_bd_,_be_){return styled(style,_bc_,_bd_,_be_)}}
    var
     _ba_=
      [0,
       signal,
       uchar,
       string,
       pair$0,
       option$0,
       result$0,
       list$0,
       array$0,
       seq$0,
       hashtbl$0,
       queue$0,
       stack$0,
       field,
       record,
       iter$0,
       iter_bindings$0],
     Fmt=
      [0,
       stdout,
       stderr,
       pf,
       pr,
       epr,
       str,
       kpf,
       kstr,
       str_like,
       with_buffer,
       failwith,
       failwith_notrace,
       invalid_arg$0,
       error,
       error_msg,
       flush,
       nop,
       any,
       using,
       const$0,
       fmt,
       cut,
       sp,
       sps,
       comma,
       semi,
       symbol,
       symbol,
       concat,
       iter,
       iter_bindings,
       box,
       hbox,
       vbox,
       hvbox,
       hovbox,
       parens,
       brackets,
       braces,
       quote,
       function(_bb_){return _bb_},
       field$0,
       record$0,
       bool,
       int$0,
       nativeint,
       int32,
       int64,
       uint,
       unativeint,
       uint32,
       uint64,
       float$0,
       float_dfrac,
       float_dsig,
       char$0,
       _m_,
       buffer,
       exn,
       exn_backtrace,
       pair,
       option,
       result,
       list,
       array,
       seq,
       hashtbl,
       queue,
       stack,
       _ba_,
       si_size,
       byte_size,
       bi_byte_size,
       uint64_ns_span,
       on_bytes,
       on_string,
       ascii,
       octets,
       addresses,
       hex,
       words,
       paragraphs,
       text,
       lines,
       truncated,
       text_loc,
       one_of,
       did_you_mean,
       if_utf_8,
       utf_8,
       set_utf_8,
       styled,
       style_renderer,
       set_style_renderer,
       of_to_string,
       to_to_string,
       str,
       kstr,
       str_like,
       any,
       any,
       prefix,
       suffix,
       styled_unit];
    runtime.caml_register_global(252,Fmt,"Fmt");
    return}
  (function(){return this}()));


//# 1 "../.js/brr/brr.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_equal=runtime.caml_equal,
     caml_js_from_bool=runtime.caml_js_from_bool,
     caml_js_get=runtime.caml_js_get,
     caml_js_instanceof=runtime.caml_js_instanceof,
     caml_js_meth_call=runtime.caml_js_meth_call,
     caml_js_new=runtime.caml_js_new,
     caml_js_to_bool=runtime.caml_js_to_bool,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_list_to_js_array=runtime.caml_list_to_js_array,
     caml_register_global=runtime.caml_register_global,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_parseInt=caml_string_of_jsbytes("parseInt"),
     cst_substr=caml_string_of_jsbytes("substr"),
     cst_slice=caml_string_of_jsbytes("slice"),
     cst_jsError=caml_string_of_jsbytes("jsError"),
     cst_NotAllowedError=caml_string_of_jsbytes("NotAllowedError"),
     cst_InvalidAccessError=caml_string_of_jsbytes("InvalidAccessError"),
     cst_AbortError=caml_string_of_jsbytes("AbortError"),
     cst_ConstraintError=caml_string_of_jsbytes("ConstraintError"),
     cst_DataCloneError=caml_string_of_jsbytes("DataCloneError"),
     cst_DataError=caml_string_of_jsbytes("DataError"),
     cst_EncodingError=caml_string_of_jsbytes("EncodingError"),
     cst_HierarchyRequestError=caml_string_of_jsbytes("HierarchyRequestError"),
     cst_IndexSizeError=caml_string_of_jsbytes("IndexSizeError"),
     cst_InvalidCharacterError=caml_string_of_jsbytes("InvalidCharacterError"),
     cst_InvalidModificationError=
      caml_string_of_jsbytes("InvalidModificationError"),
     cst_InvalidNodeTypeError=caml_string_of_jsbytes("InvalidNodeTypeError"),
     cst_InvalidStateError=caml_string_of_jsbytes("InvalidStateError"),
     cst_NamespaceError=caml_string_of_jsbytes("NamespaceError"),
     cst_NetworkError=caml_string_of_jsbytes("NetworkError"),
     cst_NoModificationAllowedError=
      caml_string_of_jsbytes("NoModificationAllowedError"),
     cst_SyntaxError=caml_string_of_jsbytes("SyntaxError"),
     cst_NotFoundError=caml_string_of_jsbytes("NotFoundError"),
     cst_NotReadableError=caml_string_of_jsbytes("NotReadableError"),
     cst_NotSupportedError=caml_string_of_jsbytes("NotSupportedError"),
     cst_OperationError=caml_string_of_jsbytes("OperationError"),
     cst_QuotaExceededError=caml_string_of_jsbytes("QuotaExceededError"),
     cst_ReadOnlyError=caml_string_of_jsbytes("ReadOnlyError"),
     cst_SecurityError=caml_string_of_jsbytes("SecurityError"),
     cst_TimeoutError=caml_string_of_jsbytes("TimeoutError"),
     cst_TransactionInactiveError=
      caml_string_of_jsbytes("TransactionInactiveError"),
     cst_TypeMismatchError=caml_string_of_jsbytes("TypeMismatchError"),
     cst_URLMismatchError=caml_string_of_jsbytes("URLMismatchError"),
     cst_UnknownError=caml_string_of_jsbytes("UnknownError"),
     cst_VersionError=caml_string_of_jsbytes("VersionError"),
     cst_WrongDocumentError=caml_string_of_jsbytes("WrongDocumentError"),
     cst_Jv_Error=caml_string_of_jsbytes("Jv.Error"),
     cst_clearMeasures=caml_string_of_jsbytes("clearMeasures"),
     cst_clearMarks=caml_string_of_jsbytes("clearMarks"),
     cst_timeOrigin=caml_string_of_jsbytes("timeOrigin"),
     cst_redirectCount=caml_string_of_jsbytes("redirectCount"),
     cst_type$3=caml_string_of_jsbytes("type'"),
     cst_loadEventEnd=caml_string_of_jsbytes("loadEventEnd"),
     cst_loadEventStart=caml_string_of_jsbytes("loadEventStart"),
     cst_domComplete=caml_string_of_jsbytes("domComplete"),
     cst_domContentLoadedEventEnd=
      caml_string_of_jsbytes("domContentLoadedEventEnd"),
     cst_domContentLoadedEventStart=
      caml_string_of_jsbytes("domContentLoadedEventStart"),
     cst_domInteractive=caml_string_of_jsbytes("domInteractive"),
     cst_unloadEventEnd=caml_string_of_jsbytes("unloadEventEnd"),
     cst_unloadEventStart=caml_string_of_jsbytes("unloadEventStart"),
     cst_decodedBodySize=caml_string_of_jsbytes("decodedBodySize"),
     cst_encodedBodySize=caml_string_of_jsbytes("encodedBodySize"),
     cst_transferSize=caml_string_of_jsbytes("transferSize"),
     cst_responseEnd=caml_string_of_jsbytes("responseEnd"),
     cst_responseStart=caml_string_of_jsbytes("responseStart"),
     cst_requestStart=caml_string_of_jsbytes("requestStart"),
     cst_secureConnectionStart=caml_string_of_jsbytes("secureConnectionStart"),
     cst_connectEnd=caml_string_of_jsbytes("connectEnd"),
     cst_connectStart=caml_string_of_jsbytes("connectStart"),
     cst_domainLookupEnd=caml_string_of_jsbytes("domainLookupEnd"),
     cst_domainLookupStart=caml_string_of_jsbytes("domainLookupStart"),
     cst_fetchStart=caml_string_of_jsbytes("fetchStart"),
     cst_redirectEnd=caml_string_of_jsbytes("redirectEnd"),
     cst_redirectStart=caml_string_of_jsbytes("redirectStart"),
     cst_workerStart=caml_string_of_jsbytes("workerStart"),
     cst_nextHopProtocol=caml_string_of_jsbytes("nextHopProtocol"),
     cst_initiatorType=caml_string_of_jsbytes("initiatorType"),
     cst_duration=caml_string_of_jsbytes("duration"),
     cst_endTime=caml_string_of_jsbytes("endTime"),
     cst_startTime=caml_string_of_jsbytes("startTime"),
     cst_entryType=caml_string_of_jsbytes("entryType"),
     cst_name$1=caml_string_of_jsbytes("name"),
     cst_onLine=caml_string_of_jsbytes("onLine"),
     cst_languages=caml_string_of_jsbytes("languages"),
     cst_language=caml_string_of_jsbytes("language"),
     cst_scrollRestoration$0=caml_string_of_jsbytes("scrollRestoration"),
     cst_scrollRestoration=caml_string_of_jsbytes("scrollRestoration"),
     cst_length$2=caml_string_of_jsbytes("length"),
     cst_matches=caml_string_of_jsbytes("matches"),
     cst_devicePixelRatio=caml_string_of_jsbytes("devicePixelRatio"),
     cst_scrollY=caml_string_of_jsbytes("scrollY"),
     cst_scrollX=caml_string_of_jsbytes("scrollX"),
     cst_closed=caml_string_of_jsbytes("closed"),
     cst_timeStamp$0=caml_string_of_jsbytes("timeStamp"),
     cst_profileEnd=caml_string_of_jsbytes("profileEnd"),
     cst_profile=caml_string_of_jsbytes("profile"),
     cst_timeEnd=caml_string_of_jsbytes("timeEnd"),
     cst_timeLog=caml_string_of_jsbytes("timeLog"),
     cst_time=caml_string_of_jsbytes("time"),
     cst_countReset=caml_string_of_jsbytes("countReset"),
     cst_count=caml_string_of_jsbytes("count"),
     cst_groupCollapsed=caml_string_of_jsbytes("groupCollapsed"),
     cst_group=caml_string_of_jsbytes("group"),
     cst_groupEnd=caml_string_of_jsbytes("groupEnd"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_dir=caml_string_of_jsbytes("dir"),
     cst_assert=caml_string_of_jsbytes("assert"),
     cst_debug=caml_string_of_jsbytes("debug"),
     cst_info=caml_string_of_jsbytes("info"),
     cst_warn=caml_string_of_jsbytes("warn"),
     cst_error=caml_string_of_jsbytes("error"),
     cst_trace=caml_string_of_jsbytes("trace"),
     cst_log=caml_string_of_jsbytes("log"),
     cst_clear=caml_string_of_jsbytes("clear"),
     cst_aborted=caml_string_of_jsbytes("aborted"),
     cst_fullscreenEnabled=caml_string_of_jsbytes("fullscreenEnabled"),
     cst_visibilityState=caml_string_of_jsbytes("visibilityState"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_referrer=caml_string_of_jsbytes("referrer"),
     cst_files=caml_string_of_jsbytes("files"),
     cst_navigationUI=caml_string_of_jsbytes("navigationUI"),
     cst_scrollHeight=caml_string_of_jsbytes("scrollHeight"),
     cst_scrollWidth=caml_string_of_jsbytes("scrollWidth"),
     cst_scrollTop=caml_string_of_jsbytes("scrollTop"),
     cst_scrollLeft=caml_string_of_jsbytes("scrollLeft"),
     cst_height$0=caml_string_of_jsbytes("height"),
     cst_width$0=caml_string_of_jsbytes("width"),
     cst_y=caml_string_of_jsbytes("y"),
     cst_x=caml_string_of_jsbytes("x"),
     cst_clientHeight=caml_string_of_jsbytes("clientHeight"),
     cst_clientWidth=caml_string_of_jsbytes("clientWidth"),
     cst_clientTop=caml_string_of_jsbytes("clientTop"),
     cst_clientLeft=caml_string_of_jsbytes("clientLeft"),
     cst_after=caml_string_of_jsbytes("after"),
     cst_before=caml_string_of_jsbytes("before"),
     cst_replaceWith=caml_string_of_jsbytes("replaceWith"),
     cst_append=caml_string_of_jsbytes("append"),
     cst_prepend=caml_string_of_jsbytes("prepend"),
     cst_nodeValue=caml_string_of_jsbytes("nodeValue"),
     cst_nodeName=caml_string_of_jsbytes("nodeName"),
     cst_nodeType$0=caml_string_of_jsbytes("nodeType"),
     cst_nodeType=caml_string_of_jsbytes("nodeType"),
     cst=caml_string_of_jsbytes("\xc2\xa0"),
     cst_length$1=caml_string_of_jsbytes("length"),
     cst_port$0=caml_string_of_jsbytes("port"),
     cst_protocol=caml_string_of_jsbytes("protocol"),
     cst_hostname=caml_string_of_jsbytes("hostname"),
     cst_port=caml_string_of_jsbytes("port"),
     cst_pathname=caml_string_of_jsbytes("pathname"),
     cst_search=caml_string_of_jsbytes("search"),
     cst_hash=caml_string_of_jsbytes("hash"),
     cst_lastModified$0=caml_string_of_jsbytes("lastModified"),
     cst_name$0=caml_string_of_jsbytes("name"),
     cst_lastModified=caml_string_of_jsbytes("lastModified"),
     cst_result=caml_string_of_jsbytes("result"),
     cst_type$2=caml_string_of_jsbytes("type"),
     cst_size=caml_string_of_jsbytes("size"),
     cst_type$1=caml_string_of_jsbytes("type"),
     cst_endings=caml_string_of_jsbytes("endings"),
     cst_name=caml_string_of_jsbytes("name"),
     cst_Float32Array=caml_string_of_jsbytes("Float32Array"),
     cst_Float64Array=caml_string_of_jsbytes("Float64Array"),
     cst_Int16Array=caml_string_of_jsbytes("Int16Array"),
     cst_Int32Array=caml_string_of_jsbytes("Int32Array"),
     cst_Int8Array=caml_string_of_jsbytes("Int8Array"),
     cst_Uint16Array=caml_string_of_jsbytes("Uint16Array"),
     cst_Uint32Array=caml_string_of_jsbytes("Uint32Array"),
     cst_Uint8Array=caml_string_of_jsbytes("Uint8Array"),
     cst_Uint8ClampedArray=caml_string_of_jsbytes("Uint8ClampedArray"),
     cst_length$0=caml_string_of_jsbytes("length"),
     cst_byteLength$0=caml_string_of_jsbytes("byteLength"),
     cst_byteOffset=caml_string_of_jsbytes("byteOffset"),
     cst_byteLength=caml_string_of_jsbytes("byteLength"),
     cst_deltaMode=caml_string_of_jsbytes("deltaMode"),
     cst_deltaZ=caml_string_of_jsbytes("deltaZ"),
     cst_deltaY=caml_string_of_jsbytes("deltaY"),
     cst_deltaX=caml_string_of_jsbytes("deltaX"),
     cst_isPrimary=caml_string_of_jsbytes("isPrimary"),
     cst_pointerType=caml_string_of_jsbytes("pointerType"),
     cst_azimuthAngle=caml_string_of_jsbytes("azimuthAngle"),
     cst_altitudeAngle=caml_string_of_jsbytes("altitudeAngle"),
     cst_twist=caml_string_of_jsbytes("twist"),
     cst_tiltY=caml_string_of_jsbytes("tiltY"),
     cst_tiltX=caml_string_of_jsbytes("tiltX"),
     cst_tangentialPressure=caml_string_of_jsbytes("tangentialPressure"),
     cst_pressure=caml_string_of_jsbytes("pressure"),
     cst_height=caml_string_of_jsbytes("height"),
     cst_width=caml_string_of_jsbytes("width"),
     cst_pointerId=caml_string_of_jsbytes("pointerId"),
     cst_dataTransfer$0=caml_string_of_jsbytes("dataTransfer"),
     cst_metaKey$0=caml_string_of_jsbytes("metaKey"),
     cst_shiftKey$0=caml_string_of_jsbytes("shiftKey"),
     cst_ctrlKey$0=caml_string_of_jsbytes("ctrlKey"),
     cst_altKey$0=caml_string_of_jsbytes("altKey"),
     cst_buttons=caml_string_of_jsbytes("buttons"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_movementY=caml_string_of_jsbytes("movementY"),
     cst_movementX=caml_string_of_jsbytes("movementX"),
     cst_screenY=caml_string_of_jsbytes("screenY"),
     cst_screenX=caml_string_of_jsbytes("screenX"),
     cst_pageY=caml_string_of_jsbytes("pageY"),
     cst_pageX=caml_string_of_jsbytes("pageX"),
     cst_clientY=caml_string_of_jsbytes("clientY"),
     cst_clientX=caml_string_of_jsbytes("clientX"),
     cst_offsetY=caml_string_of_jsbytes("offsetY"),
     cst_offsetX=caml_string_of_jsbytes("offsetX"),
     cst_relatedTarget$0=caml_string_of_jsbytes("relatedTarget"),
     cst_metaKey=caml_string_of_jsbytes("metaKey"),
     cst_shiftKey=caml_string_of_jsbytes("shiftKey"),
     cst_ctrlKey=caml_string_of_jsbytes("ctrlKey"),
     cst_altKey=caml_string_of_jsbytes("altKey"),
     cst_isComposing$0=caml_string_of_jsbytes("isComposing"),
     cst_repeat=caml_string_of_jsbytes("repeat"),
     cst_location=caml_string_of_jsbytes("location"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_key=caml_string_of_jsbytes("key"),
     cst_isComposing=caml_string_of_jsbytes("isComposing"),
     cst_inputType=caml_string_of_jsbytes("inputType"),
     cst_dataTransfer=caml_string_of_jsbytes("dataTransfer"),
     cst_data$0=caml_string_of_jsbytes("data"),
     cst_newURL=caml_string_of_jsbytes("newURL"),
     cst_oldURL=caml_string_of_jsbytes("oldURL"),
     cst_relatedTarget=caml_string_of_jsbytes("relatedTarget"),
     cst_colno=caml_string_of_jsbytes("colno"),
     cst_lineno=caml_string_of_jsbytes("lineno"),
     cst_filename=caml_string_of_jsbytes("filename"),
     cst_message=caml_string_of_jsbytes("message"),
     cst_data=caml_string_of_jsbytes("data"),
     cst_clipboardData=caml_string_of_jsbytes("clipboardData"),
     cst_effectAllowed$0=caml_string_of_jsbytes("effectAllowed"),
     cst_effectAllowed=caml_string_of_jsbytes("effectAllowed"),
     cst_dropEffect$0=caml_string_of_jsbytes("dropEffect"),
     cst_dropEffect=caml_string_of_jsbytes("dropEffect"),
     cst_length=caml_string_of_jsbytes("length"),
     cst_type$0=caml_string_of_jsbytes("type"),
     cst_kind=caml_string_of_jsbytes("kind"),
     cst_capture=caml_string_of_jsbytes("capture"),
     cst_once=caml_string_of_jsbytes("once"),
     cst_passive=caml_string_of_jsbytes("passive"),
     cst_timeStamp=caml_string_of_jsbytes("timeStamp"),
     cst_isTrusted=caml_string_of_jsbytes("isTrusted"),
     cst_composed$0=caml_string_of_jsbytes("composed"),
     cst_defaultPrevented=caml_string_of_jsbytes("defaultPrevented"),
     cst_cancelable$0=caml_string_of_jsbytes("cancelable"),
     cst_bubbles$0=caml_string_of_jsbytes("bubbles"),
     cst_eventPhase=caml_string_of_jsbytes("eventPhase"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_bubbles=caml_string_of_jsbytes("bubbles"),
     cst_cancelable=caml_string_of_jsbytes("cancelable"),
     cst_composed=caml_string_of_jsbytes("composed"),
     cst_isSecureContext=caml_string_of_jsbytes("isSecureContext"),
     cst_reason=caml_string_of_jsbytes("reason"),
     cst_code$2=caml_string_of_jsbytes("code"),
     cst_wasClean=caml_string_of_jsbytes("wasClean"),
     cst_protocol$0=caml_string_of_jsbytes("protocol"),
     cst_extensions=caml_string_of_jsbytes("extensions"),
     cst_bufferedAmount=caml_string_of_jsbytes("bufferedAmount"),
     cst_readyState$1=caml_string_of_jsbytes("readyState"),
     cst_url$2=caml_string_of_jsbytes("url"),
     cst_binaryType$0=caml_string_of_jsbytes("binaryType"),
     cst_binaryType=caml_string_of_jsbytes("binaryType"),
     cst_storageArea=caml_string_of_jsbytes("storageArea"),
     cst_url$1=caml_string_of_jsbytes("url"),
     cst_newValue=caml_string_of_jsbytes("newValue"),
     cst_oldValue=caml_string_of_jsbytes("oldValue"),
     cst_key$0=caml_string_of_jsbytes("key"),
     cst_length$4=caml_string_of_jsbytes("length"),
     cst_action$2=caml_string_of_jsbytes("action"),
     cst_title$3=caml_string_of_jsbytes("title"),
     cst_timestamp$1=caml_string_of_jsbytes("timestamp"),
     cst_silent$0=caml_string_of_jsbytes("silent"),
     cst_requireInteraction$0=caml_string_of_jsbytes("requireInteraction"),
     cst_renotify$0=caml_string_of_jsbytes("renotify"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_icon$2=caml_string_of_jsbytes("icon"),
     cst_tag=caml_string_of_jsbytes("tag"),
     cst_lang$0=caml_string_of_jsbytes("lang"),
     cst_dir$1=caml_string_of_jsbytes("dir"),
     cst_body$0=caml_string_of_jsbytes("body"),
     cst_badge$0=caml_string_of_jsbytes("badge"),
     cst_dir$0=caml_string_of_jsbytes("dir"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_icon$1=caml_string_of_jsbytes("icon"),
     cst_badge=caml_string_of_jsbytes("badge"),
     cst_timestamp$0=caml_string_of_jsbytes("timestamp"),
     cst_renotify=caml_string_of_jsbytes("renotify"),
     cst_silent=caml_string_of_jsbytes("silent"),
     cst_requireInteraction=caml_string_of_jsbytes("requireInteraction"),
     cst_data$1=caml_string_of_jsbytes("data"),
     cst_icon$0=caml_string_of_jsbytes("icon"),
     cst_title$2=caml_string_of_jsbytes("title"),
     cst_action$1=caml_string_of_jsbytes("action"),
     cst_action$0=caml_string_of_jsbytes("action"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_icon=caml_string_of_jsbytes("icon"),
     cst_maxActions=caml_string_of_jsbytes("maxActions"),
     cst_permission=caml_string_of_jsbytes("permission"),
     cst_lastEventId=caml_string_of_jsbytes("lastEventId"),
     cst_origin=caml_string_of_jsbytes("origin"),
     cst_name$3=caml_string_of_jsbytes("name"),
     cst_targetOrigin=caml_string_of_jsbytes("targetOrigin"),
     cst_transfer=caml_string_of_jsbytes("transfer"),
     cst_defaultMuted$0=caml_string_of_jsbytes("defaultMuted"),
     cst_defaultMuted=caml_string_of_jsbytes("defaultMuted"),
     cst_muted$1=caml_string_of_jsbytes("muted"),
     cst_muted$0=caml_string_of_jsbytes("muted"),
     cst_volume$0=caml_string_of_jsbytes("volume"),
     cst_volume=caml_string_of_jsbytes("volume"),
     cst_controls$0=caml_string_of_jsbytes("controls"),
     cst_controls=caml_string_of_jsbytes("controls"),
     cst_loop$0=caml_string_of_jsbytes("loop"),
     cst_loop=caml_string_of_jsbytes("loop"),
     cst_autoplay$0=caml_string_of_jsbytes("autoplay"),
     cst_autoplay=caml_string_of_jsbytes("autoplay"),
     cst_ended=caml_string_of_jsbytes("ended"),
     cst_playbackRate$0=caml_string_of_jsbytes("playbackRate"),
     cst_playbackRate=caml_string_of_jsbytes("playbackRate"),
     cst_defaultPlaybackRate$0=caml_string_of_jsbytes("defaultPlaybackRate"),
     cst_defaultPlaybackRate=caml_string_of_jsbytes("defaultPlaybackRate"),
     cst_paused=caml_string_of_jsbytes("paused"),
     cst_duration$0=caml_string_of_jsbytes("duration"),
     cst_currentTime$0=caml_string_of_jsbytes("currentTime"),
     cst_currentTime=caml_string_of_jsbytes("currentTime"),
     cst_seeking=caml_string_of_jsbytes("seeking"),
     cst_readyState$0=caml_string_of_jsbytes("readyState"),
     cst_preload$0=caml_string_of_jsbytes("preload"),
     cst_preload=caml_string_of_jsbytes("preload"),
     cst_networkState=caml_string_of_jsbytes("networkState"),
     cst_crossOrigin$0=caml_string_of_jsbytes("crossOrigin"),
     cst_crossOrigin=caml_string_of_jsbytes("crossOrigin"),
     cst_currentSrc=caml_string_of_jsbytes("currentSrc"),
     cst_src$0=caml_string_of_jsbytes("src"),
     cst_src=caml_string_of_jsbytes("src"),
     cst_length$3=caml_string_of_jsbytes("length"),
     cst_message$1=caml_string_of_jsbytes("message"),
     cst_code$1=caml_string_of_jsbytes("code"),
     cst_groupId=caml_string_of_jsbytes("groupId"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_kind$1=caml_string_of_jsbytes("kind"),
     cst_deviceId=caml_string_of_jsbytes("deviceId"),
     cst_timecode=caml_string_of_jsbytes("timecode"),
     cst_start=caml_string_of_jsbytes("start"),
     cst_audioBitrateMode$0=caml_string_of_jsbytes("audioBitrateMode"),
     cst_audioBitsPerSecond$0=caml_string_of_jsbytes("audioBitsPerSecond"),
     cst_videoBitsPerSecond$0=caml_string_of_jsbytes("videoBitsPerSecond"),
     cst_state=caml_string_of_jsbytes("state"),
     cst_mimeType$0=caml_string_of_jsbytes("mimeType"),
     cst_mimeType=caml_string_of_jsbytes("mimeType"),
     cst_audioBitsPerSecond=caml_string_of_jsbytes("audioBitsPerSecond"),
     cst_videoBitsPerSecond=caml_string_of_jsbytes("videoBitsPerSecond"),
     cst_bitsPerSecond=caml_string_of_jsbytes("bitsPerSecond"),
     cst_audioBitrateMode=caml_string_of_jsbytes("audioBitrateMode"),
     cst_active=caml_string_of_jsbytes("active"),
     cst_id$0=caml_string_of_jsbytes("id"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_applyConstraints=caml_string_of_jsbytes("applyConstraints"),
     cst_enabled$0=caml_string_of_jsbytes("enabled"),
     cst_enabled=caml_string_of_jsbytes("enabled"),
     cst_readyState=caml_string_of_jsbytes("readyState"),
     cst_muted=caml_string_of_jsbytes("muted"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_kind$0=caml_string_of_jsbytes("kind"),
     cst_isolated=caml_string_of_jsbytes("isolated"),
     cst_id=caml_string_of_jsbytes("id"),
     cst_exact$2=caml_string_of_jsbytes("exact"),
     cst_ideal$2=caml_string_of_jsbytes("ideal"),
     cst_min$4=caml_string_of_jsbytes("min"),
     cst_max$4=caml_string_of_jsbytes("max"),
     cst_exact$1=caml_string_of_jsbytes("exact"),
     cst_ideal$1=caml_string_of_jsbytes("ideal"),
     cst_max$3=caml_string_of_jsbytes("max"),
     cst_min$3=caml_string_of_jsbytes("min"),
     cst_min$2=caml_string_of_jsbytes("min"),
     cst_max$2=caml_string_of_jsbytes("max"),
     cst_min$1=caml_string_of_jsbytes("min"),
     cst_max$1=caml_string_of_jsbytes("max"),
     cst_exact$0=caml_string_of_jsbytes("exact"),
     cst_ideal$0=caml_string_of_jsbytes("ideal"),
     cst_max$0=caml_string_of_jsbytes("max"),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_min=caml_string_of_jsbytes("min"),
     cst_max=caml_string_of_jsbytes("max"),
     cst_exact=caml_string_of_jsbytes("exact"),
     cst_ideal=caml_string_of_jsbytes("ideal"),
     cst_enableHighAccuracy=caml_string_of_jsbytes("enableHighAccuracy"),
     cst_timeout=caml_string_of_jsbytes("timeout"),
     cst_maximumAge=caml_string_of_jsbytes("maximumAge"),
     cst_timestamp=caml_string_of_jsbytes("timestamp"),
     cst_speed=caml_string_of_jsbytes("speed"),
     cst_heading=caml_string_of_jsbytes("heading"),
     cst_altitudeAccuracy=caml_string_of_jsbytes("altitudeAccuracy"),
     cst_accuracy=caml_string_of_jsbytes("accuracy"),
     cst_altitude=caml_string_of_jsbytes("altitude"),
     cst_longitude=caml_string_of_jsbytes("longitude"),
     cst_latitude=caml_string_of_jsbytes("latitude"),
     cst_message$0=caml_string_of_jsbytes("message"),
     cst_code$0=caml_string_of_jsbytes("code"),
     cst_replacesClientId=caml_string_of_jsbytes("replacesClientId"),
     cst_resultingClientId=caml_string_of_jsbytes("resultingClientId"),
     cst_clientId=caml_string_of_jsbytes("clientId"),
     cst_ignoreSearch=caml_string_of_jsbytes("ignoreSearch"),
     cst_ignoreMethod=caml_string_of_jsbytes("ignoreMethod"),
     cst_ignoreVary=caml_string_of_jsbytes("ignoreVary"),
     cst_cacheName=caml_string_of_jsbytes("cacheName"),
     cst_url$0=caml_string_of_jsbytes("url"),
     cst_statusText$0=caml_string_of_jsbytes("statusText"),
     cst_status$0=caml_string_of_jsbytes("status"),
     cst_redirected=caml_string_of_jsbytes("redirected"),
     cst_ok=caml_string_of_jsbytes("ok"),
     cst_redirect$1=caml_string_of_jsbytes("redirect"),
     cst_headers$0=caml_string_of_jsbytes("headers"),
     cst_status=caml_string_of_jsbytes("status"),
     cst_statusText=caml_string_of_jsbytes("statusText"),
     cst_url=caml_string_of_jsbytes("url"),
     cst_referrerPolicy$0=caml_string_of_jsbytes("referrerPolicy"),
     cst_referrer$1=caml_string_of_jsbytes("referrer"),
     cst_redirect$0=caml_string_of_jsbytes("redirect"),
     cst_mode$0=caml_string_of_jsbytes("mode"),
     cst_method$1=caml_string_of_jsbytes("method'"),
     cst_keepalive$0=caml_string_of_jsbytes("keepalive"),
     cst_isReloadNavigation=caml_string_of_jsbytes("isReloadNavigation"),
     cst_isHistoryNavigation=caml_string_of_jsbytes("isHistoryNavigation"),
     cst_integrity$0=caml_string_of_jsbytes("integrity"),
     cst_destination=caml_string_of_jsbytes("destination"),
     cst_credentials$0=caml_string_of_jsbytes("credentials"),
     cst_cache$0=caml_string_of_jsbytes("cache"),
     cst_cache=caml_string_of_jsbytes("cache"),
     cst_credentials=caml_string_of_jsbytes("credentials"),
     cst_headers=caml_string_of_jsbytes("headers"),
     cst_integrity=caml_string_of_jsbytes("integrity"),
     cst_keepalive=caml_string_of_jsbytes("keepalive"),
     cst_method$0=caml_string_of_jsbytes("method"),
     cst_mode=caml_string_of_jsbytes("mode"),
     cst_redirect=caml_string_of_jsbytes("redirect"),
     cst_referrer$0=caml_string_of_jsbytes("referrer"),
     cst_referrerPolicy=caml_string_of_jsbytes("referrerPolicy"),
     cst_bodyUsed=caml_string_of_jsbytes("bodyUsed"),
     cst_requestSubmit=caml_string_of_jsbytes("requestSubmit"),
     cst_noValidate=caml_string_of_jsbytes("noValidate"),
     cst_autocomplete=caml_string_of_jsbytes("autocomplete"),
     cst_acceptCharset=caml_string_of_jsbytes("acceptCharset"),
     cst_enctype=caml_string_of_jsbytes("enctype"),
     cst_action=caml_string_of_jsbytes("action"),
     cst_target=caml_string_of_jsbytes("target"),
     cst_method=caml_string_of_jsbytes("method"),
     cst_name$2=caml_string_of_jsbytes("name"),
     cst_delayed=caml_string_of_jsbytes("delayed"),
     cst_lastModified$1=caml_string_of_jsbytes("lastModified"),
     cst_presentationStyle$0=caml_string_of_jsbytes("presentationStyle"),
     cst_presentationStyle=caml_string_of_jsbytes("presentationStyle"),
     cst_precision=caml_string_of_jsbytes("precision"),
     cst_rangeMax=caml_string_of_jsbytes("rangeMax"),
     cst_rangeMin=caml_string_of_jsbytes("rangeMin"),
     cst_name$4=caml_string_of_jsbytes("name"),
     cst_type$5=caml_string_of_jsbytes("type"),
     cst_size$0=caml_string_of_jsbytes("size"),
     cst_isContextLost=caml_string_of_jsbytes("isContextLost"),
     cst_drawingBufferHeight=caml_string_of_jsbytes("drawingBufferHeight"),
     cst_drawingBufferWidth=caml_string_of_jsbytes("drawingBufferWidth"),
     cst_canvas$0=caml_string_of_jsbytes("canvas"),
     cst_webgl=caml_string_of_jsbytes("webgl"),
     cst_webgl2=caml_string_of_jsbytes("webgl2"),
     cst_desynchronized$1=caml_string_of_jsbytes("desynchronized"),
     cst_powerPreference$0=caml_string_of_jsbytes("powerPreference"),
     cst_preserveDrawingBuffer$0=
      caml_string_of_jsbytes("preserveDrawingBuffer"),
     cst_premultipliedApha$0=caml_string_of_jsbytes("premultipliedApha"),
     cst_antialias$0=caml_string_of_jsbytes("antialias"),
     cst_stencil$0=caml_string_of_jsbytes("stencil"),
     cst_depth$0=caml_string_of_jsbytes("depth"),
     cst_alpha$1=caml_string_of_jsbytes("alpha"),
     cst_alpha$0=caml_string_of_jsbytes("alpha"),
     cst_depth=caml_string_of_jsbytes("depth"),
     cst_stencil=caml_string_of_jsbytes("stencil"),
     cst_antialias=caml_string_of_jsbytes("antialias"),
     cst_premultipliedApha=caml_string_of_jsbytes("premultipliedApha"),
     cst_preserveDrawingBuffer=caml_string_of_jsbytes("preserveDrawingBuffer"),
     cst_powerPreference=caml_string_of_jsbytes("powerPreference"),
     cst_failIfMajorPerformanceCave=
      caml_string_of_jsbytes("failIfMajorPerformanceCaveat"),
     cst_desynchronized$0=caml_string_of_jsbytes("desynchronized"),
     cst_height$4=caml_string_of_jsbytes("height"),
     cst_width$5=caml_string_of_jsbytes("width"),
     cst_ideographicBaseline=caml_string_of_jsbytes("ideographicBaseline"),
     cst_alphabeticBaseline=caml_string_of_jsbytes("alphabeticBaseline"),
     cst_hangingBaseline=caml_string_of_jsbytes("hangingBaseline"),
     cst_emHeightDescent=caml_string_of_jsbytes("emHeightDescent"),
     cst_emHeightAscent=caml_string_of_jsbytes("emHeightAscent"),
     cst_actualBoundingBoxDescent=
      caml_string_of_jsbytes("actualBoundingBoxDescent"),
     cst_actualBoundingBoxAscent=
      caml_string_of_jsbytes("actualBoundingBoxAscent"),
     cst_fontBoundingBoxDescent=
      caml_string_of_jsbytes("fontBoundingBoxDescent"),
     cst_fontBoundingBoxAscent=caml_string_of_jsbytes("fontBoundingBoxAscent"),
     cst_actualBoundingBoxRight=
      caml_string_of_jsbytes("actualBoundingBoxRight"),
     cst_actualBoundingBoxLeft=caml_string_of_jsbytes("actualBoundingBoxLeft"),
     cst_width$4=caml_string_of_jsbytes("width"),
     cst_strokeText=caml_string_of_jsbytes("strokeText"),
     cst_fillText=caml_string_of_jsbytes("fillText"),
     cst_direction$0=caml_string_of_jsbytes("direction"),
     cst_direction=caml_string_of_jsbytes("direction"),
     cst_textBaseline$0=caml_string_of_jsbytes("textBaseline"),
     cst_textBaseline=caml_string_of_jsbytes("textBaseline"),
     cst_textAlign$0=caml_string_of_jsbytes("textAlign"),
     cst_textAlign=caml_string_of_jsbytes("textAlign"),
     cst_font$0=caml_string_of_jsbytes("font"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_shadowColor$0=caml_string_of_jsbytes("shadowColor"),
     cst_shadowColor=caml_string_of_jsbytes("shadowColor"),
     cst_shadowOffsetY$0=caml_string_of_jsbytes("shadowOffsetY"),
     cst_shadowOffsetY=caml_string_of_jsbytes("shadowOffsetY"),
     cst_shadowOffsetX$0=caml_string_of_jsbytes("shadowOffsetX"),
     cst_shadowOffsetX=caml_string_of_jsbytes("shadowOffsetX"),
     cst_shadowBlur$0=caml_string_of_jsbytes("shadowBlur"),
     cst_shadowBlur=caml_string_of_jsbytes("shadowBlur"),
     cst_lineDashOffset$0=caml_string_of_jsbytes("lineDashOffset"),
     cst_lineDashOffset=caml_string_of_jsbytes("lineDashOffset"),
     cst_miterLimit$0=caml_string_of_jsbytes("miterLimit"),
     cst_miterLimit=caml_string_of_jsbytes("miterLimit"),
     cst_lineJoin$0=caml_string_of_jsbytes("lineJoin"),
     cst_lineJoin=caml_string_of_jsbytes("lineJoin"),
     cst_lineCap$0=caml_string_of_jsbytes("lineCap"),
     cst_lineCap=caml_string_of_jsbytes("lineCap"),
     cst_lineWidth$0=caml_string_of_jsbytes("lineWidth"),
     cst_lineWidth=caml_string_of_jsbytes("lineWidth"),
     cst_filter$0=caml_string_of_jsbytes("filter"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_globalCompositeOperation$0=
      caml_string_of_jsbytes("globalCompositeOperation"),
     cst_globalCompositeOperation=
      caml_string_of_jsbytes("globalCompositeOperation"),
     cst_globalAlpha$0=caml_string_of_jsbytes("globalAlpha"),
     cst_globalAlpha=caml_string_of_jsbytes("globalAlpha"),
     cst_imageSmoothingQuality$0=
      caml_string_of_jsbytes("imageSmoothingQuality"),
     cst_imageSmoothingQuality=caml_string_of_jsbytes("imageSmoothingQuality"),
     cst_imageSmoothingEnabled$0=
      caml_string_of_jsbytes("imageSmoothingEnabled"),
     cst_imageSmoothingEnabled=caml_string_of_jsbytes("imageSmoothingEnabled"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_desynchronized=caml_string_of_jsbytes("desynchronized"),
     cst_alpha=caml_string_of_jsbytes("alpha"),
     cst_addPath=caml_string_of_jsbytes("addPath"),
     cst_captureStrseam=caml_string_of_jsbytes("captureStrseam"),
     cst_toBlob=caml_string_of_jsbytes("toBlob"),
     cst_toDataURL=caml_string_of_jsbytes("toDataURL"),
     cst_quality$0=caml_string_of_jsbytes("quality"),
     cst_type$4=caml_string_of_jsbytes("type"),
     cst_quality=caml_string_of_jsbytes("quality"),
     cst_height$3=caml_string_of_jsbytes("height"),
     cst_width$3=caml_string_of_jsbytes("width"),
     cst_height$2=caml_string_of_jsbytes("height"),
     cst_width$2=caml_string_of_jsbytes("width"),
     cst_width$1=caml_string_of_jsbytes("width"),
     cst_height$1=caml_string_of_jsbytes("height"),
     cst_w=caml_string_of_jsbytes("w"),
     cst_z=caml_string_of_jsbytes("z"),
     cst_y$0=caml_string_of_jsbytes("y"),
     cst_x$0=caml_string_of_jsbytes("x"),
     cst_f=caml_string_of_jsbytes("f"),
     cst_e=caml_string_of_jsbytes("e"),
     cst_d=caml_string_of_jsbytes("d"),
     cst_c=caml_string_of_jsbytes("c"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_m44=caml_string_of_jsbytes("m44"),
     cst_m43=caml_string_of_jsbytes("m43"),
     cst_m42=caml_string_of_jsbytes("m42"),
     cst_m41=caml_string_of_jsbytes("m41"),
     cst_m34=caml_string_of_jsbytes("m34"),
     cst_m33=caml_string_of_jsbytes("m33"),
     cst_m32=caml_string_of_jsbytes("m32"),
     cst_m31=caml_string_of_jsbytes("m31"),
     cst_m24=caml_string_of_jsbytes("m24"),
     cst_m23=caml_string_of_jsbytes("m23"),
     cst_m22=caml_string_of_jsbytes("m22"),
     cst_m21=caml_string_of_jsbytes("m21"),
     cst_m14=caml_string_of_jsbytes("m14"),
     cst_m13=caml_string_of_jsbytes("m13"),
     cst_m12=caml_string_of_jsbytes("m12"),
     cst_m11=caml_string_of_jsbytes("m11"),
     cst_isIdentity=caml_string_of_jsbytes("isIdentity"),
     cst_is2D=caml_string_of_jsbytes("is2D"),
     cst_DEPTH_BUFFER_BIT=caml_string_of_jsbytes("DEPTH_BUFFER_BIT"),
     cst_STENCIL_BUFFER_BIT=caml_string_of_jsbytes("STENCIL_BUFFER_BIT"),
     cst_COLOR_BUFFER_BIT=caml_string_of_jsbytes("COLOR_BUFFER_BIT"),
     cst_POINTS=caml_string_of_jsbytes("POINTS"),
     cst_LINES=caml_string_of_jsbytes("LINES"),
     cst_LINE_LOOP=caml_string_of_jsbytes("LINE_LOOP"),
     cst_LINE_STRIP=caml_string_of_jsbytes("LINE_STRIP"),
     cst_TRIANGLES=caml_string_of_jsbytes("TRIANGLES"),
     cst_TRIANGLE_STRIP=caml_string_of_jsbytes("TRIANGLE_STRIP"),
     cst_TRIANGLE_FAN=caml_string_of_jsbytes("TRIANGLE_FAN"),
     cst_ZERO=caml_string_of_jsbytes("ZERO"),
     cst_ONE=caml_string_of_jsbytes("ONE"),
     cst_SRC_COLOR=caml_string_of_jsbytes("SRC_COLOR"),
     cst_ONE_MINUS_SRC_COLOR=caml_string_of_jsbytes("ONE_MINUS_SRC_COLOR"),
     cst_SRC_ALPHA=caml_string_of_jsbytes("SRC_ALPHA"),
     cst_ONE_MINUS_SRC_ALPHA=caml_string_of_jsbytes("ONE_MINUS_SRC_ALPHA"),
     cst_DST_ALPHA=caml_string_of_jsbytes("DST_ALPHA"),
     cst_ONE_MINUS_DST_ALPHA=caml_string_of_jsbytes("ONE_MINUS_DST_ALPHA"),
     cst_DST_COLOR=caml_string_of_jsbytes("DST_COLOR"),
     cst_ONE_MINUS_DST_COLOR=caml_string_of_jsbytes("ONE_MINUS_DST_COLOR"),
     cst_SRC_ALPHA_SATURATE=caml_string_of_jsbytes("SRC_ALPHA_SATURATE"),
     cst_FUNC_ADD=caml_string_of_jsbytes("FUNC_ADD"),
     cst_BLEND_EQUATION=caml_string_of_jsbytes("BLEND_EQUATION"),
     cst_BLEND_EQUATION_RGB=caml_string_of_jsbytes("BLEND_EQUATION_RGB"),
     cst_BLEND_EQUATION_ALPHA=caml_string_of_jsbytes("BLEND_EQUATION_ALPHA"),
     cst_FUNC_SUBTRACT=caml_string_of_jsbytes("FUNC_SUBTRACT"),
     cst_FUNC_REVERSE_SUBTRACT=caml_string_of_jsbytes("FUNC_REVERSE_SUBTRACT"),
     cst_BLEND_DST_RGB=caml_string_of_jsbytes("BLEND_DST_RGB"),
     cst_BLEND_SRC_RGB=caml_string_of_jsbytes("BLEND_SRC_RGB"),
     cst_BLEND_DST_ALPHA=caml_string_of_jsbytes("BLEND_DST_ALPHA"),
     cst_BLEND_SRC_ALPHA=caml_string_of_jsbytes("BLEND_SRC_ALPHA"),
     cst_CONSTANT_COLOR=caml_string_of_jsbytes("CONSTANT_COLOR"),
     cst_ONE_MINUS_CONSTANT_COLOR=
      caml_string_of_jsbytes("ONE_MINUS_CONSTANT_COLOR"),
     cst_CONSTANT_ALPHA=caml_string_of_jsbytes("CONSTANT_ALPHA"),
     cst_ONE_MINUS_CONSTANT_ALPHA=
      caml_string_of_jsbytes("ONE_MINUS_CONSTANT_ALPHA"),
     cst_BLEND_COLOR=caml_string_of_jsbytes("BLEND_COLOR"),
     cst_ARRAY_BUFFER=caml_string_of_jsbytes("ARRAY_BUFFER"),
     cst_ELEMENT_ARRAY_BUFFER=caml_string_of_jsbytes("ELEMENT_ARRAY_BUFFER"),
     cst_ARRAY_BUFFER_BINDING=caml_string_of_jsbytes("ARRAY_BUFFER_BINDING"),
     cst_ELEMENT_ARRAY_BUFFER_BINDI=
      caml_string_of_jsbytes("ELEMENT_ARRAY_BUFFER_BINDING"),
     cst_STREAM_DRAW=caml_string_of_jsbytes("STREAM_DRAW"),
     cst_STATIC_DRAW=caml_string_of_jsbytes("STATIC_DRAW"),
     cst_DYNAMIC_DRAW=caml_string_of_jsbytes("DYNAMIC_DRAW"),
     cst_BUFFER_SIZE=caml_string_of_jsbytes("BUFFER_SIZE"),
     cst_BUFFER_USAGE=caml_string_of_jsbytes("BUFFER_USAGE"),
     cst_CURRENT_VERTEX_ATTRIB=caml_string_of_jsbytes("CURRENT_VERTEX_ATTRIB"),
     cst_FRONT=caml_string_of_jsbytes("FRONT"),
     cst_BACK=caml_string_of_jsbytes("BACK"),
     cst_FRONT_AND_BACK=caml_string_of_jsbytes("FRONT_AND_BACK"),
     cst_CULL_FACE=caml_string_of_jsbytes("CULL_FACE"),
     cst_BLEND=caml_string_of_jsbytes("BLEND"),
     cst_DITHER=caml_string_of_jsbytes("DITHER"),
     cst_STENCIL_TEST=caml_string_of_jsbytes("STENCIL_TEST"),
     cst_DEPTH_TEST=caml_string_of_jsbytes("DEPTH_TEST"),
     cst_SCISSOR_TEST=caml_string_of_jsbytes("SCISSOR_TEST"),
     cst_POLYGON_OFFSET_FILL=caml_string_of_jsbytes("POLYGON_OFFSET_FILL"),
     cst_SAMPLE_ALPHA_TO_COVERAGE=
      caml_string_of_jsbytes("SAMPLE_ALPHA_TO_COVERAGE"),
     cst_SAMPLE_COVERAGE=caml_string_of_jsbytes("SAMPLE_COVERAGE"),
     cst_NO_ERROR=caml_string_of_jsbytes("NO_ERROR"),
     cst_INVALID_ENUM=caml_string_of_jsbytes("INVALID_ENUM"),
     cst_INVALID_VALUE=caml_string_of_jsbytes("INVALID_VALUE"),
     cst_INVALID_OPERATION=caml_string_of_jsbytes("INVALID_OPERATION"),
     cst_OUT_OF_MEMORY=caml_string_of_jsbytes("OUT_OF_MEMORY"),
     cst_CW=caml_string_of_jsbytes("CW"),
     cst_CCW=caml_string_of_jsbytes("CCW"),
     cst_LINE_WIDTH=caml_string_of_jsbytes("LINE_WIDTH"),
     cst_ALIASED_POINT_SIZE_RANGE=
      caml_string_of_jsbytes("ALIASED_POINT_SIZE_RANGE"),
     cst_ALIASED_LINE_WIDTH_RANGE=
      caml_string_of_jsbytes("ALIASED_LINE_WIDTH_RANGE"),
     cst_CULL_FACE_MODE=caml_string_of_jsbytes("CULL_FACE_MODE"),
     cst_FRONT_FACE=caml_string_of_jsbytes("FRONT_FACE"),
     cst_DEPTH_RANGE=caml_string_of_jsbytes("DEPTH_RANGE"),
     cst_DEPTH_WRITEMASK=caml_string_of_jsbytes("DEPTH_WRITEMASK"),
     cst_DEPTH_CLEAR_VALUE=caml_string_of_jsbytes("DEPTH_CLEAR_VALUE"),
     cst_DEPTH_FUNC=caml_string_of_jsbytes("DEPTH_FUNC"),
     cst_STENCIL_CLEAR_VALUE=caml_string_of_jsbytes("STENCIL_CLEAR_VALUE"),
     cst_STENCIL_FUNC=caml_string_of_jsbytes("STENCIL_FUNC"),
     cst_STENCIL_FAIL=caml_string_of_jsbytes("STENCIL_FAIL"),
     cst_STENCIL_PASS_DEPTH_FAIL=
      caml_string_of_jsbytes("STENCIL_PASS_DEPTH_FAIL"),
     cst_STENCIL_PASS_DEPTH_PASS=
      caml_string_of_jsbytes("STENCIL_PASS_DEPTH_PASS"),
     cst_STENCIL_REF=caml_string_of_jsbytes("STENCIL_REF"),
     cst_STENCIL_VALUE_MASK=caml_string_of_jsbytes("STENCIL_VALUE_MASK"),
     cst_STENCIL_WRITEMASK=caml_string_of_jsbytes("STENCIL_WRITEMASK"),
     cst_STENCIL_BACK_FUNC=caml_string_of_jsbytes("STENCIL_BACK_FUNC"),
     cst_STENCIL_BACK_FAIL=caml_string_of_jsbytes("STENCIL_BACK_FAIL"),
     cst_STENCIL_BACK_PASS_DEPTH_FA=
      caml_string_of_jsbytes("STENCIL_BACK_PASS_DEPTH_FAIL"),
     cst_STENCIL_BACK_PASS_DEPTH_PA=
      caml_string_of_jsbytes("STENCIL_BACK_PASS_DEPTH_PASS"),
     cst_STENCIL_BACK_REF=caml_string_of_jsbytes("STENCIL_BACK_REF"),
     cst_STENCIL_BACK_VALUE_MASK=
      caml_string_of_jsbytes("STENCIL_BACK_VALUE_MASK"),
     cst_STENCIL_BACK_WRITEMASK=
      caml_string_of_jsbytes("STENCIL_BACK_WRITEMASK"),
     cst_VIEWPORT=caml_string_of_jsbytes("VIEWPORT"),
     cst_SCISSOR_BOX=caml_string_of_jsbytes("SCISSOR_BOX"),
     cst_COLOR_CLEAR_VALUE=caml_string_of_jsbytes("COLOR_CLEAR_VALUE"),
     cst_COLOR_WRITEMASK=caml_string_of_jsbytes("COLOR_WRITEMASK"),
     cst_UNPACK_ALIGNMENT=caml_string_of_jsbytes("UNPACK_ALIGNMENT"),
     cst_PACK_ALIGNMENT=caml_string_of_jsbytes("PACK_ALIGNMENT"),
     cst_MAX_TEXTURE_SIZE=caml_string_of_jsbytes("MAX_TEXTURE_SIZE"),
     cst_MAX_VIEWPORT_DIMS=caml_string_of_jsbytes("MAX_VIEWPORT_DIMS"),
     cst_SUBPIXEL_BITS=caml_string_of_jsbytes("SUBPIXEL_BITS"),
     cst_RED_BITS=caml_string_of_jsbytes("RED_BITS"),
     cst_GREEN_BITS=caml_string_of_jsbytes("GREEN_BITS"),
     cst_BLUE_BITS=caml_string_of_jsbytes("BLUE_BITS"),
     cst_ALPHA_BITS=caml_string_of_jsbytes("ALPHA_BITS"),
     cst_DEPTH_BITS=caml_string_of_jsbytes("DEPTH_BITS"),
     cst_STENCIL_BITS=caml_string_of_jsbytes("STENCIL_BITS"),
     cst_POLYGON_OFFSET_UNITS=caml_string_of_jsbytes("POLYGON_OFFSET_UNITS"),
     cst_POLYGON_OFFSET_FACTOR=caml_string_of_jsbytes("POLYGON_OFFSET_FACTOR"),
     cst_TEXTURE_BINDING_2D=caml_string_of_jsbytes("TEXTURE_BINDING_2D"),
     cst_SAMPLE_BUFFERS=caml_string_of_jsbytes("SAMPLE_BUFFERS"),
     cst_SAMPLES=caml_string_of_jsbytes("SAMPLES"),
     cst_SAMPLE_COVERAGE_VALUE=caml_string_of_jsbytes("SAMPLE_COVERAGE_VALUE"),
     cst_SAMPLE_COVERAGE_INVERT=
      caml_string_of_jsbytes("SAMPLE_COVERAGE_INVERT"),
     cst_COMPRESSED_TEXTURE_FORMATS=
      caml_string_of_jsbytes("COMPRESSED_TEXTURE_FORMATS"),
     cst_DONT_CARE=caml_string_of_jsbytes("DONT_CARE"),
     cst_FASTEST=caml_string_of_jsbytes("FASTEST"),
     cst_NICEST=caml_string_of_jsbytes("NICEST"),
     cst_GENERATE_MIPMAP_HINT=caml_string_of_jsbytes("GENERATE_MIPMAP_HINT"),
     cst_BYTE=caml_string_of_jsbytes("BYTE"),
     cst_UNSIGNED_BYTE=caml_string_of_jsbytes("UNSIGNED_BYTE"),
     cst_SHORT=caml_string_of_jsbytes("SHORT"),
     cst_UNSIGNED_SHORT=caml_string_of_jsbytes("UNSIGNED_SHORT"),
     cst_INT=caml_string_of_jsbytes("INT"),
     cst_UNSIGNED_INT=caml_string_of_jsbytes("UNSIGNED_INT"),
     cst_FLOAT=caml_string_of_jsbytes("FLOAT"),
     cst_DEPTH_COMPONENT=caml_string_of_jsbytes("DEPTH_COMPONENT"),
     cst_ALPHA=caml_string_of_jsbytes("ALPHA"),
     cst_RGB=caml_string_of_jsbytes("RGB"),
     cst_RGBA=caml_string_of_jsbytes("RGBA"),
     cst_LUMINANCE=caml_string_of_jsbytes("LUMINANCE"),
     cst_LUMINANCE_ALPHA=caml_string_of_jsbytes("LUMINANCE_ALPHA"),
     cst_UNSIGNED_SHORT_4_4_4_4=
      caml_string_of_jsbytes("UNSIGNED_SHORT_4_4_4_4"),
     cst_UNSIGNED_SHORT_5_5_5_1=
      caml_string_of_jsbytes("UNSIGNED_SHORT_5_5_5_1"),
     cst_UNSIGNED_SHORT_5_6_5=caml_string_of_jsbytes("UNSIGNED_SHORT_5_6_5"),
     cst_FRAGMENT_SHADER=caml_string_of_jsbytes("FRAGMENT_SHADER"),
     cst_VERTEX_SHADER=caml_string_of_jsbytes("VERTEX_SHADER"),
     cst_MAX_VERTEX_ATTRIBS=caml_string_of_jsbytes("MAX_VERTEX_ATTRIBS"),
     cst_MAX_VERTEX_UNIFORM_VECTORS=
      caml_string_of_jsbytes("MAX_VERTEX_UNIFORM_VECTORS"),
     cst_MAX_VARYING_VECTORS=caml_string_of_jsbytes("MAX_VARYING_VECTORS"),
     cst_MAX_COMBINED_TEXTURE_IMAGE=
      caml_string_of_jsbytes("MAX_COMBINED_TEXTURE_IMAGE_UNITS"),
     cst_MAX_VERTEX_TEXTURE_IMAGE_U=
      caml_string_of_jsbytes("MAX_VERTEX_TEXTURE_IMAGE_UNITS"),
     cst_MAX_TEXTURE_IMAGE_UNITS=
      caml_string_of_jsbytes("MAX_TEXTURE_IMAGE_UNITS"),
     cst_MAX_FRAGMENT_UNIFORM_VECTO=
      caml_string_of_jsbytes("MAX_FRAGMENT_UNIFORM_VECTORS"),
     cst_SHADER_TYPE=caml_string_of_jsbytes("SHADER_TYPE"),
     cst_DELETE_STATUS=caml_string_of_jsbytes("DELETE_STATUS"),
     cst_LINK_STATUS=caml_string_of_jsbytes("LINK_STATUS"),
     cst_VALIDATE_STATUS=caml_string_of_jsbytes("VALIDATE_STATUS"),
     cst_ATTACHED_SHADERS=caml_string_of_jsbytes("ATTACHED_SHADERS"),
     cst_ACTIVE_UNIFORMS=caml_string_of_jsbytes("ACTIVE_UNIFORMS"),
     cst_ACTIVE_ATTRIBUTES=caml_string_of_jsbytes("ACTIVE_ATTRIBUTES"),
     cst_SHADING_LANGUAGE_VERSION=
      caml_string_of_jsbytes("SHADING_LANGUAGE_VERSION"),
     cst_CURRENT_PROGRAM=caml_string_of_jsbytes("CURRENT_PROGRAM"),
     cst_NEVER=caml_string_of_jsbytes("NEVER"),
     cst_LESS=caml_string_of_jsbytes("LESS"),
     cst_EQUAL=caml_string_of_jsbytes("EQUAL"),
     cst_LEQUAL=caml_string_of_jsbytes("LEQUAL"),
     cst_GREATER=caml_string_of_jsbytes("GREATER"),
     cst_NOTEQUAL=caml_string_of_jsbytes("NOTEQUAL"),
     cst_GEQUAL=caml_string_of_jsbytes("GEQUAL"),
     cst_ALWAYS=caml_string_of_jsbytes("ALWAYS"),
     cst_KEEP=caml_string_of_jsbytes("KEEP"),
     cst_REPLACE=caml_string_of_jsbytes("REPLACE"),
     cst_INCR=caml_string_of_jsbytes("INCR"),
     cst_DECR=caml_string_of_jsbytes("DECR"),
     cst_INVERT=caml_string_of_jsbytes("INVERT"),
     cst_INCR_WRAP=caml_string_of_jsbytes("INCR_WRAP"),
     cst_DECR_WRAP=caml_string_of_jsbytes("DECR_WRAP"),
     cst_VENDOR=caml_string_of_jsbytes("VENDOR"),
     cst_RENDERER=caml_string_of_jsbytes("RENDERER"),
     cst_VERSION=caml_string_of_jsbytes("VERSION"),
     cst_NEAREST=caml_string_of_jsbytes("NEAREST"),
     cst_LINEAR=caml_string_of_jsbytes("LINEAR"),
     cst_NEAREST_MIPMAP_NEAREST=
      caml_string_of_jsbytes("NEAREST_MIPMAP_NEAREST"),
     cst_LINEAR_MIPMAP_NEAREST=caml_string_of_jsbytes("LINEAR_MIPMAP_NEAREST"),
     cst_NEAREST_MIPMAP_LINEAR=caml_string_of_jsbytes("NEAREST_MIPMAP_LINEAR"),
     cst_LINEAR_MIPMAP_LINEAR=caml_string_of_jsbytes("LINEAR_MIPMAP_LINEAR"),
     cst_TEXTURE_MAG_FILTER=caml_string_of_jsbytes("TEXTURE_MAG_FILTER"),
     cst_TEXTURE_MIN_FILTER=caml_string_of_jsbytes("TEXTURE_MIN_FILTER"),
     cst_TEXTURE_WRAP_S=caml_string_of_jsbytes("TEXTURE_WRAP_S"),
     cst_TEXTURE_WRAP_T=caml_string_of_jsbytes("TEXTURE_WRAP_T"),
     cst_TEXTURE_2D=caml_string_of_jsbytes("TEXTURE_2D"),
     cst_TEXTURE=caml_string_of_jsbytes("TEXTURE"),
     cst_TEXTURE_CUBE_MAP=caml_string_of_jsbytes("TEXTURE_CUBE_MAP"),
     cst_TEXTURE_BINDING_CUBE_MAP=
      caml_string_of_jsbytes("TEXTURE_BINDING_CUBE_MAP"),
     cst_TEXTURE_CUBE_MAP_POSITIVE_=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_POSITIVE_X"),
     cst_TEXTURE_CUBE_MAP_NEGATIVE_=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_NEGATIVE_X"),
     cst_TEXTURE_CUBE_MAP_POSITIVE_$0=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_POSITIVE_Y"),
     cst_TEXTURE_CUBE_MAP_NEGATIVE_$0=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_NEGATIVE_Y"),
     cst_TEXTURE_CUBE_MAP_POSITIVE_$1=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_POSITIVE_Z"),
     cst_TEXTURE_CUBE_MAP_NEGATIVE_$1=
      caml_string_of_jsbytes("TEXTURE_CUBE_MAP_NEGATIVE_Z"),
     cst_MAX_CUBE_MAP_TEXTURE_SIZE=
      caml_string_of_jsbytes("MAX_CUBE_MAP_TEXTURE_SIZE"),
     cst_TEXTURE0=caml_string_of_jsbytes("TEXTURE0"),
     cst_TEXTURE1=caml_string_of_jsbytes("TEXTURE1"),
     cst_TEXTURE2=caml_string_of_jsbytes("TEXTURE2"),
     cst_TEXTURE3=caml_string_of_jsbytes("TEXTURE3"),
     cst_TEXTURE4=caml_string_of_jsbytes("TEXTURE4"),
     cst_TEXTURE5=caml_string_of_jsbytes("TEXTURE5"),
     cst_TEXTURE6=caml_string_of_jsbytes("TEXTURE6"),
     cst_TEXTURE7=caml_string_of_jsbytes("TEXTURE7"),
     cst_TEXTURE8=caml_string_of_jsbytes("TEXTURE8"),
     cst_TEXTURE9=caml_string_of_jsbytes("TEXTURE9"),
     cst_TEXTURE10=caml_string_of_jsbytes("TEXTURE10"),
     cst_TEXTURE11=caml_string_of_jsbytes("TEXTURE11"),
     cst_TEXTURE12=caml_string_of_jsbytes("TEXTURE12"),
     cst_TEXTURE13=caml_string_of_jsbytes("TEXTURE13"),
     cst_TEXTURE14=caml_string_of_jsbytes("TEXTURE14"),
     cst_TEXTURE15=caml_string_of_jsbytes("TEXTURE15"),
     cst_TEXTURE16=caml_string_of_jsbytes("TEXTURE16"),
     cst_TEXTURE17=caml_string_of_jsbytes("TEXTURE17"),
     cst_TEXTURE18=caml_string_of_jsbytes("TEXTURE18"),
     cst_TEXTURE19=caml_string_of_jsbytes("TEXTURE19"),
     cst_TEXTURE20=caml_string_of_jsbytes("TEXTURE20"),
     cst_TEXTURE21=caml_string_of_jsbytes("TEXTURE21"),
     cst_TEXTURE22=caml_string_of_jsbytes("TEXTURE22"),
     cst_TEXTURE23=caml_string_of_jsbytes("TEXTURE23"),
     cst_TEXTURE24=caml_string_of_jsbytes("TEXTURE24"),
     cst_TEXTURE25=caml_string_of_jsbytes("TEXTURE25"),
     cst_TEXTURE26=caml_string_of_jsbytes("TEXTURE26"),
     cst_TEXTURE27=caml_string_of_jsbytes("TEXTURE27"),
     cst_TEXTURE28=caml_string_of_jsbytes("TEXTURE28"),
     cst_TEXTURE29=caml_string_of_jsbytes("TEXTURE29"),
     cst_TEXTURE30=caml_string_of_jsbytes("TEXTURE30"),
     cst_TEXTURE31=caml_string_of_jsbytes("TEXTURE31"),
     cst_ACTIVE_TEXTURE=caml_string_of_jsbytes("ACTIVE_TEXTURE"),
     cst_REPEAT=caml_string_of_jsbytes("REPEAT"),
     cst_CLAMP_TO_EDGE=caml_string_of_jsbytes("CLAMP_TO_EDGE"),
     cst_MIRRORED_REPEAT=caml_string_of_jsbytes("MIRRORED_REPEAT"),
     cst_FLOAT_VEC2=caml_string_of_jsbytes("FLOAT_VEC2"),
     cst_FLOAT_VEC3=caml_string_of_jsbytes("FLOAT_VEC3"),
     cst_FLOAT_VEC4=caml_string_of_jsbytes("FLOAT_VEC4"),
     cst_INT_VEC2=caml_string_of_jsbytes("INT_VEC2"),
     cst_INT_VEC3=caml_string_of_jsbytes("INT_VEC3"),
     cst_INT_VEC4=caml_string_of_jsbytes("INT_VEC4"),
     cst_BOOL=caml_string_of_jsbytes("BOOL"),
     cst_BOOL_VEC2=caml_string_of_jsbytes("BOOL_VEC2"),
     cst_BOOL_VEC3=caml_string_of_jsbytes("BOOL_VEC3"),
     cst_BOOL_VEC4=caml_string_of_jsbytes("BOOL_VEC4"),
     cst_FLOAT_MAT2=caml_string_of_jsbytes("FLOAT_MAT2"),
     cst_FLOAT_MAT3=caml_string_of_jsbytes("FLOAT_MAT3"),
     cst_FLOAT_MAT4=caml_string_of_jsbytes("FLOAT_MAT4"),
     cst_SAMPLER_2D=caml_string_of_jsbytes("SAMPLER_2D"),
     cst_SAMPLER_CUBE=caml_string_of_jsbytes("SAMPLER_CUBE"),
     cst_VERTEX_ATTRIB_ARRAY_ENABLE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_ENABLED"),
     cst_VERTEX_ATTRIB_ARRAY_SIZE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_SIZE"),
     cst_VERTEX_ATTRIB_ARRAY_STRIDE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_STRIDE"),
     cst_VERTEX_ATTRIB_ARRAY_TYPE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_TYPE"),
     cst_VERTEX_ATTRIB_ARRAY_NORMAL=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_NORMALIZED"),
     cst_VERTEX_ATTRIB_ARRAY_POINTE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_POINTER"),
     cst_VERTEX_ATTRIB_ARRAY_BUFFER=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"),
     cst_IMPLEMENTATION_COLOR_READ_=
      caml_string_of_jsbytes("IMPLEMENTATION_COLOR_READ_TYPE"),
     cst_IMPLEMENTATION_COLOR_READ_$0=
      caml_string_of_jsbytes("IMPLEMENTATION_COLOR_READ_FORMAT"),
     cst_COMPILE_STATUS=caml_string_of_jsbytes("COMPILE_STATUS"),
     cst_LOW_FLOAT=caml_string_of_jsbytes("LOW_FLOAT"),
     cst_MEDIUM_FLOAT=caml_string_of_jsbytes("MEDIUM_FLOAT"),
     cst_HIGH_FLOAT=caml_string_of_jsbytes("HIGH_FLOAT"),
     cst_LOW_INT=caml_string_of_jsbytes("LOW_INT"),
     cst_MEDIUM_INT=caml_string_of_jsbytes("MEDIUM_INT"),
     cst_HIGH_INT=caml_string_of_jsbytes("HIGH_INT"),
     cst_FRAMEBUFFER=caml_string_of_jsbytes("FRAMEBUFFER"),
     cst_RENDERBUFFER=caml_string_of_jsbytes("RENDERBUFFER"),
     cst_RGBA4=caml_string_of_jsbytes("RGBA4"),
     cst_RGB5_A1=caml_string_of_jsbytes("RGB5_A1"),
     cst_RGB565=caml_string_of_jsbytes("RGB565"),
     cst_DEPTH_COMPONENT16=caml_string_of_jsbytes("DEPTH_COMPONENT16"),
     cst_STENCIL_INDEX8=caml_string_of_jsbytes("STENCIL_INDEX8"),
     cst_DEPTH_STENCIL=caml_string_of_jsbytes("DEPTH_STENCIL"),
     cst_RENDERBUFFER_WIDTH=caml_string_of_jsbytes("RENDERBUFFER_WIDTH"),
     cst_RENDERBUFFER_HEIGHT=caml_string_of_jsbytes("RENDERBUFFER_HEIGHT"),
     cst_RENDERBUFFER_INTERNAL_FORM=
      caml_string_of_jsbytes("RENDERBUFFER_INTERNAL_FORMAT"),
     cst_RENDERBUFFER_RED_SIZE=caml_string_of_jsbytes("RENDERBUFFER_RED_SIZE"),
     cst_RENDERBUFFER_GREEN_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_GREEN_SIZE"),
     cst_RENDERBUFFER_BLUE_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_BLUE_SIZE"),
     cst_RENDERBUFFER_ALPHA_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_ALPHA_SIZE"),
     cst_RENDERBUFFER_DEPTH_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_DEPTH_SIZE"),
     cst_RENDERBUFFER_STENCIL_SIZE=
      caml_string_of_jsbytes("RENDERBUFFER_STENCIL_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_OBJ=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"),
     cst_FRAMEBUFFER_ATTACHMENT_OBJ$0=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"),
     cst_FRAMEBUFFER_ATTACHMENT_TEX=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"),
     cst_FRAMEBUFFER_ATTACHMENT_TEX$0=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"),
     cst_COLOR_ATTACHMENT0=caml_string_of_jsbytes("COLOR_ATTACHMENT0"),
     cst_DEPTH_ATTACHMENT=caml_string_of_jsbytes("DEPTH_ATTACHMENT"),
     cst_STENCIL_ATTACHMENT=caml_string_of_jsbytes("STENCIL_ATTACHMENT"),
     cst_DEPTH_STENCIL_ATTACHMENT=
      caml_string_of_jsbytes("DEPTH_STENCIL_ATTACHMENT"),
     cst_NONE=caml_string_of_jsbytes("NONE"),
     cst_FRAMEBUFFER_COMPLETE=caml_string_of_jsbytes("FRAMEBUFFER_COMPLETE"),
     cst_FRAMEBUFFER_INCOMPLETE_ATT=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_ATTACHMENT"),
     cst_FRAMEBUFFER_INCOMPLETE_MIS=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"),
     cst_FRAMEBUFFER_INCOMPLETE_DIM=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_DIMENSIONS"),
     cst_FRAMEBUFFER_UNSUPPORTED=
      caml_string_of_jsbytes("FRAMEBUFFER_UNSUPPORTED"),
     cst_FRAMEBUFFER_BINDING=caml_string_of_jsbytes("FRAMEBUFFER_BINDING"),
     cst_RENDERBUFFER_BINDING=caml_string_of_jsbytes("RENDERBUFFER_BINDING"),
     cst_MAX_RENDERBUFFER_SIZE=caml_string_of_jsbytes("MAX_RENDERBUFFER_SIZE"),
     cst_INVALID_FRAMEBUFFER_OPERAT=
      caml_string_of_jsbytes("INVALID_FRAMEBUFFER_OPERATION"),
     cst_UNPACK_FLIP_Y_WEBGL=caml_string_of_jsbytes("UNPACK_FLIP_Y_WEBGL"),
     cst_UNPACK_PREMULTIPLY_ALPHA_W=
      caml_string_of_jsbytes("UNPACK_PREMULTIPLY_ALPHA_WEBGL"),
     cst_CONTEXT_LOST_WEBGL=caml_string_of_jsbytes("CONTEXT_LOST_WEBGL"),
     cst_UNPACK_COLORSPACE_CONVERSI=
      caml_string_of_jsbytes("UNPACK_COLORSPACE_CONVERSION_WEBGL"),
     cst_BROWSER_DEFAULT_WEBGL=caml_string_of_jsbytes("BROWSER_DEFAULT_WEBGL"),
     cst_READ_BUFFER=caml_string_of_jsbytes("READ_BUFFER"),
     cst_UNPACK_ROW_LENGTH=caml_string_of_jsbytes("UNPACK_ROW_LENGTH"),
     cst_UNPACK_SKIP_ROWS=caml_string_of_jsbytes("UNPACK_SKIP_ROWS"),
     cst_UNPACK_SKIP_PIXELS=caml_string_of_jsbytes("UNPACK_SKIP_PIXELS"),
     cst_PACK_ROW_LENGTH=caml_string_of_jsbytes("PACK_ROW_LENGTH"),
     cst_PACK_SKIP_ROWS=caml_string_of_jsbytes("PACK_SKIP_ROWS"),
     cst_PACK_SKIP_PIXELS=caml_string_of_jsbytes("PACK_SKIP_PIXELS"),
     cst_COLOR=caml_string_of_jsbytes("COLOR"),
     cst_DEPTH=caml_string_of_jsbytes("DEPTH"),
     cst_STENCIL=caml_string_of_jsbytes("STENCIL"),
     cst_RED=caml_string_of_jsbytes("RED"),
     cst_RGB8=caml_string_of_jsbytes("RGB8"),
     cst_RGBA8=caml_string_of_jsbytes("RGBA8"),
     cst_RGB10_A2=caml_string_of_jsbytes("RGB10_A2"),
     cst_TEXTURE_BINDING_3D=caml_string_of_jsbytes("TEXTURE_BINDING_3D"),
     cst_UNPACK_SKIP_IMAGES=caml_string_of_jsbytes("UNPACK_SKIP_IMAGES"),
     cst_UNPACK_IMAGE_HEIGHT=caml_string_of_jsbytes("UNPACK_IMAGE_HEIGHT"),
     cst_TEXTURE_3D=caml_string_of_jsbytes("TEXTURE_3D"),
     cst_TEXTURE_WRAP_R=caml_string_of_jsbytes("TEXTURE_WRAP_R"),
     cst_MAX_3D_TEXTURE_SIZE=caml_string_of_jsbytes("MAX_3D_TEXTURE_SIZE"),
     cst_UNSIGNED_INT_2_10_10_10_RE=
      caml_string_of_jsbytes("UNSIGNED_INT_2_10_10_10_REV"),
     cst_MAX_ELEMENTS_VERTICES=caml_string_of_jsbytes("MAX_ELEMENTS_VERTICES"),
     cst_MAX_ELEMENTS_INDICES=caml_string_of_jsbytes("MAX_ELEMENTS_INDICES"),
     cst_TEXTURE_MIN_LOD=caml_string_of_jsbytes("TEXTURE_MIN_LOD"),
     cst_TEXTURE_MAX_LOD=caml_string_of_jsbytes("TEXTURE_MAX_LOD"),
     cst_TEXTURE_BASE_LEVEL=caml_string_of_jsbytes("TEXTURE_BASE_LEVEL"),
     cst_TEXTURE_MAX_LEVEL=caml_string_of_jsbytes("TEXTURE_MAX_LEVEL"),
     cst_MIN=caml_string_of_jsbytes("MIN"),
     cst_MAX=caml_string_of_jsbytes("MAX"),
     cst_DEPTH_COMPONENT24=caml_string_of_jsbytes("DEPTH_COMPONENT24"),
     cst_MAX_TEXTURE_LOD_BIAS=caml_string_of_jsbytes("MAX_TEXTURE_LOD_BIAS"),
     cst_TEXTURE_COMPARE_MODE=caml_string_of_jsbytes("TEXTURE_COMPARE_MODE"),
     cst_TEXTURE_COMPARE_FUNC=caml_string_of_jsbytes("TEXTURE_COMPARE_FUNC"),
     cst_CURRENT_QUERY=caml_string_of_jsbytes("CURRENT_QUERY"),
     cst_QUERY_RESULT=caml_string_of_jsbytes("QUERY_RESULT"),
     cst_QUERY_RESULT_AVAILABLE=
      caml_string_of_jsbytes("QUERY_RESULT_AVAILABLE"),
     cst_STREAM_READ=caml_string_of_jsbytes("STREAM_READ"),
     cst_STREAM_COPY=caml_string_of_jsbytes("STREAM_COPY"),
     cst_STATIC_READ=caml_string_of_jsbytes("STATIC_READ"),
     cst_STATIC_COPY=caml_string_of_jsbytes("STATIC_COPY"),
     cst_DYNAMIC_READ=caml_string_of_jsbytes("DYNAMIC_READ"),
     cst_DYNAMIC_COPY=caml_string_of_jsbytes("DYNAMIC_COPY"),
     cst_MAX_DRAW_BUFFERS=caml_string_of_jsbytes("MAX_DRAW_BUFFERS"),
     cst_DRAW_BUFFER0=caml_string_of_jsbytes("DRAW_BUFFER0"),
     cst_DRAW_BUFFER1=caml_string_of_jsbytes("DRAW_BUFFER1"),
     cst_DRAW_BUFFER2=caml_string_of_jsbytes("DRAW_BUFFER2"),
     cst_DRAW_BUFFER3=caml_string_of_jsbytes("DRAW_BUFFER3"),
     cst_DRAW_BUFFER4=caml_string_of_jsbytes("DRAW_BUFFER4"),
     cst_DRAW_BUFFER5=caml_string_of_jsbytes("DRAW_BUFFER5"),
     cst_DRAW_BUFFER6=caml_string_of_jsbytes("DRAW_BUFFER6"),
     cst_DRAW_BUFFER7=caml_string_of_jsbytes("DRAW_BUFFER7"),
     cst_DRAW_BUFFER8=caml_string_of_jsbytes("DRAW_BUFFER8"),
     cst_DRAW_BUFFER9=caml_string_of_jsbytes("DRAW_BUFFER9"),
     cst_DRAW_BUFFER10=caml_string_of_jsbytes("DRAW_BUFFER10"),
     cst_DRAW_BUFFER11=caml_string_of_jsbytes("DRAW_BUFFER11"),
     cst_DRAW_BUFFER12=caml_string_of_jsbytes("DRAW_BUFFER12"),
     cst_DRAW_BUFFER13=caml_string_of_jsbytes("DRAW_BUFFER13"),
     cst_DRAW_BUFFER14=caml_string_of_jsbytes("DRAW_BUFFER14"),
     cst_DRAW_BUFFER15=caml_string_of_jsbytes("DRAW_BUFFER15"),
     cst_MAX_FRAGMENT_UNIFORM_COMPO=
      caml_string_of_jsbytes("MAX_FRAGMENT_UNIFORM_COMPONENTS"),
     cst_MAX_VERTEX_UNIFORM_COMPONE=
      caml_string_of_jsbytes("MAX_VERTEX_UNIFORM_COMPONENTS"),
     cst_SAMPLER_3D=caml_string_of_jsbytes("SAMPLER_3D"),
     cst_SAMPLER_2D_SHADOW=caml_string_of_jsbytes("SAMPLER_2D_SHADOW"),
     cst_FRAGMENT_SHADER_DERIVATIVE=
      caml_string_of_jsbytes("FRAGMENT_SHADER_DERIVATIVE_HINT"),
     cst_PIXEL_PACK_BUFFER=caml_string_of_jsbytes("PIXEL_PACK_BUFFER"),
     cst_PIXEL_UNPACK_BUFFER=caml_string_of_jsbytes("PIXEL_UNPACK_BUFFER"),
     cst_PIXEL_PACK_BUFFER_BINDING=
      caml_string_of_jsbytes("PIXEL_PACK_BUFFER_BINDING"),
     cst_PIXEL_UNPACK_BUFFER_BINDIN=
      caml_string_of_jsbytes("PIXEL_UNPACK_BUFFER_BINDING"),
     cst_FLOAT_MAT2x3=caml_string_of_jsbytes("FLOAT_MAT2x3"),
     cst_FLOAT_MAT2x4=caml_string_of_jsbytes("FLOAT_MAT2x4"),
     cst_FLOAT_MAT3x2=caml_string_of_jsbytes("FLOAT_MAT3x2"),
     cst_FLOAT_MAT3x4=caml_string_of_jsbytes("FLOAT_MAT3x4"),
     cst_FLOAT_MAT4x2=caml_string_of_jsbytes("FLOAT_MAT4x2"),
     cst_FLOAT_MAT4x3=caml_string_of_jsbytes("FLOAT_MAT4x3"),
     cst_SRGB=caml_string_of_jsbytes("SRGB"),
     cst_SRGB8=caml_string_of_jsbytes("SRGB8"),
     cst_SRGB8_ALPHA8=caml_string_of_jsbytes("SRGB8_ALPHA8"),
     cst_COMPARE_REF_TO_TEXTURE=
      caml_string_of_jsbytes("COMPARE_REF_TO_TEXTURE"),
     cst_RGBA32F=caml_string_of_jsbytes("RGBA32F"),
     cst_RGB32F=caml_string_of_jsbytes("RGB32F"),
     cst_RGBA16F=caml_string_of_jsbytes("RGBA16F"),
     cst_RGB16F=caml_string_of_jsbytes("RGB16F"),
     cst_VERTEX_ATTRIB_ARRAY_INTEGE=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_INTEGER"),
     cst_MAX_ARRAY_TEXTURE_LAYERS=
      caml_string_of_jsbytes("MAX_ARRAY_TEXTURE_LAYERS"),
     cst_MIN_PROGRAM_TEXEL_OFFSET=
      caml_string_of_jsbytes("MIN_PROGRAM_TEXEL_OFFSET"),
     cst_MAX_PROGRAM_TEXEL_OFFSET=
      caml_string_of_jsbytes("MAX_PROGRAM_TEXEL_OFFSET"),
     cst_MAX_VARYING_COMPONENTS=
      caml_string_of_jsbytes("MAX_VARYING_COMPONENTS"),
     cst_TEXTURE_2D_ARRAY=caml_string_of_jsbytes("TEXTURE_2D_ARRAY"),
     cst_TEXTURE_BINDING_2D_ARRAY=
      caml_string_of_jsbytes("TEXTURE_BINDING_2D_ARRAY"),
     cst_R11F_G11F_B10F=caml_string_of_jsbytes("R11F_G11F_B10F"),
     cst_UNSIGNED_INT_10F_11F_11F_R=
      caml_string_of_jsbytes("UNSIGNED_INT_10F_11F_11F_REV"),
     cst_RGB9_E5=caml_string_of_jsbytes("RGB9_E5"),
     cst_UNSIGNED_INT_5_9_9_9_REV=
      caml_string_of_jsbytes("UNSIGNED_INT_5_9_9_9_REV"),
     cst_TRANSFORM_FEEDBACK_BUFFER_=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_MODE"),
     cst_MAX_TRANSFORM_FEEDBACK_SEP=
      caml_string_of_jsbytes("MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"),
     cst_TRANSFORM_FEEDBACK_VARYING=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_VARYINGS"),
     cst_TRANSFORM_FEEDBACK_BUFFER_$0=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_START"),
     cst_TRANSFORM_FEEDBACK_BUFFER_$1=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_SIZE"),
     cst_TRANSFORM_FEEDBACK_PRIMITI=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"),
     cst_RASTERIZER_DISCARD=caml_string_of_jsbytes("RASTERIZER_DISCARD"),
     cst_MAX_TRANSFORM_FEEDBACK_INT=
      caml_string_of_jsbytes("MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"),
     cst_MAX_TRANSFORM_FEEDBACK_SEP$0=
      caml_string_of_jsbytes("MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"),
     cst_INTERLEAVED_ATTRIBS=caml_string_of_jsbytes("INTERLEAVED_ATTRIBS"),
     cst_SEPARATE_ATTRIBS=caml_string_of_jsbytes("SEPARATE_ATTRIBS"),
     cst_TRANSFORM_FEEDBACK_BUFFER=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER"),
     cst_TRANSFORM_FEEDBACK_BUFFER_$2=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BUFFER_BINDING"),
     cst_RGBA32UI=caml_string_of_jsbytes("RGBA32UI"),
     cst_RGB32UI=caml_string_of_jsbytes("RGB32UI"),
     cst_RGBA16UI=caml_string_of_jsbytes("RGBA16UI"),
     cst_RGB16UI=caml_string_of_jsbytes("RGB16UI"),
     cst_RGBA8UI=caml_string_of_jsbytes("RGBA8UI"),
     cst_RGB8UI=caml_string_of_jsbytes("RGB8UI"),
     cst_RGBA32I=caml_string_of_jsbytes("RGBA32I"),
     cst_RGB32I=caml_string_of_jsbytes("RGB32I"),
     cst_RGBA16I=caml_string_of_jsbytes("RGBA16I"),
     cst_RGB16I=caml_string_of_jsbytes("RGB16I"),
     cst_RGBA8I=caml_string_of_jsbytes("RGBA8I"),
     cst_RGB8I=caml_string_of_jsbytes("RGB8I"),
     cst_RED_INTEGER=caml_string_of_jsbytes("RED_INTEGER"),
     cst_RGB_INTEGER=caml_string_of_jsbytes("RGB_INTEGER"),
     cst_RGBA_INTEGER=caml_string_of_jsbytes("RGBA_INTEGER"),
     cst_SAMPLER_2D_ARRAY=caml_string_of_jsbytes("SAMPLER_2D_ARRAY"),
     cst_SAMPLER_2D_ARRAY_SHADOW=
      caml_string_of_jsbytes("SAMPLER_2D_ARRAY_SHADOW"),
     cst_SAMPLER_CUBE_SHADOW=caml_string_of_jsbytes("SAMPLER_CUBE_SHADOW"),
     cst_UNSIGNED_INT_VEC2=caml_string_of_jsbytes("UNSIGNED_INT_VEC2"),
     cst_UNSIGNED_INT_VEC3=caml_string_of_jsbytes("UNSIGNED_INT_VEC3"),
     cst_UNSIGNED_INT_VEC4=caml_string_of_jsbytes("UNSIGNED_INT_VEC4"),
     cst_INT_SAMPLER_2D=caml_string_of_jsbytes("INT_SAMPLER_2D"),
     cst_INT_SAMPLER_3D=caml_string_of_jsbytes("INT_SAMPLER_3D"),
     cst_INT_SAMPLER_CUBE=caml_string_of_jsbytes("INT_SAMPLER_CUBE"),
     cst_INT_SAMPLER_2D_ARRAY=caml_string_of_jsbytes("INT_SAMPLER_2D_ARRAY"),
     cst_UNSIGNED_INT_SAMPLER_2D=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_2D"),
     cst_UNSIGNED_INT_SAMPLER_3D=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_3D"),
     cst_UNSIGNED_INT_SAMPLER_CUBE=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_CUBE"),
     cst_UNSIGNED_INT_SAMPLER_2D_AR=
      caml_string_of_jsbytes("UNSIGNED_INT_SAMPLER_2D_ARRAY"),
     cst_DEPTH_COMPONENT32F=caml_string_of_jsbytes("DEPTH_COMPONENT32F"),
     cst_DEPTH32F_STENCIL8=caml_string_of_jsbytes("DEPTH32F_STENCIL8"),
     cst_FLOAT_32_UNSIGNED_INT_24_8=
      caml_string_of_jsbytes("FLOAT_32_UNSIGNED_INT_24_8_REV"),
     cst_FRAMEBUFFER_ATTACHMENT_COL=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"),
     cst_FRAMEBUFFER_ATTACHMENT_COM=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"),
     cst_FRAMEBUFFER_ATTACHMENT_RED=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_RED_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_GRE=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_BLU=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_ALP=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_DEP=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"),
     cst_FRAMEBUFFER_ATTACHMENT_STE=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"),
     cst_FRAMEBUFFER_DEFAULT=caml_string_of_jsbytes("FRAMEBUFFER_DEFAULT"),
     cst_UNSIGNED_INT_24_8=caml_string_of_jsbytes("UNSIGNED_INT_24_8"),
     cst_DEPTH24_STENCIL8=caml_string_of_jsbytes("DEPTH24_STENCIL8"),
     cst_UNSIGNED_NORMALIZED=caml_string_of_jsbytes("UNSIGNED_NORMALIZED"),
     cst_DRAW_FRAMEBUFFER_BINDING=
      caml_string_of_jsbytes("DRAW_FRAMEBUFFER_BINDING"),
     cst_READ_FRAMEBUFFER=caml_string_of_jsbytes("READ_FRAMEBUFFER"),
     cst_DRAW_FRAMEBUFFER=caml_string_of_jsbytes("DRAW_FRAMEBUFFER"),
     cst_READ_FRAMEBUFFER_BINDING=
      caml_string_of_jsbytes("READ_FRAMEBUFFER_BINDING"),
     cst_RENDERBUFFER_SAMPLES=caml_string_of_jsbytes("RENDERBUFFER_SAMPLES"),
     cst_FRAMEBUFFER_ATTACHMENT_TEX$1=
      caml_string_of_jsbytes("FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"),
     cst_MAX_COLOR_ATTACHMENTS=caml_string_of_jsbytes("MAX_COLOR_ATTACHMENTS"),
     cst_COLOR_ATTACHMENT1=caml_string_of_jsbytes("COLOR_ATTACHMENT1"),
     cst_COLOR_ATTACHMENT2=caml_string_of_jsbytes("COLOR_ATTACHMENT2"),
     cst_COLOR_ATTACHMENT3=caml_string_of_jsbytes("COLOR_ATTACHMENT3"),
     cst_COLOR_ATTACHMENT4=caml_string_of_jsbytes("COLOR_ATTACHMENT4"),
     cst_COLOR_ATTACHMENT5=caml_string_of_jsbytes("COLOR_ATTACHMENT5"),
     cst_COLOR_ATTACHMENT6=caml_string_of_jsbytes("COLOR_ATTACHMENT6"),
     cst_COLOR_ATTACHMENT7=caml_string_of_jsbytes("COLOR_ATTACHMENT7"),
     cst_COLOR_ATTACHMENT8=caml_string_of_jsbytes("COLOR_ATTACHMENT8"),
     cst_COLOR_ATTACHMENT9=caml_string_of_jsbytes("COLOR_ATTACHMENT9"),
     cst_COLOR_ATTACHMENT10=caml_string_of_jsbytes("COLOR_ATTACHMENT10"),
     cst_COLOR_ATTACHMENT11=caml_string_of_jsbytes("COLOR_ATTACHMENT11"),
     cst_COLOR_ATTACHMENT12=caml_string_of_jsbytes("COLOR_ATTACHMENT12"),
     cst_COLOR_ATTACHMENT13=caml_string_of_jsbytes("COLOR_ATTACHMENT13"),
     cst_COLOR_ATTACHMENT14=caml_string_of_jsbytes("COLOR_ATTACHMENT14"),
     cst_COLOR_ATTACHMENT15=caml_string_of_jsbytes("COLOR_ATTACHMENT15"),
     cst_FRAMEBUFFER_INCOMPLETE_MUL=
      caml_string_of_jsbytes("FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"),
     cst_MAX_SAMPLES=caml_string_of_jsbytes("MAX_SAMPLES"),
     cst_HALF_FLOAT=caml_string_of_jsbytes("HALF_FLOAT"),
     cst_RG=caml_string_of_jsbytes("RG"),
     cst_RG_INTEGER=caml_string_of_jsbytes("RG_INTEGER"),
     cst_R8=caml_string_of_jsbytes("R8"),
     cst_RG8=caml_string_of_jsbytes("RG8"),
     cst_R16F=caml_string_of_jsbytes("R16F"),
     cst_R32F=caml_string_of_jsbytes("R32F"),
     cst_RG16F=caml_string_of_jsbytes("RG16F"),
     cst_RG32F=caml_string_of_jsbytes("RG32F"),
     cst_R8I=caml_string_of_jsbytes("R8I"),
     cst_R8UI=caml_string_of_jsbytes("R8UI"),
     cst_R16I=caml_string_of_jsbytes("R16I"),
     cst_R16UI=caml_string_of_jsbytes("R16UI"),
     cst_R32I=caml_string_of_jsbytes("R32I"),
     cst_R32UI=caml_string_of_jsbytes("R32UI"),
     cst_RG8I=caml_string_of_jsbytes("RG8I"),
     cst_RG8UI=caml_string_of_jsbytes("RG8UI"),
     cst_RG16I=caml_string_of_jsbytes("RG16I"),
     cst_RG16UI=caml_string_of_jsbytes("RG16UI"),
     cst_RG32I=caml_string_of_jsbytes("RG32I"),
     cst_RG32UI=caml_string_of_jsbytes("RG32UI"),
     cst_VERTEX_ARRAY_BINDING=caml_string_of_jsbytes("VERTEX_ARRAY_BINDING"),
     cst_R8_SNORM=caml_string_of_jsbytes("R8_SNORM"),
     cst_RG8_SNORM=caml_string_of_jsbytes("RG8_SNORM"),
     cst_RGB8_SNORM=caml_string_of_jsbytes("RGB8_SNORM"),
     cst_RGBA8_SNORM=caml_string_of_jsbytes("RGBA8_SNORM"),
     cst_SIGNED_NORMALIZED=caml_string_of_jsbytes("SIGNED_NORMALIZED"),
     cst_COPY_READ_BUFFER=caml_string_of_jsbytes("COPY_READ_BUFFER"),
     cst_COPY_WRITE_BUFFER=caml_string_of_jsbytes("COPY_WRITE_BUFFER"),
     cst_COPY_READ_BUFFER_BINDING=
      caml_string_of_jsbytes("COPY_READ_BUFFER_BINDING"),
     cst_COPY_WRITE_BUFFER_BINDING=
      caml_string_of_jsbytes("COPY_WRITE_BUFFER_BINDING"),
     cst_UNIFORM_BUFFER=caml_string_of_jsbytes("UNIFORM_BUFFER"),
     cst_UNIFORM_BUFFER_BINDING=
      caml_string_of_jsbytes("UNIFORM_BUFFER_BINDING"),
     cst_UNIFORM_BUFFER_START=caml_string_of_jsbytes("UNIFORM_BUFFER_START"),
     cst_UNIFORM_BUFFER_SIZE=caml_string_of_jsbytes("UNIFORM_BUFFER_SIZE"),
     cst_MAX_VERTEX_UNIFORM_BLOCKS=
      caml_string_of_jsbytes("MAX_VERTEX_UNIFORM_BLOCKS"),
     cst_MAX_FRAGMENT_UNIFORM_BLOCK=
      caml_string_of_jsbytes("MAX_FRAGMENT_UNIFORM_BLOCKS"),
     cst_MAX_COMBINED_UNIFORM_BLOCK=
      caml_string_of_jsbytes("MAX_COMBINED_UNIFORM_BLOCKS"),
     cst_MAX_UNIFORM_BUFFER_BINDING=
      caml_string_of_jsbytes("MAX_UNIFORM_BUFFER_BINDINGS"),
     cst_MAX_UNIFORM_BLOCK_SIZE=
      caml_string_of_jsbytes("MAX_UNIFORM_BLOCK_SIZE"),
     cst_MAX_COMBINED_VERTEX_UNIFOR=
      caml_string_of_jsbytes("MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"),
     cst_MAX_COMBINED_FRAGMENT_UNIF=
      caml_string_of_jsbytes("MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"),
     cst_UNIFORM_BUFFER_OFFSET_ALIG=
      caml_string_of_jsbytes("UNIFORM_BUFFER_OFFSET_ALIGNMENT"),
     cst_ACTIVE_UNIFORM_BLOCKS=caml_string_of_jsbytes("ACTIVE_UNIFORM_BLOCKS"),
     cst_UNIFORM_TYPE=caml_string_of_jsbytes("UNIFORM_TYPE"),
     cst_UNIFORM_SIZE=caml_string_of_jsbytes("UNIFORM_SIZE"),
     cst_UNIFORM_BLOCK_INDEX=caml_string_of_jsbytes("UNIFORM_BLOCK_INDEX"),
     cst_UNIFORM_OFFSET=caml_string_of_jsbytes("UNIFORM_OFFSET"),
     cst_UNIFORM_ARRAY_STRIDE=caml_string_of_jsbytes("UNIFORM_ARRAY_STRIDE"),
     cst_UNIFORM_MATRIX_STRIDE=caml_string_of_jsbytes("UNIFORM_MATRIX_STRIDE"),
     cst_UNIFORM_IS_ROW_MAJOR=caml_string_of_jsbytes("UNIFORM_IS_ROW_MAJOR"),
     cst_UNIFORM_BLOCK_BINDING=caml_string_of_jsbytes("UNIFORM_BLOCK_BINDING"),
     cst_UNIFORM_BLOCK_DATA_SIZE=
      caml_string_of_jsbytes("UNIFORM_BLOCK_DATA_SIZE"),
     cst_UNIFORM_BLOCK_ACTIVE_UNIFO=
      caml_string_of_jsbytes("UNIFORM_BLOCK_ACTIVE_UNIFORMS"),
     cst_UNIFORM_BLOCK_ACTIVE_UNIFO$0=
      caml_string_of_jsbytes("UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"),
     cst_UNIFORM_BLOCK_REFERENCED_B=
      caml_string_of_jsbytes("UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"),
     cst_UNIFORM_BLOCK_REFERENCED_B$0=
      caml_string_of_jsbytes("UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"),
     cst_INVALID_INDEX=caml_string_of_jsbytes("INVALID_INDEX"),
     cst_MAX_VERTEX_OUTPUT_COMPONEN=
      caml_string_of_jsbytes("MAX_VERTEX_OUTPUT_COMPONENTS"),
     cst_MAX_FRAGMENT_INPUT_COMPONE=
      caml_string_of_jsbytes("MAX_FRAGMENT_INPUT_COMPONENTS"),
     cst_MAX_SERVER_WAIT_TIMEOUT=
      caml_string_of_jsbytes("MAX_SERVER_WAIT_TIMEOUT"),
     cst_OBJECT_TYPE=caml_string_of_jsbytes("OBJECT_TYPE"),
     cst_SYNC_CONDITION=caml_string_of_jsbytes("SYNC_CONDITION"),
     cst_SYNC_STATUS=caml_string_of_jsbytes("SYNC_STATUS"),
     cst_SYNC_FLAGS=caml_string_of_jsbytes("SYNC_FLAGS"),
     cst_SYNC_FENCE=caml_string_of_jsbytes("SYNC_FENCE"),
     cst_SYNC_GPU_COMMANDS_COMPLETE=
      caml_string_of_jsbytes("SYNC_GPU_COMMANDS_COMPLETE"),
     cst_UNSIGNALED=caml_string_of_jsbytes("UNSIGNALED"),
     cst_SIGNALED=caml_string_of_jsbytes("SIGNALED"),
     cst_ALREADY_SIGNALED=caml_string_of_jsbytes("ALREADY_SIGNALED"),
     cst_TIMEOUT_EXPIRED=caml_string_of_jsbytes("TIMEOUT_EXPIRED"),
     cst_CONDITION_SATISFIED=caml_string_of_jsbytes("CONDITION_SATISFIED"),
     cst_WAIT_FAILED=caml_string_of_jsbytes("WAIT_FAILED"),
     cst_SYNC_FLUSH_COMMANDS_BIT=
      caml_string_of_jsbytes("SYNC_FLUSH_COMMANDS_BIT"),
     cst_VERTEX_ATTRIB_ARRAY_DIVISO=
      caml_string_of_jsbytes("VERTEX_ATTRIB_ARRAY_DIVISOR"),
     cst_ANY_SAMPLES_PASSED=caml_string_of_jsbytes("ANY_SAMPLES_PASSED"),
     cst_ANY_SAMPLES_PASSED_CONSERV=
      caml_string_of_jsbytes("ANY_SAMPLES_PASSED_CONSERVATIVE"),
     cst_SAMPLER_BINDING=caml_string_of_jsbytes("SAMPLER_BINDING"),
     cst_RGB10_A2UI=caml_string_of_jsbytes("RGB10_A2UI"),
     cst_INT_2_10_10_10_REV=caml_string_of_jsbytes("INT_2_10_10_10_REV"),
     cst_TRANSFORM_FEEDBACK=caml_string_of_jsbytes("TRANSFORM_FEEDBACK"),
     cst_TRANSFORM_FEEDBACK_PAUSED=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_PAUSED"),
     cst_TRANSFORM_FEEDBACK_ACTIVE=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_ACTIVE"),
     cst_TRANSFORM_FEEDBACK_BINDING=
      caml_string_of_jsbytes("TRANSFORM_FEEDBACK_BINDING"),
     cst_TEXTURE_IMMUTABLE_FORMAT=
      caml_string_of_jsbytes("TEXTURE_IMMUTABLE_FORMAT"),
     cst_MAX_ELEMENT_INDEX=caml_string_of_jsbytes("MAX_ELEMENT_INDEX"),
     cst_TEXTURE_IMMUTABLE_LEVELS=
      caml_string_of_jsbytes("TEXTURE_IMMUTABLE_LEVELS"),
     cst_TIMEOUT_IGNORED=caml_string_of_jsbytes("TIMEOUT_IGNORED"),
     cst_MAX_CLIENT_WAIT_TIMEOUT_WE=
      caml_string_of_jsbytes("MAX_CLIENT_WAIT_TIMEOUT_WEBGL"),
     cst_length$7=caml_string_of_jsbytes("length"),
     cst_outputLatency=caml_string_of_jsbytes("outputLatency"),
     cst_baseLatency=caml_string_of_jsbytes("baseLatency"),
     cst_latencyHint=caml_string_of_jsbytes("latencyHint"),
     cst_sampleRate$2=caml_string_of_jsbytes("sampleRate"),
     cst_state$0=caml_string_of_jsbytes("state"),
     cst_currentTime$2=caml_string_of_jsbytes("currentTime"),
     cst_sampleRate$1=caml_string_of_jsbytes("sampleRate"),
     cst_performanceTime=caml_string_of_jsbytes("performanceTime"),
     cst_contextTime=caml_string_of_jsbytes("contextTime"),
     cst_channelCount$15=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$15=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$15=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_numberOfInputs$1=caml_string_of_jsbytes("numberOfInputs"),
     cst_numberOfOutputs$0=caml_string_of_jsbytes("numberOfOutputs"),
     cst_outputChannelCount=caml_string_of_jsbytes("outputChannelCount"),
     cst_parameterData=caml_string_of_jsbytes("parameterData"),
     cst_processorOptions=caml_string_of_jsbytes("processorOptions"),
     cst_oversample$1=caml_string_of_jsbytes("oversample"),
     cst_oversample$0=caml_string_of_jsbytes("oversample"),
     cst_channelCount$14=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$14=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$14=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_oversample=caml_string_of_jsbytes("oversample"),
     cst_channelCount$13=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$13=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$13=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_pan=caml_string_of_jsbytes("pan"),
     cst_coneOuterGain$0=caml_string_of_jsbytes("coneOuterGain"),
     cst_coneOuterGain=caml_string_of_jsbytes("coneOuterGain"),
     cst_coneOuterAngle$0=caml_string_of_jsbytes("coneOuterAngle"),
     cst_coneOuterAngle=caml_string_of_jsbytes("coneOuterAngle"),
     cst_coneInnerAngle$0=caml_string_of_jsbytes("coneInnerAngle"),
     cst_coneInnerAngle=caml_string_of_jsbytes("coneInnerAngle"),
     cst_maxDistance$1=caml_string_of_jsbytes("maxDistance"),
     cst_maxDistance$0=caml_string_of_jsbytes("maxDistance"),
     cst_refDistance$1=caml_string_of_jsbytes("refDistance"),
     cst_refDistance$0=caml_string_of_jsbytes("refDistance"),
     cst_distanceModel$1=caml_string_of_jsbytes("distanceModel"),
     cst_distanceModel$0=caml_string_of_jsbytes("distanceModel"),
     cst_panningModel$1=caml_string_of_jsbytes("panningModel"),
     cst_panningModel$0=caml_string_of_jsbytes("panningModel"),
     cst_channelCount$12=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$12=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$12=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_panningModel=caml_string_of_jsbytes("panningModel"),
     cst_distanceModel=caml_string_of_jsbytes("distanceModel"),
     cst_positionX=caml_string_of_jsbytes("positionX"),
     cst_positionY=caml_string_of_jsbytes("positionY"),
     cst_positionZ=caml_string_of_jsbytes("positionZ"),
     cst_orientationX=caml_string_of_jsbytes("orientationX"),
     cst_orientationY=caml_string_of_jsbytes("orientationY"),
     cst_orientationZ=caml_string_of_jsbytes("orientationZ"),
     cst_refDistance=caml_string_of_jsbytes("refDistance"),
     cst_maxDistance=caml_string_of_jsbytes("maxDistance"),
     cst_rolloff_factor=caml_string_of_jsbytes("rolloff_factor"),
     cst_cone_inner_angle=caml_string_of_jsbytes("cone_inner_angle"),
     cst_cone_outer_angle=caml_string_of_jsbytes("cone_outer_angle"),
     cst_cone_outer_gain=caml_string_of_jsbytes("cone_outer_gain"),
     cst_type$11=caml_string_of_jsbytes("type"),
     cst_type$10=caml_string_of_jsbytes("type"),
     cst_channelCount$11=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$11=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$11=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_type$9=caml_string_of_jsbytes("type"),
     cst_frequency$0=caml_string_of_jsbytes("frequency"),
     cst_detune$1=caml_string_of_jsbytes("detune"),
     cst_periodicWave=caml_string_of_jsbytes("periodicWave"),
     cst_disableNormalization$0=caml_string_of_jsbytes("disableNormalization"),
     cst_channelCount$10=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$10=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$10=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_channelCount$9=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$9=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$9=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_channelCount$8=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$8=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$8=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_gain$0=caml_string_of_jsbytes("gain"),
     cst_reduction=caml_string_of_jsbytes("reduction"),
     cst_channelCount$7=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$7=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$7=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_attack=caml_string_of_jsbytes("attack"),
     cst_knee=caml_string_of_jsbytes("knee"),
     cst_ratio=caml_string_of_jsbytes("ratio"),
     cst_release=caml_string_of_jsbytes("release"),
     cst_threshold=caml_string_of_jsbytes("threshold"),
     cst_maxChannelCount=caml_string_of_jsbytes("maxChannelCount"),
     cst_channelCount$6=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$6=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$6=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_delayTime=caml_string_of_jsbytes("delayTime"),
     cst_maxDelayTime=caml_string_of_jsbytes("maxDelayTime"),
     cst_normalize$0=caml_string_of_jsbytes("normalize"),
     cst_normalize=caml_string_of_jsbytes("normalize"),
     cst_buffer$2=caml_string_of_jsbytes("buffer"),
     cst_channelCount$5=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$5=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$5=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_buffer$1=caml_string_of_jsbytes("buffer"),
     cst_disableNormalization=caml_string_of_jsbytes("disableNormalization"),
     cst_offset=caml_string_of_jsbytes("offset"),
     cst_channelCount$4=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$4=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$4=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_numberOfOutput=caml_string_of_jsbytes("numberOfOutput"),
     cst_channelCount$3=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$3=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$3=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_numberOfInputs$0=caml_string_of_jsbytes("numberOfInputs"),
     cst_loopEnd$0=caml_string_of_jsbytes("loopEnd"),
     cst_loopEnd=caml_string_of_jsbytes("loopEnd"),
     cst_loopStart$0=caml_string_of_jsbytes("loopStart"),
     cst_loopStart=caml_string_of_jsbytes("loopStart"),
     cst_loop$3=caml_string_of_jsbytes("loop"),
     cst_loop$2=caml_string_of_jsbytes("loop"),
     cst_buffer$0=caml_string_of_jsbytes("buffer"),
     cst_buffer=caml_string_of_jsbytes("buffer"),
     cst_detune$0=caml_string_of_jsbytes("detune"),
     cst_loop$1=caml_string_of_jsbytes("loop"),
     cst_loop_start=caml_string_of_jsbytes("loop_start"),
     cst_loop_end=caml_string_of_jsbytes("loop_end"),
     cst_playbackRate$1=caml_string_of_jsbytes("playbackRate"),
     cst_type$8=caml_string_of_jsbytes("type"),
     cst_type$7=caml_string_of_jsbytes("type"),
     cst_channelCount$2=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$2=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$2=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_type$6=caml_string_of_jsbytes("type"),
     cst_Q=caml_string_of_jsbytes("Q"),
     cst_detune=caml_string_of_jsbytes("detune"),
     cst_frequency=caml_string_of_jsbytes("frequency"),
     cst_gain=caml_string_of_jsbytes("gain"),
     cst_smoothingTimeConstant$1=
      caml_string_of_jsbytes("smoothingTimeConstant"),
     cst_smoothingTimeConstant$0=
      caml_string_of_jsbytes("smoothingTimeConstant"),
     cst_maxDecibels$1=caml_string_of_jsbytes("maxDecibels"),
     cst_maxDecibels$0=caml_string_of_jsbytes("maxDecibels"),
     cst_minDecibels$1=caml_string_of_jsbytes("minDecibels"),
     cst_minDecibels$0=caml_string_of_jsbytes("minDecibels"),
     cst_frequencyBinCount=caml_string_of_jsbytes("frequencyBinCount"),
     cst_fftSize$1=caml_string_of_jsbytes("fftSize"),
     cst_fftSize$0=caml_string_of_jsbytes("fftSize"),
     cst_channelCount$1=caml_string_of_jsbytes("channelCount"),
     cst_channelCountMode$1=caml_string_of_jsbytes("channelCountMode"),
     cst_channelInterpretation$1=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_fftSize=caml_string_of_jsbytes("fftSize"),
     cst_minDecibels=caml_string_of_jsbytes("minDecibels"),
     cst_maxDecibels=caml_string_of_jsbytes("maxDecibels"),
     cst_smoothingTimeConstant=caml_string_of_jsbytes("smoothingTimeConstant"),
     cst_channelInterpretation$0=
      caml_string_of_jsbytes("channelInterpretation"),
     cst_channelInterpretation=caml_string_of_jsbytes("channelInterpretation"),
     cst_channelCountMode$0=caml_string_of_jsbytes("channelCountMode"),
     cst_channelCountMode=caml_string_of_jsbytes("channelCountMode"),
     cst_channelCount$0=caml_string_of_jsbytes("channelCount"),
     cst_channelCount=caml_string_of_jsbytes("channelCount"),
     cst_numberOfOutputs=caml_string_of_jsbytes("numberOfOutputs"),
     cst_numberOfInputs=caml_string_of_jsbytes("numberOfInputs"),
     cst_numberOfChannels=caml_string_of_jsbytes("numberOfChannels"),
     cst_length$6=caml_string_of_jsbytes("length"),
     cst_length$5=caml_string_of_jsbytes("length"),
     cst_sampleRate$0=caml_string_of_jsbytes("sampleRate"),
     cst_sampleRate=caml_string_of_jsbytes("sampleRate"),
     cst_currentTime$1=caml_string_of_jsbytes("currentTime"),
     cst_currentFrame=caml_string_of_jsbytes("currentFrame"),
     cst_maxValue$0=caml_string_of_jsbytes("maxValue"),
     cst_minValue$0=caml_string_of_jsbytes("minValue"),
     cst_defaultValue$0=caml_string_of_jsbytes("defaultValue"),
     cst_automationRate$1=caml_string_of_jsbytes("automationRate"),
     cst_automationRate$0=caml_string_of_jsbytes("automationRate"),
     cst_value$0=caml_string_of_jsbytes("value"),
     cst_value=caml_string_of_jsbytes("value"),
     cst_automationRate=caml_string_of_jsbytes("automationRate"),
     cst_minValue=caml_string_of_jsbytes("minValue"),
     cst_maxValue=caml_string_of_jsbytes("maxValue"),
     cst_defaultValue=caml_string_of_jsbytes("defaultValue"),
     cst_iterations=caml_string_of_jsbytes("iterations"),
     cst_hash$5=caml_string_of_jsbytes("hash"),
     cst_name$20=caml_string_of_jsbytes("name"),
     cst_hash$4=caml_string_of_jsbytes("hash"),
     cst_name$19=caml_string_of_jsbytes("name"),
     cst_length$10=caml_string_of_jsbytes("length"),
     cst_hash$3=caml_string_of_jsbytes("hash"),
     cst_name$18=caml_string_of_jsbytes("name"),
     cst_tagLength=caml_string_of_jsbytes("tagLength"),
     cst_additionalData=caml_string_of_jsbytes("additionalData"),
     cst_name$17=caml_string_of_jsbytes("name"),
     cst_name$16=caml_string_of_jsbytes("name"),
     cst_length$9=caml_string_of_jsbytes("length"),
     cst_name$15=caml_string_of_jsbytes("name"),
     cst_length$8=caml_string_of_jsbytes("length"),
     cst_name$14=caml_string_of_jsbytes("name"),
     cst_name$13=caml_string_of_jsbytes("name"),
     cst_hash$2=caml_string_of_jsbytes("hash"),
     cst_name$12=caml_string_of_jsbytes("name"),
     cst_namedCurve$0=caml_string_of_jsbytes("namedCurve"),
     cst_name$11=caml_string_of_jsbytes("name"),
     cst_namedCurve=caml_string_of_jsbytes("namedCurve"),
     cst_name$10=caml_string_of_jsbytes("name"),
     cst_name$9=caml_string_of_jsbytes("name"),
     cst_saltLength=caml_string_of_jsbytes("saltLength"),
     cst_name$8=caml_string_of_jsbytes("name"),
     cst_hash$1=caml_string_of_jsbytes("hash"),
     cst_name$7=caml_string_of_jsbytes("name"),
     cst_hash$0=caml_string_of_jsbytes("hash"),
     cst_modulusLength=caml_string_of_jsbytes("modulusLength"),
     cst_name$6=caml_string_of_jsbytes("name"),
     cst_name$5=caml_string_of_jsbytes("name"),
     cst_extractable=caml_string_of_jsbytes("extractable"),
     cst_type$12=caml_string_of_jsbytes("type"),
     cst_includeUncontrolled=caml_string_of_jsbytes("includeUncontrolled"),
     cst_type$16=caml_string_of_jsbytes("type"),
     cst_focused=caml_string_of_jsbytes("focused"),
     cst_visibilityState$0=caml_string_of_jsbytes("visibilityState"),
     cst_type$15=caml_string_of_jsbytes("type"),
     cst_id$1=caml_string_of_jsbytes("id"),
     cst_frameType=caml_string_of_jsbytes("frameType"),
     cst_url$3=caml_string_of_jsbytes("url"),
     cst_scope$0=caml_string_of_jsbytes("scope"),
     cst_type$14=caml_string_of_jsbytes("type"),
     cst_updateViaCache$0=caml_string_of_jsbytes("updateViaCache"),
     cst_updateViaCache=caml_string_of_jsbytes("updateViaCache"),
     cst_scope=caml_string_of_jsbytes("scope"),
     cst_headerValue=caml_string_of_jsbytes("headerValue"),
     cst_enabled$1=caml_string_of_jsbytes("enabled"),
     cst_WorkerGlobalScope=caml_string_of_jsbytes("WorkerGlobalScope"),
     cst_type$13=caml_string_of_jsbytes("type"),
     cst_credentials$1=caml_string_of_jsbytes("credentials"),
     cst_name$21=caml_string_of_jsbytes("name"),
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib=global_data.Stdlib,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_callback=global_data.Stdlib__callback,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_result=global_data.Stdlib__result,
     Assert_failure=global_data.Assert_failure,
     Stdlib_option=global_data.Stdlib__option,
     Stdlib_bigarray=global_data.Stdlib__bigarray,
     Stdlib_fun=global_data.Stdlib__fun,
     jv_global=globalThis,
     _e_=[0,caml_string_of_jsbytes("src/fut.ml"),34,25],
     _v_=[0,0],
     _u_=[0,1],
     _r_=[0,1],
     _q_=[0,1],
     _p_=[0,-1],
     _n_=[0,1],
     _o_=[0,1],
     _g_=[0,7],
     _h_=[0,8],
     _i_=[0,0],
     _j_=[0,3],
     _k_=[0,1],
     _l_=[0,5],
     _m_=[0,2],
     _f_=[0,1],
     _bs_=[0,0],
     _br_=[0,0],
     _bp_=[0,[0,4448519,0]],
     _bq_=[0,[0,4448519,0]];
    function length(s){return s.length}
    function arg(opt,i)
     {if(opt)var sth=opt[1],base=sth;else var base=10;return i.toString(base)}
    function get(s,i)
     {if(s.length <= i)
       {var
         len=s.length,
         _ov_=arg(0,len - 1 | 0),
         _ow_=
          caml_string_of_jsstring
           ("index ".concat(arg(0,i)).concat(" not in bounds [0;").concat
              (_ov_).concat
             ("]"));
        return caml_call1(Stdlib[1],_ow_)}
      var u=s.codePointAt(i),switch$0=0;
      if(55296 <= u && ! (57343 < u)){var u$0=65533;switch$0 = 1}
      if(! switch$0)var u$0=u;
      return caml_call1(Stdlib_uchar[9],u$0)}
    function jstr_of_uchar_int(i){return jv_global.String.fromCodePoint(i)}
    function get_jstr(s,i)
     {var _ou_=get(s,i);
      return jstr_of_uchar_int(caml_call1(Stdlib_uchar[10],_ou_))}
    var empty="",sp=" ",nl="\n";
    function symbol(s0,s1){return s0.concat(s1)}
    function concat(sep,ss)
     {if(sep){var sep$0=sep[1];return caml_list_to_js_array(ss).join(sep$0)}
      if(ss)
       {var ss$0=ss[2],s=ss[1];return s.concat(caml_list_to_js_array(ss$0))}
      return empty}
    function pad_start(opt,len,s){return s.padStart(len," ")}
    function pad_end(opt,len,s){return s.padEnd(len," ")}
    function repeat(n,s){return s.repeat(n)}
    function find_sub(opt,sub,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      var i=s.indexOf(sub,start);
      return -1 === i?0:[0,i]}
    function find_last_sub(before,sub,s)
     {if(before)var b=before[1],before$0=b;else var before$0=s.length;
      var pos=before$0 - sub.length | 0;
      if(0 <= pos){var i=s.lastIndexOf(sub,pos);return -1 === i?0:[0,i]}
      return 0}
    function slice(opt,stop,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)
       var stop$0=stop[1],args=[0,start,stop$0];
      else
       var args=[0,start];
      return caml_js_meth_call(s,cst_slice,args)}
    function sub(opt,len,s)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(len)var len$0=len[1],args=[0,start,len$0];else var args=[0,start];
      return caml_js_meth_call(s,cst_substr,args)}
    function cuts(sep,s){return caml_list_of_js_array(s.split(sep))}
    var iterator=Symbol.iterator;
    function fold_uchars(f,s,acc)
     {var it=s[iterator](),acc$0=acc;
      for(;;)
       {var r=it.next();
        if(r.done | 0)return acc$0;
        var u=r.value.codePointAt(0),switch$0=0;
        if(55296 <= u && ! (57343 < u)){var u$0=65533;switch$0 = 1}
        if(! switch$0)var u$0=u;
        var
         acc$1=caml_call2(f,caml_call1(Stdlib_uchar[9],u$0),acc$0),
         acc$0=acc$1;
        continue}}
    function fold_jstr_uchars(f,s,acc)
     {function f$0(u,acc)
       {return caml_call2
                (f,jstr_of_uchar_int(caml_call1(Stdlib_uchar[10],u)),acc)}
      return fold_uchars(f$0,s,acc)}
    function trim(s){return s.trim()}
    function normalized(nf,s)
     {var
       nf$0=
        868484048 <= nf
         ?868484049 <= nf?"NFKD":"NFKC"
         :3894540 <= nf?"NFD":"NFC";
      return s.normalize(nf$0)}
    function lowercased(s){return s.toLowerCase()}
    function uppercased(s){return s.toUpperCase()}
    function is_empty(s){return 0 === s.length?1:0}
    function starts_with(sub,s){return s.startsWith(sub) | 0}
    function includes(sub,s){return s.includes(sub) | 0}
    function ends_with(sub,s){return s.endsWith(sub) | 0}
    var equal=caml_equal,compare=runtime.caml_compare;
    function of_uchar(u)
     {return jstr_of_uchar_int(caml_call1(Stdlib_uchar[10],u))}
    function of_char(c){return jstr_of_uchar_int(c)}
    var number=jv_global.Number;
    function to_int(base,s)
     {if(base)var b=base[1],args=[0,s,b];else var args=[0,s];
      var n=caml_js_meth_call(number,cst_parseInt,args);
      return caml_equal(n,n)?[0,n]:0}
    function to_float(s){return number.parseFloat(s)}
    function of_float(frac,n)
     {if(frac){var frac$0=frac[1];return n.toFixed(frac$0)}
      return n.toString()}
    var
     Jstr=
      [0,
       length,
       get,
       get_jstr,
       empty,
       sp,
       nl,
       symbol,
       symbol,
       concat,
       pad_start,
       pad_end,
       repeat,
       find_sub,
       find_last_sub,
       slice,
       sub,
       cuts,
       fold_uchars,
       fold_jstr_uchars,
       trim,
       normalized,
       lowercased,
       uppercased,
       is_empty,
       starts_with,
       includes,
       ends_with,
       equal,
       compare,
       of_uchar,
       of_char,
       to_int,
       arg,
       to_float,
       of_float];
    caml_register_global(2908,Jstr,"Jstr");
    function strict_equal(_ot_,_os_){return _ot_ === _os_?1:0}
    var null$0=null,fn=undefined;
    function is_null(v){return v === null$0?1:0}
    function is_undefined(v){return v === fn?1:0}
    function is_none(v){var _or_=is_null(v);return _or_?_or_:is_undefined(v)}
    function is_some(v){return 1 - is_none(v)}
    function to_option(conv,v){return is_none(v)?0:[0,caml_call1(conv,v)]}
    function of_option(none,conv,param)
     {if(param){var v=param[1];return caml_call1(conv,v)}return none}
    var target=globalThis;
    function set_if_some(o,p,param)
     {if(param){var v=param[1];return o[p] = v}return 0}
    function find(o,p){var v=o[p];return is_none(v)?0:[0,v]}
    function find_map(f,o,p)
     {var v=o[p];return is_none(v)?0:[0,caml_call1(f,v)]}
    function find_path(o,param)
     {var o$0=o,param$0=param;
      for(;;)
       {if(param$0)
         {var ps=param$0[2],p=param$0[1],match=find(o$0,p);
          if(match){var o$1=match[1],o$0=o$1,param$0=ps;continue}
          return 0}
        return [0,o$0]}}
    var true$0=true,false$0=false;
    function find$0(o,p){var b=o[p];return is_none(b)?0:[0,b | 0]}
    function get$0(o,p){return o[p] | 0}
    function set(o,p,b){return o[p] = ! ! b}
    function set_if_some$0(o,p,param)
     {if(param){var b=param[1];return set(o,p,b)}return 0}
    var Bool=[0,find$0,get$0,set,set_if_some$0];
    function find$1(o,p){var i=o[p];return is_none(i)?0:[0,i]}
    function get$1(o,p){return o[p]}
    function set$0(o,p,i){return o[p] = i}
    function set_if_some$1(o,p,param)
     {if(param){var i=param[1];return o[p] = i}return 0}
    var Int=[0,find$1,get$1,set$0,set_if_some$1];
    function find$2(o,p){var f=o[p];return is_none(f)?0:[0,f]}
    function get$2(o,p){return o[p]}
    function set$1(o,p,b){return o[p] = b}
    function set_if_some$2(o,p,param)
     {if(param){var f=param[1];return o[p] = f}return 0}
    var Float=[0,find$2,get$2,set$1,set_if_some$2];
    function find$3(o,p){var s=o[p];return is_none(s)?0:[0,s]}
    function get$3(o,p){return o[p]}
    function set$2(o,p,b){return o[p] = b}
    function set_if_some$3(o,p,param)
     {if(param){var f=param[1];return o[p] = f}return 0}
    function create(n){return new (target.Array)(n)}
    function length$0(a){return a.length}
    var Jarray=[0,create,length$0];
    function to_array(conv,v)
     {var len=caml_call1(Jarray[2],v);
      function _oq_(i){return caml_call1(conv,v[i])}
      return caml_call2(Stdlib_array[2],len,_oq_)}
    function of_array(conv,a)
     {var
       len=a.length - 1,
       ja=caml_call1(Jarray[1],len),
       _oo_=len - 1 | 0,
       _on_=0;
      if(! (_oo_ < 0))
       {var i=_on_;
        for(;;)
         {ja[i] = caml_call1(conv,runtime.caml_check_bound(a,i)[1 + i]);
          var _op_=i + 1 | 0;
          if(_oo_ !== i){var i=_op_;continue}
          break}}
      return ja}
    function to_list(conv,v)
     {var len=caml_call1(Jarray[2],v);
      function _om_(i){return caml_call1(conv,v[i])}
      return caml_call2(Stdlib_list[10],len,_om_)}
    function of_list(conv,l)
     {var ja=caml_call1(Jarray[1],0),i=0,param=l;
      for(;;)
       {if(param)
         {var vs=param[2],v=param[1];
          ja[i] = caml_call1(conv,v);
          var i$0=i + 1 | 0,i=i$0,param=vs;
          continue}
        return ja}}
    function v(name,msg)
     {var e=new (target.Error)(msg);
      if(name){var n=name[1];e.name = n;return e}
      return e}
    function name(e){return e.name}
    function enum$0(e)
     {var
       match=caml_string_of_jsstring(e.name),
       switch$0=caml_string_compare(match,cst_NotAllowedError);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return 971339429;
        var switch$1=caml_string_compare(match,cst_SyntaxError);
        if(0 <= switch$1)
         {if(! (0 < switch$1))return 148000204;
          if(! caml_string_notequal(match,cst_TimeoutError))return -129520566;
          if(! caml_string_notequal(match,cst_TransactionInactiveError))
           return -28376747;
          if(! caml_string_notequal(match,cst_TypeMismatchError))
           return -823442212;
          if(! caml_string_notequal(match,cst_URLMismatchError))
           return 147573767;
          if(! caml_string_notequal(match,cst_UnknownError))
           return -1064646157;
          if(! caml_string_notequal(match,cst_VersionError))
           return -1025659903;
          if(! caml_string_notequal(match,cst_WrongDocumentError))
           return -937074026}
        else
         {if(! caml_string_notequal(match,cst_NotFoundError))return 829592127;
          if(! caml_string_notequal(match,cst_NotReadableError))
           return -119831547;
          if(! caml_string_notequal(match,cst_NotSupportedError))
           return -935732949;
          if(! caml_string_notequal(match,cst_OperationError))
           return 115193424;
          if(! caml_string_notequal(match,cst_QuotaExceededError))
           return 246360739;
          if(! caml_string_notequal(match,cst_ReadOnlyError))return 842968798;
          if(! caml_string_notequal(match,cst_SecurityError))return 496062953}}
      else
       {var switch$2=caml_string_compare(match,cst_InvalidAccessError);
        if(0 <= switch$2)
         {if(! (0 < switch$2))return 753062229;
          if(! caml_string_notequal(match,cst_InvalidCharacterError))
           return 197539530;
          if(! caml_string_notequal(match,cst_InvalidModificationError))
           return 943132429;
          if(! caml_string_notequal(match,cst_InvalidNodeTypeError))
           return -94613768;
          if(! caml_string_notequal(match,cst_InvalidStateError))
           return 986514226;
          if(! caml_string_notequal(match,cst_NamespaceError))
           return 861236164;
          if(! caml_string_notequal(match,cst_NetworkError))return 943709719;
          if(! caml_string_notequal(match,cst_NoModificationAllowedError))
           return 320841004}
        else
         {if(! caml_string_notequal(match,cst_AbortError))return 183065241;
          if(! caml_string_notequal(match,cst_ConstraintError))
           return 539235142;
          if(! caml_string_notequal(match,cst_DataCloneError))
           return 1031143793;
          if(! caml_string_notequal(match,cst_DataError))return 483354835;
          if(! caml_string_notequal(match,cst_EncodingError))return 518067260;
          if(! caml_string_notequal(match,cst_HierarchyRequestError))
           return 227342318;
          if(! caml_string_notequal(match,cst_IndexSizeError))return 89185783}}
      return -912009552}
    function message(e){return e.message}
    function stack(e){return e.stack}
    function throw$0(name,msg)
     {var e=v(name,msg);return caml_call1(function(exn){throw exn},e)}
    var Error=[248,cst_Jv_Error,runtime.caml_fresh_oo_id(0)];
    function register_error_exception(param)
     {return caml_call2(Stdlib_callback[2],cst_jsError,[0,Error,{}])}
    register_error_exception(0);
    var symbol$0=Symbol.iterator;
    function iterable(o)
     {var _ok_=o[symbol$0],match=to_option(function(_ol_){return _ol_},_ok_);
      if(match){var func=match[1];return func()}
      return 0}
    function iterator$0(o){return o[symbol$0]()}
    function next(it){return it.next()}
    function result_done(o)
     {var match=to_option(caml_js_to_bool,o.done);
      if(match){var d=match[1];return d}
      return 0}
    function result_value(o)
     {var _oi_=o.value;return to_option(function(_oj_){return _oj_},_oi_)}
    function get_result_value(o){return o.value}
    function fold(of_jv,f,it,acc)
     {var acc$0=acc;
      for(;;)
       {var r=it.next();
        if(result_done(r))return acc$0;
        var acc$1=caml_call2(f,caml_call1(of_jv,r.value),acc$0),acc$0=acc$1;
        continue}}
    function fold_bindings(key,value,f,it,acc)
     {var acc$0=acc;
      for(;;)
       {var r=it.next();
        if(result_done(r))return acc$0;
        var
         arr=r.value,
         _oh_=caml_call1(value,arr[1]),
         acc$1=caml_call3(f,caml_call1(key,arr[0]),_oh_,acc$0),
         acc$0=acc$1;
        continue}}
    var promise=target.Promise;
    function create$0(f){return new promise(f)}
    function resolve(v){return promise.resolve(v)}
    function reject(v){return promise.reject(v)}
    function await$0(p,k){p.then(k);return 0}
    function bind(p,res){return p.then(res)}
    function then(p,res,rej){return p.then(res,rej)}
    function all(arr){return promise.all(arr)}
    function find$4(o,p){var v=o[p];return is_none(v)?0:[0,v]}
    function find_map$0(f,o,p)
     {var v=o[p];return is_none(v)?0:[0,caml_call1(f,v)]}
    function obj(props)
     {function _og_(param)
       {var v=param[2],p=param[1];return [0,caml_string_of_jsstring(p),v]}
      return runtime.caml_js_object(caml_call2(Stdlib_array[15],_og_,props))}
    function call(o,m,args)
     {return caml_js_meth_call(o,caml_string_of_jsstring(m),args)}
    function has(p,v){return is_some(v[p])}
    function defined(v){return is_some(v)}
    var
     Id=[0],
     _a_=[0,create$0,resolve,reject,await$0,bind,then,all],
     _b_=
      [0,
       result_done,
       result_value,
       get_result_value,
       iterable,
       iterator$0,
       next,
       fold,
       fold_bindings],
     _c_=[0,v,name,enum$0,message,stack],
     _d_=[0,find$3,get$3,set$2,set_if_some$3],
     Jv=
      [0,
       strict_equal,
       runtime.caml_js_typeof,
       caml_js_instanceof,
       null$0,
       fn,
       is_null,
       is_undefined,
       is_none,
       is_some,
       to_option,
       of_option,
       target,
       find,
       find_map,
       find_path,
       set_if_some,
       true$0,
       false$0,
       Bool,
       Int,
       Float,
       _d_,
       caml_jsstring_of_string,
       caml_string_of_jsstring,
       to_array,
       of_array,
       to_list,
       of_list,
       Jarray,
       _c_,
       Error,
       throw$0,
       register_error_exception,
       _b_,
       _a_,
       find$4,
       find_map$0,
       obj,
       call,
       has,
       defined,
       Id];
    caml_register_global(2912,Jv,"Jv");
    function promise$0(f){return f.fut}
    function create$1(param)
     {function not_set(param){throw [0,Assert_failure,_e_]}
      function is_set(param){return throw$0(0,"The future is already set")}
      var setter=[0,not_set];
      function set_setter(resolve,reject){setter[1] = resolve;return 0}
      var p=caml_call1(_a_[1],set_setter);
      function set(v){caml_call1(setter[1],v);setter[1] = is_set;return 0}
      return [0,{"fut":p},set]}
    function await$1(f,k){return caml_call2(_a_[4],f.fut,k)}
    function return$0(v){return {"fut":caml_call1(_a_[2],v)}}
    function bind$0(f,fn)
     {function _of_(v){return caml_call1(fn,v).fut}
      return {"fut":caml_call2(_a_[5],f.fut,_of_)}}
    function map(fn,f)
     {return bind$0(f,function(v){return return$0(caml_call1(fn,v))})}
    function pair(f0,f1)
     {function _od_(v0)
       {function _oe_(v1){return caml_call1(_a_[2],[0,v0,v1])}
        return caml_call2(_a_[5],f1.fut,_oe_)}
      return {"fut":caml_call2(_a_[5],f0.fut,_od_)}}
    function of_list$0(fs)
     {var arr=of_list(promise$0,fs),all=caml_call1(_a_[7],arr);
      function to_list$0(l)
       {var _ob_=to_list(function(_oc_){return _oc_},l);
        return caml_call1(_a_[2],_ob_)}
      return {"fut":caml_call2(_a_[5],all,to_list$0)}}
    function tick(ms)
     {function _oa_(res,rej){target.setTimeout(res,ms);return 0}
      return {"fut":caml_call1(_a_[1],_oa_)}}
    function ok(v){return return$0([0,v])}
    function error(e){return return$0([1,e])}
    function of_promise(ok,error,p)
     {function ok$0(v)
       {var _n$_=[0,caml_call1(ok,v)];return caml_call1(_a_[2],_n$_)}
      function error$0(e)
       {var _n__=[1,caml_call1(error,e)];return caml_call1(_a_[2],_n__)}
      return {"fut":caml_call3(_a_[6],p,ok$0,error$0)}}
    function to_promise(ok,error,f)
     {function _n9_(res,rej)
       {return await$1
                (f,
                 function(param)
                  {if(0 === param[0])
                    {var v=param[1];return caml_call1(res,caml_call1(ok,v))}
                   var e=param[1];
                   return caml_call1(rej,caml_call1(error,e))})}
      return caml_call1(_a_[1],_n9_)}
    function of_promise$0(ok,v)
     {return of_promise(ok,function(_n8_){return _n8_},v)}
    function to_promise$0(ok,v)
     {return to_promise(ok,function(_n7_){return _n7_},v)}
    function let$0(f,fn){return map(fn,f)}
    var Syntax=[0,bind$0,pair,let$0,pair];
    function result_pair(r0,r1)
     {if(0 === r0[0])
       {var _n6_=r0[1];
        if(0 === r1[0]){var v1=r1[1];return [0,[0,_n6_,v1]]}
        var r=r1}
      else
       var r=r0;
      return r}
    function let$1(f,fn)
     {return bind$0
              (f,
               function(e)
                {if(0 === e[0]){var v=e[1];return caml_call1(fn,v)}
                 return return$0(e)})}
    function and(f0,f1){return map(result_pair,pair(f0,f1))}
    function let$2(f,fn){return map(caml_call1(Stdlib_result[8],fn),f)}
    var
     Fut=
      [0,
       create$1,
       await$1,
       return$0,
       map,
       bind$0,
       pair,
       of_list$0,
       tick,
       ok,
       error,
       of_promise$0,
       to_promise$0,
       of_promise,
       to_promise,
       Syntax,
       [0,let$1,and,let$2,and]];
    caml_register_global(2915,Fut,"Fut");
    var Type=[0];
    function init(bubbles,cancelable,composed,param)
     {var o={};
      caml_call3(Bool[4],o,cst_bubbles,bubbles);
      caml_call3(Bool[4],o,cst_cancelable,cancelable);
      caml_call3(Bool[4],o,cst_composed,composed);
      return o}
    var event=target.Event;
    function create$2(opt,t)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new event(t,init)}
    function type(e){return caml_call2(_d_[2],e,cst_type)}
    function target$0(e){return e.target}
    function current_target(e){return e.currentTarget}
    function composed_path(e)
     {var _n4_=e.composedPath();
      return to_list(function(_n5_){return _n5_},_n4_)}
    function event_phase(e)
     {var match=caml_call2(Int[2],e,cst_eventPhase),switcher=match - 1 | 0;
      if(2 < switcher >>> 0)return 870530776;
      switch(switcher)
       {case 0:return 497141539;
        case 1:return -276077507;
        default:return 608305129}}
    function bubbles(e){return caml_call2(Bool[2],e,cst_bubbles$0)}
    function stop_propagation(e){e.stopPropagation();return 0}
    function stop_immediate_propagation(e)
     {e.stopImmediatePropagation();return 0}
    function cancelable(e){return caml_call2(Bool[2],e,cst_cancelable$0)}
    function prevent_default(e){e.preventDefault();return 0}
    function default_prevented(e)
     {return caml_call2(Bool[2],e,cst_defaultPrevented)}
    function composed(e){return caml_call2(Bool[2],e,cst_composed$0)}
    function is_trusted(e){return caml_call2(Bool[2],e,cst_isTrusted)}
    function timestamp_ms(e){return caml_call2(Float[2],e,cst_timeStamp)}
    function dispatch(e,t){return t.dispatchEvent(e) | 0}
    function listen_opts(capture,once,passive,param)
     {var o={};
      caml_call3(Bool[4],o,cst_capture,capture);
      caml_call3(Bool[4],o,cst_once,once);
      caml_call3(Bool[4],o,cst_passive,passive);
      return o}
    function listen(opt,type,f,t)
     {if(opt)var sth=opt[1],opts=sth;else var opts={};
      t.addEventListener(type,f,opts);
      return 0}
    function unlisten(opt,type,f,t)
     {if(opt)var sth=opt[1],opts=sth;else var opts={};
      t.removeEventListener(type,f,opts);
      return 0}
    function next$0(capture,type,t)
     {var
       match=create$1(0),
       set=match[2],
       fut=match[1],
       opts=listen_opts(capture,_f_,0,0);
      listen([0,opts],type,set,t);
      return fut}
    var
     none="none",
     copy="copy",
     copy_link="copyLink",
     copy_move="copyMove",
     link="link",
     link_move="linkMove",
     move="move",
     all$0="all",
     uninitialized="uninitialized",
     Effect=
      [0,
       none,
       copy,
       copy_link,
       copy_move,
       link,
       link_move,
       move,
       all$0,
       uninitialized],
     file="file",
     string="string",
     Kind=[0,file,string];
    function kind(i){return caml_call2(_d_[2],i,cst_kind)}
    function type$0(i){return caml_call2(_d_[2],i,cst_type$0)}
    function get_file(i)
     {var _n2_=i.getAsFile();
      return to_option(function(_n3_){return _n3_},_n2_)}
    function get_jstr$0(i)
     {var match=create$1(0),set_str=match[2],str=match[1];
      i.getAsString(set_str);
      return str}
    var Item=[0,Kind,kind,type$0,get_file,get_jstr$0];
    function length$1(l){return caml_call2(Int[2],l,cst_length)}
    function add_jstr(l,type,str)
     {var _n0_=l.add(str,type);
      return to_option(function(_n1_){return _n1_},_n0_)}
    function add_file(t,file)
     {var _nY_=t.add(file);return to_option(function(_nZ_){return _nZ_},_nY_)}
    function remove(l,i){l.remove(i);return 0}
    function clear(l){l.clear();return 0}
    function items(l)
     {var acc=[0,0],_nW_=length$1(l) - 1 | 0;
      if(! (_nW_ < 0))
       {var i=_nW_;
        for(;;)
         {acc[1] = [0,l[i],acc[1]];
          var _nX_=i - 1 | 0;
          if(0 !== i){var i=_nX_;continue}
          break}}
      return acc[1]}
    function drop_effect(d){return caml_call2(_d_[2],d,cst_dropEffect)}
    function set_drop_effect(d,e)
     {return caml_call3(_d_[3],d,cst_dropEffect$0,e)}
    function effect_allowed(d){return caml_call2(_d_[2],d,cst_effectAllowed)}
    function set_effect_allowed(d,e)
     {return caml_call3(_d_[3],d,cst_effectAllowed$0,e)}
    function items$0(d){return d.items}
    function data(c)
     {return find_map(function(_nV_){return _nV_},c,cst_clipboardData)}
    var Clipboard=[0,data];
    function data$0(i){return caml_call2(_d_[2],i,cst_data)}
    var Composition=[0,data$0];
    function message$0(e){return caml_call2(_d_[2],e,cst_message)}
    function filename(e){return caml_call2(_d_[2],e,cst_filename)}
    function lineno(e){return caml_call2(Int[2],e,cst_lineno)}
    function colno(e){return caml_call2(Int[2],e,cst_colno)}
    function error$0(e){return e.error}
    var Error$0=[0,message$0,filename,lineno,colno,error$0];
    function wait_until(e,fut)
     {e.waitUntil(to_promise$0(function(_nU_){return _nU_},fut));return 0}
    var Extendable=[0,wait_until];
    function related_target(m)
     {return find_map(function(_nT_){return _nT_},m,cst_relatedTarget)}
    var Focus=[0,related_target];
    function old_url(e){return caml_call2(_d_[2],e,cst_oldURL)}
    function new_url(e){return caml_call2(_d_[2],e,cst_newURL)}
    var Hash_change=[0,old_url,new_url];
    function data$1(i){return caml_call2(_d_[2],i,cst_data$0)}
    function data_transfer(i){return find(i,cst_dataTransfer)}
    function input_type(i){return caml_call2(_d_[2],i,cst_inputType)}
    function is_composing(i){return caml_call2(Bool[2],i,cst_isComposing)}
    var
     Input=[0,data$1,data_transfer,input_type,is_composing],
     Location=[0,0,1,2,3];
    function key(k){return caml_call2(_d_[2],k,cst_key)}
    function code(k){return caml_call2(_d_[2],k,cst_code)}
    function location(k){return caml_call2(Int[2],k,cst_location)}
    function repeat$0(k){return caml_call2(Bool[2],k,cst_repeat)}
    function is_composing$0(k){return caml_call2(Bool[2],k,cst_isComposing$0)}
    function alt_key(k){return caml_call2(Bool[2],k,cst_altKey)}
    function ctrl_key(k){return caml_call2(Bool[2],k,cst_ctrlKey)}
    function shift_key(k){return caml_call2(Bool[2],k,cst_shiftKey)}
    function meta_key(k){return caml_call2(Bool[2],k,cst_metaKey)}
    function get_modifier_state(k,key){return k.getModifierState(key) | 0}
    var
     Keyboard=
      [0,
       Location,
       key,
       code,
       location,
       repeat$0,
       is_composing$0,
       alt_key,
       ctrl_key,
       shift_key,
       meta_key,
       get_modifier_state];
    function related_target$0(m)
     {return find_map(function(_nS_){return _nS_},m,cst_relatedTarget$0)}
    function offset_x(m){return caml_call2(Float[2],m,cst_offsetX)}
    function offset_y(m){return caml_call2(Float[2],m,cst_offsetY)}
    function client_x(m){return caml_call2(Float[2],m,cst_clientX)}
    function client_y(m){return caml_call2(Float[2],m,cst_clientY)}
    function page_x(m){return caml_call2(Float[2],m,cst_pageX)}
    function page_y(m){return caml_call2(Float[2],m,cst_pageY)}
    function screen_x(m){return caml_call2(Float[2],m,cst_screenX)}
    function screen_y(m){return caml_call2(Float[2],m,cst_screenY)}
    function movement_x(m){return caml_call2(Float[2],m,cst_movementX)}
    function movement_y(m){return caml_call2(Float[2],m,cst_movementY)}
    function button(m){return caml_call2(Int[2],m,cst_button)}
    function buttons(m){return caml_call2(Int[2],m,cst_buttons)}
    function alt_key$0(m){return caml_call2(Bool[2],m,cst_altKey$0)}
    function ctrl_key$0(m){return caml_call2(Bool[2],m,cst_ctrlKey$0)}
    function shift_key$0(m){return caml_call2(Bool[2],m,cst_shiftKey$0)}
    function meta_key$0(m){return caml_call2(Bool[2],m,cst_metaKey$0)}
    function get_modifier_state$0(m,key){return m.getModifierState(key) | 0}
    var
     Mouse=
      [0,
       related_target$0,
       offset_x,
       offset_y,
       client_x,
       client_y,
       page_x,
       page_y,
       screen_x,
       screen_y,
       movement_x,
       movement_y,
       button,
       buttons,
       alt_key$0,
       ctrl_key$0,
       shift_key$0,
       meta_key$0,
       get_modifier_state$0];
    function data_transfer$0(d)
     {return find_map(function(_nR_){return _nR_},d,cst_dataTransfer$0)}
    var Drag=[0,data_transfer$0];
    function id(p){return caml_call2(Int[2],p,cst_pointerId)}
    function width(p){return caml_call2(Float[2],p,cst_width)}
    function height(p){return caml_call2(Float[2],p,cst_height)}
    function pressure(p){return caml_call2(Float[2],p,cst_pressure)}
    function tangential_pressure(p)
     {return caml_call2(Float[2],p,cst_tangentialPressure)}
    function tilt_x(p){return caml_call2(Int[2],p,cst_tiltX)}
    function tilt_y(p){return caml_call2(Int[2],p,cst_tiltY)}
    function twist(p){return caml_call2(Int[2],p,cst_twist)}
    function altitude_angle(p)
     {return caml_call2(Float[2],p,cst_altitudeAngle)}
    function azimuth_angle(p){return caml_call2(Float[2],p,cst_azimuthAngle)}
    function type$1(p){return caml_call2(_d_[2],p,cst_pointerType)}
    function is_primary(p){return caml_call2(Bool[2],p,cst_isPrimary)}
    function get_coalesced_events(p)
     {var _nP_=p.getCoalescedEvents();
      return to_list(function(_nQ_){return _nQ_},_nP_)}
    function get_predicted_events(p)
     {var _nN_=p.getPredictedEvents();
      return to_list(function(_nO_){return _nO_},_nN_)}
    var
     Pointer=
      [0,
       id,
       width,
       height,
       pressure,
       tangential_pressure,
       tilt_x,
       tilt_y,
       twist,
       altitude_angle,
       azimuth_angle,
       type$1,
       is_primary,
       get_coalesced_events,
       get_predicted_events],
     Delta_mode=[0,0,1,2];
    function delta_x(w){return caml_call2(Float[2],w,cst_deltaX)}
    function delta_y(w){return caml_call2(Float[2],w,cst_deltaY)}
    function delta_z(w){return caml_call2(Float[2],w,cst_deltaZ)}
    function delta_mode(w){return caml_call2(Int[2],w,cst_deltaMode)}
    var
     Wheel=[0,Delta_mode,delta_x,delta_y,delta_z,delta_mode],
     abort="abort",
     activate="activate",
     auxclick="dblclick",
     beforeinput="beforeinput",
     blur="blur",
     canplay="canplay",
     canplaythrough="canplaythrough",
     change="change",
     click="click",
     clipboardchange="clipboardchange",
     close="close",
     compositionend="compositionend",
     compositionstart="compositionstart",
     compositionudpate="compositionupdate",
     controllerchange="controllerchange",
     copy$0="copy",
     cut="cut",
     dblclick="dblclick",
     dom_content_loaded="DOMContentLoaded",
     drag="drag",
     dragend="dragend",
     dragenter="dragenter",
     dragexit="dragexit",
     dragleave="dragleave",
     dragover="dragover",
     dragstart="dragstart",
     drop="drop",
     durationchange="durationchange",
     emptied="emptied",
     ended="ended",
     error$1="error",
     focus="focus",
     focusin="focusin",
     focusout="focusout",
     fullscreenchange="fullscreenchange",
     fullscreenerror="fullscreenerror",
     gotpointercapture="gotpointercapture",
     hashchange="hashchange",
     input="input",
     install="install",
     keydown="keydown",
     keyup="keyup",
     languagechange="languagechange",
     load="load",
     loadeddata="loadeddata",
     loadedmetadata="loadedmetadata",
     loadstart="loadstart",
     lostpointercapture="lostpointercapture",
     mousedown="mousedown",
     mouseenter="mouseenter",
     mouseleave="mouseleave",
     mousemove="mousemove",
     mouseout="mouseout",
     mouseover="mouseover",
     mouseup="mouseup",
     open="open",
     paste="paste",
     pause="pause",
     play="play",
     playing="playing",
     pointercancel="pointercancel",
     pointerdown="pointerdown",
     pointerenter="pointerenter",
     pointerleave="pointerleave",
     pointerlockchange="pointerlockchange",
     pointerlockerror="pointerlockerror",
     pointermove="pointermove",
     pointerout="pointerout",
     pointerover="pointerover",
     pointerrawupdate="pointerrawupdate",
     pointerup="pointerup",
     progress="progress",
     ratechange="ratechange",
     reset="reset",
     resize="resize",
     scroll="scroll",
     seeked="seeked",
     seeking="seeking",
     select="select",
     stalled="stalled",
     statechange="statechange",
     suspend="suspend",
     timeupdate="timeupdate",
     unload="unload",
     updatefound="updatefound",
     visibilitychange="visibilitychange",
     volumechange="volumechange",
     waiting="waiting",
     wheel="wheel",
     array_buffer=target.ArrayBuffer;
    function create$3(n){return new array_buffer(n)}
    function byte_length(a){return caml_call2(Int[2],a,cst_byteLength)}
    function slice$0(opt,stop,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)var stop$0=stop[1],stop$1=stop$0;else var stop$1=byte_length(a);
      return a.slice(start,stop$1)}
    function buffer(o){return o.buffer}
    function byte_offset(o){return caml_call2(Int[2],o,cst_byteOffset)}
    function byte_length$0(o){return caml_call2(Int[2],o,cst_byteLength$0)}
    var dataview=target.DataView;
    function of_buffer(opt,byte_length$0,b)
     {if(opt)var sth=opt[1],byte_offset=sth;else var byte_offset=0;
      if(byte_length$0)
       var l=byte_length$0[1],byte_length$1=l;
      else
       var byte_length$1=byte_length(b);
      return new dataview(b,byte_offset,byte_length$1)}
    function get_int8(b,i){return b.getInt8(i)}
    function get_int16_be(b,i){return b.getInt16(i)}
    function get_int16_le(b,i){return b.getInt16(i,true$0)}
    function get_int32_be(b,i){return b.getInt32(i)}
    function get_int32_le(b,i){return b.getInt32(i,true$0)}
    function get_uint8(b,i){return b.getUint8(i)}
    function get_uint16_be(b,i){return b.getUint16(i)}
    function get_uint16_le(b,i){return b.getUint16(i,true$0)}
    function get_uint32_be(b,i){return b.getUint32(i)}
    function get_uint32_le(b,i){return b.getUint32(i,true$0)}
    function get_float32_be(b,i){return b.getFloat32(i)}
    function get_float32_le(b,i){return b.getFloat32(i,true$0)}
    function get_float64_be(b,i){return b.getFloat64(i)}
    function get_float64_le(b,i){return b.getFloat64(i,true$0)}
    function set_int8(b,i,v){b.setInt8(i,v);return 0}
    function set_int16_be(b,i,v){b.setInt16(i,v);return 0}
    function set_int16_le(b,i,v){b.setInt16(i,v,true$0);return 0}
    function set_int32_be(b,i,v){b.setInt32(i,v);return 0}
    function set_int32_le(b,i,v){b.setInt32(i,v,true$0);return 0}
    function set_uint8(b,i,v){b.setUint8(i,v);return 0}
    function set_uint16_be(b,i,v){b.setUint16(i,v);return 0}
    function set_uint16_le(b,i,v){b.setUint16(i,v,true$0);return 0}
    function set_uint32_be(b,i,v){b.setUint32(i,v);return 0}
    function set_uint32_le(b,i,v){b.setUint32(i,v,true$0);return 0}
    function set_float32_be(b,i,v){b.setFloat32(i,v);return 0}
    function set_float32_le(b,i,v){b.setFloat32(i,v,true$0);return 0}
    function set_float64_be(b,i,v){b.setFloat64(i,v);return 0}
    function set_float64_le(b,i,v){b.setFloat64(i,v,true$0);return 0}
    function type_size_in_bytes(param)
     {switch(param)
       {case 8:return 8;
        case 1:
        case 5:return 2;
        case 0:
        case 3:
        case 4:return 1;
        default:return 4}}
    function cons_of_type(param)
     {switch(param)
       {case 0:return target.Int8Array;
        case 1:return target.Int16Array;
        case 2:return target.Int32Array;
        case 3:return target.Uint8Array;
        case 4:return target.Uint8ClampedArray;
        case 5:return target.Uint16Array;
        case 6:return target.Uint32Array;
        case 7:return target.Float32Array;
        default:return target.Float64Array}}
    function create$4(t,n){return new (cons_of_type(t))(n)}
    function of_buffer$0(t,opt,length,b)
     {if(opt)var sth=opt[1],byte_offset=sth;else var byte_offset=0;
      if(length)
       var l=length[1],args=[0,b,byte_offset,l];
      else
       var args=[0,b,byte_offset];
      return caml_js_new(cons_of_type(t),args)}
    function length$2(a){return caml_call2(Int[2],a,cst_length$0)}
    function type$2(a)
     {var
       s=
        caml_string_of_jsstring(caml_call2(_d_[2],a.constructor,cst_name));
      if(caml_string_notequal(s,cst_Float32Array))
       {if(caml_string_notequal(s,cst_Float64Array))
         {if(caml_string_notequal(s,cst_Int16Array))
           {if(caml_string_notequal(s,cst_Int32Array))
             {if(caml_string_notequal(s,cst_Int8Array))
               {if(caml_string_notequal(s,cst_Uint16Array))
                 {if(caml_string_notequal(s,cst_Uint32Array))
                   {if(caml_string_notequal(s,cst_Uint8Array))
                     {if(caml_string_notequal(s,cst_Uint8ClampedArray))
                       {var t=caml_jsstring_of_string(s);
                        return throw$0(0,"Unknown typed array: ".concat(t))}
                      return 4}
                    return 3}
                  return 6}
                return 5}
              return 0}
            return 2}
          return 1}
        return 8}
      return 7}
    function set_tarray(a,dst,b){a.set(b,dst);return 0}
    function fill(opt,stop,v,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)var stop$0=stop[1],stop$1=stop$0;else var stop$1=length$2(a);
      a.fill(v,start,stop$1);
      return 0}
    function copy_within(opt,stop,dst,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)var stop$0=stop[1],stop$1=stop$0;else var stop$1=length$2(a);
      a.copyWithin(dst,start,stop$1);
      return 0}
    function slice$1(opt,stop,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)
       var stop$0=stop[1],stop$1=stop$0;
      else
       var stop$1=byte_length$0(a);
      return a.slice(start,stop$1)}
    function sub$0(opt,stop,a)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(stop)
       var stop$0=stop[1],stop$1=stop$0;
      else
       var stop$1=byte_length$0(a);
      return a.subArray(start,stop$1)}
    function find$5(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      var _nL_=a.find(sat$0);
      return to_option(function(_nM_){return _nM_},_nL_)}
    function find_index(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      var i=a.findIndex(sat$0);
      return -1 === i?0:[0,i]}
    function for_all(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      return a.every(sat$0) | 0}
    function exists(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      return a.every(sat$0) | 0}
    function filter(sat,a)
     {function sat$0(v,i){return ! ! caml_call2(sat,i,v)}
      return a.filter(sat$0)}
    function iter(f,a)
     {function f$0(v,i){return caml_call2(f,i,v)}a.forEach(f$0);return 0}
    function map$0(f,a){return a.map(f)}
    function fold_left(f,acc,a){return a.reduce(f,acc)}
    function fold_right(f,a,acc)
     {function f$0(acc,v){return caml_call2(f,v,acc)}
      return a.reduceRight(f$0,acc)}
    function reverse(a){return a.reverse()}
    function of_tarray(t,a){return new (cons_of_type(t))(a)}
    function of_int_array(t,a)
     {var _nJ_=of_array(function(_nK_){return _nK_},a);
      return new (cons_of_type(t))(_nJ_)}
    function of_float_array(t,a)
     {var _nH_=of_array(function(_nI_){return _nI_},a);
      return new (cons_of_type(t))(_nH_)}
    function to_int_jstr(opt,b)
     {if(opt)var sth=opt[1],sep=sth;else var sep=sp;return b.join(sep)}
    function to_hex_jstr(opt,a)
     {if(opt)var sth=opt[1],sep=sth;else var sep=empty;
      var
       hex="0123456789abcdef",
       d=of_buffer(0,0,a.buffer),
       s=[0,empty],
       _nD_=byte_length$0(d) - 1 | 0,
       _nC_=0;
      if(! (_nD_ < 0))
       {var i=_nC_;
        for(;;)
         {var
           b=d.getUint8(i),
           sep$0=0 === i?empty:sep,
           _nE_=get_jstr(hex,b & 15),
           _nF_=get_jstr(hex,b >>> 4 | 0);
          s[1] = s[1].concat(sep$0).concat(_nF_).concat(_nE_);
          var _nG_=i + 1 | 0;
          if(_nD_ !== i){var i=_nG_;continue}
          break}}
      return s[1]}
    function uint8_of_buffer(b){return of_buffer$0(3,0,0,b)}
    function of_jstr(s)
     {var enc=new (target.TextEncoder)();return enc.encode(s)}
    function to_jstr(a)
     {var dec=new (target.TextDecoder)("utf-8",{"fatal":true$0});
      try
       {var s=dec.decode(a)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,s]}
    function type_to_bigarray_kind(param)
     {switch(param)
       {case 0:return Stdlib_bigarray[5];
        case 1:return Stdlib_bigarray[7];
        case 2:return Stdlib_bigarray[10];
        case 3:return Stdlib_bigarray[6];
        case 4:return Stdlib_bigarray[6];
        case 5:return Stdlib_bigarray[8];
        case 6:return Stdlib_bigarray[10];
        case 7:return Stdlib_bigarray[1];
        default:return Stdlib_bigarray[2]}}
    function type_of_bigarray_kind(param)
     {switch(param)
       {case 0:return _g_;
        case 1:return _h_;
        case 2:return _i_;
        case 3:return _j_;
        case 4:return _k_;
        case 5:return _l_;
        case 6:return _m_;
        default:return 0}}
    var
     transparent="transparent",
     native$0="native",
     Ending_type=[0,transparent,native$0];
    function init$0(type,endings,param)
     {var o={};
      caml_call3(_d_[4],o,cst_type$1,type);
      caml_call3(_d_[4],o,cst_endings,endings);
      return o}
    var blob=target.Blob;
    function of_jstr$0(opt,s)
     {if(opt)var sth=opt[1],init=sth;else var init=fn;return new blob(s,init)}
    function of_array_buffer(opt,b)
     {if(opt)var sth=opt[1],init=sth;else var init=fn;return new blob(b,init)}
    function byte_length$1(b){return caml_call2(Int[2],b,cst_size)}
    function type$3(b){return caml_call2(_d_[2],b,cst_type$2)}
    function slice$2(opt,stop,_nB_,b)
     {if(opt)var sth=opt[1],start=sth;else var start=0;
      if(_nB_)var sth$0=_nB_[1],type=sth$0;else var type=empty;
      if(stop)
       var stop$0=stop[1],stop$1=stop$0;
      else
       var stop$1=byte_length$1(b);
      return b.slice(start,stop$1,type)}
    function array_buffer$0(b)
     {var _nz_=b.arrayBuffer();
      return of_promise$0(function(_nA_){return _nA_},_nz_)}
    function stream(b){return b.stream}
    function text(b)
     {var _nx_=b.text();return of_promise$0(function(_ny_){return _ny_},_nx_)}
    function data_uri(b)
     {var
       reader=new (target.FileReader)(),
       match=create$1(0),
       set_fut=match[2],
       fut=match[1];
      function ok(e)
       {return caml_call1(set_fut,[0,caml_call2(_d_[2],reader,cst_result)])}
      function error(e){return caml_call1(set_fut,[1,reader.error])}
      listen([0,listen_opts(0,_n_,0,0)],load,ok,reader);
      listen([0,listen_opts(0,_o_,0,0)],error$1,error,reader);
      reader.readAsDataURL(b);
      return fut}
    function init$1(blob_init,last_modified_ms,param)
     {if(blob_init)var b=blob_init[1],o=b;else var o={};
      caml_call3(Int[4],o,cst_lastModified,last_modified_ms);
      return o}
    var file$0=target.File;
    function of_blob(opt,name,b)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new file$0(b,name,init)}
    function name$0(f){return caml_call2(_d_[2],f,cst_name$0)}
    function last_modified_ms(f)
     {return caml_call2(Int[2],f,cst_lastModified$0)}
    function encode(bs)
     {try
       {var v=target.btoa(bs)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    function decode(s)
     {try
       {var v=target.atob(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    var Base64=[0,encode,decode],json=target.JSON;
    function encode$0(v){return json.stringify(v)}
    function decode$0(s)
     {try
       {var v=json.parse(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    var encode$1=target.encodeURI,decode$1=target.decodeURI,url=target.URL;
    function v$0(s){return new url(s)}
    function with_uri(scheme,host,port,path,query,fragment,u)
     {var u$0=new url(u);
      function pct_enc(v){return encode$1(v)}
      try
       {set_if_some
         (u$0,cst_protocol,caml_call2(Stdlib_option[7],pct_enc,scheme));
        set_if_some
         (u$0,cst_hostname,caml_call2(Stdlib_option[7],pct_enc,host));
        if(port)
         {var
           p=port[1],
           _nu_=function(eta){return arg(0,eta)},
           _nv_=caml_call2(Stdlib_option[7],_nu_,p);
          caml_call3(_d_[4],u$0,cst_port,_nv_)}
        set_if_some
         (u$0,cst_pathname,caml_call2(Stdlib_option[7],pct_enc,path));
        set_if_some(u$0,cst_search,caml_call2(Stdlib_option[7],pct_enc,query));
        set_if_some
         (u$0,cst_hash,caml_call2(Stdlib_option[7],pct_enc,fragment));
        var _nw_=[0,u$0];
        return _nw_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function pct_dec(v){return decode$1(v)}
    function scheme(u)
     {var p=pct_dec(u.protocol);return 0 === p.length?p:slice(0,_p_,p)}
    function host(u){return pct_dec(u.hostname)}
    function port(u)
     {var p=caml_call2(_d_[2],u,cst_port$0);return is_empty(p)?0:to_int(0,p)}
    function query(u)
     {var q=pct_dec(u.search);return is_empty(q)?q:slice(_q_,0,q)}
    function path(u){return pct_dec(u.pathname)}
    function fragment(u)
     {var f=decode$1(u.hash);return is_empty(f)?f:slice(_r_,0,f)}
    var usp=target.URLSearchParams;
    function mem(k,p){return p.has(k) | 0}
    function find$6(k,p)
     {var _ns_=p.get(k);return to_option(function(_nt_){return _nt_},_ns_)}
    function find_all(k,p){return caml_list_of_js_array(p.getAll(k))}
    function fold$0(f,p,acc)
     {function key(_nr_){return _nr_}
      function value(_nq_){return _nq_}
      var _np_=p.entries();
      return caml_call5(_b_[8],key,value,f,_np_,acc)}
    function of_jstr$1(s){return new usp(s)}
    function to_jstr$0(p){return p.toString()}
    function of_assoc(l)
     {var p=of_jstr$1(empty);
      function _no_(param){var v=param[2],k=param[1];p.append(k,v);return 0}
      caml_call2(Stdlib_list[15],_no_,l);
      return p}
    function to_assoc(p)
     {var
       _nm_=0,
       _nn_=fold$0(function(k,v,acc){return [0,[0,k,v],acc]},p,_nm_);
      return caml_call1(Stdlib_list[9],_nn_)}
    function of_obj(o){return new usp(o)}
    function code$0(f,s)
     {try
       {var v=f(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    var
     encode_component=target.encodeURIComponent,
     _s_=target.decodeURIComponent;
    function encode$2(s){return code$0(encode$1,s)}
    function decode$2(s){return code$0(decode$1,s)}
    function encode_component$0(s){return code$0(encode_component,s)}
    function decode_component(s){return code$0(_s_,s)}
    function to_jstr$1(u){return u.toString()}
    function of_jstr$2(s)
     {try
       {var v=new url(s)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    function v$1(n,v){return [0,n,v]}
    function true$1(n){return [0,n,empty]}
    function int$0(n,i){return [0,n,arg(0,i)]}
    function add_if(b,at,l){return b?[0,at,l]:l}
    function add_if_some(name,o,l)
     {if(o){var a=o[1];return [0,[0,name,a],l]}return l}
    function to_pair(_nl_){return _nl_}
    var
     accesskey="accesskey",
     autofocus="autofocus",
     charset="charset",
     checked="checked",
     class$0="class",
     content="content",
     contenteditable="contenteditable",
     cols="cols",
     defer="defer",
     disabled="disabled",
     dir="dir",
     draggable="draggable",
     for$0="for",
     height$0="height",
     hidden="hidden",
     href="href",
     id$0="id",
     lang="lang",
     media="media",
     name$1="name",
     placeholder="placeholder",
     rel="rel",
     rows="rows",
     src="src",
     spellcheck="spellcheck",
     tabindex="tabindex",
     title="title",
     type$4="type",
     value="value",
     width$0="width",
     wrap="wrap";
    function accesskey$0(s){return [0,accesskey,s]}
    var autofocus$0=true$1(autofocus);
    function charset$0(_nk_){return [0,charset,_nk_]}
    var checked$0=true$1(checked);
    function class$1(s){return [0,class$0,s]}
    function cols$0(i){return int$0(cols,i)}
    function content$0(s){return [0,content,s]}
    function contenteditable$0(s){return true$1(contenteditable)}
    var defer$0=true$1(defer),disabled$0=true$1(disabled);
    function dir$0(s){return [0,dir,s]}
    function draggable$0(s){return true$1(draggable)}
    function for$1(s){return [0,for$0,s]}
    function height$1(i){return int$0(height$0,i)}
    var hidden$0=true$1(hidden);
    function href$0(s){return [0,href,s]}
    function id$1(s){return [0,id$0,s]}
    function lang$0(s){return [0,lang,s]}
    function media$0(s){return [0,media,s]}
    function name$2(s){return [0,name$1,s]}
    function placeholder$0(s){return [0,placeholder,s]}
    function rel$0(s){return [0,rel,s]}
    function rows$0(i){return int$0(rows,i)}
    function src$0(s){return [0,src,s]}
    function spellcheck$0(_nj_){return [0,spellcheck,_nj_]}
    function tabindex$0(i){return int$0(tabindex,i)}
    function title$0(s){return [0,title,s]}
    function type$5(s){return [0,type$4,s]}
    function value$0(s){return [0,value,s]}
    function width$1(i){return int$0(width$0,i)}
    function wrap$0(s){return [0,value,s]}
    var document=target.document;
    function document$0(e){return e.ownerDocument}
    var global_root=document.documentElement;
    function el_list_of_node_list(nl)
     {var acc=[0,0],len=caml_call2(Int[2],nl,cst_length$1),_nh_=len - 1 | 0;
      if(! (_nh_ < 0))
       {var i=_nh_;
        for(;;)
         {acc[1] = [0,nl[i],acc[1]];
          var _ni_=i - 1 | 0;
          if(0 !== i){var i=_ni_;continue}
          break}}
      return acc[1]}
    function _t_(e,n){e.appendChild(n);return 0}
    function v$2(opt,_nd_,name,cs)
     {if(opt)var sth=opt[1],d=sth;else var d=document;
      if(_nd_)var sth$0=_nd_[1],at=sth$0;else var at=0;
      var e=d.createElement(name);
      function _ne_(param)
       {var v=param[2],a=param[1],match=caml_equal(a,class$0);
        return match
                ?is_empty(v)?0:(e.classList.add(v),0)
                :(e.setAttribute(a,v),0)}
      caml_call2(Stdlib_list[15],_ne_,at);
      function _nf_(_ng_){return _t_(e,_ng_)}
      caml_call2(Stdlib_list[15],_nf_,cs);
      return e}
    function txt(opt,s)
     {if(opt)var sth=opt[1],d=sth;else var d=document;
      return d.createTextNode(s)}
    function txt$0(opt,s)
     {if(opt)var sth=opt[1],d=sth;else var d=document;
      return d.createTextNode(caml_jsstring_of_string(s))}
    function sp$0(opt,param){return txt(0," ")}
    function nbsp(opt,param){return txt(0,caml_jsstring_of_string(cst))}
    function is_txt(e){return 3 === caml_call2(Int[2],e,cst_nodeType)?1:0}
    function is_el(e){return 1 === caml_call2(Int[2],e,cst_nodeType$0)?1:0}
    function tag_name(e)
     {return caml_call2(_d_[2],e,cst_nodeName).toLowerCase()}
    function has_tag_name(n,e){return caml_equal(n,tag_name(e))}
    function txt_text(txt)
     {var match=is_txt(txt);
      return match?caml_call2(_d_[2],txt,cst_nodeValue):empty}
    function find_by_class(opt,c)
     {if(opt)var sth=opt[1],root=sth;else var root=global_root;
      return el_list_of_node_list(root.getElementsByClassName(c))}
    function find_by_tag_name(opt,n)
     {if(opt)var sth=opt[1],root=sth;else var root=global_root;
      return el_list_of_node_list(root.getElementsByTagName(n))}
    function children(opt,e)
     {if(opt)var sth=opt[1],only_els=sth;else var only_els=0;
      return only_els
              ?el_list_of_node_list(e.children)
              :el_list_of_node_list(e.childNodes)}
    function set_children(e,l)
     {for(;;)
       {if(is_null(e.firstChild))
         {var _nb_=function(_nc_){return _t_(e,_nc_)};
          return caml_call2(Stdlib_list[15],_nb_,l)}
        e.removeChild(e.firstChild);
        continue}}
    function prepend_children(e,l)
     {caml_js_meth_call(e,cst_prepend,caml_call1(Stdlib_array[12],l));
      return 0}
    function append_children(e,l)
     {caml_js_meth_call(e,cst_append,caml_call1(Stdlib_array[12],l));return 0}
    function insert_siblings(loc,e,l)
     {if(-126259180 === loc)
       caml_js_meth_call(e,cst_replaceWith,caml_call1(Stdlib_array[12],l));
      else
       if(818927100 <= loc)
        caml_js_meth_call(e,cst_after,caml_call1(Stdlib_array[12],l));
       else
        caml_js_meth_call(e,cst_before,caml_call1(Stdlib_array[12],l));
      return 0}
    function remove$0(e){e.remove(e);return 0}
    function at(a,e)
     {var _m$_=e.getAttribute(a);
      return to_option(function(_na_){return _na_},_m$_)}
    function set_at(a,v,e)
     {if(v){var v$0=v[1];e.setAttribute(a,v$0);return 0}
      e.removeAttribute(a);
      return 0}
    function jv_to_bool(b){return is_undefined(b)?0:b | 0}
    function jv_to_int(i){return is_undefined(i)?0:i}
    function jv_to_float(f){return is_undefined(f)?0.:f}
    function jv_to_jstr(s){return is_undefined(s)?empty:s}
    function bool(n){return [0,n,jv_to_bool,caml_js_from_bool]}
    function int$1(n){return [0,n,jv_to_int,function(_m__){return _m__}]}
    function float$0(n){return [0,n,jv_to_float,function(_m9_){return _m9_}]}
    function jstr(n){return [0,n,jv_to_jstr,function(_m8_){return _m8_}]}
    var
     checked$1=bool("checked"),
     height$2=int$1("height"),
     id$2=jstr("id"),
     name$3=jstr("name"),
     title$1=jstr("title"),
     value$1=jstr("value"),
     width$2=int$1("width");
    function prop(p,e){return caml_call1(p[2],e[p[1]])}
    function set_prop(p,v,e)
     {var _m7_=caml_call1(p[3],v);e[p[1]] = _m7_;return 0}
    function class$2(c,e){return e.classList.contains(c) | 0}
    function set_class(c,b,e)
     {return b?(e.classList.add(c),0):(e.classList.remove(c),0)}
    var
     background_color="background-color",
     color="color",
     cursor="cursor",
     display="display",
     height$3="height",
     visibility="visibility",
     width$3="width",
     Style=
      [0,background_color,color,cursor,display,height$3,visibility,width$3];
    function computed_style(opt,p,e)
     {if(opt)var sth=opt[1],w=sth;else var w=target.window;
      var style=w.getComputedStyle(e),v=style[p];
      return is_none(v)?empty:v}
    function inline_style(p,e)
     {var style=e.style;
      if(is_none(style))return empty;
      var v=style[p];
      return is_none(v)?empty:v}
    function set_inline_style(opt,p,v,e)
     {if(opt)var sth=opt[1],important=sth;else var important=0;
      var priority=important?"important":empty,style=e.style;
      return is_none(style)?0:(style.setProperty(p,v,priority),0)}
    function inner_x(e){return caml_call2(Float[2],e,cst_clientLeft)}
    function inner_y(e){return caml_call2(Float[2],e,cst_clientTop)}
    function inner_w(e){return caml_call2(Float[2],e,cst_clientWidth)}
    function inner_h(e){return caml_call2(Float[2],e,cst_clientHeight)}
    function bound_x(e)
     {var _m6_=e.getBoundingClientRect();
      return caml_call2(Float[2],_m6_,cst_x)}
    function bound_y(e)
     {var _m5_=e.getBoundingClientRect();
      return caml_call2(Float[2],_m5_,cst_y)}
    function bound_w(e)
     {var _m4_=e.getBoundingClientRect();
      return caml_call2(Float[2],_m4_,cst_width$0)}
    function bound_h(e)
     {var _m3_=e.getBoundingClientRect();
      return caml_call2(Float[2],_m3_,cst_height$0)}
    function scroll_x(e){return caml_call2(Float[2],e,cst_scrollLeft)}
    function scroll_y(e){return caml_call2(Float[2],e,cst_scrollTop)}
    function scroll_w(e){return caml_call2(Float[2],e,cst_scrollWidth)}
    function scroll_h(e){return caml_call2(Float[2],e,cst_scrollHeight)}
    function scroll_into_view(opt,e)
     {if(opt)var sth=opt[1],align_v=sth;else var align_v=389604418;
      var align=389604418 <= align_v?0:1;
      e.scrollIntoView(! ! align);
      return 0}
    function has_focus(e)
     {var
       _m1_=e.ownerDocument.activeElement,
       match=to_option(function(_m2_){return _m2_},_m1_);
      if(match){var e$0=match[1];return e === e$0?1:0}
      return 0}
    function set_has_focus(b,e){if(b)e.focus();else e.blur();return 0}
    function is_locking_pointer(e)
     {var
       _mZ_=e.ownerDocument.pointerLockElement,
       match=to_option(function(_m0_){return _m0_},_mZ_);
      if(match){var e$0=match[1];return e === e$0?1:0}
      return 0}
    function request_pointer_lock(e)
     {var
       match=create$1(0),
       set=match[2],
       fut=match[1],
       d=e.ownerDocument,
       opts=listen_opts(0,_u_,0,0);
      function unlisten$0(param)
       {unlisten([0,opts],pointerlockchange,locked,d);
        return unlisten([0,opts],pointerlockerror,error,d)}
      function locked(ev){caml_call1(set,_v_);return unlisten$0(0)}
      function error(ev)
       {var err=caml_call2(_c_[1],0,"Could not lock pointer");
        caml_call1(set,[1,err]);
        return unlisten$0(0)}
      listen([0,opts],pointerlockchange,locked,d);
      listen([0,opts],pointerlockerror,error,d);
      e.requestPointerLock();
      return fut}
    function click$0(e){e.click();return 0}
    function select_text(e){e.select();return 0}
    var auto="auto",hide="hide",show="show",Navigation_ui=[0,auto,hide,show];
    function fullscreen_opts(navigation_ui,param)
     {var o={};caml_call3(_d_[4],o,cst_navigationUI,navigation_ui);return o}
    function request_fullscreen(opt,e)
     {if(opt)var sth=opt[1],opts=sth;else var opts={};
      var _mX_=e.requestFullscreen(opts);
      return of_promise$0(function(_mY_){return 0},_mX_)}
    function files(e)
     {var match=find(e,cst_files);
      if(match)
       {var files=match[1];return to_list(function(_mW_){return _mW_},files)}
      return 0}
    var
     Input$0=[0,files],
     a="a",
     abbr="abbr",
     address="address",
     area="area",
     article="article",
     aside="aside",
     audio="audio",
     b="b",
     base="base",
     bdi="bdi",
     bdo="bdo",
     blockquote="blockquote",
     body="body",
     br="br",
     button$0="button",
     canvas="canvas",
     caption="caption",
     cite="cite",
     code$1="code",
     col="col",
     colgroup="colgroup",
     command="command",
     datalist="datalist",
     dd="dd",
     del="del",
     details="details",
     dfn="dfn",
     div="div",
     dl="dl",
     dt="dt",
     em="em",
     embed="embed",
     fieldset="fieldset",
     figcaption="figcaption",
     figure="figure",
     footer="footer",
     form="form",
     h1="h1",
     h2="h2",
     h3="h3",
     h4="h4",
     h5="h5",
     h6="h6",
     head="head",
     header="header",
     hgroup="hgroup",
     hr="hr",
     html="html",
     i="i",
     iframe="iframe",
     img="img",
     input$0="input",
     ins="ins",
     kbd="kbd",
     keygen="keygen",
     label="label",
     legend="legend",
     li="li",
     link$0="link",
     map$1="map",
     mark="mark",
     menu="menu",
     meta="meta",
     meter="meter",
     nav="nav",
     noscript="noscript",
     object="object",
     ol="ol",
     optgroup="optgroup",
     option="option",
     output="output",
     p="p",
     param="param",
     pre="pre",
     progress$0="progress",
     q="q",
     rp="rp",
     rt="rt",
     ruby="ruby",
     s="s",
     samp="samp",
     script="script",
     section="section",
     select$0="select",
     small="small",
     source="source",
     span="span",
     strong="strong",
     style="style",
     sub$1="sub",
     summary="summary",
     sup="sup",
     table="table",
     tbody="tbody",
     td="td",
     textarea="textarea",
     tfoot="tfoot",
     th="th",
     thead="thead",
     time="time",
     title$2="title",
     tr="tr",
     track="track",
     u="u",
     ul="ul",
     var$0="var",
     video="video",
     wbr="wbr",
     Name=
      [0,
       a,
       abbr,
       address,
       area,
       article,
       aside,
       audio,
       b,
       base,
       bdi,
       bdo,
       blockquote,
       body,
       br,
       button$0,
       canvas,
       caption,
       cite,
       code$1,
       col,
       colgroup,
       command,
       datalist,
       dd,
       del,
       details,
       dfn,
       div,
       dl,
       dt,
       em,
       embed,
       fieldset,
       figcaption,
       figure,
       footer,
       form,
       h1,
       h2,
       h3,
       h4,
       h5,
       h6,
       head,
       header,
       hgroup,
       hr,
       html,
       i,
       iframe,
       img,
       input$0,
       ins,
       kbd,
       keygen,
       label,
       legend,
       li,
       link$0,
       map$1,
       mark,
       menu,
       meta,
       meter,
       nav,
       noscript,
       object,
       ol,
       optgroup,
       option,
       output,
       p,
       param,
       pre,
       progress$0,
       q,
       rp,
       rt,
       ruby,
       s,
       samp,
       script,
       section,
       select$0,
       small,
       source,
       span,
       strong,
       style,
       sub$1,
       summary,
       sup,
       table,
       tbody,
       td,
       textarea,
       tfoot,
       th,
       thead,
       time,
       title$2,
       tr,
       track,
       u,
       ul,
       var$0,
       video,
       wbr];
    function cons(name,d,at,cs){return v$2(d,at,name,cs)}
    function void_cons(name,d,at,param){return v$2(d,at,name,0)}
    var _w_=Name[1];
    function a$0(_mT_,_mU_,_mV_){return cons(_w_,_mT_,_mU_,_mV_)}
    var _x_=Name[2];
    function abbr$0(_mQ_,_mR_,_mS_){return cons(_x_,_mQ_,_mR_,_mS_)}
    var _y_=Name[3];
    function address$0(_mN_,_mO_,_mP_){return cons(_y_,_mN_,_mO_,_mP_)}
    var _z_=Name[4];
    function area$0(_mK_,_mL_,_mM_){return void_cons(_z_,_mK_,_mL_,_mM_)}
    var _A_=Name[5];
    function article$0(_mH_,_mI_,_mJ_){return cons(_A_,_mH_,_mI_,_mJ_)}
    var _B_=Name[6];
    function aside$0(_mE_,_mF_,_mG_){return cons(_B_,_mE_,_mF_,_mG_)}
    var _C_=Name[7];
    function audio$0(_mB_,_mC_,_mD_){return cons(_C_,_mB_,_mC_,_mD_)}
    var _D_=Name[8];
    function b$0(_my_,_mz_,_mA_){return cons(_D_,_my_,_mz_,_mA_)}
    var _E_=Name[9];
    function base$0(_mv_,_mw_,_mx_){return void_cons(_E_,_mv_,_mw_,_mx_)}
    var _F_=Name[10];
    function bdi$0(_ms_,_mt_,_mu_){return cons(_F_,_ms_,_mt_,_mu_)}
    var _G_=Name[11];
    function bdo$0(_mp_,_mq_,_mr_){return cons(_G_,_mp_,_mq_,_mr_)}
    var _H_=Name[12];
    function blockquote$0(_mm_,_mn_,_mo_){return cons(_H_,_mm_,_mn_,_mo_)}
    var _I_=Name[13];
    function body$0(_mj_,_mk_,_ml_){return cons(_I_,_mj_,_mk_,_ml_)}
    var _J_=Name[14];
    function br$0(_mg_,_mh_,_mi_){return void_cons(_J_,_mg_,_mh_,_mi_)}
    var _K_=Name[15];
    function button$1(_md_,_me_,_mf_){return cons(_K_,_md_,_me_,_mf_)}
    var _L_=Name[16];
    function canvas$0(_ma_,_mb_,_mc_){return cons(_L_,_ma_,_mb_,_mc_)}
    var _M_=Name[17];
    function caption$0(_l9_,_l__,_l$_){return cons(_M_,_l9_,_l__,_l$_)}
    var _N_=Name[18];
    function cite$0(_l6_,_l7_,_l8_){return cons(_N_,_l6_,_l7_,_l8_)}
    var _O_=Name[19];
    function code$2(_l3_,_l4_,_l5_){return cons(_O_,_l3_,_l4_,_l5_)}
    var _P_=Name[20];
    function col$0(_l0_,_l1_,_l2_){return void_cons(_P_,_l0_,_l1_,_l2_)}
    var _Q_=Name[21];
    function colgroup$0(_lX_,_lY_,_lZ_){return cons(_Q_,_lX_,_lY_,_lZ_)}
    var _R_=Name[22];
    function command$0(_lU_,_lV_,_lW_){return cons(_R_,_lU_,_lV_,_lW_)}
    var _S_=Name[23];
    function datalist$0(_lR_,_lS_,_lT_){return cons(_S_,_lR_,_lS_,_lT_)}
    var _T_=Name[24];
    function dd$0(_lO_,_lP_,_lQ_){return cons(_T_,_lO_,_lP_,_lQ_)}
    var _U_=Name[25];
    function del$0(_lL_,_lM_,_lN_){return cons(_U_,_lL_,_lM_,_lN_)}
    var _V_=Name[26];
    function details$0(_lI_,_lJ_,_lK_){return cons(_V_,_lI_,_lJ_,_lK_)}
    var _W_=Name[27];
    function dfn$0(_lF_,_lG_,_lH_){return cons(_W_,_lF_,_lG_,_lH_)}
    var _X_=Name[28];
    function div$0(_lC_,_lD_,_lE_){return cons(_X_,_lC_,_lD_,_lE_)}
    var _Y_=Name[29];
    function dl$0(_lz_,_lA_,_lB_){return cons(_Y_,_lz_,_lA_,_lB_)}
    var _Z_=Name[30];
    function dt$0(_lw_,_lx_,_ly_){return cons(_Z_,_lw_,_lx_,_ly_)}
    var ___=Name[31];
    function em$0(_lt_,_lu_,_lv_){return cons(___,_lt_,_lu_,_lv_)}
    var _$_=Name[32];
    function embed$0(_lq_,_lr_,_ls_){return void_cons(_$_,_lq_,_lr_,_ls_)}
    var _aa_=Name[33];
    function fieldset$0(_ln_,_lo_,_lp_){return cons(_aa_,_ln_,_lo_,_lp_)}
    var _ab_=Name[34];
    function figcaption$0(_lk_,_ll_,_lm_){return cons(_ab_,_lk_,_ll_,_lm_)}
    var _ac_=Name[35];
    function figure$0(_lh_,_li_,_lj_){return cons(_ac_,_lh_,_li_,_lj_)}
    var _ad_=Name[36];
    function footer$0(_le_,_lf_,_lg_){return cons(_ad_,_le_,_lf_,_lg_)}
    var _ae_=Name[37];
    function form$0(_lb_,_lc_,_ld_){return cons(_ae_,_lb_,_lc_,_ld_)}
    var _af_=Name[38];
    function h1$0(_k__,_k$_,_la_){return cons(_af_,_k__,_k$_,_la_)}
    var _ag_=Name[39];
    function h2$0(_k7_,_k8_,_k9_){return cons(_ag_,_k7_,_k8_,_k9_)}
    var _ah_=Name[40];
    function h3$0(_k4_,_k5_,_k6_){return cons(_ah_,_k4_,_k5_,_k6_)}
    var _ai_=Name[41];
    function h4$0(_k1_,_k2_,_k3_){return cons(_ai_,_k1_,_k2_,_k3_)}
    var _aj_=Name[42];
    function h5$0(_kY_,_kZ_,_k0_){return cons(_aj_,_kY_,_kZ_,_k0_)}
    var _ak_=Name[43];
    function h6$0(_kV_,_kW_,_kX_){return cons(_ak_,_kV_,_kW_,_kX_)}
    var _al_=Name[44];
    function head$0(_kS_,_kT_,_kU_){return cons(_al_,_kS_,_kT_,_kU_)}
    var _am_=Name[45];
    function header$0(_kP_,_kQ_,_kR_){return cons(_am_,_kP_,_kQ_,_kR_)}
    var _an_=Name[46];
    function hgroup$0(_kM_,_kN_,_kO_){return cons(_an_,_kM_,_kN_,_kO_)}
    var _ao_=Name[47];
    function hr$0(_kJ_,_kK_,_kL_){return void_cons(_ao_,_kJ_,_kK_,_kL_)}
    var _ap_=Name[48];
    function html$0(_kG_,_kH_,_kI_){return cons(_ap_,_kG_,_kH_,_kI_)}
    var _aq_=Name[49];
    function i$0(_kD_,_kE_,_kF_){return cons(_aq_,_kD_,_kE_,_kF_)}
    var _ar_=Name[50];
    function iframe$0(_kA_,_kB_,_kC_){return cons(_ar_,_kA_,_kB_,_kC_)}
    var _as_=Name[51];
    function img$0(_kx_,_ky_,_kz_){return void_cons(_as_,_kx_,_ky_,_kz_)}
    var _at_=Name[52];
    function input$1(_ku_,_kv_,_kw_){return void_cons(_at_,_ku_,_kv_,_kw_)}
    var _au_=Name[53];
    function ins$0(_kr_,_ks_,_kt_){return cons(_au_,_kr_,_ks_,_kt_)}
    var _av_=Name[54];
    function kbd$0(_ko_,_kp_,_kq_){return cons(_av_,_ko_,_kp_,_kq_)}
    var _aw_=Name[55];
    function keygen$0(_kl_,_km_,_kn_){return cons(_aw_,_kl_,_km_,_kn_)}
    var _ax_=Name[56];
    function label$0(_ki_,_kj_,_kk_){return cons(_ax_,_ki_,_kj_,_kk_)}
    var _ay_=Name[57];
    function legend$0(_kf_,_kg_,_kh_){return cons(_ay_,_kf_,_kg_,_kh_)}
    var _az_=Name[58];
    function li$0(_kc_,_kd_,_ke_){return cons(_az_,_kc_,_kd_,_ke_)}
    var _aA_=Name[59];
    function link$1(_j$_,_ka_,_kb_){return void_cons(_aA_,_j$_,_ka_,_kb_)}
    var _aB_=Name[60];
    function map$2(_j8_,_j9_,_j__){return cons(_aB_,_j8_,_j9_,_j__)}
    var _aC_=Name[61];
    function mark$0(_j5_,_j6_,_j7_){return cons(_aC_,_j5_,_j6_,_j7_)}
    var _aD_=Name[62];
    function menu$0(_j2_,_j3_,_j4_){return cons(_aD_,_j2_,_j3_,_j4_)}
    var _aE_=Name[63];
    function meta$0(_jZ_,_j0_,_j1_){return void_cons(_aE_,_jZ_,_j0_,_j1_)}
    var _aF_=Name[64];
    function meter$0(_jW_,_jX_,_jY_){return cons(_aF_,_jW_,_jX_,_jY_)}
    var _aG_=Name[65];
    function nav$0(_jT_,_jU_,_jV_){return cons(_aG_,_jT_,_jU_,_jV_)}
    var _aH_=Name[66];
    function noscript$0(_jQ_,_jR_,_jS_){return cons(_aH_,_jQ_,_jR_,_jS_)}
    var _aI_=Name[67];
    function object$0(_jN_,_jO_,_jP_){return cons(_aI_,_jN_,_jO_,_jP_)}
    var _aJ_=Name[68];
    function ol$0(_jK_,_jL_,_jM_){return cons(_aJ_,_jK_,_jL_,_jM_)}
    var _aK_=Name[69];
    function optgroup$0(_jH_,_jI_,_jJ_){return cons(_aK_,_jH_,_jI_,_jJ_)}
    var _aL_=Name[70];
    function option$0(_jE_,_jF_,_jG_){return cons(_aL_,_jE_,_jF_,_jG_)}
    var _aM_=Name[71];
    function output$0(_jB_,_jC_,_jD_){return cons(_aM_,_jB_,_jC_,_jD_)}
    var _aN_=Name[72];
    function p$0(_jy_,_jz_,_jA_){return cons(_aN_,_jy_,_jz_,_jA_)}
    var _aO_=Name[73];
    function param$0(_jv_,_jw_,_jx_){return void_cons(_aO_,_jv_,_jw_,_jx_)}
    var _aP_=Name[74];
    function pre$0(_js_,_jt_,_ju_){return cons(_aP_,_js_,_jt_,_ju_)}
    var _aQ_=Name[75];
    function progress$1(_jp_,_jq_,_jr_){return cons(_aQ_,_jp_,_jq_,_jr_)}
    var _aR_=Name[76];
    function q$0(_jm_,_jn_,_jo_){return cons(_aR_,_jm_,_jn_,_jo_)}
    var _aS_=Name[77];
    function rp$0(_jj_,_jk_,_jl_){return cons(_aS_,_jj_,_jk_,_jl_)}
    var _aT_=Name[78];
    function rt$0(_jg_,_jh_,_ji_){return cons(_aT_,_jg_,_jh_,_ji_)}
    var _aU_=Name[79];
    function ruby$0(_jd_,_je_,_jf_){return cons(_aU_,_jd_,_je_,_jf_)}
    var _aV_=Name[80];
    function s$0(_ja_,_jb_,_jc_){return cons(_aV_,_ja_,_jb_,_jc_)}
    var _aW_=Name[81];
    function samp$0(_i9_,_i__,_i$_){return cons(_aW_,_i9_,_i__,_i$_)}
    var _aX_=Name[82];
    function script$0(_i6_,_i7_,_i8_){return cons(_aX_,_i6_,_i7_,_i8_)}
    var _aY_=Name[83];
    function section$0(_i3_,_i4_,_i5_){return cons(_aY_,_i3_,_i4_,_i5_)}
    var _aZ_=Name[84];
    function select$1(_i0_,_i1_,_i2_){return cons(_aZ_,_i0_,_i1_,_i2_)}
    var _a0_=Name[85];
    function small$0(_iX_,_iY_,_iZ_){return cons(_a0_,_iX_,_iY_,_iZ_)}
    var _a1_=Name[86];
    function source$0(_iU_,_iV_,_iW_){return void_cons(_a1_,_iU_,_iV_,_iW_)}
    var _a2_=Name[87];
    function span$0(_iR_,_iS_,_iT_){return cons(_a2_,_iR_,_iS_,_iT_)}
    var _a3_=Name[88];
    function strong$0(_iO_,_iP_,_iQ_){return cons(_a3_,_iO_,_iP_,_iQ_)}
    var _a4_=Name[89];
    function style$0(_iL_,_iM_,_iN_){return cons(_a4_,_iL_,_iM_,_iN_)}
    var _a5_=Name[90];
    function sub$2(_iI_,_iJ_,_iK_){return cons(_a5_,_iI_,_iJ_,_iK_)}
    var _a6_=Name[91];
    function summary$0(_iF_,_iG_,_iH_){return cons(_a6_,_iF_,_iG_,_iH_)}
    var _a7_=Name[92];
    function sup$0(_iC_,_iD_,_iE_){return cons(_a7_,_iC_,_iD_,_iE_)}
    var _a8_=Name[93];
    function table$0(_iz_,_iA_,_iB_){return cons(_a8_,_iz_,_iA_,_iB_)}
    var _a9_=Name[94];
    function tbody$0(_iw_,_ix_,_iy_){return cons(_a9_,_iw_,_ix_,_iy_)}
    var _a__=Name[95];
    function td$0(_it_,_iu_,_iv_){return cons(_a__,_it_,_iu_,_iv_)}
    var _a$_=Name[96];
    function textarea$0(_iq_,_ir_,_is_){return cons(_a$_,_iq_,_ir_,_is_)}
    var _ba_=Name[97];
    function tfoot$0(_in_,_io_,_ip_){return cons(_ba_,_in_,_io_,_ip_)}
    var _bb_=Name[98];
    function th$0(_ik_,_il_,_im_){return cons(_bb_,_ik_,_il_,_im_)}
    var _bc_=Name[99];
    function thead$0(_ih_,_ii_,_ij_){return cons(_bc_,_ih_,_ii_,_ij_)}
    var _bd_=Name[100];
    function time$0(_ie_,_if_,_ig_){return cons(_bd_,_ie_,_if_,_ig_)}
    var _be_=Name[101];
    function title$3(_ib_,_ic_,_id_){return cons(_be_,_ib_,_ic_,_id_)}
    var _bf_=Name[102];
    function tr$0(_h__,_h$_,_ia_){return cons(_bf_,_h__,_h$_,_ia_)}
    var _bg_=Name[103];
    function track$0(_h7_,_h8_,_h9_){return void_cons(_bg_,_h7_,_h8_,_h9_)}
    var _bh_=Name[104];
    function u$0(_h4_,_h5_,_h6_){return cons(_bh_,_h4_,_h5_,_h6_)}
    var _bi_=Name[105];
    function ul$0(_h1_,_h2_,_h3_){return cons(_bi_,_h1_,_h2_,_h3_)}
    var _bj_=Name[106];
    function var$1(_hY_,_hZ_,_h0_){return cons(_bj_,_hY_,_hZ_,_h0_)}
    var _bk_=Name[107];
    function video$0(_hV_,_hW_,_hX_){return cons(_bk_,_hV_,_hW_,_hX_)}
    var _bl_=Name[108];
    function wbr$0(_hS_,_hT_,_hU_){return void_cons(_bl_,_hS_,_hT_,_hU_)}
    function as_target(d){return d}
    function root(d){return d.documentElement}
    function body$1(d)
     {var b=d.body;
      return is_some(b)
              ?b
              :throw$0
                (0,
                 "Document body is null. Try to defer your script execution.")}
    function head$1(d){return d.head}
    function active_el(d)
     {var _hQ_=d.activeElement;
      return to_option(function(_hR_){return _hR_},_hQ_)}
    function find_el_by_id(d,id)
     {var _hO_=d.getElementById(id);
      return to_option(function(_hP_){return _hP_},_hO_)}
    function find_els_by_name(d,n)
     {return el_list_of_node_list(d.getElementsByName(n))}
    function referrer(d){return caml_call2(_d_[2],d,cst_referrer)}
    function title$4(d){return caml_call2(_d_[2],d,cst_title)}
    function set_title(d,t){return caml_call3(_d_[3],d,cst_title$0,t)}
    var
     hidden$1="hidden",
     visible="visible",
     Visibility_state=[0,hidden$1,visible];
    function visibility_state(d)
     {return caml_call2(_d_[2],d,cst_visibilityState)}
    function pointer_lock_element(d)
     {var _hM_=d.pointerLockElement;
      return to_option(function(_hN_){return _hN_},_hM_)}
    function exit_pointer_lock(d)
     {var fut=next$0(0,pointerlockchange,d);d.exitPointerLock();return fut}
    function fullscreen_available(d)
     {return caml_call2(Bool[2],d,cst_fullscreenEnabled)}
    function fullscreen_element(d)
     {var _hK_=d.fullscreenElement;
      return to_option(function(_hL_){return _hL_},_hK_)}
    function exit_fullscreen(d)
     {var _hI_=d.exitFullscreen();
      return of_promise$0(function(_hJ_){return 0},_hI_)}
    function aborted(s){return caml_call2(Bool[2],s,cst_aborted)}
    var abort$0="abort",Signal=[0,aborted,abort$0];
    function controller(param){return new (target.AbortController)()}
    function signal(c){return c.signal}
    function abort$1(c){c.abort();return 0}
    var Abort=[0,Signal,controller,signal,abort$1];
    function call$0(c,meth,args){caml_js_meth_call(c,meth,args);return 0}
    var c=[0,target.console];
    function get$4(param){return c[1]}
    function set$3(n){c[1] = n;return 0}
    function clear$0(param){return call$0(c[1],cst_clear,[0])}
    function msg(v){return [0,v,0]}
    function str(v)
     {return is_null(v)?"null":is_undefined(v)?"undefined":v.toString()}
    function msg_to_jv_array(msg)
     {var a=caml_call1(Jarray[1],0),i=0,param=msg;
      for(;;)
       {if(param)
         {var vs=param[2],v=param[1];
          a[i] = v;
          var i$0=i + 1 | 0,i=i$0,param=vs;
          continue}
        return runtime.caml_js_to_array(a)}}
    function log(msg)
     {var _hH_=msg_to_jv_array(msg);return call$0(c[1],cst_log,_hH_)}
    function trace(msg)
     {var _hG_=msg_to_jv_array(msg);return call$0(c[1],cst_trace,_hG_)}
    function error$2(msg)
     {var _hF_=msg_to_jv_array(msg);return call$0(c[1],cst_error,_hF_)}
    function warn(msg)
     {var _hE_=msg_to_jv_array(msg);return call$0(c[1],cst_warn,_hE_)}
    function info(msg)
     {var _hD_=msg_to_jv_array(msg);return call$0(c[1],cst_info,_hD_)}
    function debug(msg)
     {var _hC_=msg_to_jv_array(msg);return call$0(c[1],cst_debug,_hC_)}
    function assert(b,msg)
     {var _hB_=msg_to_jv_array([0,! ! b,msg]);
      return call$0(c[1],cst_assert,_hB_)}
    function dir$1(o){return call$0(c[1],cst_dir,[0,o])}
    function table$1(cols,v)
     {if(cols)
       var l=cols[1],msg=[0,v,caml_list_to_js_array(l)];
      else
       var msg=[0,v];
      return call$0(c[1],cst_table,msg)}
    function group_end(param){return call$0(c[1],cst_groupEnd,[0])}
    function group(opt,msg)
     {if(opt)var sth=opt[1],closed=sth;else var closed=0;
      if(closed)
       {var _hz_=msg_to_jv_array(msg);
        return call$0(c[1],cst_groupCollapsed,_hz_)}
      var _hA_=msg_to_jv_array(msg);
      return call$0(c[1],cst_group,_hA_)}
    function count(label){return call$0(c[1],cst_count,[0,label])}
    function count_reset(label){return call$0(c[1],cst_countReset,[0,label])}
    function time$1(label){return call$0(c[1],cst_time,[0,label])}
    function time_log(label,msg)
     {var _hy_=msg_to_jv_array([0,label,msg]);
      return call$0(c[1],cst_timeLog,_hy_)}
    function time_end(label){return call$0(c[1],cst_timeEnd,[0,label])}
    function profile(label){return call$0(c[1],cst_profile,[0,label])}
    function profile_end(label){return call$0(c[1],cst_profileEnd,[0,label])}
    function time_stamp(label){return call$0(c[1],cst_timeStamp$0,[0,label])}
    function log_result(opt,_hx_,r)
     {if(opt)var sth=opt[1],ok=sth;else var ok=function(v){return [0,v,0]};
      if(_hx_)
       var sth$0=_hx_[1],err=sth$0;
      else
       var err=function(e){return [0,str(e),0]};
      if(0 === r[0])
       {var v=r[1];log(caml_call1(ok,v))}
      else
       {var e=r[1];error$2(caml_call1(err,e))}
      return r}
    function log_if_error(opt,_hw_,use,param)
     {if(opt)var sth=opt[1],l=sth;else var l=error$2;
      if(_hw_)
       var sth$0=_hw_[1],error_msg=sth$0;
      else
       var error_msg=function(e){return [0,str(e),0]};
      if(0 === param[0]){var v=param[1];return v}
      var e=param[1];
      caml_call1(l,caml_call1(error_msg,e));
      return use}
    function log_if_error$0(l,error_msg,use,r)
     {return [0,log_if_error(l,error_msg,use,r)]}
    function as_target$0(w){return w}
    function closed(w){return caml_call2(Bool[2],w,cst_closed)}
    function scroll_x$0(w){return caml_call2(Float[2],w,cst_scrollX)}
    function scroll_y$0(w){return caml_call2(Float[2],w,cst_scrollY)}
    function device_pixel_ratio(w)
     {return caml_call2(Float[2],w,cst_devicePixelRatio)}
    function matches_media(w,s)
     {var o=w.matchMedia(s);return caml_call2(Bool[2],o,cst_matches)}
    function prefers_dark_color_scheme(w)
     {return matches_media(w,"(prefers-color-scheme: dark)")}
    function close$0(w){w.close();return 0}
    function print(w){w.print();return 0}
    function reload(w){w.location.reload();return 0}
    function location$0(w){return new url(w.location)}
    function set_location(w,u){return w.location = u}
    var auto$0="auto",manual="manual",Scroll_restoration=[0,auto$0,manual];
    function length$3(h){return caml_call2(Int[2],h,cst_length$2)}
    function scroll_restoration(h)
     {return caml_call2(_d_[2],h,cst_scrollRestoration)}
    function set_scroll_restoration(h,r)
     {return caml_call3(_d_[3],h,cst_scrollRestoration$0,r)}
    function back(h){h.back();return 0}
    function forward(h){h.forward();return 0}
    function go(h,d){h.go(d);return 0}
    function state(h){return h.state}
    function push_state(opt,_hv_,_hu_,h)
     {if(opt)var sth=opt[1],state=sth;else var state=null$0;
      if(_hv_)var sth$0=_hv_[1],title=sth$0;else var title=empty;
      if(_hu_)var sth$1=_hu_[1],uri=sth$1;else var uri=null$0;
      h.pushState(state,title,uri);
      return 0}
    function replace_state(opt,_ht_,_hs_,h)
     {if(opt)var sth=opt[1],state=sth;else var state=null$0;
      if(_ht_)var sth$0=_ht_[1],title=sth$0;else var title=empty;
      if(_hs_)var sth$1=_hs_[1],uri=sth$1;else var uri=null$0;
      h.replaceState(state,title,uri);
      return 0}
    function state$0(e){return e.state}
    var
     Popstate=[0,state$0],
     popstate="popstate",
     Ev=[0,Popstate,popstate],
     History=
      [0,
       Scroll_restoration,
       length$3,
       scroll_restoration,
       set_scroll_restoration,
       back,
       forward,
       go,
       state,
       push_state,
       replace_state,
       Ev];
    function history(w){return w.history}
    var
     Window=
      [0,
       as_target$0,
       closed,
       scroll_x$0,
       scroll_y$0,
       device_pixel_ratio,
       matches_media,
       prefers_dark_color_scheme,
       close$0,
       print,
       reload,
       location$0,
       set_location,
       History,
       history];
    function languages(n)
     {var match=find(n,cst_languages);
      if(match){var a=match[1];return caml_list_of_js_array(a)}
      var match$0=caml_call2(_d_[1],n,cst_language);
      if(match$0){var v=match$0[1];return [0,v,0]}
      return 0}
    function max_touch_points(n){var t=n.maxTouchPoints;return is_none(t)?0:t}
    function online(n){return caml_call2(Bool[2],n,cst_onLine)}
    var
     Navigator=[0,languages,max_touch_points,online],
     frame="frame",
     navigation="navigation",
     resource="resource",
     mark$1="mark",
     measure="measure",
     paint="paint",
     longtask="longtask",
     Type$0=[0,frame,navigation,resource,mark$1,measure,paint,longtask];
    function name$4(e){return caml_call2(_d_[2],e,cst_name$1)}
    function type$6(e){return caml_call2(_d_[2],e,cst_entryType)}
    function start_time(e){return caml_call2(Float[2],e,cst_startTime)}
    function end_time(e){return caml_call2(Float[2],e,cst_endTime)}
    function duration(e){return caml_call2(Float[2],e,cst_duration)}
    function to_json(e){return e.toJSON()}
    function as_entry(_hr_){return _hr_}
    function initiator_type(e){return caml_call2(_d_[2],e,cst_initiatorType)}
    function next_hop_protocol(e)
     {return caml_call2(_d_[2],e,cst_nextHopProtocol)}
    function worker_start(e){return caml_call2(Float[2],e,cst_workerStart)}
    function redirect_start(e)
     {return caml_call2(Float[2],e,cst_redirectStart)}
    function redirect_end(e){return caml_call2(Float[2],e,cst_redirectEnd)}
    function fetch_start(e){return caml_call2(Float[2],e,cst_fetchStart)}
    function domain_lookup_start(e)
     {return caml_call2(Float[2],e,cst_domainLookupStart)}
    function domain_lookup_end(e)
     {return caml_call2(Float[2],e,cst_domainLookupEnd)}
    function connect_start(e){return caml_call2(Float[2],e,cst_connectStart)}
    function connect_end(e){return caml_call2(Float[2],e,cst_connectEnd)}
    function secure_connection_start(e)
     {return caml_call2(Float[2],e,cst_secureConnectionStart)}
    function request_start(e){return caml_call2(Float[2],e,cst_requestStart)}
    function response_start(e)
     {return caml_call2(Float[2],e,cst_responseStart)}
    function response_end(e){return caml_call2(Float[2],e,cst_responseEnd)}
    function transfer_size(e){return caml_call2(Int[2],e,cst_transferSize)}
    function encoded_body_size(e)
     {return caml_call2(Int[2],e,cst_encodedBodySize)}
    function decoded_body_size(e)
     {return caml_call2(Int[2],e,cst_decodedBodySize)}
    var
     Resource_timing=
      [0,
       as_entry,
       initiator_type,
       next_hop_protocol,
       worker_start,
       redirect_start,
       redirect_end,
       fetch_start,
       domain_lookup_start,
       domain_lookup_end,
       connect_start,
       connect_end,
       secure_connection_start,
       request_start,
       response_start,
       response_end,
       transfer_size,
       encoded_body_size,
       decoded_body_size],
     navigate="navigate",
     reload$0="reload",
     back_forward="back_forward",
     prerender="prerender",
     Type$1=[0,navigate,reload$0,back_forward,prerender];
    function as_resource_timing(_hq_){return _hq_}
    function as_entry$0(_hp_){return _hp_}
    function unload_event_start(e)
     {return caml_call2(Float[2],e,cst_unloadEventStart)}
    function unload_event_end(e)
     {return caml_call2(Float[2],e,cst_unloadEventEnd)}
    function dom_interactive(e)
     {return caml_call2(Float[2],e,cst_domInteractive)}
    function dom_content_loaded_event_start(e)
     {return caml_call2(Float[2],e,cst_domContentLoadedEventStart)}
    function dom_content_loaded_event_end(e)
     {return caml_call2(Float[2],e,cst_domContentLoadedEventEnd)}
    function dom_complete(e){return caml_call2(Float[2],e,cst_domComplete)}
    function load_event_start(e)
     {return caml_call2(Float[2],e,cst_loadEventStart)}
    function load_event_end(e){return caml_call2(Float[2],e,cst_loadEventEnd)}
    function type$7(e){return caml_call2(_d_[2],e,cst_type$3)}
    function redirect_count(e){return caml_call2(Int[2],e,cst_redirectCount)}
    function as_resource_timing$0(_ho_){return _ho_}
    function as_navigation_timing(_hn_){return _hn_}
    function time_origin_ms(p){return caml_call2(Float[2],p,cst_timeOrigin)}
    function clear_marks(p,n)
     {if(n)var n$0=n[1],args=[0,n$0];else var args=[0];
      caml_js_meth_call(p,cst_clearMarks,args);
      return 0}
    function clear_measures(p,n)
     {if(n)var n$0=n[1],args=[0,n$0];else var args=[0];
      caml_js_meth_call(p,cst_clearMeasures,args);
      return 0}
    function clear_resource_timings(p){p.clearResourceTimings();return 0}
    function get_entries(match,name,p)
     {if(name)
       {var _he_=name[1];
        if(match)
         {var t=match[1],_hf_=p.getEntriesByName(_he_,t);
          return to_list(function(_hm_){return _hm_},_hf_)}
        var _hg_=p.getEntriesByName(_he_);
        return to_list(function(_hl_){return _hl_},_hg_)}
      if(match)
       {var t$0=match[1],_hh_=p.getEntriesByType(t$0);
        return to_list(function(_hk_){return _hk_},_hh_)}
      var _hi_=p.getEntries();
      return to_list(function(_hj_){return _hj_},_hi_)}
    function mark$2(p,n){p.mark(n);return 0}
    function measure$0(start,match,p,n)
     {if(start)
       {var _hd_=start[1];
        if(match){var e=match[1];p.measure(_hd_,e);return 0}
        p.measure(_hd_);
        return 0}
      if(match){var e$0=match[1];p.measure(fn,e$0);return 0}
      p.measure();
      return 0}
    function now_ms(p){return p.now()}
    function to_json$0(p){return p.toJSON()}
    var
     console=target.console,
     navigator=target.navigator,
     performance=target.performance,
     window=target.window,
     is_secure_context=caml_call2(Bool[2],target,cst_isSecureContext);
    function set_timeout(ms,f){return target.setTimeout(f,ms)}
    function set_interval(ms,f){return target.setInterval(f,ms)}
    function stop_timer(tid){target.clearTimeout(tid);return 0}
    function request_animation_frame(f)
     {return target.requestAnimationFrame(f)}
    function cancel_animation_frame(fid)
     {target.cancelAnimationFrame(fid);return 0}
    var
     _bm_=
      [0,
       console,
       document,
       navigator,
       performance,
       window,
       target,
       is_secure_context,
       set_timeout,
       set_interval,
       stop_timer,
       request_animation_frame,
       cancel_animation_frame],
     _bn_=
      [0,
       v$2,
       txt,
       txt$0,
       sp$0,
       nbsp,
       is_txt,
       is_el,
       tag_name,
       has_tag_name,
       txt_text,
       document$0,
       find_by_class,
       find_by_tag_name,
       children,
       set_children,
       prepend_children,
       append_children,
       insert_siblings,
       remove$0,
       at,
       set_at,
       [0,
        bool,
        int$1,
        float$0,
        jstr,
        checked$1,
        height$2,
        id$2,
        name$3,
        title$1,
        value$1,
        width$2],
       prop,
       set_prop,
       class$2,
       set_class,
       Style,
       computed_style,
       inline_style,
       set_inline_style,
       inner_x,
       inner_y,
       inner_w,
       inner_h,
       bound_x,
       bound_y,
       bound_w,
       bound_h,
       scroll_x,
       scroll_y,
       scroll_w,
       scroll_h,
       scroll_into_view,
       has_focus,
       set_has_focus,
       is_locking_pointer,
       request_pointer_lock,
       Navigation_ui,
       fullscreen_opts,
       request_fullscreen,
       click$0,
       select_text,
       Input$0,
       Name,
       a$0,
       abbr$0,
       address$0,
       area$0,
       article$0,
       aside$0,
       audio$0,
       b$0,
       base$0,
       bdi$0,
       bdo$0,
       blockquote$0,
       body$0,
       br$0,
       button$1,
       canvas$0,
       caption$0,
       cite$0,
       code$2,
       col$0,
       colgroup$0,
       command$0,
       datalist$0,
       dd$0,
       del$0,
       details$0,
       dfn$0,
       div$0,
       dl$0,
       dt$0,
       em$0,
       embed$0,
       fieldset$0,
       figcaption$0,
       figure$0,
       footer$0,
       form$0,
       h1$0,
       h2$0,
       h3$0,
       h4$0,
       h5$0,
       h6$0,
       head$0,
       header$0,
       hgroup$0,
       hr$0,
       html$0,
       i$0,
       iframe$0,
       img$0,
       input$1,
       ins$0,
       kbd$0,
       keygen$0,
       label$0,
       legend$0,
       li$0,
       link$1,
       map$2,
       mark$0,
       menu$0,
       meta$0,
       meter$0,
       nav$0,
       noscript$0,
       object$0,
       ol$0,
       optgroup$0,
       option$0,
       output$0,
       p$0,
       param$0,
       pre$0,
       progress$1,
       q$0,
       rp$0,
       rt$0,
       ruby$0,
       s$0,
       samp$0,
       script$0,
       section$0,
       select$1,
       small$0,
       source$0,
       span$0,
       strong$0,
       style$0,
       sub$2,
       summary$0,
       sup$0,
       table$0,
       tbody$0,
       td$0,
       textarea$0,
       tfoot$0,
       th$0,
       thead$0,
       time$0,
       title$3,
       tr$0,
       track$0,
       u$0,
       ul$0,
       var$1,
       video$0,
       wbr$0],
     _bo_=[0,init$1,of_blob,name$0,last_modified_ms],
     Brr=
      [0,
       [0,
        [0,create$3,byte_length,slice$0],
        [0,
         of_buffer,
         buffer,
         byte_offset,
         byte_length$0,
         get_int8,
         get_int16_be,
         get_int16_le,
         get_int32_be,
         get_int32_le,
         get_uint8,
         get_uint16_be,
         get_uint16_le,
         get_uint32_be,
         get_uint32_le,
         get_float32_be,
         get_float32_le,
         get_float64_be,
         get_float64_le,
         set_int8,
         set_int16_be,
         set_int16_le,
         set_int32_be,
         set_int32_le,
         set_uint8,
         set_uint16_be,
         set_uint16_le,
         set_uint32_be,
         set_uint32_le,
         set_float32_be,
         set_float32_le,
         set_float64_be,
         set_float64_le],
        type_size_in_bytes,
        create$4,
        of_buffer$0,
        buffer,
        byte_offset,
        byte_length$0,
        length$2,
        type$2,
        set_tarray,
        fill,
        copy_within,
        slice$1,
        sub$0,
        find$5,
        find_index,
        for_all,
        exists,
        filter,
        iter,
        map$0,
        fold_left,
        fold_right,
        reverse,
        of_tarray,
        uint8_of_buffer,
        of_int_array,
        of_float_array,
        of_jstr,
        to_jstr,
        to_int_jstr,
        to_hex_jstr,
        type_to_bigarray_kind,
        type_of_bigarray_kind],
       [0,
        Ending_type,
        init$0,
        of_jstr$0,
        of_array_buffer,
        byte_length$1,
        type$3,
        slice$2,
        array_buffer$0,
        stream,
        text,
        data_uri],
       _bo_,
       Base64,
       [0,encode$0,decode$0],
       [0,
        v$0,
        scheme,
        host,
        port,
        path,
        query,
        fragment,
        with_uri,
        [0,
         mem,
         find$6,
         find_all,
         fold$0,
         of_obj,
         of_jstr$1,
         to_jstr$0,
         of_assoc,
         to_assoc],
        encode$2,
        decode$2,
        encode_component$0,
        decode_component,
        of_jstr$2,
        to_jstr$1],
       [0,
        Type,
        init,
        create$2,
        type,
        target$0,
        current_target,
        composed_path,
        event_phase,
        bubbles,
        stop_propagation,
        stop_immediate_propagation,
        cancelable,
        prevent_default,
        default_prevented,
        composed,
        is_trusted,
        timestamp_ms,
        dispatch,
        listen_opts,
        listen,
        unlisten,
        next$0,
        [0,
         Effect,
         Item,
         [0,length$1,add_jstr,add_file,remove,clear,caml_js_get,items],
         drop_effect,
         set_drop_effect,
         effect_allowed,
         set_effect_allowed,
         items$0],
        Clipboard,
        Composition,
        Error$0,
        Extendable,
        Focus,
        Hash_change,
        Input,
        Keyboard,
        Mouse,
        Drag,
        Pointer,
        Wheel,
        abort,
        activate,
        auxclick,
        beforeinput,
        blur,
        canplay,
        canplaythrough,
        change,
        click,
        clipboardchange,
        close,
        compositionend,
        compositionstart,
        compositionudpate,
        controllerchange,
        copy$0,
        cut,
        dblclick,
        dom_content_loaded,
        drag,
        dragend,
        dragenter,
        dragexit,
        dragleave,
        dragover,
        dragstart,
        drop,
        durationchange,
        emptied,
        ended,
        error$1,
        focus,
        focusin,
        focusout,
        fullscreenchange,
        fullscreenerror,
        gotpointercapture,
        hashchange,
        input,
        install,
        keydown,
        keyup,
        languagechange,
        load,
        loadeddata,
        loadedmetadata,
        loadstart,
        lostpointercapture,
        mousedown,
        mouseenter,
        mouseleave,
        mousemove,
        mouseout,
        mouseover,
        mouseup,
        open,
        paste,
        pause,
        play,
        playing,
        pointercancel,
        pointerdown,
        pointerenter,
        pointerleave,
        pointerlockchange,
        pointerlockerror,
        pointermove,
        pointerout,
        pointerover,
        pointerrawupdate,
        pointerup,
        progress,
        ratechange,
        reset,
        resize,
        scroll,
        seeked,
        seeking,
        select,
        statechange,
        stalled,
        suspend,
        timeupdate,
        unload,
        updatefound,
        visibilitychange,
        volumechange,
        waiting,
        wheel],
       [0,
        v$1,
        true$1,
        int$0,
        add_if,
        add_if_some,
        to_pair,
        [0,
         autofocus,
         charset,
         checked,
         class$0,
         content,
         defer,
         disabled,
         for$0,
         height$0,
         href,
         id$0,
         lang,
         media,
         name$1,
         placeholder,
         rel,
         src,
         tabindex,
         title,
         type$4,
         value,
         wrap,
         width$0],
        accesskey$0,
        autofocus$0,
        charset$0,
        checked$0,
        class$1,
        content$0,
        contenteditable$0,
        cols$0,
        defer$0,
        disabled$0,
        dir$0,
        draggable$0,
        for$1,
        height$1,
        href$0,
        hidden$0,
        id$1,
        lang$0,
        media$0,
        name$2,
        placeholder$0,
        rel$0,
        rows$0,
        spellcheck$0,
        src$0,
        tabindex$0,
        title$0,
        type$5,
        value$0,
        wrap$0,
        width$1],
       _bn_,
       [0,
        as_target,
        find_el_by_id,
        find_els_by_name,
        root,
        body$1,
        head$1,
        active_el,
        referrer,
        title$4,
        set_title,
        Visibility_state,
        visibility_state,
        pointer_lock_element,
        exit_pointer_lock,
        fullscreen_available,
        fullscreen_element,
        exit_fullscreen],
       Abort,
       [0,
        get$4,
        set$3,
        clear$0,
        msg,
        str,
        log_result,
        log_if_error,
        log_if_error$0,
        log,
        trace,
        error$2,
        warn,
        info,
        debug,
        assert,
        dir$1,
        table$1,
        group,
        group_end,
        count,
        count_reset,
        time$1,
        time_log,
        time_end,
        profile,
        profile_end,
        time_stamp],
       Window,
       Navigator,
       [0,
        [0,
         Type$0,
         name$4,
         type$6,
         start_time,
         end_time,
         duration,
         to_json,
         Resource_timing,
         [0,
          Type$1,
          as_entry$0,
          as_resource_timing,
          unload_event_start,
          unload_event_end,
          dom_interactive,
          dom_content_loaded_event_start,
          dom_content_loaded_event_end,
          dom_complete,
          load_event_start,
          load_event_end,
          type$7,
          redirect_count],
         as_resource_timing$0,
         as_navigation_timing],
        time_origin_ms,
        clear_marks,
        clear_measures,
        clear_resource_timings,
        get_entries,
        mark$2,
        measure$0,
        now_ms,
        to_json$0],
       _bm_];
    caml_register_global(2918,Brr,"Brr");
    var
     unspecified="unspecified",
     inline="inline",
     attachment="attachement",
     Presentation_style=[0,unspecified,inline,attachment];
    function opts(presentation_style,param)
     {var o={};
      caml_call3(_d_[4],o,cst_presentationStyle,presentation_style);
      return o}
    var item=target.ClipboardItem;
    function create$5(opts,vs)
     {var o={};
      function add_v(param){var b=param[2],t=param[1];return o[t] = b}
      caml_call2(Stdlib_list[15],add_v,vs);
      return new item(o)}
    function presentation_style(i)
     {return caml_call2(_d_[2],i,cst_presentationStyle$0)}
    function last_modified_ms$0(i)
     {return caml_call2(Int[2],i,cst_lastModified$1)}
    function delayed(i){return caml_call2(Bool[2],i,cst_delayed)}
    function types(i){return caml_list_of_js_array(i.types)}
    function get_type(i,t)
     {var _hb_=i.getType(i,t);
      return of_promise$0(function(_hc_){return _hc_},_hb_)}
    function of_navigator(n){return n.clipboard}
    function as_target$1(_ha_){return _ha_}
    function read(c)
     {function _g9_(_g$_){return _g$_}
      function ok(_g__){return to_list(_g9_,_g__)}
      return of_promise$0(ok,c.read())}
    function read_text(c)
     {var _g7_=c.readText();
      return of_promise$0(function(_g8_){return _g8_},_g7_)}
    function write(c,data)
     {var _g4_=c.write(of_list(function(_g6_){return _g6_},data));
      return of_promise$0(function(_g5_){return 0},_g4_)}
    function write_text(c,data)
     {var _g2_=c.writeText(data);
      return of_promise$0(function(_g3_){return 0},_g2_)}
    function of_el(e)
     {return caml_call2(_bn_[9],_bn_[54][37],e)
              ?e
              :throw$0
                (0,
                 "Expected form element but found: ".concat
                  (caml_call1(_bn_[8],e)))}
    function to_el(e){return e}
    function name$5(f){return caml_call2(_d_[2],f,cst_name$2)}
    function method(f){return caml_call2(_d_[2],f,cst_method)}
    function target$1(f){return caml_call2(_d_[2],f,cst_target)}
    function action(f){return caml_call2(_d_[2],f,cst_action)}
    function enctype(f){return caml_call2(_d_[2],f,cst_enctype)}
    function accept_charset(f){return caml_call2(_d_[2],f,cst_acceptCharset)}
    function autocomplete(f){return caml_call2(_d_[2],f,cst_autocomplete)}
    function no_validate(f){return caml_call2(Bool[2],f,cst_noValidate)}
    function check_validity(f){return f.checkValidity() | 0}
    function report_validity(f){return f.reportValidity() | 0}
    function request_submit(f,el)
     {if(el)var e=el[1],args=[0,e];else var args=[0];
      caml_js_meth_call(f,cst_requestSubmit,args);
      return 0}
    function reset$0(f){f.reset();return 0}
    function submit(f){f.submit();return 0}
    var formdata=target.FormData;
    function create$6(param){return new formdata()}
    function of_form(f){return new formdata(f)}
    function mem$0(d,k){return d.has(k) | 0}
    function value$2(v)
     {var match=v instanceof target.File?1:0;
      return match?[0,781515420,v]:[0,-976970511,v]}
    function find$7(d,k){return to_option(value$2,d.get(k))}
    function find_all$0(d,k){return to_list(value$2,d.getAll(k))}
    function fold$1(f,d,acc)
     {function key(_g1_){return _g1_}
      var _g0_=d.entries();
      return caml_call5(_b_[8],key,value$2,f,_g0_,acc)}
    function set$4(d,k,v){d.set(k,v);return 0}
    function set_blob(fn$0,d,k,b)
     {if(fn$0)var f=fn$0[1],fn$1=f;else var fn$1=fn;d.set(k,b,fn$1);return 0}
    function append(d,k,v){d.append(k,v);return 0}
    function append_blob(fn$0,d,k,b)
     {if(fn$0)var f=fn$0[1],fn$1=f;else var fn$1=fn;
      d.append(k,b,fn$1);
      return 0}
    function delete$0(d,k){d.delete(k);return 0}
    function of_assoc$0(l)
     {var d=create$6(0);
      function _gZ_(param)
       {var v=param[2],k=param[1];
        if(781515420 <= v[1])
         var f=v[2],fn$0=caml_call1(_bo_[3],f),v$0=f;
        else
         var s=v[2],fn$0=fn,v$0=s;
        d.append(k,v$0,fn$0);
        return 0}
      caml_call2(Stdlib_list[15],_gZ_,l);
      return d}
    function to_assoc$0(p)
     {var
       _gX_=0,
       _gY_=fold$1(function(k,v,acc){return [0,[0,k,v],acc]},p,_gX_);
      return caml_call1(Stdlib_list[9],_gY_)}
    function form_data(e){return e.formData}
    var Data=[0,form_data],formdata$0="formdata";
    function submitter(e)
     {var _gV_=e.submitter;return to_option(function(_gW_){return _gW_},_gV_)}
    var
     Submit=[0,submitter],
     submit$0="submit",
     Ev$0=[0,Data,formdata$0,Submit,submit$0];
    function of_jstr$3(_gU_){return _gU_}
    function of_uri_params(_gT_){return _gT_}
    function of_form_data(_gS_){return _gS_}
    function of_blob$0(_gR_){return _gR_}
    function of_array_buffer$0(_gQ_){return _gQ_}
    function body_used(r){return caml_call2(Bool[2],r,cst_bodyUsed)}
    function body$2(r)
     {var _gO_=r.body;return to_option(function(_gP_){return _gP_},_gO_)}
    function array_buffer$1(r)
     {var _gM_=r.arrayBuffer();
      return of_promise$0(function(_gN_){return _gN_},_gM_)}
    function blob$0(r)
     {var _gK_=r.blob();return of_promise$0(function(_gL_){return _gL_},_gK_)}
    function form_data$0(r)
     {var _gI_=r.formData();
      return of_promise$0(function(_gJ_){return _gJ_},_gI_)}
    function json$0(r)
     {var _gG_=r.json();return of_promise$0(function(_gH_){return _gH_},_gG_)}
    function text$0(r)
     {var _gE_=r.text();return of_promise$0(function(_gF_){return _gF_},_gE_)}
    var
     Body=
      [0,
       of_jstr$3,
       of_uri_params,
       of_form_data,
       of_blob$0,
       of_array_buffer$0,
       body_used,
       body$2,
       array_buffer$1,
       blob$0,
       form_data$0,
       json$0,
       text$0],
     headers=target.Headers;
    function mem$1(h,hs){return hs.has(h) | 0}
    function find$8(h,hs)
     {var _gC_=hs.get(h);return to_option(function(_gD_){return _gD_},_gC_)}
    function fold$2(f,p,acc)
     {function key(_gB_){return _gB_}
      function value(_gA_){return _gA_}
      var _gz_=p.entries();
      return caml_call5(_b_[8],key,value,f,_gz_,acc)}
    function of_obj$0(o){return new headers(o)}
    function of_assoc$1(init,l)
     {if(init)var h=init[1],args=[0,h];else var args=[0];
      var hs=caml_js_new(headers,args);
      function _gy_(param){var v=param[2],k=param[1];hs.append(k,v);return 0}
      caml_call2(Stdlib_list[15],_gy_,l);
      return hs}
    function to_assoc$1(p)
     {var
       _gw_=0,
       _gx_=fold$2(function(k,v,acc){return [0,[0,k,v],acc]},p,_gw_);
      return caml_call1(Stdlib_list[9],_gx_)}
    var
     default$0="default",
     force_cache="force-cache",
     no_cache="no-cache",
     no_store="no-store",
     only_if_cached="only-if-cached",
     reload$1="reload",
     Cache=[0,default$0,force_cache,no_cache,no_store,only_if_cached,reload$1],
     include="include'",
     omit="omit",
     same_origin="same-origin",
     Credentials=[0,include,omit,same_origin],
     audio$1="audio",
     audioworklet="audioworklet",
     document$1="document",
     embed$1="embed",
     font="font",
     frame$0="frame",
     iframe$1="iframe",
     image="image",
     manifest="manifest",
     object$1="object'",
     paintworklet="paintworklet",
     report="report",
     script$1="script",
     sharedworker="sharedworker",
     style$1="style",
     track$1="track",
     video$1="video",
     worker="worker",
     xslt="xslt",
     Destination=
      [0,
       audio$1,
       audioworklet,
       document$1,
       embed$1,
       font,
       frame$0,
       iframe$1,
       image,
       manifest,
       object$1,
       paintworklet,
       report,
       script$1,
       sharedworker,
       style$1,
       track$1,
       video$1,
       worker,
       xslt],
     cors="cors",
     navigate$0="navigate",
     no_cors="no-cors",
     same_origin$0="same-origin",
     Mode=[0,cors,navigate$0,no_cors,same_origin$0],
     error$3="error",
     follow="follow",
     manual$0="manual",
     Redirect=[0,error$3,follow,manual$0];
    function init$2
     (body,
      cache,
      credentials,
      headers,
      integrity,
      keepalive,
      method,
      mode,
      redirect,
      referrer,
      referrer_policy,
      signal,
      param)
     {var o={};
      o.body = of_option(fn,function(_gv_){return _gv_},body);
      caml_call3(_d_[4],o,cst_cache,cache);
      caml_call3(_d_[4],o,cst_credentials,credentials);
      function _gs_(_gu_){return _gu_}
      set_if_some(o,cst_headers,caml_call2(Stdlib_option[7],_gs_,headers));
      caml_call3(_d_[4],o,cst_integrity,integrity);
      caml_call3(Bool[4],o,cst_keepalive,keepalive);
      caml_call3(_d_[4],o,cst_method$0,method);
      caml_call3(_d_[4],o,cst_mode,mode);
      caml_call3(_d_[4],o,cst_redirect,redirect);
      caml_call3(_d_[4],o,cst_referrer$0,referrer);
      caml_call3(_d_[4],o,cst_referrerPolicy,referrer_policy);
      o.signal = of_option(fn,function(_gt_){return _gt_},signal);
      return o}
    var request=target.Request;
    function v$3(opt,url)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new request(url,init)}
    function of_request(init,r)
     {if(init){var init$0=init[1];return new request(r,init$0)}
      return r.clone()}
    function cache(r){return caml_call2(_d_[2],r,cst_cache$0)}
    function credentials(r){return caml_call2(_d_[2],r,cst_credentials$0)}
    function destination(r){return caml_call2(_d_[2],r,cst_destination)}
    function headers$0(r){return r.headers}
    function integrity(r){return caml_call2(_d_[2],r,cst_integrity$0)}
    function is_history_navigation(r)
     {return caml_call2(Bool[2],r,cst_isHistoryNavigation)}
    function is_reload_navigation(r)
     {return caml_call2(Bool[2],r,cst_isReloadNavigation)}
    function keepalive(r){return caml_call2(Bool[2],r,cst_keepalive$0)}
    function method$0(r){return caml_call2(_d_[2],r,cst_method$1)}
    function mode(r){return caml_call2(_d_[2],r,cst_mode$0)}
    function redirect(r){return caml_call2(_d_[2],r,cst_redirect$0)}
    function referrer$0(r){return caml_call2(_d_[2],r,cst_referrer$1)}
    function referrer_policy(r)
     {return caml_call2(_d_[2],r,cst_referrerPolicy$0)}
    function signal$0(r)
     {var _gq_=r.signal;return to_option(function(_gr_){return _gr_},_gq_)}
    function url$0(r){return caml_call2(_d_[2],r,cst_url)}
    var
     basic="basic",
     cors$0="cors",
     default$1="default",
     error$4="error",
     opaque="opaque",
     opaqueredirect="opaqueredirect",
     Type$2=[0,basic,cors$0,default$1,error$4,opaque,opaqueredirect];
    function init$3(headers,status,status_text,param)
     {var o={};
      function _go_(_gp_){return _gp_}
      set_if_some(o,cst_headers$0,caml_call2(Stdlib_option[7],_go_,headers));
      caml_call3(Int[4],o,cst_status,status);
      caml_call3(_d_[4],o,cst_statusText,status_text);
      return o}
    var response=target.Response;
    function v$4(opt,body,param)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      var body$0=of_option(null$0,function(_gn_){return _gn_},body);
      return new response(body$0,init)}
    function of_response(r){return r.clone()}
    function error$5(param){return response.error()}
    function redirect$0(status,url)
     {if(status)
       var status$0=status[1],args=[0,url,status$0];
      else
       var args=[0,url];
      return caml_js_meth_call(response,cst_redirect$1,args)}
    function headers$1(r){return r.headers}
    function ok$0(r){return caml_call2(Bool[2],r,cst_ok)}
    function redirected(r){return caml_call2(Bool[2],r,cst_redirected)}
    function status(r){return caml_call2(Int[2],r,cst_status$0)}
    function status_text(r){return caml_call2(_d_[2],r,cst_statusText$0)}
    function url$1(r){return caml_call2(_d_[2],r,cst_url$0)}
    function query_opts
     (ignore_search,ignore_method,ignore_vary,cache_name,param)
     {var o={};
      caml_call3(Bool[4],o,cst_ignoreSearch,ignore_search);
      caml_call3(Bool[4],o,cst_ignoreMethod,ignore_method);
      caml_call3(Bool[4],o,cst_ignoreVary,ignore_vary);
      caml_call3(_d_[4],o,cst_cacheName,cache_name);
      return o}
    function match(opt,c,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      function _gk_(_gm_){return _gm_}
      function ok(_gl_){return to_option(_gk_,_gl_)}
      return of_promise$0(ok,c.match(req,query_opts))}
    function match_all(opt,c,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      function _gh_(_gj_){return _gj_}
      function ok(_gi_){return to_list(_gh_,_gi_)}
      return of_promise$0(ok,c.matchAll(req,query_opts))}
    function add(c,req)
     {var _gf_=c.add(req);return of_promise$0(function(_gg_){return 0},_gf_)}
    function add_all(c,reqs)
     {var _gc_=c.addAll(of_list(function(_ge_){return _ge_},reqs));
      return of_promise$0(function(_gd_){return 0},_gc_)}
    function put(c,req,resp)
     {var _ga_=c.put(req,resp);
      return of_promise$0(function(_gb_){return 0},_ga_)}
    function delete$1(opt,c,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      return of_promise$0(caml_js_to_bool,c.delete(req,query_opts))}
    function keys(opt,_f7_,c)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      if(_f7_)var sth$0=_f7_[1],req=sth$0;else var req=fn;
      var _f8_=c.keys(req,query_opts);
      function _f9_(_f$_){return _f$_}
      return of_promise$0(function(_f__){return to_list(_f9_,_f__)},_f8_)}
    function match$0(opt,s,req)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      function _f4_(_f6_){return _f6_}
      function ok(_f5_){return to_option(_f4_,_f5_)}
      return of_promise$0(ok,s.match(req,query_opts))}
    function has$0(s,n){return of_promise$0(caml_js_to_bool,s.has(n))}
    function open$0(s,n)
     {var _f2_=s.open(n);
      return of_promise$0(function(_f3_){return _f3_},_f2_)}
    function delete$2(s,n){return of_promise$0(caml_js_to_bool,s.delete(n))}
    function keys$0(s){return of_promise$0(caml_list_of_js_array,s.keys())}
    var
     Storage=[0,match$0,has$0,open$0,delete$2,keys$0],
     Cache$0=
      [0,query_opts,match,match_all,add,add_all,put,delete$1,keys,Storage],
     fetch="fetch";
    function as_extendable(_f1_){return _f1_}
    function request$0(e){return e.request}
    function preload_response(e)
     {function _fY_(_f0_){return _f0_}
      function ok(_fZ_){return to_option(_fY_,_fZ_)}
      return of_promise$0(ok,e.preloadReponse)}
    function client_id(e){return caml_call2(_d_[2],e,cst_clientId)}
    function resulting_client_id(e)
     {return caml_call2(_d_[2],e,cst_resultingClientId)}
    function replaces_client_id(e)
     {return caml_call2(_d_[2],e,cst_replacesClientId)}
    function handled(e)
     {var _fW_=e.handled;return of_promise$0(function(_fX_){return 0},_fW_)}
    function respond_with(e,fut)
     {e.respondWith(to_promise$0(function(_fV_){return _fV_},fut));return 0}
    var
     Ev$1=
      [0,
       fetch,
       as_extendable,
       request$0,
       preload_response,
       client_id,
       resulting_client_id,
       replaces_client_id,
       handled,
       respond_with],
     fetch$0=target.fetch;
    function url$2(opt,url)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      var _fT_=fetch$0(url,init);
      return of_promise$0(function(_fU_){return _fU_},_fT_)}
    function request$1(r)
     {var _fR_=fetch$0(r);
      return of_promise$0(function(_fS_){return _fS_},_fR_)}
    var
     caches=target.caches,
     permission_denied=1,
     position_unavailable=2,
     timeout=3;
    function code$3(e){return caml_call2(Int[2],e,cst_code$0)}
    function message$1(e){return caml_call2(_d_[2],e,cst_message$0)}
    var
     Error$1=
      [0,permission_denied,position_unavailable,timeout,code$3,message$1];
    function latitude(p){return caml_call2(Float[2],p.coords,cst_latitude)}
    function longitude(p){return caml_call2(Float[2],p.coords,cst_longitude)}
    function altitude(p){return caml_call2(Float[1],p.coords,cst_altitude)}
    function accuracy(p){return caml_call2(Float[2],p.coords,cst_accuracy)}
    function altitude_accuracy(p)
     {return caml_call2(Float[1],p.coords,cst_altitudeAccuracy)}
    function heading(p){return caml_call2(Float[1],p.coords,cst_heading)}
    function speed(p){return caml_call2(Float[1],p.coords,cst_speed)}
    function timestamp_ms$0(p){return caml_call2(Float[2],p,cst_timestamp)}
    function of_navigator$0(n){return n.geolocation}
    function opts$0(high_accuracy,timeout_ms,maximum_age_ms,param)
     {var o={};
      caml_call3(Bool[4],o,cst_enableHighAccuracy,high_accuracy);
      caml_call3(Int[4],o,cst_timeout,timeout_ms);
      caml_call3(Int[4],o,cst_maximumAge,maximum_age_ms);
      return o}
    function get$5(opts,l)
     {var match=create$1(0),set_fut=match[2],fut=match[1];
      function pos(p){return caml_call1(set_fut,[0,p])}
      function error(e){return caml_call1(set_fut,[1,e])}
      var opts$0=of_option(fn,function(_fQ_){return _fQ_},opts);
      l.getCurrentPosition(pos,error,opts$0);
      return fut}
    function watch(opts,l,f)
     {function pos(p){return caml_call1(f,[0,p])}
      function error(e){return caml_call1(f,[1,e])}
      var opts$0=of_option(fn,function(_fP_){return _fP_},opts);
      return l.watchPosition(pos,error,opts$0)}
    function unwatch(l,id){l.clearWatch(id);return 0}
    function v$5(exact,ideal,param)
     {var o={};
      caml_call3(Bool[4],o,cst_exact,exact);
      caml_call3(Bool[4],o,cst_ideal,ideal);
      return o}
    var Constraint=[0,v$5],Bool$0=[0,Constraint];
    function v$6(min,max,param)
     {var o={};
      caml_call3(Int[4],o,cst_min,min);
      caml_call3(Int[4],o,cst_max,max);
      return o}
    function min(r){return caml_call2(Int[1],r,cst_min$0)}
    function max(r){return caml_call2(Int[1],r,cst_max$0)}
    var Range=[0,v$6,min,max];
    function v$7(min,max,exact,ideal,param)
     {var o={};
      caml_call3(Int[4],o,cst_min$1,min);
      caml_call3(Int[4],o,cst_max$1,max);
      caml_call3(Int[4],o,cst_exact$0,exact);
      caml_call3(Int[4],o,cst_ideal$0,ideal);
      return o}
    var Constraint$0=[0,v$7],Int$0=[0,Range,Constraint$0];
    function v$8(min,max,param)
     {var o={};
      caml_call3(Float[4],o,cst_min$2,min);
      caml_call3(Float[4],o,cst_max$2,max);
      return o}
    function min$0(r){return caml_call2(Float[1],r,cst_min$3)}
    function max$0(r){return caml_call2(Float[1],r,cst_max$3)}
    var Range$0=[0,v$8,min$0,max$0];
    function v$9(min,max,exact,ideal,param)
     {var o={};
      caml_call3(Float[4],o,cst_min$4,min);
      caml_call3(Float[4],o,cst_max$4,max);
      caml_call3(Float[4],o,cst_exact$1,exact);
      caml_call3(Float[4],o,cst_ideal$1,ideal);
      return o}
    var Constraint$1=[0,v$9],Float$0=[0,Range$0,Constraint$1];
    function v$10(exact,ideal,param)
     {var o={};
      set_if_some
       (o,
        cst_exact$2,
        caml_call2(Stdlib_option[7],caml_list_to_js_array,exact));
      set_if_some
       (o,
        cst_ideal$2,
        caml_call2(Stdlib_option[7],caml_list_to_js_array,ideal));
      return o}
    var Constraint$2=[0,v$10],Jstr$0=[0,Constraint$2];
    function v$11(name,param,_fO_,_fN_)
     {var
       constr_of_jv=_fN_[2],
       constr_to_jv=_fN_[1],
       cap_of_jv=_fO_[2],
       cap_to_jv=_fO_[1],
       value_of_jv=param[2],
       value_to_jv=param[1];
      return [0,
              name,
              value_to_jv,
              value_of_jv,
              cap_to_jv,
              cap_of_jv,
              constr_to_jv,
              constr_of_jv]}
    function name$6(p){return p[1]}
    function value_to_jv(p){return p[2]}
    function value_of_jv(p){return p[3]}
    function cap_to_jv(p){return p[4]}
    function cap_of_jv(p){return p[5]}
    function constr_to_jv(p){return p[6]}
    function constr_of_jv(p){return p[7]}
    function bool$0(name)
     {var
       value_conv=[0,caml_js_from_bool,caml_js_to_bool],
       _fF_=caml_js_to_bool;
      function _fG_(_fM_){return to_list(_fF_,_fM_)}
      var
       _fH_=caml_js_from_bool,
       cap_conv=[0,function(_fL_){return of_list(_fH_,_fL_)},_fG_];
      function _fI_(_fK_){return _fK_}
      var constr_conv=[0,function(_fJ_){return _fJ_},_fI_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function int$2(name)
     {function _fw_(_fE_){return _fE_}
      var value_conv=[0,function(_fD_){return _fD_},_fw_];
      function _fx_(_fC_){return _fC_}
      var cap_conv=[0,function(_fB_){return _fB_},_fx_];
      function _fy_(_fA_){return _fA_}
      var constr_conv=[0,function(_fz_){return _fz_},_fy_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function float$1(name)
     {function _fn_(_fv_){return _fv_}
      var value_conv=[0,function(_fu_){return _fu_},_fn_];
      function _fo_(_ft_){return _ft_}
      var cap_conv=[0,function(_fs_){return _fs_},_fo_];
      function _fp_(_fr_){return _fr_}
      var constr_conv=[0,function(_fq_){return _fq_},_fp_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function jstr$0(name)
     {function _fh_(_fm_){return _fm_}
      var value_conv=[0,function(_fl_){return _fl_},_fh_];
      function _fi_(_fk_){return _fk_}
      var constr_conv=[0,function(_fj_){return _fj_},_fi_];
      return v$11(name,value_conv,value_conv,constr_conv)}
    function jstr_enum(name)
     {function _fb_(_fg_){return _fg_}
      var
       value_conv=[0,function(_ff_){return _ff_},_fb_],
       cap_conv=[0,caml_list_to_js_array,caml_list_of_js_array];
      function _fc_(_fe_){return _fe_}
      var constr_conv=[0,function(_fd_){return _fd_},_fc_];
      return v$11(name,value_conv,cap_conv,constr_conv)}
    function mem$2(p,cs){var mem=cs[p[1]];return is_none(mem)?0:mem | 0}
    function names(cs){return caml_list_of_js_array(target.Object.keys(cs))}
    var Supported_constraints=[0,mem$2,names];
    function empty$0(param){return {}}
    function find$9(p,c){return find_map$0(p[7],c,p[1])}
    function set$5(p,v,c){var _fa_=caml_call1(p[6],v);return c[p[1]] = _fa_}
    function delete$3(p,c){return delete c[p[1]]}
    var Constraints=[0,empty$0,find$9,set$5,delete$3];
    function find$10(p,s){return find_map$0(p[5],s,p[1])}
    function set$6(p,v,s){var _e$_=caml_call1(p[4],v);return s[p[1]] = _e$_}
    function delete$4(p,s){return delete s[p[1]]}
    var Capabilities=[0,find$10,set$6,delete$4];
    function get$6(p,s){return caml_call1(p[3],s[p[1]])}
    function find$11(p,s){return find_map$0(p[3],s,p[1])}
    var
     Settings=[0,get$6,find$11],
     aspect_ratio=float$1("aspectRatio"),
     auto_gain_control=bool$0("autoGainControl"),
     channel_count=int$2("channelCount"),
     cursor$0=jstr_enum("cursor"),
     device_id=jstr$0("deviceId"),
     display_surface=jstr_enum("displaySurface"),
     echo_cancellation=bool$0("echoCancellation"),
     facing_mode=jstr_enum("facingMode"),
     frame_rate=float$1("frameRate"),
     group_id=jstr$0("groupId"),
     height$4=int$2("height"),
     latency=float$1("latency"),
     logical_surface=bool$0("logicalSurface"),
     noise_suppresion=bool$0("noiseSuppresion"),
     resize_mode=jstr_enum("resizeMode"),
     sample_rate=int$2("sampleRate"),
     sample_size=int$2("sampleSize"),
     width$4=int$2("width"),
     Prop=
      [0,
       aspect_ratio,
       auto_gain_control,
       channel_count,
       cursor$0,
       device_id,
       display_surface,
       echo_cancellation,
       facing_mode,
       frame_rate,
       group_id,
       height$4,
       latency,
       logical_surface,
       noise_suppresion,
       resize_mode,
       sample_rate,
       sample_size,
       width$4],
     live="live",
     ended$0="ended",
     State=[0,live,ended$0],
     audio$2="audio",
     video$2="video",
     Kind$0=[0,audio$2,video$2];
    function id$3(t){return caml_call2(_d_[2],t,cst_id)}
    function isolated(t){return caml_call2(Bool[2],t,cst_isolated)}
    function kind$0(t){return caml_call2(_d_[2],t,cst_kind$0)}
    function label$1(t){return caml_call2(_d_[2],t,cst_label)}
    function muted(t){return caml_call2(Bool[2],t,cst_muted)}
    function ready_state(t){return caml_call2(_d_[2],t,cst_readyState)}
    function enabled(t){return caml_call2(Bool[2],t,cst_enabled)}
    function set_enabled(t,b){return caml_call3(Bool[3],t,cst_enabled$0,b)}
    function get_capabilities(t){return t.getCapabilities()}
    function get_constraints(t){return t.getConstraints()}
    function apply_constraints(t,c)
     {if(c)var c$0=c[1],a=[0,c$0];else var a=[0];
      var _e__=caml_js_meth_call(t,cst_applyConstraints,a);
      return of_promise$0(caml_call1(Stdlib_fun[1],0),_e__)}
    function get_settings(t){return t.getSettings()}
    function stop(t){t.stop();return 0}
    function clone(t){return t.clone()}
    var
     ended$1="ended",
     isolationchange="isolationchange",
     mute="mute",
     unmute="unmute";
    function track$2(p){return p.track}
    function v$12(opt,_e8_,param)
     {if(opt)var sth=opt[1],audio=sth;else var audio=17505;
      if(_e8_)var sth$0=_e8_[1],video=sth$0;else var video=17505;
      var o={};
      function set_track(o,n,param)
       {if(typeof param === "number")return caml_call3(Bool[3],o,n,0);
        var _e9_=param[2];
        if(_e9_){var c=_e9_[1];return o[n] = c}
        return caml_call3(Bool[3],o,n,1)}
      set_track(o,cst_audio,audio);
      set_track(o,cst_video,video);
      return o}
    function av(param){return v$12(_bq_,_bp_,0)}
    var Constraints$0=[0,v$12,av],stream$0=target.MediaStream;
    function create$7(param){return new stream$0()}
    function of_stream(s){return new stream$0(s)}
    function of_tracks(ts)
     {return new stream$0(of_list(function(_e7_){return _e7_},ts))}
    function id$4(s){return caml_call2(_d_[2],s,cst_id$0)}
    function active(s){return caml_call2(Bool[2],s,cst_active)}
    function get_audio_tracks(s)
     {var _e5_=s.getAudioTracks();
      return to_list(function(_e6_){return _e6_},_e5_)}
    function get_video_tracks(s)
     {var _e3_=s.getVideoTracks();
      return to_list(function(_e4_){return _e4_},_e3_)}
    function get_tracks(s)
     {var _e1_=s.getTracks();return to_list(function(_e2_){return _e2_},_e1_)}
    function get_track_by_id(s,id)
     {var _eZ_=s.getTrackById(id);
      return to_option(function(_e0_){return _e0_},_eZ_)}
    function add_track(s,t){s.addTrack(t);return 0}
    function remove_track(s,t){s.removeTrack(t);return 0}
    function clone$0(s){return s.clone()}
    var
     addtrack="addtrack",
     removetrack="removetrack",
     Ev$2=[0,addtrack,removetrack],
     cbr="cbr",
     vbr="vbr",
     Bitrate_mode=[0,cbr,vbr],
     inactive="inactive",
     recording="recording",
     paused="paused",
     Recording_state=[0,inactive,recording,paused];
    function init$4(type,audio_bps,video_bps,bps,audio_bitrate_mode,param)
     {var o={};
      caml_call3(_d_[4],o,cst_mimeType,type);
      caml_call3(Int[4],o,cst_audioBitsPerSecond,audio_bps);
      caml_call3(Int[4],o,cst_videoBitsPerSecond,video_bps);
      caml_call3(Int[4],o,cst_bitsPerSecond,bps);
      caml_call3(_d_[4],o,cst_audioBitrateMode,audio_bitrate_mode);
      return o}
    var recorder=target.MediaRecorder;
    function is_type_supported(t){return recorder.isTypeSupported(t) | 0}
    function create$8(opt,s)
     {if(opt)var sth=opt[1],init=sth;else var init={};
      return new recorder(s,init)}
    function stream$1(r){return r.stream}
    function type$8(r){return caml_call2(_d_[2],r,cst_mimeType$0)}
    function state$1(r){return caml_call2(_d_[2],r,cst_state)}
    function video_bps(r)
     {return caml_call2(Int[2],r,cst_videoBitsPerSecond$0)}
    function audio_bps(r)
     {return caml_call2(Int[2],r,cst_audioBitsPerSecond$0)}
    function audio_bitrate_mode(r)
     {return caml_call2(_d_[2],r,cst_audioBitrateMode$0)}
    function start(r,ts)
     {if(ts)var ms=ts[1],args=[0,ms];else var args=[0];
      try
       {caml_js_meth_call(r,cst_start,args);return _br_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function stop$0(r){r.stop();return 0}
    function pause$0(r){r.pause();return 0}
    function resume(r){r.resume();return 0}
    function request_data(r){r.requestData();return 0}
    function data$2(e){return e.data}
    function timecode(e){return caml_call2(Float[2],e,cst_timecode)}
    var Blob=[0,data$2,timecode];
    function error$6(e){return e.error}
    var
     Error$2=[0,error$6],
     start$0="start",
     stop$1="stop",
     dataavailable="dataavailable",
     pause$1="pause",
     resume$0="resume",
     error$7="error",
     Ev$3=
      [0,Blob,Error$2,start$0,stop$1,dataavailable,pause$1,resume$0,error$7],
     audioinput="audioinput",
     audiooutput="audiooutput",
     videoinput="videoinput",
     Kind$1=[0,audioinput,audiooutput,videoinput];
    function device_id$0(d){return caml_call2(_d_[2],d,cst_deviceId)}
    function kind$1(d){return caml_call2(_d_[2],d,cst_kind$1)}
    function label$2(d){return caml_call2(_d_[2],d,cst_label$0)}
    function group_id$0(d){return caml_call2(_d_[2],d,cst_groupId)}
    function to_json$1(d){return d.toJSON()}
    var
     Info=[0,device_id$0,kind$1,label$2,group_id$0,to_json$1],
     Device=[0,Kind$1,Info];
    function of_navigator$1(n){return n.mediaDevices}
    function enumerate(m)
     {function _eW_(_eY_){return _eY_}
      function ok(_eX_){return to_list(_eW_,_eX_)}
      return of_promise$0(ok,m.enumerateDevices())}
    function get_supported_constraints(m){return m.getSupportedConstraints()}
    function get_user_media(m,c)
     {function ok(_eV_){return _eV_}return of_promise$0(ok,m.getUserMedia(c))}
    function get_display_media(m,c)
     {function ok(_eU_){return _eU_}
      return of_promise$0(ok,m.getDisplayMedia(c))}
    var
     devicechange="devicechange",
     Ev$4=[0,devicechange],
     Devices=
      [0,
       of_navigator$1,
       enumerate,
       get_supported_constraints,
       get_user_media,
       get_display_media,
       Ev$4],
     aborted$0=1,
     network=2,
     decode$3=3,
     src_not_supported=4;
    function code$4(e){return caml_call2(Int[2],e,cst_code$1)}
    function message$2(e){return caml_call2(_d_[2],e,cst_message$1)}
    var
     Error$3=[0,aborted$0,network,decode$3,src_not_supported,code$4,message$2],
     maybe="maybe",
     probably="probably",
     Can_play=[0,maybe,probably],
     Have=[0,0,1,2,3,4],
     Network=[0,0,1,2,3],
     anonymous="anonymous",
     use_credentials="use-credentials",
     Cors=[0,anonymous,use_credentials];
    function of_media_stream(_eT_){return _eT_}
    function of_blob$1(_eS_){return _eS_}
    function of_media_source(_eR_){return _eR_}
    var
     Provider=[0,of_media_stream,of_blob$1,of_media_source],
     List=[0],
     Audio_track=[0,List],
     List$0=[0],
     Video_track=[0,List$0],
     Kind$2=[0],
     List$1=[0],
     Text_track=[0,Kind$2,List$1];
    function length$4(r){return caml_call2(Int[2],r,cst_length$3)}
    function start$1(r,i){return r.start(i)}
    function end(r,i){return r.end(i)}
    var Time_ranges=[0,length$4,start$1,end];
    function of_el$0(e)
     {return caml_call2(_bn_[9],_bn_[54][107],e)
              ?e
              :caml_call2(_bn_[9],_bn_[54][7],e)
                ?e
                :throw$0
                  (0,
                   "Expected audio or video element but found: ".concat
                    (caml_call1(_bn_[8],e)))}
    function to_el$0(_eQ_){return _eQ_}
    function error$8(m)
     {var _eO_=m.error;return to_option(function(_eP_){return _eP_},_eO_)}
    function src$1(m){return caml_call2(_d_[2],m,cst_src)}
    function set_src(m,s){return caml_call3(_d_[3],m,cst_src$0,s)}
    function src_object(m)
     {var _eM_=m.srcObject;return to_option(function(_eN_){return _eN_},_eM_)}
    function set_src_object(m,o)
     {return m.srcObject = of_option(null$0,function(_eL_){return _eL_},o)}
    function current_src(m){return caml_call2(_d_[2],m,cst_currentSrc)}
    function cross_origin(m){return caml_call2(_d_[2],m,cst_crossOrigin)}
    function set_cross_origin(m,c)
     {return caml_call3(_d_[3],m,cst_crossOrigin$0,c)}
    function network_state(m){return caml_call2(Int[2],m,cst_networkState)}
    function preload(m){return caml_call2(_d_[2],m,cst_preload)}
    function set_preload(m,p){return caml_call3(_d_[3],m,cst_preload$0,p)}
    function buffered(m){return m.buffered}
    function load$0(m){m.load();return 0}
    function can_play_type(m,t){return m.canPlayType(t)}
    function ready_state$0(m){return caml_call2(Int[2],m,cst_readyState$0)}
    function seeking$0(m){return caml_call2(Bool[2],m,cst_seeking)}
    function current_time_s(m){return caml_call2(Float[2],m,cst_currentTime)}
    function set_current_time_s(m,t)
     {return caml_call3(Float[3],m,cst_currentTime$0,t)}
    function fast_seek_s(m,t){m.fastSeek(t);return 0}
    function duration_s(m){return caml_call2(Float[2],m,cst_duration$0)}
    function paused$0(m){return caml_call2(Bool[2],m,cst_paused)}
    function default_playback_rate(m)
     {return caml_call2(Float[2],m,cst_defaultPlaybackRate)}
    function set_default_playback_rate(m,r)
     {return caml_call3(Float[3],m,cst_defaultPlaybackRate$0,r)}
    function playback_rate(m){return caml_call2(Float[2],m,cst_playbackRate)}
    function set_playback_rate(m,r)
     {return caml_call3(Float[3],m,cst_playbackRate$0,r)}
    function played(m){return m.played}
    function seekable(m){return m.seekable}
    function ended$2(m){return caml_call2(Bool[2],m,cst_ended)}
    function autoplay(m){return caml_call2(Bool[2],m,cst_autoplay)}
    function set_auto_play(m,b){return caml_call3(Bool[3],m,cst_autoplay$0,b)}
    function loop(m){return caml_call2(Bool[2],m,cst_loop)}
    function set_loop(m,b){return caml_call3(Bool[3],m,cst_loop$0,b)}
    function play$0(m)
     {var _eJ_=m.play();return of_promise$0(function(_eK_){return 0},_eJ_)}
    function pause$2(m){m.pause();return 0}
    function controls(m){return caml_call2(Bool[2],m,cst_controls)}
    function set_controls(m,b){return caml_call3(Bool[3],m,cst_controls$0,b)}
    function volume(m){return caml_call2(Float[2],m,cst_volume)}
    function set_volume(m,f){return caml_call3(Float[3],m,cst_volume$0,f)}
    function muted$0(m){return caml_call2(Bool[2],m,cst_muted$0)}
    function set_muted(m,b){return caml_call3(Bool[3],m,cst_muted$1,b)}
    function default_muted(m){return caml_call2(Bool[2],m,cst_defaultMuted)}
    function set_default_muted(m,b)
     {return caml_call3(Bool[3],m,cst_defaultMuted$0,b)}
    function audio_track_list(m){return m.audioTracks}
    function video_track_list(m){return m.videoTracks}
    function text_track_list(m){return m.textTracks}
    function capture_stream(m){return m.captureStream()}
    var
     El=
      [0,
       Error$3,
       Can_play,
       Have,
       Network,
       Cors,
       Provider,
       Audio_track,
       Video_track,
       Text_track,
       Time_ranges,
       of_el$0,
       to_el$0,
       error$8,
       src$1,
       set_src,
       src_object,
       set_src_object,
       current_src,
       cross_origin,
       set_cross_origin,
       network_state,
       preload,
       set_preload,
       buffered,
       load$0,
       can_play_type,
       ready_state$0,
       seeking$0,
       current_time_s,
       set_current_time_s,
       fast_seek_s,
       duration_s,
       paused$0,
       default_playback_rate,
       set_default_playback_rate,
       playback_rate,
       set_playback_rate,
       played,
       seekable,
       ended$2,
       autoplay,
       set_auto_play,
       loop,
       set_loop,
       play$0,
       pause$2,
       controls,
       set_controls,
       volume,
       set_volume,
       muted$0,
       set_muted,
       default_muted,
       set_default_muted,
       audio_track_list,
       video_track_list,
       text_track_list,
       capture_stream];
    function transfer(_eI_){return _eI_}
    function opts$1(target_origin,transfer,param)
     {var o={};
      caml_call3(_d_[4],o,cst_targetOrigin,target_origin);
      set_if_some
       (o,
        cst_transfer,
        caml_call2(Stdlib_option[7],caml_list_to_js_array,transfer));
      return o}
    function start$2(p){p.start();return 0}
    function close$1(p){p.close();return 0}
    function post(opt,p,v)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      p.postMessage(v,opts);
      return 0}
    var Port=[0,start$2,close$1,post],channel=target.MessageChannel;
    function create$9(param){return new channel()}
    function port1(c){return c.port1}
    function port2(c){return c.port2}
    var broadcast=target.BroadcastChannel;
    function create$10(n){return new broadcast(n)}
    function name$7(b){return caml_call2(_d_[2],b,cst_name$3)}
    function close$2(b){b.close();return 0}
    function post$0(b,v){b.postMessage(v);return 0}
    function window_post(opt,w,v)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      w.postMessage(v,opts);
      return 0}
    var message$3="message",messageerror="messageerror";
    function as_extendable$0(_eH_){return _eH_}
    function data$3(e){return e.data}
    function origin(e){return caml_call2(_d_[2],e,cst_origin)}
    function last_event_id(e){return caml_call2(_d_[2],e,cst_lastEventId)}
    function source$1(e)
     {var _eF_=e.source;return to_option(function(_eG_){return _eG_},_eF_)}
    function ports(e)
     {var _eD_=e.ports;return to_list(function(_eE_){return _eE_},_eD_)}
    var
     default$2="default",
     denied="denied",
     granted="granted",
     Permission=[0,default$2,denied,granted],
     notification=target.Notification;
    function permission(param)
     {return caml_call2(_d_[2],notification,cst_permission)}
    function request_permission(param)
     {var _eB_=notification.requestPermission();
      return of_promise$0(function(_eC_){return _eC_},_eB_)}
    var auto$1="auto",ltr="ltr",rtl="rtl",Direction=[0,auto$1,ltr,rtl];
    function max$1(param)
     {return caml_call2(Int[2],notification,cst_maxActions)}
    function v$13(icon,action,title,param)
     {var o={};
      caml_call3(_d_[3],o,cst_action$0,action);
      caml_call3(_d_[3],o,cst_title$1,title);
      caml_call3(_d_[4],o,cst_icon,icon);
      return o}
    function action$0(a){return caml_call2(_d_[2],a,cst_action$1)}
    function title$5(a){return caml_call2(_d_[2],a,cst_title$2)}
    function icon(a){return caml_call2(_d_[1],a,cst_icon$0)}
    var Action=[0,max$1,v$13,action$0,title$5,icon];
    function opts$2
     (dir,
      lang,
      body,
      tag,
      image,
      icon,
      badge,
      timestamp_ms,
      renotify,
      silent,
      require_interaction,
      data,
      opt,
      param)
     {if(opt)var sth=opt[1],actions=sth;else var actions=0;
      var o={};
      caml_call3(_d_[4],o,cst_dir$0,dir);
      caml_call3(_d_[4],o,cst_lang,lang);
      caml_call3(_d_[4],o,cst_body,body);
      caml_call3(_d_[4],o,cst_image,image);
      caml_call3(_d_[4],o,cst_icon$1,icon);
      caml_call3(_d_[4],o,cst_badge,badge);
      caml_call3(Int[4],o,cst_timestamp$0,timestamp_ms);
      caml_call3(Bool[4],o,cst_renotify,renotify);
      caml_call3(Bool[4],o,cst_silent,silent);
      caml_call3(Bool[4],o,cst_requireInteraction,require_interaction);
      function _ey_(_eA_){return _eA_}
      set_if_some(o,cst_data$1,caml_call2(Stdlib_option[7],_ey_,data));
      o.actions = of_list(function(_ez_){return _ez_},actions);
      return o}
    function create$11(opt,title)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new notification(title,opts)}
    function close$3(n){n.close();return 0}
    function actions(n)
     {var _ew_=n.actions;return to_list(function(_ex_){return _ex_},_ew_)}
    function badge(n){return caml_call2(_d_[2],n,cst_badge$0)}
    function body$3(n){return caml_call2(_d_[2],n,cst_body$0)}
    function data$4(n){return n.data}
    function dir$2(n){return caml_call2(_d_[2],n,cst_dir$1)}
    function lang$1(n){return caml_call2(_d_[2],n,cst_lang$0)}
    function tag(n){return caml_call2(_d_[2],n,cst_tag)}
    function icon$0(n){return caml_call2(_d_[2],n,cst_icon$2)}
    function image$0(n){return caml_call2(_d_[2],n,cst_image$0)}
    function renotify(n){return caml_call2(Bool[2],n,cst_renotify$0)}
    function require_interaction(n)
     {return caml_call2(Bool[2],n,cst_requireInteraction$0)}
    function silent(n){return caml_call2(Bool[2],n,cst_silent$0)}
    function timestamp_ms$1(n){return caml_call2(Int[2],n,cst_timestamp$1)}
    function title$6(n){return caml_call2(_d_[2],n,cst_title$3)}
    var
     notificationclick="notificationclick",
     notificationclose="notificationclose";
    function as_extendable$1(_ev_){return _ev_}
    function notification$0(e){return e.notification}
    function action$1(e){return caml_call2(_d_[2],e,cst_action$2)}
    function local(w){return w.localStorage}
    function session(w){return w.sessionStorage}
    function length$5(s){return caml_call2(Int[2],s,cst_length$4)}
    function key$0(s,i)
     {var _et_=s.key(i);return to_option(function(_eu_){return _eu_},_et_)}
    function get_item(s,k)
     {var _er_=s.getItem(k);
      return to_option(function(_es_){return _es_},_er_)}
    function set_item(s,k,v)
     {try
       {s.setItem(k,v);return _bs_}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}}
    function remove_item(s,k){s.removeItem(k);return 0}
    function clear$1(s){s.clear();return 0}
    var storage="storage";
    function key$1(e){return caml_call2(_d_[1],e,cst_key$0)}
    function old_value(e){return caml_call2(_d_[1],e,cst_oldValue)}
    function new_value(e){return caml_call2(_d_[1],e,cst_newValue)}
    function url$3(e){return caml_call2(_d_[2],e,cst_url$1)}
    function storage_area(e){return find(e,cst_storageArea)}
    var
     blob$1="blob",
     arraybuffer="arraybuffer",
     Binary_type=[0,blob$1,arraybuffer],
     Ready_state=[0,0,1,2,3],
     websocket=target.WebSocket;
    function create$12(protocols,url)
     {if(protocols)
       var ps=protocols[1],protocols$0=caml_list_to_js_array(ps);
      else
       var protocols$0=fn;
      return new websocket(url,protocols$0)}
    function binary_type(s){return caml_call2(_d_[2],s,cst_binaryType)}
    function set_binary_type(s,t)
     {return caml_call3(_d_[3],s,cst_binaryType$0,t)}
    function close$4(code,r,s)
     {if(code)var c=code[1],code$0=c;else var code$0=fn;
      if(r)var s$0=r[1],reason=s$0;else var reason=fn;
      s.close(code$0,reason);
      return 0}
    function url$4(s){return caml_call2(_d_[2],s,cst_url$2)}
    function ready_state$1(s){return caml_call2(Int[2],s,cst_readyState$1)}
    function buffered_amount(s)
     {return caml_call2(Int[2],s,cst_bufferedAmount)}
    function extensions(s){return caml_call2(_d_[2],s,cst_extensions)}
    function protocol(s){return caml_call2(_d_[2],s,cst_protocol$0)}
    function send_string(s,d){s.send(d);return 0}
    function send_blob(s,d){s.send(d);return 0}
    function send_tarray(s,d){s.send(d);return 0}
    function send_array_buffer(s,d){s.send(d);return 0}
    function was_clean(e){return caml_call2(Bool[2],e,cst_wasClean)}
    function code$5(e){return caml_call2(Int[2],e,cst_code$2)}
    function reason(e){return caml_call2(_d_[2],e,cst_reason)}
    var
     Close=[0,was_clean,code$5,reason],
     close$5="close",
     Ev$5=[0,Close,close$5],
     Brr_io=
      [0,
       [0,
        [0,
         Presentation_style,
         opts,
         create$5,
         presentation_style,
         last_modified_ms$0,
         delayed,
         types,
         get_type],
        of_navigator,
        as_target$1,
        read,
        read_text,
        write,
        write_text],
       [0,
        of_el,
        to_el,
        name$5,
        method,
        target$1,
        action,
        enctype,
        accept_charset,
        autocomplete,
        no_validate,
        check_validity,
        report_validity,
        request_submit,
        reset$0,
        submit,
        [0,
         create$6,
         of_form,
         mem$0,
         find$7,
         find_all$0,
         fold$1,
         set$4,
         set_blob,
         append,
         append_blob,
         delete$0,
         of_assoc$0,
         to_assoc$0],
        Ev$0],
       [0,
        Body,
        [0,mem$1,find$8,fold$2,of_obj$0,of_assoc$1,to_assoc$1],
        [0,
         Cache,
         Credentials,
         Destination,
         Mode,
         Redirect,
         init$2,
         v$3,
         of_request,
         cache,
         credentials,
         destination,
         headers$0,
         integrity,
         is_history_navigation,
         is_reload_navigation,
         keepalive,
         method$0,
         mode,
         redirect,
         referrer$0,
         referrer_policy,
         signal$0,
         url$0],
        [0,
         Type$2,
         init$3,
         v$4,
         of_response,
         error$5,
         redirect$0,
         headers$1,
         ok$0,
         redirected,
         status,
         status_text,
         url$1],
        Cache$0,
        Ev$1,
        url$2,
        request$1,
        caches],
       [0,
        Error$1,
        [0,
         latitude,
         longitude,
         accuracy,
         altitude,
         altitude_accuracy,
         heading,
         speed,
         timestamp_ms$0],
        opts$0,
        of_navigator$0,
        get$5,
        watch,
        unwatch],
       [0,
        [0,
         Bool$0,
         Int$0,
         Float$0,
         Jstr$0,
         bool$0,
         int$2,
         float$1,
         jstr$0,
         jstr_enum,
         v$11,
         name$6,
         value_of_jv,
         value_to_jv,
         cap_of_jv,
         cap_to_jv,
         constr_of_jv,
         constr_to_jv],
        Supported_constraints,
        Constraints,
        Capabilities,
        Settings,
        [0,
         State,
         Kind$0,
         Prop,
         id$3,
         isolated,
         kind$0,
         label$1,
         muted,
         ready_state,
         enabled,
         set_enabled,
         get_capabilities,
         get_constraints,
         apply_constraints,
         get_settings,
         stop,
         clone,
         [0,track$2,ended$1,isolationchange,mute,unmute]],
        [0,
         Constraints$0,
         create$7,
         of_stream,
         of_tracks,
         id$4,
         active,
         get_audio_tracks,
         get_video_tracks,
         get_tracks,
         get_track_by_id,
         add_track,
         remove_track,
         clone$0,
         Ev$2],
        [0,
         Bitrate_mode,
         Recording_state,
         is_type_supported,
         init$4,
         create$8,
         stream$1,
         type$8,
         state$1,
         video_bps,
         audio_bps,
         audio_bitrate_mode,
         start,
         stop$0,
         pause$0,
         resume,
         request_data,
         Ev$3],
        Device,
        Devices,
        El],
       [0,
        transfer,
        opts$1,
        Port,
        [0,create$9,port1,port2],
        [0,create$10,name$7,close$2,post$0],
        window_post,
        [0,
         as_extendable$0,
         data$3,
         origin,
         last_event_id,
         source$1,
         ports,
         message$3,
         messageerror]],
       [0,
        Permission,
        permission,
        request_permission,
        Direction,
        Action,
        opts$2,
        create$11,
        close$3,
        actions,
        badge,
        body$3,
        data$4,
        dir$2,
        lang$1,
        tag,
        icon$0,
        image$0,
        renotify,
        require_interaction,
        silent,
        timestamp_ms$1,
        title$6,
        [0,
         as_extendable$1,
         notification$0,
         action$1,
         notificationclick,
         notificationclose]],
       [0,
        local,
        session,
        length$5,
        key$0,
        get_item,
        set_item,
        remove_item,
        clear$1,
        [0,key$1,old_value,new_value,url$3,storage_area,storage]],
       [0,
        Binary_type,
        Ready_state,
        create$12,
        binary_type,
        set_binary_type,
        close$4,
        url$4,
        ready_state$1,
        buffered_amount,
        extensions,
        protocol,
        send_string,
        send_blob,
        send_array_buffer,
        send_tarray,
        Ev$5]];
    caml_register_global(2920,Brr_io,"Brr_io");
    function is_2d(m){return caml_call2(Bool[2],m,cst_is2D)}
    function is_identity(m){return caml_call2(Bool[2],m,cst_isIdentity)}
    function inverse(m){return m.inverse()}
    function multiply(m$0,m){return m$0.multiply(m)}
    function m11(m){return caml_call2(Float[2],m,cst_m11)}
    function m12(m){return caml_call2(Float[2],m,cst_m12)}
    function m13(m){return caml_call2(Float[2],m,cst_m13)}
    function m14(m){return caml_call2(Float[2],m,cst_m14)}
    function m21(m){return caml_call2(Float[2],m,cst_m21)}
    function m22(m){return caml_call2(Float[2],m,cst_m22)}
    function m23(m){return caml_call2(Float[2],m,cst_m23)}
    function m24(m){return caml_call2(Float[2],m,cst_m24)}
    function m31(m){return caml_call2(Float[2],m,cst_m31)}
    function m32(m){return caml_call2(Float[2],m,cst_m32)}
    function m33(m){return caml_call2(Float[2],m,cst_m33)}
    function m34(m){return caml_call2(Float[2],m,cst_m34)}
    function m41(m){return caml_call2(Float[2],m,cst_m41)}
    function m42(m){return caml_call2(Float[2],m,cst_m42)}
    function m43(m){return caml_call2(Float[2],m,cst_m43)}
    function m44(m){return caml_call2(Float[2],m,cst_m44)}
    function a$1(m){return caml_call2(Float[2],m,cst_a)}
    function b$1(m){return caml_call2(Float[2],m,cst_b)}
    function c$0(m){return caml_call2(Float[2],m,cst_c)}
    function d(m){return caml_call2(Float[2],m,cst_d)}
    function e(m){return caml_call2(Float[2],m,cst_e)}
    function f(m){return caml_call2(Float[2],m,cst_f)}
    var dommatrixro=target.DOMMatrixReadOnly;
    function to_float32_array(m){return m.toFloat32Array()}
    function of_float32_array(a){return dommatrixro.fromFloat32Array(a)}
    function to_float64_array(m){return m.toFloat64Array()}
    function of_float64_array(a){return dommatrixro.fromFloat64Array(a)}
    var v4=target.DOMPointReadOnly;
    function v$14(x,y,z,w){return new v4(x,y,z,w)}
    function tr$1(m,v){return v.matrixTransform(m)}
    function to_json$2(v){return v.toJSON()}
    function x(v){return caml_call2(Float[2],v,cst_x$0)}
    function y(v){return caml_call2(Float[2],v,cst_y$0)}
    function z(v){return caml_call2(Float[2],v,cst_z)}
    function w(v){return caml_call2(Float[2],v,cst_w)}
    function create$13(d,at,opt,_eq_,cs)
     {if(opt)var sth=opt[1],w=sth;else var w=0;
      if(_eq_)var sth$0=_eq_[1],h=sth$0;else var h=0;
      var c=caml_call3(_bn_[70],d,at,cs);
      caml_call3(Int[3],c,cst_width$1,w);
      caml_call3(Int[3],c,cst_height$1,h);
      return c}
    function of_el$1(e)
     {return caml_call2(_bn_[9],_bn_[54][16],e)
              ?e
              :throw$0
                (0,
                 "Expected canvas element but found: ".concat
                  (caml_call1(_bn_[8],e)))}
    function to_el$1(_ep_){return _ep_}
    function w$0(c){return caml_call2(Int[2],c,cst_width$2)}
    function h(c){return caml_call2(Int[2],c,cst_height$2)}
    function set_w(c,w){return caml_call3(Int[3],c,cst_width$3,w)}
    function set_h(c,h){return caml_call3(Int[3],c,cst_height$3,h)}
    function set_size_to_layout_size(opt,c)
     {if(opt)var sth=opt[1],hidpi=sth;else var hidpi=1;
      var
       dpr=hidpi?caml_call1(Window[5],_bm_[5]):1.,
       cw=Math.ceil(dpr * caml_call1(_bn_[33],c)) | 0,
       ch=Math.ceil(dpr * caml_call1(_bn_[34],c)) | 0,
       _en_=w$0(c) !== cw?1:0,
       _eo_=_en_ || (h(c) !== ch?1:0);
      return _eo_?(set_w(c,cw),set_h(c,ch)):_eo_}
    function image_encode(opt,quality,param)
     {if(opt)var sth=opt[1],type=sth;else var type="image/png";
      var o={};
      caml_call3(_d_[3],o,cst_type$4,type);
      caml_call3(Float[4],o,cst_quality,quality);
      return o}
    function enc(encode,c,meth,arg)
     {if(encode)
       var e=encode[1],encode$0=e;
      else
       var encode$0=image_encode(0,0,0);
      var t=encode$0.type,q=find(encode$0,cst_quality$0);
      if(arg)
       {var a=arg[1];
        if(q)var q$0=q[1],_em_=[0,a,t,q$0];else var _em_=[0,a,t];
        var args=_em_}
      else
       if(q)var q$1=q[1],args=[0,t,q$1];else var args=[0,t];
      return caml_js_meth_call(c,meth,args)}
    function to_data_url(encode,c)
     {try
       {var v=enc(0,c,cst_toDataURL,0)}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];return [1,e]}
        throw exn}
      return [0,v]}
    function to_blob(encode,c)
     {var match=create$1(0),set=match[2],fut=match[1];
      function cb(blob)
       {return caml_call1(set,[0,to_option(function(_el_){return _el_},blob)])}
      try
       {enc(0,c,cst_toBlob,[0,cb]);return fut}
      catch(exn)
       {exn = caml_wrap_exception(exn);
        if(exn[1] === Error){var e=exn[2];caml_call1(set,[1,e]);return fut}
        throw exn}}
    function capture_stream$0(hz,c)
     {if(hz)var hz$0=hz[1],args=[0,hz$0];else var args=[0];
      return caml_js_meth_call(c,cst_captureStrseam,args)}
    var
     nonzero="nonzero",
     evenodd="evenodd",
     Fill_rule=[0,nonzero,evenodd],
     low="low",
     medium="medium",
     high="high",
     Image_smoothing_quality=[0,low,medium,high],
     butt="butt",
     round="round",
     square="square",
     Line_cap=[0,butt,round,square],
     round$0="round",
     bevel="bevel",
     miter="miter",
     Line_join=[0,round$0,bevel,miter],
     start$3="start",
     end$0="end",
     left="left",
     right="right",
     center="center",
     Text_align=[0,start$3,end$0,left,right,center],
     top="top",
     hanging="hanging",
     middle="middle",
     alphabetic="alphabetic",
     ideographic="ideographic",
     bottom="bottom",
     Text_baseline=[0,top,hanging,middle,alphabetic,ideographic,bottom],
     ltr$0="ltr",
     rtl$0="rtl",
     inherit="inherit",
     Text_direction=[0,ltr$0,rtl$0,inherit],
     normal="normal",
     multiply$0="multiply",
     screen="screen",
     overlay="overlay",
     darken="darken",
     lighten="lighten",
     color_dodge="color-dodge",
     color_burn="color-burn",
     hard_light="hard-light",
     soft_light="soft-light",
     difference="difference",
     exclusion="exclusion",
     hue="hue",
     saturation="saturation",
     color$0="color",
     luminosity="luminosity",
     clear$2="clear",
     copy$1="copy",
     source_over="source-over",
     destination_over="destination-over",
     source_in="source-in",
     destination_in="destination-in",
     source_out="source-out",
     destination_out="destination-out",
     source_atop="source-atop",
     destination_atop="destination-atop",
     xor="xor",
     lighter="lighter",
     plus_darker="plus-darker",
     plus_lighter="plus-lighter",
     Composite_op=
      [0,
       normal,
       multiply$0,
       screen,
       overlay,
       darken,
       lighten,
       color_dodge,
       color_burn,
       hard_light,
       soft_light,
       difference,
       exclusion,
       hue,
       saturation,
       color$0,
       luminosity,
       clear$2,
       copy$1,
       source_over,
       destination_over,
       source_in,
       destination_in,
       source_out,
       destination_out,
       source_atop,
       destination_atop,
       xor,
       lighter,
       plus_darker,
       plus_lighter],
     xy="repeat",
     x$0="repeat-x",
     y$0="repeat-y",
     no="no-repeat",
     Repeat=[0,xy,x$0,y$0,no],
     path$0=target.Path2D;
    function create$14(param){return new path$0()}
    function of_svg(svg){return new path$0(svg)}
    function of_path(p){return new path$0(p)}
    function add$0(tr,p$0,p)
     {if(tr)var t=tr[1],_ek_=[0,p,t];else var _ek_=[0,p];
      caml_js_meth_call(p$0,cst_addPath,_ek_);
      return 0}
    function close$6(p){p.closePath();return 0}
    function move_to(p,x,y){p.moveTo(x,y);return 0}
    function line_to(p,x,y){p.lineTo(x,y);return 0}
    function qcurve_to(p,cx,cy,x,y){p.quadraticCurveTo(cx,cy,x,y);return 0}
    function ccurve_to(p,cx$0,cy$0,cx,cy,x,y)
     {p.bezierCurveTo(cx$0,cy$0,cx,cy,x,y);return 0}
    function arc_to(p,cx$0,cy$0,cx,cy,r){p.arcTo(cx$0,cy$0,cx,cy,r);return 0}
    function arc(opt,p,cx,cy,r,start,stop)
     {if(opt)var sth=opt[1],anticlockwise=sth;else var anticlockwise=0;
      p.arc(cx,cy,r,start,stop,! ! anticlockwise);
      return 0}
    function rect(p,x,y,w,h){p.rect(x,y,w,h);return 0}
    function ellipse(opt,p,cx,cy,rx,ry,rot,start,stop)
     {if(opt)var sth=opt[1],anticlockwise=sth;else var anticlockwise=0;
      p.ellipse(cx,cy,rx,ry,rot,start,stop,! ! anticlockwise);
      return 0}
    function image_src_of_el(_ej_){return _ej_}
    function image_src_of_jv(_ei_){return _ei_}
    function attrs_alpha(o){return caml_call2(Bool[2],o,cst_alpha)}
    function attrs_desynchronized(o)
     {return caml_call2(Bool[2],o,cst_desynchronized)}
    function create$15(opt,cnv)
     {if(opt)var sth=opt[1],attrs=sth;else var attrs=fn;
      return cnv.getContext("2d",attrs)}
    function canvas$1(c)
     {return find_map(function(_eh_){return _eh_},c,cst_canvas)}
    function attrs(c){return c.getContextAttributes()}
    function save(c){c.save();return 0}
    function restore(c){c.restore();return 0}
    function image_smoothing_enabled(c)
     {return caml_call2(Bool[2],c,cst_imageSmoothingEnabled)}
    function set_image_smoothing_enabled(c,b)
     {return caml_call3(Bool[3],c,cst_imageSmoothingEnabled$0,b)}
    function image_smoothing_quality(c)
     {return caml_call2(_d_[2],c,cst_imageSmoothingQuality)}
    function set_image_smoothing_quality(c,v)
     {return caml_call3(_d_[3],c,cst_imageSmoothingQuality$0,v)}
    function global_alpha(c){return caml_call2(Float[2],c,cst_globalAlpha)}
    function set_global_alpha(c,a)
     {return caml_call3(Float[3],c,cst_globalAlpha$0,a)}
    function global_composite_op(c)
     {return caml_call2(_d_[2],c,cst_globalCompositeOperation)}
    function set_global_composite_op(c,o)
     {return caml_call3(_d_[3],c,cst_globalCompositeOperation$0,o)}
    function filter$0(c){return caml_call2(_d_[2],c,cst_filter)}
    function set_filter(c,f){return caml_call3(_d_[3],c,cst_filter$0,f)}
    function get_transform(c){return c.getTransform()}
    function set_transform(c,m){c.setTransform(m);return 0}
    function reset_transform(c){c.resetTransform();return 0}
    function transform(c,m)
     {var _ec_=f(m),_ed_=e(m),_ee_=d(m),_ef_=c$0(m),_eg_=b$1(m);
      c.resetTransform(a$1(m),_eg_,_ef_,_ee_,_ed_,_ec_);
      return 0}
    function translate(c,x,y){c.translate(x,y);return 0}
    function rotate(c,r){c.rotate(r);return 0}
    function scale(c,sx,sy){c.scale(sx,sy);return 0}
    function set_stroke_style(c,s){return c.strokeStyle = s}
    function set_fill_style(c,s){return c.fillStyle = s}
    function color$1(_eb_){return _eb_}
    function gradient_style(_ea_){return _ea_}
    function make_stops(g,stops)
     {function _d$_(param)
       {var c=param[2],off=param[1];g.addColorStop(off,c);return 0}
      return caml_call2(Stdlib_list[15],_d$_,stops)}
    function linear_gradient(c,x0,y0,x1,y1,stops)
     {var g=c.createLinearGradient(x0,y0,x1,y1);make_stops(g,stops);return g}
    function radial_gradient(c,x0,y0,r0,x1,y1,r1,stops)
     {var g=c.createRadialGradient(x0,y0,r0,x1,y1,r1);
      make_stops(g,stops);
      return g}
    function pattern(c,img,r,tr)
     {var p=c.createPattern(img,r);
      if(tr){var t=tr[1];p.setTransform(t);return p}
      return p}
    function pattern_style(_d__){return _d__}
    function line_width(c){return caml_call2(Float[2],c,cst_lineWidth)}
    function set_line_width(c,w)
     {return caml_call3(Float[3],c,cst_lineWidth$0,w)}
    function line_cap(c){return caml_call2(_d_[2],c,cst_lineCap)}
    function set_line_cap(c,cap)
     {return caml_call3(_d_[3],c,cst_lineCap$0,cap)}
    function line_join(c){return caml_call2(_d_[2],c,cst_lineJoin)}
    function set_line_join(c,join)
     {return caml_call3(_d_[3],c,cst_lineJoin$0,join)}
    function miter_limit(c){return caml_call2(Float[2],c,cst_miterLimit)}
    function set_miter_limit(c,l)
     {return caml_call3(Float[3],c,cst_miterLimit$0,l)}
    function line_dash(c)
     {var _d8_=c.getLineDash();
      return to_list(function(_d9_){return _d9_},_d8_)}
    function set_line_dash(c,ds)
     {c.setLineDash(of_list(function(_d7_){return _d7_},ds));return 0}
    function line_dash_offset(c)
     {return caml_call2(Float[2],c,cst_lineDashOffset)}
    function set_line_dash_offset(c,o)
     {return caml_call3(Float[3],c,cst_lineDashOffset$0,o)}
    function shadow_blur(c){return caml_call2(Float[2],c,cst_shadowBlur)}
    function set_shadow_blur(c,b)
     {return caml_call3(Float[3],c,cst_shadowBlur$0,b)}
    function shadow_offset_x(c)
     {return caml_call2(Float[2],c,cst_shadowOffsetX)}
    function set_shadow_offset_x(c,o)
     {return caml_call3(Float[3],c,cst_shadowOffsetX$0,o)}
    function shadow_offset_y(c)
     {return caml_call2(Float[2],c,cst_shadowOffsetY)}
    function set_shadow_offset_y(c,o)
     {return caml_call3(Float[3],c,cst_shadowOffsetY$0,o)}
    function shadow_color(c){return caml_call2(_d_[2],c,cst_shadowColor)}
    function set_shadow_color(c,col)
     {return caml_call3(_d_[3],c,cst_shadowColor$0,col)}
    function font$0(c){return caml_call2(_d_[2],c,cst_font)}
    function set_font(c,f){return caml_call3(_d_[3],c,cst_font$0,f)}
    function text_align(c){return caml_call2(_d_[2],c,cst_textAlign)}
    function set_text_align(c,a)
     {return caml_call3(_d_[3],c,cst_textAlign$0,a)}
    function text_baseline(c){return caml_call2(_d_[2],c,cst_textBaseline)}
    function set_text_baseline(c,b)
     {return caml_call3(_d_[3],c,cst_textBaseline$0,b)}
    function text_direction(c){return caml_call2(_d_[2],c,cst_direction)}
    function set_text_direction(c,d)
     {return caml_call3(_d_[3],c,cst_direction$0,d)}
    function clear_rect(c,x,y,w,h){c.clearRect(x,y,w,h);return 0}
    function fill_rect(c,x,y,w,h){c.fillRect(x,y,w,h);return 0}
    function stroke_rect(c,x,y,w,h){c.strokeRect(x,y,w,h);return 0}
    function fill$0(opt,c,p)
     {if(opt)var sth=opt[1],fill_rule=sth;else var fill_rule=Fill_rule[1];
      c.fill(p,fill_rule);
      return 0}
    function stroke(c,p){c.stroke(p);return 0}
    function clip(opt,c,p)
     {if(opt)var sth=opt[1],fill_rule=sth;else var fill_rule=Fill_rule[1];
      c.clip(p,fill_rule);
      return 0}
    function draw_focus_if_needed(c,p,e){c.drawFocusIfNeeded(p,e);return 0}
    function scroll_path_into_view(c,p){c.scrollPathIntoView(p);return 0}
    function is_point_in_fill(opt,c,p,x,y)
     {if(opt)var sth=opt[1],fill_rule=sth;else var fill_rule=Fill_rule[1];
      return c.isPointInPath(p,x,y,fill_rule) | 0}
    function is_point_in_stroke(c,p,x,y){return c.isPointInStroke(p,x,y) | 0}
    function call_text(c,meth,max_width,txt,x,y)
     {if(max_width)
       var m=max_width[1],args=[0,txt,x,y,m];
      else
       var args=[0,txt,x,y];
      caml_js_meth_call(c,meth,args);
      return 0}
    function fill_text(max_width,c,txt,x,y)
     {return call_text(c,cst_fillText,max_width,txt,x,y)}
    function stroke_text(max_width,c,txt,x,y)
     {return call_text(c,cst_strokeText,max_width,txt,x,y)}
    function width$5(m){return caml_call2(Float[2],m,cst_width$4)}
    function actual_bounding_box_left(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxLeft)}
    function actual_bounding_box_right(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxRight)}
    function font_bounding_box_ascent(m)
     {return caml_call2(Float[2],m,cst_fontBoundingBoxAscent)}
    function font_bounding_box_descent(m)
     {return caml_call2(Float[2],m,cst_fontBoundingBoxDescent)}
    function actual_bounding_box_ascent(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxAscent)}
    function actual_bounding_box_descent(m)
     {return caml_call2(Float[2],m,cst_actualBoundingBoxDescent)}
    function em_height_ascent(m)
     {return caml_call2(Float[2],m,cst_emHeightAscent)}
    function em_height_descent(m)
     {return caml_call2(Float[2],m,cst_emHeightDescent)}
    function hanging_baseline(m)
     {return caml_call2(Float[2],m,cst_hangingBaseline)}
    function alphabetic_baseline(m)
     {return caml_call2(Float[2],m,cst_alphabeticBaseline)}
    function ideographic_baseline(m)
     {return caml_call2(Float[2],m,cst_ideographicBaseline)}
    var
     Text_metrics=
      [0,
       width$5,
       actual_bounding_box_left,
       actual_bounding_box_right,
       font_bounding_box_ascent,
       font_bounding_box_descent,
       actual_bounding_box_ascent,
       actual_bounding_box_descent,
       em_height_ascent,
       em_height_descent,
       hanging_baseline,
       alphabetic_baseline,
       ideographic_baseline];
    function measure_text(c,txt){return c.measureText(txt)}
    function draw_image(c,i,x,y){c.drawImage(i,x,y);return 0}
    function draw_image_in_rect(c,i,x,y,w,h){c.drawImage(i,x,y,w,h);return 0}
    function draw_sub_image_in_rect(c,i,sx,sy,sw,sh,x,y,w,h)
     {c.drawImage(i,sx,sy,sw,sh,x,y,w,h);return 0}
    var image_data=target.ImageData;
    function create$16(data,w,h)
     {if(data)var data$0=data[1],args=[0,data$0,w,h];else var args=[0,w,h];
      return caml_js_new(image_data,args)}
    function w$1(d){return caml_call2(Int[2],d,cst_width$5)}
    function h$0(d){return caml_call2(Int[2],d,cst_height$4)}
    function data$5(d){return d.data}
    function create_image_data(c,w,h){return c.createImageData(w,h)}
    function get_image_data(c,x,y,w,h){return c.getImageData(x,y,w,h)}
    function put_image_data(c,d,x,y){c.putImageData(d,x,y);return 0}
    function put_sub_image_data(c,d,sx,sy,sw,sh,x,y)
     {c.putImageData(d,x,y,sx,sy,sw,sh);return 0}
    var
     default$3="default",
     high_performance="high-performance",
     low_power="low-power",
     Power_preference=[0,default$3,high_performance,low_power];
    function v$15
     (alpha,
      depth,
      stencil,
      antialias,
      premultiplied_alpha,
      preserve_drawing_buffer,
      power_preference,
      fail_if_major_performance_cave,
      desynchronized,
      param)
     {var o={};
      caml_call3(Bool[4],o,cst_alpha$0,alpha);
      caml_call3(Bool[4],o,cst_depth,depth);
      caml_call3(Bool[4],o,cst_stencil,stencil);
      caml_call3(Bool[4],o,cst_antialias,antialias);
      caml_call3(Bool[4],o,cst_premultipliedApha,premultiplied_alpha);
      caml_call3(Bool[4],o,cst_preserveDrawingBuffer,preserve_drawing_buffer);
      caml_call3(_d_[4],o,cst_powerPreference,power_preference);
      caml_call3
       (Bool[4],
        o,
        cst_failIfMajorPerformanceCave,
        fail_if_major_performance_cave);
      caml_call3(Bool[4],o,cst_desynchronized$0,desynchronized);
      return o}
    function alpha(a){return caml_call2(Bool[2],a,cst_alpha$1)}
    function depth(a){return caml_call2(Bool[2],a,cst_depth$0)}
    function stencil(a){return caml_call2(Bool[2],a,cst_stencil$0)}
    function antialias(a){return caml_call2(Bool[2],a,cst_antialias$0)}
    function premultiplied_alpha(a)
     {return caml_call2(Bool[2],a,cst_premultipliedApha$0)}
    function preserve_drawing_buffer(a)
     {return caml_call2(Bool[2],a,cst_preserveDrawingBuffer$0)}
    function power_preference(a)
     {return caml_call2(_d_[2],a,cst_powerPreference$0)}
    function desynchronized(a)
     {return caml_call2(Bool[2],a,cst_desynchronized$1)}
    function create$17(opt,_d3_,cnv)
     {if(opt)var sth=opt[1],attrs=sth;else var attrs=fn;
      if(_d3_)var sth$0=_d3_[1],v1=sth$0;else var v1=0;
      var
       _d4_=v1?cst_webgl:cst_webgl2,
       webgl=caml_jsstring_of_string(_d4_),
       _d5_=cnv.getContext(webgl,attrs);
      return to_option(function(_d6_){return _d6_},_d5_)}
    function canvas$2(c)
     {return find_map(function(_d2_){return _d2_},c,cst_canvas$0)}
    function attrs$0(c){return c.getContextAttributes()}
    function drawing_buffer_width(c)
     {return caml_call2(Int[2],c,cst_drawingBufferWidth)}
    function drawing_buffer_height(c)
     {return caml_call2(Int[2],c,cst_drawingBufferHeight)}
    function is_context_lost(c)
     {return caml_call2(Bool[2],c,cst_isContextLost)}
    function get_supported_extensions(c)
     {return caml_list_of_js_array(c.getSupportedExtensions())}
    function get_extension(c,ext){return c.getExtension(ext)}
    function size(i){return caml_call2(Int[2],i,cst_size$0)}
    function type$9(i){return caml_call2(Int[2],i,cst_type$5)}
    function name$8(i){return caml_call2(_d_[2],i,cst_name$4)}
    var Active_info=[0,size,type$9,name$8];
    function range_min(f){return caml_call2(Int[2],f,cst_rangeMin)}
    function range_max(f){return caml_call2(Int[2],f,cst_rangeMax)}
    function precision(f){return caml_call2(Int[2],f,cst_precision)}
    var Shader_precision_format=[0,range_min,range_max,precision];
    function of_image_data(_d1_){return _d1_}
    function of_img_el(_d0_){return _d0_}
    function of_canvas_el(_dZ_){return _dZ_}
    function of_video_el(_dY_){return _dY_}
    function of_offscreen_canvas(_dX_){return _dX_}
    var
     Tex_image_source=
      [0,of_image_data,of_img_el,of_canvas_el,of_video_el,of_offscreen_canvas];
    function active_texture(c,texture){c.activeTexture(texture);return 0}
    function attach_shader(c,program,shader)
     {c.attachShader(program,shader);return 0}
    function begin_query(c,target,query){c.beginQuery(target,query);return 0}
    function begin_transform_feedback(c,primitiveMode)
     {c.beginTransformFeedback(primitiveMode);return 0}
    function bind_attrib_location(c,program,index,name)
     {c.bindAttribLocation(program,index,name);return 0}
    function bind_buffer(c,target,buffer)
     {c.bindBuffer
       (target,of_option(null$0,function(_dW_){return _dW_},buffer));
      return 0}
    function bind_buffer_base(c,target,index,buffer)
     {c.bindBufferBase(target,index,buffer);return 0}
    function bind_buffer_range(c,target,index,buffer,offset,size)
     {c.bindBufferRange(target,index,buffer,offset,size);return 0}
    function bind_framebuffer(c,target,framebuffer)
     {c.bindFramebuffer
       (target,of_option(null$0,function(_dV_){return _dV_},framebuffer));
      return 0}
    function bind_renderbuffer(c,target,renderbuffer)
     {c.bindRenderbuffer
       (target,of_option(null$0,function(_dU_){return _dU_},renderbuffer));
      return 0}
    function bind_sampler(c,unit,sampler)
     {c.bindSampler
       (unit,of_option(null$0,function(_dT_){return _dT_},sampler));
      return 0}
    function bind_texture(c,target,texture)
     {c.bindTexture
       (target,of_option(null$0,function(_dS_){return _dS_},texture));
      return 0}
    function bind_transform_feedback(c,target,tf)
     {c.bindTransformFeedback
       (target,of_option(null$0,function(_dR_){return _dR_},tf));
      return 0}
    function bind_vertex_array(c,array)
     {c.bindVertexArray(of_option(null$0,function(_dQ_){return _dQ_},array));
      return 0}
    function blend_color(c,red,green,blue,alpha)
     {c.blendColor(red,green,blue,alpha);return 0}
    function blend_equation(c,mode){c.blendEquation(mode);return 0}
    function blend_equation_separate(c,modeRGB,modeAlpha)
     {c.blendEquationSeparate(modeRGB,modeAlpha);return 0}
    function blend_func(c,sfactor,dfactor)
     {c.blendFunc(sfactor,dfactor);return 0}
    function blend_func_separate(c,srcRGB,dstRGB,srcAlpha,dstAlpha)
     {c.blendFuncSeparate(srcRGB,dstRGB,srcAlpha,dstAlpha);return 0}
    function blit_framebuffer
     (c,srcX0,srcY0,srcX1,srcY1,dstX0,dstY0,dstX1,dstY1,mask,filter)
     {c.blitFramebuffer
       (srcX0,srcY0,srcX1,srcY1,dstX0,dstY0,dstX1,dstY1,mask,filter);
      return 0}
    function buffer_data(c,target,srcData,usage)
     {c.bufferData(target,srcData,usage);return 0}
    function buffer_data_size(c,target,size,usage)
     {c.bufferData(target,size,usage);return 0}
    function buffer_sub_data(c,target,dstByteOffset,srcData)
     {c.bufferSubData(target,dstByteOffset,srcData);return 0}
    function check_framebuffer_status(c,target)
     {return c.checkFramebufferStatus(target)}
    function clear$3(c,mask){c.clear(mask);return 0}
    function clear_bufferfi(c,buffer,drawbuffer,depth,stencil)
     {c.clearBufferfi(buffer,drawbuffer,depth,stencil);return 0}
    function clear_bufferfv(c,buffer,drawbuffer,values)
     {c.clearBufferfv(buffer,drawbuffer,values);return 0}
    function clear_bufferiv(c,buffer,drawbuffer,values)
     {c.clearBufferiv(buffer,drawbuffer,values);return 0}
    function clear_bufferuiv(c,buffer,drawbuffer,values)
     {c.clearBufferuiv(buffer,drawbuffer,values);return 0}
    function clear_color(c,red,green,blue,alpha)
     {c.clearColor(red,green,blue,alpha);return 0}
    function clear_depth(c,depth){c.clearDepth(depth);return 0}
    function clear_stencil(c,s){c.clearStencil(s);return 0}
    function client_wait_sync(c,sync,flags,timeout)
     {return c.clientWaitSync(sync,flags,timeout)}
    function color_mask(c,red,green,blue,alpha)
     {c.colorMask(! ! red,! ! green,! ! blue,! ! alpha);return 0}
    function compile_shader(c,shader){c.compileShader(shader);return 0}
    function compressed_tex_image2d
     (c,target,level,internalformat,width,height,border,srcData)
     {c.compressedTexImage2D
       (target,level,internalformat,width,height,border,srcData);
      return 0}
    function compressed_tex_image2d_size
     (c,target,level,internalformat,width,height,border,imageSize,offset)
     {c.compressedTexImage2D
       (target,level,internalformat,width,height,border,imageSize,offset);
      return 0}
    function compressed_tex_image3d
     (c,target,level,internalformat,width,height,depth,border,srcData)
     {c.compressedTexImage3D
       (target,level,internalformat,width,height,depth,border,srcData);
      return 0}
    function compressed_tex_image3d_size
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      imageSize,
      offset)
     {c.compressedTexImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        imageSize,
        offset);
      return 0}
    function compressed_tex_sub_image2d
     (c,target,level,xoffset,yoffset,width,height,format,srcData)
     {c.compressedTexSubImage2D
       (target,level,xoffset,yoffset,width,height,format,srcData);
      return 0}
    function compressed_tex_sub_image2d_siz
     (c,target,level,xoffset,yoffset,width,height,format,imageSize,offset)
     {c.compressedTexSubImage2D
       (target,level,xoffset,yoffset,width,height,format,imageSize,offset);
      return 0}
    function compressed_tex_sub_image3d
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      srcData)
     {c.compressedTexSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        srcData);
      return 0}
    function compressed_tex_sub_image3d_siz
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      imageSize,
      offset)
     {c.compressedTexSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        imageSize,
        offset);
      return 0}
    function copy_buffer_sub_data
     (c,readTarget,writeTarget,readOffset,writeOffset,size)
     {c.copyBufferSubData(readTarget,writeTarget,readOffset,writeOffset,size);
      return 0}
    function copy_tex_image2d
     (c,target,level,internalformat,x,y,width,height,border)
     {c.copyTexImage2D(target,level,internalformat,x,y,width,height,border);
      return 0}
    function copy_tex_sub_image2d
     (c,target,level,xoffset,yoffset,x,y,width,height)
     {c.copyTexSubImage2D(target,level,xoffset,yoffset,x,y,width,height);
      return 0}
    function copy_tex_sub_image3d
     (c,target,level,xoffset,yoffset,zoffset,x,y,width,height)
     {c.copyTexSubImage3D
       (target,level,xoffset,yoffset,zoffset,x,y,width,height);
      return 0}
    function create_buffer(c){return c.createBuffer()}
    function create_framebuffer(c){return c.createFramebuffer()}
    function create_program(c){return c.createProgram()}
    function create_query(c){return c.createQuery()}
    function create_renderbuffer(c){return c.createRenderbuffer()}
    function create_sampler(c){return c.createSampler()}
    function create_shader(c,type){return c.createShader(type)}
    function create_texture(c){return c.createTexture()}
    function create_transform_feedback(c){return c.createTransformFeedback()}
    function create_vertex_array(c){return c.createVertexArray()}
    function cull_face(c,mode){c.cullFace(mode);return 0}
    function delete_buffer(c,buffer){c.deleteBuffer(buffer);return 0}
    function delete_framebuffer(c,framebuffer)
     {c.deleteFramebuffer(framebuffer);return 0}
    function delete_program(c,program){c.deleteProgram(program);return 0}
    function delete_query(c,query){c.deleteQuery(query);return 0}
    function delete_renderbuffer(c,renderbuffer)
     {c.deleteRenderbuffer(renderbuffer);return 0}
    function delete_sampler(c,sampler){c.deleteSampler(sampler);return 0}
    function delete_shader(c,shader){c.deleteShader(shader);return 0}
    function delete_sync(c,sync){c.deleteSync(sync);return 0}
    function delete_texture(c,texture){c.deleteTexture(texture);return 0}
    function delete_transform_feedback(c,tf)
     {c.deleteTransformFeedback(tf);return 0}
    function delete_vertex_array(c,vertexArray)
     {c.deleteVertexArray(vertexArray);return 0}
    function depth_func(c,func){c.depthFunc(func);return 0}
    function depth_mask(c,flag){c.depthMask(! ! flag);return 0}
    function detach_shader(c,program,shader)
     {c.detachShader(program,shader);return 0}
    function disable(c,cap){c.disable(cap);return 0}
    function disable_vertex_attrib_array(c,index)
     {c.disableVertexAttribArray(index);return 0}
    function draw_arrays(c,mode,first,count)
     {c.drawArrays(mode,first,count);return 0}
    function draw_arrays_instanced(c,mode,first,count,instanceCount)
     {c.drawArraysInstanced(mode,first,count,instanceCount);return 0}
    function draw_buffers(c,buffers)
     {c.drawBuffers(of_list(function(_dP_){return _dP_},buffers));return 0}
    function draw_elements(c,mode,count,type,offset)
     {c.drawElements(mode,count,type,offset);return 0}
    function draw_elements_instanced(c,mode,count,type,offset,instanceCount)
     {c.drawElementsInstanced(mode,count,type,offset,instanceCount);return 0}
    function draw_range_elements(c,mode,start,end,count,type,offset)
     {c.drawRangeElements(mode,start,end,count,type,offset);return 0}
    function enable(c,cap){c.enable(cap);return 0}
    function enable_vertex_attrib_array(c,index)
     {c.enableVertexAttribArray(index);return 0}
    function end_query(c,target){c.endQuery(target);return 0}
    function end_transform_feedback(c){c.endTransformFeedback();return 0}
    function fence_sync(c,condition,flags)
     {return c.fenceSync(condition,flags)}
    function finish(c){c.finish();return 0}
    function flush(c){c.flush();return 0}
    function framebuffer_renderbuffer
     (c,target,attachment,renderbuffertarget,renderbuffer)
     {c.framebufferRenderbuffer
       (target,attachment,renderbuffertarget,renderbuffer);
      return 0}
    function framebuffer_texture2d
     (c,target,attachment,textarget,texture,level)
     {c.framebufferTexture2D(target,attachment,textarget,texture,level);
      return 0}
    function framebuffer_texture_layer
     (c,target,attachment,texture,level,layer)
     {c.framebufferTextureLayer(target,attachment,texture,level,layer);
      return 0}
    function front_face(c,mode){c.frontFace(mode);return 0}
    function generate_mipmap(c,target){c.generateMipmap(target);return 0}
    function get_active_attrib(c,program,index)
     {return c.getActiveAttrib(program,index)}
    function get_active_uniform(c,program,index)
     {return c.getActiveUniform(program,index)}
    function get_active_uniform_block_name(c,program,uniformBlockIndex)
     {return c.getActiveUniformBlockName(program,uniformBlockIndex)}
    function get_active_uniform_block_param(c,program,uniformBlockIndex,pname)
     {return c.getActiveUniformBlockParameter(program,uniformBlockIndex,pname)}
    function get_active_uniforms(c,program,uniformIndices,pname)
     {return c.getActiveUniforms
              (program,
               of_list(function(_dO_){return _dO_},uniformIndices),
               pname)}
    function get_attached_shaders(c,program)
     {return caml_list_of_js_array(c.getAttachedShaders(program))}
    function get_attrib_location(c,program,name)
     {return c.getAttribLocation(program,name)}
    function get_buffer_parameter(c,target,pname)
     {return c.getBufferParameter(target,pname)}
    function get_buffer_sub_data(c,target,srcByteOffset,dstBuffer)
     {c.getBufferSubData(target,srcByteOffset,dstBuffer);return 0}
    function get_error(c){return c.getError()}
    function get_frag_data_location(c,program,name)
     {return c.getFragDataLocation(program,name)}
    function get_framebuffer_attachment_par(c,target,attachment,pname)
     {return c.getFramebufferAttachmentParameter(target,attachment,pname)}
    function get_indexed_parameter(c,target,index)
     {return c.getIndexedParameter(target,index)}
    function get_internalformat_parameter(c,target,internalformat,pname)
     {return c.getInternalformatParameter(target,internalformat,pname)}
    function get_parameter(c,pname){return c.getParameter(pname)}
    function get_program_info_log(c,program)
     {return c.getProgramInfoLog(program)}
    function get_program_parameter(c,program,pname)
     {return c.getProgramParameter(program,pname)}
    function get_query(c,target,pname){return c.getQuery(target,pname)}
    function get_query_parameter(c,query,pname)
     {return c.getQueryParameter(query,pname)}
    function get_renderbuffer_parameter(c,target,pname)
     {return c.getRenderbufferParameter(target,pname)}
    function get_sampler_parameter(c,sampler,pname)
     {return c.getSamplerParameter(sampler,pname)}
    function get_shader_info_log(c,shader){return c.getShaderInfoLog(shader)}
    function get_shader_parameter(c,shader,pname)
     {return c.getShaderParameter(shader,pname)}
    function get_shader_precision_format(c,shadertype,precisiontype)
     {return c.getShaderPrecisionFormat(shadertype,precisiontype)}
    function get_shader_source(c,shader){return c.getShaderSource(shader)}
    function get_sync_parameter(c,sync,pname)
     {return c.getSyncParameter(sync,pname)}
    function get_tex_parameter(c,target,pname)
     {return c.getTexParameter(target,pname)}
    function get_transform_feedback_varying(c,program,index)
     {return c.getTransformFeedbackVarying(program,index)}
    function get_uniform(c,program,location)
     {return c.getUniform(program,location)}
    function get_uniform_block_index(c,program,uniformBlockName)
     {return c.getUniformBlockIndex(program,uniformBlockName)}
    function get_uniform_indices(c,program,uniformNames)
     {var
       _dM_=
        c.getUniformIndices(program,caml_list_to_js_array(uniformNames));
      return to_list(function(_dN_){return _dN_},_dM_)}
    function get_uniform_location(c,program,name)
     {return c.getUniformLocation(program,name)}
    function get_vertex_attrib(c,index,pname)
     {return c.getVertexAttrib(index,pname)}
    function get_vertex_attrib_offset(c,index,pname)
     {return c.getVertexAttribOffset(index,pname)}
    function hint(c,target,mode){c.hint(target,mode);return 0}
    function invalidate_framebuffer(c,target,attachments)
     {c.invalidateFramebuffer
       (target,of_list(function(_dL_){return _dL_},attachments));
      return 0}
    function invalidate_sub_framebuffer(c,target,attachments,x,y,width,height)
     {c.invalidateSubFramebuffer
       (target,
        of_list(function(_dK_){return _dK_},attachments),
        x,
        y,
        width,
        height);
      return 0}
    function is_buffer(c,buffer){return c.isBuffer(buffer) | 0}
    function is_enabled(c,cap){return c.isEnabled(cap) | 0}
    function is_framebuffer(c,framebuffer)
     {return c.isFramebuffer(framebuffer) | 0}
    function is_program(c,program){return c.isProgram(program) | 0}
    function is_query(c,query){return c.isQuery(query) | 0}
    function is_renderbuffer(c,renderbuffer)
     {return c.isRenderbuffer(renderbuffer) | 0}
    function is_sampler(c,sampler){return c.isSampler(sampler) | 0}
    function is_shader(c,shader){return c.isShader(shader) | 0}
    function is_texture(c,texture){return c.isTexture(texture) | 0}
    function is_transform_feedback(c,tf){return c.isTransformFeedback(tf) | 0}
    function is_vertex_array(c,vertexArray)
     {return c.isVertexArray(vertexArray) | 0}
    function line_width$0(c,width){c.lineWidth(width);return 0}
    function link_program(c,program){c.linkProgram(program);return 0}
    function pause_transform_feedback(c){c.pauseTransformFeedback();return 0}
    function pixel_storei(c,pname,param){c.pixelStorei(pname,param);return 0}
    function polygon_offset(c,factor,units)
     {c.polygonOffset(factor,units);return 0}
    function read_buffer(c,src){c.readBuffer(src);return 0}
    function read_pixels_to_pixel_pack(c,x,y,width,height,format,type,offset)
     {c.readPixels(x,y,width,height,format,type,offset);return 0}
    function read_pixels(c,x,y,width,height,format,type,dstData)
     {c.readPixels(x,y,width,height,format,type,dstData);return 0}
    function renderbuffer_storage(c,target,internalformat,width,height)
     {c.renderbufferStorage(target,internalformat,width,height);return 0}
    function renderbuffer_storage_multisamp
     (c,target,samples,internalformat,width,height)
     {c.renderbufferStorageMultisample
       (target,samples,internalformat,width,height);
      return 0}
    function resume_transform_feedback(c)
     {c.resumeTransformFeedback();return 0}
    function sample_coverage(c,value,invert)
     {c.sampleCoverage(value,! ! invert);return 0}
    function sampler_parameterf(c,sampler,pname,param)
     {c.samplerParameterf(sampler,pname,param);return 0}
    function sampler_parameteri(c,sampler,pname,param)
     {c.samplerParameteri(sampler,pname,param);return 0}
    function scissor(c,x,y,width,height){c.scissor(x,y,width,height);return 0}
    function shader_source(c,shader,source)
     {c.shaderSource(shader,source);return 0}
    function stencil_func(c,func,ref,mask)
     {c.stencilFunc(func,ref,mask);return 0}
    function stencil_func_separate(c,face,func,ref,mask)
     {c.stencilFuncSeparate(face,func,ref,mask);return 0}
    function stencil_mask(c,mask){c.stencilMask(mask);return 0}
    function stencil_mask_separate(c,face,mask)
     {c.stencilMaskSeparate(face,mask);return 0}
    function stencil_op(c,fail,zfail,zpass)
     {c.stencilOp(fail,zfail,zpass);return 0}
    function stencil_op_separate(c,face,fail,zfail,zpass)
     {c.stencilOpSeparate(face,fail,zfail,zpass);return 0}
    function tex_image2d
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      border,
      format,
      type,
      srcData,
      srcOffset)
     {c.texImage2D
       (target,
        level,
        internalformat,
        width,
        height,
        border,
        format,
        type,
        srcData,
        srcOffset);
      return 0}
    function tex_image2d_of_source
     (c,target,level,internalformat,width,height,border,format,type,source)
     {c.texImage2D
       (target,level,internalformat,width,height,border,format,type,source);
      return 0}
    function tex_image2d_of_pixel_unpack
     (c,target,level,internalformat,width,height,border,format,type,pboOffset)
     {c.texImage2D
       (target,level,internalformat,width,height,border,format,type,pboOffset);
      return 0}
    function tex_image3d
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type,
      srcData,
      srcOffset)
     {c.texImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        srcData,
        srcOffset);
      return 0}
    function tex_image3d_of_source
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type,
      source)
     {c.texImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        source);
      return 0}
    function tex_image3d_of_pixel_unpack
     (c,
      target,
      level,
      internalformat,
      width,
      height,
      depth,
      border,
      format,
      type,
      pboOffset)
     {c.texImage3D
       (target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        pboOffset);
      return 0}
    function tex_parameterf(c,target,pname,param)
     {c.texParameterf(target,pname,param);return 0}
    function tex_parameteri(c,target,pname,param)
     {c.texParameteri(target,pname,param);return 0}
    function tex_storage2d(c,target,levels,internalformat,width,height)
     {c.texStorage2D(target,levels,internalformat,width,height);return 0}
    function tex_storage3d(c,target,levels,internalformat,width,height,depth)
     {c.texStorage3D(target,levels,internalformat,width,height,depth);
      return 0}
    function tex_sub_image2d
     (c,
      target,
      level,
      xoffset,
      yoffset,
      width,
      height,
      format,
      type,
      srcData,
      srcOffset)
     {c.texSubImage2D
       (target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type,
        srcData,
        srcOffset);
      return 0}
    function tex_sub_image2d_of_source
     (c,target,level,xoffset,yoffset,width,height,format,type,source)
     {c.texSubImage2D
       (target,level,xoffset,yoffset,width,height,format,type,source);
      return 0}
    function tex_sub_image2d_of_pixel_unpac
     (c,target,level,xoffset,yoffset,width,height,format,type,pboOffset)
     {c.texSubImage2D
       (target,level,xoffset,yoffset,width,height,format,type,pboOffset);
      return 0}
    function tex_sub_image3d
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type,
      srcData)
     {c.texSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        srcData);
      return 0}
    function tex_sub_image3d_of_source
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type,
      source)
     {c.texSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        source);
      return 0}
    function tex_sub_image3d_of_pixel_unpac
     (c,
      target,
      level,
      xoffset,
      yoffset,
      zoffset,
      width,
      height,
      depth,
      format,
      type,
      pboOffset)
     {c.texSubImage3D
       (target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        pboOffset);
      return 0}
    function transform_feedback_varyings(c,program,varyings,bufferMode)
     {c.transformFeedbackVaryings
       (program,caml_list_to_js_array(varyings),bufferMode);
      return 0}
    function uniform1f(c,location,x){c.uniform1f(location,x);return 0}
    function uniform1fv(c,location,data){c.uniform1fv(location,data);return 0}
    function uniform1i(c,location,x){c.uniform1i(location,x);return 0}
    function uniform1iv(c,location,data){c.uniform1iv(location,data);return 0}
    function uniform1ui(c,location,v0){c.uniform1ui(location,v0);return 0}
    function uniform1uiv(c,location,data)
     {c.uniform1uiv(location,data);return 0}
    function uniform2f(c,location,x,y){c.uniform2f(location,x,y);return 0}
    function uniform2fv(c,location,data){c.uniform2fv(location,data);return 0}
    function uniform2i(c,location,x,y){c.uniform2i(location,x,y);return 0}
    function uniform2iv(c,location,data){c.uniform2iv(location,data);return 0}
    function uniform2ui(c,location,v0,v1)
     {c.uniform2ui(location,v0,v1);return 0}
    function uniform2uiv(c,location,data)
     {c.uniform2uiv(location,data);return 0}
    function uniform3f(c,location,x,y,z){c.uniform3f(location,x,y,z);return 0}
    function uniform3fv(c,location,data){c.uniform3fv(location,data);return 0}
    function uniform3i(c,location,x,y,z){c.uniform3i(location,x,y,z);return 0}
    function uniform3iv(c,location,data){c.uniform3iv(location,data);return 0}
    function uniform3ui(c,location,v0,v1,v2)
     {c.uniform3ui(location,v0,v1,v2);return 0}
    function uniform3uiv(c,location,data)
     {c.uniform3uiv(location,data);return 0}
    function uniform4f(c,location,x,y,z,w)
     {c.uniform4f(location,x,y,z,w);return 0}
    function uniform4fv(c,location,data){c.uniform4fv(location,data);return 0}
    function uniform4i(c,location,x,y,z,w)
     {c.uniform4i(location,x,y,z,w);return 0}
    function uniform4iv(c,location,data){c.uniform4iv(location,data);return 0}
    function uniform4ui(c,location,v0,v1,v2,v3)
     {c.uniform4ui(location,v0,v1,v2,v3);return 0}
    function uniform4uiv(c,location,data)
     {c.uniform4uiv(location,data);return 0}
    function uniform_block_binding
     (c,program,uniformBlockIndex,uniformBlockBinding)
     {c.uniformBlockBinding(program,uniformBlockIndex,uniformBlockBinding);
      return 0}
    function uniform_matrix2fv(c,location,transpose,data)
     {c.uniformMatrix2fv(location,! ! transpose,data);return 0}
    function uniform_matrix2x3fv(c,location,transpose,data)
     {c.uniformMatrix2x3fv(location,! ! transpose,data);return 0}
    function uniform_matrix2x4fv(c,location,transpose,data)
     {c.uniformMatrix2x4fv(location,! ! transpose,data);return 0}
    function uniform_matrix3fv(c,location,transpose,data)
     {c.uniformMatrix3fv(location,! ! transpose,data);return 0}
    function uniform_matrix3x2fv(c,location,transpose,data)
     {c.uniformMatrix3x2fv(location,! ! transpose,data);return 0}
    function uniform_matrix3x4fv(c,location,transpose,data)
     {c.uniformMatrix3x4fv(location,! ! transpose,data);return 0}
    function uniform_matrix4fv(c,location,transpose,data)
     {c.uniformMatrix4fv(location,! ! transpose,data);return 0}
    function uniform_matrix4x2fv(c,location,transpose,data)
     {c.uniformMatrix4x2fv(location,! ! transpose,data);return 0}
    function uniform_matrix4x3fv(c,location,transpose,data)
     {c.uniformMatrix4x3fv(location,! ! transpose,data);return 0}
    function use_program(c,program){c.useProgram(program);return 0}
    function validate_program(c,program){c.validateProgram(program);return 0}
    function vertex_attrib1f(c,index,x){c.vertexAttrib1f(index,x);return 0}
    function vertex_attrib1fv(c,index,values)
     {c.vertexAttrib1fv(index,values);return 0}
    function vertex_attrib2f(c,index,x,y)
     {c.vertexAttrib2f(index,x,y);return 0}
    function vertex_attrib2fv(c,index,values)
     {c.vertexAttrib2fv(index,values);return 0}
    function vertex_attrib3f(c,index,x,y,z)
     {c.vertexAttrib3f(index,x,y,z);return 0}
    function vertex_attrib3fv(c,index,values)
     {c.vertexAttrib3fv(index,values);return 0}
    function vertex_attrib4f(c,index,x,y,z,w)
     {c.vertexAttrib4f(index,x,y,z,w);return 0}
    function vertex_attrib4fv(c,index,values)
     {c.vertexAttrib4fv(index,values);return 0}
    function vertex_attrib_divisor(c,index,divisor)
     {c.vertexAttribDivisor(index,divisor);return 0}
    function vertex_attrib_i4i(c,index,x,y,z,w)
     {c.vertexAttribI4i(index,x,y,z,w);return 0}
    function vertex_attrib_i4iv(c,index,values)
     {c.vertexAttribI4iv(index,values);return 0}
    function vertex_attrib_i4ui(c,index,x,y,z,w)
     {c.vertexAttribI4ui(index,x,y,z,w);return 0}
    function vertex_attrib_i4uiv(c,index,values)
     {c.vertexAttribI4uiv(index,values);return 0}
    function vertex_attrib_ipointer(c,index,size,type,stride,offset)
     {c.vertexAttribIPointer(index,size,type,stride,offset);return 0}
    function vertex_attrib_pointer(c,index,size,type,normalized,stride,offset)
     {c.vertexAttribPointer(index,size,type,! ! normalized,stride,offset);
      return 0}
    function viewport(c,x,y,width,height)
     {c.viewport(x,y,width,height);return 0}
    function wait_sync(c,sync,flags,timeout)
     {c.waitSync(sync,flags,timeout);return 0}
    var
     gl1ctx=target.WebGLRenderingContext,
     depth_buffer_bit=caml_call2(Int[2],gl1ctx,cst_DEPTH_BUFFER_BIT),
     stencil_buffer_bit=caml_call2(Int[2],gl1ctx,cst_STENCIL_BUFFER_BIT),
     color_buffer_bit=caml_call2(Int[2],gl1ctx,cst_COLOR_BUFFER_BIT),
     points=caml_call2(Int[2],gl1ctx,cst_POINTS),
     lines=caml_call2(Int[2],gl1ctx,cst_LINES),
     line_loop=caml_call2(Int[2],gl1ctx,cst_LINE_LOOP),
     line_strip=caml_call2(Int[2],gl1ctx,cst_LINE_STRIP),
     triangles=caml_call2(Int[2],gl1ctx,cst_TRIANGLES),
     triangle_strip=caml_call2(Int[2],gl1ctx,cst_TRIANGLE_STRIP),
     triangle_fan=caml_call2(Int[2],gl1ctx,cst_TRIANGLE_FAN),
     zero=caml_call2(Int[2],gl1ctx,cst_ZERO),
     one=caml_call2(Int[2],gl1ctx,cst_ONE),
     src_color=caml_call2(Int[2],gl1ctx,cst_SRC_COLOR),
     one_minus_src_color=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_SRC_COLOR),
     src_alpha=caml_call2(Int[2],gl1ctx,cst_SRC_ALPHA),
     one_minus_src_alpha=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_SRC_ALPHA),
     dst_alpha=caml_call2(Int[2],gl1ctx,cst_DST_ALPHA),
     one_minus_dst_alpha=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_DST_ALPHA),
     dst_color=caml_call2(Int[2],gl1ctx,cst_DST_COLOR),
     one_minus_dst_color=caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_DST_COLOR),
     src_alpha_saturate=caml_call2(Int[2],gl1ctx,cst_SRC_ALPHA_SATURATE),
     func_add=caml_call2(Int[2],gl1ctx,cst_FUNC_ADD),
     blend_equation$0=caml_call2(Int[2],gl1ctx,cst_BLEND_EQUATION),
     blend_equation_rgb=caml_call2(Int[2],gl1ctx,cst_BLEND_EQUATION_RGB),
     blend_equation_alpha=caml_call2(Int[2],gl1ctx,cst_BLEND_EQUATION_ALPHA),
     func_subtract=caml_call2(Int[2],gl1ctx,cst_FUNC_SUBTRACT),
     func_reverse_subtract=caml_call2(Int[2],gl1ctx,cst_FUNC_REVERSE_SUBTRACT),
     blend_dst_rgb=caml_call2(Int[2],gl1ctx,cst_BLEND_DST_RGB),
     blend_src_rgb=caml_call2(Int[2],gl1ctx,cst_BLEND_SRC_RGB),
     blend_dst_alpha=caml_call2(Int[2],gl1ctx,cst_BLEND_DST_ALPHA),
     blend_src_alpha=caml_call2(Int[2],gl1ctx,cst_BLEND_SRC_ALPHA),
     constant_color=caml_call2(Int[2],gl1ctx,cst_CONSTANT_COLOR),
     one_minus_constant_color=
      caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_CONSTANT_COLOR),
     constant_alpha=caml_call2(Int[2],gl1ctx,cst_CONSTANT_ALPHA),
     one_minus_constant_alpha=
      caml_call2(Int[2],gl1ctx,cst_ONE_MINUS_CONSTANT_ALPHA),
     blend_color$0=caml_call2(Int[2],gl1ctx,cst_BLEND_COLOR),
     array_buffer$2=caml_call2(Int[2],gl1ctx,cst_ARRAY_BUFFER),
     element_array_buffer=caml_call2(Int[2],gl1ctx,cst_ELEMENT_ARRAY_BUFFER),
     array_buffer_binding=caml_call2(Int[2],gl1ctx,cst_ARRAY_BUFFER_BINDING),
     element_array_buffer_binding=
      caml_call2(Int[2],gl1ctx,cst_ELEMENT_ARRAY_BUFFER_BINDI),
     stream_draw=caml_call2(Int[2],gl1ctx,cst_STREAM_DRAW),
     static_draw=caml_call2(Int[2],gl1ctx,cst_STATIC_DRAW),
     dynamic_draw=caml_call2(Int[2],gl1ctx,cst_DYNAMIC_DRAW),
     buffer_size=caml_call2(Int[2],gl1ctx,cst_BUFFER_SIZE),
     buffer_usage=caml_call2(Int[2],gl1ctx,cst_BUFFER_USAGE),
     current_vertex_attrib=caml_call2(Int[2],gl1ctx,cst_CURRENT_VERTEX_ATTRIB),
     front=caml_call2(Int[2],gl1ctx,cst_FRONT),
     back$0=caml_call2(Int[2],gl1ctx,cst_BACK),
     front_and_back=caml_call2(Int[2],gl1ctx,cst_FRONT_AND_BACK),
     cull_face$0=caml_call2(Int[2],gl1ctx,cst_CULL_FACE),
     blend=caml_call2(Int[2],gl1ctx,cst_BLEND),
     dither=caml_call2(Int[2],gl1ctx,cst_DITHER),
     stencil_test=caml_call2(Int[2],gl1ctx,cst_STENCIL_TEST),
     depth_test=caml_call2(Int[2],gl1ctx,cst_DEPTH_TEST),
     scissor_test=caml_call2(Int[2],gl1ctx,cst_SCISSOR_TEST),
     polygon_offset_fill=caml_call2(Int[2],gl1ctx,cst_POLYGON_OFFSET_FILL),
     sample_alpha_to_coverage=
      caml_call2(Int[2],gl1ctx,cst_SAMPLE_ALPHA_TO_COVERAGE),
     sample_coverage$0=caml_call2(Int[2],gl1ctx,cst_SAMPLE_COVERAGE),
     no_error=caml_call2(Int[2],gl1ctx,cst_NO_ERROR),
     invalid_enum=caml_call2(Int[2],gl1ctx,cst_INVALID_ENUM),
     invalid_value=caml_call2(Int[2],gl1ctx,cst_INVALID_VALUE),
     invalid_operation=caml_call2(Int[2],gl1ctx,cst_INVALID_OPERATION),
     out_of_memory=caml_call2(Int[2],gl1ctx,cst_OUT_OF_MEMORY),
     cw=caml_call2(Int[2],gl1ctx,cst_CW),
     ccw=caml_call2(Int[2],gl1ctx,cst_CCW),
     line_width$1=caml_call2(Int[2],gl1ctx,cst_LINE_WIDTH),
     aliased_point_size_range=
      caml_call2(Int[2],gl1ctx,cst_ALIASED_POINT_SIZE_RANGE),
     aliased_line_width_range=
      caml_call2(Int[2],gl1ctx,cst_ALIASED_LINE_WIDTH_RANGE),
     cull_face_mode=caml_call2(Int[2],gl1ctx,cst_CULL_FACE_MODE),
     front_face$0=caml_call2(Int[2],gl1ctx,cst_FRONT_FACE),
     depth_range=caml_call2(Int[2],gl1ctx,cst_DEPTH_RANGE),
     depth_writemask=caml_call2(Int[2],gl1ctx,cst_DEPTH_WRITEMASK),
     depth_clear_value=caml_call2(Int[2],gl1ctx,cst_DEPTH_CLEAR_VALUE),
     depth_func$0=caml_call2(Int[2],gl1ctx,cst_DEPTH_FUNC),
     stencil_clear_value=caml_call2(Int[2],gl1ctx,cst_STENCIL_CLEAR_VALUE),
     stencil_func$0=caml_call2(Int[2],gl1ctx,cst_STENCIL_FUNC),
     stencil_fail=caml_call2(Int[2],gl1ctx,cst_STENCIL_FAIL),
     stencil_pass_depth_fail=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_PASS_DEPTH_FAIL),
     stencil_pass_depth_pass=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_PASS_DEPTH_PASS),
     stencil_ref=caml_call2(Int[2],gl1ctx,cst_STENCIL_REF),
     stencil_value_mask=caml_call2(Int[2],gl1ctx,cst_STENCIL_VALUE_MASK),
     stencil_writemask=caml_call2(Int[2],gl1ctx,cst_STENCIL_WRITEMASK),
     stencil_back_func=caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_FUNC),
     stencil_back_fail=caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_FAIL),
     stencil_back_pass_depth_fail=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_PASS_DEPTH_FA),
     stencil_back_pass_depth_pass=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_PASS_DEPTH_PA),
     stencil_back_ref=caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_REF),
     stencil_back_value_mask=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_VALUE_MASK),
     stencil_back_writemask=
      caml_call2(Int[2],gl1ctx,cst_STENCIL_BACK_WRITEMASK),
     viewport$0=caml_call2(Int[2],gl1ctx,cst_VIEWPORT),
     scissor_box=caml_call2(Int[2],gl1ctx,cst_SCISSOR_BOX),
     color_clear_value=caml_call2(Int[2],gl1ctx,cst_COLOR_CLEAR_VALUE),
     color_writemask=caml_call2(Int[2],gl1ctx,cst_COLOR_WRITEMASK),
     unpack_alignment=caml_call2(Int[2],gl1ctx,cst_UNPACK_ALIGNMENT),
     pack_alignment=caml_call2(Int[2],gl1ctx,cst_PACK_ALIGNMENT),
     max_texture_size=caml_call2(Int[2],gl1ctx,cst_MAX_TEXTURE_SIZE),
     max_viewport_dims=caml_call2(Int[2],gl1ctx,cst_MAX_VIEWPORT_DIMS),
     subpixel_bits=caml_call2(Int[2],gl1ctx,cst_SUBPIXEL_BITS),
     red_bits=caml_call2(Int[2],gl1ctx,cst_RED_BITS),
     green_bits=caml_call2(Int[2],gl1ctx,cst_GREEN_BITS),
     blue_bits=caml_call2(Int[2],gl1ctx,cst_BLUE_BITS),
     alpha_bits=caml_call2(Int[2],gl1ctx,cst_ALPHA_BITS),
     depth_bits=caml_call2(Int[2],gl1ctx,cst_DEPTH_BITS),
     stencil_bits=caml_call2(Int[2],gl1ctx,cst_STENCIL_BITS),
     polygon_offset_units=caml_call2(Int[2],gl1ctx,cst_POLYGON_OFFSET_UNITS),
     polygon_offset_factor=caml_call2(Int[2],gl1ctx,cst_POLYGON_OFFSET_FACTOR),
     texture_binding_2d=caml_call2(Int[2],gl1ctx,cst_TEXTURE_BINDING_2D),
     sample_buffers=caml_call2(Int[2],gl1ctx,cst_SAMPLE_BUFFERS),
     samples=caml_call2(Int[2],gl1ctx,cst_SAMPLES),
     sample_coverage_value=caml_call2(Int[2],gl1ctx,cst_SAMPLE_COVERAGE_VALUE),
     sample_coverage_invert=
      caml_call2(Int[2],gl1ctx,cst_SAMPLE_COVERAGE_INVERT),
     compressed_texture_formats=
      caml_call2(Int[2],gl1ctx,cst_COMPRESSED_TEXTURE_FORMATS),
     dont_care=caml_call2(Int[2],gl1ctx,cst_DONT_CARE),
     fastest=caml_call2(Int[2],gl1ctx,cst_FASTEST),
     nicest=caml_call2(Int[2],gl1ctx,cst_NICEST),
     generate_mipmap_hint=caml_call2(Int[2],gl1ctx,cst_GENERATE_MIPMAP_HINT),
     byte$0=caml_call2(Int[2],gl1ctx,cst_BYTE),
     unsigned_byte=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_BYTE),
     short$0=caml_call2(Int[2],gl1ctx,cst_SHORT),
     unsigned_short=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT),
     int$3=caml_call2(Int[2],gl1ctx,cst_INT),
     unsigned_int=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_INT),
     float$2=caml_call2(Int[2],gl1ctx,cst_FLOAT),
     depth_component=caml_call2(Int[2],gl1ctx,cst_DEPTH_COMPONENT),
     alpha$0=caml_call2(Int[2],gl1ctx,cst_ALPHA),
     rgb=caml_call2(Int[2],gl1ctx,cst_RGB),
     rgba=caml_call2(Int[2],gl1ctx,cst_RGBA),
     luminance=caml_call2(Int[2],gl1ctx,cst_LUMINANCE),
     luminance_alpha=caml_call2(Int[2],gl1ctx,cst_LUMINANCE_ALPHA),
     unsigned_short_4_4_4_4=
      caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT_4_4_4_4),
     unsigned_short_5_5_5_1=
      caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT_5_5_5_1),
     unsigned_short_5_6_5=caml_call2(Int[2],gl1ctx,cst_UNSIGNED_SHORT_5_6_5),
     fragment_shader=caml_call2(Int[2],gl1ctx,cst_FRAGMENT_SHADER),
     vertex_shader=caml_call2(Int[2],gl1ctx,cst_VERTEX_SHADER),
     max_vertex_attribs=caml_call2(Int[2],gl1ctx,cst_MAX_VERTEX_ATTRIBS),
     max_vertex_uniform_vectors=
      caml_call2(Int[2],gl1ctx,cst_MAX_VERTEX_UNIFORM_VECTORS),
     max_varying_vectors=caml_call2(Int[2],gl1ctx,cst_MAX_VARYING_VECTORS),
     max_combined_texture_image_uni=
      caml_call2(Int[2],gl1ctx,cst_MAX_COMBINED_TEXTURE_IMAGE),
     max_vertex_texture_image_units=
      caml_call2(Int[2],gl1ctx,cst_MAX_VERTEX_TEXTURE_IMAGE_U),
     max_texture_image_units=
      caml_call2(Int[2],gl1ctx,cst_MAX_TEXTURE_IMAGE_UNITS),
     max_fragment_uniform_vectors=
      caml_call2(Int[2],gl1ctx,cst_MAX_FRAGMENT_UNIFORM_VECTO),
     shader_type=caml_call2(Int[2],gl1ctx,cst_SHADER_TYPE),
     delete_status=caml_call2(Int[2],gl1ctx,cst_DELETE_STATUS),
     link_status=caml_call2(Int[2],gl1ctx,cst_LINK_STATUS),
     validate_status=caml_call2(Int[2],gl1ctx,cst_VALIDATE_STATUS),
     attached_shaders=caml_call2(Int[2],gl1ctx,cst_ATTACHED_SHADERS),
     active_uniforms=caml_call2(Int[2],gl1ctx,cst_ACTIVE_UNIFORMS),
     active_attributes=caml_call2(Int[2],gl1ctx,cst_ACTIVE_ATTRIBUTES),
     shading_language_version=
      caml_call2(Int[2],gl1ctx,cst_SHADING_LANGUAGE_VERSION),
     current_program=caml_call2(Int[2],gl1ctx,cst_CURRENT_PROGRAM),
     never=caml_call2(Int[2],gl1ctx,cst_NEVER),
     less=caml_call2(Int[2],gl1ctx,cst_LESS),
     equal$0=caml_call2(Int[2],gl1ctx,cst_EQUAL),
     lequal=caml_call2(Int[2],gl1ctx,cst_LEQUAL),
     greater=caml_call2(Int[2],gl1ctx,cst_GREATER),
     notequal=caml_call2(Int[2],gl1ctx,cst_NOTEQUAL),
     gequal=caml_call2(Int[2],gl1ctx,cst_GEQUAL),
     always=caml_call2(Int[2],gl1ctx,cst_ALWAYS),
     keep=caml_call2(Int[2],gl1ctx,cst_KEEP),
     replace=caml_call2(Int[2],gl1ctx,cst_REPLACE),
     incr=caml_call2(Int[2],gl1ctx,cst_INCR),
     decr=caml_call2(Int[2],gl1ctx,cst_DECR),
     invert=caml_call2(Int[2],gl1ctx,cst_INVERT),
     incr_wrap=caml_call2(Int[2],gl1ctx,cst_INCR_WRAP),
     decr_wrap=caml_call2(Int[2],gl1ctx,cst_DECR_WRAP),
     vendor=caml_call2(Int[2],gl1ctx,cst_VENDOR),
     renderer=caml_call2(Int[2],gl1ctx,cst_RENDERER),
     version=caml_call2(Int[2],gl1ctx,cst_VERSION),
     nearest=caml_call2(Int[2],gl1ctx,cst_NEAREST),
     linear=caml_call2(Int[2],gl1ctx,cst_LINEAR),
     nearest_mipmap_nearest=
      caml_call2(Int[2],gl1ctx,cst_NEAREST_MIPMAP_NEAREST),
     linear_mipmap_nearest=caml_call2(Int[2],gl1ctx,cst_LINEAR_MIPMAP_NEAREST),
     nearest_mipmap_linear=caml_call2(Int[2],gl1ctx,cst_NEAREST_MIPMAP_LINEAR),
     linear_mipmap_linear=caml_call2(Int[2],gl1ctx,cst_LINEAR_MIPMAP_LINEAR),
     texture_mag_filter=caml_call2(Int[2],gl1ctx,cst_TEXTURE_MAG_FILTER),
     texture_min_filter=caml_call2(Int[2],gl1ctx,cst_TEXTURE_MIN_FILTER),
     texture_wrap_s=caml_call2(Int[2],gl1ctx,cst_TEXTURE_WRAP_S),
     texture_wrap_t=caml_call2(Int[2],gl1ctx,cst_TEXTURE_WRAP_T),
     texture_2d=caml_call2(Int[2],gl1ctx,cst_TEXTURE_2D),
     texture=caml_call2(Int[2],gl1ctx,cst_TEXTURE),
     texture_cube_map=caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP),
     texture_binding_cube_map=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_BINDING_CUBE_MAP),
     texture_cube_map_positive_x=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_POSITIVE_),
     texture_cube_map_negative_x=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_NEGATIVE_),
     texture_cube_map_positive_y=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_POSITIVE_$0),
     texture_cube_map_negative_y=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_NEGATIVE_$0),
     texture_cube_map_positive_z=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_POSITIVE_$1),
     texture_cube_map_negative_z=
      caml_call2(Int[2],gl1ctx,cst_TEXTURE_CUBE_MAP_NEGATIVE_$1),
     max_cube_map_texture_size=
      caml_call2(Int[2],gl1ctx,cst_MAX_CUBE_MAP_TEXTURE_SIZE),
     texture0=caml_call2(Int[2],gl1ctx,cst_TEXTURE0),
     texture1=caml_call2(Int[2],gl1ctx,cst_TEXTURE1),
     texture2=caml_call2(Int[2],gl1ctx,cst_TEXTURE2),
     texture3=caml_call2(Int[2],gl1ctx,cst_TEXTURE3),
     texture4=caml_call2(Int[2],gl1ctx,cst_TEXTURE4),
     texture5=caml_call2(Int[2],gl1ctx,cst_TEXTURE5),
     texture6=caml_call2(Int[2],gl1ctx,cst_TEXTURE6),
     texture7=caml_call2(Int[2],gl1ctx,cst_TEXTURE7),
     texture8=caml_call2(Int[2],gl1ctx,cst_TEXTURE8),
     texture9=caml_call2(Int[2],gl1ctx,cst_TEXTURE9),
     texture10=caml_call2(Int[2],gl1ctx,cst_TEXTURE10),
     texture11=caml_call2(Int[2],gl1ctx,cst_TEXTURE11),
     texture12=caml_call2(Int[2],gl1ctx,cst_TEXTURE12),
     texture13=caml_call2(Int[2],gl1ctx,cst_TEXTURE13),
     texture14=caml_call2(Int[2],gl1ctx,cst_TEXTURE14),
     texture15=caml_call2(Int[2],gl1ctx,cst_TEXTURE15),
     texture16=caml_call2(Int[2],gl1ctx,cst_TEXTURE16),
     texture17=caml_call2(Int[2],gl1ctx,cst_TEXTURE17),
     texture18=caml_call2(Int[2],gl1ctx,cst_TEXTURE18),
     texture19=caml_call2(Int[2],gl1ctx,cst_TEXTURE19),
     texture20=caml_call2(Int[2],gl1ctx,cst_TEXTURE20),
     texture21=caml_call2(Int[2],gl1ctx,cst_TEXTURE21),
     texture22=caml_call2(Int[2],gl1ctx,cst_TEXTURE22),
     texture23=caml_call2(Int[2],gl1ctx,cst_TEXTURE23),
     texture24=caml_call2(Int[2],gl1ctx,cst_TEXTURE24),
     texture25=caml_call2(Int[2],gl1ctx,cst_TEXTURE25),
     texture26=caml_call2(Int[2],gl1ctx,cst_TEXTURE26),
     texture27=caml_call2(Int[2],gl1ctx,cst_TEXTURE27),
     texture28=caml_call2(Int[2],gl1ctx,cst_TEXTURE28),
     texture29=caml_call2(Int[2],gl1ctx,cst_TEXTURE29),
     texture30=caml_call2(Int[2],gl1ctx,cst_TEXTURE30),
     texture31=caml_call2(Int[2],gl1ctx,cst_TEXTURE31),
     active_texture$0=caml_call2(Int[2],gl1ctx,cst_ACTIVE_TEXTURE),
     repeat$1=caml_call2(Int[2],gl1ctx,cst_REPEAT),
     clamp_to_edge=caml_call2(Int[2],gl1ctx,cst_CLAMP_TO_EDGE),
     mirrored_repeat=caml_call2(Int[2],gl1ctx,cst_MIRRORED_REPEAT),
     float_vec2=caml_call2(Int[2],gl1ctx,cst_FLOAT_VEC2),
     float_vec3=caml_call2(Int[2],gl1ctx,cst_FLOAT_VEC3),
     float_vec4=caml_call2(Int[2],gl1ctx,cst_FLOAT_VEC4),
     int_vec2=caml_call2(Int[2],gl1ctx,cst_INT_VEC2),
     int_vec3=caml_call2(Int[2],gl1ctx,cst_INT_VEC3),
     int_vec4=caml_call2(Int[2],gl1ctx,cst_INT_VEC4),
     bool$1=caml_call2(Int[2],gl1ctx,cst_BOOL),
     bool_vec2=caml_call2(Int[2],gl1ctx,cst_BOOL_VEC2),
     bool_vec3=caml_call2(Int[2],gl1ctx,cst_BOOL_VEC3),
     bool_vec4=caml_call2(Int[2],gl1ctx,cst_BOOL_VEC4),
     float_mat2=caml_call2(Int[2],gl1ctx,cst_FLOAT_MAT2),
     float_mat3=caml_call2(Int[2],gl1ctx,cst_FLOAT_MAT3),
     float_mat4=caml_call2(Int[2],gl1ctx,cst_FLOAT_MAT4),
     sampler_2d=caml_call2(Int[2],gl1ctx,cst_SAMPLER_2D),
     sampler_cube=caml_call2(Int[2],gl1ctx,cst_SAMPLER_CUBE),
     vertex_attrib_array_enabled=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_ENABLE),
     vertex_attrib_array_size=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_SIZE),
     vertex_attrib_array_stride=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_STRIDE),
     vertex_attrib_array_type=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_TYPE),
     vertex_attrib_array_normalized=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_NORMAL),
     vertex_attrib_array_pointer=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_POINTE),
     vertex_attrib_array_buffer_bin=
      caml_call2(Int[2],gl1ctx,cst_VERTEX_ATTRIB_ARRAY_BUFFER),
     implementation_color_read_type=
      caml_call2(Int[2],gl1ctx,cst_IMPLEMENTATION_COLOR_READ_),
     implementation_color_read_form=
      caml_call2(Int[2],gl1ctx,cst_IMPLEMENTATION_COLOR_READ_$0),
     compile_status=caml_call2(Int[2],gl1ctx,cst_COMPILE_STATUS),
     low_float=caml_call2(Int[2],gl1ctx,cst_LOW_FLOAT),
     medium_float=caml_call2(Int[2],gl1ctx,cst_MEDIUM_FLOAT),
     high_float=caml_call2(Int[2],gl1ctx,cst_HIGH_FLOAT),
     low_int=caml_call2(Int[2],gl1ctx,cst_LOW_INT),
     medium_int=caml_call2(Int[2],gl1ctx,cst_MEDIUM_INT),
     high_int=caml_call2(Int[2],gl1ctx,cst_HIGH_INT),
     framebuffer=caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER),
     renderbuffer=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER),
     rgba4=caml_call2(Int[2],gl1ctx,cst_RGBA4),
     rgb5_a1=caml_call2(Int[2],gl1ctx,cst_RGB5_A1),
     rgb565=caml_call2(Int[2],gl1ctx,cst_RGB565),
     depth_component16=caml_call2(Int[2],gl1ctx,cst_DEPTH_COMPONENT16),
     stencil_index8=caml_call2(Int[2],gl1ctx,cst_STENCIL_INDEX8),
     depth_stencil=caml_call2(Int[2],gl1ctx,cst_DEPTH_STENCIL),
     renderbuffer_width=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_WIDTH),
     renderbuffer_height=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_HEIGHT),
     renderbuffer_internal_format=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_INTERNAL_FORM),
     renderbuffer_red_size=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_RED_SIZE),
     renderbuffer_green_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_GREEN_SIZE),
     renderbuffer_blue_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_BLUE_SIZE),
     renderbuffer_alpha_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_ALPHA_SIZE),
     renderbuffer_depth_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_DEPTH_SIZE),
     renderbuffer_stencil_size=
      caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_STENCIL_SIZE),
     framebuffer_attachment_object_=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_OBJ),
     framebuffer_attachment_object_$0=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_OBJ$0),
     framebuffer_attachment_texture=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_TEX),
     framebuffer_attachment_texture$0=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_ATTACHMENT_TEX$0),
     color_attachment0=caml_call2(Int[2],gl1ctx,cst_COLOR_ATTACHMENT0),
     depth_attachment=caml_call2(Int[2],gl1ctx,cst_DEPTH_ATTACHMENT),
     stencil_attachment=caml_call2(Int[2],gl1ctx,cst_STENCIL_ATTACHMENT),
     depth_stencil_attachment=
      caml_call2(Int[2],gl1ctx,cst_DEPTH_STENCIL_ATTACHMENT),
     none$0=caml_call2(Int[2],gl1ctx,cst_NONE),
     framebuffer_complete=caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_COMPLETE),
     framebuffer_incomplete_attachm=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_INCOMPLETE_ATT),
     framebuffer_incomplete_missing=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_INCOMPLETE_MIS),
     framebuffer_incomplete_dimensi=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_INCOMPLETE_DIM),
     framebuffer_unsupported=
      caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_UNSUPPORTED),
     framebuffer_binding=caml_call2(Int[2],gl1ctx,cst_FRAMEBUFFER_BINDING),
     renderbuffer_binding=caml_call2(Int[2],gl1ctx,cst_RENDERBUFFER_BINDING),
     max_renderbuffer_size=caml_call2(Int[2],gl1ctx,cst_MAX_RENDERBUFFER_SIZE),
     invalid_framebuffer_operation=
      caml_call2(Int[2],gl1ctx,cst_INVALID_FRAMEBUFFER_OPERAT),
     unpack_flip_y_webgl=caml_call2(Int[2],gl1ctx,cst_UNPACK_FLIP_Y_WEBGL),
     unpack_premultiply_alpha_webgl=
      caml_call2(Int[2],gl1ctx,cst_UNPACK_PREMULTIPLY_ALPHA_W),
     context_lost_webgl=caml_call2(Int[2],gl1ctx,cst_CONTEXT_LOST_WEBGL),
     unpack_colorspace_conversion_w=
      caml_call2(Int[2],gl1ctx,cst_UNPACK_COLORSPACE_CONVERSI),
     browser_default_webgl=caml_call2(Int[2],gl1ctx,cst_BROWSER_DEFAULT_WEBGL),
     gl2ctx=target.WebGL2RenderingContext,
     read_buffer$0=caml_call2(Int[2],gl2ctx,cst_READ_BUFFER),
     unpack_row_length=caml_call2(Int[2],gl2ctx,cst_UNPACK_ROW_LENGTH),
     unpack_skip_rows=caml_call2(Int[2],gl2ctx,cst_UNPACK_SKIP_ROWS),
     unpack_skip_pixels=caml_call2(Int[2],gl2ctx,cst_UNPACK_SKIP_PIXELS),
     pack_row_length=caml_call2(Int[2],gl2ctx,cst_PACK_ROW_LENGTH),
     pack_skip_rows=caml_call2(Int[2],gl2ctx,cst_PACK_SKIP_ROWS),
     pack_skip_pixels=caml_call2(Int[2],gl2ctx,cst_PACK_SKIP_PIXELS),
     color$2=caml_call2(Int[2],gl2ctx,cst_COLOR),
     depth$0=caml_call2(Int[2],gl2ctx,cst_DEPTH),
     stencil$0=caml_call2(Int[2],gl2ctx,cst_STENCIL),
     red=caml_call2(Int[2],gl2ctx,cst_RED),
     rgb8=caml_call2(Int[2],gl2ctx,cst_RGB8),
     rgba8=caml_call2(Int[2],gl2ctx,cst_RGBA8),
     rgb10_a2=caml_call2(Int[2],gl2ctx,cst_RGB10_A2),
     texture_binding_3d=caml_call2(Int[2],gl2ctx,cst_TEXTURE_BINDING_3D),
     unpack_skip_images=caml_call2(Int[2],gl2ctx,cst_UNPACK_SKIP_IMAGES),
     unpack_image_height=caml_call2(Int[2],gl2ctx,cst_UNPACK_IMAGE_HEIGHT),
     texture_3d=caml_call2(Int[2],gl2ctx,cst_TEXTURE_3D),
     texture_wrap_r=caml_call2(Int[2],gl2ctx,cst_TEXTURE_WRAP_R),
     max_3d_texture_size=caml_call2(Int[2],gl2ctx,cst_MAX_3D_TEXTURE_SIZE),
     unsigned_int_2_10_10_10_rev=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_2_10_10_10_RE),
     max_elements_vertices=caml_call2(Int[2],gl2ctx,cst_MAX_ELEMENTS_VERTICES),
     max_elements_indices=caml_call2(Int[2],gl2ctx,cst_MAX_ELEMENTS_INDICES),
     texture_min_lod=caml_call2(Int[2],gl2ctx,cst_TEXTURE_MIN_LOD),
     texture_max_lod=caml_call2(Int[2],gl2ctx,cst_TEXTURE_MAX_LOD),
     texture_base_level=caml_call2(Int[2],gl2ctx,cst_TEXTURE_BASE_LEVEL),
     texture_max_level=caml_call2(Int[2],gl2ctx,cst_TEXTURE_MAX_LEVEL),
     min$1=caml_call2(Int[2],gl2ctx,cst_MIN),
     max$2=caml_call2(Int[2],gl2ctx,cst_MAX),
     depth_component24=caml_call2(Int[2],gl2ctx,cst_DEPTH_COMPONENT24),
     max_texture_lod_bias=caml_call2(Int[2],gl2ctx,cst_MAX_TEXTURE_LOD_BIAS),
     texture_compare_mode=caml_call2(Int[2],gl2ctx,cst_TEXTURE_COMPARE_MODE),
     texture_compare_func=caml_call2(Int[2],gl2ctx,cst_TEXTURE_COMPARE_FUNC),
     current_query=caml_call2(Int[2],gl2ctx,cst_CURRENT_QUERY),
     query_result=caml_call2(Int[2],gl2ctx,cst_QUERY_RESULT),
     query_result_available=
      caml_call2(Int[2],gl2ctx,cst_QUERY_RESULT_AVAILABLE),
     stream_read=caml_call2(Int[2],gl2ctx,cst_STREAM_READ),
     stream_copy=caml_call2(Int[2],gl2ctx,cst_STREAM_COPY),
     static_read=caml_call2(Int[2],gl2ctx,cst_STATIC_READ),
     static_copy=caml_call2(Int[2],gl2ctx,cst_STATIC_COPY),
     dynamic_read=caml_call2(Int[2],gl2ctx,cst_DYNAMIC_READ),
     dynamic_copy=caml_call2(Int[2],gl2ctx,cst_DYNAMIC_COPY),
     max_draw_buffers=caml_call2(Int[2],gl2ctx,cst_MAX_DRAW_BUFFERS),
     draw_buffer0=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER0),
     draw_buffer1=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER1),
     draw_buffer2=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER2),
     draw_buffer3=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER3),
     draw_buffer4=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER4),
     draw_buffer5=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER5),
     draw_buffer6=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER6),
     draw_buffer7=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER7),
     draw_buffer8=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER8),
     draw_buffer9=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER9),
     draw_buffer10=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER10),
     draw_buffer11=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER11),
     draw_buffer12=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER12),
     draw_buffer13=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER13),
     draw_buffer14=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER14),
     draw_buffer15=caml_call2(Int[2],gl2ctx,cst_DRAW_BUFFER15),
     max_fragment_uniform_component=
      caml_call2(Int[2],gl2ctx,cst_MAX_FRAGMENT_UNIFORM_COMPO),
     max_vertex_uniform_components=
      caml_call2(Int[2],gl2ctx,cst_MAX_VERTEX_UNIFORM_COMPONE),
     sampler_3d=caml_call2(Int[2],gl2ctx,cst_SAMPLER_3D),
     sampler_2d_shadow=caml_call2(Int[2],gl2ctx,cst_SAMPLER_2D_SHADOW),
     fragment_shader_derivative_hin=
      caml_call2(Int[2],gl2ctx,cst_FRAGMENT_SHADER_DERIVATIVE),
     pixel_pack_buffer=caml_call2(Int[2],gl2ctx,cst_PIXEL_PACK_BUFFER),
     pixel_unpack_buffer=caml_call2(Int[2],gl2ctx,cst_PIXEL_UNPACK_BUFFER),
     pixel_pack_buffer_binding=
      caml_call2(Int[2],gl2ctx,cst_PIXEL_PACK_BUFFER_BINDING),
     pixel_unpack_buffer_binding=
      caml_call2(Int[2],gl2ctx,cst_PIXEL_UNPACK_BUFFER_BINDIN),
     float_mat2x3=caml_call2(Int[2],gl2ctx,cst_FLOAT_MAT2x3),
     float_mat2x4=caml_call2(Int[2],gl2ctx,cst_FLOAT_MAT2x4),
     float_mat3x2=caml_call2(Int[2],gl2ctx,cst_FLOAT_MAT3x2),
     float_mat3x4=caml_call2(Int[2],gl2ctx,cst_FLOAT_MAT3x4),
     float_mat4x2=caml_call2(Int[2],gl2ctx,cst_FLOAT_MAT4x2),
     float_mat4x3=caml_call2(Int[2],gl2ctx,cst_FLOAT_MAT4x3),
     srgb=caml_call2(Int[2],gl2ctx,cst_SRGB),
     srgb8=caml_call2(Int[2],gl2ctx,cst_SRGB8),
     srgb8_alpha8=caml_call2(Int[2],gl2ctx,cst_SRGB8_ALPHA8),
     compare_ref_to_texture=
      caml_call2(Int[2],gl2ctx,cst_COMPARE_REF_TO_TEXTURE),
     rgba32f=caml_call2(Int[2],gl2ctx,cst_RGBA32F),
     rgb32f=caml_call2(Int[2],gl2ctx,cst_RGB32F),
     rgba16f=caml_call2(Int[2],gl2ctx,cst_RGBA16F),
     rgb16f=caml_call2(Int[2],gl2ctx,cst_RGB16F),
     vertex_attrib_array_integer=
      caml_call2(Int[2],gl2ctx,cst_VERTEX_ATTRIB_ARRAY_INTEGE),
     max_array_texture_layers=
      caml_call2(Int[2],gl2ctx,cst_MAX_ARRAY_TEXTURE_LAYERS),
     min_program_texel_offset=
      caml_call2(Int[2],gl2ctx,cst_MIN_PROGRAM_TEXEL_OFFSET),
     max_program_texel_offset=
      caml_call2(Int[2],gl2ctx,cst_MAX_PROGRAM_TEXEL_OFFSET),
     max_varying_components=
      caml_call2(Int[2],gl2ctx,cst_MAX_VARYING_COMPONENTS),
     texture_2d_array=caml_call2(Int[2],gl2ctx,cst_TEXTURE_2D_ARRAY),
     texture_binding_2d_array=
      caml_call2(Int[2],gl2ctx,cst_TEXTURE_BINDING_2D_ARRAY),
     r11f_g11f_b10f=caml_call2(Int[2],gl2ctx,cst_R11F_G11F_B10F),
     unsigned_int_10f_11f_11f_rev=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_10F_11F_11F_R),
     rgb9_e5=caml_call2(Int[2],gl2ctx,cst_RGB9_E5),
     unsigned_int_5_9_9_9_rev=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_5_9_9_9_REV),
     transform_feedback_buffer_mode=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_),
     max_transform_feedback_separat=
      caml_call2(Int[2],gl2ctx,cst_MAX_TRANSFORM_FEEDBACK_SEP),
     transform_feedback_varyings$0=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_VARYING),
     transform_feedback_buffer_star=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_$0),
     transform_feedback_buffer_size=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_$1),
     transform_feedback_primitives_=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_PRIMITI),
     rasterizer_discard=caml_call2(Int[2],gl2ctx,cst_RASTERIZER_DISCARD),
     max_transform_feedback_interle=
      caml_call2(Int[2],gl2ctx,cst_MAX_TRANSFORM_FEEDBACK_INT),
     max_transform_feedback_separat$0=
      caml_call2(Int[2],gl2ctx,cst_MAX_TRANSFORM_FEEDBACK_SEP$0),
     interleaved_attribs=caml_call2(Int[2],gl2ctx,cst_INTERLEAVED_ATTRIBS),
     separate_attribs=caml_call2(Int[2],gl2ctx,cst_SEPARATE_ATTRIBS),
     transform_feedback_buffer=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER),
     transform_feedback_buffer_bind=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_BUFFER_$2),
     rgba32ui=caml_call2(Int[2],gl2ctx,cst_RGBA32UI),
     rgb32ui=caml_call2(Int[2],gl2ctx,cst_RGB32UI),
     rgba16ui=caml_call2(Int[2],gl2ctx,cst_RGBA16UI),
     rgb16ui=caml_call2(Int[2],gl2ctx,cst_RGB16UI),
     rgba8ui=caml_call2(Int[2],gl2ctx,cst_RGBA8UI),
     rgb8ui=caml_call2(Int[2],gl2ctx,cst_RGB8UI),
     rgba32i=caml_call2(Int[2],gl2ctx,cst_RGBA32I),
     rgb32i=caml_call2(Int[2],gl2ctx,cst_RGB32I),
     rgba16i=caml_call2(Int[2],gl2ctx,cst_RGBA16I),
     rgb16i=caml_call2(Int[2],gl2ctx,cst_RGB16I),
     rgba8i=caml_call2(Int[2],gl2ctx,cst_RGBA8I),
     rgb8i=caml_call2(Int[2],gl2ctx,cst_RGB8I),
     red_integer=caml_call2(Int[2],gl2ctx,cst_RED_INTEGER),
     rgb_integer=caml_call2(Int[2],gl2ctx,cst_RGB_INTEGER),
     rgba_integer=caml_call2(Int[2],gl2ctx,cst_RGBA_INTEGER),
     sampler_2d_array=caml_call2(Int[2],gl2ctx,cst_SAMPLER_2D_ARRAY),
     sampler_2d_array_shadow=
      caml_call2(Int[2],gl2ctx,cst_SAMPLER_2D_ARRAY_SHADOW),
     sampler_cube_shadow=caml_call2(Int[2],gl2ctx,cst_SAMPLER_CUBE_SHADOW),
     unsigned_int_vec2=caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_VEC2),
     unsigned_int_vec3=caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_VEC3),
     unsigned_int_vec4=caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_VEC4),
     int_sampler_2d=caml_call2(Int[2],gl2ctx,cst_INT_SAMPLER_2D),
     int_sampler_3d=caml_call2(Int[2],gl2ctx,cst_INT_SAMPLER_3D),
     int_sampler_cube=caml_call2(Int[2],gl2ctx,cst_INT_SAMPLER_CUBE),
     int_sampler_2d_array=caml_call2(Int[2],gl2ctx,cst_INT_SAMPLER_2D_ARRAY),
     unsigned_int_sampler_2d=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_SAMPLER_2D),
     unsigned_int_sampler_3d=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_SAMPLER_3D),
     unsigned_int_sampler_cube=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_SAMPLER_CUBE),
     unsigned_int_sampler_2d_array=
      caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_SAMPLER_2D_AR),
     depth_component32f=caml_call2(Int[2],gl2ctx,cst_DEPTH_COMPONENT32F),
     depth32f_stencil8=caml_call2(Int[2],gl2ctx,cst_DEPTH32F_STENCIL8),
     float_32_unsigned_int_24_8_rev=
      caml_call2(Int[2],gl2ctx,cst_FLOAT_32_UNSIGNED_INT_24_8),
     framebuffer_attachment_color_e=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_COL),
     framebuffer_attachment_compone=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_COM),
     framebuffer_attachment_red_siz=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_RED),
     framebuffer_attachment_green_s=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_GRE),
     framebuffer_attachment_blue_si=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_BLU),
     framebuffer_attachment_alpha_s=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_ALP),
     framebuffer_attachment_depth_s=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_DEP),
     framebuffer_attachment_stencil=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_STE),
     framebuffer_default=caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_DEFAULT),
     unsigned_int_24_8=caml_call2(Int[2],gl2ctx,cst_UNSIGNED_INT_24_8),
     depth24_stencil8=caml_call2(Int[2],gl2ctx,cst_DEPTH24_STENCIL8),
     unsigned_normalized=caml_call2(Int[2],gl2ctx,cst_UNSIGNED_NORMALIZED),
     draw_framebuffer_binding=
      caml_call2(Int[2],gl2ctx,cst_DRAW_FRAMEBUFFER_BINDING),
     read_framebuffer=caml_call2(Int[2],gl2ctx,cst_READ_FRAMEBUFFER),
     draw_framebuffer=caml_call2(Int[2],gl2ctx,cst_DRAW_FRAMEBUFFER),
     read_framebuffer_binding=
      caml_call2(Int[2],gl2ctx,cst_READ_FRAMEBUFFER_BINDING),
     renderbuffer_samples=caml_call2(Int[2],gl2ctx,cst_RENDERBUFFER_SAMPLES),
     framebuffer_attachment_texture$1=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_ATTACHMENT_TEX$1),
     max_color_attachments=caml_call2(Int[2],gl2ctx,cst_MAX_COLOR_ATTACHMENTS),
     color_attachment1=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT1),
     color_attachment2=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT2),
     color_attachment3=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT3),
     color_attachment4=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT4),
     color_attachment5=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT5),
     color_attachment6=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT6),
     color_attachment7=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT7),
     color_attachment8=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT8),
     color_attachment9=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT9),
     color_attachment10=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT10),
     color_attachment11=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT11),
     color_attachment12=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT12),
     color_attachment13=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT13),
     color_attachment14=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT14),
     color_attachment15=caml_call2(Int[2],gl2ctx,cst_COLOR_ATTACHMENT15),
     framebuffer_incomplete_multisa=
      caml_call2(Int[2],gl2ctx,cst_FRAMEBUFFER_INCOMPLETE_MUL),
     max_samples=caml_call2(Int[2],gl2ctx,cst_MAX_SAMPLES),
     half_float=caml_call2(Int[2],gl2ctx,cst_HALF_FLOAT),
     rg=caml_call2(Int[2],gl2ctx,cst_RG),
     rg_integer=caml_call2(Int[2],gl2ctx,cst_RG_INTEGER),
     r8=caml_call2(Int[2],gl2ctx,cst_R8),
     rg8=caml_call2(Int[2],gl2ctx,cst_RG8),
     r16f=caml_call2(Int[2],gl2ctx,cst_R16F),
     r32f=caml_call2(Int[2],gl2ctx,cst_R32F),
     rg16f=caml_call2(Int[2],gl2ctx,cst_RG16F),
     rg32f=caml_call2(Int[2],gl2ctx,cst_RG32F),
     r8i=caml_call2(Int[2],gl2ctx,cst_R8I),
     r8ui=caml_call2(Int[2],gl2ctx,cst_R8UI),
     r16i=caml_call2(Int[2],gl2ctx,cst_R16I),
     r16ui=caml_call2(Int[2],gl2ctx,cst_R16UI),
     r32i=caml_call2(Int[2],gl2ctx,cst_R32I),
     r32ui=caml_call2(Int[2],gl2ctx,cst_R32UI),
     rg8i=caml_call2(Int[2],gl2ctx,cst_RG8I),
     rg8ui=caml_call2(Int[2],gl2ctx,cst_RG8UI),
     rg16i=caml_call2(Int[2],gl2ctx,cst_RG16I),
     rg16ui=caml_call2(Int[2],gl2ctx,cst_RG16UI),
     rg32i=caml_call2(Int[2],gl2ctx,cst_RG32I),
     rg32ui=caml_call2(Int[2],gl2ctx,cst_RG32UI),
     vertex_array_binding=caml_call2(Int[2],gl2ctx,cst_VERTEX_ARRAY_BINDING),
     r8_snorm=caml_call2(Int[2],gl2ctx,cst_R8_SNORM),
     rg8_snorm=caml_call2(Int[2],gl2ctx,cst_RG8_SNORM),
     rgb8_snorm=caml_call2(Int[2],gl2ctx,cst_RGB8_SNORM),
     rgba8_snorm=caml_call2(Int[2],gl2ctx,cst_RGBA8_SNORM),
     signed_normalized=caml_call2(Int[2],gl2ctx,cst_SIGNED_NORMALIZED),
     copy_read_buffer=caml_call2(Int[2],gl2ctx,cst_COPY_READ_BUFFER),
     copy_write_buffer=caml_call2(Int[2],gl2ctx,cst_COPY_WRITE_BUFFER),
     copy_read_buffer_binding=
      caml_call2(Int[2],gl2ctx,cst_COPY_READ_BUFFER_BINDING),
     copy_write_buffer_binding=
      caml_call2(Int[2],gl2ctx,cst_COPY_WRITE_BUFFER_BINDING),
     uniform_buffer=caml_call2(Int[2],gl2ctx,cst_UNIFORM_BUFFER),
     uniform_buffer_binding=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BUFFER_BINDING),
     uniform_buffer_start=caml_call2(Int[2],gl2ctx,cst_UNIFORM_BUFFER_START),
     uniform_buffer_size=caml_call2(Int[2],gl2ctx,cst_UNIFORM_BUFFER_SIZE),
     max_vertex_uniform_blocks=
      caml_call2(Int[2],gl2ctx,cst_MAX_VERTEX_UNIFORM_BLOCKS),
     max_fragment_uniform_blocks=
      caml_call2(Int[2],gl2ctx,cst_MAX_FRAGMENT_UNIFORM_BLOCK),
     max_combined_uniform_blocks=
      caml_call2(Int[2],gl2ctx,cst_MAX_COMBINED_UNIFORM_BLOCK),
     max_uniform_buffer_bindings=
      caml_call2(Int[2],gl2ctx,cst_MAX_UNIFORM_BUFFER_BINDING),
     max_uniform_block_size=
      caml_call2(Int[2],gl2ctx,cst_MAX_UNIFORM_BLOCK_SIZE),
     max_combined_vertex_uniform_co=
      caml_call2(Int[2],gl2ctx,cst_MAX_COMBINED_VERTEX_UNIFOR),
     max_combined_fragment_uniform_=
      caml_call2(Int[2],gl2ctx,cst_MAX_COMBINED_FRAGMENT_UNIF),
     uniform_buffer_offset_alignmen=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BUFFER_OFFSET_ALIG),
     active_uniform_blocks=caml_call2(Int[2],gl2ctx,cst_ACTIVE_UNIFORM_BLOCKS),
     uniform_type=caml_call2(Int[2],gl2ctx,cst_UNIFORM_TYPE),
     uniform_size=caml_call2(Int[2],gl2ctx,cst_UNIFORM_SIZE),
     uniform_block_index=caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_INDEX),
     uniform_offset=caml_call2(Int[2],gl2ctx,cst_UNIFORM_OFFSET),
     uniform_array_stride=caml_call2(Int[2],gl2ctx,cst_UNIFORM_ARRAY_STRIDE),
     uniform_matrix_stride=caml_call2(Int[2],gl2ctx,cst_UNIFORM_MATRIX_STRIDE),
     uniform_is_row_major=caml_call2(Int[2],gl2ctx,cst_UNIFORM_IS_ROW_MAJOR),
     uniform_block_binding$0=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_BINDING),
     uniform_block_data_size=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_DATA_SIZE),
     uniform_block_active_uniforms=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_ACTIVE_UNIFO),
     uniform_block_active_uniform_i=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_ACTIVE_UNIFO$0),
     uniform_block_referenced_by_ve=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_REFERENCED_B),
     uniform_block_referenced_by_fr=
      caml_call2(Int[2],gl2ctx,cst_UNIFORM_BLOCK_REFERENCED_B$0),
     invalid_index=caml_call2(Int[2],gl2ctx,cst_INVALID_INDEX),
     max_vertex_output_components=
      caml_call2(Int[2],gl2ctx,cst_MAX_VERTEX_OUTPUT_COMPONEN),
     max_fragment_input_components=
      caml_call2(Int[2],gl2ctx,cst_MAX_FRAGMENT_INPUT_COMPONE),
     max_server_wait_timeout=
      caml_call2(Int[2],gl2ctx,cst_MAX_SERVER_WAIT_TIMEOUT),
     object_type=caml_call2(Int[2],gl2ctx,cst_OBJECT_TYPE),
     sync_condition=caml_call2(Int[2],gl2ctx,cst_SYNC_CONDITION),
     sync_status=caml_call2(Int[2],gl2ctx,cst_SYNC_STATUS),
     sync_flags=caml_call2(Int[2],gl2ctx,cst_SYNC_FLAGS),
     sync_fence=caml_call2(Int[2],gl2ctx,cst_SYNC_FENCE),
     sync_gpu_commands_complete=
      caml_call2(Int[2],gl2ctx,cst_SYNC_GPU_COMMANDS_COMPLETE),
     unsignaled=caml_call2(Int[2],gl2ctx,cst_UNSIGNALED),
     signaled=caml_call2(Int[2],gl2ctx,cst_SIGNALED),
     already_signaled=caml_call2(Int[2],gl2ctx,cst_ALREADY_SIGNALED),
     timeout_expired=caml_call2(Int[2],gl2ctx,cst_TIMEOUT_EXPIRED),
     condition_satisfied=caml_call2(Int[2],gl2ctx,cst_CONDITION_SATISFIED),
     wait_failed=caml_call2(Int[2],gl2ctx,cst_WAIT_FAILED),
     sync_flush_commands_bit=
      caml_call2(Int[2],gl2ctx,cst_SYNC_FLUSH_COMMANDS_BIT),
     vertex_attrib_array_divisor=
      caml_call2(Int[2],gl2ctx,cst_VERTEX_ATTRIB_ARRAY_DIVISO),
     any_samples_passed=caml_call2(Int[2],gl2ctx,cst_ANY_SAMPLES_PASSED),
     any_samples_passed_conservativ=
      caml_call2(Int[2],gl2ctx,cst_ANY_SAMPLES_PASSED_CONSERV),
     sampler_binding=caml_call2(Int[2],gl2ctx,cst_SAMPLER_BINDING),
     rgb10_a2ui=caml_call2(Int[2],gl2ctx,cst_RGB10_A2UI),
     int_2_10_10_10_rev=caml_call2(Int[2],gl2ctx,cst_INT_2_10_10_10_REV),
     transform_feedback=caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK),
     transform_feedback_paused=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_PAUSED),
     transform_feedback_active=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_ACTIVE),
     transform_feedback_binding=
      caml_call2(Int[2],gl2ctx,cst_TRANSFORM_FEEDBACK_BINDING),
     texture_immutable_format=
      caml_call2(Int[2],gl2ctx,cst_TEXTURE_IMMUTABLE_FORMAT),
     max_element_index=caml_call2(Int[2],gl2ctx,cst_MAX_ELEMENT_INDEX),
     texture_immutable_levels=
      caml_call2(Int[2],gl2ctx,cst_TEXTURE_IMMUTABLE_LEVELS),
     timeout_ignored=caml_call2(Int[2],gl2ctx,cst_TIMEOUT_IGNORED),
     max_client_wait_timeout_webgl=
      caml_call2(Int[2],gl2ctx,cst_MAX_CLIENT_WAIT_TIMEOUT_WE),
     Brr_canvas=
      [0,
       [0,
        is_2d,
        is_identity,
        inverse,
        multiply,
        m11,
        m12,
        m13,
        m14,
        m21,
        m22,
        m23,
        m24,
        m31,
        m32,
        m33,
        m34,
        m41,
        m42,
        m43,
        m44,
        a$1,
        b$1,
        c$0,
        d,
        e,
        f,
        to_float32_array,
        of_float32_array,
        to_float64_array,
        of_float64_array],
       [0,v$14,tr$1,to_json$2,x,y,z,w],
       [0,
        create$13,
        of_el$1,
        to_el$1,
        w$0,
        h,
        set_w,
        set_h,
        set_size_to_layout_size,
        image_encode,
        to_data_url,
        to_blob,
        capture_stream$0],
       [0,
        Fill_rule,
        Image_smoothing_quality,
        Line_cap,
        Line_join,
        Text_align,
        Text_baseline,
        Text_direction,
        Composite_op,
        Repeat,
        [0,
         create$14,
         of_svg,
         of_path,
         add$0,
         close$6,
         move_to,
         line_to,
         qcurve_to,
         ccurve_to,
         arc_to,
         arc,
         rect,
         ellipse],
        image_src_of_el,
        image_src_of_jv,
        attrs_alpha,
        attrs_desynchronized,
        create$15,
        canvas$1,
        attrs,
        save,
        restore,
        image_smoothing_enabled,
        set_image_smoothing_enabled,
        image_smoothing_quality,
        set_image_smoothing_quality,
        global_alpha,
        set_global_alpha,
        global_composite_op,
        set_global_composite_op,
        filter$0,
        set_filter,
        get_transform,
        set_transform,
        reset_transform,
        transform,
        translate,
        rotate,
        scale,
        set_stroke_style,
        set_fill_style,
        color$1,
        gradient_style,
        linear_gradient,
        radial_gradient,
        pattern_style,
        pattern,
        line_width,
        set_line_width,
        line_cap,
        set_line_cap,
        line_join,
        set_line_join,
        miter_limit,
        set_miter_limit,
        line_dash,
        set_line_dash,
        line_dash_offset,
        set_line_dash_offset,
        shadow_blur,
        set_shadow_blur,
        shadow_offset_x,
        set_shadow_offset_x,
        shadow_offset_y,
        set_shadow_offset_y,
        shadow_color,
        set_shadow_color,
        font$0,
        set_font,
        text_align,
        set_text_align,
        text_baseline,
        set_text_baseline,
        text_direction,
        set_text_direction,
        clear_rect,
        fill_rect,
        stroke_rect,
        fill$0,
        stroke,
        clip,
        draw_focus_if_needed,
        scroll_path_into_view,
        is_point_in_fill,
        is_point_in_stroke,
        fill_text,
        stroke_text,
        Text_metrics,
        measure_text,
        draw_image,
        draw_image_in_rect,
        draw_sub_image_in_rect,
        [0,create$16,w$1,h$0,data$5],
        create_image_data,
        get_image_data,
        put_image_data,
        put_sub_image_data],
       [0,
        [0,
         Power_preference,
         v$15,
         alpha,
         depth,
         stencil,
         antialias,
         premultiplied_alpha,
         preserve_drawing_buffer,
         power_preference,
         desynchronized],
        create$17,
        canvas$2,
        drawing_buffer_width,
        drawing_buffer_height,
        attrs$0,
        is_context_lost,
        get_supported_extensions,
        get_extension,
        Active_info,
        Shader_precision_format,
        Tex_image_source,
        active_texture,
        attach_shader,
        begin_query,
        begin_transform_feedback,
        bind_attrib_location,
        bind_buffer,
        bind_buffer_base,
        bind_buffer_range,
        bind_framebuffer,
        bind_renderbuffer,
        bind_sampler,
        bind_texture,
        bind_transform_feedback,
        bind_vertex_array,
        blend_color,
        blend_equation,
        blend_equation_separate,
        blend_func,
        blend_func_separate,
        blit_framebuffer,
        buffer_data,
        buffer_data_size,
        buffer_sub_data,
        check_framebuffer_status,
        clear$3,
        clear_bufferfi,
        clear_bufferfv,
        clear_bufferiv,
        clear_bufferuiv,
        clear_color,
        clear_depth,
        clear_stencil,
        client_wait_sync,
        color_mask,
        compile_shader,
        compressed_tex_image2d,
        compressed_tex_image2d_size,
        compressed_tex_image3d,
        compressed_tex_image3d_size,
        compressed_tex_sub_image2d,
        compressed_tex_sub_image2d_siz,
        compressed_tex_sub_image3d,
        compressed_tex_sub_image3d_siz,
        copy_buffer_sub_data,
        copy_tex_image2d,
        copy_tex_sub_image2d,
        copy_tex_sub_image3d,
        create_buffer,
        create_framebuffer,
        create_program,
        create_query,
        create_renderbuffer,
        create_sampler,
        create_shader,
        create_texture,
        create_transform_feedback,
        create_vertex_array,
        cull_face,
        delete_buffer,
        delete_framebuffer,
        delete_program,
        delete_query,
        delete_renderbuffer,
        delete_sampler,
        delete_shader,
        delete_sync,
        delete_texture,
        delete_transform_feedback,
        delete_vertex_array,
        depth_func,
        depth_mask,
        detach_shader,
        disable,
        disable_vertex_attrib_array,
        draw_arrays,
        draw_arrays_instanced,
        draw_buffers,
        draw_elements,
        draw_elements_instanced,
        draw_range_elements,
        enable,
        enable_vertex_attrib_array,
        end_query,
        end_transform_feedback,
        fence_sync,
        finish,
        flush,
        framebuffer_renderbuffer,
        framebuffer_texture2d,
        framebuffer_texture_layer,
        front_face,
        generate_mipmap,
        get_active_attrib,
        get_active_uniform,
        get_active_uniform_block_name,
        get_active_uniform_block_param,
        get_active_uniforms,
        get_attached_shaders,
        get_attrib_location,
        get_buffer_parameter,
        get_buffer_sub_data,
        get_error,
        get_frag_data_location,
        get_framebuffer_attachment_par,
        get_indexed_parameter,
        get_internalformat_parameter,
        get_parameter,
        get_program_info_log,
        get_program_parameter,
        get_query,
        get_query_parameter,
        get_renderbuffer_parameter,
        get_sampler_parameter,
        get_shader_info_log,
        get_shader_parameter,
        get_shader_precision_format,
        get_shader_source,
        get_sync_parameter,
        get_tex_parameter,
        get_transform_feedback_varying,
        get_uniform,
        get_uniform_block_index,
        get_uniform_indices,
        get_uniform_location,
        get_vertex_attrib,
        get_vertex_attrib_offset,
        hint,
        invalidate_framebuffer,
        invalidate_sub_framebuffer,
        is_buffer,
        is_enabled,
        is_framebuffer,
        is_program,
        is_query,
        is_renderbuffer,
        is_sampler,
        is_shader,
        is_texture,
        is_transform_feedback,
        is_vertex_array,
        line_width$0,
        link_program,
        pause_transform_feedback,
        pixel_storei,
        polygon_offset,
        read_buffer,
        read_pixels_to_pixel_pack,
        read_pixels,
        renderbuffer_storage,
        renderbuffer_storage_multisamp,
        resume_transform_feedback,
        sample_coverage,
        sampler_parameterf,
        sampler_parameteri,
        scissor,
        shader_source,
        stencil_func,
        stencil_func_separate,
        stencil_mask,
        stencil_mask_separate,
        stencil_op,
        stencil_op_separate,
        tex_image2d,
        tex_image2d_of_source,
        tex_image2d_of_pixel_unpack,
        tex_image3d,
        tex_image3d_of_source,
        tex_image3d_of_pixel_unpack,
        tex_parameterf,
        tex_parameteri,
        tex_storage2d,
        tex_storage3d,
        tex_sub_image2d,
        tex_sub_image2d_of_source,
        tex_sub_image2d_of_pixel_unpac,
        tex_sub_image3d,
        tex_sub_image3d_of_source,
        tex_sub_image3d_of_pixel_unpac,
        transform_feedback_varyings,
        uniform1f,
        uniform1fv,
        uniform1i,
        uniform1iv,
        uniform1ui,
        uniform1uiv,
        uniform2f,
        uniform2fv,
        uniform2i,
        uniform2iv,
        uniform2ui,
        uniform2uiv,
        uniform3f,
        uniform3fv,
        uniform3i,
        uniform3iv,
        uniform3ui,
        uniform3uiv,
        uniform4f,
        uniform4fv,
        uniform4i,
        uniform4iv,
        uniform4ui,
        uniform4uiv,
        uniform_block_binding,
        uniform_matrix2fv,
        uniform_matrix2x3fv,
        uniform_matrix2x4fv,
        uniform_matrix3fv,
        uniform_matrix3x2fv,
        uniform_matrix3x4fv,
        uniform_matrix4fv,
        uniform_matrix4x2fv,
        uniform_matrix4x3fv,
        use_program,
        validate_program,
        vertex_attrib1f,
        vertex_attrib1fv,
        vertex_attrib2f,
        vertex_attrib2fv,
        vertex_attrib3f,
        vertex_attrib3fv,
        vertex_attrib4f,
        vertex_attrib4fv,
        vertex_attrib_divisor,
        vertex_attrib_i4i,
        vertex_attrib_i4iv,
        vertex_attrib_i4ui,
        vertex_attrib_i4uiv,
        vertex_attrib_ipointer,
        vertex_attrib_pointer,
        viewport,
        wait_sync,
        active_attributes,
        active_texture$0,
        active_uniform_blocks,
        active_uniforms,
        aliased_line_width_range,
        aliased_point_size_range,
        alpha$0,
        alpha_bits,
        already_signaled,
        always,
        any_samples_passed,
        any_samples_passed_conservativ,
        array_buffer$2,
        array_buffer_binding,
        attached_shaders,
        back$0,
        blend,
        blend_color$0,
        blend_dst_alpha,
        blend_dst_rgb,
        blend_equation$0,
        blend_equation_alpha,
        blend_equation_rgb,
        blend_src_alpha,
        blend_src_rgb,
        blue_bits,
        bool$1,
        bool_vec2,
        bool_vec3,
        bool_vec4,
        browser_default_webgl,
        buffer_size,
        buffer_usage,
        byte$0,
        ccw,
        clamp_to_edge,
        color$2,
        color_attachment0,
        color_attachment1,
        color_attachment10,
        color_attachment11,
        color_attachment12,
        color_attachment13,
        color_attachment14,
        color_attachment15,
        color_attachment2,
        color_attachment3,
        color_attachment4,
        color_attachment5,
        color_attachment6,
        color_attachment7,
        color_attachment8,
        color_attachment9,
        color_buffer_bit,
        color_clear_value,
        color_writemask,
        compare_ref_to_texture,
        compile_status,
        compressed_texture_formats,
        condition_satisfied,
        constant_alpha,
        constant_color,
        context_lost_webgl,
        copy_read_buffer,
        copy_read_buffer_binding,
        copy_write_buffer,
        copy_write_buffer_binding,
        cull_face$0,
        cull_face_mode,
        current_program,
        current_query,
        current_vertex_attrib,
        cw,
        decr,
        decr_wrap,
        delete_status,
        depth$0,
        depth24_stencil8,
        depth32f_stencil8,
        depth_attachment,
        depth_bits,
        depth_buffer_bit,
        depth_clear_value,
        depth_component,
        depth_component16,
        depth_component24,
        depth_component32f,
        depth_func$0,
        depth_range,
        depth_stencil,
        depth_stencil_attachment,
        depth_test,
        depth_writemask,
        dither,
        dont_care,
        draw_buffer0,
        draw_buffer1,
        draw_buffer10,
        draw_buffer11,
        draw_buffer12,
        draw_buffer13,
        draw_buffer14,
        draw_buffer15,
        draw_buffer2,
        draw_buffer3,
        draw_buffer4,
        draw_buffer5,
        draw_buffer6,
        draw_buffer7,
        draw_buffer8,
        draw_buffer9,
        draw_framebuffer,
        draw_framebuffer_binding,
        dst_alpha,
        dst_color,
        dynamic_copy,
        dynamic_draw,
        dynamic_read,
        element_array_buffer,
        element_array_buffer_binding,
        equal$0,
        fastest,
        float$2,
        float_32_unsigned_int_24_8_rev,
        float_mat2,
        float_mat2x3,
        float_mat2x4,
        float_mat3,
        float_mat3x2,
        float_mat3x4,
        float_mat4,
        float_mat4x2,
        float_mat4x3,
        float_vec2,
        float_vec3,
        float_vec4,
        fragment_shader,
        fragment_shader_derivative_hin,
        framebuffer,
        framebuffer_attachment_alpha_s,
        framebuffer_attachment_blue_si,
        framebuffer_attachment_color_e,
        framebuffer_attachment_compone,
        framebuffer_attachment_depth_s,
        framebuffer_attachment_green_s,
        framebuffer_attachment_object_$0,
        framebuffer_attachment_object_,
        framebuffer_attachment_red_siz,
        framebuffer_attachment_stencil,
        framebuffer_attachment_texture$0,
        framebuffer_attachment_texture$1,
        framebuffer_attachment_texture,
        framebuffer_binding,
        framebuffer_complete,
        framebuffer_default,
        framebuffer_incomplete_attachm,
        framebuffer_incomplete_dimensi,
        framebuffer_incomplete_missing,
        framebuffer_incomplete_multisa,
        framebuffer_unsupported,
        front,
        front_and_back,
        front_face$0,
        func_add,
        func_reverse_subtract,
        func_subtract,
        generate_mipmap_hint,
        gequal,
        greater,
        green_bits,
        half_float,
        high_float,
        high_int,
        implementation_color_read_form,
        implementation_color_read_type,
        incr,
        incr_wrap,
        int$3,
        int_2_10_10_10_rev,
        int_sampler_2d,
        int_sampler_2d_array,
        int_sampler_3d,
        int_sampler_cube,
        int_vec2,
        int_vec3,
        int_vec4,
        interleaved_attribs,
        invalid_enum,
        invalid_framebuffer_operation,
        invalid_index,
        invalid_operation,
        invalid_value,
        invert,
        keep,
        lequal,
        less,
        line_loop,
        line_strip,
        line_width$1,
        linear,
        linear_mipmap_linear,
        linear_mipmap_nearest,
        lines,
        link_status,
        low_float,
        low_int,
        luminance,
        luminance_alpha,
        max$2,
        max_3d_texture_size,
        max_array_texture_layers,
        max_client_wait_timeout_webgl,
        max_color_attachments,
        max_combined_fragment_uniform_,
        max_combined_texture_image_uni,
        max_combined_uniform_blocks,
        max_combined_vertex_uniform_co,
        max_cube_map_texture_size,
        max_draw_buffers,
        max_element_index,
        max_elements_indices,
        max_elements_vertices,
        max_fragment_input_components,
        max_fragment_uniform_blocks,
        max_fragment_uniform_component,
        max_fragment_uniform_vectors,
        max_program_texel_offset,
        max_renderbuffer_size,
        max_samples,
        max_server_wait_timeout,
        max_texture_image_units,
        max_texture_lod_bias,
        max_texture_size,
        max_transform_feedback_interle,
        max_transform_feedback_separat$0,
        max_transform_feedback_separat,
        max_uniform_block_size,
        max_uniform_buffer_bindings,
        max_varying_components,
        max_varying_vectors,
        max_vertex_attribs,
        max_vertex_output_components,
        max_vertex_texture_image_units,
        max_vertex_uniform_blocks,
        max_vertex_uniform_components,
        max_vertex_uniform_vectors,
        max_viewport_dims,
        medium_float,
        medium_int,
        min$1,
        min_program_texel_offset,
        mirrored_repeat,
        nearest,
        nearest_mipmap_linear,
        nearest_mipmap_nearest,
        never,
        nicest,
        no_error,
        none$0,
        notequal,
        object_type,
        one,
        one_minus_constant_alpha,
        one_minus_constant_color,
        one_minus_dst_alpha,
        one_minus_dst_color,
        one_minus_src_alpha,
        one_minus_src_color,
        out_of_memory,
        pack_alignment,
        pack_row_length,
        pack_skip_pixels,
        pack_skip_rows,
        pixel_pack_buffer,
        pixel_pack_buffer_binding,
        pixel_unpack_buffer,
        pixel_unpack_buffer_binding,
        points,
        polygon_offset_factor,
        polygon_offset_fill,
        polygon_offset_units,
        query_result,
        query_result_available,
        r11f_g11f_b10f,
        r16f,
        r16i,
        r16ui,
        r32f,
        r32i,
        r32ui,
        r8,
        r8_snorm,
        r8i,
        r8ui,
        rasterizer_discard,
        read_buffer$0,
        read_framebuffer,
        read_framebuffer_binding,
        red,
        red_bits,
        red_integer,
        renderbuffer,
        renderbuffer_alpha_size,
        renderbuffer_binding,
        renderbuffer_blue_size,
        renderbuffer_depth_size,
        renderbuffer_green_size,
        renderbuffer_height,
        renderbuffer_internal_format,
        renderbuffer_red_size,
        renderbuffer_samples,
        renderbuffer_stencil_size,
        renderbuffer_width,
        renderer,
        repeat$1,
        replace,
        rg,
        rg16f,
        rg16i,
        rg16ui,
        rg32f,
        rg32i,
        rg32ui,
        rg8,
        rg8_snorm,
        rg8i,
        rg8ui,
        rg_integer,
        rgb,
        rgb10_a2,
        rgb10_a2ui,
        rgb16f,
        rgb16i,
        rgb16ui,
        rgb32f,
        rgb32i,
        rgb32ui,
        rgb565,
        rgb5_a1,
        rgb8,
        rgb8_snorm,
        rgb8i,
        rgb8ui,
        rgb9_e5,
        rgb_integer,
        rgba,
        rgba16f,
        rgba16i,
        rgba16ui,
        rgba32f,
        rgba32i,
        rgba32ui,
        rgba4,
        rgba8,
        rgba8_snorm,
        rgba8i,
        rgba8ui,
        rgba_integer,
        sample_alpha_to_coverage,
        sample_buffers,
        sample_coverage$0,
        sample_coverage_invert,
        sample_coverage_value,
        sampler_2d,
        sampler_2d_array,
        sampler_2d_array_shadow,
        sampler_2d_shadow,
        sampler_3d,
        sampler_binding,
        sampler_cube,
        sampler_cube_shadow,
        samples,
        scissor_box,
        scissor_test,
        separate_attribs,
        shader_type,
        shading_language_version,
        short$0,
        signaled,
        signed_normalized,
        src_alpha,
        src_alpha_saturate,
        src_color,
        srgb,
        srgb8,
        srgb8_alpha8,
        static_copy,
        static_draw,
        static_read,
        stencil$0,
        stencil_attachment,
        stencil_back_fail,
        stencil_back_func,
        stencil_back_pass_depth_fail,
        stencil_back_pass_depth_pass,
        stencil_back_ref,
        stencil_back_value_mask,
        stencil_back_writemask,
        stencil_bits,
        stencil_buffer_bit,
        stencil_clear_value,
        stencil_fail,
        stencil_func$0,
        stencil_index8,
        stencil_pass_depth_fail,
        stencil_pass_depth_pass,
        stencil_ref,
        stencil_test,
        stencil_value_mask,
        stencil_writemask,
        stream_copy,
        stream_draw,
        stream_read,
        subpixel_bits,
        sync_condition,
        sync_fence,
        sync_flags,
        sync_flush_commands_bit,
        sync_gpu_commands_complete,
        sync_status,
        texture,
        texture0,
        texture1,
        texture10,
        texture11,
        texture12,
        texture13,
        texture14,
        texture15,
        texture16,
        texture17,
        texture18,
        texture19,
        texture2,
        texture20,
        texture21,
        texture22,
        texture23,
        texture24,
        texture25,
        texture26,
        texture27,
        texture28,
        texture29,
        texture3,
        texture30,
        texture31,
        texture4,
        texture5,
        texture6,
        texture7,
        texture8,
        texture9,
        texture_2d,
        texture_2d_array,
        texture_3d,
        texture_base_level,
        texture_binding_2d,
        texture_binding_2d_array,
        texture_binding_3d,
        texture_binding_cube_map,
        texture_compare_func,
        texture_compare_mode,
        texture_cube_map,
        texture_cube_map_negative_x,
        texture_cube_map_negative_y,
        texture_cube_map_negative_z,
        texture_cube_map_positive_x,
        texture_cube_map_positive_y,
        texture_cube_map_positive_z,
        texture_immutable_format,
        texture_immutable_levels,
        texture_mag_filter,
        texture_max_level,
        texture_max_lod,
        texture_min_filter,
        texture_min_lod,
        texture_wrap_r,
        texture_wrap_s,
        texture_wrap_t,
        timeout_expired,
        timeout_ignored,
        transform_feedback,
        transform_feedback_active,
        transform_feedback_binding,
        transform_feedback_buffer,
        transform_feedback_buffer_bind,
        transform_feedback_buffer_mode,
        transform_feedback_buffer_size,
        transform_feedback_buffer_star,
        transform_feedback_paused,
        transform_feedback_primitives_,
        transform_feedback_varyings$0,
        triangle_fan,
        triangle_strip,
        triangles,
        uniform_array_stride,
        uniform_block_active_uniform_i,
        uniform_block_active_uniforms,
        uniform_block_binding$0,
        uniform_block_data_size,
        uniform_block_index,
        uniform_block_referenced_by_fr,
        uniform_block_referenced_by_ve,
        uniform_buffer,
        uniform_buffer_binding,
        uniform_buffer_offset_alignmen,
        uniform_buffer_size,
        uniform_buffer_start,
        uniform_is_row_major,
        uniform_matrix_stride,
        uniform_offset,
        uniform_size,
        uniform_type,
        unpack_alignment,
        unpack_colorspace_conversion_w,
        unpack_flip_y_webgl,
        unpack_image_height,
        unpack_premultiply_alpha_webgl,
        unpack_row_length,
        unpack_skip_images,
        unpack_skip_pixels,
        unpack_skip_rows,
        unsignaled,
        unsigned_byte,
        unsigned_int,
        unsigned_int_10f_11f_11f_rev,
        unsigned_int_24_8,
        unsigned_int_2_10_10_10_rev,
        unsigned_int_5_9_9_9_rev,
        unsigned_int_sampler_2d,
        unsigned_int_sampler_2d_array,
        unsigned_int_sampler_3d,
        unsigned_int_sampler_cube,
        unsigned_int_vec2,
        unsigned_int_vec3,
        unsigned_int_vec4,
        unsigned_normalized,
        unsigned_short,
        unsigned_short_4_4_4_4,
        unsigned_short_5_5_5_1,
        unsigned_short_5_6_5,
        validate_status,
        vendor,
        version,
        vertex_array_binding,
        vertex_attrib_array_buffer_bin,
        vertex_attrib_array_divisor,
        vertex_attrib_array_enabled,
        vertex_attrib_array_integer,
        vertex_attrib_array_normalized,
        vertex_attrib_array_pointer,
        vertex_attrib_array_size,
        vertex_attrib_array_stride,
        vertex_attrib_array_type,
        vertex_shader,
        viewport$0,
        wait_failed,
        zero]];
    caml_register_global(2921,Brr_canvas,"Brr_canvas");
    var a_rate="a-rate",k_rate="k-rate",Automation_rate=[0,a_rate,k_rate];
    function descriptor(automation_rate,min_value,max_value,default_value,n)
     {var o={};
      o.name = n;
      caml_call3(_d_[4],o,cst_automationRate,automation_rate);
      caml_call3(Float[4],o,cst_minValue,min_value);
      caml_call3(Float[4],o,cst_maxValue,max_value);
      caml_call3(Float[4],o,cst_defaultValue,max_value);
      return o}
    function value$3(p){return caml_call2(Float[2],p,cst_value)}
    function set_value(p,v){return caml_call3(Float[3],p,cst_value$0,v)}
    function automation_rate(p)
     {return caml_call2(_d_[2],p,cst_automationRate$0)}
    function set_automation_rate(p,v)
     {return caml_call3(_d_[3],p,cst_automationRate$1,v)}
    function default_value(p)
     {return caml_call2(Float[2],p,cst_defaultValue$0)}
    function min_value(p){return caml_call2(Float[2],p,cst_minValue$0)}
    function max_value(p){return caml_call2(Float[2],p,cst_maxValue$0)}
    function set_value_at_time(p,v,t){p.setValueAtTime(v,t);return 0}
    function linear_ramp_to_value_at_time(p,v,t)
     {p.linearRampToValueAtTime(v,t);return 0}
    function exponential_ramp_to_value_at_t(p,v,t)
     {p.exponentialRampToValueAtTime(v,t);return 0}
    function set_target_at_time(p,v,t,r){p.setTargetAtTime(v,t,r);return 0}
    function set_value_curve_at_time(p,vs,t,d)
     {p.setValueCurveAtTime(vs,t,d);return 0}
    function cancel_scheduled_values(p,t){p.cancelScheduledValues(t);return 0}
    function cancel_and_hold_at_time(p,t){p.cancelAndHoldAtTime(t);return 0}
    var
     Param=
      [0,
       Automation_rate,
       descriptor,
       value$3,
       set_value,
       automation_rate,
       set_automation_rate,
       default_value,
       min_value,
       max_value,
       set_value_at_time,
       linear_ramp_to_value_at_time,
       exponential_ramp_to_value_at_t,
       set_target_at_time,
       set_value_curve_at_time,
       cancel_scheduled_values,
       cancel_and_hold_at_time];
    function position_x(l){return l.positionX()}
    function position_y(l){return l.positionY()}
    function position_z(l){return l.positionZ()}
    function forward_x(l){return l.forwardX()}
    function forward_y(l){return l.forwardY()}
    function forward_z(l){return l.forwardZ()}
    function up_x(l){return l.upX()}
    function up_y(l){return l.upY()}
    function up_z(l){return l.upZ()}
    var
     Listener=
      [0,
       position_x,
       position_y,
       position_z,
       forward_x,
       forward_y,
       forward_z,
       up_x,
       up_y,
       up_z];
    function add_module(w,url)
     {var _dI_=w.addModule(url);
      return of_promise$0(function(_dJ_){return 0},_dI_)}
    function register_processor(n,c){target.registerProcessor(n,c);return 0}
    function current_frame(param)
     {return caml_call2(Int[2],target,cst_currentFrame)}
    function current_time(param)
     {return caml_call2(Float[2],target,cst_currentTime$1)}
    function sample_rate$0(param)
     {return caml_call2(Float[2],target,cst_sampleRate)}
    var G=[0,register_processor,current_frame,current_time,sample_rate$0];
    function port$0(p){return p.port}
    var Processor=[0,port$0],Worklet=[0,add_module,G,Processor];
    function opts$3(cc,l,r,param)
     {return {"numberOfChannels":cc,"length":l,"sampleRate":r}}
    function create$18(opts){return new (target.AudioBuffer)(opts)}
    function sample_rate$1(b){return caml_call2(Float[2],b,cst_sampleRate$0)}
    function length$6(b){return caml_call2(Int[2],b,cst_length$5)}
    function duration_s$0(b){return caml_call2(Float[2],b,cst_length$6)}
    function channel_count$0(b)
     {return caml_call2(Int[2],b,cst_numberOfChannels)}
    function get_channel_data(b,channel){return b.getChannelData(channel)}
    function copy_from_channel(opt,b,c,dst)
     {if(opt)var sth=opt[1],dst_start=sth;else var dst_start=0;
      b.copyFromChannel(dst,c,dst_start);
      return 0}
    function copy_to_channel(opt,b,src,c)
     {if(opt)var sth=opt[1],dst_start=sth;else var dst_start=0;
      b.copyToChannel(src,c,dst_start);
      return 0}
    var
     Buffer=
      [0,
       opts$3,
       create$18,
       sample_rate$1,
       length$6,
       duration_s$0,
       channel_count$0,
       get_channel_data,
       copy_from_channel,
       copy_to_channel],
     max$3="max",
     clamped_max="clamped-max",
     explicit="explicit",
     Channel_count_mode=[0,max$3,clamped_max,explicit],
     speakers="speakers",
     discrete="discrete",
     Channel_interpretation=[0,speakers,discrete];
    function context(n){return n.context}
    function input_count(n){return caml_call2(Int[2],n,cst_numberOfInputs)}
    function output_count(n){return caml_call2(Int[2],n,cst_numberOfOutputs)}
    function channel_count$1(n){return caml_call2(Int[2],n,cst_channelCount)}
    function set_channel_count(n,c)
     {return caml_call3(Int[3],n,cst_channelCount$0,c)}
    function channel_count_mode(n)
     {return caml_call2(_d_[2],n,cst_channelCountMode)}
    function set_channel_count_mode(n,m)
     {return caml_call3(_d_[3],n,cst_channelCountMode$0,m)}
    function channel_interpretation(n)
     {return caml_call2(_d_[2],n,cst_channelInterpretation)}
    function set_channel_interpretation(n,i)
     {return caml_call3(_d_[3],n,cst_channelInterpretation$0,i)}
    function connect_node(n,opt,_dH_,dst)
     {if(opt)var sth=opt[1],output=sth;else var output=0;
      if(_dH_)var sth$0=_dH_[1],input=sth$0;else var input=0;
      n.connect(dst,output,input);
      return 0}
    function connect_param(n,opt,dst)
     {if(opt)var sth=opt[1],output=sth;else var output=0;
      n.connect(dst,output);
      return 0}
    function disconnect(n){n.disconnect();return 0}
    function disconnect_node(output,input,n,dst)
     {var
       output$0=of_option(fn,function(_dG_){return _dG_},output),
       input$0=of_option(fn,function(_dF_){return _dF_},input);
      n.disconnect(dst,output$0,input$0);
      return 0}
    function disconnect_param(output,n,dst)
     {var output$0=of_option(fn,function(_dE_){return _dE_},output);
      n.disconnect(dst,output$0);
      return 0}
    function opts$4
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      fft_size,
      max_decibels,
      min_decibels,
      smoothing_time_constant,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$1,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$1,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$1,channel_interpretation);
      caml_call3(Int[4],o,cst_fftSize,fft_size);
      caml_call3(Float[4],o,cst_minDecibels,min_decibels);
      caml_call3(Float[4],o,cst_maxDecibels,max_decibels);
      caml_call3(Float[4],o,cst_smoothingTimeConstant,smoothing_time_constant);
      return o}
    function create$19(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AnalyserNode)(c,opts)}
    function get_float_frequency_data(n,a)
     {n.getFloatFrequencyData(a);return 0}
    function get_byte_frequency_data(n,a){n.getByteFrequencyData(a);return 0}
    function get_float_time_domain_data(n,a)
     {n.getFloatTimeDomainData(a);return 0}
    function get_byte_time_domain_data(n,a)
     {n.getByteTimeDomainData(a);return 0}
    function fft_size(n){return caml_call2(Int[2],n,cst_fftSize$0)}
    function set_fft_size(n,v){return caml_call3(Int[3],n,cst_fftSize$1,v)}
    function frequency_bin_count(n)
     {return caml_call2(Int[2],n,cst_frequencyBinCount)}
    function min_decibels(n){return caml_call2(Float[2],n,cst_minDecibels$0)}
    function set_min_decibels(n,v)
     {return caml_call3(Float[3],n,cst_minDecibels$1,v)}
    function max_decibels(n){return caml_call2(Float[2],n,cst_maxDecibels$0)}
    function set_max_decibels(n,v)
     {return caml_call3(Float[3],n,cst_maxDecibels$1,v)}
    function smoothing_time_constant(n)
     {return caml_call2(Float[2],n,cst_smoothingTimeConstant$0)}
    function set_smoothing_time_constant(n,v)
     {return caml_call3(Float[3],n,cst_smoothingTimeConstant$1,v)}
    var
     Analyser=
      [0,
       opts$4,
       create$19,
       get_float_frequency_data,
       get_byte_frequency_data,
       get_float_time_domain_data,
       get_byte_time_domain_data,
       fft_size,
       set_fft_size,
       frequency_bin_count,
       min_decibels,
       set_min_decibels,
       max_decibels,
       set_max_decibels,
       smoothing_time_constant,
       set_smoothing_time_constant],
     lowpass="lowpass",
     highpass="highpass",
     bandpass="bandpass",
     lowshelf="lowshelf",
     highshelf="highshelf",
     peaking="peaking",
     notch="notch",
     allpass="allpass",
     Type$3=
      [0,lowpass,highpass,bandpass,lowshelf,highshelf,peaking,notch,allpass];
    function opts$5
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      type,
      q,
      detune,
      frequency,
      gain,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$2,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$2,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$2,channel_interpretation);
      caml_call3(_d_[4],o,cst_type$6,type);
      caml_call3(Float[4],o,cst_Q,q);
      caml_call3(Float[4],o,cst_detune,detune);
      caml_call3(Float[4],o,cst_frequency,frequency);
      caml_call3(Float[4],o,cst_gain,gain);
      return o}
    function create$20(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.BiquadFilterNode)(c,opts)}
    function type$10(n){return caml_call2(_d_[2],n,cst_type$7)}
    function set_type(n,v){return caml_call3(_d_[3],n,cst_type$8,v)}
    function detune(n){return n.detune()}
    function frequency(n){return n.frequency()}
    function q$1(n){return n.Q()}
    function gain(n){return n.gain()}
    function get_frequency_response(n,f,m,p)
     {n.getFrequencyResponse(f,m,p);return 0}
    var
     Biquad_filter=
      [0,
       Type$3,
       opts$5,
       create$20,
       type$10,
       set_type,
       detune,
       frequency,
       q$1,
       gain,
       get_frequency_response];
    function opts$6
     (buffer,detune,loop,loop_start,loop_end,playback_rate,param)
     {var o={};
      set_if_some(o,cst_buffer,buffer);
      caml_call3(Float[4],o,cst_detune$0,detune);
      caml_call3(Bool[4],o,cst_loop$1,loop);
      caml_call3(Float[4],o,cst_loop_start,loop_start);
      caml_call3(Float[4],o,cst_loop_end,loop_end);
      caml_call3(Float[4],o,cst_playbackRate$1,playback_rate);
      return o}
    function create$21(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AudioBufferSourceNode)(c,opts)}
    function buffer$0(n)
     {return find_map(function(_dD_){return _dD_},n,cst_buffer$0)}
    function set_buffer(n,v)
     {return n.buffer = of_option(null$0,function(_dC_){return _dC_},v)}
    function playback_rate$0(n){return n.playbackRate}
    function detune$0(n){return n.detune}
    function loop$0(n){return caml_call2(Bool[2],n,cst_loop$2)}
    function set_loop$0(n,b){return caml_call3(Bool[3],n,cst_loop$3,b)}
    function loop_start(n){return caml_call2(Float[2],n,cst_loopStart)}
    function set_loop_start(n,v)
     {return caml_call3(Float[3],n,cst_loopStart$0,v)}
    function loop_end(n){return caml_call2(Float[2],n,cst_loopEnd)}
    function set_loop_end(n,v){return caml_call3(Float[3],n,cst_loopEnd$0,v)}
    function start$4(t,o,d,n)
     {var
       t$0=of_option(fn,function(_dB_){return _dB_},t),
       o$0=of_option(fn,function(_dA_){return _dA_},o),
       d$0=of_option(fn,function(_dz_){return _dz_},d);
      n.start(t$0,o$0,d$0);
      return 0}
    function stop$2(t,n)
     {var t$0=of_option(fn,function(_dy_){return _dy_},t);
      n.stop(t$0);
      return 0}
    var
     Buffer_source=
      [0,
       opts$6,
       create$21,
       buffer$0,
       set_buffer,
       playback_rate$0,
       detune$0,
       loop$0,
       set_loop$0,
       loop_start,
       set_loop_start,
       loop_end,
       set_loop_end,
       start$4,
       stop$2];
    function opts$7
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      input_count,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$3,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$3,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$3,channel_interpretation);
      caml_call3(Int[4],o,cst_numberOfInputs$0,input_count);
      return o}
    function create$22(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ChannelMergerNode)(c,opts)}
    var Channel_merger=[0,opts$7,create$22];
    function opts$8
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      output_count,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$4,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$4,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$4,channel_interpretation);
      caml_call3(Int[4],o,cst_numberOfOutput,output_count);
      return o}
    function create$23(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ChannelSplitterNode)(c,opts)}
    var Channel_splitter=[0,opts$8,create$23];
    function opts$9(offset,param)
     {var o={};caml_call3(Float[4],o,cst_offset,offset);return o}
    function create$24(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ConstantSourceNode)(c,opts)}
    function offset(n){return n.offset}
    function start$5(t,n)
     {var t$0=of_option(fn,function(_dx_){return _dx_},t);
      n.start(t$0);
      return 0}
    function stop$3(t,n)
     {var t$0=of_option(fn,function(_dw_){return _dw_},t);
      n.stop(t$0);
      return 0}
    var Constant_source=[0,opts$9,create$24,offset,start$5,stop$3];
    function opts$10
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      buffer,
      disable_normalization,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$5,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$5,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$5,channel_interpretation);
      set_if_some(o,cst_buffer$1,buffer);
      caml_call3(Bool[4],o,cst_disableNormalization,disable_normalization);
      return o}
    function create$25(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.ConvolverNode)(c,opts)}
    function buffer$1(n)
     {return find_map(function(_dv_){return _dv_},n,cst_buffer$2)}
    function set_buffer$0(n,v)
     {return n.buffer = of_option(null$0,function(_du_){return _du_},v)}
    function normalize(n){return caml_call2(Bool[2],n,cst_normalize)}
    function set_normalize(n,b)
     {return caml_call3(Bool[3],n,cst_normalize$0,b)}
    var
     Convolver=
      [0,opts$10,create$25,buffer$1,set_buffer$0,normalize,set_normalize];
    function opts$11
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      delay_time,
      max_delay_time,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$6,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$6,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$6,channel_interpretation);
      caml_call3(Float[4],o,cst_delayTime,delay_time);
      caml_call3(Float[4],o,cst_maxDelayTime,max_delay_time);
      return o}
    function create$26(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.DelayNode)(c,opts)}
    function delay_time(n){return n.delayTime}
    var Delay=[0,opts$11,create$26,delay_time];
    function max_channel_count(n)
     {return caml_call2(Int[2],n,cst_maxChannelCount)}
    var Destination$0=[0,max_channel_count];
    function opts$12
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      attack,
      knee,
      ratio,
      release,
      threshold,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$7,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$7,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$7,channel_interpretation);
      caml_call3(Float[4],o,cst_attack,attack);
      caml_call3(Float[4],o,cst_knee,knee);
      caml_call3(Float[4],o,cst_ratio,ratio);
      caml_call3(Float[4],o,cst_release,release);
      caml_call3(Float[4],o,cst_threshold,threshold);
      return o}
    function create$27(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.DynamicsCompressorNode)(c,opts)}
    function attack(n){return n.attack}
    function knee(n){return n.knee}
    function ratio(n){return n.ratio}
    function reduction(n){return caml_call2(Float[2],n,cst_reduction)}
    function release(n){return n.release}
    function threshold(n){return n.threshold}
    var
     Dynamics_compressor=
      [0,opts$12,create$27,attack,knee,ratio,reduction,release,threshold];
    function opts$13
     (channel_count,channel_count_mode,channel_interpretation,gain,param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$8,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$8,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$8,channel_interpretation);
      caml_call3(Float[4],o,cst_gain$0,gain);
      return o}
    function create$28(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.GainNode)(c,opts)}
    function gain$0(n){return n.gain}
    var Gain=[0,opts$13,create$28,gain$0];
    function opts$14
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      feedforward,
      feedback,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$9,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$9,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$9,channel_interpretation);
      o.feedforward = feedforward;
      o.feedback = feedback;
      return o}
    function create$29(c,opts){return new (target.IIRFilterNode)(c,opts)}
    function get_frequency_response$0(n,f,m,p)
     {n.getFrequencyResponse(f,m,p);return 0}
    var Iir_filter=[0,opts$14,create$29,get_frequency_response$0];
    function opts$15(el,param){var o={};o.mediaElement = el;return o}
    function create$30(c,opts)
     {return new
              (target[caml_string_of_jsbytes("MediaElementAudioSourceNode ")])
              (c,opts)}
    function media_element(n){return n.mediaElement}
    var Media_element_source=[0,opts$15,create$30,media_element];
    function opts$16
     (channel_count,channel_count_mode,channel_interpretation,param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$10,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$10,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$10,channel_interpretation);
      return o}
    function create$31(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.MediaStreamAudioDestinationNode)(c,opts)}
    function stream$2(n){return n.stream}
    var Media_stream_destination=[0,opts$16,create$31,stream$2];
    function opts$17(stream,param){var o={};o.mediaStream = stream;return o}
    function create$32(c,opts)
     {return new (target.MediaStreamAudioSourceNode)(c,opts)}
    function media_stream(n){return n.mediaStream}
    var Media_stream_source=[0,opts$17,create$32,media_stream];
    function opts$18(stream,param)
     {var o={};o.mediaStreamTrack = stream;return o}
    function create$33(c,opts)
     {return new
              (target
                [caml_string_of_jsbytes("MediaStreamTrackAudioSourceNode ")])
              (c,opts)}
    var Media_stream_track_source=[0,opts$18,create$33];
    function opts$19(disable_normalization,real,imag,param)
     {var o={};
      caml_call3(Bool[4],o,cst_disableNormalization$0,disable_normalization);
      o.real = of_option(fn,function(_dt_){return _dt_},real);
      o.imag = of_option(fn,function(_ds_){return _ds_},imag);
      return o}
    function create$34(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.PeriodicWave)(c,opts)}
    var
     Periodic_wave=[0,opts$19,create$34],
     sine="sine",
     square$0="square",
     sawtooth="sawtooth",
     triangle="triangle",
     custom="custom",
     Type$4=[0,sine,square$0,sawtooth,triangle,custom];
    function opts$20
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      type,
      frequency,
      detune,
      periodic_wave,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$11,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$11,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$11,channel_interpretation);
      caml_call3(_d_[4],o,cst_type$9,type);
      caml_call3(Float[4],o,cst_frequency$0,frequency);
      caml_call3(Float[4],o,cst_detune$1,detune);
      set_if_some(o,cst_periodicWave,periodic_wave);
      return o}
    function create$35(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.OscillatorNode)(c,opts)}
    function type$11(n){return caml_call2(_d_[2],n,cst_type$10)}
    function set_type$0(n,v){return caml_call3(_d_[3],n,cst_type$11,v)}
    function detune$1(n){return n.detune()}
    function frequency$0(n){return n.frequency()}
    function set_periodic_wave(n,w){n.setPeriodicWave(w);return 0}
    function start$6(t,n)
     {var t$0=of_option(fn,function(_dr_){return _dr_},t);
      n.start(t$0);
      return 0}
    function stop$4(t,n)
     {var t$0=of_option(fn,function(_dq_){return _dq_},t);
      n.stop(t$0);
      return 0}
    var
     Oscillator=
      [0,
       Periodic_wave,
       Type$4,
       opts$20,
       create$35,
       type$11,
       set_type$0,
       detune$1,
       frequency$0,
       set_periodic_wave,
       start$6,
       stop$4],
     equalpower="equalpower",
     hrtf="HRTF",
     Panning_model=[0,equalpower,hrtf],
     linear$0="linear",
     inverse$0="inverse",
     exponential="exponential",
     Distance_model=[0,linear$0,inverse$0,exponential];
    function opts$21
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      panning_model,
      distance_model,
      position_x,
      position_y,
      position_z,
      orientation_x,
      orientation_y,
      orientation_z,
      ref_distance,
      max_distance,
      rolloff_factor,
      cone_inner_angle,
      cone_outer_angle,
      cone_outer_gain,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$12,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$12,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$12,channel_interpretation);
      caml_call3(_d_[4],o,cst_panningModel,panning_model);
      caml_call3(_d_[4],o,cst_distanceModel,distance_model);
      caml_call3(Float[4],o,cst_positionX,position_x);
      caml_call3(Float[4],o,cst_positionY,position_y);
      caml_call3(Float[4],o,cst_positionZ,position_z);
      caml_call3(Float[4],o,cst_orientationX,orientation_x);
      caml_call3(Float[4],o,cst_orientationY,orientation_y);
      caml_call3(Float[4],o,cst_orientationZ,orientation_z);
      caml_call3(Float[4],o,cst_refDistance,ref_distance);
      caml_call3(Float[4],o,cst_maxDistance,max_distance);
      caml_call3(Float[4],o,cst_rolloff_factor,rolloff_factor);
      caml_call3(Float[4],o,cst_cone_inner_angle,cone_inner_angle);
      caml_call3(Float[4],o,cst_cone_outer_angle,cone_outer_angle);
      caml_call3(Float[4],o,cst_cone_outer_gain,cone_outer_gain);
      return o}
    function create$36(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.PannerNode)(c,opts)}
    function panning_model(n){return caml_call2(_d_[2],n,cst_panningModel$0)}
    function set_panning_model(n,v)
     {return caml_call3(_d_[3],n,cst_panningModel$1,v)}
    function distance_model(n)
     {return caml_call2(_d_[2],n,cst_distanceModel$0)}
    function set_distance_model(n,v)
     {return caml_call3(_d_[3],n,cst_distanceModel$1,v)}
    function position_x$0(n){return n.positionX}
    function position_y$0(n){return n.positionY}
    function position_z$0(n){return n.positionZ}
    function orientation_x(n){return n.orientationX}
    function orientation_y(n){return n.orientationY}
    function orientation_z(n){return n.orientationZ}
    function ref_distance(n){return caml_call2(Float[2],n,cst_refDistance$0)}
    function set_ref_distance(n,v)
     {return caml_call3(Float[3],n,cst_refDistance$1,v)}
    function max_distance(n){return caml_call2(Float[2],n,cst_maxDistance$0)}
    function set_max_distance(n,v)
     {return caml_call3(Float[3],n,cst_maxDistance$1,v)}
    function cone_inner_angle(n)
     {return caml_call2(Float[2],n,cst_coneInnerAngle)}
    function set_cone_inner_angle(n,v)
     {return caml_call3(Float[3],n,cst_coneInnerAngle$0,v)}
    function cone_outer_angle(n)
     {return caml_call2(Float[2],n,cst_coneOuterAngle)}
    function set_cone_outer_angle(n,v)
     {return caml_call3(Float[3],n,cst_coneOuterAngle$0,v)}
    function cone_outer_gain(n)
     {return caml_call2(Float[2],n,cst_coneOuterGain)}
    function set_cone_outer_gain(n,v)
     {return caml_call3(Float[3],n,cst_coneOuterGain$0,v)}
    var
     Panner=
      [0,
       Panning_model,
       Distance_model,
       opts$21,
       create$36,
       panning_model,
       set_panning_model,
       distance_model,
       set_distance_model,
       position_x$0,
       position_y$0,
       position_z$0,
       orientation_x,
       orientation_y,
       orientation_z,
       ref_distance,
       set_ref_distance,
       max_distance,
       set_max_distance,
       cone_inner_angle,
       set_cone_inner_angle,
       cone_outer_angle,
       set_cone_outer_angle,
       cone_outer_gain,
       set_cone_outer_gain];
    function opts$22
     (channel_count,channel_count_mode,channel_interpretation,pan,param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$13,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$13,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$13,channel_interpretation);
      caml_call3(Float[4],o,cst_pan,pan);
      return o}
    function create$37(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.StereoPannerNode)(c,opts)}
    function pan(n){return n.pan}
    var
     Stereo_panner=[0,opts$22,create$37,pan],
     none$1="none",
     mul_2x="2x",
     mul_4x="4x",
     Oversample=[0,none$1,mul_2x,mul_4x];
    function opts$23
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      curve,
      oversample,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$14,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$14,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$14,channel_interpretation);
      o.curve = of_option(fn,function(_dp_){return _dp_},curve);
      caml_call3(_d_[4],o,cst_oversample,oversample);
      return o}
    function create$38(opt,c)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.WaveShaperNode)(c,opts)}
    function curve(n)
     {var _dn_=n.curve;return to_option(function(_do_){return _do_},_dn_)}
    function set_curve(n,v)
     {return n.curve = of_option(null$0,function(_dm_){return _dm_},v)}
    function oversample(n){return caml_call2(_d_[2],n,cst_oversample$0)}
    function set_oversample(n,v)
     {return caml_call3(_d_[3],n,cst_oversample$1,v)}
    var
     Wave_shaper=
      [0,
       Oversample,
       opts$23,
       create$38,
       curve,
       set_curve,
       oversample,
       set_oversample];
    function opts$24
     (channel_count,
      channel_count_mode,
      channel_interpretation,
      input_count,
      output_count,
      output_channel_count,
      parameters,
      processor_options,
      param)
     {var o={};
      caml_call3(Int[4],o,cst_channelCount$15,channel_count);
      caml_call3(_d_[4],o,cst_channelCountMode$15,channel_count_mode);
      caml_call3(_d_[4],o,cst_channelInterpretation$15,channel_interpretation);
      caml_call3(Int[4],o,cst_numberOfInputs$1,input_count);
      caml_call3(Int[4],o,cst_numberOfOutputs$0,output_count);
      function _di_(_dl_){return _dl_}
      function _dj_(_dk_){return of_list(_di_,_dk_)}
      set_if_some
       (o,
        cst_outputChannelCount,
        caml_call2(Stdlib_option[7],_dj_,output_channel_count));
      set_if_some(o,cst_parameterData,parameters);
      set_if_some(o,cst_processorOptions,processor_options);
      return o}
    function create$39(opt,c,name)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AudioWorkletNode)(c,name,opts)}
    function parameter(n,k)
     {var p=n.parameters.get(k);
      return is_none(p)?throw$0(0,"no parameter named ".concat(k)):p}
    function port$1(n){return n.port}
    var
     Worklet$0=[0,opts$24,create$39,parameter,port$1],
     Node=
      [0,
       Channel_count_mode,
       Channel_interpretation,
       context,
       input_count,
       output_count,
       channel_count$1,
       set_channel_count,
       channel_count_mode,
       set_channel_count_mode,
       channel_interpretation,
       set_channel_interpretation,
       connect_node,
       connect_param,
       disconnect,
       disconnect_node,
       disconnect_param,
       Analyser,
       Biquad_filter,
       Buffer_source,
       Channel_merger,
       Channel_splitter,
       Constant_source,
       Convolver,
       Delay,
       Destination$0,
       Dynamics_compressor,
       Gain,
       Iir_filter,
       Media_element_source,
       Media_stream_destination,
       Media_stream_source,
       Media_stream_track_source,
       Oscillator,
       Panner,
       Stereo_panner,
       Wave_shaper,
       Worklet$0];
    function context_time(t){return caml_call2(Float[2],t,cst_contextTime)}
    function performance_time(t)
     {return caml_call2(Float[2],t,cst_performanceTime)}
    var
     Timestamp=[0,context_time,performance_time],
     suspended="suspended",
     running="running",
     closed$0="closed",
     State$0=[0,suspended,running,closed$0];
    function decode_audio_data(c,b)
     {var _dg_=c.decodeAudioData(b);
      return of_promise$0(function(_dh_){return _dh_},_dg_)}
    function destination$0(c){return c.destination}
    function sample_rate$2(c){return caml_call2(Float[2],c,cst_sampleRate$1)}
    function current_time$0(c)
     {return caml_call2(Float[2],c,cst_currentTime$2)}
    function listener(c){return c.listener}
    function state$2(c){return caml_call2(_d_[2],c,cst_state$0)}
    function audio_worklet(c){return c.audioWorklet}
    var
     Base=
      [0,
       decode_audio_data,
       destination$0,
       sample_rate$2,
       current_time$0,
       listener,
       state$2,
       audio_worklet],
     balanced="balanced",
     interactive="interactive",
     playback="playback",
     Latency_category=[0,balanced,interactive,playback];
    function opts$25(latency_hint,sample_rate_hz,param)
     {var o={};
      if(latency_hint)
       {var _de_=latency_hint[1];
        if(925478882 <= _de_[1])
         var s=_de_[2],_df_=[0,s];
        else
         var c=_de_[2],_df_=[0,c];
        var latency_hint$0=_df_}
      else
       var latency_hint$0=0;
      set_if_some(o,cst_latencyHint,latency_hint$0);
      caml_call3(Float[4],o,cst_sampleRate$2,sample_rate_hz);
      return o}
    function create$40(opt,param)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new (target.AudioContext)(opts)}
    function base_latency(c){return caml_call2(Float[2],c,cst_baseLatency)}
    function output_latency(c)
     {return caml_call2(Float[2],c,cst_outputLatency)}
    function get_output_timestamp(c){return c.getOutputTimestamp()}
    function resume$1(c)
     {var _dc_=c.resume();return of_promise$0(function(_dd_){return 0},_dc_)}
    function suspend$0(c)
     {var _da_=c.suspend();return of_promise$0(function(_db_){return 0},_da_)}
    function close$7(c)
     {var _c__=c.close();return of_promise$0(function(_c$_){return 0},_c__)}
    function opts$26(cc,l,r,param)
     {return {"numberOfChannels":cc,"length":l,"sampleRate":r}}
    function length$7(c){return caml_call2(Int[2],c,cst_length$7)}
    function create$41(opts){return new (target.OfflineAudioContext)(opts)}
    function start_rendering(c)
     {var _c8_=c.startRenderig();
      return of_promise$0(function(_c9_){return _c9_},_c8_)}
    function suspend$1(c,secs)
     {var _c6_=c.suspend(secs);
      return of_promise$0(function(_c7_){return 0},_c6_)}
    function resume$2(c)
     {var _c4_=c.resume();return of_promise$0(function(_c5_){return 0},_c4_)}
    var
     Brr_webaudio=
      [0,
       [0,
        Param,
        Listener,
        Worklet,
        Buffer,
        Node,
        Timestamp,
        [0,
         State$0,
         Base,
         Latency_category,
         opts$25,
         create$40,
         base_latency,
         output_latency,
         get_output_timestamp,
         resume$1,
         suspend$0,
         close$7,
         [0,opts$26,create$41,length$7,start_rendering,suspend$1,resume$2]]]];
    caml_register_global(2922,Brr_webaudio,"Brr_webaudio");
    var
     public$0="public",
     private$0="private",
     secret="secret",
     Type$5=[0,public$0,private$0,secret],
     encrypt="encrypt",
     decrypt="decrypt",
     sign="sign",
     verify="verify",
     derive_key="deriveKey",
     derive_bits="deriveBits",
     wrap_key="wrapKey",
     unwrap_key="unwrapKey",
     Usage=
      [0,
       encrypt,
       decrypt,
       sign,
       verify,
       derive_key,
       derive_bits,
       wrap_key,
       unwrap_key],
     raw="raw",
     pkcs8="pkcs8",
     spki="spki",
     jwk="jwk",
     Format=[0,raw,pkcs8,spki,jwk];
    function type$12(k){return caml_call2(_d_[2],k,cst_type$12)}
    function extractable(k){return caml_call2(Bool[2],k,cst_extractable)}
    function algorithm(k){return k.algorithm}
    function usages(k){return caml_list_of_js_array(k.usages)}
    function public$1(p){return p.publicKey}
    function private$1(p){return p.privateKey}
    var
     Crypto_key=
      [0,
       Type$5,
       Usage,
       Format,
       type$12,
       extractable,
       algorithm,
       usages,
       public$1,
       private$1];
    function v$16(n){return {"name":n}}
    function name$9(a){return caml_call2(_d_[2],a,cst_name$5)}
    var rsassa_pks1_v1_5="RSASSA-PKCS1-v1_5";
    function v$17(name,modulus_length,public_exponent,hash,param)
     {return {"name":name,
              "modulusLength":modulus_length,
              "publicExponent":public_exponent,
              "hash":hash}}
    function of_algo(_c3_){return _c3_}
    function name$10(a){return caml_call2(_d_[2],a,cst_name$6)}
    function modulus_length(a){return caml_call2(Int[2],a,cst_modulusLength)}
    function public_exponent(a){return a.publicExponent}
    function hash(a){return caml_call2(_d_[2],a,cst_hash$0)}
    var
     Rsa_hashed_key_gen_params=
      [0,v$17,of_algo,name$10,modulus_length,public_exponent,hash];
    function v$18(name,hash,param){return {"name":name,"hash":hash}}
    function of_algo$0(_c2_){return _c2_}
    function name$11(a){return caml_call2(_d_[2],a,cst_name$7)}
    function hash$0(a){return caml_call2(_d_[2],a,cst_hash$1)}
    var
     Rsa_hashed_import_params=[0,v$18,of_algo$0,name$11,hash$0],
     rsa_pss="RSA-PSS";
    function v$19(opt,salt_length,param)
     {if(opt)var sth=opt[1],name=sth;else var name=rsa_pss;
      return {"name":name,"saltLength":salt_length}}
    function of_algo$1(_c1_){return _c1_}
    function name$12(a){return caml_call2(_d_[2],a,cst_name$8)}
    function salt_length(a){return caml_call2(Int[2],a,cst_saltLength)}
    var
     Rsa_pss_params=[0,v$19,of_algo$1,name$12,salt_length],
     rsa_oaep="RSA-OAEP";
    function v$20(opt,label,param)
     {if(opt)var sth=opt[1],name=sth;else var name=rsa_oaep;
      if(label)var l=label[1],label$0=l;else var label$0=fn;
      return {"name":name,"label":label$0}}
    function of_algo$2(_c0_){return _c0_}
    function name$13(a){return caml_call2(_d_[2],a,cst_name$9)}
    function label$3(a)
     {var _cY_=a.label;return to_option(function(_cZ_){return _cZ_},_cY_)}
    var Rsa_oaep_params=[0,v$20,of_algo$2,name$13,label$3],ecdsa="ECDSA";
    function v$21(name,named_curve,param)
     {return {"name":name,"namedCurve":named_curve}}
    function of_algo$3(_cX_){return _cX_}
    function name$14(a){return caml_call2(_d_[2],a,cst_name$10)}
    function named_curve(a){return caml_call2(_d_[2],a,cst_namedCurve)}
    var Ec_key_gen_params=[0,v$21,of_algo$3,name$14,named_curve];
    function v$22(name,named_curve,param)
     {return {"name":name,"namedCurve":named_curve}}
    function of_algo$4(_cW_){return _cW_}
    function name$15(a){return caml_call2(_d_[2],a,cst_name$11)}
    function named_curve$0(a){return caml_call2(_d_[2],a,cst_namedCurve$0)}
    var Ec_key_import_params=[0,v$22,of_algo$4,name$15,named_curve$0];
    function v$23(name,hash,param){return {"name":name,"hash":hash}}
    function of_algo$5(_cV_){return _cV_}
    function name$16(a){return caml_call2(_d_[2],a,cst_name$12)}
    function hash$1(a){return caml_call2(_d_[2],a,cst_hash$2)}
    var Ecdsa_params=[0,v$23,of_algo$5,name$16,hash$1],ecdh="ECDH";
    function v$24(name,public$0,param){return {"name":name,"public":public$0}}
    function of_algo$6(_cU_){return _cU_}
    function name$17(a){return caml_call2(_d_[2],a,cst_name$13)}
    function public$2(a){return a[caml_string_of_jsbytes("public")]}
    var
     Ecdh_key_derive_params=[0,v$24,of_algo$6,name$17,public$2],
     aes_ctr="AES-CTR";
    function v$25(name,length,param){return {"name":name,"length":length}}
    function of_algo$7(_cT_){return _cT_}
    function name$18(a){return caml_call2(_d_[2],a,cst_name$14)}
    function length$8(a){return caml_call2(Int[2],a,cst_length$8)}
    var Aes_key_gen_params=[0,v$25,of_algo$7,name$18,length$8];
    function v$26(opt,counter,length,param)
     {if(opt)var sth=opt[1],name=sth;else var name=aes_ctr;
      return {"name":name,"counter":counter,"length":length}}
    function of_algo$8(_cS_){return _cS_}
    function name$19(a){return caml_call2(_d_[2],a,cst_name$15)}
    function counter(a){return a.counter}
    function length$9(a){return caml_call2(Int[2],a,cst_length$9)}
    var
     Aes_ctr_params=[0,v$26,of_algo$8,name$19,counter,length$9],
     aes_cbc="AES-CBC";
    function v$27(opt,iv,param)
     {if(opt)var sth=opt[1],name=sth;else var name=aes_cbc;
      return {"name":name,"iv":iv}}
    function of_algo$9(_cR_){return _cR_}
    function name$20(a){return caml_call2(_d_[2],a,cst_name$16)}
    function iv(a){return a.iv}
    var Aes_cbc_params=[0,v$27,of_algo$9,name$20,iv],aes_gcm="AES-GCM";
    function v$28(opt,iv,additional_data,tag_length,param)
     {if(opt)var sth=opt[1],name=sth;else var name=aes_cbc;
      if(additional_data)var a=additional_data[1],add=a;else var add=fn;
      if(tag_length)var l=tag_length[1],tlen=l;else var tlen=fn;
      return {"name":name,"iv":iv,"additionalData":add,"tagLength":tlen}}
    function of_algo$10(_cQ_){return _cQ_}
    function name$21(a){return caml_call2(_d_[2],a,cst_name$17)}
    function iv$0(a){return a.iv}
    function additional_data(a)
     {return find_map(function(_cP_){return _cP_},a,cst_additionalData)}
    function tag_length(a)
     {return find_map(function(_cO_){return _cO_},a,cst_tagLength)}
    var
     Aes_gcm_params=
      [0,v$28,of_algo$10,name$21,iv$0,additional_data,tag_length],
     aes_kw="AES-KW",
     hmac="HMAC";
    function v$29(opt,length,hash,param)
     {if(opt)var sth=opt[1],name=sth;else var name=hmac;
      if(length)var l=length[1],l$0=l;else var l$0=fn;
      return {"name":name,"hash":hash,"length":l$0}}
    function of_algo$11(_cN_){return _cN_}
    function name$22(a){return caml_call2(_d_[2],a,cst_name$18)}
    function hash$2(a){return caml_call2(_d_[2],a,cst_hash$3)}
    function length$10(a)
     {return find_map(function(_cM_){return _cM_},a,cst_length$10)}
    var
     Hmac_key_gen_params=[0,v$29,of_algo$11,name$22,hash$2,length$10],
     sha_1="SHA-1",
     sha_256="SHA-256",
     sha_384="SHA-384",
     sha_512="SHA-512",
     hkdf="HKDF";
    function v$30(opt,hash,salt,info,param)
     {if(opt)var sth=opt[1],name=sth;else var name=hkdf;
      return {"name":name,"hash":hash,"salt":salt,"info":info}}
    function of_algo$12(_cL_){return _cL_}
    function name$23(a){return caml_call2(_d_[2],a,cst_name$19)}
    function hash$3(a){return caml_call2(_d_[2],a,cst_hash$4)}
    function salt(a){return a.salt}
    function info$0(a){return a.info}
    var
     Hkdf_params=[0,v$30,of_algo$12,name$23,hash$3,salt,info$0],
     pbkdf2="PBKDF2";
    function v$31(opt,hash,salt,iterations,param)
     {if(opt)var sth=opt[1],name=sth;else var name=pbkdf2;
      return {"name":name,"hash":hash,"salt":salt,"iterations":iterations}}
    function of_algo$13(_cK_){return _cK_}
    function name$24(a){return caml_call2(_d_[2],a,cst_name$20)}
    function hash$4(a){return caml_call2(_d_[2],a,cst_hash$5)}
    function salt$0(a){return a.salt}
    function iterations(a){return caml_call2(Int[2],a,cst_iterations)}
    var Pbkdf2_params=[0,v$31,of_algo$13,name$24,hash$4,salt$0,iterations];
    function encrypt$0(s,a,k,d)
     {var _cI_=s.encrypt(a,k,d);
      return of_promise$0(function(_cJ_){return _cJ_},_cI_)}
    function decrypt$0(s,a,k,d)
     {var _cG_=s.decrypt(a,k,d);
      return of_promise$0(function(_cH_){return _cH_},_cG_)}
    function digest(s,a,d)
     {var _cE_=s.digest(a,d);
      return of_promise$0(function(_cF_){return _cF_},_cE_)}
    function sign$0(s,a,k,d)
     {var _cC_=s.sign(a,k,d);
      return of_promise$0(function(_cD_){return _cD_},_cC_)}
    function verify$0(s,a,k,sig,d)
     {return of_promise$0(caml_js_to_bool,s.verify(a,k,sig,d))}
    function generate_key(s,a,extractable,usages)
     {var _cA_=s.generateKey(a,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cB_){return _cB_},_cA_)}
    function generate_key_pair(s,a,extractable,usages)
     {var _cy_=s.generateKey(a,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cz_){return _cz_},_cy_)}
    function derive_bits$0(s,a,k,l)
     {var _cw_=s.deriveBits(a,k,l);
      return of_promise$0(function(_cx_){return _cx_},_cw_)}
    function derive_key$0(s,a,k,derived,extractable,usages)
     {var
       _cu_=
        s.deriveKey(a,k,derived,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_cv_){return _cv_},_cu_)}
    function import_key(s,f,k,a,extractable,usages)
     {if(98868477 <= k[1])var k$0=k[2],k$1=k$0;else var b=k[2],k$1=b;
      var
       _cs_=
        s.importKey(f,k$1,a,! ! extractable,caml_list_to_js_array(usages));
      return of_promise$0(function(_ct_){return _ct_},_cs_)}
    function export_key(s,f,k)
     {var
       match=caml_equal(Crypto_key[3][4],f),
       ok=
        match
         ?function(v){return [0,98868477,v]}
         :function(v){return [0,86585632,v]};
      return of_promise$0(ok,s.exportKey(f,k))}
    function wrap_key$0(s,f,k,wrap_key,wrapper)
     {var _cq_=s.wrapKey(f,k,wrap_key,wrapper);
      return of_promise$0(function(_cr_){return _cr_},_cq_)}
    function unwrap_key$0(s,f,k,wrap_key,wrapper,unwrapped,extractable,usages)
     {var
       _co_=
        s.unwrapKey
         (f,
          k,
          wrap_key,
          wrapper,
          unwrapped,
          ! ! extractable,
          caml_list_to_js_array(usages));
      return of_promise$0(function(_cp_){return _cp_},_co_)}
    var crypto=target.crypto;
    function subtle(c){return c.subtle}
    function set_random_values(c,a){c.getRandomValues(a);return 0}
    var
     Crypto=[0,crypto,subtle,set_random_values],
     Brr_webcrypto=
      [0,
       Crypto_key,
       [0,
        v$16,
        name$9,
        rsassa_pks1_v1_5,
        Rsa_hashed_key_gen_params,
        Rsa_hashed_import_params,
        rsa_pss,
        Rsa_pss_params,
        rsa_oaep,
        Rsa_oaep_params,
        ecdsa,
        Ec_key_gen_params,
        Ec_key_import_params,
        Ecdsa_params,
        ecdh,
        Ecdh_key_derive_params,
        aes_ctr,
        Aes_key_gen_params,
        Aes_ctr_params,
        aes_cbc,
        Aes_cbc_params,
        aes_gcm,
        Aes_gcm_params,
        aes_kw,
        hmac,
        Hmac_key_gen_params,
        Hmac_key_gen_params,
        sha_1,
        sha_256,
        sha_384,
        sha_512,
        hkdf,
        Hkdf_params,
        pbkdf2,
        Pbkdf2_params],
       [0,
        encrypt$0,
        decrypt$0,
        digest,
        sign$0,
        verify$0,
        generate_key,
        generate_key_pair,
        derive_bits$0,
        derive_key$0,
        export_key,
        import_key,
        wrap_key$0,
        unwrap_key$0],
       Crypto];
    caml_register_global(2923,Brr_webcrypto,"Brr_webcrypto");
    var classic="classic",module="module",Type$6=[0,classic,module];
    function opts$27(type,credentials,name,param)
     {var o=obj([0]);
      caml_call3(_d_[4],o,cst_type$13,type);
      caml_call3(_d_[4],o,cst_credentials$1,credentials);
      caml_call3(_d_[4],o,cst_name$21,name);
      return o}
    var worker$0=target.Worker;
    function create$42(opt,uri)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new worker$0(uri,opts)}
    function terminate(w){w.terminate();return 0}
    function post$1(opts,w,v)
     {if(opts)var o=opts[1],opts$0=o;else var opts$0=fn;
      w.postMessage(v,opts$0);
      return 0}
    var shared=target.SharedWorker;
    function create$43(opt,uri)
     {if(opt)var sth=opt[1],opts=sth;else var opts=fn;
      return new shared(uri,opts)}
    function port$2(w){return w.port}
    function ami(param){return has(cst_WorkerGlobalScope,target)}
    function import_scripts(uris)
     {target.importScripts(caml_list_to_js_array(uris));return 0}
    function post$2(opts,v)
     {if(opts)var o=opts[1],opts$0=o;else var opts$0=fn;
      target.postMessage(v,opts$0);
      return 0}
    function close$8(param){target.close();return 0}
    var
     G$0=[0,import_scripts,post$2,close$8],
     imports="imports",
     all$1="all",
     none$2="none",
     Update_via_cache=[0,imports,all$1,none$2],
     parsed="parsed",
     installing="installing",
     installed="installed",
     activating="activating",
     activated="activated",
     redundant="redundant",
     State$1=[0,parsed,installing,installed,activating,activated,redundant];
    function script_url(w){return w.scriptURL()}
    function state$3(w){return w.state()}
    function enable$0(p)
     {var _cm_=p.enable();return of_promise$0(function(_cn_){return 0},_cm_)}
    function disable$0(p)
     {var _ck_=p.disable();return of_promise$0(function(_cl_){return 0},_ck_)}
    function set_header_value(p,v)
     {var _ci_=p.setHeaderValue(v);
      return of_promise$0(function(_cj_){return 0},_ci_)}
    function get_state(p)
     {function extract(s)
       {var _ch_=caml_call2(_d_[2],s,cst_headerValue);
        return [0,caml_call2(Bool[2],s,cst_enabled$1),_ch_]}
      return of_promise$0(extract,p.getState())}
    var
     Navigation_preload_manager=
      [0,enable$0,disable$0,set_header_value,get_state];
    function installing$0(r)
     {var _cf_=r.installing;
      return to_option(function(_cg_){return _cg_},_cf_)}
    function waiting$0(r)
     {var _cd_=r.waiting;return to_option(function(_ce_){return _ce_},_cd_)}
    function active$0(r)
     {var _cb_=r.active;return to_option(function(_cc_){return _cc_},_cb_)}
    function navigation_preload(r){return r.navigationPreload}
    function scope(r){return caml_call2(_d_[2],r,cst_scope)}
    function update_via_cache(r)
     {return caml_call2(_d_[2],r,cst_updateViaCache)}
    function update(r)
     {var _b$_=r.update();return of_promise$0(function(_ca_){return 0},_b$_)}
    function unregister(r)
     {return of_promise$0(caml_js_to_bool,r.unregister())}
    function show_notification(opts,r,title)
     {var
       opts$0=of_option(fn,function(_b__){return _b__},opts),
       _b8_=r.showNotification(title,opts$0);
      return of_promise$0(function(_b9_){return 0},_b8_)}
    function get_notifications(tag,r)
     {if(tag)var tag$0=tag[1],opts={"tag":tag$0};else var opts=fn;
      var _b4_=r.getNotifications(opts);
      function _b5_(_b7_){return _b7_}
      return of_promise$0(function(_b6_){return to_list(_b5_,_b6_)},_b4_)}
    function of_navigator$2(n){return n.serviceWorker}
    function controller$0(c)
     {var _b2_=c.controller;
      return to_option(function(_b3_){return _b3_},_b2_)}
    function ready(c)
     {var _b0_=c.ready;return of_promise$0(function(_b1_){return _b1_},_b0_)}
    function register_opts(scope,type,update_via_cache,param)
     {var o={};
      caml_call3(_d_[4],o,cst_scope$0,scope);
      caml_call3(_d_[4],o,cst_type$14,type);
      caml_call3(_d_[4],o,cst_updateViaCache$0,update_via_cache);
      return o}
    function register(opt,c,uri)
     {if(opt)var sth=opt[1],register_opts=sth;else var register_opts=fn;
      var _bY_=c.register(uri,register_opts);
      return of_promise$0(function(_bZ_){return _bZ_},_bY_)}
    function get_registration(c,uri)
     {var
       uri$0=of_option(fn,function(_bX_){return _bX_},uri),
       _bT_=c.getRegistration(uri$0);
      function _bU_(_bW_){return _bW_}
      return of_promise$0(function(_bV_){return to_option(_bU_,_bV_)},_bT_)}
    function get_registrations(c)
     {var _bP_=c.getRegistrations();
      function _bQ_(_bS_){return _bS_}
      return of_promise$0(function(_bR_){return to_list(_bQ_,_bR_)},_bP_)}
    function start_messages(c){c.startMessages();return 0}
    var
     Container=
      [0,
       of_navigator$2,
       controller$0,
       ready,
       register_opts,
       register,
       get_registration,
       get_registrations,
       start_messages],
     hidden$2="hidden",
     visible$0="visible",
     Visibility_state$0=[0,hidden$2,visible$0],
     window$0="window",
     worker$1="worker",
     sharedworker$0="sharedworker",
     all$2="all",
     Type$7=[0,window$0,worker$1,sharedworker$0,all$2],
     auxiliary="auxiliary",
     top_level="top-level",
     nested="nested",
     none$3="none",
     Frame_type=[0,auxiliary,top_level,nested,none$3];
    function url$5(c){return caml_call2(_d_[2],c,cst_url$3)}
    function frame_type(c){return caml_call2(_d_[2],c,cst_frameType)}
    function id$5(c){return caml_call2(_d_[2],c,cst_id$1)}
    function type$13(c){return caml_call2(_d_[2],c,cst_type$15)}
    function post$3(opts,c,v)
     {if(opts)var o=opts[1],opts$0=o;else var opts$0=fn;
      c.postMessage(v,opts$0);
      return 0}
    function visibility_state$0(w)
     {return caml_call2(_d_[2],w,cst_visibilityState$0)}
    function focused(w){return caml_call2(Bool[2],w,cst_focused)}
    function ancestor_origins(w)
     {var _bN_=w.ancestorOrigins;
      return to_list(function(_bO_){return _bO_},_bN_)}
    function focus$0(w)
     {var _bL_=w.focus();
      return of_promise$0(function(_bM_){return _bM_},_bL_)}
    function navigate$1(w,url)
     {var _bJ_=w.focus(url);
      return of_promise$0(function(_bK_){return _bK_},_bJ_)}
    var
     Window$0=
      [0,visibility_state$0,focused,ancestor_origins,focus$0,navigate$1],
     Client=
      [0,
       Visibility_state$0,
       Type$7,
       Frame_type,
       url$5,
       frame_type,
       id$5,
       type$13,
       post$3,
       Window$0];
    function query_opts$0(include_uncontrolled,type,param)
     {var o={};
      caml_call3(Bool[4],o,cst_includeUncontrolled,include_uncontrolled);
      caml_call3(_d_[4],o,cst_type$16,type);
      return o}
    function get$7(cs,id)
     {var _bF_=cs.get(id);
      function _bG_(_bI_){return _bI_}
      return of_promise$0(function(_bH_){return to_option(_bG_,_bH_)},_bF_)}
    function match_all$0(opt,cs)
     {if(opt)var sth=opt[1],query_opts=sth;else var query_opts=fn;
      var _bB_=cs.matchAll(query_opts);
      function _bC_(_bE_){return _bE_}
      return of_promise$0(function(_bD_){return to_list(_bC_,_bD_)},_bB_)}
    function open_window(cs,url)
     {var _bx_=cs.openWindow(url);
      function _by_(_bA_){return _bA_}
      return of_promise$0(function(_bz_){return to_option(_by_,_bz_)},_bx_)}
    function claim(cs)
     {var _bv_=cs.claim();return of_promise$0(function(_bw_){return 0},_bv_)}
    var
     Clients=[0,query_opts$0,get$7,match_all$0,open_window,claim],
     clients=target.clients,
     registration=target.registration,
     service_worker=target.serviceWorker;
    function skip_waiting(param)
     {var _bt_=target.skipWaiting();
      return of_promise$0(function(_bu_){return 0},_bt_)}
    var
     G$1=[0,clients,registration,service_worker,skip_waiting],
     Brr_webworkers=
      [0,
       [0,
        Type$6,
        opts$27,
        create$42,
        terminate,
        post$1,
        [0,create$43,port$2],
        ami,
        G$0],
       [0,
        Update_via_cache,
        State$1,
        script_url,
        state$3,
        Navigation_preload_manager,
        [0,
         update,
         unregister,
         show_notification,
         get_notifications,
         installing$0,
         waiting$0,
         active$0,
         navigation_preload,
         scope,
         update_via_cache],
        Container,
        Client,
        Clients,
        G$1]];
    caml_register_global(2924,Brr_webworkers,"Brr_webworkers");
    return}
  (function(){return this}()));


//# 1 "../.js/uutf/uutf.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_blit_bytes=runtime.caml_blit_bytes,
     caml_bytes_unsafe_get=runtime.caml_bytes_unsafe_get,
     caml_check_bound=runtime.caml_check_bound,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_ml_bytes_length=runtime.caml_ml_bytes_length,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_string_compare=runtime.caml_string_compare,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_UTF_8$0=caml_string_of_jsbytes("UTF-8"),
     cst_US_ASCII$0=caml_string_of_jsbytes("US-ASCII"),
     cst_ISO_8859_1$1=caml_string_of_jsbytes("ISO-8859-1"),
     cst_UTF_16$0=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16LE$0=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_16BE$0=caml_string_of_jsbytes("UTF-16BE"),
     cst_ISO646_US=caml_string_of_jsbytes("ISO646-US"),
     cst_CSISOLATIN1=caml_string_of_jsbytes("CSISOLATIN1"),
     cst_ANSI_X3_4_1968=caml_string_of_jsbytes("ANSI_X3.4-1968"),
     cst_ANSI_X3_4_1986=caml_string_of_jsbytes("ANSI_X3.4-1986"),
     cst_ASCII=caml_string_of_jsbytes("ASCII"),
     cst_CP367=caml_string_of_jsbytes("CP367"),
     cst_CP819=caml_string_of_jsbytes("CP819"),
     cst_CSASCII=caml_string_of_jsbytes("CSASCII"),
     cst_IBM367=caml_string_of_jsbytes("IBM367"),
     cst_IBM819=caml_string_of_jsbytes("IBM819"),
     cst_ISO_8859_1$0=caml_string_of_jsbytes("ISO-8859-1"),
     cst_ISO_IR_100=caml_string_of_jsbytes("ISO-IR-100"),
     cst_ISO_IR_6=caml_string_of_jsbytes("ISO-IR-6"),
     cst_US=caml_string_of_jsbytes("US"),
     cst_ISO_646_IRV_1991=caml_string_of_jsbytes("ISO_646.IRV:1991"),
     cst_ISO_8859_1=caml_string_of_jsbytes("ISO_8859-1"),
     cst_ISO_8859_1_1987=caml_string_of_jsbytes("ISO_8859-1:1987"),
     cst_L1=caml_string_of_jsbytes("L1"),
     cst_LATIN1=caml_string_of_jsbytes("LATIN1"),
     cst_US_ASCII=caml_string_of_jsbytes("US-ASCII"),
     cst_UTF_16=caml_string_of_jsbytes("UTF-16"),
     cst_UTF_16BE=caml_string_of_jsbytes("UTF-16BE"),
     cst_UTF_16LE=caml_string_of_jsbytes("UTF-16LE"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_expected_Await_encode=
      caml_string_of_jsbytes("expected `Await encode"),
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_format=global_data.Stdlib__format,
     _a_=Stdlib_format[125],
     _B_=[0,caml_string_of_jsbytes("src/uutf.ml"),364,9],
     _u_=
      [0,
       [11,caml_string_of_jsbytes("`Await"),0],
       caml_string_of_jsbytes("`Await")],
     _v_=
      [0,[11,caml_string_of_jsbytes("`End"),0],caml_string_of_jsbytes("`End")],
     _w_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Uchar U+"),[4,8,[0,2,4],0,[17,0,0]]]],
       caml_string_of_jsbytes("@[`Uchar U+%04X@]")],
     _x_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [11,caml_string_of_jsbytes("`Malformed ("),0]],
       caml_string_of_jsbytes("@[`Malformed (")],
     _y_=[0,[4,8,[0,2,2],0,0],caml_string_of_jsbytes("%02X")],
     _A_=[0,[12,32,[4,8,[0,2,2],0,0]],caml_string_of_jsbytes(" %02X")],
     _z_=[0,[12,41,[17,0,0]],caml_string_of_jsbytes(")@]")],
     _p_=[0,-211555818,3299808],
     _k_=[0,-211558048,3299808],
     _q_=[0,684370880,3299808],
     _o_=[0,684370880,427938126],
     _l_=[0,-211558048,427938126],
     _m_=[0,caml_string_of_jsbytes("src/uutf.ml"),154,55],
     _n_=[0,684370880,427938126],
     _r_=[0,caml_string_of_jsbytes("src/uutf.ml"),153,55],
     _s_=[0,caml_string_of_jsbytes("src/uutf.ml"),155,55],
     _t_=[0,684370880,3455931],
     _j_=[0,caml_string_of_jsbytes("src/uutf.ml"),121,9],
     _c_=[0,684370880],
     _d_=[0,-211555818],
     _e_=[0,-211558048],
     _f_=[0,143365725],
     _g_=[0,423112016],
     _h_=[0,338302576],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes("invalid bounds (index "),
        [4,0,0,0,[11,caml_string_of_jsbytes(", length "),[4,0,0,0,[12,41,0]]]]],
       caml_string_of_jsbytes("invalid bounds (index %d, length %d)")],
     _i_=
      [0,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       3,
       4,
       4,
       4,
       4,
       4,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0,
       0];
    function invalid_bounds(j,l)
     {var _aF_=caml_call3(Stdlib_printf[4],_b_,j,l);
      return caml_call1(Stdlib[1],_aF_)}
    function unsafe_set_byte(s,j,byte$0)
     {runtime.caml_bytes_unsafe_set(s,j,byte$0);return 0}
    var
     u_bom=caml_call1(Stdlib_uchar[9],65279),
     u_rep=caml_call1(Stdlib_uchar[9],65533);
    function encoding_of_string(s)
     {var
       match=caml_call1(Stdlib_string[25],s),
       _aD_=caml_string_compare(match,cst_ISO646_US),
       switch$1=0;
      if(0 <= _aD_)
       {if(0 < _aD_)
         {var switch$0=caml_string_compare(match,cst_US);
          if(0 <= switch$0)
           {if(0 < switch$0 && caml_string_notequal(match,cst_US_ASCII))
             {if(! caml_string_notequal(match,cst_UTF_16))return _f_;
              if(! caml_string_notequal(match,cst_UTF_16BE))return _e_;
              if(! caml_string_notequal(match,cst_UTF_16LE))return _d_;
              if(! caml_string_notequal(match,cst_UTF_8))return _c_;
              switch$1 = 2}}
          else
           if(caml_string_notequal(match,cst_ISO_646_IRV_1991))
            if
             (caml_string_notequal(match,cst_ISO_8859_1)
              &&
              caml_string_notequal(match,cst_ISO_8859_1_1987)
              &&
              caml_string_notequal(match,cst_L1)
              &&
              caml_string_notequal(match,cst_LATIN1))
             switch$1 = 2;
            else
             switch$1 = 1}}
      else
       {var _aE_=caml_string_compare(match,cst_CSISOLATIN1);
        if(0 <= _aE_)
         if(0 < _aE_)
          {if(caml_string_notequal(match,cst_IBM367))
            if
             (caml_string_notequal(match,cst_IBM819)
              &&
              caml_string_notequal(match,cst_ISO_8859_1$0)
              &&
              caml_string_notequal(match,cst_ISO_IR_100))
             {if(caml_string_notequal(match,cst_ISO_IR_6))switch$1 = 2}
            else
             switch$1 = 1}
         else
          switch$1 = 1;
        else
         if
          (caml_string_notequal(match,cst_ANSI_X3_4_1968)
           &&
           caml_string_notequal(match,cst_ANSI_X3_4_1986)
           &&
           caml_string_notequal(match,cst_ASCII)
           &&
           caml_string_notequal(match,cst_CP367))
          if(caml_string_notequal(match,cst_CP819))
           {if(caml_string_notequal(match,cst_CSASCII))switch$1 = 2}
          else
           switch$1 = 1}
      switch(switch$1){case 2:return 0;case 0:return _g_;default:return _h_}}
    function encoding_to_string(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?cst_UTF_8$0:cst_US_ASCII$0
                :338302576 <= param?cst_ISO_8859_1$1:cst_UTF_16$0
              :-211555818 <= param?cst_UTF_16LE$0:cst_UTF_16BE$0}
    function malformed(s,j,l)
     {return [0,659980059,caml_call3(Stdlib_bytes[8],s,j,l)]}
    function malformed_pair(be,hi,s,j,l)
     {var bs1=caml_call3(Stdlib_bytes[7],s,j,l),bs0=caml_create_bytes(2);
      if(be)var j1=1,j0=0;else var j1=0,j0=1;
      unsafe_set_byte(bs0,j0,hi >>> 8 | 0);
      unsafe_set_byte(bs0,j1,hi & 255);
      var _aC_=caml_call2(Stdlib_bytes[14],bs0,bs1);
      return [0,659980059,caml_call1(Stdlib_bytes[42],_aC_)]}
    var utf_8_len=_i_.slice();
    function r_utf_8(s,j,l)
     {function uchar(c){return [0,852405675,caml_call1(Stdlib_uchar[9],c)]}
      var switcher=l - 1 | 0;
      if(3 < switcher >>> 0)throw [0,Assert_failure,_j_];
      switch(switcher)
       {case 0:return uchar(caml_bytes_unsafe_get(s,j));
        case 1:
         var
          b0=caml_bytes_unsafe_get(s,j),
          b1=caml_bytes_unsafe_get(s,j + 1 | 0);
         return 2 === (b1 >>> 6 | 0)
                 ?uchar((b0 & 31) << 6 | b1 & 63)
                 :malformed(s,j,l);
        case 2:
         var
          b0$0=caml_bytes_unsafe_get(s,j),
          b1$0=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2=caml_bytes_unsafe_get(s,j + 2 | 0),
          c=(b0$0 & 15) << 12 | (b1$0 & 63) << 6 | b2 & 63;
         if(2 === (b2 >>> 6 | 0))
          {if(224 === b0$0)
            {if(160 <= b1$0 && ! (191 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           if(237 === b0$0)
            {if(128 <= b1$0 && ! (159 < b1$0))return uchar(c);
             return malformed(s,j,l)}
           return 2 === (b1$0 >>> 6 | 0)?uchar(c):malformed(s,j,l)}
         return malformed(s,j,l);
        default:
         var
          b0$1=caml_bytes_unsafe_get(s,j),
          b1$1=caml_bytes_unsafe_get(s,j + 1 | 0),
          b2$0=caml_bytes_unsafe_get(s,j + 2 | 0),
          b3=caml_bytes_unsafe_get(s,j + 3 | 0),
          c$0=
           (b0$1 & 7)
           <<
           18
           |
           (b1$1 & 63)
           <<
           12
           |
           (b2$0 & 63)
           <<
           6
           |
           b3
           &
           63;
         if(2 === (b3 >>> 6 | 0) && 2 === (b2$0 >>> 6 | 0))
          {if(240 === b0$1)
            {if(144 <= b1$1 && ! (191 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           if(244 === b0$1)
            {if(128 <= b1$1 && ! (143 < b1$1))return uchar(c$0);
             return malformed(s,j,l)}
           return 2 === (b1$1 >>> 6 | 0)?uchar(c$0):malformed(s,j,l)}
         return malformed(s,j,l)}}
    function r_utf_16(s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       u=b0 << 8 | b1;
      if(55296 <= u && ! (57343 < u))
       return 56319 < u
               ?malformed(s,caml_call2(Stdlib[16],j0,j1),2)
               :[0,16161,u];
      return [0,852405675,caml_call1(Stdlib_uchar[9],u)]}
    function r_utf_16_lo(hi,s,j0,j1)
     {var
       b0=caml_bytes_unsafe_get(s,j0),
       b1=caml_bytes_unsafe_get(s,j1),
       lo=b0 << 8 | b1;
      if(56320 <= lo && ! (57343 < lo))
       return [0,
               852405675,
               caml_call1
                (Stdlib_uchar[9],((hi & 1023) << 10 | lo & 1023) + 65536 | 0)];
      return malformed_pair(j0 < j1?1:0,hi,s,caml_call2(Stdlib[16],j0,j1),2)}
    function r_encoding(s,j,l)
     {function some(i){return i < l?[0,caml_bytes_unsafe_get(s,j + i | 0)]:0}
      var match=some(0),match$0=some(1),match$1=some(2);
      if(match)
       {var _aB_=match[1],switch$0=0;
        if(240 <= _aB_)
         if(254 === _aB_)
          {if(match$0){if(255 === match$0[1])return _k_;switch$0 = 1}}
         else
          if(255 === _aB_)
           {if(match$0){if(254 === match$0[1])return _p_;switch$0 = 1}}
          else
           switch$0 = 1;
        else
         if(0 === _aB_)
          {if(match$0)
            {var p=match$0[1];
             if(0 < p)return [0,-211558048,[0,605782321,p]];
             switch$0 = 1}}
         else
          if(239 <= _aB_)
           {if(match$0)
             if(187 === match$0[1])
              {if(match$1 && 191 === match$1[1])return _q_}
             else
              switch$0 = 1}
          else
           switch$0 = 1;
        if(switch$0 && match$0 && 0 === match$0[1] && 0 < _aB_)
         return [0,-211555818,[0,605782321,_aB_]];
        if(0 === caml_check_bound(utf_8_len,_aB_)[1 + _aB_])
         {if(match$0)return _l_;
          if(match$1)throw [0,Assert_failure,_m_];
          return _n_}
        return _o_}
      if(match$0)throw [0,Assert_failure,_r_];
      if(match$1)throw [0,Assert_failure,_s_];
      return _t_}
    function pp_decode(ppf,param)
     {if(typeof param === "number")
       return 1006505782 <= param
               ?caml_call2(_a_,ppf,_u_)
               :caml_call2(_a_,ppf,_v_);
      if(852405675 <= param[1])
       {var u=param[2];
        return caml_call3(_a_,ppf,_w_,caml_call1(Stdlib_uchar[10],u))}
      var bs=param[2],l=caml_ml_string_length(bs);
      caml_call2(_a_,ppf,_x_);
      if(0 < l)caml_call3(_a_,ppf,_y_,caml_string_get(bs,0));
      var _az_=l - 1 | 0,_ay_=1;
      if(! (_az_ < 1))
       {var i=_ay_;
        for(;;)
         {caml_call3(_a_,ppf,_A_,caml_string_get(bs,i));
          var _aA_=i + 1 | 0;
          if(_az_ !== i){var i=_aA_;continue}
          break}}
      return caml_call2(_a_,ppf,_z_)}
    function i_rem(d){return (d[7] - d[6] | 0) + 1 | 0}
    function eoi(d)
     {d[5] = Stdlib_bytes[3];d[6] = 0;d[7] = Stdlib[20];return 0}
    function src(d,s,j,l)
     {if(0 <= j && 0 <= l && ! (caml_ml_bytes_length(s) < (j + l | 0)))
       return 0 === l?eoi(d):(d[5] = s,d[6] = j,d[7] = (j + l | 0) - 1 | 0,0);
      return invalid_bounds(j,l)}
    function refill(k,d)
     {var _ax_=d[1];
      if(typeof _ax_ === "number"){d[18] = k;return 1006505782}
      if(438511779 <= _ax_[1])
       {var
         ic=_ax_[2],
         rc=caml_call4(Stdlib[84],ic,d[5],0,caml_ml_bytes_length(d[5]));
        src(d,d[5],0,rc);
        return caml_call1(k,d)}
      eoi(d);
      return caml_call1(k,d)}
    function t_need(d,need){d[9] = 0;d[10] = need;return 0}
    function t_fill(k,d)
     {function blit(d,l)
       {caml_blit_bytes(d[5],d[6],d[8],d[9],l);
        d[6] = d[6] + l | 0;
        d[9] = d[9] + l | 0;
        return 0}
      var rem=i_rem(d);
      if(0 <= rem)
       {var need=d[10] - d[9] | 0;
        return rem < need
                ?(blit(d,rem),refill(function(_aw_){return t_fill(k,_aw_)},d))
                :(blit(d,need),caml_call1(k,d))}
      return caml_call1(k,d)}
    function ret(k,v,byte_count,d)
     {d[18] = k;d[15] = d[15] + byte_count | 0;return caml_call2(d[17],d,v)}
    function decode_us_ascii(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        var
         _au_=d[5],
         b0=caml_bytes_unsafe_get(_au_,j),
         _at_=1,
         _av_=
          127 < b0
           ?malformed(_au_,j,1)
           :[0,852405675,caml_call1(Stdlib_uchar[9],b0)];
        return ret(decode_us_ascii,_av_,_at_,d)}
      return 0 <= rem?refill(decode_us_ascii,d):3455931}
    function decode_iso_8859_1(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var j=d[6];
        d[6] = d[6] + 1 | 0;
        return ret
                (decode_iso_8859_1,
                 [0,
                  852405675,
                  caml_call1(Stdlib_uchar[9],caml_bytes_unsafe_get(d[5],j))],
                 1,
                 d)}
      return 0 <= rem?refill(decode_iso_8859_1,d):3455931}
    function t_decode_utf_8(d)
     {if(d[9] < d[10])
       {var _ar_=d[9];return ret(decode_utf_8,malformed(d[8],0,d[9]),_ar_,d)}
      var _as_=d[9];
      return ret(decode_utf_8,r_utf_8(d[8],0,d[9]),_as_,d)}
    function decode_utf_8(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {var need=utf_8_len[1 + caml_bytes_unsafe_get(d[5],d[6])];
        if(rem < need){t_need(d,need);return t_fill(t_decode_utf_8,d)}
        var j=d[6];
        return 0 === need
                ?(d[6]
                  =
                  d[6]
                  +
                  1
                  |
                  0,
                  ret(decode_utf_8,malformed(d[5],j,1),1,d))
                :(d[6]
                  =
                  d[6]
                  +
                  need
                  |
                  0,
                  ret(decode_utf_8,r_utf_8(d[5],j,need),need,d))}
      return 0 <= rem?refill(decode_utf_8,d):3455931}
    function t_decode_utf_16be_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16be,malformed_pair(1,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16be,r_utf_16_lo(hi,d[8],0,1),bcount,d)}
    function decode_utf_16be_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16be,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16be,r_utf_16_lo(hi,d[5],j,j + 1 | 0),4,d)}
      t_need(d,2);
      return t_fill(function(_aq_){return t_decode_utf_16be_lo(hi,_aq_)},d)}
    function t_decode_utf_16be(d)
     {if(d[9] < d[10])
       {var _ap_=d[9];
        return ret(decode_utf_16be,malformed(d[8],0,d[9]),_ap_,d)}
      return decode_utf_16be_lo(r_utf_16(d[8],0,1),d)}
    function decode_utf_16be(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16be_lo(r_utf_16(d[5],j,j + 1 | 0),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16be,d)}
      return 0 <= rem?refill(decode_utf_16be,d):3455931}
    function t_decode_utf_16_lo(hi,d)
     {var bcount=d[9] + 2 | 0;
      return d[9] < d[10]
              ?ret(decode_utf_16,malformed_pair(0,hi,d[8],0,d[9]),bcount,d)
              :ret(decode_utf_16,r_utf_16_lo(hi,d[8],1,0),bcount,d)}
    function decode_utf_16le_lo(v,d)
     {if(659980059 <= v[1])return ret(decode_utf_16,v,2,d);
      var hi=v[2],rem=i_rem(d);
      if(2 <= rem)
       {var j=d[6];
        d[6] = d[6] + 2 | 0;
        return ret(decode_utf_16,r_utf_16_lo(hi,d[5],j + 1 | 0,j),4,d)}
      t_need(d,2);
      return t_fill(function(_ao_){return t_decode_utf_16_lo(hi,_ao_)},d)}
    function t_decode_utf_16(d)
     {if(d[9] < d[10])
       {var _an_=d[9];return ret(decode_utf_16,malformed(d[8],0,d[9]),_an_,d)}
      return decode_utf_16le_lo(r_utf_16(d[8],1,0),d)}
    function decode_utf_16(d)
     {var rem=i_rem(d);
      if(0 < rem)
       {if(2 <= rem)
         {var j=d[6];
          d[6] = d[6] + 2 | 0;
          return decode_utf_16le_lo(r_utf_16(d[5],j + 1 | 0,j),d)}
        t_need(d,2);
        return t_fill(t_decode_utf_16,d)}
      return 0 <= rem?refill(decode_utf_16,d):3455931}
    function guessed_utf_16(d,be,v)
     {if(be)
       var
        j1=1,
        j0=0,
        t_decode_utf_16_lo$0=t_decode_utf_16be_lo,
        t_decode_utf_16$0=t_decode_utf_16be,
        decode_utf_16$0=decode_utf_16be;
      else
       var
        j1=0,
        j0=1,
        t_decode_utf_16_lo$0=t_decode_utf_16_lo,
        t_decode_utf_16$0=t_decode_utf_16,
        decode_utf_16$0=decode_utf_16;
      function b3(k,d)
       {return 3 <= d[9]
                ?(d[10]
                  =
                  2,
                  d[9]
                  =
                  1,
                  unsafe_set_byte(d[8],0,caml_bytes_unsafe_get(d[8],2)),
                  t_fill(k,d))
                :decode_utf_16$0(d)}
      if(typeof v === "number")
       {if(427938126 <= v)
         {var v$0=r_utf_16(d[8],j0,j1);
          if(659980059 <= v$0[1])
           {var _ad_=2;
            return ret
                    (function(_am_){return b3(t_decode_utf_16$0,_am_)},
                     v$0,
                     _ad_,
                     d)}
          var hi=v$0[2];
          if(3 <= d[9])
           return b3(function(_al_){return t_decode_utf_16_lo$0(hi,_al_)},d);
          var _ae_=d[9];
          return ret
                  (decode_utf_16$0,
                   malformed_pair(be,hi,Stdlib_bytes[3],0,0),
                   _ae_,
                   d)}
        var _af_=2,_ag_=[0,852405675,u_bom];
        return ret
                (function(_ak_){return b3(t_decode_utf_16$0,_ak_)},
                 _ag_,
                 _af_,
                 d)}
      var u=v[2],_ah_=2,_ai_=[0,852405675,caml_call1(Stdlib_uchar[9],u)];
      return ret
              (function(_aj_){return b3(t_decode_utf_16$0,_aj_)},_ai_,_ah_,d)}
    function k(d)
     {function setup(d)
       {var match=r_encoding(d[8],0,d[9]),_ac_=match[1];
        if(-211555818 === _ac_)
         {var r=match[2];
          d[2] = -211555818;
          d[18] = decode_utf_16;
          return guessed_utf_16(d,0,r)}
        if(684370880 <= _ac_)
         {var r$0=match[2];
          d[2] = 684370880;
          d[18] = decode_utf_8;
          if(3455931 === r$0)return 3455931;
          if(427938126 <= r$0)
           {var
             b3=
              function(d)
               {var
                 b3=caml_bytes_unsafe_get(d[8],2),
                 n=caml_check_bound(utf_8_len,b3)[1 + b3];
                return 0 === n
                        ?ret(decode_utf_8,malformed(d[8],2,1),1,d)
                        :(d[10]
                          =
                          n,
                          d[9]
                          =
                          1,
                          unsafe_set_byte(d[8],0,b3),
                          t_fill(t_decode_utf_8,d))},
             b2=
              function(d)
               {var
                 b2=caml_bytes_unsafe_get(d[8],1),
                 b3$0=2 < d[9]?b3:decode_utf_8,
                 n=caml_check_bound(utf_8_len,b2)[1 + b2];
                if(0 === n)return ret(b3$0,malformed(d[8],1,1),1,d);
                if(1 === n)return ret(b3$0,r_utf_8(d[8],1,1),1,d);
                d[10] = n;
                unsafe_set_byte(d[8],0,b2);
                if(3 <= d[9])
                 {d[9] = 2;
                  unsafe_set_byte(d[8],1,caml_bytes_unsafe_get(d[8],2))}
                else
                 d[9] = 1;
                return t_fill(t_decode_utf_8,d)},
             b1=caml_bytes_unsafe_get(d[8],0),
             b2$0=1 < d[9]?b2:decode_utf_8,
             n=caml_check_bound(utf_8_len,b1)[1 + b1];
            if(4 < n >>> 0)throw [0,Assert_failure,_B_];
            switch(n)
             {case 0:return ret(b2$0,malformed(d[8],0,1),1,d);
              case 1:return ret(b2$0,r_utf_8(d[8],0,1),1,d);
              case 2:
               return 2 <= d[9]
                       ?3 <= d[9]
                         ?ret(b3,r_utf_8(d[8],0,2),2,d)
                         :ret(decode_utf_8,r_utf_8(d[8],0,2),2,d)
                       :ret(decode_utf_8,malformed(d[8],0,1),1,d);
              case 3:
               if(3 <= d[9])return ret(decode_utf_8,r_utf_8(d[8],0,3),3,d);
               var _aa_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_aa_,d);
              default:
               if(3 <= d[9]){d[10] = 4;return t_fill(t_decode_utf_8,d)}
               var _ab_=d[9];
               return ret(decode_utf_8,malformed(d[8],0,d[9]),_ab_,d)}}
          return ret(decode_utf_8,[0,852405675,u_bom],3,d)}
        var r$1=match[2];
        d[2] = -211558048;
        d[18] = decode_utf_16be;
        return guessed_utf_16(d,1,r$1)}
      t_need(d,3);
      return t_fill(setup,d)}
    function nline(d){d[14] = 0;d[13] = d[13] + 1 | 0;return 0}
    function ncol(d){d[14] = d[14] + 1 | 0;return 0}
    function ncount(d){d[16] = d[16] + 1 | 0;return 0}
    function cr(d,b){d[12] = b;return 0}
    function pp(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _$_=match - 133 | 0,
         switch$0=0;
        if(8100 < _$_ >>> 0)
         {var switcher=_$_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              ncount(d);
              return last_cr?v:(nline(d),v);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return v}}
        else
         if(8097 < (_$_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_readline(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         ___=match - 133 | 0,
         switch$0=0;
        if(8100 < ___ >>> 0)
         {var switcher=___ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (___ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),[0,852405675,d[4]])
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_nlf(d,v)
     {if(852405675 <= v[1])
       {var u=v[2],match=caml_call1(Stdlib_uchar[10],u),switch$0=0;
        if(14 <= match)
         {if(8232 <= match)
           {if(! (8234 <= match))switch$0 = 1}
          else
           if(133 === match)
            {cr(d,0);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(10 <= match)
          {var switcher=match - 10 | 0;
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function pp_nln_ascii(d,v)
     {if(852405675 <= v[1])
       {var
         u=v[2],
         match=caml_call1(Stdlib_uchar[10],u),
         _Z_=match - 133 | 0,
         switch$0=0;
        if(8100 < _Z_ >>> 0)
         {var switcher=_Z_ + 123 | 0;
          if(! (3 < switcher >>> 0))
           switch(switcher)
            {case 0:
              var last_cr=d[12];
              cr(d,0);
              return last_cr
                      ?caml_call1(d[18],d)
                      :(ncount(d),nline(d),[0,852405675,d[4]]);
             case 1:break;
             case 2:switch$0 = 1;break;
             default:cr(d,1);ncount(d);nline(d);return [0,852405675,d[4]]}}
        else
         if(8097 < (_Z_ - 1 | 0) >>> 0)switch$0 = 1;
        return switch$0
                ?(cr(d,0),ncount(d),nline(d),v)
                :(cr(d,0),ncount(d),ncol(d),v)}
      cr(d,0);
      ncount(d);
      ncol(d);
      return v}
    function decode_fun(param)
     {return 143365725 <= param
              ?423112016 <= param
                ?684370880 <= param?decode_utf_8:decode_us_ascii
                :338302576 <= param?decode_iso_8859_1:decode_utf_16be
              :-211555818 <= param?decode_utf_16:decode_utf_16be}
    function decoder(nln,encoding,src)
     {if(nln)
       {var _X_=nln[1],_Y_=_X_[1];
        if(3895880 === _Y_)
         var nl=_X_[2],nl$0=nl,pp$0=pp_nln_nlf;
        else
         if(605782321 <= _Y_)
          var nl$1=_X_[2],nl$0=nl$1,pp$0=pp_nln_ascii;
         else
          var nl$2=_X_[2],nl$0=nl$2,pp$0=pp_nln_readline}
      else
       var nl$3=caml_call1(Stdlib_uchar[9],10),nl$0=nl$3,pp$0=pp;
      if(encoding)
       var e=encoding[1],k$0=decode_fun(e),encoding$0=e;
      else
       var k$0=k,encoding$0=684370880;
      if(typeof src === "number")
       var i_max=0,i_pos=1,i=Stdlib_bytes[3];
      else
       if(438511779 <= src[1])
        var i_max=0,i_pos=1,i=caml_create_bytes(65536);
       else
        var
         s=src[2],
         i_max$0=caml_ml_string_length(s) - 1 | 0,
         i$0=caml_call1(Stdlib_bytes[43],s),
         i_max=i_max$0,
         i_pos=0,
         i=i$0;
      var utf16=143365725 === encoding$0?1:0;
      return [0,
              src,
              encoding$0,
              nln,
              nl$0,
              i,
              i_pos,
              i_max,
              caml_create_bytes(4),
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              function(d,v)
               {if(852405675 <= v[1])
                 {var u=v[2],match=caml_call1(Stdlib_uchar[10],u);
                  if(65279 === match)
                   {if(utf16){d[2] = -211558048;d[18] = decode_utf_16be}
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  if(65534 === match && utf16)
                   {d[2] = -211555818;
                    d[18] = decode_utf_16;
                    d[11] = 1;
                    d[17] = pp$0;
                    return caml_call1(d[18],d)}
                  d[11] = 0;
                  d[17] = pp$0;
                  return caml_call2(d[17],d,v)}
                d[11] = 0;
                d[17] = pp$0;
                return caml_call2(d[17],d,v)},
              k$0]}
    function decode(d){return caml_call1(d[18],d)}
    function decoder_line(d){return d[13]}
    function decoder_col(d){return d[14]}
    function decoder_byte_count(d){return d[15]}
    function decoder_count(d){return d[16]}
    function decoder_removed_bom(d){return d[11]}
    function decoder_src(d){return d[1]}
    function decoder_nln(d){return d[3]}
    function decoder_encoding(d){return d[2]}
    function set_decoder_encoding(d,e)
     {d[2] = e;d[18] = decode_fun(e);return 0}
    function o_rem(e){return (e[5] - e[4] | 0) + 1 | 0}
    function dst(e,s,j,l)
     {var _U_=j < 0?1:0;
      if(_U_)
       var _V_=_U_;
      else
       var
        _W_=l < 0?1:0,
        _V_=_W_ || (caml_ml_bytes_length(s) < (j + l | 0)?1:0);
      if(_V_)invalid_bounds(j,l);
      e[3] = s;
      e[4] = j;
      e[5] = (j + l | 0) - 1 | 0;
      return 0}
    function flush(k,e)
     {var _T_=e[1];
      if(typeof _T_ === "number")
       {e[9]
        =
        function(e,param)
         {if(typeof param === "number" && 1006505782 <= param)
           return caml_call1(k,e);
          return caml_call1(Stdlib[1],cst_expected_Await_encode)};
        return 939392865}
      if(438511779 <= _T_[1])
       {var oc=_T_[2];
        caml_call4(Stdlib[68],oc,e[3],0,e[4]);
        e[4] = 0;
        return caml_call1(k,e)}
      var b=_T_[2],o=caml_call1(Stdlib_bytes[42],e[3]);
      caml_call4(Stdlib_buffer[16],b,o,0,e[4]);
      e[4] = 0;
      return caml_call1(k,e)}
    function t_range(e,max){e[7] = 0;e[8] = max;return 0}
    function t_flush(k,e)
     {function blit(e,l)
       {caml_blit_bytes(e[6],e[7],e[3],e[4],l);
        e[4] = e[4] + l | 0;
        e[7] = e[7] + l | 0;
        return 0}
      var rem=o_rem(e),len=(e[8] - e[7] | 0) + 1 | 0;
      return rem < len
              ?(blit(e,rem),flush(function(_S_){return t_flush(k,_S_)},e))
              :(blit(e,len),caml_call1(k,e))}
    function encode_utf_8(e,v)
     {function k(e){e[9] = encode_utf_8;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(127 < u$0)
       {if(2047 < u$0)
         {if(65535 < u$0)
           {if(4 <= rem)
             {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
            else
             {t_range(e,3);
              var
               _M_=function(_R_){return t_flush(k,_R_)},
               k$0=_M_,
               j$0=0,
               s=e[6]}
            unsafe_set_byte(s,j$0,240 | u$0 >>> 18 | 0);
            unsafe_set_byte(s,j$0 + 1 | 0,128 | (u$0 >>> 12 | 0) & 63);
            unsafe_set_byte(s,j$0 + 2 | 0,128 | (u$0 >>> 6 | 0) & 63);
            unsafe_set_byte(s,j$0 + 3 | 0,128 | u$0 & 63);
            return k$0(e)}
          if(3 <= rem)
           {var j$1=e[4];e[4] = e[4] + 3 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
          else
           {t_range(e,2);
            var
             _N_=function(_Q_){return t_flush(k,_Q_)},
             k$1=_N_,
             j$2=0,
             s$0=e[6]}
          unsafe_set_byte(s$0,j$2,224 | u$0 >>> 12 | 0);
          unsafe_set_byte(s$0,j$2 + 1 | 0,128 | (u$0 >>> 6 | 0) & 63);
          unsafe_set_byte(s$0,j$2 + 2 | 0,128 | u$0 & 63);
          return k$1(e)}
        if(2 <= rem)
         {var j$3=e[4];e[4] = e[4] + 2 | 0;var k$2=k,j$4=j$3,s$1=e[3]}
        else
         {t_range(e,1);
          var _O_=function(_P_){return t_flush(k,_P_)},k$2=_O_,j$4=0,s$1=e[6]}
        unsafe_set_byte(s$1,j$4,192 | u$0 >>> 6 | 0);
        unsafe_set_byte(s$1,j$4 + 1 | 0,128 | u$0 & 63);
        return k$2(e)}
      return 1 <= rem
              ?(unsafe_set_byte(e[3],e[4],u$0),e[4] = e[4] + 1 | 0,k(e))
              :flush(function(e){return encode_utf_8(e,v)},e)}
    function encode_utf_16be(e,v)
     {function k(e){e[9] = encode_utf_16be;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _I_=function(_L_){return t_flush(k,_L_)},k$0=_I_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 1 | 0,hi & 255);
        unsafe_set_byte(s,j$0 + 2 | 0,lo >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 3 | 0,lo & 255);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _J_=function(_K_){return t_flush(k,_K_)},k$1=_J_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 >>> 8 | 0);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 & 255);
      return k$1(e)}
    function encode_utf_16le(e,v)
     {function k(e){e[9] = encode_utf_16le;return 17724}
      if(typeof v === "number")return 1006505782 <= v?k(e):flush(k,e);
      var u=v[2],u$0=caml_call1(Stdlib_uchar[10],u),rem=o_rem(e);
      if(65536 <= u$0)
       {if(4 <= rem)
         {var j=e[4];e[4] = e[4] + 4 | 0;var k$0=k,j$0=j,s=e[3]}
        else
         {t_range(e,3);
          var _E_=function(_H_){return t_flush(k,_H_)},k$0=_E_,j$0=0,s=e[6]}
        var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        unsafe_set_byte(s,j$0,hi & 255);
        unsafe_set_byte(s,j$0 + 1 | 0,hi >>> 8 | 0);
        unsafe_set_byte(s,j$0 + 2 | 0,lo & 255);
        unsafe_set_byte(s,j$0 + 3 | 0,lo >>> 8 | 0);
        return k$0(e)}
      if(2 <= rem)
       {var j$1=e[4];e[4] = e[4] + 2 | 0;var k$1=k,j$2=j$1,s$0=e[3]}
      else
       {t_range(e,1);
        var _F_=function(_G_){return t_flush(k,_G_)},k$1=_F_,j$2=0,s$0=e[6]}
      unsafe_set_byte(s$0,j$2,u$0 & 255);
      unsafe_set_byte(s$0,j$2 + 1 | 0,u$0 >>> 8 | 0);
      return k$1(e)}
    function encoder(encoding,dst)
     {if(typeof dst === "number")
       var o_max=0,o_pos=1,o=Stdlib_bytes[3];
      else
       var o$0=caml_create_bytes(65536),o_max=65535,o_pos=0,o=o$0;
      var
       _D_=
        143365725 <= encoding
         ?684370880 <= encoding?encode_utf_8:encode_utf_16be
         :-211555818 <= encoding?encode_utf_16le:encode_utf_16be;
      return [0,dst,encoding,o,o_pos,o_max,caml_create_bytes(4),1,0,_D_]}
    function encode(e,v){return caml_call2(e[9],e,v)}
    function encoder_encoding(e){return e[2]}
    function encoder_dst(e){return e[1]}
    var Manual=[0,src,dst,o_rem];
    function encoding_guess(s)
     {var
       s$0=caml_call1(Stdlib_bytes[43],s),
       match=
        r_encoding(s$0,0,caml_call2(Stdlib[17],caml_ml_bytes_length(s$0),3)),
       _C_=match[1];
      if(-211555818 === _C_)
       {var d=match[2];return [0,-211555818,3299808 === d?1:0]}
      if(684370880 <= _C_)
       {var d$0=match[2];return [0,684370880,3299808 === d$0?1:0]}
      var d$1=match[2];
      return [0,-211558048,3299808 === d$1?1:0]}
    function fold_utf_8(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var need=utf_8_len[1 + caml_bytes_unsafe_get(s$0,i)];
        if(0 === need)
         {var
           i$0=i + 1 | 0,
           acc$1=caml_call3(f,acc$0,i,malformed(s$0,i,1)),
           acc$0=acc$1,
           i=i$0;
          continue}
        var rem=(last - i | 0) + 1 | 0;
        if(rem < need)return caml_call3(f,acc$0,i,malformed(s$0,i,rem));
        var
         i$1=i + need | 0,
         acc$2=caml_call3(f,acc$0,i,r_utf_8(s$0,i,need)),
         acc$0=acc$2,
         i=i$1;
        continue}}
    function fold_utf_16be(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i,i + 1 | 0);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 2 | 0,i + 3 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    function fold_utf_16le(opt,len,f,acc,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(len)
       var l=len[1],len$0=l;
      else
       var len$0=caml_ml_string_length(s) - pos | 0;
      var
       last=(pos + len$0 | 0) - 1 | 0,
       s$0=caml_call1(Stdlib_bytes[43],s),
       acc$0=acc,
       i=pos;
      for(;;)
       {if(last < i)return acc$0;
        var rem=(last - i | 0) + 1 | 0;
        if(2 <= rem)
         {var v=r_utf_16(s$0,i + 1 | 0,i);
          if(659980059 <= v[1])
           {var i$0=i + 2 | 0,acc$1=caml_call3(f,acc$0,i,v),acc$0=acc$1,i=i$0;
            continue}
          var hi=v[2];
          if(4 <= rem)
           {var
             i$1=i + 4 | 0,
             acc$2=
              caml_call3(f,acc$0,i,r_utf_16_lo(hi,s$0,i + 3 | 0,i + 2 | 0)),
             acc$0=acc$2,
             i=i$1;
            continue}
          return caml_call3(f,acc$0,i,malformed(s$0,i,rem))}
        return caml_call3(f,acc$0,i,malformed(s$0,i,1))}}
    var String=[0,encoding_guess,fold_utf_8,fold_utf_16be,fold_utf_16le];
    function add_utf_8(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      return 127 < u$0
              ?2047 < u$0
                ?65535 < u$0
                  ?(w(240 | u$0 >>> 18 | 0),
                    w(128 | (u$0 >>> 12 | 0) & 63),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                  :(w(224 | u$0 >>> 12 | 0),
                    w(128 | (u$0 >>> 6 | 0) & 63),
                    w(128 | u$0 & 63))
                :(w(192 | u$0 >>> 6 | 0),w(128 | u$0 & 63))
              :w(u$0)}
    function add_utf_16be(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi >>> 8 | 0);
        w(hi & 255);
        w(lo >>> 8 | 0);
        return w(lo & 255)}
      w(u$0 >>> 8 | 0);
      return w(u$0 & 255)}
    function add_utf_16le(b,u)
     {var u$0=caml_call1(Stdlib_uchar[10],u);
      function w(byte$0){return caml_call2(Stdlib_buffer[10],b,byte$0)}
      if(65536 <= u$0)
       {var
         u$1=u$0 - 65536 | 0,
         hi=55296 | u$1 >>> 10 | 0,
         lo=56320 | u$1 & 1023;
        w(hi & 255);
        w(hi >>> 8 | 0);
        w(lo & 255);
        return w(lo >>> 8 | 0)}
      w(u$0 & 255);
      return w(u$0 >>> 8 | 0)}
    var
     Buffer=[0,add_utf_8,add_utf_16be,add_utf_16le],
     Uutf=
      [0,
       u_bom,
       u_rep,
       encoding_of_string,
       encoding_to_string,
       decoder,
       decode,
       decoder_encoding,
       set_decoder_encoding,
       decoder_line,
       decoder_col,
       decoder_byte_count,
       decoder_count,
       decoder_removed_bom,
       decoder_src,
       decoder_nln,
       pp_decode,
       encoder,
       encode,
       encoder_encoding,
       encoder_dst,
       Manual,
       String,
       Buffer];
    runtime.caml_register_global(66,Uutf,"Uutf");
    return}
  (function(){return this}()));


//# 1 "../.js/re/re.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_bytes_get=runtime.caml_bytes_get,
     caml_bytes_set=runtime.caml_bytes_set,
     caml_bytes_unsafe_set=runtime.caml_bytes_unsafe_set,
     caml_check_bound=runtime.caml_check_bound,
     caml_compare=runtime.caml_compare,
     caml_create_bytes=runtime.caml_create_bytes,
     caml_equal=runtime.caml_equal,
     caml_fresh_oo_id=runtime.caml_fresh_oo_id,
     caml_int_compare=runtime.caml_int_compare,
     caml_lessthan=runtime.caml_lessthan,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_make_vect=runtime.caml_make_vect,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_obj_tag=runtime.caml_obj_tag,
     caml_register_global=runtime.caml_register_global,
     caml_string_get=runtime.caml_string_get,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_trampoline=runtime.caml_trampoline,
     caml_trampoline_return=runtime.caml_trampoline_return,
     caml_wrap_exception=runtime.caml_wrap_exception;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Re_cset_pick=caml_string_of_jsbytes("Re_cset.pick"),
     cany=[0,[0,0,255],0],
     cst_eps=caml_string_of_jsbytes("eps"),
     cst_cst=caml_string_of_jsbytes("cst"),
     cst_alt=caml_string_of_jsbytes("alt"),
     cst_seq=caml_string_of_jsbytes("seq"),
     cst_rep=caml_string_of_jsbytes("rep"),
     cst_mark=caml_string_of_jsbytes("mark"),
     cst_erase=caml_string_of_jsbytes("erase"),
     cst_before=caml_string_of_jsbytes("before"),
     cst_after=caml_string_of_jsbytes("after"),
     cst_pmark=caml_string_of_jsbytes("pmark"),
     cst_Non_greedy=caml_string_of_jsbytes("Non_greedy"),
     cst_Greedy=caml_string_of_jsbytes("Greedy"),
     cst_first=caml_string_of_jsbytes("first"),
     cst_short=caml_string_of_jsbytes("short"),
     cst_long=caml_string_of_jsbytes("long"),
     eps_expr=[0,0,0],
     cst_Group=caml_string_of_jsbytes("Group"),
     dummy_offset=[0,-1,-1],
     dummy_string=caml_string_of_jsbytes(""),
     cst_Beg_of_line=caml_string_of_jsbytes("Beg_of_line"),
     cst_End_of_line=caml_string_of_jsbytes("End_of_line"),
     cst_Beg_of_word=caml_string_of_jsbytes("Beg_of_word"),
     cst_End_of_word=caml_string_of_jsbytes("End_of_word"),
     cst_Not_bound=caml_string_of_jsbytes("Not_bound"),
     cst_Beg_of_str=caml_string_of_jsbytes("Beg_of_str"),
     cst_End_of_str=caml_string_of_jsbytes("End_of_str"),
     cst_Last_end_of_line=caml_string_of_jsbytes("Last_end_of_line"),
     cst_Start=caml_string_of_jsbytes("Start"),
     cst_Stop=caml_string_of_jsbytes("Stop"),
     cst_Set=caml_string_of_jsbytes("Set"),
     cst_Sequence=caml_string_of_jsbytes("Sequence"),
     cst_Alternative=caml_string_of_jsbytes("Alternative"),
     cst_Repeat=caml_string_of_jsbytes("Repeat"),
     cst_Sem=caml_string_of_jsbytes("Sem"),
     cst_Sem_greedy=caml_string_of_jsbytes("Sem_greedy"),
     cst_Group$0=caml_string_of_jsbytes("Group"),
     cst_No_group=caml_string_of_jsbytes("No_group"),
     cst_Nest=caml_string_of_jsbytes("Nest"),
     cst_Case=caml_string_of_jsbytes("Case"),
     cst_No_case=caml_string_of_jsbytes("No_case"),
     cst_Intersection=caml_string_of_jsbytes("Intersection"),
     cst_Complement=caml_string_of_jsbytes("Complement"),
     cst_Difference=caml_string_of_jsbytes("Difference"),
     cst_Pmark=caml_string_of_jsbytes("Pmark"),
     cst$1=caml_string_of_jsbytes(""),
     cst$2=caml_string_of_jsbytes(""),
     cst_Re_replace=caml_string_of_jsbytes("Re.replace"),
     cst_Re_replace$0=caml_string_of_jsbytes("Re.replace"),
     cst_Re_split=caml_string_of_jsbytes("Re.split"),
     cst_Re_split$0=caml_string_of_jsbytes("Re.split"),
     cst_Re_all=caml_string_of_jsbytes("Re.all"),
     cst_Re_all$0=caml_string_of_jsbytes("Re.all"),
     cst_Re_exec_partial=caml_string_of_jsbytes("Re.exec_partial"),
     cst_Re_execp=caml_string_of_jsbytes("Re.execp"),
     cst_Re_exec_opt=caml_string_of_jsbytes("Re.exec_opt"),
     cst_Re_exec=caml_string_of_jsbytes("Re.exec"),
     cst_Re_diff=caml_string_of_jsbytes("Re.diff"),
     cst_Re_compl=caml_string_of_jsbytes("Re.compl"),
     cst_Re_inter=caml_string_of_jsbytes("Re.inter"),
     cst_Re_repn=caml_string_of_jsbytes("Re.repn"),
     cst_Re_repn$0=caml_string_of_jsbytes("Re.repn"),
     cst$0=caml_string_of_jsbytes("\t "),
     cst_Re_Emacs_Parse_error=caml_string_of_jsbytes("Re__Emacs.Parse_error"),
     cst_Re_Emacs_Not_supported=
      caml_string_of_jsbytes("Re__Emacs.Not_supported"),
     cst_Str_replace_illegal_backsl=
      caml_string_of_jsbytes("Str.replace: illegal backslash sequence"),
     cst$5=caml_string_of_jsbytes(""),
     cst$4=caml_string_of_jsbytes(""),
     cst$3=caml_string_of_jsbytes(""),
     cst_Str_group_end=caml_string_of_jsbytes("Str.group_end"),
     cst_Str_group_beginning=caml_string_of_jsbytes("Str.group_beginning"),
     beg=[0,caml_string_of_jsbytes(""),0],
     cst_Re_Glob_Parse_error=caml_string_of_jsbytes("Re__Glob.Parse_error"),
     cst$6=caml_string_of_jsbytes(":]"),
     cst_lower=caml_string_of_jsbytes("lower"),
     cst_alnum=caml_string_of_jsbytes("alnum"),
     cst_ascii=caml_string_of_jsbytes("ascii"),
     cst_blank=caml_string_of_jsbytes("blank"),
     cst_cntrl=caml_string_of_jsbytes("cntrl"),
     cst_digit=caml_string_of_jsbytes("digit"),
     cst_graph=caml_string_of_jsbytes("graph"),
     cst_print=caml_string_of_jsbytes("print"),
     cst_punct=caml_string_of_jsbytes("punct"),
     cst_space=caml_string_of_jsbytes("space"),
     cst_upper=caml_string_of_jsbytes("upper"),
     cst_word=caml_string_of_jsbytes("word"),
     cst_xdigit=caml_string_of_jsbytes("xdigit"),
     cst_Invalid_pcre_class=caml_string_of_jsbytes("Invalid pcre class: "),
     cst_Re_Perl_Parse_error=caml_string_of_jsbytes("Re__Perl.Parse_error"),
     cst_Re_Perl_Not_supported=
      caml_string_of_jsbytes("Re__Perl.Not_supported"),
     posix_class_strings=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("alnum"),
         caml_string_of_jsbytes("ascii"),
         caml_string_of_jsbytes("blank"),
         caml_string_of_jsbytes("cntrl"),
         caml_string_of_jsbytes("digit"),
         caml_string_of_jsbytes("lower"),
         caml_string_of_jsbytes("print"),
         caml_string_of_jsbytes("space"),
         caml_string_of_jsbytes("upper"),
         caml_string_of_jsbytes("word"),
         caml_string_of_jsbytes("punct"),
         caml_string_of_jsbytes("graph"),
         caml_string_of_jsbytes("xdigit")]),
     cst_Re_Posix_Parse_error=caml_string_of_jsbytes("Re__Posix.Parse_error"),
     cst_Re_Posix_Not_supported=
      caml_string_of_jsbytes("Re__Posix.Not_supported"),
     include=global_data.Stdlib__format,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Stdlib=global_data.Stdlib,
     Assert_failure=global_data.Assert_failure,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_map=global_data.Stdlib__map,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_array=global_data.Stdlib__array,
     Stdlib_hashtbl=global_data.Stdlib__hashtbl,
     Stdlib_char=global_data.Stdlib__char,
     Stdlib_bytes=global_data.Stdlib__bytes,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_seq=global_data.Stdlib__seq,
     CamlinternalLazy=global_data.CamlinternalLazy,
     Re=[0];
    caml_register_global(134,Re,"Re__");
    var
     _bI_=
      [0,
       [12,59,[17,[0,caml_string_of_jsbytes("@ "),1,0],0]],
       caml_string_of_jsbytes(";@ ")],
     _bJ_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [12,
         91,
         [17,
          [0,caml_string_of_jsbytes("@ "),1,0],
          [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[12,93,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>[@ %a@ ]@]")],
     _bH_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _bG_=
      [0,
       [17,[0,caml_string_of_jsbytes("@ "),1,0],[4,0,0,0,0]],
       caml_string_of_jsbytes("@ %d")],
     _bF_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<3>"),0],
          caml_string_of_jsbytes("<3>")]],
        [12,
         40,
         [2,0,[17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]]],
       caml_string_of_jsbytes("@[<3>(%s@ %a)@]")],
     _bN_=[0,caml_string_of_jsbytes("lib/cset.ml"),153,9],
     _bK_=[0,[4,0,0,0,0],caml_string_of_jsbytes("%d")],
     _bL_=[0,[4,0,0,0,[12,45,[4,0,0,0,0]]],caml_string_of_jsbytes("%d-%d")],
     _b1_=[0,caml_string_of_jsbytes("lib/automata.ml"),360,21],
     _bS_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("(Seq"),
         [17,[0,caml_string_of_jsbytes("@ "),1,0],0]]],
       caml_string_of_jsbytes("@[<2>(Seq@ ")],
     _bT_=[0,[12,32,[15,[12,41,[17,0,0]]]],caml_string_of_jsbytes(" %a)@]")],
     _bU_=
      [0,
       [11,
        caml_string_of_jsbytes("(Exp "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" ("),
          [15,[11,caml_string_of_jsbytes(") (eps))"),0]]]]],
       caml_string_of_jsbytes("(Exp %d (%a) (eps))")],
     _bV_=
      [0,
       [11,
        caml_string_of_jsbytes("(Exp "),
        [4,
         0,
         0,
         0,
         [11,
          caml_string_of_jsbytes(" ("),
          [15,[11,caml_string_of_jsbytes(") "),[15,[12,41,0]]]]]]],
       caml_string_of_jsbytes("(Exp %d (%a) %a)")],
     _bW_=
      [0,
       [18,
        [1,
         [0,
          [11,caml_string_of_jsbytes("<2>"),0],
          caml_string_of_jsbytes("<2>")]],
        [11,
         caml_string_of_jsbytes("(Match"),
         [17,[0,caml_string_of_jsbytes("@ "),1,0],[15,[12,41,[17,0,0]]]]]],
       caml_string_of_jsbytes("@[<2>(Match@ %a)@]")],
     _bX_=
      [0,[11,caml_string_of_jsbytes(" | "),0],caml_string_of_jsbytes(" | ")],
     _bY_=[0,[11,caml_string_of_jsbytes("()"),0],caml_string_of_jsbytes("()")],
     _bZ_=[0,0,0],
     _bR_=[1,0],
     _bQ_=
      [0,
       [12,32,[4,0,0,0,[12,45,[4,0,0,0,0]]]],
       caml_string_of_jsbytes(" %d-%d")],
     _bP_=[0,[4,0,0,0,[12,45,[4,0,0,0,0]]],caml_string_of_jsbytes("%d-%d")],
     _b4_=
      [0,
       [18,
        [1,[0,0,caml_string_of_jsbytes("")]],
        [12,
         40,
         [2,
          0,
          [11,
           caml_string_of_jsbytes(" ("),
           [4,
            0,
            0,
            0,
            [12,32,[4,0,0,0,[11,caml_string_of_jsbytes("))"),[17,0,0]]]]]]]]],
       caml_string_of_jsbytes("@[(%s (%d %d))@]")],
     _b6_=
      [0,
       [15,[17,[0,caml_string_of_jsbytes("@ "),1,0],[4,0,0,0,[15,0]]]],
       caml_string_of_jsbytes("%a@ %d%a")],
     _ca_=[0,caml_string_of_jsbytes("lib/core.ml"),690,4],
     _cx_=[0,caml_string_of_jsbytes("lib/core.ml"),1149,24],
     _cy_=[0,caml_string_of_jsbytes("lib/core.ml"),1160,27],
     _cc_=[0,1],
     _cb_=[0,caml_string_of_jsbytes("lib/core.ml"),723,13],
     _b$_=[0,caml_string_of_jsbytes("lib/core.ml"),493,35],
     _b5_=[0,0,0,0,0,0,0,0,0,0,0],
     _b__=[0,170,[0,181,[0,186,[0,223,[0,255,0]]]]],
     _cD_=[0,1],
     _cC_=[0,1],
     _cA_=[0,caml_string_of_jsbytes(""),0],
     _cB_=[0,caml_string_of_jsbytes(""),0],
     _cz_=[0,45],
     _cE_=[0,748194550,8],
     _cF_=[0,748194550,10],
     _cG_=[0,748194550,13],
     _cH_=[0,748194550,9],
     _cI_=[0,-1,-1];
    function equal(x,y){return x === y?1:0}
    var compare=caml_int_compare;
    function to_int(x){return x}
    var pp=include[17];
    function intersect(x,y){return 0 !== (x & y)?1:0}
    function symbol(x,y){return x | y}
    var
     dummy=-1,
     inexistant=1,
     letter=2,
     not_letter=4,
     newline=8,
     lastnewline=16,
     search_boundary=32;
    function from_char(param)
     {var switch$0=0;
      if(170 <= param)
       if(187 <= param)
        {var _jb_=param - 192 | 0;
         if(54 < _jb_ >>> 0)
          {if(56 <= _jb_)switch$0 = 1}
         else
          if(23 !== _jb_)switch$0 = 1}
       else
        {var _jc_=param - 171 | 0;
         if(14 < _jc_ >>> 0 || 10 === _jc_)switch$0 = 1}
      else
       if(65 <= param)
        {var _jd_=param - 91 | 0;
         if(5 < _jd_ >>> 0)
          {if(! (32 <= _jd_))switch$0 = 1}
         else
          if(4 === _jd_)switch$0 = 1}
       else
        if(48 <= param)
         {if(! (58 <= param))switch$0 = 1}
        else
         if(10 === param)return 12;
      return switch$0?letter:not_letter}
    var
     Re_Category=
      [0,
       symbol,
       from_char,
       dummy,
       inexistant,
       letter,
       not_letter,
       newline,
       lastnewline,
       search_boundary,
       to_int,
       equal,
       compare,
       intersect,
       pp];
    caml_register_global(136,Re_Category,"Re__Category");
    var
     _m_=include[13],
     _q_=include[17],
     _y_=include[25],
     _A_=include[27],
     _bf_=include[125],
     _a_=include[1],
     _b_=include[2],
     _c_=include[3],
     _d_=include[4],
     _e_=include[5],
     _f_=include[6],
     _g_=include[7],
     _h_=include[8],
     _i_=include[9],
     _j_=include[10],
     _k_=include[11],
     _l_=include[12],
     _n_=include[14],
     _o_=include[15],
     _p_=include[16],
     _r_=include[18],
     _s_=include[19],
     _t_=include[20],
     _u_=include[21],
     _v_=include[22],
     _w_=include[23],
     _x_=include[24],
     _z_=include[26],
     _B_=include[28],
     _C_=include[29],
     _D_=include[30],
     _E_=include[31],
     _F_=include[32],
     _G_=include[33],
     _H_=include[34],
     _I_=include[35],
     _J_=include[36],
     _K_=include[37],
     _L_=include[38],
     _M_=include[39],
     _N_=include[40],
     _O_=include[41],
     _P_=include[42],
     _Q_=include[43],
     _R_=include[44],
     _S_=include[45],
     _T_=include[46],
     _U_=include[47],
     _V_=include[48],
     _W_=include[49],
     _X_=include[50],
     _Y_=include[51],
     _Z_=include[52],
     ___=include[53],
     _$_=include[54],
     _aa_=include[55],
     _ab_=include[56],
     _ac_=include[57],
     _ad_=include[58],
     _ae_=include[59],
     _af_=include[60],
     _ag_=include[61],
     _ah_=include[62],
     _ai_=include[63],
     _aj_=include[64],
     _ak_=include[65],
     _al_=include[66],
     _am_=include[67],
     _an_=include[68],
     _ao_=include[69],
     _ap_=include[70],
     _aq_=include[71],
     _ar_=include[72],
     _as_=include[73],
     _at_=include[74],
     _au_=include[75],
     _av_=include[76],
     _aw_=include[77],
     _ax_=include[78],
     _ay_=include[79],
     _az_=include[80],
     _aA_=include[81],
     _aB_=include[82],
     _aC_=include[83],
     _aD_=include[84],
     _aE_=include[85],
     _aF_=include[86],
     _aG_=include[87],
     _aH_=include[88],
     _aI_=include[89],
     _aJ_=include[90],
     _aK_=include[91],
     _aL_=include[92],
     _aM_=include[93],
     _aN_=include[94],
     _aO_=include[95],
     _aP_=include[96],
     _aQ_=include[97],
     _aR_=include[98],
     _aS_=include[99],
     _aT_=include[100],
     _aU_=include[101],
     _aV_=include[102],
     _aW_=include[103],
     _aX_=include[104],
     _aY_=include[105],
     _aZ_=include[106],
     _a0_=include[107],
     _a1_=include[108],
     _a2_=include[109],
     _a3_=include[110],
     _a4_=include[111],
     _a5_=include[112],
     _a6_=include[113],
     _a7_=include[114],
     _a8_=include[115],
     _a9_=include[116],
     _a__=include[117],
     _a$_=include[118],
     _ba_=include[119],
     _bb_=include[120],
     _bc_=include[122],
     _bd_=include[123],
     _be_=include[124],
     _bg_=include[126],
     _bh_=include[127],
     _bi_=include[128],
     _bj_=include[129],
     _bk_=include[130],
     _bl_=include[131],
     _bm_=include[132],
     _bn_=include[133],
     _bo_=include[134],
     _bp_=include[135],
     _bq_=include[136],
     _br_=include[137],
     _bs_=include[138],
     _bt_=include[139],
     _bu_=include[140],
     _bv_=include[141],
     _bw_=include[142],
     _bx_=include[143],
     _by_=include[144],
     _bz_=include[145],
     _bA_=include[146],
     _bB_=include[147],
     _bC_=include[148],
     _bD_=include[149],
     _bE_=include[150];
    function pp_print_list(opt,pp,ppf,param)
     {var opt$0=opt,param$0=param;
      for(;;)
       {if(opt$0)var sth=opt$0[1],pp_sep=sth;else var pp_sep=_A_;
        if(param$0)
         {var _ja_=param$0[1];
          if(param$0[2])
           {var vs=param$0[2];
            caml_call2(pp,ppf,_ja_);
            caml_call2(pp_sep,ppf,0);
            var opt$1=[0,pp_sep],opt$0=opt$1,param$0=vs;
            continue}
          return caml_call2(pp,ppf,_ja_)}
        return 0}}
    function sexp(fmt,s,pp,x){return caml_call5(_bf_,fmt,_bF_,s,pp,x)}
    function pair(pp1,pp2,fmt,param)
     {var v2=param[2],v1=param[1];
      caml_call2(pp1,fmt,v1);
      caml_call2(_y_,fmt,0);
      return caml_call2(pp2,fmt,v2)}
    function triple(pp1,pp2,pp3,fmt,param)
     {var v3=param[3],v2=param[2],v1=param[1];
      caml_call2(pp1,fmt,v1);
      caml_call2(_y_,fmt,0);
      caml_call2(pp2,fmt,v2);
      caml_call2(_y_,fmt,0);
      return caml_call2(pp3,fmt,v3)}
    function optint(fmt,param)
     {if(param){var i=param[1];return caml_call3(_bf_,fmt,_bG_,i)}return 0}
    function quote(fmt,s){return caml_call3(include[125],fmt,_bH_,s)}
    function pp_olist(pp_elem,fmt)
     {var _i8_=[0,function(fmt,param){return caml_call2(_bf_,fmt,_bI_)}];
      function _i9_(_i__,_i$_){return pp_print_list(_i8_,pp_elem,_i__,_i$_)}
      return caml_call3(include[125],fmt,_bJ_,_i9_)}
    function pp_str_list(_i7_){return pp_olist(quote,_i7_)}
    function to_to_string(pp,x)
     {var b=caml_call1(Stdlib_buffer[1],16),fmt=caml_call1(include[109],b);
      caml_call2(pp,fmt,x);
      return caml_call1(Stdlib_buffer[2],b)}
    var
     Re_Fmt=
      [0,
       _a_,
       _b_,
       _c_,
       _d_,
       _e_,
       _f_,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       _m_,
       _n_,
       _o_,
       _p_,
       _q_,
       _r_,
       _s_,
       _t_,
       _u_,
       _v_,
       _w_,
       _x_,
       _y_,
       _z_,
       _A_,
       _B_,
       _C_,
       _D_,
       _E_,
       _F_,
       _G_,
       _H_,
       _I_,
       _J_,
       _K_,
       _L_,
       _M_,
       _N_,
       _O_,
       _P_,
       _Q_,
       _R_,
       _S_,
       _T_,
       _U_,
       _V_,
       _W_,
       _X_,
       _Y_,
       _Z_,
       ___,
       _$_,
       _aa_,
       _ab_,
       _ac_,
       _ad_,
       _ae_,
       _af_,
       _ag_,
       _ah_,
       _ai_,
       _aj_,
       _ak_,
       _al_,
       _am_,
       _an_,
       _ao_,
       _ap_,
       _aq_,
       _ar_,
       _as_,
       _at_,
       _au_,
       _av_,
       _aw_,
       _ax_,
       _ay_,
       _az_,
       _aA_,
       _aB_,
       _aC_,
       _aD_,
       _aE_,
       _aF_,
       _aG_,
       _aH_,
       _aI_,
       _aJ_,
       _aK_,
       _aL_,
       _aM_,
       _aN_,
       _aO_,
       _aP_,
       _aQ_,
       _aR_,
       _aS_,
       _aT_,
       _aU_,
       _aV_,
       _aW_,
       _aX_,
       _aY_,
       _aZ_,
       _a0_,
       _a1_,
       _a2_,
       _a3_,
       _a4_,
       _a5_,
       _a6_,
       _a7_,
       _a8_,
       _a9_,
       _a__,
       _a$_,
       _ba_,
       _bb_,
       _bc_,
       _bd_,
       _be_,
       _bf_,
       _bg_,
       _bh_,
       _bi_,
       _bj_,
       _bk_,
       _bl_,
       _bm_,
       _bn_,
       _bo_,
       _bp_,
       _bq_,
       _br_,
       _bs_,
       _bt_,
       _bu_,
       _bv_,
       _bw_,
       _bx_,
       _by_,
       _bz_,
       _bA_,
       _bB_,
       _bC_,
       _bD_,
       _bE_,
       pp_print_list,
       pp_print_list,
       _m_,
       sexp,
       pair,
       triple,
       _q_,
       optint,
       quote,
       pp_olist,
       pp_str_list,
       to_to_string];
    caml_register_global(138,Re_Fmt,"Re__Fmt");
    function union(l$0,l)
     {var l$2=l$0,l$1=l;
      for(;;)
       {if(l$1)
         {if(l$2)
           {var
             r=l$1[2],
             _i6_=l$1[1],
             c2=_i6_[2],
             c1=_i6_[1],
             r$0=l$2[2],
             match=l$2[1],
             c2$0=match[2],
             c1$0=match[1];
            if((c2$0 + 1 | 0) < c1)return [0,[0,c1$0,c2$0],union(r$0,l$1)];
            if((c2 + 1 | 0) < c1$0)return [0,[0,c1,c2],union(l$2,r)];
            if(c2$0 < c2)
             {var
               l$3=[0,[0,caml_call2(Stdlib[16],c1$0,c1),c2],r],
               l$2=r$0,
               l$1=l$3;
              continue}
            var
             l$4=[0,[0,caml_call2(Stdlib[16],c1$0,c1),c2$0],r$0],
             l$2=l$4,
             l$1=r;
            continue}
          return l$1}
        return l$2}}
    function inter(l$0,l)
     {var l$2=l$0,l$1=l;
      for(;;)
       {if(l$1)
         {if(l$2)
           {var
             r=l$1[2],
             _i3_=l$1[1],
             c2=_i3_[2],
             c1=_i3_[1],
             r$0=l$2[2],
             match=l$2[1],
             c2$0=match[2],
             c1$0=match[1];
            if(caml_lessthan(c2$0,c1)){var l$2=r$0;continue}
            if(caml_lessthan(c2,c1$0)){var l$1=r;continue}
            if(caml_lessthan(c2$0,c2))
             {var _i4_=inter(r$0,l$1);
              return [0,[0,caml_call2(Stdlib[17],c1$0,c1),c2$0],_i4_]}
            var _i5_=inter(l$2,r);
            return [0,[0,caml_call2(Stdlib[17],c1$0,c1),c2],_i5_]}
          return 0}
        return 0}}
    function diff(l$0,l)
     {var l$2=l$0,l$1=l;
      for(;;)
       {if(l$1)
         {if(l$2)
           {var
             r=l$1[2],
             _i2_=l$1[1],
             c2=_i2_[2],
             c1=_i2_[1],
             r$0=l$2[2],
             match=l$2[1],
             c2$0=match[2],
             c1$0=match[1];
            if(c2$0 < c1)return [0,[0,c1$0,c2$0],diff(r$0,l$1)];
            if(c2 < c1$0){var l$1=r;continue}
            var r$1=c2 < c2$0?[0,[0,c2 + 1 | 0,c2$0],r$0]:r$0;
            if(c1$0 < c1)return [0,[0,c1$0,c1 - 1 | 0],diff(r$1,r)];
            var l$2=r$1,l$1=r;
            continue}
          return 0}
        return l$2}}
    function single(c){return [0,[0,c,c],0]}
    function add(c,l){return union(single(c),l)}
    function seq(c$0,c)
     {return runtime.caml_lessequal(c$0,c)?[0,[0,c$0,c],0]:[0,[0,c,c$0],0]}
    function offset(o,l)
     {if(l)
       {var r=l[2],match=l[1],c2=match[2],c1=match[1];
        return [0,[0,c1 + o | 0,c2 + o | 0],offset(o,r)]}
      return 0}
    var empty=0;
    function mem(c,s)
     {var s$0=s;
      for(;;)
       {if(s$0)
         {var rem=s$0[2],match=s$0[1],c2=match[2],c1=match[1];
          if(c <= c2)return c1 <= c?1:0;
          var s$0=rem;
          continue}
        return 0}}
    function hash_rec(param)
     {if(param)
       {var r=param[2],match=param[1],j=match[2],i=match[1];
        return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0}
      return 0}
    function hash(l){return hash_rec(l) & 1073741823}
    function print_one(ch,param)
     {var c2=param[2],c1=param[1];
      return c1 === c2
              ?caml_call3(include[125],ch,_bK_,c1)
              :caml_call4(include[125],ch,_bL_,c1,c2)}
    var _bM_=0;
    function pp$0(_i0_,_i1_){return pp_print_list(_bM_,print_one,_i0_,_i1_)}
    function iter(t,f)
     {var t$0=t;
      for(;;)
       {if(t$0)
         {var xs=t$0[2],match=t$0[1],y=match[2],x=match[1];
          caml_call2(f,x,y);
          var t$0=xs;
          continue}
        return 0}}
    function one_char(param)
     {if(param && ! param[2])
       {var match=param[1],j=match[2],i=match[1];
        if(caml_equal(i,j))return [0,i]}
      return 0}
    function compare$0(param,_iZ_)
     {var v=_iZ_[2],j=_iZ_[1],u=param[2],i=param[1],c=caml_compare(i,j);
      return 0 === c?caml_compare(u,v):c}
    var CSetMap=caml_call1(Stdlib_map[1],[0,compare$0]);
    function fold_right(t,init,f){return caml_call3(Stdlib_list[24],f,t,init)}
    function csingle(c){return single(c)}
    function is_empty(param){return param?0:1}
    function prepend(s,x,l)
     {var s$0=s;
      for(;;)
       {if(s$0)
         {if(l)
           {var _iU_=l[1],_iV_=_iU_[1];
            if(_iV_ && ! _iV_[2])
             {var
               x$0=_iU_[2],
               _iW_=_iV_[1],
               d=_iW_[2],
               d$0=_iW_[1],
               r=s$0[2],
               match=s$0[1],
               c=match[2],
               c$0=match[1];
              if(c < d$0){var s$0=r;continue}
              var r$0=l[2];
              if(c$0 <= d$0)
               {if(c < d)
                 {var _iX_=prepend(r,x,[0,[0,[0,[0,c + 1 | 0,d],0],x$0],r$0]);
                  return [0,
                          [0,[0,[0,d$0,c],0],caml_call2(Stdlib[37],x,x$0)],
                          _iX_]}
                var _iY_=prepend(s$0,x,r$0);
                return [0,
                        [0,[0,[0,d$0,d],0],caml_call2(Stdlib[37],x,x$0)],
                        _iY_]}
              return d < c$0
                      ?[0,[0,[0,[0,d$0,d],0],x$0],prepend(s$0,x,r$0)]
                      :[0,
                        [0,[0,[0,d$0,c$0 - 1 | 0],0],x$0],
                        prepend(s$0,x,[0,[0,[0,[0,c$0,d],0],x$0],r$0])]}
            throw [0,Assert_failure,_bN_]}
          return 0}
        return l}}
    function pick(param)
     {if(param){var match=param[1],x=match[1];return x}
      return caml_call1(Stdlib[1],cst_Re_cset_pick)}
    var
     Re_Cset=
      [0,
       iter,
       union,
       inter,
       diff,
       offset,
       empty,
       single,
       seq,
       add,
       mem,
       hash,
       pp$0,
       one_char,
       fold_right,
       hash_rec,
       CSetMap,
       cany,
       csingle,
       is_empty,
       prepend,
       pick];
    caml_register_global(143,Re_Cset,"Re__Cset");
    function equal$0(x,y){return x === y?1:0}
    var compare$1=caml_int_compare,r=[0,0];
    function gen(param){r[1]++;return r[1]}
    var
     pp$1=include[17],
     Set=caml_call1(Stdlib_set[1],[0,compare$1]),
     Re_Pmark=[0,equal$0,compare$1,gen,pp$1,Set];
    caml_register_global(145,Re_Pmark,"Re__Pmark");
    function hash_combine(h,accu){return (accu * 65599 | 0) + h | 0}
    var empty$0=[0,0,Set[1]];
    function merge_marks_offset(old,param)
     {if(param)
       {var
         rem=param[2],
         match=param[1],
         v=match[2],
         i=match[1],
         nw=merge_marks_offset(caml_call2(Stdlib_list[50],i,old),rem);
        return -2 === v?nw:[0,[0,i,v],nw]}
      return old}
    function merge(old,nw)
     {var _iT_=caml_call2(Set[7],old[2],nw[2]);
      return [0,merge_marks_offset(old[1],nw[1]),_iT_]}
    function hash$0(m,accu$1)
     {var
       accu$2=hash_combine(caml_call1(Stdlib_hashtbl[27],m[2]),accu$1),
       l=m[1],
       accu=accu$2;
      for(;;)
       {if(l)
         {var
           r=l[2],
           match=l[1],
           i=match[2],
           a=match[1],
           accu$0=hash_combine(a,hash_combine(i,accu)),
           l=r,
           accu=accu$0;
          continue}
        return accu}}
    function _bO_(idx,marks)
     {if(marks)
       {var _iS_=marks[1];
        if(-1 === _iS_[2])
         {var rem=marks[2],a=_iS_[1];return [0,[0,a,idx],_bO_(idx,rem)]}}
      return marks}
    function marks_set_idx(marks,idx)
     {var _iR_=marks[2];return [0,_bO_(idx,marks[1]),_iR_]}
    function pp_marks(ch,t)
     {var _iP_=t[1];
      if(_iP_)
       {var r=_iP_[2],match=_iP_[1],i=match[2],a=match[1];
        caml_call4(include[125],ch,_bP_,a,i);
        var
         _iQ_=
          function(param)
           {var i=param[2],a=param[1];
            return caml_call4(include[125],ch,_bQ_,a,i)};
        return caml_call2(Stdlib_list[15],_iQ_,r)}
      return 0}
    function pp_sem(ch,k)
     {var _iO_=-730718166 === k?cst_long:332064784 <= k?cst_first:cst_short;
      return caml_call2(include[13],ch,_iO_)}
    function pp_rep_kind(fmt,param)
     {return 620821490 <= param
              ?caml_call2(include[13],fmt,cst_Non_greedy)
              :caml_call2(include[13],fmt,cst_Greedy)}
    function pp$2(ch,e)
     {var _iB_=e[2];
      if(typeof _iB_ === "number")
       return caml_call2(_m_,ch,cst_eps);
      else
       switch(_iB_[0])
        {case 0:var l=_iB_[1];return sexp(ch,cst_cst,pp$0,l);
         case 1:
          var l$0=_iB_[1],_iC_=0;
          return sexp
                  (ch,
                   cst_alt,
                   function(_iM_,_iN_)
                    {return pp_print_list(_iC_,pp$2,_iM_,_iN_)},
                   l$0);
         case 2:
          var e$0=_iB_[3],e$1=_iB_[2],k=_iB_[1],_iD_=[0,k,e$1,e$0];
          return sexp
                  (ch,
                   cst_seq,
                   function(_iK_,_iL_)
                    {return triple(pp_sem,pp$2,pp$2,_iK_,_iL_)},
                   _iD_);
         case 3:
          var e$2=_iB_[3],k$0=_iB_[2],_iE_=[0,k$0,e$2];
          return sexp
                  (ch,
                   cst_rep,
                   function(_iI_,_iJ_){return pair(pp_sem,pp$2,_iI_,_iJ_)},
                   _iE_);
         case 4:var i=_iB_[1];return sexp(ch,cst_mark,_q_,i);
         case 5:
          var e$3=_iB_[2],b=_iB_[1],_iF_=[0,b,e$3];
          return sexp
                  (ch,
                   cst_erase,
                   function(_iG_,_iH_){return pair(_q_,_q_,_iG_,_iH_)},
                   _iF_);
         case 6:var c=_iB_[1];return sexp(ch,cst_before,pp,c);
         case 7:var c$0=_iB_[1];return sexp(ch,cst_after,pp,c$0);
         default:var i$0=_iB_[1];return sexp(ch,cst_pmark,_q_,i$0)}}
    function first(f,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var r=param$0[2],x=param$0[1],res=caml_call1(f,x);
          if(res)return res;
          var param$0=r;
          continue}
        return 0}}
    function create_ids(param){return [0,0]}
    function mk_expr(ids,def){ids[1]++;return [0,ids[1],def]}
    function empty$1(ids){return mk_expr(ids,_bR_)}
    function cst(ids,s){return is_empty(s)?empty$1(ids):mk_expr(ids,[0,s])}
    function alt(ids,l)
     {if(l){if(l[2])return mk_expr(ids,[1,l]);var c=l[1];return c}
      return empty$1(ids)}
    function seq$0(ids,kind,x,y)
     {var _iz_=x[2],_iA_=y[2];
      if(typeof _iz_ !== "number" && 1 === _iz_[0] && ! _iz_[1])return x;
      if(typeof _iA_ !== "number" && 1 === _iA_[0] && ! _iA_[1])return y;
      if(typeof _iz_ === "number")return y;
      if(typeof _iA_ === "number" && 332064784 === kind)return x;
      return mk_expr(ids,[2,kind,x,y])}
    function is_eps(expr){return typeof expr[2] === "number"?1:0}
    function eps(ids){return mk_expr(ids,0)}
    function rep(ids,kind,sem,x){return mk_expr(ids,[3,kind,sem,x])}
    function mark(ids,m){return mk_expr(ids,[4,m])}
    function pmark(ids,i){return mk_expr(ids,[8,i])}
    function erase(ids,m$0,m){return mk_expr(ids,[5,m$0,m])}
    function before(ids,c){return mk_expr(ids,[6,c])}
    function after(ids,c){return mk_expr(ids,[7,c])}
    function rename(ids,x)
     {var _iv_=x[2];
      if(typeof _iv_ !== "number")
       switch(_iv_[0])
        {case 1:
          var l=_iv_[1],_iw_=function(_iy_){return rename(ids,_iy_)};
          return mk_expr(ids,[1,caml_call2(Stdlib_list[17],_iw_,l)]);
         case 2:
          var z=_iv_[3],y=_iv_[2],k=_iv_[1],_ix_=rename(ids,z);
          return mk_expr(ids,[2,k,rename(ids,y),_ix_]);
         case 3:
          var y$0=_iv_[3],k$0=_iv_[2],g=_iv_[1];
          return mk_expr(ids,[3,g,k$0,rename(ids,y$0)])
         }
      return mk_expr(ids,x[2])}
    function equal$1(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {var _ic_=l1$0[1];
          switch(_ic_[0])
           {case 0:
             if(l2$0)
              {var _id_=l2$0[1],_ie_=l1$0[2],_if_=_ic_[2],_ig_=_ic_[1];
               if(0 === _id_[0])
                {var
                  r2=l2$0[2],
                  e2=_id_[2],
                  l2$1=_id_[1],
                  _ih_=_if_[1] === e2[1]?1:0;
                 if(_ih_)
                  {var _ii_=equal$1(_ig_,l2$1);
                   if(_ii_){var l1$0=_ie_,l2$0=r2;continue}
                   var _ij_=_ii_}
                 else
                  var _ij_=_ih_;
                 return _ij_}}
             break;
            case 1:
             if(l2$0)
              {var _ik_=l2$0[1],_il_=l1$0[2],_im_=_ic_[2],_in_=_ic_[1];
               if(1 === _ik_[0])
                {var
                  r2$0=l2$0[2],
                  e2$0=_ik_[2],
                  marks2=_ik_[1],
                  _io_=_im_[1] === e2$0[1]?1:0;
                 if(_io_)
                  {var _ip_=caml_equal(_in_,marks2);
                   if(_ip_){var l1$0=_il_,l2$0=r2$0;continue}
                   var _iq_=_ip_}
                 else
                  var _iq_=_io_;
                 return _iq_}}
             break;
            default:
             if(l2$0)
              {var _ir_=l2$0[1],_is_=l1$0[2],_it_=_ic_[1];
               if(2 === _ir_[0])
                {var
                  r2$1=l2$0[2],
                  marks2$0=_ir_[1],
                  _iu_=caml_equal(_it_,marks2$0);
                 if(_iu_){var l1$0=_is_,l2$0=r2$1;continue}
                 return _iu_}}}}
        else
         if(! l2$0)return 1;
        return 0}}
    function hash$1(l,accu)
     {var l$0=l,accu$0=accu;
      for(;;)
       {if(l$0)
         {var _h$_=l$0[1];
          switch(_h$_[0])
           {case 0:
             var
              r=l$0[2],
              e=_h$_[2],
              l$1=_h$_[1],
              _ia_=hash$1(l$1,accu$0),
              accu$1=hash_combine(388635598,hash_combine(e[1],_ia_)),
              l$0=r,
              accu$0=accu$1;
             continue;
            case 1:
             var
              r$0=l$0[2],
              e$0=_h$_[2],
              marks=_h$_[1],
              _ib_=hash$0(marks,accu$0),
              accu$2=hash_combine(726404471,hash_combine(e$0[1],_ib_)),
              l$0=r$0,
              accu$0=accu$2;
             continue;
            default:
             var
              r$1=l$0[2],
              marks$0=_h$_[1],
              accu$3=hash_combine(471882453,hash$0(marks$0,accu$0)),
              l$0=r$1,
              accu$0=accu$3;
             continue}}
        return accu$0}}
    function tseq(kind,x,y,rem)
     {if(x)
       {var _h__=x[1];
        if(1 === _h__[0] && typeof _h__[2][2] === "number" && ! x[2])
         {var marks=_h__[1];return [0,[1,marks,y],rem]}
        return [0,[0,x,y,kind],rem]}
      return rem}
    function print_state_lst(ch,l,y)
     {if(l)
       {var rem=l[2],e=l[1];
        print_state_rec(ch,e,y);
        var
         _h9_=
          function(e)
           {caml_call2(include[125],ch,_bX_);return print_state_rec(ch,e,y)};
        return caml_call2(Stdlib_list[15],_h9_,rem)}
      return caml_call2(include[125],ch,_bY_)}
    function print_state_rec(ch,e,y)
     {switch(e[0])
       {case 0:
         var x=e[2],l=e[1];
         caml_call2(include[125],ch,_bS_);
         print_state_lst(ch,l,x);
         return caml_call4(include[125],ch,_bT_,pp$2,x);
        case 1:
         var _h8_=e[1];
         if(typeof e[2][2] === "number")
          return caml_call5(include[125],ch,_bU_,y[1],pp_marks,_h8_);
         var x$0=e[2];
         return caml_call7(include[125],ch,_bV_,x$0[1],pp_marks,_h8_,pp$2,x$0);
        default:
         var marks=e[1];return caml_call4(include[125],ch,_bW_,pp_marks,marks)}}
    function pp$3(ch,t){return print_state_lst(ch,[0,t,0],_bZ_)}
    var dummy$0=[0,-1,dummy,0,0,-1];
    function mk(idx,cat,desc)
     {return [0,
              idx,
              cat,
              desc,
              0,
              hash$1(desc,hash_combine(idx,hash_combine(cat,0))) & 1073741823]}
    function create(cat,e){return mk(0,cat,[0,[1,empty$0,e],0])}
    function equal$2(x,y)
     {var _h4_=x[5] === y[5]?1:0;
      if(_h4_)
       {var _h5_=x[1] === y[1]?1:0;
        if(_h5_)
         {var _h6_=x[2] === y[2]?1:0;
          if(_h6_)return equal$1(x[3],y[3]);
          var _h7_=_h6_}
        else
         var _h7_=_h5_}
      else
       var _h7_=_h4_;
      return _h7_}
    function hash$2(t){return t[5]}
    var Table=caml_call1(Stdlib_hashtbl[25],[0,equal$2,hash$2]);
    function create_working_area(param){return [0,[0,0]]}
    function index_count(w){return w[1].length - 1}
    function mark_used_indices(tbl)
     {function _hZ_(param)
       {if(0 === param[0])
         {var l=param[1];return caml_call1(mark_used_indices(tbl),l)}
        var marks=param[1],_h0_=marks[1];
        function _h1_(param)
         {var
           i=param[2],
           _h2_=0 <= i?1:0,
           _h3_=_h2_?(caml_check_bound(tbl,i)[1 + i] = 1,0):_h2_;
          return _h3_}
        return caml_call2(Stdlib_list[15],_h1_,_h0_)}
      return caml_call1(Stdlib_list[15],_hZ_)}
    function free_index(tbl_ref,l)
     {var tbl=tbl_ref[1];
      caml_call4(Stdlib_array[9],tbl,0,tbl.length - 1,0);
      caml_call1(mark_used_indices(tbl),l);
      var len=tbl.length - 1,idx=0;
      for(;;)
       {if(idx !== len && caml_check_bound(tbl,idx)[1 + idx])
         {var idx$0=idx + 1 | 0,idx=idx$0;continue}
        if(idx === len)tbl_ref[1] = caml_make_vect(2 * len | 0,0);
        return idx}}
    function _b0_(param){return 2 === param[0]?0:1}
    var remove_matches=caml_call1(Stdlib_list[39],_b0_);
    function split_at_match(l$1)
     {var l=0,param=l$1;
      for(;;)
       {if(param)
         {var _hX_=param[1];
          if(2 === _hX_[0])
           {var r=param[2],_hY_=caml_call1(remove_matches,r);
            return [0,caml_call1(Stdlib_list[9],l),_hY_]}
          var param$0=param[2],l$0=[0,_hX_,l],l=l$0,param=param$0;
          continue}
        throw [0,Assert_failure,_b1_]}}
    function remove_duplicates(prev,l,y)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _hW_=l$0[1];
          switch(_hW_[0])
           {case 0:
             var
              r=l$0[2],
              kind=_hW_[3],
              x=_hW_[2],
              l$1=_hW_[1],
              match=remove_duplicates(prev,l$1,x),
              prev$0=match[2],
              l$2=match[1],
              match$0=remove_duplicates(prev$0,r,y),
              prev$1=match$0[2],
              r$0=match$0[1];
             return [0,tseq(kind,l$2,x,r$0),prev$1];
            case 1:
             if(typeof _hW_[2][2] === "number")
              {var r$1=l$0[2];
               if(caml_call2(Stdlib_list[35],y[1],prev)){var l$0=r$1;continue}
               var
                match$1=remove_duplicates([0,y[1],prev],r$1,y),
                prev$2=match$1[2],
                r$2=match$1[1];
               return [0,[0,_hW_,r$2],prev$2]}
             var r$3=l$0[2],x$0=_hW_[2];
             if(caml_call2(Stdlib_list[35],x$0[1],prev)){var l$0=r$3;continue}
             var
              match$2=remove_duplicates([0,x$0[1],prev],r$3,y),
              prev$3=match$2[2],
              r$4=match$2[1];
             return [0,[0,_hW_,r$4],prev$3];
            default:return [0,[0,_hW_,0],prev]}}
        return [0,0,prev]}}
    function set_idx(idx,param)
     {if(param)
       {var _hS_=param[1];
        switch(_hS_[0])
         {case 0:
           var
            r=param[2],
            kind=_hS_[3],
            x=_hS_[2],
            l=_hS_[1],
            _hT_=set_idx(idx,r);
           return [0,[0,set_idx(idx,l),x,kind],_hT_];
          case 1:
           var r$0=param[2],x$0=_hS_[2],marks=_hS_[1],_hU_=set_idx(idx,r$0);
           return [0,[1,marks_set_idx(marks,idx),x$0],_hU_];
          default:
           var r$1=param[2],marks$0=_hS_[1],_hV_=set_idx(idx,r$1);
           return [0,[2,marks_set_idx(marks$0,idx)],_hV_]}}
      return 0}
    function filter_marks(b,e,marks)
     {var _hN_=marks[2],_hO_=marks[1];
      function _hP_(param)
       {var i=param[1],_hQ_=i < b?1:0,_hR_=_hQ_ || (e < i?1:0);return _hR_}
      return [0,caml_call2(Stdlib_list[39],_hP_,_hO_),_hN_]}
    function delta_1$0(counter,init,c,next_cat,prev_cat,x,rem)
     {var _hK_=x[2];
      if(typeof _hK_ === "number")
       return [0,[2,init],rem];
      else
       switch(_hK_[0])
        {case 0:var s=_hK_[1];return mem(c,s)?[0,[1,init,eps_expr],rem]:rem;
         case 1:
          var l=_hK_[1];
          if(counter < 50)
           {var counter$1=counter + 1 | 0;
            return delta_2$0(counter$1,init,c,next_cat,prev_cat,l,rem)}
          return caml_trampoline_return
                  (delta_2$0,[0,init,c,next_cat,prev_cat,l,rem]);
         case 2:
          var
           z=_hK_[3],
           y=_hK_[2],
           kind=_hK_[1],
           y$0=delta_1(init,c,next_cat,prev_cat,y,0);
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return delta_seq$0(counter$0,c,next_cat,prev_cat,kind,y$0,z,rem)}
          return caml_trampoline_return
                  (delta_seq$0,[0,c,next_cat,prev_cat,kind,y$0,z,rem]);
         case 3:
          var
           y$1=_hK_[3],
           kind$0=_hK_[2],
           rep_kind=_hK_[1],
           y$2=delta_1(init,c,next_cat,prev_cat,y$1,0),
           match=
            first
             (function(param)
               {if(2 === param[0]){var marks=param[1];return [0,marks]}
                return 0},
              y$2);
          if(match)
           var
            marks=match[1],
            marks$0=marks,
            y$3=caml_call1(remove_matches,y$2);
          else
           var marks$0=init,y$3=y$2;
          return 620821490 <= rep_kind
                  ?[0,[2,init],tseq(kind$0,y$3,x,rem)]
                  :tseq(kind$0,y$3,x,[0,[2,marks$0],rem]);
         case 4:
          var
           i=_hK_[1],
           _hL_=init[2],
           marks$1=[0,[0,[0,i,-1],caml_call2(Stdlib_list[50],i,init[1])],_hL_];
          return [0,[2,marks$1],rem];
         case 5:
          var e=_hK_[2],b=_hK_[1];return [0,[2,filter_marks(b,e,init)],rem];
         case 6:
          var cat=_hK_[1];return intersect(next_cat,cat)?[0,[2,init],rem]:rem;
         case 7:
          var cat$0=_hK_[1];
          return intersect(prev_cat,cat$0)?[0,[2,init],rem]:rem;
         default:
          var
           i$0=_hK_[1],
           _hM_=caml_call2(Set[4],i$0,init[2]),
           marks$2=[0,init[1],_hM_];
          return [0,[2,marks$2],rem]}}
    function delta_2$0(counter,marks,c,next_cat,prev_cat,l,rem)
     {if(l)
       {var r=l[2],y=l[1],_hJ_=delta_2(marks,c,next_cat,prev_cat,r,rem);
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return delta_1$0(counter$0,marks,c,next_cat,prev_cat,y,_hJ_)}
        return caml_trampoline_return
                (delta_1$0,[0,marks,c,next_cat,prev_cat,y,_hJ_])}
      return rem}
    function delta_seq$0(counter,c,next_cat,prev_cat,kind,y,z,rem)
     {var
       match=
        first
         (function(param)
           {if(2 === param[0]){var marks=param[1];return [0,marks]}return 0},
          y);
      if(match)
       {var marks=match[1];
        if(-730718166 === kind)
         {var _hH_=delta_1(marks,c,next_cat,prev_cat,z,rem);
          return tseq(kind,caml_call1(remove_matches,y),z,_hH_)}
        if(332064784 <= kind)
         {var match$0=split_at_match(y),y$0=match$0[2],y$1=match$0[1];
          return tseq
                  (kind,
                   y$1,
                   z,
                   delta_1(marks,c,next_cat,prev_cat,z,tseq(kind,y$0,z,rem)))}
        var _hI_=tseq(kind,caml_call1(remove_matches,y),z,rem);
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return delta_1$0(counter$0,marks,c,next_cat,prev_cat,z,_hI_)}
        return caml_trampoline_return
                (delta_1$0,[0,marks,c,next_cat,prev_cat,z,_hI_])}
      return tseq(kind,y,z,rem)}
    function delta_1(init,c,next_cat,prev_cat,x,rem)
     {return caml_trampoline(delta_1$0(0,init,c,next_cat,prev_cat,x,rem))}
    function delta_2(marks,c,next_cat,prev_cat,l,rem)
     {return caml_trampoline(delta_2$0(0,marks,c,next_cat,prev_cat,l,rem))}
    function delta_seq(c,next_cat,prev_cat,kind,y,z,rem)
     {return caml_trampoline(delta_seq$0(0,c,next_cat,prev_cat,kind,y,z,rem))}
    function delta_4(c,next_cat,prev_cat,l,rem)
     {if(l)
       {var r=l[2],y$1=l[1],rem$0=delta_4(c,next_cat,prev_cat,r,rem);
        switch(y$1[0])
         {case 0:
           var
            kind=y$1[3],
            z=y$1[2],
            y=y$1[1],
            y$0=delta_4(c,next_cat,prev_cat,y,0);
           return delta_seq(c,next_cat,prev_cat,kind,y$0,z,rem$0);
          case 1:
           var e=y$1[2],marks=y$1[1];
           return delta_1(marks,c,next_cat,prev_cat,e,rem$0);
          default:return [0,y$1,rem$0]}}
      return rem}
    function delta(tbl_ref,next_cat,char$0,st)
     {var
       prev_cat=st[2],
       match=
        remove_duplicates
         (0,delta_4(char$0,next_cat,prev_cat,st[3],0),eps_expr),
       expr=match[1],
       idx=free_index(tbl_ref,expr),
       expr$0=set_idx(idx,expr);
      return mk(idx,next_cat,expr$0)}
    function red_tr(l)
     {var l$0=l;
      for(;;)
       {if(l$0)
         {var _hG_=l$0[2];
          if(_hG_)
           {var
             rem=_hG_[2],
             tr2=_hG_[1],
             st2=tr2[2],
             s2=tr2[1],
             tr1=l$0[1],
             st1=tr1[2],
             s1=tr1[1];
            if(equal$2(st1,st2))
             {var l$1=[0,[0,union(s1,s2),st1],rem],l$0=l$1;continue}
            return [0,tr1,red_tr([0,tr2,rem])]}}
        return l$0}}
    function _b2_(param,l){var x=param[2],s=param[1];return prepend(s,x,l)}
    var prepend_deriv=caml_call1(Stdlib_list[24],_b2_);
    function restrict(s,param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var
           rem=param$0[2],
           match=param$0[1],
           x=match[2],
           s$0=match[1],
           s$1=inter(s,s$0);
          if(is_empty(s$1)){var param$0=rem;continue}
          return [0,[0,s$1,x],restrict(s,rem)]}
        return 0}}
    function prepend_marks_expr_lst(m,l)
     {function _hF_(param)
       {switch(param[0])
         {case 0:
           var s=param[3],e=param[2],l=param[1];
           return [0,prepend_marks_expr_lst(m,l),e,s];
          case 1:var e$0=param[2],m$0=param[1];return [1,merge(m,m$0),e$0];
          default:var m$1=param[1];return [2,merge(m,m$1)]}}
      return caml_call2(Stdlib_list[17],_hF_,l)}
    function deriv_seq(all_chars,categories,cat,kind,y,z,rem)
     {function _hw_(param)
       {var xl=param[2];
        function _hE_(param){return 2 === param[0]?1:0}
        return caml_call2(Stdlib_list[31],_hE_,xl)}
      if(caml_call2(Stdlib_list[31],_hw_,y))
       {var
         z$0=deriv_1(all_chars,categories,empty$0,cat,z,[0,[0,all_chars,0],0]),
         _hx_=
          function(param,rem)
           {var
             y=param[2],
             s=param[1],
             match=
              first
               (function(param)
                 {if(2 === param[0]){var marks=param[1];return [0,marks]}
                  return 0},
                y);
            if(match)
             {var
               marks=match[1],
               _hz_=
                function(param)
                 {var x=param[2],s=param[1];
                  return [0,s,prepend_marks_expr_lst(marks,x)]},
               z$1=caml_call1(caml_call1(Stdlib_list[17],_hz_),z$0);
              if(-730718166 === kind)
               {var _hA_=caml_call2(prepend_deriv,restrict(s,z$1),rem);
                return prepend
                        (s,tseq(kind,caml_call1(remove_matches,y),z,0),_hA_)}
              if(332064784 <= kind)
               {var
                 match$0=split_at_match(y),
                 y$0=match$0[2],
                 y$1=match$0[1],
                 _hB_=prepend(s,tseq(kind,y$0,z,0),rem),
                 _hC_=caml_call2(prepend_deriv,restrict(s,z$1),_hB_);
                return prepend(s,tseq(kind,y$1,z,0),_hC_)}
              var
               _hD_=
                prepend(s,tseq(kind,caml_call1(remove_matches,y),z,0),rem);
              return caml_call2(prepend_deriv,restrict(s,z$1),_hD_)}
            return prepend(s,tseq(kind,y,z,0),rem)};
        return caml_call3(Stdlib_list[24],_hx_,y,rem)}
      function _hy_(param,rem)
       {var xl=param[2],s=param[1];return prepend(s,tseq(kind,xl,z,0),rem)}
      return caml_call3(Stdlib_list[24],_hy_,y,rem)}
    function deriv_1$0(counter,all_chars,categories,marks,cat,x,rem$1)
     {var _hq_=x[2];
      if(typeof _hq_ === "number")
       return prepend(all_chars,[0,[2,marks],0],rem$1);
      else
       switch(_hq_[0])
        {case 0:
          var s=_hq_[1];return prepend(s,[0,[1,marks,eps_expr],0],rem$1);
         case 1:
          var l=_hq_[1];
          if(counter < 50)
           {var counter$0=counter + 1 | 0;
            return deriv_2$0(counter$0,all_chars,categories,marks,cat,l,rem$1)}
          return caml_trampoline_return
                  (deriv_2$0,[0,all_chars,categories,marks,cat,l,rem$1]);
         case 2:
          var
           z=_hq_[3],
           y=_hq_[2],
           kind=_hq_[1],
           y$0=deriv_1(all_chars,categories,marks,cat,y,[0,[0,all_chars,0],0]);
          return deriv_seq(all_chars,categories,cat,kind,y$0,z,rem$1);
         case 3:
          var
           y$1=_hq_[3],
           kind$0=_hq_[2],
           rep_kind=_hq_[1],
           y$2=
            deriv_1(all_chars,categories,marks,cat,y$1,[0,[0,all_chars,0],0]),
           _hr_=
            function(param,rem)
             {var
               z=param[2],
               s=param[1],
               match=
                first
                 (function(param)
                   {if(2 === param[0]){var marks=param[1];return [0,marks]}
                    return 0},
                  z);
              if(match)
               var
                marks$0=match[1],
                marks$1=marks$0,
                z$0=caml_call1(remove_matches,z);
              else
               var marks$1=marks,z$0=z;
              var
               _hv_=
                620821490 <= rep_kind
                 ?[0,[2,marks],tseq(kind$0,z$0,x,0)]
                 :tseq(kind$0,z$0,x,[0,[2,marks$1],0]);
              return prepend(s,_hv_,rem)};
          return caml_call3(Stdlib_list[24],_hr_,y$2,rem$1);
         case 4:
          var i=_hq_[1],_hs_=marks[2];
          return prepend
                  (all_chars,
                   [0,
                    [2,
                     [0,[0,[0,i,-1],caml_call2(Stdlib_list[50],i,marks[1])],_hs_]],
                    0],
                   rem$1);
         case 5:
          var
           e$1=_hq_[2],
           b=_hq_[1],
           _hu_=marks[2],
           e=e$1,
           rem=filter_marks(b,e$1,marks)[1],
           _ht_=0;
          for(;;)
           {if(e < b)
             return prepend(all_chars,[0,[2,[0,rem,_hu_]],_ht_],rem$1);
            var rem$0=[0,[0,e,-2],rem],e$0=e - 1 | 0,e=e$0,rem=rem$0;
            continue}
         case 6:
          var cat$0=_hq_[1];
          return prepend
                  (caml_call2(Stdlib_list[45],cat$0,categories),
                   [0,[2,marks],0],
                   rem$1);
         case 7:
          var cat$1=_hq_[1];
          return intersect(cat,cat$1)
                  ?prepend(all_chars,[0,[2,marks],0],rem$1)
                  :rem$1;
         default:return prepend(all_chars,[0,[2,marks],0],rem$1)}}
    function deriv_2$0(counter,all_chars,categories,marks,cat,l,rem)
     {if(l)
       {var r=l[2],y=l[1],_hp_=deriv_2(all_chars,categories,marks,cat,r,rem);
        if(counter < 50)
         {var counter$0=counter + 1 | 0;
          return deriv_1$0(counter$0,all_chars,categories,marks,cat,y,_hp_)}
        return caml_trampoline_return
                (deriv_1$0,[0,all_chars,categories,marks,cat,y,_hp_])}
      return rem}
    function deriv_1(all_chars,categories,marks,cat,x,rem)
     {return caml_trampoline
              (deriv_1$0(0,all_chars,categories,marks,cat,x,rem))}
    function deriv_2(all_chars,categories,marks,cat,l,rem)
     {return caml_trampoline
              (deriv_2$0(0,all_chars,categories,marks,cat,l,rem))}
    function deriv_4(all_chars,categories,cat,l,rem)
     {if(l)
       {var r=l[2],y$1=l[1],rem$0=deriv_4(all_chars,categories,cat,r,rem);
        switch(y$1[0])
         {case 0:
           var
            kind=y$1[3],
            z=y$1[2],
            y=y$1[1],
            y$0=deriv_4(all_chars,categories,cat,y,[0,[0,all_chars,0],0]);
           return deriv_seq(all_chars,categories,cat,kind,y$0,z,rem$0);
          case 1:
           var e=y$1[2],marks=y$1[1];
           return deriv_1(all_chars,categories,marks,cat,e,rem$0);
          default:return prepend(all_chars,[0,y$1,0],rem$0)}}
      return rem}
    function deriv(tbl_ref,all_chars,categories,st)
     {var
       der=deriv_4(all_chars,categories,st[2],st[3],[0,[0,all_chars,0],0]),
       _hk_=0;
      function _hl_(param,rem)
       {var
         expr=param[2],
         s=param[1],
         match=remove_duplicates(0,expr,eps_expr),
         expr$0=match[1],
         idx=free_index(tbl_ref,expr$0),
         expr$1=set_idx(idx,expr$0);
        function _ho_(param,rem)
         {var s$0=param[2],cat=param[1],s$1=inter(s,s$0);
          return is_empty(s$1)?rem:[0,[0,s$1,mk(idx,cat,expr$1)],rem]}
        return caml_call3(Stdlib_list[24],_ho_,categories,rem)}
      var l=caml_call3(Stdlib_list[24],_hl_,der,_hk_);
      function _hh_(param,_hn_)
       {var st2=_hn_[2],st1=param[2],c=caml_int_compare(st1[5],st2[5]);
        if(0 === c)
         {var c$0=caml_int_compare(st1[2],st2[2]);
          return 0 === c$0?caml_compare(st1[3],st2[3]):c$0}
        return c}
      var _hi_=red_tr(caml_call2(Stdlib_list[53],_hh_,l));
      function _hj_(param,_hm_)
       {var s2=_hm_[1],s1=param[1];return caml_compare(s1,s2)}
      return caml_call2(Stdlib_list[53],_hj_,_hi_)}
    function status(s)
     {var _hc_=s[4];
      if(_hc_){var st=_hc_[1];return st}
      var _hd_=s[3];
      if(_hd_)
       {var _he_=_hd_[1];
        if(2 === _he_[0])
         {var
           m=_he_[1],
           _hg_=m[1],
           _hf_=m[2],
           _g$_=-1,
           _ha_=
            function(ma,param)
             {var i=param[1];return caml_call2(Stdlib[17],ma,i)},
           ma=caml_call3(Stdlib_list[23],_ha_,_g$_,_hg_),
           res=caml_make_vect(ma + 1 | 0,-1),
           _hb_=
            function(param)
             {var v=param[2],i=param[1];
              caml_check_bound(res,i)[1 + i] = v;
              return 0};
          caml_call2(Stdlib_list[15],_hb_,_hg_);
          var st$0=[0,res,_hf_]}
        else
         var st$0=1}
      else
       var st$0=0;
      s[4] = [0,st$0];
      return st$0}
    var
     _b3_=[0,dummy$0,create,Table],
     Re_Automata=
      [0,
       pp_sem,
       pp_rep_kind,
       is_eps,
       pp$2,
       create_ids,
       cst,
       empty$1,
       alt,
       seq$0,
       eps,
       rep,
       mark,
       pmark,
       erase,
       before,
       after,
       rename,
       [0],
       [0,pp$3],
       _b3_,
       create_working_area,
       index_count,
       delta,
       deriv,
       status];
    caml_register_global(148,Re_Automata,"Re__Automata");
    function make(param){return caml_call2(Stdlib_bytes[1],257,0)}
    function flatten(cm)
     {var c=caml_create_bytes(256),color_repr=caml_create_bytes(256),v=[0,0];
      caml_bytes_set(c,0,0);
      caml_bytes_set(color_repr,0,0);
      var i=1;
      for(;;)
       {if(0 !== caml_bytes_get(cm,i))v[1]++;
        caml_bytes_set(c,i,caml_call1(Stdlib_char[1],v[1]));
        var _g9_=caml_call1(Stdlib_char[1],i);
        caml_bytes_set(color_repr,v[1],_g9_);
        var _g__=i + 1 | 0;
        if(255 !== i){var i=_g__;continue}
        var _g8_=v[1] + 1 | 0;
        return [0,
                c,
                caml_call3(Stdlib_bytes[7],color_repr,0,v[1] + 1 | 0),
                _g8_]}}
    function split(s,cm)
     {return iter
              (s,
               function(i,j)
                {caml_bytes_set(cm,i,1);return caml_bytes_set(cm,j + 1 | 0,1)})}
    var Re_Color_map=[0,make,flatten,split];
    caml_register_global(151,Re_Color_map,"Re__Color_map");
    function offset$0(t,i)
     {if(t[2].length - 1 <= ((2 * i | 0) + 1 | 0))throw Stdlib[8];
      var _g5_=2 * i | 0,m1=caml_check_bound(t[2],_g5_)[1 + _g5_];
      if(-1 === m1)throw Stdlib[8];
      var
       p1=caml_check_bound(t[4],m1)[1 + m1] - 1 | 0,
       _g6_=(2 * i | 0) + 1 | 0,
       _g7_=caml_check_bound(t[2],_g6_)[1 + _g6_],
       p2=caml_check_bound(t[4],_g7_)[1 + _g7_] - 1 | 0;
      return [0,p1,p2]}
    function get(t,i)
     {var match=offset$0(t,i),p2=match[2],p1=match[1];
      return caml_call3(Stdlib_string[4],t[1],p1,p2 - p1 | 0)}
    function start(subs,i){return offset$0(subs,i)[1]}
    function stop(subs,i){return offset$0(subs,i)[2]}
    function test(t,i)
     {if(t[2].length - 1 <= (2 * i | 0))return 0;
      var _g4_=2 * i | 0,idx=caml_check_bound(t[2],_g4_)[1 + _g4_];
      return -1 !== idx?1:0}
    function all_offset(t)
     {var
       res=caml_make_vect(t[5],dummy_offset),
       _gZ_=((t[2].length - 1) / 2 | 0) - 1 | 0,
       _gY_=0;
      if(! (_gZ_ < 0))
       {var i=_gY_;
        for(;;)
         {var _g0_=2 * i | 0,m1=caml_check_bound(t[2],_g0_)[1 + _g0_];
          if(-1 !== m1)
           {var
             p1=caml_check_bound(t[4],m1)[1 + m1],
             _g1_=(2 * i | 0) + 1 | 0,
             _g2_=caml_check_bound(t[2],_g1_)[1 + _g1_],
             p2=caml_check_bound(t[4],_g2_)[1 + _g2_];
            caml_check_bound(res,i)[1 + i] = [0,p1 - 1 | 0,p2 - 1 | 0]}
          var _g3_=i + 1 | 0;
          if(_gZ_ !== i){var i=_g3_;continue}
          break}}
      return res}
    function all(t)
     {var
       res=caml_make_vect(t[5],dummy_string),
       _gS_=((t[2].length - 1) / 2 | 0) - 1 | 0,
       _gR_=0;
      if(! (_gS_ < 0))
       {var i=_gR_;
        for(;;)
         {var _gT_=2 * i | 0,m1=caml_check_bound(t[2],_gT_)[1 + _gT_];
          if(-1 !== m1)
           {var
             p1=caml_check_bound(t[4],m1)[1 + m1],
             _gU_=(2 * i | 0) + 1 | 0,
             _gV_=caml_check_bound(t[2],_gU_)[1 + _gU_],
             p2=caml_check_bound(t[4],_gV_)[1 + _gV_],
             _gW_=caml_call3(Stdlib_string[4],t[1],p1 - 1 | 0,p2 - p1 | 0);
            caml_check_bound(res,i)[1 + i] = _gW_}
          var _gX_=i + 1 | 0;
          if(_gS_ !== i){var i=_gX_;continue}
          break}}
      return res}
    function pp$4(fmt,t)
     {var offsets=all_offset(t),strs=all(t);
      function _gL_(i)
       {var _gQ_=caml_check_bound(offsets,i)[1 + i];
        return [0,caml_check_bound(strs,i)[1 + i],_gQ_]}
      var
       _gM_=caml_call2(Stdlib_array[2],strs.length - 1,_gL_),
       matches=caml_call1(Stdlib_array[11],_gM_);
      function pp_match(fmt,param)
       {var match=param[2],stop=match[2],start=match[1],str=param[1];
        return caml_call5(_bf_,fmt,_b4_,str,start,stop)}
      var _gN_=0;
      return sexp
              (fmt,
               cst_Group,
               function(_gO_,_gP_)
                {return pp_print_list(_gN_,pp_match,_gO_,_gP_)},
               matches)}
    function nb_groups(t){return t[5]}
    var Group=[0,get,offset$0,start,stop,all,all_offset,test,nb_groups,pp$4];
    caml_register_global(153,Group,"Re__Group");
    function iter$0(n,f,v)
     {var n$0=n,v$0=v;
      for(;;)
       {if(0 === n$0)return v$0;
        var v$1=caml_call1(f,v$0),n$1=n$0 - 1 | 0,n$0=n$1,v$0=v$1;
        continue}}
    var unknown=-2,break$0=-3;
    function print_re(ch,re){return pp$2(ch,re[1])}
    function category(re,color)
     {return -1 === color
              ?inexistant
              :color === re[6]?28:from_char(caml_bytes_get(re[4],color))}
    var dummy_next=[0],unknown_state=[0,unknown,0,dummy_next,0,_b3_[1]];
    function mk_state(ncol,desc)
     {var match=status(desc),switch$0=0;
      if(typeof match === "number" && match){var break_state=0;switch$0 = 1}
      if(! switch$0)var break_state=1;
      var
       _gH_=0,
       _gI_=break_state?dummy_next:caml_make_vect(ncol,unknown_state),
       _gJ_=desc[1],
       _gK_=break_state?break$0:desc[1];
      return [0,_gK_,_gJ_,_gI_,_gH_,desc]}
    function find_state(re,desc)
     {try
       {var _gF_=caml_call2(_b3_[3][7],re[8],desc);return _gF_}
      catch(_gG_)
       {_gG_ = caml_wrap_exception(_gG_);
        if(_gG_ === Stdlib[8])
         {var st=mk_state(re[5],desc);
          caml_call3(_b3_[3][5],re[8],desc,st);
          return st}
        throw _gG_}}
    function delta$0(info,cat,color,st)
     {var
       desc=delta(info[1][7],cat,color,st[5]),
       len=info[3].length - 1,
       _gD_=desc[1] === len?1:0,
       _gE_=_gD_?0 < len?1:0:_gD_;
      if(_gE_)
       {var pos=info[3];
        info[3] = caml_make_vect(2 * len | 0,0);
        caml_call5(Stdlib_array[10],pos,0,info[3],0,len)}
      return desc}
    function validate(info,s,pos,st)
     {var
       _gC_=caml_string_get(s,pos),
       color=caml_bytes_get(info[2],_gC_),
       cat=category(info[1],color),
       desc=delta$0(info,cat,color,st),
       st$0=find_state(info[1],desc);
      caml_check_bound(st[3],color)[1 + color] = st$0;
      return 0}
    function final$0(info,st,cat)
     {try
       {var _gA_=caml_call2(Stdlib_list[45],cat,st[4]);return _gA_}
      catch(_gB_)
       {_gB_ = caml_wrap_exception(_gB_);
        if(_gB_ === Stdlib[8])
         {var
           st$0=delta$0(info,cat,-1,st),
           _gz_=status(st$0),
           res=[0,st$0[1],_gz_];
          st[4] = [0,[0,cat,res],st[4]];
          return res}
        throw _gB_}}
    function find_initial_state(re,cat)
     {try
       {var _gx_=caml_call2(Stdlib_list[45],cat,re[2]);return _gx_}
      catch(_gy_)
       {_gy_ = caml_wrap_exception(_gy_);
        if(_gy_ === Stdlib[8])
         {var st=find_state(re,caml_call2(_b3_[2],cat,re[1]));
          re[2] = [0,[0,cat,st],re[2]];
          return st}
        throw _gy_}}
    function get_color(re,s,pos)
     {if(0 <= pos)
       {var slen=caml_ml_string_length(s);
        if(slen <= pos)return -1;
        if
         (pos
          ===
          (slen - 1 | 0)
          &&
          -1
          !==
          re[6]
          &&
          10
          ===
          caml_string_get(s,pos))
         return re[6];
        var _gw_=caml_string_get(s,pos);
        return caml_bytes_get(re[3],_gw_)}
      return -1}
    function scan_str(info,s,st$8,groups)
     {var pos$4=info[4],last=info[5];
      if
       (last
        ===
        caml_ml_string_length(s)
        &&
        -1
        !==
        info[1][6]
        &&
        pos$4
        <
        last
        &&
        10
        ===
        caml_string_get(s,last - 1 | 0))
       {var
         info$0=[0,info[1],info[2],info[3],info[4],last - 1 | 0],
         st$9=scan_str(info$0,s,st$8,groups);
        if(st$9[1] === -3)return st$9;
        var pos$5=last - 1 | 0;
        for(;;)
         {var _gt_=info$0[1][6],st$6=caml_check_bound(st$9[3],_gt_)[1 + _gt_];
          if(0 <= st$6[1])
           {if(groups)
             {var _gu_=st$6[1];
              caml_check_bound(info$0[3],_gu_)[1 + _gu_] = pos$5 + 1 | 0}
            return st$6}
          if(st$6[1] === -3)
           {if(groups)
             {var _gv_=st$6[2];
              caml_check_bound(info$0[3],_gv_)[1 + _gv_] = pos$5 + 1 | 0}
            return st$6}
          var
           color=info$0[1][6],
           real_c=caml_bytes_get(info$0[2],10),
           cat=category(info$0[1],color),
           desc=delta$0(info$0,cat,real_c,st$9),
           st$7=find_state(info$0[1],desc);
          caml_check_bound(st$9[3],color)[1 + color] = st$7;
          continue}}
      if(groups)
       {var pos=pos$4,st=st$8;
        a:
        for(;;)
         {if(pos < info[5])
           {var
             _gk_=caml_string_get(s,pos),
             _gl_=caml_bytes_get(info[2],_gk_),
             st$0=caml_check_bound(st[3],_gl_)[1 + _gl_],
             pos$0=pos,
             st$2=st,
             st$1=st$0;
            for(;;)
             {if(0 <= st$1[1])
               {var pos$1=pos$0 + 1 | 0;
                if(pos$1 < info[5])
                 {var
                   _gm_=caml_string_get(s,pos$1),
                   _gn_=caml_bytes_get(info[2],_gm_),
                   st$3=caml_check_bound(st$1[3],_gn_)[1 + _gn_],
                   _go_=st$1[1];
                  caml_check_bound(info[3],_go_)[1 + _go_] = pos$1;
                  var pos$0=pos$1,st$2=st$1,st$1=st$3;
                  continue}
                var _gp_=st$1[1];
                caml_check_bound(info[3],_gp_)[1 + _gp_] = pos$1;
                return st$1}
              if(st$1[1] === -3)
               {var _gq_=st$1[2];
                caml_check_bound(info[3],_gq_)[1 + _gq_] = pos$0 + 1 | 0;
                return st$1}
              validate(info,s,pos$0,st$2);
              var pos=pos$0,st=st$2;
              continue a}}
          return st}}
      var pos$2=pos$4,st$4=st$8;
      for(;;)
       {if(pos$2 < last)
         {var
           _gr_=caml_string_get(s,pos$2),
           _gs_=caml_bytes_get(info[2],_gr_),
           st$5=caml_check_bound(st$4[3],_gs_)[1 + _gs_];
          if(0 <= st$5[1])
           {var pos$3=pos$2 + 1 | 0,pos$2=pos$3,st$4=st$5;continue}
          if(st$5[1] === -3)return st$5;
          validate(info,s,pos$2,st$4);
          continue}
        return st$4}}
    function match_str(groups,partial,re,s,pos,len)
     {var slen=caml_ml_string_length(s),last=-1 === len?slen:pos + len | 0;
      if(groups)
       var
        n=index_count(re[7]) + 1 | 0,
        _gi_=10 < n?caml_make_vect(n,0):_b5_.slice(),
        _gj_=_gi_;
      else
       var _gj_=[0];
      var
       info=[0,re,re[3],_gj_,pos,last],
       initial_cat=0 === pos?33:32 | category(re,get_color(re,s,pos - 1 | 0)),
       initial_state=find_initial_state(re,initial_cat),
       st=scan_str(info,s,initial_state,groups),
       switch$0=0;
      if(st[1] !== -3 && ! partial)
       {var
         final_cat=last === slen?33:32 | category(re,get_color(re,s,last)),
         match=final$0(info,st,final_cat),
         res$0=match[2],
         idx=match[1];
        if(groups)caml_check_bound(info[3],idx)[1 + idx] = last + 1 | 0;
        var res=res$0;
        switch$0 = 1}
      if(! switch$0)var res=status(st[5]);
      if(typeof res === "number")return res?1:0;
      var pmarks=res[2],marks=res[1];
      return [0,[0,s,marks,pmarks,info[3],re[9]]]}
    function cseq(c$0,c){return seq(c$0,c)}
    function cadd(c,s){return add(c,s)}
    function trans_set(cache,cm,s)
     {var match=one_char(s);
      if(match){var i=match[1];return csingle(caml_bytes_get(cm,i))}
      var v=[0,hash_rec(s),s];
      try
       {var _gf_=caml_call2(CSetMap[28],v,cache[1]);return _gf_}
      catch(_gg_)
       {_gg_ = caml_wrap_exception(_gg_);
        if(_gg_ === Stdlib[8])
         {var
           l=
            fold_right
             (s,
              empty,
              function(param,l)
               {var j=param[2],i=param[1],_gh_=caml_bytes_get(cm,j);
                return union(cseq(caml_bytes_get(cm,i),_gh_),l)});
          cache[1] = caml_call3(CSetMap[4],v,l,cache[1]);
          return l}
        throw _gg_}}
    function view(t){return t}
    var View=[0,view];
    function pp$5(fmt,t)
     {function var$0(s,re){return sexp(fmt,s,pp$5,re)}
      function seq(s,rel)
       {var _gc_=0;
        return sexp
                (fmt,
                 s,
                 function(_gd_,_ge_)
                  {return pp_print_list(_gc_,pp$5,_gd_,_ge_)},
                 rel)}
      if(typeof t === "number")
       switch(t)
        {case 0:return caml_call2(_m_,fmt,cst_Beg_of_line);
         case 1:return caml_call2(_m_,fmt,cst_End_of_line);
         case 2:return caml_call2(_m_,fmt,cst_Beg_of_word);
         case 3:return caml_call2(_m_,fmt,cst_End_of_word);
         case 4:return caml_call2(_m_,fmt,cst_Not_bound);
         case 5:return caml_call2(_m_,fmt,cst_Beg_of_str);
         case 6:return caml_call2(_m_,fmt,cst_End_of_str);
         case 7:return caml_call2(_m_,fmt,cst_Last_end_of_line);
         case 8:return caml_call2(_m_,fmt,cst_Start);
         default:return caml_call2(_m_,fmt,cst_Stop)}
      else
       switch(t[0])
        {case 0:var s=t[1];return sexp(fmt,cst_Set,pp$0,s);
         case 1:var sq=t[1];return seq(cst_Sequence,sq);
         case 2:var alt=t[1];return seq(cst_Alternative,alt);
         case 3:
          var
           stop=t[3],
           start=t[2],
           re=t[1],
           pp=
            function(fmt,param)
             {return caml_call7(_bf_,fmt,_b6_,pp$5,re,start,optint,stop)};
          return sexp(fmt,cst_Repeat,pp,0);
         case 4:
          var re$0=t[2],sem=t[1],_f2_=[0,sem,re$0];
          return sexp
                  (fmt,
                   cst_Sem,
                   function(_f__,_f$_){return pair(pp_sem,pp$5,_f__,_f$_)},
                   _f2_);
         case 5:
          var re$1=t[2],k=t[1],_f3_=[0,k,re$1];
          return sexp
                  (fmt,
                   cst_Sem_greedy,
                   function(_f8_,_f9_){return pair(pp_rep_kind,pp$5,_f8_,_f9_)},
                   _f3_);
         case 6:var c=t[1];return var$0(cst_Group$0,c);
         case 7:var c$0=t[1];return var$0(cst_No_group,c$0);
         case 8:var c$1=t[1];return var$0(cst_Nest,c$1);
         case 9:var c$2=t[1];return var$0(cst_Case,c$2);
         case 10:var c$3=t[1];return var$0(cst_No_case,c$3);
         case 11:var c$4=t[1];return seq(cst_Intersection,c$4);
         case 12:var c$5=t[1];return seq(cst_Complement,c$5);
         case 13:
          var b=t[2],a=t[1],_f4_=[0,a,b];
          return sexp
                  (fmt,
                   cst_Difference,
                   function(_f6_,_f7_){return pair(pp$5,pp$5,_f6_,_f7_)},
                   _f4_);
         default:
          var r=t[2],m=t[1],_f5_=[0,m,r];
          return sexp
                  (fmt,
                   cst_Pmark,
                   function(_ga_,_gb_){return pair(pp$1,pp$5,_ga_,_gb_)},
                   _f5_)}}
    function is_charset(param)
     {var param$0=param;
      for(;;)
       {var switch$0=0;
        if(typeof param$0 === "number")
         switch$0 = 1;
        else
         switch(param$0[0])
          {case 0:return 1;
           case 13:
            var r=param$0[2],r$0=param$0[1],_f1_=is_charset(r$0);
            if(_f1_){var param$0=r;continue}
            return _f1_;
           case 4:
           case 5:var param$1=param$0[2];break;
           case 2:
           case 11:
           case 12:
            var l=param$0[1];return caml_call2(Stdlib_list[30],is_charset,l);
           case 7:
           case 9:
           case 10:var param$1=param$0[1];break;
           default:switch$0 = 1}
        if(switch$0)return 0;
        var param$0=param$1;
        continue}}
    var
     _b7_=cseq(216,222),
     _b8_=union(cseq(192,214),_b7_),
     cupper=union(cseq(65,90),_b8_),
     clower=offset(32,cupper),
     _b9_=union(clower,cupper),
     calpha=caml_call3(Stdlib_list[24],cadd,_b__,_b9_),
     cdigit=cseq(48,57),
     calnum=union(calpha,cdigit),
     cword=cadd(95,calnum);
    function equal$3(x1,x2)
     {var x1$0=x1,x2$0=x2;
      for(;;)
       {var switch$0=0;
        if(typeof x1$0 === "number")
         switch(x1$0)
          {case 0:if(typeof x2$0 === "number" && ! x2$0)switch$0 = 1;break;
           case 1:
            if(typeof x2$0 === "number" && 1 === x2$0)switch$0 = 1;break;
           case 2:
            if(typeof x2$0 === "number" && 2 === x2$0)switch$0 = 1;break;
           case 3:
            if(typeof x2$0 === "number" && 3 === x2$0)switch$0 = 1;break;
           case 4:
            if(typeof x2$0 === "number" && 4 === x2$0)switch$0 = 1;break;
           case 5:
            if(typeof x2$0 === "number" && 5 === x2$0)switch$0 = 1;break;
           case 6:
            if(typeof x2$0 === "number" && 6 === x2$0)switch$0 = 1;break;
           case 7:
            if(typeof x2$0 === "number" && 7 === x2$0)switch$0 = 1;break;
           case 8:
            if(typeof x2$0 === "number" && 8 === x2$0)switch$0 = 1;break;
           default:if(typeof x2$0 === "number" && 9 <= x2$0)switch$0 = 1}
        else
         switch(x1$0[0])
          {case 0:
            if(typeof x2$0 !== "number" && 0 === x2$0[0])
             {var s2=x2$0[1],s1=x1$0[1];return caml_equal(s1,s2)}
            break;
           case 1:
            if(typeof x2$0 !== "number" && 1 === x2$0[0])
             {var l2=x2$0[1],l1=x1$0[1];return eq_list(l1,l2)}
            break;
           case 2:
            if(typeof x2$0 !== "number" && 2 === x2$0[0])
             {var l2$0=x2$0[1],l1$0=x1$0[1];return eq_list(l1$0,l2$0)}
            break;
           case 3:
            if(typeof x2$0 !== "number" && 3 === x2$0[0])
             {var
               j2=x2$0[3],
               i2=x2$0[2],
               x2$1=x2$0[1],
               j1=x1$0[3],
               i1=x1$0[2],
               x1$1=x1$0[1],
               _fU_=i1 === i2?1:0;
              if(_fU_)
               {var _fV_=caml_equal(j1,j2);
                if(_fV_){var x1$0=x1$1,x2$0=x2$1;continue}
                var _fW_=_fV_}
              else
               var _fW_=_fU_;
              return _fW_}
            break;
           case 4:
            if(typeof x2$0 !== "number" && 4 === x2$0[0])
             {var
               x2$2=x2$0[2],
               sem2=x2$0[1],
               x1$2=x1$0[2],
               sem1=x1$0[1],
               _fX_=sem1 === sem2?1:0;
              if(_fX_){var x1$0=x1$2,x2$0=x2$2;continue}
              return _fX_}
            break;
           case 5:
            if(typeof x2$0 !== "number" && 5 === x2$0[0])
             {var
               x2$3=x2$0[2],
               k2=x2$0[1],
               x1$3=x1$0[2],
               k1=x1$0[1],
               _fY_=k1 === k2?1:0;
              if(_fY_){var x1$0=x1$3,x2$0=x2$3;continue}
              return _fY_}
            break;
           case 6:if(typeof x2$0 !== "number" && 6 === x2$0[0])return 0;break;
           case 7:
            if(typeof x2$0 !== "number" && 7 === x2$0[0])
             {var x2$4=x2$0[1],x1$4=x1$0[1],x1$0=x1$4,x2$0=x2$4;continue}
            break;
           case 8:
            if(typeof x2$0 !== "number" && 8 === x2$0[0])
             {var x2$5=x2$0[1],x1$5=x1$0[1],x1$0=x1$5,x2$0=x2$5;continue}
            break;
           case 9:
            if(typeof x2$0 !== "number" && 9 === x2$0[0])
             {var x2$6=x2$0[1],x1$6=x1$0[1],x1$0=x1$6,x2$0=x2$6;continue}
            break;
           case 10:
            if(typeof x2$0 !== "number" && 10 === x2$0[0])
             {var x2$7=x2$0[1],x1$7=x1$0[1],x1$0=x1$7,x2$0=x2$7;continue}
            break;
           case 11:
            if(typeof x2$0 !== "number" && 11 === x2$0[0])
             {var l2$1=x2$0[1],l1$1=x1$0[1];return eq_list(l1$1,l2$1)}
            break;
           case 12:
            if(typeof x2$0 !== "number" && 12 === x2$0[0])
             {var l2$2=x2$0[1],l1$2=x1$0[1];return eq_list(l1$2,l2$2)}
            break;
           case 13:
            if(typeof x2$0 !== "number" && 13 === x2$0[0])
             {var
               x2$8=x2$0[2],
               x2$9=x2$0[1],
               x1$8=x1$0[2],
               x1$9=x1$0[1],
               _fZ_=equal$3(x1$9,x2$9);
              if(_fZ_){var x1$0=x1$8,x2$0=x2$8;continue}
              return _fZ_}
            break;
           default:
            if(typeof x2$0 !== "number" && 14 === x2$0[0])
             {var
               r2=x2$0[2],
               m2=x2$0[1],
               r1=x1$0[2],
               m1=x1$0[1],
               _f0_=m1 === m2?1:0;
              if(_f0_){var x1$0=r1,x2$0=r2;continue}
              return _f0_}}
        return switch$0?1:0}}
    function eq_list(l1,l2)
     {var l1$0=l1,l2$0=l2;
      for(;;)
       {if(l1$0)
         {if(l2$0)
           {var
             r2=l2$0[2],
             x2=l2$0[1],
             r1=l1$0[2],
             x1=l1$0[1],
             _fT_=equal$3(x1,x2);
            if(_fT_){var l1$0=r1,l2$0=r2;continue}
            return _fT_}}
        else
         if(! l2$0)return 1;
        return 0}}
    function sequence(l){if(l && ! l[2]){var x=l[1];return x}return [1,l]}
    function merge_sequences(param)
     {var param$0=param;
      for(;;)
       {if(param$0)
         {var _fO_=param$0[1];
          if(typeof _fO_ !== "number")
           switch(_fO_[0])
            {case 1:
              var _fP_=_fO_[1];
              if(_fP_)
               {var
                 r$0=param$0[2],
                 y=_fP_[2],
                 x=_fP_[1],
                 r$1=merge_sequences(r$0);
                if(r$1)
                 {var _fQ_=r$1[1],switch$0=0;
                  if(typeof _fQ_ === "number" || ! (1 === _fQ_[0]))
                   switch$0 = 1;
                  else
                   {var _fR_=_fQ_[1];
                    if(_fR_)
                     {var r$2=r$1[2],y$0=_fR_[2],x$0=_fR_[1];
                      if(equal$3(x,x$0))
                       {var _fS_=[0,sequence(y$0),0];
                        return [0,[1,[0,x,[0,[2,[0,sequence(y),_fS_]],0]]],r$2]}}}}
                return [0,[1,[0,x,y]],r$1]}
              break;
             case 2:
              var
               r$3=param$0[2],
               l=_fO_[1],
               param$1=caml_call2(Stdlib[37],l,r$3),
               param$0=param$1;
              continue
             }
          var r=param$0[2];
          return [0,_fO_,merge_sequences(r)]}
        return 0}}
    function enforce_kind(ids,kind,k,cr)
     {return 332064784 === kind?332064784 === k?cr:seq$0(ids,k,cr,eps(ids)):cr}
    function trans_seq(ids,kind,ign_group,ign_case,greedy,pos,cache,c,param)
     {if(param)
       {var _fN_=param[1];
        if(param[2])
         {var
           rem=param[2],
           match=
            translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,_fN_),
           kind$0=match[2],
           cr=match[1],
           cr$0=trans_seq(ids,kind,ign_group,ign_case,greedy,pos,cache,c,rem);
          return is_eps(cr$0)?cr:is_eps(cr)?cr$0:seq$0(ids,kind$0,cr,cr$0)}
        var
         match$0=
          translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,_fN_),
         kind$1=match$0[2],
         cr$1=match$0[1];
        return enforce_kind(ids,kind,kind$1,cr$1)}
      return eps(ids)}
    function translate(ids,kind,ign_group,ign_case,greedy,pos,cache,c,param)
     {var ign_group$0=ign_group,greedy$0=greedy,param$0=param;
      for(;;)
       if(typeof param$0 === "number")
        switch(param$0)
         {case 0:return [0,after(ids,9),kind];
          case 1:return [0,before(ids,9),kind];
          case 2:
           var _fE_=before(ids,3);
           return [0,seq$0(ids,332064784,after(ids,5),_fE_),kind];
          case 3:
           var _fF_=before(ids,5);
           return [0,seq$0(ids,332064784,after(ids,3),_fF_),kind];
          case 4:
           var
            _fG_=before(ids,letter),
            _fH_=[0,seq$0(ids,332064784,after(ids,letter),_fG_),0],
            _fI_=before(ids,letter);
           return [0,
                   alt
                    (ids,[0,seq$0(ids,332064784,after(ids,letter),_fI_),_fH_]),
                   kind];
          case 5:return [0,after(ids,inexistant),kind];
          case 6:return [0,before(ids,inexistant),kind];
          case 7:return [0,before(ids,17),kind];
          case 8:return [0,after(ids,search_boundary),kind];
          default:return [0,before(ids,search_boundary),kind]}
       else
        switch(param$0[0])
         {case 0:
           var s=param$0[1];return [0,cst(ids,trans_set(cache,c,s)),kind];
          case 1:
           var l=param$0[1];
           return [0,
                   trans_seq
                    (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,l),
                   kind];
          case 2:
           var l$0=param$0[1],merged_sequences=merge_sequences(l$0);
           if(merged_sequences && ! merged_sequences[2])
            {var
              r=merged_sequences[1],
              match=
               translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r),
              kind$0=match[2],
              cr=match[1];
             return [0,enforce_kind(ids,kind,kind$0,cr),kind]}
           var
            _fJ_=
             function(r)
              {var
                match=
                 translate
                  (ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r),
                kind$0=match[2],
                cr=match[1];
               return enforce_kind(ids,kind,kind$0,cr)};
           return [0,
                   alt(ids,caml_call2(Stdlib_list[17],_fJ_,merged_sequences)),
                   kind];
          case 3:
           var
            j=param$0[3],
            i=param$0[2],
            r$0=param$0[1],
            match$0=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$0),
            kind$1=match$0[2],
            cr$0=match$0[1];
           if(j)
            var
             j$0=j[1],
             f=
              620821490 <= greedy$0
               ?function(rem)
                 {var _fL_=[0,seq$0(ids,kind$1,rename(ids,cr$0),rem),0];
                  return alt(ids,[0,eps(ids),_fL_])}
               :function(rem)
                 {var _fM_=[0,eps(ids),0];
                  return alt
                          (ids,[0,seq$0(ids,kind$1,rename(ids,cr$0),rem),_fM_])},
             rem=iter$0(j$0 - i | 0,f,eps(ids));
           else
            var rem=rep(ids,greedy$0,kind$1,cr$0);
           return [0,
                   iter$0
                    (i,
                     function(rem){return seq$0(ids,kind$1,rename(ids,cr$0),rem)},
                     rem),
                   kind];
          case 4:
           var
            r$1=param$0[2],
            kind$2=param$0[1],
            match$1=
             translate
              (ids,kind$2,ign_group$0,ign_case,greedy$0,pos,cache,c,r$1),
            kind$3=match$1[2],
            cr$1=match$1[1];
           return [0,enforce_kind(ids,kind$2,kind$3,cr$1),kind$2];
          case 5:
           var
            param$1=param$0[2],
            greedy$1=param$0[1],
            greedy$0=greedy$1,
            param$0=param$1;
           continue;
          case 6:
           var r$2=param$0[1];
           if(ign_group$0){var param$0=r$2;continue}
           var p=pos[1];
           pos[1] = pos[1] + 2 | 0;
           var
            match$2=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$2),
            kind$4=match$2[2],
            cr$2=match$2[1],
            _fK_=seq$0(ids,332064784,cr$2,mark(ids,p + 1 | 0));
           return [0,seq$0(ids,332064784,mark(ids,p),_fK_),kind$4];
          case 7:
           var param$2=param$0[1],ign_group$0=1,param$0=param$2;continue;
          case 8:
           var
            r$3=param$0[1],
            b=pos[1],
            match$3=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$3),
            kind$5=match$3[2],
            cr$3=match$3[1],
            e=pos[1] - 1 | 0;
           return e < b
                   ?[0,cr$3,kind$5]
                   :[0,seq$0(ids,332064784,erase(ids,b,e),cr$3),kind$5];
          case 14:
           var
            r$4=param$0[2],
            i$0=param$0[1],
            match$4=
             translate(ids,kind,ign_group$0,ign_case,greedy$0,pos,cache,c,r$4),
            kind$6=match$4[2],
            cr$4=match$4[1];
           return [0,seq$0(ids,332064784,pmark(ids,i$0),cr$4),kind$6];
          default:throw [0,Assert_failure,_ca_]}}
    function as_set(param)
     {if(typeof param !== "number" && 0 === param[0]){var s=param[1];return s}
      throw [0,Assert_failure,_cb_]}
    function handle_case(ign_case,r)
     {var ign_case$0=ign_case,r$0=r;
      for(;;)
       if(typeof r$0 === "number")
        return r$0;
       else
        switch(r$0[0])
         {case 0:
           var s=r$0[1];
           if(ign_case$0)
            var
             _fs_=offset(-32,inter(s,clower)),
             _ft_=union(s,union(offset(32,inter(s,cupper)),_fs_));
           else
            var _ft_=s;
           return [0,_ft_];
          case 1:
           var
            l=r$0[1],
            _fu_=function(_fD_){return handle_case(ign_case$0,_fD_)};
           return [1,caml_call2(Stdlib_list[17],_fu_,l)];
          case 2:
           var
            l$0=r$0[1],
            _fv_=function(_fC_){return handle_case(ign_case$0,_fC_)},
            l$1=caml_call2(Stdlib_list[17],_fv_,l$0);
           if(is_charset([2,l$1]))
            {var _fw_=function(s,r){return union(s,as_set(r))};
             return [0,caml_call3(Stdlib_list[23],_fw_,empty,l$1)]}
           return [2,l$1];
          case 3:
           var j=r$0[3],i=r$0[2],r$1=r$0[1];
           return [3,handle_case(ign_case$0,r$1),i,j];
          case 4:
           var r$2=r$0[2],k=r$0[1],r$3=handle_case(ign_case$0,r$2);
           return is_charset(r$3)?r$3:[4,k,r$3];
          case 5:
           var r$4=r$0[2],k$0=r$0[1],r$5=handle_case(ign_case$0,r$4);
           return is_charset(r$5)?r$5:[5,k$0,r$5];
          case 6:var r$6=r$0[1];return [6,handle_case(ign_case$0,r$6)];
          case 7:
           var r$7=r$0[1],r$8=handle_case(ign_case$0,r$7);
           return is_charset(r$8)?r$8:[7,r$8];
          case 8:
           var r$9=r$0[1],r$10=handle_case(ign_case$0,r$9);
           return is_charset(r$10)?r$10:[8,r$10];
          case 9:var r$11=r$0[1],ign_case$0=0,r$0=r$11;continue;
          case 10:var r$12=r$0[1],ign_case$0=1,r$0=r$12;continue;
          case 11:
           var
            l$2=r$0[1],
            _fx_=function(r){return handle_case(ign_case$0,r)},
            l$3=caml_call2(Stdlib_list[17],_fx_,l$2),
            _fy_=function(s,r){return inter(s,as_set(r))};
           return [0,caml_call3(Stdlib_list[23],_fy_,cany,l$3)];
          case 12:
           var
            l$4=r$0[1],
            _fz_=function(r){return handle_case(ign_case$0,r)},
            l$5=caml_call2(Stdlib_list[17],_fz_,l$4),
            _fA_=function(s,r){return union(s,as_set(r))};
           return [0,diff(cany,caml_call3(Stdlib_list[23],_fA_,empty,l$5))];
          case 13:
           var
            r$13=r$0[2],
            r$14=r$0[1],
            _fB_=diff(cany,as_set(handle_case(ign_case$0,r$13)));
           return [0,inter(as_set(handle_case(ign_case$0,r$14)),_fB_)];
          default:
           var r$15=r$0[2],i$0=r$0[1];
           return [14,i$0,handle_case(ign_case$0,r$15)]}}
    function anchored(param)
     {var param$0=param;
      for(;;)
       {var switch$0=0;
        if(typeof param$0 === "number")
         switch(param$0){case 5:case 8:return 1}
        else
         switch(param$0[0])
          {case 1:
            var l=param$0[1];return caml_call2(Stdlib_list[31],anchored,l);
           case 2:
            var l$0=param$0[1];
            return caml_call2(Stdlib_list[30],anchored,l$0);
           case 3:
            var i=param$0[2],r=param$0[1],_fr_=0 < i?1:0;
            if(_fr_){var param$0=r;continue}
            return _fr_;
           case 4:
           case 5:
           case 14:var param$1=param$0[2];switch$0 = 1;break;
           case 0:
           case 11:
           case 12:
           case 13:break;
           default:var param$1=param$0[1];switch$0 = 1}
        if(switch$0){var param$0=param$1;continue}
        return 0}}
    function str(s)
     {var l=[0,0],_fo_=caml_ml_string_length(s) - 1 | 0;
      if(! (_fo_ < 0))
       {var i=_fo_;
        for(;;)
         {var _fp_=l[1];
          l[1] = [0,[0,csingle(caml_string_get(s,i))],_fp_];
          var _fq_=i - 1 | 0;
          if(0 !== i){var i=_fq_;continue}
          break}}
      return [1,l[1]]}
    function char$0(c){return [0,csingle(c)]}
    function alt$0(l){if(l && ! l[2]){var r=l[1];return r}return [2,l]}
    function seq$1(l){if(l && ! l[2]){var r=l[1];return r}return [1,l]}
    var empty$2=alt$0(0),epsilon=seq$1(0);
    function repn(r,i,j)
     {if(i < 0)caml_call1(Stdlib[1],cst_Re_repn);
      var switch$0=0;
      if(j)
       {var j$0=j[1];
        if(j$0 < i){caml_call1(Stdlib[1],cst_Re_repn$0);switch$0 = 1}}
      return [3,r,i,j]}
    function rep$0(r){return repn(r,0,0)}
    function rep1(r){return repn(r,1,0)}
    function opt(r){return repn(r,0,_cc_)}
    var bol=0,eol=1,bow=2,eow=3;
    function word(r){return seq$1([0,bow,[0,r,[0,eow,0]]])}
    var not_boundary=4,bos=5,eos=6;
    function whole_string(r){return seq$1([0,bos,[0,r,[0,eos,0]]])}
    var leol=7,start$0=8,stop$0=9;
    function longest(r){return [4,-730718166,r]}
    function shortest(r){return [4,-1034406550,r]}
    function first$0(r){return [4,332064784,r]}
    function greedy(r){return [5,-904640576,r]}
    function non_greedy(r){return [5,620821490,r]}
    function group(r){return [6,r]}
    function no_group(r){return [7,r]}
    function nest(r){return [8,r]}
    function mark$0(r){var i=gen(0);return [0,i,[14,i,r]]}
    function set(str)
     {var s=[0,empty],_fl_=caml_ml_string_length(str) - 1 | 0,_fk_=0;
      if(! (_fl_ < 0))
       {var i=_fk_;
        for(;;)
         {var _fm_=s[1];
          s[1] = union(csingle(caml_string_get(str,i)),_fm_);
          var _fn_=i + 1 | 0;
          if(_fl_ !== i){var i=_fn_;continue}
          break}}
      return [0,s[1]]}
    function rg(c$0,c){return [0,cseq(c$0,c)]}
    function inter$0(l)
     {var r=[11,l];return is_charset(r)?r:caml_call1(Stdlib[1],cst_Re_inter)}
    function compl(l)
     {var r=[12,l];return is_charset(r)?r:caml_call1(Stdlib[1],cst_Re_compl)}
    function diff$0(r$0,r)
     {var r$1=[13,r$0,r];
      return is_charset(r$1)?r$1:caml_call1(Stdlib[1],cst_Re_diff)}
    var
     any=[0,cany],
     notnl=[0,diff(cany,csingle(10))],
     _cd_=[0,rg(248,255),0],
     _ce_=[0,rg(223,246),_cd_],
     _cf_=[0,char$0(181),_ce_],
     lower=alt$0([0,rg(97,122),_cf_]),
     _cg_=[0,rg(216,222),0],
     _ch_=[0,rg(192,214),_cg_],
     upper=alt$0([0,rg(65,90),_ch_]),
     _ci_=[0,char$0(186),0],
     alpha=alt$0([0,lower,[0,upper,[0,char$0(170),_ci_]]]),
     digit=rg(48,57),
     alnum=alt$0([0,alpha,[0,digit,0]]),
     wordc=alt$0([0,alnum,[0,char$0(95),0]]),
     ascii=rg(0,127),
     blank=set(cst$0),
     _cj_=[0,rg(127,159),0],
     cntrl=alt$0([0,rg(0,31),_cj_]),
     _ck_=[0,rg(160,255),0],
     graph=alt$0([0,rg(33,126),_ck_]),
     _cl_=[0,rg(160,255),0],
     print=alt$0([0,rg(32,126),_cl_]),
     _cm_=[0,char$0(247),0],
     _cn_=[0,char$0(215),_cm_],
     _co_=[0,rg(187,191),_cn_],
     _cp_=[0,rg(182,185),_co_],
     _cq_=[0,rg(171,180),_cp_],
     _cr_=[0,rg(160,169),_cq_],
     _cs_=[0,rg(123,126),_cr_],
     _ct_=[0,rg(91,96),_cs_],
     _cu_=[0,rg(58,64),_ct_],
     punct=alt$0([0,rg(33,47),_cu_]),
     _cv_=[0,rg(9,13),0],
     space=alt$0([0,char$0(32),_cv_]),
     _cw_=[0,rg(65,70),0],
     xdigit=alt$0([0,digit,[0,rg(97,102),_cw_]]);
    function case$0(r){return [9,r]}
    function no_case(r){return [10,r]}
    function compile(r$0)
     {var
       _fj_=
        anchored(r$0)?[6,r$0]:seq$1([0,shortest(rep$0(any)),[0,[6,r$0],0]]),
       regexp=handle_case(0,_fj_),
       c=make(0),
       lnl=[0,0];
      function colorize(regexp)
       {var regexp$0=regexp;
        for(;;)
         {if(typeof regexp$0 === "number")
           switch(regexp$0)
            {case 7:lnl[1] = 1;return 0;
             case 0:
             case 1:return split(csingle(10),c);
             case 2:
             case 3:
             case 4:return split(cword,c);
             default:return 0}
          else
           switch(regexp$0[0])
            {case 0:var s=regexp$0[1];return split(s,c);
             case 1:
              var l=regexp$0[1];return caml_call2(Stdlib_list[15],colorize,l);
             case 2:
              var l$0=regexp$0[1];
              return caml_call2(Stdlib_list[15],colorize,l$0);
             case 3:var regexp$1=regexp$0[1],regexp$0=regexp$1;continue;
             case 4:
             case 5:
             case 14:var regexp$2=regexp$0[2];break;
             case 6:
             case 7:
             case 8:var regexp$2=regexp$0[1];break;
             default:throw [0,Assert_failure,_b$_]}
          var regexp$0=regexp$2;
          continue}}
      colorize(regexp);
      var
       _fi_=lnl[1],
       match=flatten(c),
       ncolor=match[3],
       color_repr=match[2],
       colors=match[1],
       lnl$0=_fi_?ncolor:-1,
       ncolor$0=_fi_?ncolor + 1 | 0:ncolor,
       ids=create_ids(0),
       pos=[0,0],
       match$0=
        translate
         (ids,332064784,0,0,-904640576,pos,[0,CSetMap[1]],colors,regexp),
       kind=match$0[2],
       r=match$0[1],
       initial=enforce_kind(ids,332064784,kind,r),
       group_count=pos[1] / 2 | 0,
       _fh_=caml_call1(_b3_[3][1],97);
      return [0,
              initial,
              0,
              colors,
              color_repr,
              ncolor$0,
              lnl$0,
              create_working_area(0),
              _fh_,
              group_count]}
    function exec_internal(name,opt,_fd_,partial,groups,re,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(_fd_)var sth$0=_fd_[1],len=sth$0;else var len=-1;
      var _fe_=pos < 0?1:0;
      if(_fe_)
       var _ff_=_fe_;
      else
       var
        _fg_=len < -1?1:0,
        _ff_=_fg_ || (caml_ml_string_length(s) < (pos + len | 0)?1:0);
      if(_ff_)caml_call1(Stdlib[1],name);
      return match_str(groups,partial,re,s,pos,len)}
    function exec(pos,len,re,s)
     {var match=exec_internal(cst_Re_exec,pos,len,0,1,re,s);
      if(typeof match === "number")throw Stdlib[8];
      var substr=match[1];
      return substr}
    function exec_opt(pos,len,re,s)
     {var match=exec_internal(cst_Re_exec_opt,pos,len,0,1,re,s);
      if(typeof match === "number")return 0;
      var substr=match[1];
      return [0,substr]}
    function execp(pos,len,re,s)
     {var match=exec_internal(cst_Re_execp,pos,len,0,0,re,s);
      return typeof match === "number"?0:1}
    function exec_partial(pos,len,re,s)
     {var match=exec_internal(cst_Re_exec_partial,pos,len,1,0,re,s);
      return typeof match === "number"?match?939392865:-1062743954:782112175}
    function marked(g,p){return caml_call2(Set[3],p,g[3])}
    function mark_set(g){return g[3]}
    function all_seq(opt,len,re,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(pos < 0)caml_call1(Stdlib[1],cst_Re_all);
      if(len)
       {var
         l=len[1],
         _e$_=l < 0?1:0,
         _fa_=_e$_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
        if(_fa_)caml_call1(Stdlib[1],cst_Re_all$0);
        var limit=pos + l | 0}
      else
       var limit=caml_ml_string_length(s);
      function aux(pos,param)
       {if(limit <= pos)return 0;
        var match=match_str(1,0,re,s,pos,limit - pos | 0);
        if(typeof match === "number")return 0;
        var
         substr=match[1],
         match$0=caml_call2(Group[2],substr,0),
         p2=match$0[2],
         p1=match$0[1],
         pos$0=p1 === p2?p2 + 1 | 0:p2;
        return [0,substr,function(_fc_){return aux(pos$0,_fc_)}]}
      return function(_fb_){return aux(pos,_fb_)}}
    function matches_seq(pos,len,re,s)
     {var _e9_=all_seq(pos,len,re,s);
      function _e__(sub){return caml_call2(Group[1],sub,0)}
      return caml_call2(Stdlib_seq[5],_e__,_e9_)}
    function split_full_seq(opt,len,re,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(pos < 0)caml_call1(Stdlib[1],cst_Re_split);
      if(len)
       {var
         l=len[1],
         _eY_=l < 0?1:0,
         _eZ_=_eY_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
        if(_eZ_)caml_call1(Stdlib[1],cst_Re_split$0);
        var limit=pos + l | 0}
      else
       var limit=caml_ml_string_length(s);
      function aux(state,i,pos$0,param)
       {if(typeof state === "number")
         {if(limit <= pos$0)
           {if(i < limit)
             {var
               sub=caml_call3(Stdlib_string[4],s,i,limit - i | 0),
               _e2_=i + 1 | 0;
              return [0,
                      [0,936573133,sub],
                      function(_e8_){return aux(state,_e2_,pos$0,_e8_)}]}
            return 0}
          var match=match_str(1,0,re,s,pos$0,limit - pos$0 | 0);
          if(typeof match === "number")
           {if(match)return 0;
            if(i < limit)
             {var text=caml_call3(Stdlib_string[4],s,i,limit - i | 0);
              return [0,
                      [0,936573133,text],
                      function(_e7_){return aux(state,limit,pos$0,_e7_)}]}
            return 0}
          var
           substr=match[1],
           match$0=caml_call2(Group[2],substr,0),
           p2=match$0[2],
           p1=match$0[1],
           pos$1=p1 === p2?p2 + 1 | 0:p2;
          if(pos < p1)
           {var
             text$0=caml_call3(Stdlib_string[4],s,i,p1 - i | 0),
             state$0=[0,73271853,[0,-363573681,substr]];
            return [0,
                    [0,936573133,text$0],
                    function(_e6_){return aux(state$0,p2,pos$1,_e6_)}]}
          return [0,
                  [0,-363573681,substr],
                  function(_e5_){return aux(state,p2,pos$1,_e5_)}]}
        var x=state[2],_e3_=814535476;
        return [0,x,function(_e4_){return aux(_e3_,i,pos$0,_e4_)}]}
      var _e0_=814535476;
      return function(_e1_){return aux(_e0_,pos,pos,_e1_)}}
    function split_seq(pos,len,re,s)
     {var seq=split_full_seq(pos,len,re,s);
      function filter(seq,param)
       {var seq$0=seq;
        for(;;)
         {var match=caml_call1(seq$0,0);
          if(match)
           {var _eW_=match[1];
            if(936573133 <= _eW_[1])
             {var tl=match[2],s=_eW_[2];
              return [0,s,function(_eX_){return filter(tl,_eX_)}]}
            var seq$1=match[2],seq$0=seq$1;
            continue}
          return 0}}
      return function(_eV_){return filter(seq,_eV_)}}
    function list_of_seq(s)
     {var _eS_=0;
      function _eT_(l,x){return [0,x,l]}
      var _eU_=caml_call3(Stdlib_seq[9],_eT_,_eS_,s);
      return caml_call1(Stdlib_list[9],_eU_)}
    function all$0(pos,len,re,s){return list_of_seq(all_seq(pos,len,re,s))}
    function matches(pos,len,re,s)
     {return list_of_seq(matches_seq(pos,len,re,s))}
    function split_full(pos,len,re,s)
     {return list_of_seq(split_full_seq(pos,len,re,s))}
    function split$0(pos,len,re,s)
     {return list_of_seq(split_seq(pos,len,re,s))}
    function gen_of_seq(s)
     {var r=[0,s];
      return function(param)
       {var match=caml_call1(r[1],0);
        if(match){var tl=match[2],x=match[1];r[1] = tl;return [0,x]}
        return 0}}
    function split_gen(pos,len,re,s)
     {return gen_of_seq(split_seq(pos,len,re,s))}
    function split_full_gen(pos,len,re,s)
     {return gen_of_seq(split_full_seq(pos,len,re,s))}
    function all_gen(pos,len,re,s){return gen_of_seq(all_seq(pos,len,re,s))}
    function matches_gen(pos,len,re,s)
     {return gen_of_seq(matches_seq(pos,len,re,s))}
    function replace(opt,len,_eO_,re,f,s)
     {if(opt)var sth=opt[1],pos=sth;else var pos=0;
      if(_eO_)var sth$0=_eO_[1],all=sth$0;else var all=1;
      if(pos < 0)caml_call1(Stdlib[1],cst_Re_replace);
      if(len)
       {var
         l=len[1],
         _eP_=l < 0?1:0,
         _eQ_=_eP_ || (caml_ml_string_length(s) < (pos + l | 0)?1:0);
        if(_eQ_)caml_call1(Stdlib[1],cst_Re_replace$0);
        var limit=pos + l | 0}
      else
       var limit=caml_ml_string_length(s);
      var buf=caml_call1(Stdlib_buffer[1],caml_ml_string_length(s)),pos$0=pos;
      for(;;)
       {if(pos$0 < limit)
         {var match=match_str(1,0,re,s,pos$0,limit - pos$0 | 0);
          if(typeof match === "number")
           {if(! match)
             caml_call4(Stdlib_buffer[16],buf,s,pos$0,limit - pos$0 | 0)}
          else
           {var
             substr=match[1],
             match$0=caml_call2(Group[2],substr,0),
             p2=match$0[2],
             p1=match$0[1];
            caml_call4(Stdlib_buffer[16],buf,s,pos$0,p1 - pos$0 | 0);
            var replacing=caml_call1(f,substr);
            caml_call2(Stdlib_buffer[14],buf,replacing);
            if(all)
             {if(p1 === p2)
               {if(p2 < limit)
                 {var _eR_=caml_string_get(s,p2);
                  caml_call2(Stdlib_buffer[10],buf,_eR_)}
                var pos$1=p2 + 1 | 0}
              else
               var pos$1=p2;
              var pos$0=pos$1;
              continue}
            caml_call4(Stdlib_buffer[16],buf,s,p2,limit - p2 | 0)}}
        return caml_call1(Stdlib_buffer[2],buf)}}
    function replace_string(pos,len,all,re,by,s)
     {return replace(pos,len,all,re,function(param){return by},s)}
    function witness(t)
     {function witness(param)
       {var param$0=param;
        for(;;)
         {if(typeof param$0 === "number")
           return cst$1;
          else
           switch(param$0[0])
            {case 0:
              var
               c=param$0[1],
               _eI_=pick(c),
               _eJ_=caml_call1(Stdlib_char[1],_eI_);
              return caml_call2(Stdlib_string[1],1,_eJ_);
             case 1:
              var xs=param$0[1],_eK_=caml_call2(Stdlib_list[17],witness,xs);
              return caml_call2(Stdlib_string[7],cst$2,_eK_);
             case 2:
              var _eL_=param$0[1];
              if(_eL_){var param$1=_eL_[1],param$0=param$1;continue}
              throw [0,Assert_failure,_cx_];
             case 3:
              var
               from=param$0[2],
               r=param$0[1],
               w=witness(r),
               b=
                caml_call1
                 (Stdlib_buffer[1],
                  runtime.caml_mul(caml_ml_string_length(w),from)),
               _eM_=1;
              if(! (from < 1))
               {var i=_eM_;
                for(;;)
                 {caml_call2(Stdlib_buffer[14],b,w);
                  var _eN_=i + 1 | 0;
                  if(from !== i){var i=_eN_;continue}
                  break}}
              return caml_call1(Stdlib_buffer[2],b);
             case 10:var param$3=param$0[1],param$0=param$3;continue;
             case 4:
             case 5:
             case 14:var param$2=param$0[2];break;
             case 11:
             case 12:
             case 13:throw [0,Assert_failure,_cy_];
             default:var param$2=param$0[1]}
          var param$0=param$2;
          continue}}
      return witness(handle_case(0,t))}
    var
     get$0=Group[1],
     get_ofs=Group[2],
     get_all=Group[5],
     get_all_ofs=Group[6],
     test$0=Group[7],
     Seq=[0,all_seq,matches_seq,split_seq,split_full_seq],
     Mark=[0,marked,Set,mark_set,equal$0,compare$1],
     include$0=
      [0,
       Group,
       compile,
       exec,
       exec_opt,
       execp,
       exec_partial,
       Mark,
       Seq,
       all$0,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split$0,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       replace,
       replace_string,
       str,
       char$0,
       alt$0,
       seq$1,
       empty$2,
       epsilon,
       rep$0,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start$0,
       stop$0,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first$0,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark$0,
       set,
       rg,
       inter$0,
       diff$0,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp$5,
       print_re,
       print_re,
       View,
       witness,
       get$0,
       get_ofs,
       get_all,
       get_all_ofs,
       test$0,
       marked,
       mark_set];
    caml_register_global(155,include$0,"Re__Core");
    var
     Parse_error=[248,cst_Re_Emacs_Parse_error,caml_fresh_oo_id(0)],
     Not_supported=[248,cst_Re_Emacs_Not_supported,caml_fresh_oo_id(0)];
    function re(opt$0,s)
     {if(opt$0)var sth=opt$0[1],case$0=sth;else var case$0=1;
      var i=[0,0],l=caml_ml_string_length(s);
      function eos$0(param){return i[1] === l?1:0}
      function test2(c$0,c)
       {var _eF_=(i[1] + 1 | 0) < l?1:0;
        if(_eF_)
         var
          _eG_=caml_string_get(s,i[1]) === c$0?1:0,
          _eH_=_eG_?caml_string_get(s,i[1] + 1 | 0) === c?1:0:_eG_;
        else
         var _eH_=_eF_;
        return _eH_}
      function accept(c)
       {var
         _eD_=1 - eos$0(0),
         _eE_=_eD_?caml_string_get(s,i[1]) === c?1:0:_eD_;
        if(_eE_)i[1]++;
        return _eE_}
      function accept2(c$0,c)
       {var r=test2(c$0,c);if(r)i[1] = i[1] + 2 | 0;return r}
      function get(param){var r=caml_string_get(s,i[1]);i[1]++;return r}
      function char$1(param){if(eos$0(0))throw Parse_error;return get(0)}
      function bracket(s)
       {var s$0=s;
        for(;;)
         {if(0 !== s$0 && accept(93))return s$0;
          var c=char$1(0);
          if(accept(45))
           {if(accept(93))
             {var _eC_=[0,char$0(45),s$0];return [0,char$0(c),_eC_]}
            var c$0=char$1(0),s$1=[0,rg(c,c$0),s$0],s$0=s$1;
            continue}
          var s$2=[0,char$0(c),s$0],s$0=s$2;
          continue}}
      function branch(param)
       {var left=0;
        for(;;)
         {if(! eos$0(0) && ! test2(92,124) && ! test2(92,41))
           {if(accept(46))
             var r=notnl;
            else
             if(accept(94))
              var r=bol;
             else
              if(accept(36))
               var r=eol;
              else
               if(accept(91))
                var r=accept(94)?compl(bracket(0)):alt$0(bracket(0));
               else
                if(accept(92))
                 if(accept(40))
                  {var r$0=regexp(0);
                   if(1 - accept2(92,41))throw Parse_error;
                   var r=[6,r$0]}
                 else
                  if(accept(96))
                   var r=bos;
                  else
                   if(accept(39))
                    var r=eos;
                   else
                    if(accept(61))
                     var r=start$0;
                    else
                     if(accept(98))
                      var r=alt$0([0,bow,[0,eow,0]]);
                     else
                      if(accept(66))
                       var r=not_boundary;
                      else
                       if(accept(60))
                        var r=bow;
                       else
                        if(accept(62))
                         var r=eow;
                        else
                         if(accept(119))
                          var r=alt$0([0,alnum,[0,char$0(95),0]]);
                         else
                          if(accept(87))
                           var r=compl([0,alnum,[0,char$0(95),0]]);
                          else
                           {if(eos$0(0))throw Parse_error;
                            var c=get(0),switch$0=0;
                            if(63 <= c)
                             {if(91 <= c)
                               {if(! (95 <= c))switch$0 = 1}
                              else
                               if(! (64 <= c))switch$0 = 1}
                            else
                             if(48 <= c)
                              {if(! (58 <= c))throw Not_supported}
                             else
                              if(36 <= c)
                               switch(c - 36 | 0)
                                {case 0:case 6:case 7:case 10:switch$0 = 1;break}
                            if(! switch$0)throw Parse_error;
                            var r=char$0(c)}
                else
                 {if(eos$0(0))throw Parse_error;
                  var c$0=get(0),switch$1=0;
                  if(44 <= c$0)
                   {if(63 === c$0)switch$1 = 1}
                  else
                   if(42 <= c$0)switch$1 = 1;
                  if(switch$1)throw Parse_error;
                  var r=char$0(c$0)}
            var
             _eB_=accept(42)?rep$0(r):accept(43)?rep1(r):accept(63)?opt(r):r,
             left$0=[0,_eB_,left],
             left=left$0;
            continue}
          return seq$1(caml_call1(Stdlib_list[9],left))}}
      function regexp(param)
       {var left=branch(0),left$0=left;
        for(;;)
         {if(accept2(92,124))
           {var left$1=alt$0([0,left$0,[0,branch(0),0]]),left$0=left$1;
            continue}
          return left$0}}
      var r=regexp(0);
      if(1 - eos$0(0))throw Parse_error;
      return case$0?r:[10,r]}
    function compile_pat(opt,s)
     {if(opt)var sth=opt[1],case$0=sth;else var case$0=1;
      return compile(re([0,case$0],s))}
    var Re_Emacs=[0,Parse_error,Not_supported,re,compile,compile_pat];
    caml_register_global(156,Re_Emacs,"Re__Emacs");
    function compile_regexp(s,c)
     {var
       re$0=re([0,1 - c],s),
       _ey_=[246,function(_eA_){return compile(re$0)}];
      return [0,
              re$0,
              [246,
               function(_ez_){return compile(seq$1([0,start$0,[0,re$0,0]]))}],
              _ey_]}
    var state=[0,0];
    function string_match(re,s,p)
     {try
       {var
         _et_=re[2],
         _eu_=caml_obj_tag(_et_),
         _ev_=
          250 === _eu_
           ?_et_[1]
           :246 === _eu_?caml_call1(CamlinternalLazy[2],_et_):_et_;
        state[1] = [0,exec([0,p],0,_ev_,s)];
        var _ew_=1;
        return _ew_}
      catch(_ex_)
       {_ex_ = caml_wrap_exception(_ex_);
        if(_ex_ === Stdlib[8]){state[1] = 0;return 0}
        throw _ex_}}
    function string_partial_match(re,s,p)
     {var
       _eq_=re[2],
       _er_=caml_obj_tag(_eq_),
       _es_=
        250 === _er_
         ?_eq_[1]
         :246 === _er_?caml_call1(CamlinternalLazy[2],_eq_):_eq_,
       match=exec_partial([0,p],0,_es_,s);
      return 782112175 === match?string_match(re,s,p):939392865 <= match?1:0}
    function search_forward(re,s,p)
     {try
       {var
         _el_=re[3],
         _em_=caml_obj_tag(_el_),
         _en_=
          250 === _em_
           ?_el_[1]
           :246 === _em_?caml_call1(CamlinternalLazy[2],_el_):_el_,
         res=exec([0,p],0,_en_,s);
        state[1] = [0,res];
        var _eo_=caml_call2(Group[2],res,0)[1];
        return _eo_}
      catch(_ep_)
       {_ep_ = caml_wrap_exception(_ep_);
        if(_ep_ === Stdlib[8]){state[1] = 0;throw Stdlib[8]}
        throw _ep_}}
    function search_backward(re,s,p)
     {var p$0=p;
      for(;;)
       try
        {var
          _eh_=re[2],
          _ei_=caml_obj_tag(_eh_),
          _ej_=
           250 === _ei_
            ?_eh_[1]
            :246 === _ei_?caml_call1(CamlinternalLazy[2],_eh_):_eh_,
          res=exec([0,p$0],0,_ej_,s);
         state[1] = [0,res];
         return p$0}
       catch(_ek_)
        {_ek_ = caml_wrap_exception(_ek_);
         if(_ek_ === Stdlib[8])
          {state[1] = 0;
           if(0 === p$0)throw Stdlib[8];
           var p$1=p$0 - 1 | 0,p$0=p$1;
           continue}
         throw _ek_}}
    function valid_group(n)
     {var _ed_=0 <= n?1:0;
      if(_ed_)
       {var _ee_=n < 10?1:0;
        if(_ee_)
         {var _ef_=state[1];
          if(_ef_){var m=_ef_[1];return n < caml_call1(Group[8],m)?1:0}
          var _eg_=0}
        else
         var _eg_=_ee_}
      else
       var _eg_=_ed_;
      return _eg_}
    function offset_group(i)
     {var _ec_=state[1];
      if(_ec_){var m=_ec_[1];return caml_call2(Group[2],m,i)}
      throw Stdlib[8]}
    function group_len(i)
     {try
       {var match=offset_group(i),e=match[2],b=match[1],_ea_=e - b | 0;
        return _ea_}
      catch(_eb_)
       {_eb_ = caml_wrap_exception(_eb_);
        if(_eb_ === Stdlib[8])return 0;
        throw _eb_}}
    function replace$0(orig,repl,p,res,q,len)
     {var p$0=p,q$0=q;
      for(;;)
       {var _d9_=p$0 < len?1:0;
        if(_d9_)
         {var c=caml_string_get(repl,p$0);
          if(92 === c)
           {var c$0=caml_string_get(repl,p$0 + 1 | 0);
            if(58 <= c$0)
             {if(92 === c$0)
               {caml_bytes_set(res,q$0,92);
                var q$1=q$0 + 1 | 0,p$1=p$0 + 2 | 0,p$0=p$1,q$0=q$1;
                continue}}
            else
             if(48 <= c$0)
              {try
                {var
                  match=offset_group(c$0 - 48 | 0),
                  e=match[2],
                  b=match[1],
                  d$0=e - b | 0;
                 if(0 < d$0)caml_call5(Stdlib_string[6],orig,b,res,q$0,d$0);
                 var d=d$0}
               catch(_d$_)
                {_d$_ = caml_wrap_exception(_d$_);
                 if(_d$_ !== Stdlib[8])throw _d$_;
                 var d=0,_d__=_d$_}
               var q$3=q$0 + d | 0,p$3=p$0 + 2 | 0,p$0=p$3,q$0=q$3;
               continue}
            caml_bytes_set(res,q$0,92);
            caml_bytes_set(res,q$0 + 1 | 0,c$0);
            var q$2=q$0 + 2 | 0,p$2=p$0 + 2 | 0,p$0=p$2,q$0=q$2;
            continue}
          caml_bytes_set(res,q$0,c);
          var q$4=q$0 + 1 | 0,p$4=p$0 + 1 | 0,p$0=p$4,q$0=q$4;
          continue}
        return _d9_}}
    function replacement_text(repl,orig)
     {var len=caml_ml_string_length(repl),p=0,q=0;
      for(;;)
       {if(p < len)
         {if(92 === caml_string_get(repl,p))
           {var p$0=p + 1 | 0;
            if(p$0 === len)
             caml_call1(Stdlib[2],cst_Str_replace_illegal_backsl);
            var c=caml_string_get(repl,p$0),switch$0=0;
            if(58 <= c)
             if(92 === c)var q$0=q + 1 | 0;else switch$0 = 1;
            else
             if(48 <= c)
              var q$0=q + group_len(c - 48 | 0) | 0;
             else
              switch$0 = 1;
            if(switch$0)var q$0=q + 2 | 0;
            var p$1=p$0 + 1 | 0,p=p$1,q=q$0;
            continue}
          var q$1=q + 1 | 0,p$2=p + 1 | 0,p=p$2,q=q$1;
          continue}
        var res=caml_create_bytes(q);
        replace$0(orig,repl,0,res,0,caml_ml_string_length(repl));
        return caml_call1(Stdlib_bytes[42],res)}}
    function quote$0(s)
     {var
       len=caml_ml_string_length(s),
       buf=caml_call1(Stdlib_buffer[1],2 * len | 0),
       _d5_=len - 1 | 0,
       _d4_=0;
      if(! (_d5_ < 0))
       {var i=_d4_;
        for(;;)
         {var c=caml_string_get(s,i),_d6_=c - 63 | 0,switch$0=0;
          if(31 < _d6_ >>> 0)
           {var _d7_=_d6_ + 27 | 0;
            if(! (10 < _d7_ >>> 0))
             switch(_d7_){case 0:case 6:case 7:case 10:switch$0 = 1;break}}
          else
           if(26 < (_d6_ - 1 | 0) >>> 0)switch$0 = 1;
          if(switch$0)
           {caml_call2(Stdlib_buffer[10],buf,92);
            caml_call2(Stdlib_buffer[10],buf,c)}
          else
           caml_call2(Stdlib_buffer[10],buf,c);
          var _d8_=i + 1 | 0;
          if(_d5_ !== i){var i=_d8_;continue}
          break}}
      return caml_call1(Stdlib_buffer[2],buf)}
    function string_before(s,n){return caml_call3(Stdlib_string[4],s,0,n)}
    function string_after(s,n)
     {return caml_call3(Stdlib_string[4],s,n,caml_ml_string_length(s) - n | 0)}
    function first_chars(s,n){return caml_call3(Stdlib_string[4],s,0,n)}
    function last_chars(s,n)
     {return caml_call3(Stdlib_string[4],s,caml_ml_string_length(s) - n | 0,n)}
    function regexp(e){return compile_regexp(e,0)}
    function regexp_case_fold(e){return compile_regexp(e,1)}
    function regexp_string(s){return compile_regexp(quote$0(s),0)}
    function regexp_string_case_fold(s){return compile_regexp(quote$0(s),1)}
    function group_beginning(n)
     {if(1 - valid_group(n))caml_call1(Stdlib[1],cst_Str_group_beginning);
      var pos=offset_group(n)[1];
      if(-1 === pos)throw Stdlib[8];
      return pos}
    function group_end(n)
     {if(1 - valid_group(n))caml_call1(Stdlib[1],cst_Str_group_end);
      var pos=offset_group(n)[2];
      if(-1 === pos)throw Stdlib[8];
      return pos}
    function matched_group(n,txt)
     {var match=offset_group(n),e=match[2],b=match[1];
      return caml_call3(Stdlib_string[4],txt,b,e - b | 0)}
    function replace_matched(repl,matched)
     {return replacement_text(repl,matched)}
    function match_beginning(param){return group_beginning(0)}
    function match_end(param){return group_end(0)}
    function matched_string(txt){return matched_group(0,txt)}
    function substitute_first(expr,repl_fun,text)
     {try
       {var
         pos=search_forward(expr,text,0),
         _dZ_=[0,string_after(text,match_end(0)),0],
         _d0_=[0,caml_call1(repl_fun,text),_dZ_],
         _d1_=[0,string_before(text,pos),_d0_],
         _d2_=caml_call2(Stdlib_string[7],cst$3,_d1_);
        return _d2_}
      catch(_d3_)
       {_d3_ = caml_wrap_exception(_d3_);
        if(_d3_ === Stdlib[8])return text;
        throw _d3_}}
    function global_substitute(expr,repl_fun,text)
     {function replace(accu,start,last_was_empty)
       {try
         {var startpos=last_was_empty?start + 1 | 0:start;
          if(caml_ml_string_length(text) < startpos)throw Stdlib[8];
          var
           pos=search_forward(expr,text,startpos),
           end_pos=match_end(0),
           repl_text=caml_call1(repl_fun,text),
           _dX_=
            replace
             ([0,
               repl_text,
               [0,
                caml_call3(Stdlib_string[4],text,start,pos - start | 0),
                accu]],
              end_pos,
              end_pos === pos?1:0);
          return _dX_}
        catch(_dY_)
         {_dY_ = caml_wrap_exception(_dY_);
          if(_dY_ === Stdlib[8])return [0,string_after(text,start),accu];
          throw _dY_}}
      var _dV_=replace(0,0,0),_dW_=caml_call1(Stdlib_list[9],_dV_);
      return caml_call2(Stdlib_string[7],cst$4,_dW_)}
    function global_replace(expr,repl,text)
     {return global_substitute
              (expr,function(_dU_){return replacement_text(repl,_dU_)},text)}
    function replace_first(expr,repl,text)
     {return substitute_first
              (expr,function(_dT_){return replacement_text(repl,_dT_)},text)}
    function search_forward_progress(re,s,p)
     {var pos=search_forward(re,s,p);
      if(p < match_end(0))return pos;
      if(p < caml_ml_string_length(s))return search_forward(re,s,p + 1 | 0);
      throw Stdlib[8]}
    function bounded_split(expr,text,num)
     {var start=string_match(expr,text,0)?match_end(0):0;
      function split(accu,start,n)
       {if(caml_ml_string_length(text) <= start)return accu;
        if(1 === n)return [0,string_after(text,start),accu];
        try
         {var
           pos=search_forward_progress(expr,text,start),
           _dQ_=match_end(0),
           _dR_=
            split
             ([0,caml_call3(Stdlib_string[4],text,start,pos - start | 0),accu],
              _dQ_,
              n - 1 | 0);
          return _dR_}
        catch(_dS_)
         {_dS_ = caml_wrap_exception(_dS_);
          if(_dS_ === Stdlib[8])return [0,string_after(text,start),accu];
          throw _dS_}}
      var _dP_=split(0,start,num);
      return caml_call1(Stdlib_list[9],_dP_)}
    function split$1(expr,text){return bounded_split(expr,text,0)}
    function bounded_split_delim(expr,text,num)
     {function split(accu,start,n)
       {if(caml_ml_string_length(text) < start)return accu;
        if(1 === n)return [0,string_after(text,start),accu];
        try
         {var
           pos=search_forward_progress(expr,text,start),
           _dM_=match_end(0),
           _dN_=
            split
             ([0,caml_call3(Stdlib_string[4],text,start,pos - start | 0),accu],
              _dM_,
              n - 1 | 0);
          return _dN_}
        catch(_dO_)
         {_dO_ = caml_wrap_exception(_dO_);
          if(_dO_ === Stdlib[8])return [0,string_after(text,start),accu];
          throw _dO_}}
      if(runtime.caml_string_equal(text,cst$5))return 0;
      var _dL_=split(0,0,num);
      return caml_call1(Stdlib_list[9],_dL_)}
    function split_delim(expr,text){return bounded_split_delim(expr,text,0)}
    function bounded_full_split(expr,text,num)
     {function split(accu,start,n)
       {if(caml_ml_string_length(text) <= start)return accu;
        if(1 === n)return [0,[0,string_after(text,start)],accu];
        try
         {var
           pos=search_forward_progress(expr,text,start),
           s=matched_string(text);
          if(start < pos)
           var
            _dI_=match_end(0),
            _dJ_=
             split
              ([0,
                [1,s],
                [0,
                 [0,caml_call3(Stdlib_string[4],text,start,pos - start | 0)],
                 accu]],
               _dI_,
               n - 1 | 0);
          else
           var _dJ_=split([0,[1,s],accu],match_end(0),n - 1 | 0);
          return _dJ_}
        catch(_dK_)
         {_dK_ = caml_wrap_exception(_dK_);
          if(_dK_ === Stdlib[8])return [0,[0,string_after(text,start)],accu];
          throw _dK_}}
      var _dH_=split(0,0,num);
      return caml_call1(Stdlib_list[9],_dH_)}
    function full_split(expr,text){return bounded_full_split(expr,text,0)}
    var
     Re_Str=
      [0,
       regexp,
       regexp_case_fold,
       quote$0,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split$1,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
    caml_register_global(158,Re_Str,"Re__Str");
    var Parse_error$0=[248,cst_Re_Glob_Parse_error,caml_fresh_oo_id(0)];
    function mul(l$0,l)
     {function _dE_(s)
       {function _dG_(s$0){return caml_call2(Stdlib[28],s,s$0)}
        return caml_call2(Stdlib_list[17],_dG_,l)}
      var _dF_=caml_call2(Stdlib_list[17],_dE_,l$0);
      return caml_call1(Stdlib_list[14],_dF_)}
    function explicit_period(t)
     {var _dA_=t[6];
      if(_dA_)
       {var _dB_=t[3];
        if(_dB_)var _dC_=_dB_;else var _dD_=t[4],_dC_=_dD_?t[5]:_dD_}
      else
       var _dC_=_dA_;
      return _dC_}
    function append(opt,t,piece)
     {if(opt)
       var sth=opt[1],am_at_start_of_component=sth;
      else
       var am_at_start_of_component=0;
      return [0,[0,piece,t[1]],t[2],0,am_at_start_of_component,t[5],t[6]]}
    function next(t)
     {var _dz_=t[2];
      if(_dz_)
       {var remaining=_dz_[2],piece=_dz_[1];
        return [0,[0,piece,[0,t[1],remaining,t[3],t[4],t[5],t[6]]]]}
      return 0}
    function one(explicit_slash,explicit_period)
     {var
       _dv_=0,
       _dw_=explicit_period?[0,char$0(46),0]:0,
       _dx_=[0,_dw_,_dv_],
       _dy_=explicit_slash?[0,char$0(47),0]:0;
      return compl(caml_call1(Stdlib_list[13],[0,_dy_,_dx_]))}
    function enclosed(enclosed)
     {if(0 === enclosed[0]){var c=enclosed[1];return char$0(c)}
      var high=enclosed[2],low=enclosed[1];
      return rg(low,high)}
    function enclosed_set(explicit_slash,explicit_period,kind,set)
     {var
       set$0=caml_call2(Stdlib_list[17],enclosed,set),
       enclosure=596216810 <= kind?alt$0(set$0):compl(set$0);
      return inter$0([0,enclosure,[0,one(explicit_slash,explicit_period),0]])}
    function exactly(state,c){return append([0,47 === c?1:0],state,char$0(c))}
    function glob(opt$0,_dj_,_di_,_dh_,s)
     {if(opt$0)var sth=opt$0[1],anchored=sth;else var anchored=0;
      if(_dj_)var sth$0=_dj_[1],pathname=sth$0;else var pathname=1;
      if(_di_)var sth$1=_di_[1],period=sth$1;else var period=1;
      if(_dh_)var sth$2=_dh_[1],expand_braces=sth$2;else var expand_braces=0;
      function to_re(s)
       {var i=[0,0],l=caml_ml_string_length(s);
        function eos(param){return i[1] === l?1:0}
        function read(c)
         {var _du_=1 - eos(0),r=_du_?caml_string_get(s,i[1]) === c?1:0:_du_;
          if(r)i[1]++;
          return r}
        function char$0(param)
         {read(92);
          if(eos(0))throw Parse_error$0;
          var r=caml_string_get(s,i[1]);
          i[1]++;
          return r}
        function enclosed(param)
         {var s=0;
          for(;;)
           {if(0 !== s && read(93))return s;
            var c=char$0(0);
            if(read(45))
             {if(read(93))return [0,[0,c],[0,_cz_,s]];
              var c$0=char$0(0),s$0=[0,[1,c,c$0],s],s=s$0;
              continue}
            var s$1=[0,[0,c],s],s=s$1;
            continue}}
        var pieces=0;
        for(;;)
         {if(eos(0))
           {var
             glob=caml_call1(Stdlib_list[9],pieces),
             state=[0,0,glob,1,1,pathname,period],
             state$7=state;
            for(;;)
             {var match$0=next(state$7);
              if(match$0)
               {var
                 match$1=match$0[1],
                 state$8=match$1[2],
                 p=match$1[1],
                 explicit_slash$0=state$8[5],
                 explicit_period$1=explicit_period(state$8);
                if(typeof p === "number")
                 if(0 === p)
                  var
                   state$9=
                    append(0,state$8,one(explicit_slash$0,explicit_period$1));
                 else
                  {var
                    explicit_slash=state$8[5],
                    explicit_period$0=explicit_period(state$8);
                   if(explicit_period$0)
                    if(explicit_slash)
                     {var
                       _dn_=[0,rep$0(one(1,0)),0],
                       not_empty=seq$1([0,one(1,1),_dn_]),
                       maybe_empty=opt(not_empty),
                       enclosed_set$1=
                        function(not_empty)
                         {function enclosed_set$0(state,kind,set)
                           {var
                             _dt_=
                              [0,seq$1([0,not_empty,[0,enclosed_set(1,0,kind,set),0]]),0];
                            return append
                                    (0,state,alt$0([0,enclosed_set(1,1,kind,set),_dt_]))}
                          return enclosed_set$0},
                       enclosed_set$0=enclosed_set$1(not_empty),
                       state$0=state$8;
                      for(;;)
                       {var match=next(state$0);
                        if(match)
                         {var _do_=match[1],_dp_=_do_[1];
                          if(typeof _dp_ === "number")
                           {if(0 !== _dp_)
                             {var state$2=_do_[2],state$0=state$2;continue}
                            var state$1=_do_[2],_dq_=append(0,state$1,not_empty)}
                          else
                           switch(_dp_[0])
                            {case 0:
                              var
                               state$3=_do_[2],
                               c=_dp_[1],
                               not_empty$0=46 === c?not_empty:maybe_empty,
                               state$4=append(0,state$3,not_empty$0),
                               _dq_=exactly(state$4,c);
                              break;
                             case 1:
                              var
                               state$5=_do_[2],
                               enclosed$0=_dp_[1],
                               _dq_=enclosed_set$0(state$5,596216810,enclosed$0);
                              break;
                             default:
                              var
                               state$6=_do_[2],
                               enclosed$1=_dp_[1],
                               _dq_=enclosed_set$0(state$6,-188280562,enclosed$1)}}
                        else
                         var _dq_=append(0,state$0,maybe_empty);
                        var _ds_=_dq_;
                        break}}
                    else
                     var
                      _dr_=[0,rep$0(one(0,0)),0],
                      _ds_=
                       append
                        (0,state$8,opt(seq$1([0,one(0,explicit_period$0),_dr_])));
                   else
                    var
                     _ds_=
                      append
                       (0,state$8,rep$0(one(explicit_slash,explicit_period$0)));
                   var state$9=_ds_}
                else
                 switch(p[0])
                  {case 0:var c$0=p[1],state$9=exactly(state$8,c$0);break;
                   case 1:
                    var
                     enclosed$2=p[1],
                     state$9=
                      append
                       (0,
                        state$8,
                        enclosed_set
                         (explicit_slash$0,explicit_period$1,596216810,enclosed$2));
                    break;
                   default:
                    var
                     enclosed$3=p[1],
                     state$9=
                      append
                       (0,
                        state$8,
                        enclosed_set
                         (explicit_slash$0,explicit_period$1,-188280562,enclosed$3))}
                var state$7=state$9;
                continue}
              var re=seq$1(caml_call1(Stdlib_list[9],state$7[1]));
              return anchored?whole_string(re):re}}
          if(read(42))
           var _dm_=1;
          else
           if(read(63))
            var _dm_=0;
           else
            if(read(91))
             {var switch$0=0;
              if(read(94) || read(33))
               switch$0 = 1;
              else
               var _dm_=[1,enclosed(0)];
              if(switch$0)var _dm_=[2,enclosed(0)]}
            else
             var _dm_=[0,char$0(0)];
          var pieces$0=[0,_dm_,pieces],pieces=pieces$0;
          continue}}
      if(expand_braces)
       {var
         l=caml_ml_string_length(s),
         expl=
          function(inner,s$0,i,acc,beg$0)
           {var s$1=s$0,i$0=i,acc$0=acc,beg$1=beg$0;
            for(;;)
             {if(l <= i$0)
               {if(inner)throw Parse_error$0;
                return [0,
                        mul
                         (beg$1,
                          [0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0]),
                        i$0]}
              var match=caml_string_get(s,i$0);
              if(44 === match)
               {if(inner)
                 {var
                   _dk_=
                    mul
                     (beg$1,
                      [0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0]),
                   acc$1=caml_call2(Stdlib[37],_dk_,acc$0),
                   i$1=i$0 + 1 | 0,
                   s$2=i$0 + 1 | 0,
                   s$1=s$2,
                   i$0=i$1,
                   acc$0=acc$1,
                   beg$1=beg;
                  continue}}
              else
               if(123 <= match)
                {if(! (126 <= match))
                  {var switcher=match - 123 | 0;
                   switch(switcher)
                    {case 0:
                      var
                       match$0=expl(1,i$0 + 1 | 0,i$0 + 1 | 0,0,_cA_),
                       i$3=match$0[2],
                       t=match$0[1],
                       beg$2=
                        mul
                         (beg$1,
                          mul
                           ([0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0],t)),
                       s$1=i$3,
                       i$0=i$3,
                       beg$1=beg$2;
                      continue;
                     case 1:break;
                     default:
                      if(inner)
                       {var
                         _dl_=
                          mul
                           (beg$1,
                            [0,caml_call3(Stdlib_string[4],s,s$1,i$0 - s$1 | 0),0]);
                        return [0,caml_call2(Stdlib[37],_dl_,acc$0),i$0 + 1 | 0]}}}}
               else
                if(92 === match){var i$4=i$0 + 2 | 0,i$0=i$4;continue}
              var i$2=i$0 + 1 | 0,i$0=i$2;
              continue}},
         _df_=expl(0,0,0,0,_cB_)[1],
         _dg_=caml_call1(Stdlib_list[9],_df_);
        return alt$0(caml_call2(Stdlib_list[17],to_re,_dg_))}
      return to_re(s)}
    function glob$0(anchored,period,s){return glob(anchored,0,[0,period],0,s)}
    function globx(anchored,s){return glob(anchored,0,0,_cC_,s)}
    function globx$0(anchored,period,s)
     {return glob(anchored,0,[0,period],_cD_,s)}
    var Re_Glob=[0,Parse_error$0,glob,glob$0,globx,globx$0];
    caml_register_global(159,Re_Glob,"Re__Glob");
    var
     Parse_error$1=[248,cst_Re_Perl_Parse_error,caml_fresh_oo_id(0)],
     Not_supported$0=[248,cst_Re_Perl_Not_supported,caml_fresh_oo_id(0)];
    function posix_class_of_string(class$0)
     {var switch$0=runtime.caml_string_compare(class$0,cst_lower);
      if(0 <= switch$0)
       {if(! (0 < switch$0))return lower;
        if(! caml_string_notequal(class$0,cst_print))return print;
        if(! caml_string_notequal(class$0,cst_punct))return punct;
        if(! caml_string_notequal(class$0,cst_space))return space;
        if(! caml_string_notequal(class$0,cst_upper))return upper;
        if(! caml_string_notequal(class$0,cst_word))return wordc;
        if(! caml_string_notequal(class$0,cst_xdigit))return xdigit}
      else
       {if(! caml_string_notequal(class$0,cst_alnum))return alnum;
        if(! caml_string_notequal(class$0,cst_ascii))return ascii;
        if(! caml_string_notequal(class$0,cst_blank))return blank;
        if(! caml_string_notequal(class$0,cst_cntrl))return cntrl;
        if(! caml_string_notequal(class$0,cst_digit))return digit;
        if(! caml_string_notequal(class$0,cst_graph))return graph}
      var _de_=caml_call2(Stdlib[28],cst_Invalid_pcre_class,class$0);
      return caml_call1(Stdlib[1],_de_)}
    function re$0(opt$0,s)
     {if(opt$0)var sth=opt$0[1],opts=sth;else var opts=0;
      var
       ungreedy=caml_call2(Stdlib_list[35],-243745063,opts),
       dotall=caml_call2(Stdlib_list[35],-424303016,opts),
       dollar_endonly=caml_call2(Stdlib_list[35],-712595228,opts),
       multiline=caml_call2(Stdlib_list[35],1071952589,opts),
       i=[0,0],
       l=caml_ml_string_length(s);
      function eos$0(param){return i[1] === l?1:0}
      function test(c)
       {var
         _dc_=1 - eos$0(0),
         _dd_=_dc_?caml_string_get(s,i[1]) === c?1:0:_dc_;
        return _dd_}
      function accept(c){var r=test(c);if(r)i[1]++;return r}
      function accept_s(s$0)
       {var len=caml_ml_string_length(s$0);
        try
         {var _c8_=len - 1 | 0,_c7_=0;
          if(! (_c8_ < 0))
           {var j=_c7_;
            for(;;)
             {try
               {var _c__=caml_string_get(s,i[1] + j | 0);
                if(caml_string_get(s$0,j) !== _c__)throw Stdlib[3]}
              catch(_db_){throw Stdlib[3]}
              var _c$_=j + 1 | 0;
              if(_c8_ !== j){var j=_c$_;continue}
              break}}
          i[1] = i[1] + len | 0;
          var _c9_=1;
          return _c9_}
        catch(_da_)
         {_da_ = caml_wrap_exception(_da_);
          if(_da_ === Stdlib[3])return 0;
          throw _da_}}
      function get(param){var r=caml_string_get(s,i[1]);i[1]++;return r}
      function unget(param){i[1] += -1;return 0}
      function greedy_mod(r)
       {var gr=accept(63),gr$0=ungreedy?1 - gr:gr;
        return gr$0?non_greedy(r):greedy(r)}
      function char$1(param)
       {if(eos$0(0))throw Parse_error$1;
        var c=get(0);
        if(91 === c)
         {if(accept(61))throw Not_supported$0;
          if(accept(58))
           {var compl$0=accept(94);
            try
             {var cls=caml_call2(Stdlib_list[36],accept_s,posix_class_strings)}
            catch(_c6_)
             {_c6_ = caml_wrap_exception(_c6_);
              if(_c6_ === Stdlib[8])throw Parse_error$1;
              throw _c6_}
            if(1 - accept_s(cst$6))throw Parse_error$1;
            var
             posix_class=posix_class_of_string(cls),
             re=compl$0?compl([0,posix_class,0]):posix_class;
            return [0,4150146,re]}
          if(accept(46))
           {if(eos$0(0))throw Parse_error$1;
            var c$0=get(0);
            if(1 - accept(46))throw Not_supported$0;
            if(1 - accept(93))throw Parse_error$1;
            return [0,748194550,c$0]}
          return [0,748194550,c]}
        if(92 === c)
         {if(eos$0(0))throw Parse_error$1;
          var c$1=get(0);
          if(58 <= c$1)
           {if(! (123 <= c$1))
             {var switcher=c$1 - 58 | 0;
              switch(switcher)
               {case 10:return [0,4150146,compl([0,digit,0])];
                case 25:return [0,4150146,compl([0,space,0])];
                case 29:return [0,4150146,compl([0,alnum,[0,char$0(95),0]])];
                case 40:return _cE_;
                case 42:return [0,4150146,digit];
                case 52:return _cF_;
                case 56:return _cG_;
                case 57:return [0,4150146,space];
                case 58:return _cH_;
                case 61:return [0,4150146,alt$0([0,alnum,[0,char$0(95),0]])];
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:break;
                default:throw Parse_error$1}}}
          else
           if(48 <= c$1)throw Not_supported$0;
          return [0,748194550,c$1]}
        return [0,748194550,c]}
      function bracket(s)
       {var s$0=s;
        for(;;)
         {if(0 !== s$0 && accept(93))return s$0;
          var match=char$1(0);
          if(748194550 <= match[1])
           {var c=match[2];
            if(accept(45))
             {if(accept(93))
               {var _c4_=[0,char$0(45),s$0];return [0,char$0(c),_c4_]}
              var match$0=char$1(0);
              if(748194550 <= match$0[1])
               {var c$0=match$0[2],s$1=[0,rg(c,c$0),s$0],s$0=s$1;continue}
              var
               st=match$0[2],
               _c5_=[0,char$0(45),[0,st,s$0]],
               s$2=[0,char$0(c),_c5_],
               s$0=s$2;
              continue}
            var s$3=[0,char$0(c),s$0],s$0=s$3;
            continue}
          var st$0=match[2],s$4=[0,st$0,s$0],s$0=s$4;
          continue}}
      function integer(param)
       {if(eos$0(0))return 0;
        var d=get(0),switcher=d - 48 | 0;
        if(9 < switcher >>> 0){unget(0);return 0}
        var i=d - 48 | 0,i$0=i;
        for(;;)
         {if(eos$0(0))return [0,i$0];
          var d$0=get(0),switcher$0=d$0 - 48 | 0;
          if(9 < switcher$0 >>> 0){unget(0);return [0,i$0]}
          var i$1=(10 * i$0 | 0) + (d$0 - 48 | 0) | 0;
          if(i$1 < i$0)throw Parse_error$1;
          var i$0=i$1;
          continue}}
      function branch(param)
       {var left=0;
        for(;;)
         {if(! eos$0(0) && ! test(124) && ! test(41))
           {if(accept(46))
             var r=dotall?any:notnl;
            else
             if(accept(40))
              if(accept(63))
               if(accept(58))
                {var r$0=regexp(0);
                 if(1 - accept(41))throw Parse_error$1;
                 var r=r$0}
               else
                {if(! accept(35))throw Parse_error$1;
                 for(;;)
                  {if(eos$0(0))throw Parse_error$1;
                   if(! accept(41)){i[1]++;continue}
                   var r=epsilon;
                   break}}
              else
               {var r$1=regexp(0);
                if(1 - accept(41))throw Parse_error$1;
                var r=[6,r$1]}
             else
              if(accept(94))
               var r=multiline?bol:bos;
              else
               if(accept(36))
                var r=multiline?eol:dollar_endonly?leol:eos;
               else
                if(accept(91))
                 var r=accept(94)?compl(bracket(0)):alt$0(bracket(0));
                else
                 if(accept(92))
                  {if(eos$0(0))throw Parse_error$1;
                   var c=get(0),switcher=c - 48 | 0,switch$0=0;
                   if(74 < switcher >>> 0)
                    switch$0 = 1;
                   else
                    switch(switcher)
                     {case 17:var r=bos;break;
                      case 18:var r=not_boundary;break;
                      case 20:var r=compl([0,digit,0]);break;
                      case 23:var r=start$0;break;
                      case 35:var r=compl([0,space,0]);break;
                      case 39:var r=compl([0,alnum,[0,char$0(95),0]]);break;
                      case 42:var r=leol;break;
                      case 50:var r=alt$0([0,bow,[0,eow,0]]);break;
                      case 52:var r=digit;break;
                      case 67:var r=space;break;
                      case 71:var r=alt$0([0,alnum,[0,char$0(95),0]]);break;
                      case 74:var r=eos;break;
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                      case 8:
                      case 9:throw Not_supported$0;
                      case 10:
                      case 11:
                      case 12:
                      case 13:
                      case 14:
                      case 15:
                      case 16:
                      case 43:
                      case 44:
                      case 45:
                      case 46:
                      case 47:
                      case 48:switch$0 = 1;break;
                      default:throw Parse_error$1}
                   if(switch$0)var r=char$0(c)}
                 else
                  {if(eos$0(0))throw Parse_error$1;
                   var c$0=get(0),switch$1=0;
                   if(64 <= c$0)
                    {if(92 !== c$0 && 123 !== c$0)switch$1 = 1}
                   else
                    if(44 <= c$0)
                     {if(! (63 <= c$0))switch$1 = 1}
                    else
                     if(! (42 <= c$0))switch$1 = 1;
                   if(! switch$1)throw Parse_error$1;
                   var r=char$0(c$0)}
            if(accept(42))
             var _c3_=greedy_mod(rep$0(r));
            else
             if(accept(43))
              var _c3_=greedy_mod(rep1(r));
             else
              if(accept(63))
               var _c3_=greedy_mod(opt(r));
              else
               if(accept(123))
                {var match=integer(0);
                 if(match)
                  {var i$0=match[1],j=accept(44)?integer(0):[0,i$0];
                   if(1 - accept(125))throw Parse_error$1;
                   if(j){var j$0=j[1];if(j$0 < i$0)throw Parse_error$1}
                   var _c3_=greedy_mod(repn(r,i$0,j))}
                 else
                  {unget(0);var _c3_=r}}
               else
                var _c3_=r;
            var left$0=[0,_c3_,left],left=left$0;
            continue}
          return seq$1(caml_call1(Stdlib_list[9],left))}}
      function regexp(param)
       {var left=branch(0),left$0=left;
        for(;;)
         {if(accept(124))
           {var left$1=alt$0([0,left$0,[0,branch(0),0]]),left$0=left$1;
            continue}
          return left$0}}
      var r=regexp(0);
      if(1 - eos$0(0))throw Parse_error$1;
      var
       r$0=
        caml_call2(Stdlib_list[35],616470068,opts)
         ?seq$1([0,start$0,[0,r,0]])
         :r,
       r$1=caml_call2(Stdlib_list[35],604571177,opts)?[10,r$0]:r$0;
      return r$1}
    function compile_pat$0(opt,s)
     {if(opt)var sth=opt[1],opts=sth;else var opts=0;
      return compile(re$0([0,opts],s))}
    var Re_Perl=[0,Parse_error$1,Not_supported$0,re$0,compile,compile_pat$0];
    caml_register_global(160,Re_Perl,"Re__Perl");
    function re$1(opt,pat)
     {if(opt)var sth=opt[1],flags=sth;else var flags=0;
      function _c2_(param)
       {return 601676297 === param
                ?604571177
                :613575188 <= param?616470068:1071952589}
      var opts=caml_call2(Stdlib_list[17],_c2_,flags);
      return re$0([0,opts],pat)}
    function regexp$0(flags,pat){return compile(re$1(flags,pat))}
    function extract(rex,s)
     {var _c1_=exec(0,0,rex,s);return caml_call1(Group[5],_c1_)}
    function exec$0(rex,pos,s){return exec(pos,0,rex,s)}
    function get_substring(s,i){return caml_call2(Group[1],s,i)}
    function get_substring_ofs(s,i){return caml_call2(Group[2],s,i)}
    function pmatch(rex,s){return execp(0,0,rex,s)}
    function substitute(rex,subst,str)
     {var b=caml_call1(Stdlib_buffer[1],1024),pos=0;
      for(;;)
       {if(caml_ml_string_length(str) <= pos)
         return caml_call1(Stdlib_buffer[2],b);
        if(execp([0,pos],0,rex,str))
         {var
           ss=exec([0,pos],0,rex,str),
           match=caml_call2(Group[2],ss,0),
           fin=match[2],
           start=match[1],
           pat=caml_call2(Group[1],ss,0);
          caml_call4(Stdlib_buffer[16],b,str,pos,start - pos | 0);
          var _c0_=caml_call1(subst,pat);
          caml_call2(Stdlib_buffer[14],b,_c0_);
          var pos=fin;
          continue}
        caml_call4
         (Stdlib_buffer[16],b,str,pos,caml_ml_string_length(str) - pos | 0);
        var pos$0=caml_ml_string_length(str),pos=pos$0;
        continue}}
    function split$2(rex,str)
     {var accu=0,pos=0;
      for(;;)
       {if(caml_ml_string_length(str) <= pos)
         return caml_call1(Stdlib_list[9],accu);
        if(execp([0,pos],0,rex,str))
         {var
           ss=exec([0,pos],0,rex,str),
           match=caml_call2(Group[2],ss,0),
           fin=match[2],
           start=match[1],
           s=caml_call3(Stdlib_string[4],str,pos,start - pos | 0),
           accu$0=[0,s,accu],
           accu=accu$0,
           pos=fin;
          continue}
        var
         s$0=
          caml_call3
           (Stdlib_string[4],str,pos,caml_ml_string_length(str) - pos | 0),
         pos$0=caml_ml_string_length(str),
         accu$1=[0,s$0,accu],
         accu=accu$1,
         pos=pos$0;
        continue}}
    function quote$1(s)
     {var
       len=caml_ml_string_length(s),
       s$0=caml_create_bytes(len << 1),
       pos=[0,0],
       _cW_=len - 1 | 0,
       _cV_=0;
      if(! (_cW_ < 0))
       {var i=_cV_;
        for(;;)
         {var c=runtime.caml_string_unsafe_get(s,i),switch$0=0;
          if(91 <= c)
           {var _cY_=c - 93 | 0;
            if(29 < _cY_ >>> 0)
             {if(! (32 <= _cY_))switch$0 = 1}
            else
             if(1 === _cY_)switch$0 = 1}
          else
           if(47 <= c)
            {if(63 === c)switch$0 = 1}
           else
            if(36 <= c)
             switch(c - 36 | 0)
              {case 1:case 2:case 3:case 8:case 9:break;default:switch$0 = 1}
          if(switch$0)
           {caml_bytes_unsafe_set(s$0,pos[1],92);
            pos[1]++;
            caml_bytes_unsafe_set(s$0,pos[1],c);
            pos[1]++}
          else
           {caml_bytes_unsafe_set(s$0,pos[1],c);pos[1]++}
          var _cZ_=i + 1 | 0;
          if(_cW_ !== i){var i=_cZ_;continue}
          break}}
      var _cX_=pos[1],r=caml_create_bytes(_cX_);
      runtime.caml_blit_bytes(s$0,0,r,0,_cX_);
      return caml_call1(Stdlib_bytes[42],r)}
    function full_split$0(opt,rex,s)
     {if(opt)var sth=opt[1],max=sth;else var max=0;
      if(0 === caml_ml_string_length(s))return 0;
      if(1 === max)return [0,[0,s],0];
      var results=split_full(0,0,rex,s);
      function _cP_(param)
       {if(936573133 <= param[1]){var s=param[2];return [0,[0,s],0]}
        var
         d=param[2],
         matches=caml_call1(Group[6],d),
         delim=caml_call2(Group[1],d,0),
         l=[0,0],
         _cR_=matches.length - 1 - 1 | 0,
         _cQ_=1;
        if(! (_cR_ < 1))
         {var i=_cQ_;
          for(;;)
           {var
             _cS_=l[1],
             _cT_=
              caml_equal(caml_check_bound(matches,i)[1 + i],_cI_)
               ?0
               :[2,i,caml_call2(Group[1],d,i)];
            l[1] = [0,_cT_,_cS_];
            var _cU_=i + 1 | 0;
            if(_cR_ !== i){var i=_cU_;continue}
            break}}
        return [0,[1,delim],caml_call1(Stdlib_list[9],l[1])]}
      var matches=caml_call2(Stdlib_list[17],_cP_,results);
      return caml_call1(Stdlib_list[13],matches)}
    var
     Re_Pcre=
      [0,
       re$1,
       regexp$0,
       extract,
       exec$0,
       get_substring,
       get_substring_ofs,
       pmatch,
       substitute,
       full_split$0,
       split$2,
       quote$1];
    caml_register_global(161,Re_Pcre,"Re__Pcre");
    var
     Parse_error$2=[248,cst_Re_Posix_Parse_error,caml_fresh_oo_id(0)],
     Not_supported$1=[248,cst_Re_Posix_Not_supported,caml_fresh_oo_id(0)];
    function re$2(opt$0,s)
     {if(opt$0)var sth=opt$0[1],opts=sth;else var opts=0;
      var
       newline=caml_call2(Stdlib_list[35],-638074828,opts),
       i=[0,0],
       l=caml_ml_string_length(s);
      function eos$0(param){return i[1] === l?1:0}
      function test(c)
       {var
         _cN_=1 - eos$0(0),
         _cO_=_cN_?caml_string_get(s,i[1]) === c?1:0:_cN_;
        return _cO_}
      function accept(c){var r=test(c);if(r)i[1]++;return r}
      function get(param){var r=caml_string_get(s,i[1]);i[1]++;return r}
      function unget(param){i[1] += -1;return 0}
      function char$1(param)
       {if(eos$0(0))throw Parse_error$2;
        var c=get(0);
        if(91 === c)
         {if(accept(61))throw Not_supported$1;
          if(accept(58))throw Not_supported$1;
          if(accept(46))
           {if(eos$0(0))throw Parse_error$2;
            var c$0=get(0);
            if(1 - accept(46))throw Not_supported$1;
            if(1 - accept(93))throw Parse_error$2;
            return c$0}
          return c}
        return c}
      function bracket(s)
       {var s$0=s;
        for(;;)
         {if(0 !== s$0 && accept(93))return s$0;
          var c=char$1(0);
          if(accept(45))
           {if(accept(93))
             {var _cM_=[0,char$0(45),s$0];return [0,char$0(c),_cM_]}
            var c$0=char$1(0),s$1=[0,rg(c,c$0),s$0],s$0=s$1;
            continue}
          var s$2=[0,char$0(c),s$0],s$0=s$2;
          continue}}
      function integer(param)
       {if(eos$0(0))return 0;
        var d=get(0),switcher=d - 48 | 0;
        if(9 < switcher >>> 0){unget(0);return 0}
        var i=d - 48 | 0,i$0=i;
        for(;;)
         {if(eos$0(0))return [0,i$0];
          var d$0=get(0),switcher$0=d$0 - 48 | 0;
          if(9 < switcher$0 >>> 0){unget(0);return [0,i$0]}
          var i$1=(10 * i$0 | 0) + (d$0 - 48 | 0) | 0;
          if(i$1 < i$0)throw Parse_error$2;
          var i$0=i$1;
          continue}}
      function branch(param)
       {var left=0;
        for(;;)
         {if(! eos$0(0) && ! test(124) && ! test(41))
           {if(accept(46))
             var r=newline?notnl:any;
            else
             if(accept(40))
              {var r$0=regexp(0);
               if(1 - accept(41))throw Parse_error$2;
               var r=[6,r$0]}
             else
              if(accept(94))
               var r=newline?bol:bos;
              else
               if(accept(36))
                var r=newline?eol:eos;
               else
                if(accept(91))
                 if(accept(94))
                  var _cK_=char$0(10),r=diff$0(compl(bracket(0)),_cK_);
                 else
                  var r=alt$0(bracket(0));
                else
                 if(accept(92))
                  {if(eos$0(0))throw Parse_error$2;
                   var c=get(0),switch$0=0;
                   if(91 <= c)
                    {var _cL_=c - 93 | 0;
                     if(29 < _cL_ >>> 0)
                      {if(! (32 <= _cL_))switch$0 = 1}
                     else
                      if(1 === _cL_)switch$0 = 1}
                   else
                    if(47 <= c)
                     {if(63 === c)switch$0 = 1}
                    else
                     if(36 <= c)
                      switch(c - 36 | 0)
                       {case 1:
                        case 2:
                        case 3:
                        case 8:
                        case 9:break;
                        default:switch$0 = 1}
                   if(! switch$0)throw Parse_error$2;
                   var r=char$0(c)}
                 else
                  {if(eos$0(0))throw Parse_error$2;
                   var c$0=get(0),switch$1=0;
                   if(64 <= c$0)
                    {if(92 !== c$0 && 123 !== c$0)switch$1 = 1}
                   else
                    if(44 <= c$0)
                     {if(! (63 <= c$0))switch$1 = 1}
                    else
                     if(! (42 <= c$0))switch$1 = 1;
                   if(! switch$1)throw Parse_error$2;
                   var r=char$0(c$0)}
            if(accept(42))
             var _cJ_=rep$0([8,r]);
            else
             if(accept(43))
              var _cJ_=rep1([8,r]);
             else
              if(accept(63))
               var _cJ_=opt(r);
              else
               if(accept(123))
                {var match=integer(0);
                 if(match)
                  {var i=match[1],j=accept(44)?integer(0):[0,i];
                   if(1 - accept(125))throw Parse_error$2;
                   if(j){var j$0=j[1];if(j$0 < i)throw Parse_error$2}
                   var _cJ_=repn([8,r],i,j)}
                 else
                  {unget(0);var _cJ_=r}}
               else
                var _cJ_=r;
            var left$0=[0,_cJ_,left],left=left$0;
            continue}
          return seq$1(caml_call1(Stdlib_list[9],left))}}
      function regexp(param)
       {var left=branch(0),left$0=left;
        for(;;)
         {if(accept(124))
           {var left$1=alt$0([0,left$0,[0,branch(0),0]]),left$0=left$1;
            continue}
          return left$0}}
      var r=regexp(0);
      if(1 - eos$0(0))throw Parse_error$2;
      var
       r$0=caml_call2(Stdlib_list[35],886285209,opts)?[10,r]:r,
       r$1=caml_call2(Stdlib_list[35],853495711,opts)?[7,r$0]:r$0;
      return r$1}
    function compile$0(re){return compile(longest(re))}
    function compile_pat$1(opt,s)
     {if(opt)var sth=opt[1],opts=sth;else var opts=0;
      return compile$0(re$2([0,opts],s))}
    var
     Re_Posix=
      [0,Parse_error$2,Not_supported$1,re$2,compile$0,compile_pat$1];
    caml_register_global(162,Re_Posix,"Re__Posix");
    var
     Re$0=
      [0,
       Group,
       compile,
       exec,
       exec_opt,
       execp,
       exec_partial,
       Mark,
       Seq,
       all$0,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split$0,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       replace,
       replace_string,
       str,
       char$0,
       alt$0,
       seq$1,
       empty$2,
       epsilon,
       rep$0,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start$0,
       stop$0,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first$0,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark$0,
       set,
       rg,
       inter$0,
       diff$0,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp$5,
       print_re,
       print_re,
       View,
       witness,
       get$0,
       get_ofs,
       get_all,
       get_all_ofs,
       test$0,
       marked,
       mark_set];
    caml_register_global(163,Re$0,"Re");
    return}
  (function(){return this}()));


//# 1 "../.js/tyxml.functor/tyxml_f.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_float_of_string=runtime.caml_float_of_string,
     caml_list_of_js_array=runtime.caml_list_of_js_array,
     caml_ml_string_length=runtime.caml_ml_string_length,
     caml_register_global=runtime.caml_register_global,
     caml_string_equal=runtime.caml_string_equal,
     caml_string_notequal=runtime.caml_string_notequal,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call7(f,a0,a1,a2,a3,a4,a5,a6)
     {return f.length == 7
              ?f(a0,a1,a2,a3,a4,a5,a6)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6])}
    function caml_call11(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
     {return f.length == 11
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Xml_stream_Malformed_strea=
      caml_string_of_jsbytes("Xml_stream.Malformed_stream"),
     cst_xmlns$1=caml_string_of_jsbytes("xmlns"),
     cst$30=caml_string_of_jsbytes(""),
     cst_xmlns$2=caml_string_of_jsbytes("xmlns"),
     cst$26=caml_string_of_jsbytes(""),
     cst$27=caml_string_of_jsbytes(" -->\n"),
     cst$28=caml_string_of_jsbytes("<!-- "),
     cst$29=caml_string_of_jsbytes("\n"),
     cst$12=caml_string_of_jsbytes(" "),
     cst$13=caml_string_of_jsbytes(" />"),
     cst$14=caml_string_of_jsbytes("<"),
     cst$15=caml_string_of_jsbytes(">"),
     cst$16=caml_string_of_jsbytes("><\/"),
     cst$17=caml_string_of_jsbytes("<"),
     cst$18=caml_string_of_jsbytes(">"),
     cst$19=caml_string_of_jsbytes("<\/"),
     cst$20=caml_string_of_jsbytes(">"),
     cst$21=caml_string_of_jsbytes("<"),
     cst$22=caml_string_of_jsbytes("-->"),
     cst$23=caml_string_of_jsbytes("<!--"),
     cst$24=caml_string_of_jsbytes(";"),
     cst$25=caml_string_of_jsbytes("&"),
     cst$10=caml_string_of_jsbytes(", "),
     cst$11=caml_string_of_jsbytes(" "),
     cst_xmlns=caml_string_of_jsbytes("xmlns"),
     cst_xmlns$0=caml_string_of_jsbytes("xmlns"),
     partial=[12,62,0],
     cst$9=caml_string_of_jsbytes(" "),
     cst_lt$0=caml_string_of_jsbytes("&lt;"),
     cst_gt$4=caml_string_of_jsbytes("&gt;"),
     cst_amp$0=caml_string_of_jsbytes("&amp;"),
     cst_quot$0=caml_string_of_jsbytes("&quot;"),
     cst_Infinity=caml_string_of_jsbytes("Infinity"),
     cst_Infinity$0=caml_string_of_jsbytes("-Infinity"),
     cst_NaN=caml_string_of_jsbytes("NaN"),
     cst$5=caml_string_of_jsbytes("--!>"),
     cst$6=caml_string_of_jsbytes("-->"),
     cst$7=caml_string_of_jsbytes("->"),
     cst$8=caml_string_of_jsbytes(">"),
     cst_gt$0=caml_string_of_jsbytes("&gt;"),
     cst_gt$1=caml_string_of_jsbytes("-&gt;"),
     cst_gt$2=caml_string_of_jsbytes("--&gt;"),
     cst_gt$3=caml_string_of_jsbytes("--!&gt;"),
     cst_1_0=caml_string_of_jsbytes("1.0"),
     cst_UTF_8=caml_string_of_jsbytes("UTF-8"),
     cst_64=caml_string_of_jsbytes("&#64;"),
     cst_lt=caml_string_of_jsbytes("&lt;"),
     cst_gt=caml_string_of_jsbytes("&gt;"),
     cst_amp=caml_string_of_jsbytes("&amp;"),
     cst_quot=caml_string_of_jsbytes("&quot;"),
     cst=caml_string_of_jsbytes("&#"),
     cst$0=caml_string_of_jsbytes(";"),
     cst$1=caml_string_of_jsbytes("--!>"),
     cst$2=caml_string_of_jsbytes("-->"),
     cst$3=caml_string_of_jsbytes("->"),
     cst$4=caml_string_of_jsbytes(">"),
     cst$38=caml_string_of_jsbytes(" "),
     cst$37=caml_string_of_jsbytes(""),
     partial$0=[12,32,[8,[0,0,3],0,0,[12,41,0]]],
     partial$1=[0,0,3],
     cst_none$1=caml_string_of_jsbytes("none"),
     cst_auto$2=caml_string_of_jsbytes("auto"),
     cst$36=caml_string_of_jsbytes("%"),
     cst_strokePaint=caml_string_of_jsbytes("strokePaint"),
     cst_sourceAlpha=caml_string_of_jsbytes("sourceAlpha"),
     cst_fillPaint=caml_string_of_jsbytes("fillPaint"),
     cst_sourceGraphic=caml_string_of_jsbytes("sourceGraphic"),
     cst_backgroundImage=caml_string_of_jsbytes("backgroundImage"),
     cst_backgroundAlpha=caml_string_of_jsbytes("backgroundAlpha"),
     cst_nochange=caml_string_of_jsbytes("nochange"),
     cst_alphabetic$1=caml_string_of_jsbytes("alphabetic"),
     cst_auto$1=caml_string_of_jsbytes("auto"),
     cst_hanging$1=caml_string_of_jsbytes("hanging"),
     cst_mathematical$1=caml_string_of_jsbytes("mathematical"),
     cst_inherit$1=caml_string_of_jsbytes("inherit"),
     cst_middle$1=caml_string_of_jsbytes("middle"),
     cst_central$0=caml_string_of_jsbytes("central"),
     cst_usescript=caml_string_of_jsbytes("usescript"),
     cst_ideographic$1=caml_string_of_jsbytes("ideographic"),
     cst_textbeforeedge=caml_string_of_jsbytes("textbeforeedge"),
     cst_resetsize=caml_string_of_jsbytes("resetsize"),
     cst_textafteredge=caml_string_of_jsbytes("textafteredge"),
     cst_stitch=caml_string_of_jsbytes("stitch"),
     cst_onRequest=caml_string_of_jsbytes("onRequest"),
     cst_repeat=caml_string_of_jsbytes("repeat"),
     cst_wrap=caml_string_of_jsbytes("wrap"),
     cst_remove=caml_string_of_jsbytes("remove"),
     cst_reflect=caml_string_of_jsbytes("reflect"),
     cst_noStitch=caml_string_of_jsbytes("noStitch"),
     cst$35=caml_string_of_jsbytes(""),
     cst_over=caml_string_of_jsbytes("over"),
     cst_none$0=caml_string_of_jsbytes("none"),
     cst_medial=caml_string_of_jsbytes("medial"),
     cst_never=caml_string_of_jsbytes("never"),
     cst_butt=caml_string_of_jsbytes("butt"),
     cst_auto$0=caml_string_of_jsbytes("auto"),
     cst_atop=caml_string_of_jsbytes("atop"),
     cst_arithmetic=caml_string_of_jsbytes("arithmetic"),
     cst_underline=caml_string_of_jsbytes("underline"),
     cst_gamma=caml_string_of_jsbytes("gamma"),
     cst_linear=caml_string_of_jsbytes("linear"),
     cst_overline=caml_string_of_jsbytes("overline"),
     cst_onLoad=caml_string_of_jsbytes("onLoad"),
     cst_turbulence=caml_string_of_jsbytes("turbulence"),
     cst_table=caml_string_of_jsbytes("table"),
     cst_geometricPrecision=caml_string_of_jsbytes("geometricPrecision"),
     cst_optimizeSpeed=caml_string_of_jsbytes("optimizeSpeed"),
     cst_miter=caml_string_of_jsbytes("miter"),
     cst_initial=caml_string_of_jsbytes("initial"),
     cst_start=caml_string_of_jsbytes("start"),
     cst_whenNotActive=caml_string_of_jsbytes("whenNotActive"),
     cst_identity=caml_string_of_jsbytes("identity"),
     cst_skewY=caml_string_of_jsbytes("skewY"),
     cst_skewX=caml_string_of_jsbytes("skewX"),
     cst_square=caml_string_of_jsbytes("square"),
     cst_scale$0=caml_string_of_jsbytes("scale"),
     cst_exact=caml_string_of_jsbytes("exact"),
     cst_perceptual=caml_string_of_jsbytes("perceptual"),
     cst_discrete=caml_string_of_jsbytes("discrete"),
     cst_erode=caml_string_of_jsbytes("erode"),
     cst_middle$0=caml_string_of_jsbytes("middle"),
     cst_round=caml_string_of_jsbytes("round"),
     cst_xor=caml_string_of_jsbytes("xor"),
     cst_XML=caml_string_of_jsbytes("XML"),
     cst_sum=caml_string_of_jsbytes("sum"),
     cst_pad=caml_string_of_jsbytes("pad"),
     cst_out=caml_string_of_jsbytes("out"),
     cst_new=caml_string_of_jsbytes("new"),
     cst_end=caml_string_of_jsbytes("end"),
     cst_CSS=caml_string_of_jsbytes("CSS"),
     cst_in$1=caml_string_of_jsbytes("in"),
     cst_v=caml_string_of_jsbytes("v"),
     cst_r$0=caml_string_of_jsbytes("r"),
     cst_h=caml_string_of_jsbytes("h"),
     cst_g$0=caml_string_of_jsbytes("g"),
     cst_b=caml_string_of_jsbytes("b"),
     cst_a$0=caml_string_of_jsbytes("a"),
     cst_rotate$0=caml_string_of_jsbytes("rotate"),
     cst_disable=caml_string_of_jsbytes("disable"),
     cst_screen=caml_string_of_jsbytes("screen"),
     cst_absolute_colorimetric=caml_string_of_jsbytes("absolute_colorimetric"),
     cst_inherit$0=caml_string_of_jsbytes("inherit"),
     cst_always=caml_string_of_jsbytes("always"),
     cst_spacingAndGlyphs=caml_string_of_jsbytes("spacingAndGlyphs"),
     cst_replace=caml_string_of_jsbytes("replace"),
     cst_multiply=caml_string_of_jsbytes("multiply"),
     cst_spline=caml_string_of_jsbytes("spline"),
     cst_matrix=caml_string_of_jsbytes("matrix"),
     cst_saturation=caml_string_of_jsbytes("saturation"),
     cst_dilate=caml_string_of_jsbytes("dilate"),
     cst_translate=caml_string_of_jsbytes("translate"),
     cst_default=caml_string_of_jsbytes("default"),
     cst_lighten=caml_string_of_jsbytes("lighten"),
     cst_normal=caml_string_of_jsbytes("normal"),
     cst_freeze=caml_string_of_jsbytes("freeze"),
     cst_magnify=caml_string_of_jsbytes("magnify"),
     cst_hueRotate=caml_string_of_jsbytes("hueRotate"),
     cst_spacing$0=caml_string_of_jsbytes("spacing"),
     cst_fractalNoise=caml_string_of_jsbytes("fractalNoise"),
     cst_saturate=caml_string_of_jsbytes("saturate"),
     cst_userSpaceOnUse=caml_string_of_jsbytes("userSpaceOnUse"),
     cst_objectBoundingBox=caml_string_of_jsbytes("objectBoundingBox"),
     cst_darken=caml_string_of_jsbytes("darken"),
     cst_paced=caml_string_of_jsbytes("paced"),
     cst_isolated=caml_string_of_jsbytes("isolated"),
     cst_optimizeLegibility=caml_string_of_jsbytes("optimizeLegibility"),
     cst_luminanceToAlpha=caml_string_of_jsbytes("luminanceToAlpha"),
     cst_line_through=caml_string_of_jsbytes("line-through"),
     cst_other=caml_string_of_jsbytes("other"),
     cst_terminal=caml_string_of_jsbytes("terminal"),
     cst_blink=caml_string_of_jsbytes("blink"),
     cst_stroke_width$0=caml_string_of_jsbytes("stroke-width"),
     cst_stretch=caml_string_of_jsbytes("stretch"),
     cst_bevel=caml_string_of_jsbytes("bevel"),
     cst_duplicate=caml_string_of_jsbytes("duplicate"),
     cst_preserve=caml_string_of_jsbytes("preserve"),
     cst_relative_colorimetric=caml_string_of_jsbytes("relative_colorimetric"),
     cst_after_edge=caml_string_of_jsbytes("after-edge"),
     cst_alphabetic$0=caml_string_of_jsbytes("alphabetic"),
     cst_auto=caml_string_of_jsbytes("auto"),
     cst_hanging$0=caml_string_of_jsbytes("hanging"),
     cst_mathematical$0=caml_string_of_jsbytes("mathematical"),
     cst_inherit=caml_string_of_jsbytes("inherit"),
     cst_middle=caml_string_of_jsbytes("middle"),
     cst_baseline=caml_string_of_jsbytes("baseline"),
     cst_central=caml_string_of_jsbytes("central"),
     cst_ideographic$0=caml_string_of_jsbytes("ideographic"),
     cst_text_before_edge=caml_string_of_jsbytes("text-before-edge"),
     cst_before_edge=caml_string_of_jsbytes("before-edge"),
     cst_text_after_edge=caml_string_of_jsbytes("text-after-edge"),
     cst_http_www_w3_org_1999_xlink=
      caml_string_of_jsbytes("http://www.w3.org/1999/xlink"),
     cst_xmlns_xlink=caml_string_of_jsbytes("xmlns:xlink"),
     cst_http_www_w3_org_2000_svg=
      caml_string_of_jsbytes("http://www.w3.org/2000/svg"),
     cst_xmlns$3=caml_string_of_jsbytes("xmlns"),
     cst_svg$0=caml_string_of_jsbytes("svg"),
     cst_stroke_dasharray=caml_string_of_jsbytes("stroke-dasharray"),
     cst_stroke_linejoin=caml_string_of_jsbytes("stroke-linejoin"),
     cst_stroke_linecap=caml_string_of_jsbytes("stroke-linecap"),
     cst_dominant_baseline=caml_string_of_jsbytes("dominant-baseline"),
     cst_alignment_baseline=caml_string_of_jsbytes("alignment-baseline"),
     cst_arabic_form=caml_string_of_jsbytes("arabic-form"),
     cst_orientation=caml_string_of_jsbytes("orientation"),
     cst_accumulate=caml_string_of_jsbytes("accumulate"),
     cst_additive=caml_string_of_jsbytes("additive"),
     cst_calcMode=caml_string_of_jsbytes("calcMode"),
     cst_fill$0=caml_string_of_jsbytes("fill"),
     cst_restart=caml_string_of_jsbytes("restart"),
     cst_attributeType=caml_string_of_jsbytes("attributeType"),
     cst_xlink_actuate=caml_string_of_jsbytes("xlink:actuate"),
     cst_xlink_show=caml_string_of_jsbytes("xlink:show"),
     cst_type$2=caml_string_of_jsbytes("type"),
     cst_stitchTiles=caml_string_of_jsbytes("stitchTiles"),
     cst_operator$0=caml_string_of_jsbytes("operator"),
     cst_yChannelSelector=caml_string_of_jsbytes("yChannelSelector"),
     cst_xChannelSelector=caml_string_of_jsbytes("xChannelSelector"),
     cst_targetY$0=caml_string_of_jsbytes("targetY"),
     cst_operator=caml_string_of_jsbytes("operator"),
     cst_type$1=caml_string_of_jsbytes("type"),
     cst_type$0=caml_string_of_jsbytes("type"),
     cst_mode=caml_string_of_jsbytes("mode"),
     cst_in2=caml_string_of_jsbytes("in2"),
     cst_in$0=caml_string_of_jsbytes("in"),
     cst_primitiveUnits=caml_string_of_jsbytes("primitiveUnits"),
     cst_maskContentUnits=caml_string_of_jsbytes("maskContentUnits"),
     cst_maskUnits=caml_string_of_jsbytes("maskUnits"),
     cst_clipPathUnits=caml_string_of_jsbytes("clipPathUnits"),
     cst_patternTransform=caml_string_of_jsbytes("patternTransform"),
     cst_patternContentUnits=caml_string_of_jsbytes("patternContentUnits"),
     cst_patternUnits=caml_string_of_jsbytes("patternUnits"),
     cst_offset=caml_string_of_jsbytes("offset"),
     cst_spreadMethod=caml_string_of_jsbytes("spreadMethod"),
     cst_gradientUnits=caml_string_of_jsbytes("gradientUnits"),
     cst_rendering_intent=caml_string_of_jsbytes("rendering-intent"),
     cst_orient=caml_string_of_jsbytes("orient"),
     cst_markerUnits=caml_string_of_jsbytes("markerUnits"),
     cst_spacing=caml_string_of_jsbytes("spacing"),
     cst_method=caml_string_of_jsbytes("method"),
     cst_text_rendering=caml_string_of_jsbytes("text-rendering"),
     cst_text_decoration=caml_string_of_jsbytes("text-decoration"),
     cst_text_anchor=caml_string_of_jsbytes("text-anchor"),
     cst_lengthAdjust=caml_string_of_jsbytes("lengthAdjust"),
     cst_xml_space=caml_string_of_jsbytes("xml:space"),
     cst_data=caml_string_of_jsbytes("data-"),
     cst_zoomAndSpan=caml_string_of_jsbytes("zoomAndSpan"),
     cst_foreignObject=caml_string_of_jsbytes("foreignObject"),
     cst_metadata=caml_string_of_jsbytes("metadata"),
     content_type=caml_string_of_jsbytes("image/svg+xml"),
     version=caml_string_of_jsbytes("SVG 1.1"),
     standard=caml_string_of_jsbytes("http://www.w3.org/TR/svg11/"),
     namespace=caml_string_of_jsbytes("http://www.w3.org/2000/svg"),
     cst_svg=caml_string_of_jsbytes("svg"),
     cst_version=caml_string_of_jsbytes("version"),
     cst_baseProfile=caml_string_of_jsbytes("baseProfile"),
     cst_x=caml_string_of_jsbytes("x"),
     cst_y=caml_string_of_jsbytes("y"),
     cst_width=caml_string_of_jsbytes("width"),
     cst_height=caml_string_of_jsbytes("height"),
     cst_preserveAspectRatio=caml_string_of_jsbytes("preserveAspectRatio"),
     cst_contentScriptType=caml_string_of_jsbytes("contentScriptType"),
     cst_contentStyleType=caml_string_of_jsbytes("contentStyleType"),
     cst_href=caml_string_of_jsbytes("href"),
     cst_xlink_href=caml_string_of_jsbytes("xlink:href"),
     cst_requiredFeatures=caml_string_of_jsbytes("requiredFeatures"),
     cst_requiredExtension=caml_string_of_jsbytes("requiredExtension"),
     cst_systemLanguage=caml_string_of_jsbytes("systemLanguage"),
     cst_externalRessourcesRequired=
      caml_string_of_jsbytes("externalRessourcesRequired"),
     cst_id=caml_string_of_jsbytes("id"),
     cst_xml_base=caml_string_of_jsbytes("xml:base"),
     cst_xml_lang=caml_string_of_jsbytes("xml:lang"),
     cst_type=caml_string_of_jsbytes("type"),
     cst_media=caml_string_of_jsbytes("media"),
     cst_xlink_title=caml_string_of_jsbytes("xlink:title"),
     cst_class=caml_string_of_jsbytes("class"),
     cst_style=caml_string_of_jsbytes("style"),
     cst_transform=caml_string_of_jsbytes("transform"),
     cst_viewBox=caml_string_of_jsbytes("viewBox"),
     cst_d=caml_string_of_jsbytes("d"),
     cst_pathLength=caml_string_of_jsbytes("pathLength"),
     cst_rx=caml_string_of_jsbytes("rx"),
     cst_ry=caml_string_of_jsbytes("ry"),
     cst_cx=caml_string_of_jsbytes("cx"),
     cst_cy=caml_string_of_jsbytes("cy"),
     cst_r=caml_string_of_jsbytes("r"),
     cst_x1=caml_string_of_jsbytes("x1"),
     cst_y1=caml_string_of_jsbytes("y1"),
     cst_x2=caml_string_of_jsbytes("x2"),
     cst_y2=caml_string_of_jsbytes("y2"),
     cst_points=caml_string_of_jsbytes("points"),
     cst_x$0=caml_string_of_jsbytes("x"),
     cst_y$0=caml_string_of_jsbytes("y"),
     cst_dx=caml_string_of_jsbytes("dx"),
     cst_dy=caml_string_of_jsbytes("dy"),
     cst_dx$0=caml_string_of_jsbytes("dx"),
     cst_dy$0=caml_string_of_jsbytes("dy"),
     cst_textLength=caml_string_of_jsbytes("textLength"),
     cst_rotate=caml_string_of_jsbytes("rotate"),
     cst_startOffset=caml_string_of_jsbytes("startOffset"),
     cst_glyphRef=caml_string_of_jsbytes("glyphRef"),
     cst_format=caml_string_of_jsbytes("format"),
     cst_refX=caml_string_of_jsbytes("refX"),
     cst_refY=caml_string_of_jsbytes("refY"),
     cst_markerWidth=caml_string_of_jsbytes("markerWidth"),
     cst_markerHeight=caml_string_of_jsbytes("markerHeight"),
     cst_local=caml_string_of_jsbytes("local"),
     cst_gradientTransform=caml_string_of_jsbytes("gradientTransform"),
     cst_fx=caml_string_of_jsbytes("fx"),
     cst_fy=caml_string_of_jsbytes("fy"),
     cst_filterResUnits=caml_string_of_jsbytes("filterResUnits"),
     cst_result=caml_string_of_jsbytes("result"),
     cst_azimuth=caml_string_of_jsbytes("azimuth"),
     cst_elevation=caml_string_of_jsbytes("elevation"),
     cst_pointsAtX=caml_string_of_jsbytes("pointsAtX"),
     cst_pointsAtY=caml_string_of_jsbytes("pointsAtY"),
     cst_pointsAtZ=caml_string_of_jsbytes("pointsAtZ"),
     cst_specularExponent=caml_string_of_jsbytes("specularExponent"),
     cst_specularConstant=caml_string_of_jsbytes("specularConstant"),
     cst_limitingConeAngle=caml_string_of_jsbytes("limitingConeAngle"),
     cst_values=caml_string_of_jsbytes("values"),
     cst_tableValues=caml_string_of_jsbytes("tableValues"),
     cst_intercept=caml_string_of_jsbytes("intercept"),
     cst_amplitude=caml_string_of_jsbytes("amplitude"),
     cst_exponent=caml_string_of_jsbytes("exponent"),
     cst_offset$0=caml_string_of_jsbytes("offset"),
     cst_k1=caml_string_of_jsbytes("k1"),
     cst_k2=caml_string_of_jsbytes("k2"),
     cst_k3=caml_string_of_jsbytes("k3"),
     cst_k4=caml_string_of_jsbytes("k4"),
     cst_order=caml_string_of_jsbytes("order"),
     cst_kernelMatrix=caml_string_of_jsbytes("kernelMatrix"),
     cst_divisor=caml_string_of_jsbytes("divisor"),
     cst_bias=caml_string_of_jsbytes("bias"),
     cst_kernelUnitLength=caml_string_of_jsbytes("kernelUnitLength"),
     cst_targetX=caml_string_of_jsbytes("targetX"),
     cst_targetY=caml_string_of_jsbytes("targetY"),
     cst_preserveAlpha=caml_string_of_jsbytes("preserveAlpha"),
     cst_surfaceScale=caml_string_of_jsbytes("surfaceScale"),
     cst_diffuseConstant=caml_string_of_jsbytes("diffuseConstant"),
     cst_scale=caml_string_of_jsbytes("scale"),
     cst_stdDeviation=caml_string_of_jsbytes("stdDeviation"),
     cst_radius=caml_string_of_jsbytes("radius"),
     cst_baseFrequency=caml_string_of_jsbytes("baseFrequency"),
     cst_numOctaves=caml_string_of_jsbytes("numOctaves"),
     cst_seed=caml_string_of_jsbytes("seed"),
     cst_xlink_target=caml_string_of_jsbytes("xlink:target"),
     cst_viewTarget=caml_string_of_jsbytes("viewTarget"),
     cst_attributeName=caml_string_of_jsbytes("attributeName"),
     cst_begin=caml_string_of_jsbytes("begin"),
     cst_dur=caml_string_of_jsbytes("dur"),
     cst_min=caml_string_of_jsbytes("min"),
     cst_max=caml_string_of_jsbytes("max"),
     cst_repeatCount=caml_string_of_jsbytes("repeatCount"),
     cst_repeatDur=caml_string_of_jsbytes("repeatDur"),
     cst_fill=caml_string_of_jsbytes("fill"),
     cst_values$0=caml_string_of_jsbytes("values"),
     cst_keyTimes=caml_string_of_jsbytes("keyTimes"),
     cst_keySplines=caml_string_of_jsbytes("keySplines"),
     cst_from=caml_string_of_jsbytes("from"),
     cst_to=caml_string_of_jsbytes("to"),
     cst_by=caml_string_of_jsbytes("by"),
     cst_keyPoints=caml_string_of_jsbytes("keyPoints"),
     cst_path=caml_string_of_jsbytes("path"),
     cst_type$3=caml_string_of_jsbytes("type"),
     cst_horiz_origin_x=caml_string_of_jsbytes("horiz-origin-x"),
     cst_horiz_origin_y=caml_string_of_jsbytes("horiz-origin-y"),
     cst_horiz_adv_x=caml_string_of_jsbytes("horiz-adv-x"),
     cst_vert_origin_x=caml_string_of_jsbytes("vert-origin-x"),
     cst_vert_origin_y=caml_string_of_jsbytes("vert-origin-y"),
     cst_vert_adv_y=caml_string_of_jsbytes("vert-adv-y"),
     cst_unicode=caml_string_of_jsbytes("unicode"),
     cst_glyphname=caml_string_of_jsbytes("glyphname"),
     cst_lang=caml_string_of_jsbytes("lang"),
     cst_u1=caml_string_of_jsbytes("u1"),
     cst_u2=caml_string_of_jsbytes("u2"),
     cst_g1=caml_string_of_jsbytes("g1"),
     cst_g2=caml_string_of_jsbytes("g2"),
     cst_k=caml_string_of_jsbytes("k"),
     cst_font_family=caml_string_of_jsbytes("font-family"),
     cst_font_style=caml_string_of_jsbytes("font-style"),
     cst_font_variant=caml_string_of_jsbytes("font-variant"),
     cst_font_weight=caml_string_of_jsbytes("font-weight"),
     cst_font_stretch=caml_string_of_jsbytes("font-stretch"),
     cst_font_size=caml_string_of_jsbytes("font-size"),
     cst_unicode_range=caml_string_of_jsbytes("unicode-range"),
     cst_units_per_em=caml_string_of_jsbytes("units-per-em"),
     cst_stemv=caml_string_of_jsbytes("stemv"),
     cst_stemh=caml_string_of_jsbytes("stemh"),
     cst_slope=caml_string_of_jsbytes("slope"),
     cst_cap_height=caml_string_of_jsbytes("cap-height"),
     cst_x_height=caml_string_of_jsbytes("x-height"),
     cst_accent_height=caml_string_of_jsbytes("accent-height"),
     cst_ascent=caml_string_of_jsbytes("ascent"),
     cst_widths=caml_string_of_jsbytes("widths"),
     cst_bbox=caml_string_of_jsbytes("bbox"),
     cst_ideographic=caml_string_of_jsbytes("ideographic"),
     cst_alphabetic=caml_string_of_jsbytes("alphabetic"),
     cst_mathematical=caml_string_of_jsbytes("mathematical"),
     cst_hanging=caml_string_of_jsbytes("hanging"),
     cst_v_ideographic=caml_string_of_jsbytes("v-ideographic"),
     cst_v_alphabetic=caml_string_of_jsbytes("v-alphabetic"),
     cst_v_mathematical=caml_string_of_jsbytes("v-mathematical"),
     cst_v_hanging=caml_string_of_jsbytes("v-hanging"),
     cst_underline_position=caml_string_of_jsbytes("underline-position"),
     cst_underline_thickness=caml_string_of_jsbytes("underline-thickness"),
     cst_strikethrough_position=
      caml_string_of_jsbytes("strikethrough-position"),
     cst_strikethrough_thickness=
      caml_string_of_jsbytes("strikethrough-thickness"),
     cst_overline_position=caml_string_of_jsbytes("overline-position"),
     cst_overline_thickness=caml_string_of_jsbytes("overline-thickness"),
     cst_string=caml_string_of_jsbytes("string"),
     cst_name=caml_string_of_jsbytes("name"),
     cst_onabort=caml_string_of_jsbytes("onabort"),
     cst_onactivate=caml_string_of_jsbytes("onactivate"),
     cst_onbegin=caml_string_of_jsbytes("onbegin"),
     cst_onend=caml_string_of_jsbytes("onend"),
     cst_onerror=caml_string_of_jsbytes("onerror"),
     cst_onfocusin=caml_string_of_jsbytes("onfocusin"),
     cst_onfocusout=caml_string_of_jsbytes("onfocusout"),
     cst_onload=caml_string_of_jsbytes("onload"),
     cst_onrepeat=caml_string_of_jsbytes("onrepeat"),
     cst_onresize=caml_string_of_jsbytes("onresize"),
     cst_onscroll=caml_string_of_jsbytes("onscroll"),
     cst_onunload=caml_string_of_jsbytes("onunload"),
     cst_onzoom=caml_string_of_jsbytes("onzoom"),
     cst_onclick=caml_string_of_jsbytes("onclick"),
     cst_onmousedown=caml_string_of_jsbytes("onmousedown"),
     cst_onmouseup=caml_string_of_jsbytes("onmouseup"),
     cst_onmouseover=caml_string_of_jsbytes("onmouseover"),
     cst_onmouseout=caml_string_of_jsbytes("onmouseout"),
     cst_onmousemove=caml_string_of_jsbytes("onmousemove"),
     cst_ontouchstart=caml_string_of_jsbytes("ontouchstart"),
     cst_ontouchend=caml_string_of_jsbytes("ontouchend"),
     cst_ontouchmove=caml_string_of_jsbytes("ontouchmove"),
     cst_ontouchcancel=caml_string_of_jsbytes("ontouchcancel"),
     cst_stop_color=caml_string_of_jsbytes("stop-color"),
     cst_stop_opacity=caml_string_of_jsbytes("stop-opacity"),
     cst_stroke=caml_string_of_jsbytes("stroke"),
     cst_stroke_width=caml_string_of_jsbytes("stroke-width"),
     cst_stroke_miterlimit=caml_string_of_jsbytes("stroke-miterlimit"),
     cst_stroke_dashoffset=caml_string_of_jsbytes("stroke-dashoffset"),
     cst_stroke_opacity=caml_string_of_jsbytes("stroke-opacity"),
     cst_g=caml_string_of_jsbytes("g"),
     cst_defs=caml_string_of_jsbytes("defs"),
     cst_desc=caml_string_of_jsbytes("desc"),
     cst_title=caml_string_of_jsbytes("title"),
     cst_symbol=caml_string_of_jsbytes("symbol"),
     cst_use=caml_string_of_jsbytes("use"),
     cst_image=caml_string_of_jsbytes("image"),
     cst_switch=caml_string_of_jsbytes("switch"),
     cst_style$0=caml_string_of_jsbytes("style"),
     cst_path$0=caml_string_of_jsbytes("path"),
     cst_rect=caml_string_of_jsbytes("rect"),
     cst_circle=caml_string_of_jsbytes("circle"),
     cst_ellipse=caml_string_of_jsbytes("ellipse"),
     cst_line=caml_string_of_jsbytes("line"),
     cst_polyline=caml_string_of_jsbytes("polyline"),
     cst_polygon=caml_string_of_jsbytes("polygon"),
     cst_text=caml_string_of_jsbytes("text"),
     cst_tspan=caml_string_of_jsbytes("tspan"),
     cst_tref=caml_string_of_jsbytes("tref"),
     cst_textPath=caml_string_of_jsbytes("textPath"),
     cst_altGlyph=caml_string_of_jsbytes("altGlyph"),
     cst_altGlyphDef=caml_string_of_jsbytes("altGlyphDef"),
     cst_altGlyphItem=caml_string_of_jsbytes("altGlyphItem"),
     cst_glyphRef$0=caml_string_of_jsbytes("glyphRef"),
     cst_marker=caml_string_of_jsbytes("marker"),
     cst_color_profile=caml_string_of_jsbytes("color-profile"),
     cst_linearGradient=caml_string_of_jsbytes("linearGradient"),
     cst_radialGradient=caml_string_of_jsbytes("radialGradient"),
     cst_stop=caml_string_of_jsbytes("stop"),
     cst_pattern=caml_string_of_jsbytes("pattern"),
     cst_clipPath=caml_string_of_jsbytes("clipPath"),
     cst_filter=caml_string_of_jsbytes("filter"),
     cst_feDistantLight=caml_string_of_jsbytes("feDistantLight"),
     cst_fePointLight=caml_string_of_jsbytes("fePointLight"),
     cst_feSpotLight=caml_string_of_jsbytes("feSpotLight"),
     cst_feBlend=caml_string_of_jsbytes("feBlend"),
     cst_feColorMatrix=caml_string_of_jsbytes("feColorMatrix"),
     cst_feComponentTransfer=caml_string_of_jsbytes("feComponentTransfer"),
     cst_feFuncA=caml_string_of_jsbytes("feFuncA"),
     cst_feFuncG=caml_string_of_jsbytes("feFuncG"),
     cst_feFuncB=caml_string_of_jsbytes("feFuncB"),
     cst_feFuncR=caml_string_of_jsbytes("feFuncR"),
     cst_feComposite=caml_string_of_jsbytes("feComposite"),
     cst_feConvolveMatrix=caml_string_of_jsbytes("feConvolveMatrix"),
     cst_feDiffuseLighting=caml_string_of_jsbytes("feDiffuseLighting"),
     cst_feDisplacementMap=caml_string_of_jsbytes("feDisplacementMap"),
     cst_feFlood=caml_string_of_jsbytes("feFlood"),
     cst_feGaussianBlur=caml_string_of_jsbytes("feGaussianBlur"),
     cst_feImage=caml_string_of_jsbytes("feImage"),
     cst_feMerge=caml_string_of_jsbytes("feMerge"),
     cst_feMorphology=caml_string_of_jsbytes("feMorphology"),
     cst_feOffset=caml_string_of_jsbytes("feOffset"),
     cst_feSpecularLighting=caml_string_of_jsbytes("feSpecularLighting"),
     cst_feTile=caml_string_of_jsbytes("feTile"),
     cst_feTurbulence=caml_string_of_jsbytes("feTurbulence"),
     cst_cursor=caml_string_of_jsbytes("cursor"),
     cst_a=caml_string_of_jsbytes("a"),
     cst_view=caml_string_of_jsbytes("view"),
     cst_script=caml_string_of_jsbytes("script"),
     cst_animate=caml_string_of_jsbytes("animate"),
     cst_set=caml_string_of_jsbytes("set"),
     cst_animateMotion=caml_string_of_jsbytes("animateMotion"),
     cst_mpath=caml_string_of_jsbytes("mpath"),
     cst_animateColor=caml_string_of_jsbytes("animateColor"),
     cst_animateTransform=caml_string_of_jsbytes("animateTransform"),
     cst_font=caml_string_of_jsbytes("font"),
     cst_glyph=caml_string_of_jsbytes("glyph"),
     cst_missing_glyph=caml_string_of_jsbytes("missing-glyph"),
     cst_hkern=caml_string_of_jsbytes("hkern"),
     cst_vkern=caml_string_of_jsbytes("vkern"),
     cst_font_face=caml_string_of_jsbytes("font-face"),
     cst_font_face_src=caml_string_of_jsbytes("font-face-src"),
     cst_font_face_uri=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_uri$0=caml_string_of_jsbytes("font-face-uri"),
     cst_font_face_name=caml_string_of_jsbytes("font-face-name"),
     cst$34=caml_string_of_jsbytes(" "),
     cst_none=caml_string_of_jsbytes("none"),
     cst_currentColor=caml_string_of_jsbytes("currentColor"),
     cst$33=caml_string_of_jsbytes(" "),
     sep=caml_string_of_jsbytes(" "),
     cst_px=caml_string_of_jsbytes("px"),
     cst_pt=caml_string_of_jsbytes("pt"),
     cst_pc=caml_string_of_jsbytes("pc"),
     cst_in=caml_string_of_jsbytes("in"),
     cst_mm=caml_string_of_jsbytes("mm"),
     cst_ex=caml_string_of_jsbytes("ex"),
     cst_em=caml_string_of_jsbytes("em"),
     cst_cm=caml_string_of_jsbytes("cm"),
     cst$32=caml_string_of_jsbytes("%"),
     cst_grad=caml_string_of_jsbytes("grad"),
     cst_deg=caml_string_of_jsbytes("deg"),
     cst_rad=caml_string_of_jsbytes("rad"),
     cst$31=caml_string_of_jsbytes(""),
     cst$46=caml_string_of_jsbytes(", "),
     cst$45=caml_string_of_jsbytes(" "),
     cst$44=caml_string_of_jsbytes(", "),
     cst$43=caml_string_of_jsbytes(","),
     cst$42=caml_string_of_jsbytes(" "),
     cst$41=caml_string_of_jsbytes(" "),
     cst_any$1=caml_string_of_jsbytes("any"),
     cst_any$0=caml_string_of_jsbytes("any"),
     cst$40=caml_string_of_jsbytes(""),
     cst_on=caml_string_of_jsbytes("on"),
     cst_off=caml_string_of_jsbytes("off"),
     cst_week=caml_string_of_jsbytes("week"),
     cst_time$0=caml_string_of_jsbytes("time"),
     cst_text$1=caml_string_of_jsbytes("text"),
     cst_file=caml_string_of_jsbytes("file"),
     cst_date=caml_string_of_jsbytes("date"),
     cst_datetime_local=caml_string_of_jsbytes("datetime-local"),
     cst_password=caml_string_of_jsbytes("password"),
     cst_month=caml_string_of_jsbytes("month"),
     cst_search$1=caml_string_of_jsbytes("search"),
     cst_button$0=caml_string_of_jsbytes("button"),
     cst_checkbox$0=caml_string_of_jsbytes("checkbox"),
     cst_email$0=caml_string_of_jsbytes("email"),
     cst_hidden$1=caml_string_of_jsbytes("hidden"),
     cst_url$0=caml_string_of_jsbytes("url"),
     cst_tel$0=caml_string_of_jsbytes("tel"),
     cst_reset=caml_string_of_jsbytes("reset"),
     cst_range=caml_string_of_jsbytes("range"),
     cst_radio$0=caml_string_of_jsbytes("radio"),
     cst_readonly$1=caml_string_of_jsbytes("readonly"),
     cst_color=caml_string_of_jsbytes("color"),
     cst_number=caml_string_of_jsbytes("number"),
     cst_image$0=caml_string_of_jsbytes("image"),
     cst_submit=caml_string_of_jsbytes("submit"),
     cst_datetime$0=caml_string_of_jsbytes("datetime"),
     cst_external$0=caml_string_of_jsbytes("external"),
     cst_0=caml_string_of_jsbytes("0"),
     cst_formnovalidate$0=caml_string_of_jsbytes("formnovalidate"),
     cst_audio$0=caml_string_of_jsbytes("audio"),
     cst_async$0=caml_string_of_jsbytes("async"),
     cst_toolbar=caml_string_of_jsbytes("toolbar"),
     cst_text$0=caml_string_of_jsbytes("text"),
     cst_soft=caml_string_of_jsbytes("soft"),
     cst_rows$0=caml_string_of_jsbytes("rows"),
     cst_rect$0=caml_string_of_jsbytes("rect"),
     cst_prev$0=caml_string_of_jsbytes("prev"),
     cst_POST=caml_string_of_jsbytes("POST"),
     cst_poly=caml_string_of_jsbytes("poly"),
     cst_open$0=caml_string_of_jsbytes("open"),
     cst_decimal=caml_string_of_jsbytes("decimal"),
     cst_none$2=caml_string_of_jsbytes("none"),
     cst_next$0=caml_string_of_jsbytes("next"),
     cst_loop$0=caml_string_of_jsbytes("loop"),
     cst_left=caml_string_of_jsbytes("left"),
     cst_last$0=caml_string_of_jsbytes("last"),
     cst_kana=caml_string_of_jsbytes("kana"),
     cst_icon$1=caml_string_of_jsbytes("icon"),
     cst_help$0=caml_string_of_jsbytes("help"),
     cst_hard=caml_string_of_jsbytes("hard"),
     cst_cols$0=caml_string_of_jsbytes("cols"),
     cst_char$0=caml_string_of_jsbytes("char"),
     cst_auto$3=caml_string_of_jsbytes("auto"),
     cst_noreferrer$0=caml_string_of_jsbytes("noreferrer"),
     cst_author$0=caml_string_of_jsbytes("author"),
     cst_muted$0=caml_string_of_jsbytes("muted"),
     cst_autoplay$0=caml_string_of_jsbytes("autoplay"),
     cst_anonymous=caml_string_of_jsbytes("anonymous"),
     cst_metadata$0=caml_string_of_jsbytes("metadata"),
     cst_license$0=caml_string_of_jsbytes("license"),
     cst_search$0=caml_string_of_jsbytes("search"),
     cst_first$0=caml_string_of_jsbytes("first"),
     cst_novalidate$0=caml_string_of_jsbytes("novalidate"),
     cst_controls$0=caml_string_of_jsbytes("controls"),
     cst_bookmark$0=caml_string_of_jsbytes("bookmark"),
     cst_required$0=caml_string_of_jsbytes("required"),
     cst_selected$0=caml_string_of_jsbytes("selected"),
     cst_circle$0=caml_string_of_jsbytes("circle"),
     cst_rowgroup=caml_string_of_jsbytes("rowgroup"),
     cst_checkbox=caml_string_of_jsbytes("checkbox"),
     cst_katakana=caml_string_of_jsbytes("katakana"),
     cst_email=caml_string_of_jsbytes("email"),
     cst_latin=caml_string_of_jsbytes("latin"),
     cst_hidden$0=caml_string_of_jsbytes("hidden"),
     cst_yes=caml_string_of_jsbytes("yes"),
     cst_url=caml_string_of_jsbytes("url"),
     cst_tel=caml_string_of_jsbytes("tel"),
     cst_tag$0=caml_string_of_jsbytes("tag"),
     cst_rtl=caml_string_of_jsbytes("rtl"),
     cst_row=caml_string_of_jsbytes("row"),
     cst_1=caml_string_of_jsbytes("1"),
     cst_ltr=caml_string_of_jsbytes("ltr"),
     cst_GET=caml_string_of_jsbytes("GET"),
     cst_col$0=caml_string_of_jsbytes("col"),
     cst_any=caml_string_of_jsbytes("any"),
     cst_all$0=caml_string_of_jsbytes("all"),
     cst_up$0=caml_string_of_jsbytes("up"),
     cst_no=caml_string_of_jsbytes("no"),
     cst_right=caml_string_of_jsbytes("right"),
     cst_scoped$0=caml_string_of_jsbytes("scoped"),
     cst_numeric=caml_string_of_jsbytes("numeric"),
     cst_pingback$0=caml_string_of_jsbytes("pingback"),
     cst_radio=caml_string_of_jsbytes("radio"),
     cst_pubdate$0=caml_string_of_jsbytes("pubdate"),
     cst_multiple$0=caml_string_of_jsbytes("multiple"),
     cst_latin_name=caml_string_of_jsbytes("latin-name"),
     cst_autofocus$0=caml_string_of_jsbytes("autofocus"),
     cst_nofollow$0=caml_string_of_jsbytes("nofollow"),
     cst_defer$0=caml_string_of_jsbytes("defer"),
     cst_full_width_latin=caml_string_of_jsbytes("full-width-latin"),
     cst_default$0=caml_string_of_jsbytes("default"),
     cst_context=caml_string_of_jsbytes("context"),
     cst_verbatim=caml_string_of_jsbytes("verbatim"),
     cst_checked$0=caml_string_of_jsbytes("checked"),
     cst_stylesheet$0=caml_string_of_jsbytes("stylesheet"),
     cst_reserved$0=caml_string_of_jsbytes("reserved"),
     cst_alternate$0=caml_string_of_jsbytes("alternate"),
     cst_http_www_w3_org_1999_xhtml=
      caml_string_of_jsbytes("http://www.w3.org/1999/xhtml"),
     cst_disabled$0=caml_string_of_jsbytes("disabled"),
     cst_ismap$0=caml_string_of_jsbytes("ismap"),
     cst_use_credentials=caml_string_of_jsbytes("use-credentials"),
     cst_index$0=caml_string_of_jsbytes("index"),
     cst_justify=caml_string_of_jsbytes("justify"),
     cst_groups=caml_string_of_jsbytes("groups"),
     cst_command$0=caml_string_of_jsbytes("command"),
     cst_sidebar$0=caml_string_of_jsbytes("sidebar"),
     cst_latin_prose=caml_string_of_jsbytes("latin-prose"),
     cst_readonly$0=caml_string_of_jsbytes("readonly"),
     cst_colgroup$0=caml_string_of_jsbytes("colgroup"),
     cst_archives$0=caml_string_of_jsbytes("archives"),
     cst_seamless$0=caml_string_of_jsbytes("seamless"),
     cst_prefetch$0=caml_string_of_jsbytes("prefetch"),
     cst_preserve$0=caml_string_of_jsbytes("preserve"),
     cst_same_origin=caml_string_of_jsbytes("same-origin"),
     cst_origin_when_cross_origin=
      caml_string_of_jsbytes("origin-when-cross-origin"),
     cst_no_referrer_when_downgrade=
      caml_string_of_jsbytes("no-referrer-when-downgrade"),
     cst_no_referrer=caml_string_of_jsbytes("no-referrer"),
     cst_unsafe_url=caml_string_of_jsbytes("unsafe-url"),
     cst$39=caml_string_of_jsbytes(""),
     cst_origin=caml_string_of_jsbytes("origin"),
     cst_strict_origin=caml_string_of_jsbytes("strict-origin"),
     cst_strict_origin_when_cross_o=
      caml_string_of_jsbytes("strict-origin-when-cross-origin"),
     cst_projection=caml_string_of_jsbytes("projection"),
     cst_aural=caml_string_of_jsbytes("aural"),
     cst_handheld=caml_string_of_jsbytes("handheld"),
     cst_embossed=caml_string_of_jsbytes("embossed"),
     cst_tty=caml_string_of_jsbytes("tty"),
     cst_all=caml_string_of_jsbytes("all"),
     cst_tv=caml_string_of_jsbytes("tv"),
     cst_screen$0=caml_string_of_jsbytes("screen"),
     cst_speech=caml_string_of_jsbytes("speech"),
     cst_print=caml_string_of_jsbytes("print"),
     cst_braille=caml_string_of_jsbytes("braille"),
     cst_external=caml_string_of_jsbytes("external"),
     cst_canonical=caml_string_of_jsbytes("canonical"),
     cst_prev=caml_string_of_jsbytes("prev"),
     cst_next=caml_string_of_jsbytes("next"),
     cst_last=caml_string_of_jsbytes("last"),
     cst_icon$0=caml_string_of_jsbytes("icon"),
     cst_help=caml_string_of_jsbytes("help"),
     cst_noreferrer=caml_string_of_jsbytes("noreferrer"),
     cst_author=caml_string_of_jsbytes("author"),
     cst_license=caml_string_of_jsbytes("license"),
     cst_search=caml_string_of_jsbytes("search"),
     cst_noopener=caml_string_of_jsbytes("noopener"),
     cst_first=caml_string_of_jsbytes("first"),
     cst_bookmark=caml_string_of_jsbytes("bookmark"),
     cst_tag=caml_string_of_jsbytes("tag"),
     cst_up=caml_string_of_jsbytes("up"),
     cst_pingback=caml_string_of_jsbytes("pingback"),
     cst_nofollow=caml_string_of_jsbytes("nofollow"),
     cst_stylesheet=caml_string_of_jsbytes("stylesheet"),
     cst_alternate=caml_string_of_jsbytes("alternate"),
     cst_index=caml_string_of_jsbytes("index"),
     cst_sidebar=caml_string_of_jsbytes("sidebar"),
     cst_archives=caml_string_of_jsbytes("archives"),
     cst_prefetch=caml_string_of_jsbytes("prefetch"),
     cst_allow_same_origin=caml_string_of_jsbytes("allow-same-origin"),
     cst_allow_popups=caml_string_of_jsbytes("allow-popups"),
     cst_allow_forms=caml_string_of_jsbytes("allow-forms"),
     cst_allow_pointer_lock=caml_string_of_jsbytes("allow-pointer-lock"),
     cst_allow_script=caml_string_of_jsbytes("allow-script"),
     cst_allow_top_navigation=caml_string_of_jsbytes("allow-top-navigation"),
     cst_link=caml_string_of_jsbytes("link"),
     cst_style$2=caml_string_of_jsbytes("style"),
     cst_picture=caml_string_of_jsbytes("picture"),
     cst_img=caml_string_of_jsbytes("img"),
     cst_object=caml_string_of_jsbytes("object"),
     cst_table$0=caml_string_of_jsbytes("table"),
     cst_figure=caml_string_of_jsbytes("figure"),
     cst_optgroup=caml_string_of_jsbytes("optgroup"),
     cst_fieldset=caml_string_of_jsbytes("fieldset"),
     cst_details=caml_string_of_jsbytes("details"),
     cst_datalist=caml_string_of_jsbytes("datalist"),
     cst_menu=caml_string_of_jsbytes("menu"),
     cst_command=caml_string_of_jsbytes("command"),
     cst_area=caml_string_of_jsbytes("area"),
     cst_coords=caml_string_of_jsbytes("coords"),
     cst_shape=caml_string_of_jsbytes("shape"),
     cst_bdo=caml_string_of_jsbytes("bdo"),
     cst_nbsp=caml_string_of_jsbytes("nbsp"),
     cst_html$0=caml_string_of_jsbytes("html"),
     cst_aria=caml_string_of_jsbytes("aria-"),
     cst_scrolling=caml_string_of_jsbytes("scrolling"),
     cst_frameborder=caml_string_of_jsbytes("frameborder"),
     cst_char=caml_string_of_jsbytes("char"),
     cst_rules=caml_string_of_jsbytes("rules"),
     cst_scope=caml_string_of_jsbytes("scope"),
     cst_align=caml_string_of_jsbytes("align"),
     cst_type$8=caml_string_of_jsbytes("type"),
     cst_type$7=caml_string_of_jsbytes("type"),
     cst_type$6=caml_string_of_jsbytes("type"),
     cst_type$5=caml_string_of_jsbytes("type"),
     cst_wrap$0=caml_string_of_jsbytes("wrap"),
     cst_translate$0=caml_string_of_jsbytes("translate"),
     cst_step=caml_string_of_jsbytes("step"),
     cst_sizes=caml_string_of_jsbytes("sizes"),
     cst_spellcheck=caml_string_of_jsbytes("spellcheck"),
     cst_sandbox=caml_string_of_jsbytes("sandbox"),
     cst_preload=caml_string_of_jsbytes("preload"),
     cst_inputmode=caml_string_of_jsbytes("inputmode"),
     cst_draggable=caml_string_of_jsbytes("draggable"),
     cst_dir=caml_string_of_jsbytes("dir"),
     cst_contenteditable=caml_string_of_jsbytes("contenteditable"),
     cst_crossorigin=caml_string_of_jsbytes("crossorigin"),
     cst_autocomplete=caml_string_of_jsbytes("autocomplete"),
     cst_referrerpolicy=caml_string_of_jsbytes("referrerpolicy"),
     cst_method$0=caml_string_of_jsbytes("method"),
     cst_width$0=caml_string_of_jsbytes("width"),
     cst_height$0=caml_string_of_jsbytes("height"),
     cst_download=caml_string_of_jsbytes("download"),
     cst_accesskey=caml_string_of_jsbytes("accesskey"),
     cst_xml_space$0=caml_string_of_jsbytes("xml:space"),
     cst_xmlns$4=caml_string_of_jsbytes("xmlns"),
     cst_data$0=caml_string_of_jsbytes("data-"),
     content_type$0=caml_string_of_jsbytes("text/html"),
     alternative_content_types=
      [0,
       caml_string_of_jsbytes("application/xhtml+xml"),
       [0,
        caml_string_of_jsbytes("application/xml"),
        [0,caml_string_of_jsbytes("text/xml"),0]]],
     version$0=caml_string_of_jsbytes("HTML5-draft"),
     standard$0=caml_string_of_jsbytes("http://www.w3.org/TR/html5/"),
     namespace$0=caml_string_of_jsbytes("http://www.w3.org/1999/xhtml"),
     cst_html=caml_string_of_jsbytes("html"),
     emptytags=
      caml_list_of_js_array
       ([caml_string_of_jsbytes("area"),
         caml_string_of_jsbytes("base"),
         caml_string_of_jsbytes("br"),
         caml_string_of_jsbytes("col"),
         caml_string_of_jsbytes("command"),
         caml_string_of_jsbytes("embed"),
         caml_string_of_jsbytes("hr"),
         caml_string_of_jsbytes("img"),
         caml_string_of_jsbytes("input"),
         caml_string_of_jsbytes("keygen"),
         caml_string_of_jsbytes("link"),
         caml_string_of_jsbytes("meta"),
         caml_string_of_jsbytes("param"),
         caml_string_of_jsbytes("source"),
         caml_string_of_jsbytes("wbr")]),
     cst_class$0=caml_string_of_jsbytes("class"),
     cst_id$0=caml_string_of_jsbytes("id"),
     cst_title$0=caml_string_of_jsbytes("title"),
     cst_xml_lang$0=caml_string_of_jsbytes("xml:lang"),
     cst_lang$0=caml_string_of_jsbytes("lang"),
     cst_style$1=caml_string_of_jsbytes("style"),
     cst_property=caml_string_of_jsbytes("property"),
     cst_onabort$0=caml_string_of_jsbytes("onabort"),
     cst_onafterprint=caml_string_of_jsbytes("onafterprint"),
     cst_onbeforeprint=caml_string_of_jsbytes("onbeforeprint"),
     cst_onbeforeunload=caml_string_of_jsbytes("onbeforeunload"),
     cst_onblur=caml_string_of_jsbytes("onblur"),
     cst_oncanplay=caml_string_of_jsbytes("oncanplay"),
     cst_oncanplaythrough=caml_string_of_jsbytes("oncanplaythrough"),
     cst_onchange=caml_string_of_jsbytes("onchange"),
     cst_ondurationchange=caml_string_of_jsbytes("ondurationchange"),
     cst_onemptied=caml_string_of_jsbytes("onemptied"),
     cst_onended=caml_string_of_jsbytes("onended"),
     cst_onerror$0=caml_string_of_jsbytes("onerror"),
     cst_onfocus=caml_string_of_jsbytes("onfocus"),
     cst_onformchange=caml_string_of_jsbytes("onformchange"),
     cst_onforminput=caml_string_of_jsbytes("onforminput"),
     cst_onhashchange=caml_string_of_jsbytes("onhashchange"),
     cst_oninput=caml_string_of_jsbytes("oninput"),
     cst_oninvalid=caml_string_of_jsbytes("oninvalid"),
     cst_onoffline=caml_string_of_jsbytes("onoffline"),
     cst_ononline=caml_string_of_jsbytes("ononline"),
     cst_onpause=caml_string_of_jsbytes("onpause"),
     cst_onplay=caml_string_of_jsbytes("onplay"),
     cst_onplaying=caml_string_of_jsbytes("onplaying"),
     cst_onpagehide=caml_string_of_jsbytes("onpagehide"),
     cst_onpageshow=caml_string_of_jsbytes("onpageshow"),
     cst_onpopstate=caml_string_of_jsbytes("onpopstate"),
     cst_onprogress=caml_string_of_jsbytes("onprogress"),
     cst_onratechange=caml_string_of_jsbytes("onratechange"),
     cst_onreadystatechange=caml_string_of_jsbytes("onreadystatechange"),
     cst_onredo=caml_string_of_jsbytes("onredo"),
     cst_onresize$0=caml_string_of_jsbytes("onresize"),
     cst_onscroll$0=caml_string_of_jsbytes("onscroll"),
     cst_onseeked=caml_string_of_jsbytes("onseeked"),
     cst_onseeking=caml_string_of_jsbytes("onseeking"),
     cst_onselect=caml_string_of_jsbytes("onselect"),
     cst_onshow=caml_string_of_jsbytes("onshow"),
     cst_onstalled=caml_string_of_jsbytes("onstalled"),
     cst_onstorage=caml_string_of_jsbytes("onstorage"),
     cst_onsubmit=caml_string_of_jsbytes("onsubmit"),
     cst_onsuspend=caml_string_of_jsbytes("onsuspend"),
     cst_ontimeupdate=caml_string_of_jsbytes("ontimeupdate"),
     cst_onundo=caml_string_of_jsbytes("onundo"),
     cst_onunload$0=caml_string_of_jsbytes("onunload"),
     cst_onvolumechange=caml_string_of_jsbytes("onvolumechange"),
     cst_onwaiting=caml_string_of_jsbytes("onwaiting"),
     cst_onload$0=caml_string_of_jsbytes("onload"),
     cst_onloadeddata=caml_string_of_jsbytes("onloadeddata"),
     cst_onloadedmetadata=caml_string_of_jsbytes("onloadedmetadata"),
     cst_onloadstart=caml_string_of_jsbytes("onloadstart"),
     cst_onmessage=caml_string_of_jsbytes("onmessage"),
     cst_onmousewheel=caml_string_of_jsbytes("onmousewheel"),
     cst_onclick$0=caml_string_of_jsbytes("onclick"),
     cst_oncontextmenu=caml_string_of_jsbytes("oncontextmenu"),
     cst_ondblclick=caml_string_of_jsbytes("ondblclick"),
     cst_ondrag=caml_string_of_jsbytes("ondrag"),
     cst_ondragend=caml_string_of_jsbytes("ondragend"),
     cst_ondragenter=caml_string_of_jsbytes("ondragenter"),
     cst_ondragleave=caml_string_of_jsbytes("ondragleave"),
     cst_ondragover=caml_string_of_jsbytes("ondragover"),
     cst_ondragstart=caml_string_of_jsbytes("ondragstart"),
     cst_ondrop=caml_string_of_jsbytes("ondrop"),
     cst_onmousedown$0=caml_string_of_jsbytes("onmousedown"),
     cst_onmouseup$0=caml_string_of_jsbytes("onmouseup"),
     cst_onmouseover$0=caml_string_of_jsbytes("onmouseover"),
     cst_onmousemove$0=caml_string_of_jsbytes("onmousemove"),
     cst_onmouseout$0=caml_string_of_jsbytes("onmouseout"),
     cst_ontouchstart$0=caml_string_of_jsbytes("ontouchstart"),
     cst_ontouchend$0=caml_string_of_jsbytes("ontouchend"),
     cst_ontouchmove$0=caml_string_of_jsbytes("ontouchmove"),
     cst_ontouchcancel$0=caml_string_of_jsbytes("ontouchcancel"),
     cst_onkeypress=caml_string_of_jsbytes("onkeypress"),
     cst_onkeydown=caml_string_of_jsbytes("onkeydown"),
     cst_onkeyup=caml_string_of_jsbytes("onkeyup"),
     cst_version$0=caml_string_of_jsbytes("version"),
     cst_manifest=caml_string_of_jsbytes("manifest"),
     cst_cite=caml_string_of_jsbytes("cite"),
     cst_charset=caml_string_of_jsbytes("charset"),
     cst_accept_charset=caml_string_of_jsbytes("accept-charset"),
     cst_accept=caml_string_of_jsbytes("accept"),
     cst_href$0=caml_string_of_jsbytes("href"),
     cst_hreflang=caml_string_of_jsbytes("hreflang"),
     cst_rel=caml_string_of_jsbytes("rel"),
     cst_tabindex=caml_string_of_jsbytes("tabindex"),
     cst_type$4=caml_string_of_jsbytes("type"),
     cst_alt=caml_string_of_jsbytes("alt"),
     cst_src=caml_string_of_jsbytes("src"),
     cst_for=caml_string_of_jsbytes("for"),
     cst_for$0=caml_string_of_jsbytes("for"),
     cst_selected=caml_string_of_jsbytes("selected"),
     cst_value=caml_string_of_jsbytes("value"),
     cst_value$0=caml_string_of_jsbytes("value"),
     cst_value$1=caml_string_of_jsbytes("value"),
     cst_value$2=caml_string_of_jsbytes("value"),
     cst_action=caml_string_of_jsbytes("action"),
     cst_enctype=caml_string_of_jsbytes("enctype"),
     cst_checked=caml_string_of_jsbytes("checked"),
     cst_disabled=caml_string_of_jsbytes("disabled"),
     cst_readonly=caml_string_of_jsbytes("readonly"),
     cst_maxlength=caml_string_of_jsbytes("maxlength"),
     cst_minlength=caml_string_of_jsbytes("minlength"),
     cst_name$0=caml_string_of_jsbytes("name"),
     cst_allowfullscreen=caml_string_of_jsbytes("allowfullscreen"),
     cst_allowpaymentrequest=caml_string_of_jsbytes("allowpaymentrequest"),
     cst_async=caml_string_of_jsbytes("async"),
     cst_autofocus=caml_string_of_jsbytes("autofocus"),
     cst_autoplay=caml_string_of_jsbytes("autoplay"),
     cst_muted=caml_string_of_jsbytes("muted"),
     cst_integrity=caml_string_of_jsbytes("integrity"),
     cst_mediagroup=caml_string_of_jsbytes("mediagroup"),
     cst_challenge=caml_string_of_jsbytes("challenge"),
     cst_contextmenu=caml_string_of_jsbytes("contextmenu"),
     cst_controls=caml_string_of_jsbytes("controls"),
     cst_form=caml_string_of_jsbytes("form"),
     cst_formaction=caml_string_of_jsbytes("formaction"),
     cst_formenctype=caml_string_of_jsbytes("formenctype"),
     cst_formnovalidate=caml_string_of_jsbytes("formnovalidate"),
     cst_formtarget=caml_string_of_jsbytes("formtarget"),
     cst_hidden=caml_string_of_jsbytes("hidden"),
     cst_high=caml_string_of_jsbytes("high"),
     cst_icon=caml_string_of_jsbytes("icon"),
     cst_ismap=caml_string_of_jsbytes("ismap"),
     cst_keytype=caml_string_of_jsbytes("keytype"),
     cst_list=caml_string_of_jsbytes("list"),
     cst_loop=caml_string_of_jsbytes("loop"),
     cst_low=caml_string_of_jsbytes("low"),
     cst_max$0=caml_string_of_jsbytes("max"),
     cst_max$1=caml_string_of_jsbytes("max"),
     cst_min$0=caml_string_of_jsbytes("min"),
     cst_min$1=caml_string_of_jsbytes("min"),
     cst_novalidate=caml_string_of_jsbytes("novalidate"),
     cst_open=caml_string_of_jsbytes("open"),
     cst_optimum=caml_string_of_jsbytes("optimum"),
     cst_pattern$0=caml_string_of_jsbytes("pattern"),
     cst_placeholder=caml_string_of_jsbytes("placeholder"),
     cst_poster=caml_string_of_jsbytes("poster"),
     cst_pubdate=caml_string_of_jsbytes("pubdate"),
     cst_radiogroup=caml_string_of_jsbytes("radiogroup"),
     cst_required=caml_string_of_jsbytes("required"),
     cst_reserved=caml_string_of_jsbytes("reserved"),
     cst_scoped=caml_string_of_jsbytes("scoped"),
     cst_seamless=caml_string_of_jsbytes("seamless"),
     cst_span=caml_string_of_jsbytes("span"),
     cst_xml_lang$1=caml_string_of_jsbytes("xml:lang"),
     cst_srcset=caml_string_of_jsbytes("srcset"),
     cst_sizes$0=caml_string_of_jsbytes("sizes"),
     cst_start$0=caml_string_of_jsbytes("start"),
     cst_size=caml_string_of_jsbytes("size"),
     cst_multiple=caml_string_of_jsbytes("multiple"),
     cst_cols=caml_string_of_jsbytes("cols"),
     cst_rows=caml_string_of_jsbytes("rows"),
     cst_summary=caml_string_of_jsbytes("summary"),
     cst_axis=caml_string_of_jsbytes("axis"),
     cst_colspan=caml_string_of_jsbytes("colspan"),
     cst_headers=caml_string_of_jsbytes("headers"),
     cst_rowspan=caml_string_of_jsbytes("rowspan"),
     cst_border=caml_string_of_jsbytes("border"),
     cst_data$1=caml_string_of_jsbytes("data"),
     cst_codetype=caml_string_of_jsbytes("codetype"),
     cst_marginheight=caml_string_of_jsbytes("marginheight"),
     cst_marginwidth=caml_string_of_jsbytes("marginwidth"),
     cst_target=caml_string_of_jsbytes("target"),
     cst_content=caml_string_of_jsbytes("content"),
     cst_http_equiv=caml_string_of_jsbytes("http-equiv"),
     cst_media$0=caml_string_of_jsbytes("media"),
     cst_role=caml_string_of_jsbytes("role"),
     cst_body=caml_string_of_jsbytes("body"),
     cst_head=caml_string_of_jsbytes("head"),
     cst_title$1=caml_string_of_jsbytes("title"),
     cst_footer=caml_string_of_jsbytes("footer"),
     cst_header=caml_string_of_jsbytes("header"),
     cst_section=caml_string_of_jsbytes("section"),
     cst_nav=caml_string_of_jsbytes("nav"),
     cst_h1=caml_string_of_jsbytes("h1"),
     cst_h2=caml_string_of_jsbytes("h2"),
     cst_h3=caml_string_of_jsbytes("h3"),
     cst_h4=caml_string_of_jsbytes("h4"),
     cst_h5=caml_string_of_jsbytes("h5"),
     cst_h6=caml_string_of_jsbytes("h6"),
     cst_hgroup=caml_string_of_jsbytes("hgroup"),
     cst_address=caml_string_of_jsbytes("address"),
     cst_blockquote=caml_string_of_jsbytes("blockquote"),
     cst_div=caml_string_of_jsbytes("div"),
     cst_p=caml_string_of_jsbytes("p"),
     cst_pre=caml_string_of_jsbytes("pre"),
     cst_abbr=caml_string_of_jsbytes("abbr"),
     cst_br=caml_string_of_jsbytes("br"),
     cst_cite$0=caml_string_of_jsbytes("cite"),
     cst_code=caml_string_of_jsbytes("code"),
     cst_dfn=caml_string_of_jsbytes("dfn"),
     cst_em$0=caml_string_of_jsbytes("em"),
     cst_kbd=caml_string_of_jsbytes("kbd"),
     cst_q=caml_string_of_jsbytes("q"),
     cst_samp=caml_string_of_jsbytes("samp"),
     cst_span$0=caml_string_of_jsbytes("span"),
     cst_strong=caml_string_of_jsbytes("strong"),
     cst_time=caml_string_of_jsbytes("time"),
     cst_var=caml_string_of_jsbytes("var"),
     cst_a$1=caml_string_of_jsbytes("a"),
     cst_dl=caml_string_of_jsbytes("dl"),
     cst_ol=caml_string_of_jsbytes("ol"),
     cst_ul=caml_string_of_jsbytes("ul"),
     cst_dd=caml_string_of_jsbytes("dd"),
     cst_dt=caml_string_of_jsbytes("dt"),
     cst_li=caml_string_of_jsbytes("li"),
     cst_hr=caml_string_of_jsbytes("hr"),
     cst_b$0=caml_string_of_jsbytes("b"),
     cst_i=caml_string_of_jsbytes("i"),
     cst_u=caml_string_of_jsbytes("u"),
     cst_small=caml_string_of_jsbytes("small"),
     cst_sub=caml_string_of_jsbytes("sub"),
     cst_sup=caml_string_of_jsbytes("sup"),
     cst_mark=caml_string_of_jsbytes("mark"),
     cst_rp=caml_string_of_jsbytes("rp"),
     cst_rt=caml_string_of_jsbytes("rt"),
     cst_ruby=caml_string_of_jsbytes("ruby"),
     cst_wbr=caml_string_of_jsbytes("wbr"),
     cst_datetime=caml_string_of_jsbytes("datetime"),
     cst_usemap=caml_string_of_jsbytes("usemap"),
     cst_defer=caml_string_of_jsbytes("defer"),
     cst_label=caml_string_of_jsbytes("label"),
     cst_map=caml_string_of_jsbytes("map"),
     cst_del=caml_string_of_jsbytes("del"),
     cst_ins=caml_string_of_jsbytes("ins"),
     cst_script$0=caml_string_of_jsbytes("script"),
     cst_noscript=caml_string_of_jsbytes("noscript"),
     cst_template=caml_string_of_jsbytes("template"),
     cst_article=caml_string_of_jsbytes("article"),
     cst_aside=caml_string_of_jsbytes("aside"),
     cst_main=caml_string_of_jsbytes("main"),
     cst_audio=caml_string_of_jsbytes("audio"),
     cst_video=caml_string_of_jsbytes("video"),
     cst_canvas=caml_string_of_jsbytes("canvas"),
     cst_embed=caml_string_of_jsbytes("embed"),
     cst_source=caml_string_of_jsbytes("source"),
     cst_meter=caml_string_of_jsbytes("meter"),
     cst_output=caml_string_of_jsbytes("output"),
     cst_form$0=caml_string_of_jsbytes("form"),
     cst_input=caml_string_of_jsbytes("input"),
     cst_keygen=caml_string_of_jsbytes("keygen"),
     cst_label$0=caml_string_of_jsbytes("label"),
     cst_option=caml_string_of_jsbytes("option"),
     cst_select=caml_string_of_jsbytes("select"),
     cst_textarea=caml_string_of_jsbytes("textarea"),
     cst_button=caml_string_of_jsbytes("button"),
     cst_progress=caml_string_of_jsbytes("progress"),
     cst_legend=caml_string_of_jsbytes("legend"),
     cst_summary$0=caml_string_of_jsbytes("summary"),
     cst_figcaption=caml_string_of_jsbytes("figcaption"),
     cst_caption=caml_string_of_jsbytes("caption"),
     cst_td=caml_string_of_jsbytes("td"),
     cst_th=caml_string_of_jsbytes("th"),
     cst_tr=caml_string_of_jsbytes("tr"),
     cst_colgroup=caml_string_of_jsbytes("colgroup"),
     cst_col=caml_string_of_jsbytes("col"),
     cst_thead=caml_string_of_jsbytes("thead"),
     cst_tbody=caml_string_of_jsbytes("tbody"),
     cst_tfoot=caml_string_of_jsbytes("tfoot"),
     cst_iframe=caml_string_of_jsbytes("iframe"),
     cst_param=caml_string_of_jsbytes("param"),
     cst_meta=caml_string_of_jsbytes("meta"),
     cst_base=caml_string_of_jsbytes("base"),
     Stdlib=global_data.Stdlib,
     Stdlib_list=global_data.Stdlib__list,
     Stdlib_seq=global_data.Stdlib__seq,
     Stdlib_printf=global_data.Stdlib__printf,
     Stdlib_string=global_data.Stdlib__string,
     Stdlib_format=global_data.Stdlib__format,
     Stdlib_set=global_data.Stdlib__set,
     Stdlib_uchar=global_data.Stdlib__uchar,
     Stdlib_buffer=global_data.Stdlib__buffer,
     Uutf=global_data.Uutf,
     Re=global_data.Re,
     _L_=[0,[2,0,[12,61,[2,0,0]]],caml_string_of_jsbytes("%s=%s")],
     _H_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _I_=[0,[12,34,[4,0,0,0,[12,34,0]]],caml_string_of_jsbytes('"%d"')],
     _J_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _K_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _F_=
      [0,
       [2,0,[17,[0,caml_string_of_jsbytes("@,"),0,0],0]],
       caml_string_of_jsbytes("%s@,")],
     _G_=
      [0,
       [11,
        caml_string_of_jsbytes("<!-- "),
        [2,
         0,
         [11,
          caml_string_of_jsbytes(" -->"),
          [17,[0,caml_string_of_jsbytes("@,"),0,0],0]]]],
       caml_string_of_jsbytes("<!-- %s -->@,")],
     _C_=
      [0,
       [12,
        60,
        [16,
         [15,
          [12,
           62,
           [16,
            [15,[16,[16,[11,caml_string_of_jsbytes("<\/"),[2,0,partial]]]]]]]]]],
       caml_string_of_jsbytes("<%t%a>%t%a%t%t<\/%s>")],
     _D_=
      [0,
       [11,
        caml_string_of_jsbytes("<!--"),
        [2,0,[11,caml_string_of_jsbytes("-->"),0]]],
       caml_string_of_jsbytes("<!--%s-->")],
     _E_=[0,[12,38,[2,0,[12,59,0]]],caml_string_of_jsbytes("&%s;")],
     _A_=
      [0,
       [12,60,[15,[11,caml_string_of_jsbytes("/>"),0]]],
       caml_string_of_jsbytes("<%a/>")],
     _B_=
      [0,
       [12,
        60,
        [15,[12,62,[16,[11,caml_string_of_jsbytes("<\/"),[2,0,[12,62,0]]]]]]],
       caml_string_of_jsbytes("<%a>%t<\/%s>")],
     _z_=[0,[2,0,[15,[16,0]]],caml_string_of_jsbytes("%s%a%t")],
     _y_=[0,[16,[2,0,[12,61,[15,0]]]],caml_string_of_jsbytes("%t%s=%a")],
     _u_=[0,[12,34,[15,[12,34,0]]],caml_string_of_jsbytes('"%a"')],
     _v_=[0,[12,34,[4,0,0,0,[12,34,0]]],caml_string_of_jsbytes('"%d"')],
     _w_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _x_=[0,[12,34,[15,[12,34,0]]],caml_string_of_jsbytes('"%a"')],
     _t_=[0,[12,44,[16,0]],caml_string_of_jsbytes(",%t")],
     _s_=
      [0,
       [18,[1,[0,0,caml_string_of_jsbytes("")]],[15,[17,0,0]]],
       caml_string_of_jsbytes("@[%a@]")],
     _r_=[0,[15,0],caml_string_of_jsbytes("%a")],
     _n_=[0,[4,0,0,0,[12,101,[4,0,0,0,0]]],caml_string_of_jsbytes("%de%d")],
     _o_=[0,[8,[0,0,3],0,[0,12],0],caml_string_of_jsbytes("%.12g")],
     _p_=[0,[8,[0,0,3],0,[0,15],0],caml_string_of_jsbytes("%.15g")],
     _q_=[0,[8,[0,0,3],0,[0,18],0],caml_string_of_jsbytes("%.18g")],
     _m_=[0,1],
     _c_=[0,[12,34,[2,0,[12,34,0]]],caml_string_of_jsbytes('"%s"')],
     _d_=
      [0,
       [11,caml_string_of_jsbytes(" PUBLIC "),[15,0]],
       caml_string_of_jsbytes(" PUBLIC %a")],
     _e_=
      [0,
       [11,caml_string_of_jsbytes("<!DOCTYPE "),[2,0,[15,[12,62,0]]]],
       caml_string_of_jsbytes("<!DOCTYPE %s%a>")],
     _b_=
      [0,
       [11,
        caml_string_of_jsbytes('<?xml version="'),
        [2,
         0,
         [11,
          caml_string_of_jsbytes('" encoding="'),
          [2,0,[11,caml_string_of_jsbytes('"?>\\n'),0]]]]],
       caml_string_of_jsbytes('<?xml version="%s" encoding="%s"?>\\n')],
     _X_=
      [0,
       [11,caml_string_of_jsbytes("skewY("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("skewY(%s)")],
     _Y_=
      [0,
       [11,caml_string_of_jsbytes("skewX("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("skewX(%s)")],
     _Z_=
      [0,
       [11,caml_string_of_jsbytes("scale("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("scale(%s)")],
     ___=
      [0,
       [8,[0,0,3],0,0,[12,32,[8,[0,0,3],0,0,0]]],
       caml_string_of_jsbytes("%g %g")],
     _$_=
      [0,
       [11,caml_string_of_jsbytes("rotate("),[2,0,[12,32,[2,0,[12,41,0]]]]],
       caml_string_of_jsbytes("rotate(%s %s)")],
     _aa_=
      [0,
       [11,
        caml_string_of_jsbytes("matrix("),
        [8,
         [0,0,3],
         0,
         0,
         [12,
          32,
          [8,
           [0,0,3],
           0,
           0,
           [12,
            32,
            [8,
             [0,0,3],
             0,
             0,
             [12,32,[8,[0,0,3],0,0,[12,32,[8,partial$1,0,0,partial$0]]]]]]]]]],
       caml_string_of_jsbytes("matrix(%g %g %g %g %g %g)")],
     _ab_=
      [0,
       [11,caml_string_of_jsbytes("translate("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("translate(%s)")],
     _U_=
      [0,
       [8,[0,0,3],0,0,[11,caml_string_of_jsbytes(", "),[8,[0,0,3],0,0,0]]],
       caml_string_of_jsbytes("%g, %g")],
     _V_=[0,[8,[0,0,3],0,0,0],caml_string_of_jsbytes("%g")],
     _T_=
      [0,
       [2,0,[12,32,[2,0,[12,32,[2,0,[12,32,[2,0,0]]]]]]],
       caml_string_of_jsbytes("%s %s %s %s")],
     _S_=
      [0,
       [8,[0,0,3],0,0,[11,caml_string_of_jsbytes(", "),[8,[0,0,3],0,0,0]]],
       caml_string_of_jsbytes("%g, %g")],
     _W_=[0,caml_string_of_jsbytes("; ")],
     _R_=
      [0,
       caml_string_of_jsbytes("-//W3C//DTD SVG 1.1//EN"),
       [0,
        caml_string_of_jsbytes
         ("http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"),
        0]],
     _Q_=[0,[8,[0,0,3],0,0,[2,0,0]],caml_string_of_jsbytes("%g%s")],
     _P_=
      [0,
       [11,caml_string_of_jsbytes("url("),[2,0,[12,41,0]]],
       caml_string_of_jsbytes("url(%s)")],
     _ag_=[0,[2,0,[12,32,[2,0,[12,120,0]]]],caml_string_of_jsbytes("%s %sx")],
     _af_=[0,[2,0,[12,32,[2,0,[12,119,0]]]],caml_string_of_jsbytes("%s %sw")],
     _ae_=[0,[4,0,0,0,[12,120,[4,0,0,0,0]]],caml_string_of_jsbytes("%dx%d")];
    function fmap(f){return f}
    function nil(param){return 0}
    function singleton(x){return [0,x,0]}
    function cons(x,xs){return [0,x,xs]}
    function append(x,y){return caml_call2(Stdlib[37],x,y)}
    var
     map=Stdlib_list[17],
     Xml_wrap=
      [0,[0,function(_nk_){return _nk_},fmap,nil,singleton,cons,append,map]];
    caml_register_global(1088,Xml_wrap,"Xml_wrap");
    var
     Malformed_stream=
      [248,cst_Xml_stream_Malformed_strea,runtime.caml_fresh_oo_id(0)];
    function _a_(Xml)
     {function of_list(l)
       {var _nh_=caml_call1(Xml[1][3],0);
        function _ni_(a,b)
         {var _nj_=caml_call1(Xml[1][1],a);
          return caml_call2(Xml[1][5],_nj_,b)}
        return caml_call3(Stdlib_list[24],_ni_,l,_nh_)}
      function mk(children,seq)
       {var children$0=children,seq$0=seq;
        for(;;)
         {var match=caml_call1(seq$0,0);
          if(match)
           {var _m$_=match[1];
            if(typeof _m$_ === "number")
             {var rest=match[2];
              return [0,of_list(caml_call1(Stdlib_list[9],children$0)),rest]}
            var _na_=_m$_[1];
            if(856096383 === _na_)
             {var
               q=match[2],
               _nb_=_m$_[2],
               attrs=_nb_[2],
               match$0=_nb_[1],
               name=match$0[2],
               f=
                function(param)
                 {var
                   v=param[2],
                   match=param[1],
                   name=match[2],
                   _ng_=caml_call1(Xml[1][1],v);
                  return caml_call2(Xml[6],name,_ng_)},
               a=caml_call2(Stdlib_list[17],f,attrs),
               match$1=mk(0,q),
               rest$0=match$1[2],
               sub_children=match$1[1],
               children$1=
                [0,caml_call3(Xml[21],[0,a],name,sub_children),children$0],
               children$0=children$1,
               seq$0=rest$0;
              continue}
            if(936573133 <= _na_)
             {var
               q$0=match[2],
               s=_m$_[2],
               _nc_=
                function(x)
                 {var _nf_=caml_call1(Xml[1][1],x);
                  return caml_call1(Xml[17],_nf_)},
               _nd_=caml_call2(Stdlib_list[17],_nc_,s),
               children$2=caml_call2(Stdlib[37],_nd_,children$0),
               children$0=children$2,
               seq$0=q$0;
              continue}
            var
             q$1=match[2],
             s$0=_m$_[2],
             children$3=[0,caml_call1(Xml[16],s$0),children$0],
             children$0=children$3,
             seq$0=q$1;
            continue}
          var _ne_=Stdlib_seq[1];
          return [0,of_list(caml_call1(Stdlib_list[9],children$0)),_ne_]}}
      function of_seq(seq)
       {var
         match=mk(0,seq),
         rest=match[2],
         l=match[1],
         match$0=caml_call1(rest,0);
        if(match$0)throw Malformed_stream;
        return l}
      return [0,of_seq]}
    var Xml_stream=[0,Malformed_stream,_a_];
    caml_register_global(1090,Xml_stream,"Xml_stream");
    function add_unsafe_char(b,c)
     {if(34 === c)return caml_call2(Stdlib_buffer[14],b,cst_quot);
      if(60 <= c)
       {if(! (63 <= c))
         {var switcher=c - 60 | 0;
          switch(switcher)
           {case 0:return caml_call2(Stdlib_buffer[14],b,cst_lt);
            case 1:break;
            default:return caml_call2(Stdlib_buffer[14],b,cst_gt)}}}
      else
       if(38 === c)return caml_call2(Stdlib_buffer[14],b,cst_amp);
      var _m4_=c <= 8?1:0;
      if(_m4_)
       var _m5_=_m4_;
      else
       {var _m6_=11 === c?1:0;
        if(_m6_)
         var _m5_=_m6_;
        else
         {var _m7_=12 === c?1:0;
          if(_m7_)
           var _m5_=_m7_;
          else
           var
            _m8_=14 <= c?1:0,
            _m9_=_m8_?c <= 31?1:0:_m8_,
            _m5_=_m9_ || (127 === c?1:0)}}
      if(_m5_)
       {caml_call2(Stdlib_buffer[14],b,cst);
        var _m__=caml_call1(Stdlib[33],c);
        caml_call2(Stdlib_buffer[14],b,_m__);
        return caml_call2(Stdlib_buffer[14],b,cst$0)}
      return caml_call2(Stdlib_buffer[10],b,c)}
    function encode_unsafe_char(s)
     {var b=caml_call1(Stdlib_buffer[1],caml_ml_string_length(s));
      function _m2_(_m3_){return add_unsafe_char(b,_m3_)}
      caml_call2(Stdlib_string[8],_m2_,s);
      return caml_call1(Stdlib_buffer[2],b)}
    function encode_unsafe_char_and_at(s)
     {var b=caml_call1(Stdlib_buffer[1],caml_ml_string_length(s));
      function f(c)
       {return 64 === c
                ?caml_call2(Stdlib_buffer[14],b,cst_64)
                :add_unsafe_char(b,c)}
      caml_call2(Stdlib_string[8],f,s);
      return caml_call1(Stdlib_buffer[2],b)}
    function compose_decl(opt,_m1_,param)
     {if(opt)var sth=opt[1],version=sth;else var version=cst_1_0;
      if(_m1_)var sth$0=_m1_[1],encoding=sth$0;else var encoding=cst_UTF_8;
      return caml_call3(Stdlib_format[128],_b_,version,encoding)}
    function compose_doctype(dt,args)
     {function pp_args(fmt,l)
       {if(l)
         {var
           _mZ_=function(fmt){return caml_call2(Stdlib_format[125],fmt,_c_)},
           _m0_=caml_call2(Stdlib_format[121],[0,Stdlib_format[25]],_mZ_);
          return caml_call4(Stdlib_format[125],fmt,_d_,_m0_,l)}
        return 0}
      return caml_call4(Stdlib_format[129],_e_,dt,pp_args,args)}
    var
     _f_=[0,caml_call1(Re[23],cst$1),0],
     _g_=[0,caml_call1(Re[23],cst$2),_f_],
     _h_=[0,caml_call1(Re[23],cst$3),0],
     _i_=[0,caml_call1(Re[26],[0,Re[37],_h_]),_g_],
     _j_=[0,caml_call1(Re[23],cst$4),0],
     _k_=[0,caml_call1(Re[26],[0,Re[37],_j_]),_i_],
     _l_=caml_call1(Re[25],_k_),
     re_end_comment=caml_call1(Re[2],_l_);
    function pp_number(fmt,v)
     {if(v == Stdlib[22])
       return caml_call2(Stdlib_format[13],fmt,cst_Infinity);
      if(v == Stdlib[23])
       return caml_call2(Stdlib_format[13],fmt,cst_Infinity$0);
      if(v != v)return caml_call2(Stdlib_format[13],fmt,cst_NaN);
      var n=v | 0;
      if(n == v)
       {var n$0=n,i=0;
        for(;;)
         {if(0 !== n$0 && 0 === (n$0 % 10 | 0))
           {var i$0=i + 1 | 0,n$1=n$0 / 10 | 0,n$0=n$1,i=i$0;continue}
          return 2 < i
                  ?caml_call4(Stdlib_format[125],fmt,_n_,n$0,i)
                  :caml_call2(Stdlib_format[17],fmt,n)}}
      var s1=caml_call2(Stdlib_printf[4],_o_,v);
      if(v == caml_float_of_string(s1))
       return caml_call2(Stdlib_format[13],fmt,s1);
      var s2=caml_call2(Stdlib_printf[4],_p_,v);
      return v == caml_float_of_string(s2)
              ?caml_call2(Stdlib_format[13],fmt,s2)
              :caml_call3(Stdlib_format[125],fmt,_q_,v)}
    function string_of_number(v)
     {return caml_call3(Stdlib_format[129],_r_,pp_number,v)}
    function normalize(src)
     {var
       warn=[0,0],
       buffer=caml_call1(Stdlib_buffer[1],caml_ml_string_length(src)),
       _mV_=0;
      function _mW_(param,_mY_,d)
       {if(852405675 <= d[1])
         {var code=d[2];return caml_call2(Uutf[23][1],buffer,code)}
        caml_call2(Uutf[23][1],buffer,Uutf[2]);
        warn[1] = 1;
        return 0}
      caml_call5(Uutf[22][2],0,0,_mW_,_mV_,src);
      var _mX_=warn[1];
      return [0,caml_call1(Stdlib_buffer[2],buffer),_mX_]}
    function normalize_html(src)
     {var l=caml_ml_string_length(src),i=0;
      for(;;)
       {var _mP_=i < l?1:0;
        if(_mP_)
         {var match=runtime.caml_string_get(src,i),switch$0=0;
          if(35 <= match)
           {if(61 <= match)
             {if(62 === match)switch$0 = 1;else if(127 <= match)switch$0 = 2}
            else
             if(38 === match || 60 <= match)switch$0 = 1}
          else
           if(11 <= match)
            {if(32 <= match)
              {if(34 <= match)switch$0 = 1}
             else
              if(13 !== match)switch$0 = 2}
           else
            if(! (9 <= match))switch$0 = 2;
          switch(switch$0)
           {case 2:var _mQ_=1;break;
            case 1:var _mQ_=1;break;
            default:var i$0=i + 1 | 0,i=i$0;continue}}
        else
         var _mQ_=_mP_;
        if(_mQ_)
         {var
           warn=[0,0],
           buffer=caml_call1(Stdlib_buffer[1],caml_ml_string_length(src)),
           _mR_=0,
           _mS_=
            function(param,_mU_,d)
             {if(852405675 <= d[1])
               {var u=d[2],code=caml_call1(Stdlib_uchar[10],u);
                if(34 === code)
                 return caml_call2(Stdlib_buffer[14],buffer,cst_quot$0);
                if(60 <= code)
                 {if(! (63 <= code))
                   {var switcher=code - 60 | 0;
                    switch(switcher)
                     {case 0:
                       return caml_call2(Stdlib_buffer[14],buffer,cst_lt$0);
                      case 1:break;
                      default:return caml_call2(Stdlib_buffer[14],buffer,cst_gt$4)}}}
                else
                 if(38 === code)
                  return caml_call2(Stdlib_buffer[14],buffer,cst_amp$0);
                var switch$0=0;
                if(! (31 < code) && 9 !== code && 10 !== code && 13 !== code)
                 switch$0 = 1;
                var switch$1=0;
                if(! switch$0)
                 {var switch$2=0;
                  if(127 <= code && ! (159 < code))switch$2 = 1;
                  if
                   (!
                    switch$2
                    &&
                    65534
                    !==
                    (code & 65535)
                    &&
                    65535
                    !==
                    (code & 65535))
                   {var u$0=u;switch$1 = 1}}
                if(! switch$1){warn[1] = 1;var u$0=Uutf[2]}
                return caml_call2(Uutf[23][1],buffer,u$0)}
              caml_call2(Uutf[23][1],buffer,Uutf[2]);
              warn[1] = 1;
              return 0};
          caml_call5(Uutf[22][2],0,0,_mS_,_mR_,src);
          var _mT_=warn[1];
          return [0,caml_call1(Stdlib_buffer[2],buffer),_mT_]}
        return [0,src,0]}}
    function pp_noop(fmt,param){return 0}
    function Make_fmt(Xml,_lY_)
     {function open_box(indent,fmt)
       {return indent?caml_call2(Stdlib_format[1],fmt,0):0}
      function close_box(indent,fmt)
       {return indent?caml_call2(Stdlib_format[3],fmt,0):0}
      function sp(indent,fmt)
       {return indent
                ?caml_call2(Stdlib_format[25],fmt,0)
                :caml_call2(Stdlib_format[13],fmt,cst$9)}
      function cut(indent,fmt)
       {return indent?caml_call2(Stdlib_format[27],fmt,0):0}
      var S=caml_call1(Stdlib_set[1],[0,Stdlib_string[33]]),_lZ_=_lY_[1];
      if(_lZ_)
       var
        _l0_=S[1],
        _l1_=function(s,x){return caml_call2(S[4],x,s)},
        set=caml_call3(Stdlib_list[23],_l1_,_l0_,_lZ_),
        is_emptytag=function(x){return caml_call2(S[3],x,set)};
      else
       var is_emptytag=function(param){return 0};
      function pp_encode(encode,indent,fmt,s)
       {var s$0=caml_call1(encode,s);
        return indent
                ?caml_call4(Stdlib_format[125],fmt,_s_,Stdlib_format[122],s$0)
                :caml_call2(Stdlib_format[13],fmt,s$0)}
      function pp_sep(indent,param)
       {return param
                ?function(fmt,param)
                  {function _mN_(_mO_){return sp(indent,_mO_)}
                   return caml_call3(Stdlib_format[125],fmt,_t_,_mN_)}
                :function(fmt,param){return sp(indent,fmt)}}
      function pp_attrib_value(encode,indent,fmt,a)
       {var match=caml_call1(Xml[26],a);
        switch(match[0])
         {case 0:
           var f=match[1];
           return caml_call4(Stdlib_format[125],fmt,_u_,pp_number,f);
          case 1:
           var i=match[1];return caml_call3(Stdlib_format[125],fmt,_v_,i);
          case 2:
           var s=match[1],_mH_=caml_call1(encode,s);
           return caml_call3(Stdlib_format[125],fmt,_w_,_mH_);
          default:
           var
            slist=match[2],
            sep=match[1],
            _mI_=
             function(_mL_,_mM_){return pp_encode(encode,indent,_mL_,_mM_)},
            _mJ_=[0,pp_sep(indent,sep)],
            _mK_=caml_call2(Stdlib_format[121],_mJ_,_mI_);
           return caml_call4(Stdlib_format[125],fmt,_x_,_mK_,slist)}}
      function pp_attrib(encode,indent,fmt,a)
       {function _mB_(_mF_,_mG_)
         {return pp_attrib_value(encode,indent,_mF_,_mG_)}
        var _mC_=caml_call1(Xml[25],a);
        function _mD_(_mE_){return sp(indent,_mE_)}
        return caml_call6(Stdlib_format[125],fmt,_y_,_mD_,_mC_,_mB_,a)}
      function pp_attribs(encode,indent)
       {function _my_(_mz_,_mA_){return pp_attrib(encode,indent,_mz_,_mA_)}
        return caml_call2(Stdlib_format[121],[0,pp_noop],_my_)}
      function pp_tag_and_attribs(encode,indent,fmt,param)
       {var attrs=param[2],tag=param[1];
        open_box(indent,fmt);
        function _mv_(_mx_){return cut(indent,_mx_)}
        var _mw_=pp_attribs(encode,indent);
        caml_call6(Stdlib_format[125],fmt,_z_,tag,_mw_,attrs,_mv_);
        return close_box(indent,fmt)}
      function pp_closedtag(encode,indent,fmt,tag,attrs)
       {if(is_emptytag(tag))
         {var
           _ml_=[0,tag,attrs],
           _mm_=
            function(_mt_,_mu_)
             {return pp_tag_and_attribs(encode,indent,_mt_,_mu_)};
          return caml_call4(Stdlib_format[125],fmt,_A_,_mm_,_ml_)}
        open_box(indent,fmt);
        function _mn_(_ms_){return cut(indent,_ms_)}
        var _mo_=[0,tag,attrs];
        function _mp_(_mq_,_mr_)
         {return pp_tag_and_attribs(encode,indent,_mq_,_mr_)}
        caml_call6(Stdlib_format[125],fmt,_B_,_mp_,_mo_,_mn_,tag);
        return close_box(indent,fmt)}
      function pp_elts(encode,indent)
       {function _mh_(_mj_,_mk_){return pp_elt(encode,indent,_mj_,_mk_)}
        var _mi_=[0,function(fmt,param){return cut(indent,fmt)}];
        return caml_call2(Stdlib_format[121],_mi_,_mh_)}
      function pp_tag(encode,indent,fmt,tag,attrs,children)
       {if(children)
         {open_box(indent,fmt);
          var
           _l6_=function(_mg_){return cut(indent,_mg_)},
           _l7_=function(_mf_){return close_box(indent,_mf_)},
           _l8_=pp_elts(encode,indent),
           _l9_=function(_me_){return cut(indent,_me_)},
           _l__=[0,tag,attrs],
           _l$_=
            function(_mc_,_md_)
             {return pp_tag_and_attribs(encode,indent,_mc_,_md_)},
           _ma_=function(_mb_){return open_box(indent,_mb_)};
          caml_call11
           (Stdlib_format[125],
            fmt,
            _C_,
            _ma_,
            _l$_,
            _l__,
            _l9_,
            _l8_,
            children,
            _l7_,
            _l6_,
            tag);
          return close_box(indent,fmt)}
        return pp_closedtag(encode,indent,fmt,tag,attrs)}
      function pp_elt(encode,indent,fmt,elt)
       {var match=caml_call1(Xml[27],elt);
        if(typeof match === "number")
         return 0;
        else
         switch(match[0])
          {case 0:
            var
             texte=match[1],
             f=
              function(g)
               {var s=caml_call2(Re[1][1],g,0);
                return caml_string_notequal(s,cst$5)
                        ?caml_string_notequal(s,cst$6)
                          ?caml_string_notequal(s,cst$7)
                            ?caml_string_notequal(s,cst$8)?s:cst_gt$0
                            :cst_gt$1
                          :cst_gt$2
                        :cst_gt$3},
             _l5_=caml_call6(Re[21],0,0,_m_,re_end_comment,f,texte);
            return caml_call3(Stdlib_format[125],fmt,_D_,_l5_);
           case 1:
            var texte$0=match[1];
            return caml_call2(Stdlib_format[13],fmt,texte$0);
           case 2:
            var texte$1=match[1];return pp_encode(encode,indent,fmt,texte$1);
           case 3:
            var e=match[1];return caml_call3(Stdlib_format[125],fmt,_E_,e);
           case 4:
            var xh_attrs=match[2],name=match[1];
            return pp_closedtag(encode,indent,fmt,name,xh_attrs);
           default:
            var xh_taglist=match[3],xh_attrs$0=match[2],name$0=match[1];
            return pp_tag(encode,indent,fmt,name$0,xh_attrs$0,xh_taglist)}}
      function pp(opt,_l2_,param)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        if(_l2_)var sth$0=_l2_[1],indent=sth$0;else var indent=0;
        return function(_l3_,_l4_){return pp_elt(encode,indent,_l3_,_l4_)}}
      return [0,
              open_box,
              close_box,
              sp,
              cut,
              S,
              is_emptytag,
              pp_encode,
              pp_sep,
              pp_attrib_value,
              pp_attrib,
              pp_attribs,
              pp_tag_and_attribs,
              pp_closedtag,
              pp_tag,
              pp_elt,
              pp_elts,
              pp]}
    function Make(Xml,I,O)
     {var symbol=O[2];
      function separator_to_string(param){return param?cst$10:cst$11}
      function attrib_value_to_string(encode,a)
       {var match=caml_call1(Xml[26],a);
        switch(match[0])
         {case 0:
           var f=match[1],_lU_=string_of_number(f);
           return caml_call2(Stdlib_printf[4],_H_,_lU_);
          case 1:var i=match[1];return caml_call2(Stdlib_printf[4],_I_,i);
          case 2:
           var s=match[1],_lV_=caml_call1(encode,s);
           return caml_call2(Stdlib_printf[4],_J_,_lV_);
          default:
           var
            slist=match[2],
            sep=match[1],
            _lW_=separator_to_string(sep),
            _lX_=caml_call1(encode,caml_call2(Stdlib_string[7],_lW_,slist));
           return caml_call2(Stdlib_printf[4],_K_,_lX_)}}
      function attrib_to_string(encode,a)
       {var _lS_=attrib_value_to_string(encode,a),_lT_=caml_call1(Xml[25],a);
        return caml_call3(Stdlib_printf[4],_L_,_lT_,_lS_)}
      function xh_print_attrs(encode,attrs)
       {if(attrs)
         {var
           queue=attrs[2],
           attr=attrs[1],
           _lP_=xh_print_attrs(encode,queue),
           _lQ_=attrib_to_string(encode,attr),
           _lR_=caml_call2(Stdlib[28],cst$12,_lQ_);
          return caml_call2(symbol,caml_call1(O[3],_lR_),_lP_)}
        return O[1]}
      function xh_print_closedtag(encode,tag,attrs)
       {if(0 !== I[1] && ! caml_call2(Stdlib_list[34],tag,I[1]))
         {var
           _lK_=caml_call2(Stdlib[28],tag,cst$15),
           _lL_=caml_call2(Stdlib[28],cst$16,_lK_),
           _lM_=caml_call1(O[3],_lL_),
           _lN_=xh_print_attrs(encode,attrs),
           _lO_=caml_call2(Stdlib[28],cst$17,tag);
          return caml_call2
                  (symbol,caml_call2(symbol,caml_call1(O[3],_lO_),_lN_),_lM_)}
        var
         _lH_=caml_call1(O[3],cst$13),
         _lI_=xh_print_attrs(encode,attrs),
         _lJ_=caml_call2(Stdlib[28],cst$14,tag);
        return caml_call2
                (symbol,caml_call2(symbol,caml_call1(O[3],_lJ_),_lI_),_lH_)}
      function xh_print_taglist(encode,taglist)
       {var taglist$0=taglist;
        for(;;)
         {if(taglist$0)
           {var
             queue=taglist$0[2],
             elt=taglist$0[1],
             match=caml_call1(Xml[27],elt);
            if(typeof match === "number")
             {var taglist$0=queue;continue}
            else
             switch(match[0])
              {case 0:
                var
                 texte=match[1],
                 _lx_=xh_print_taglist(encode,queue),
                 _ly_=caml_call1(encode,texte),
                 _lz_=caml_call2(Stdlib[28],_ly_,cst$22),
                 _lA_=caml_call2(Stdlib[28],cst$23,_lz_);
                return caml_call2(symbol,caml_call1(O[3],_lA_),_lx_);
               case 1:
                var texte$0=match[1],_lB_=xh_print_taglist(encode,queue);
                return caml_call2(symbol,caml_call1(O[3],texte$0),_lB_);
               case 2:
                var
                 texte$1=match[1],
                 _lC_=xh_print_taglist(encode,queue),
                 _lD_=caml_call1(encode,texte$1);
                return caml_call2(symbol,caml_call1(O[3],_lD_),_lC_);
               case 3:
                var
                 e=match[1],
                 _lE_=xh_print_taglist(encode,queue),
                 _lF_=caml_call2(Stdlib[28],e,cst$24),
                 _lG_=caml_call2(Stdlib[28],cst$25,_lF_);
                return caml_call2(symbol,caml_call1(O[3],_lG_),_lE_);
               case 4:
                var xh_attrs=match[2],name=match[1];
                return print_nodes(encode,name,xh_attrs,0,queue);
               default:
                var xh_taglist=match[3],xh_attrs$0=match[2],name$0=match[1];
                return print_nodes(encode,name$0,xh_attrs$0,xh_taglist,queue)}}
          return O[1]}}
      function print_nodes(encode,name,xh_attrs,xh_taglist,queue)
       {var _lw_=xh_print_taglist(encode,queue);
        return caml_call2
                (symbol,xh_print_tag(encode,name,xh_attrs,xh_taglist),_lw_)}
      function xh_print_tag(encode,tag,attrs,taglist)
       {if(0 === taglist)return xh_print_closedtag(encode,tag,attrs);
        var
         _lp_=caml_call2(Stdlib[28],tag,cst$18),
         _lq_=caml_call2(Stdlib[28],cst$19,_lp_),
         _lr_=caml_call1(O[3],_lq_),
         _ls_=xh_print_taglist(encode,taglist),
         _lt_=caml_call1(O[3],cst$20),
         _lu_=xh_print_attrs(encode,attrs),
         _lv_=caml_call2(Stdlib[28],cst$21,tag);
        return caml_call2
                (symbol,
                 caml_call2
                  (symbol,
                   caml_call2
                    (symbol,caml_call2(symbol,caml_call1(O[3],_lv_),_lu_),_lt_),
                   _ls_),
                 _lr_)}
      function print_list(opt,foret)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        var _lo_=xh_print_taglist(encode,foret);
        return caml_call1(O[4],_lo_)}
      return [0,
              symbol,
              separator_to_string,
              attrib_value_to_string,
              attrib_to_string,
              xh_print_attrs,
              xh_print_closedtag,
              xh_print_tag,
              print_nodes,
              xh_print_taglist,
              print_list]}
    function Make_typed(Xml,Typed_xml,O)
     {var P=Make(Xml,[0,Typed_xml[1][7]],O),symbol=O[2];
      function print_list(opt,foret)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        var
         _lm_=caml_call2(Stdlib_list[17],Typed_xml[2],foret),
         _ln_=caml_call2(P[9],encode,_lm_);
        return caml_call1(O[4],_ln_)}
      function print(opt,_lf_,doc)
       {if(opt)var sth=opt[1],encode=sth;else var encode=encode_unsafe_char;
        if(_lf_)var sth$0=_lf_[1],advert=sth$0;else var advert=cst$30;
        var
         doc$0=caml_call1(Typed_xml[3],doc),
         match=caml_call1(Xml[27],doc$0),
         switch$0=0;
        if(typeof match !== "number" && 5 === match[0])
         {var
           c=match[3],
           a=match[2],
           n=match[1],
           _ll_=
            function(a)
             {return caml_string_equal(caml_call1(Xml[25],a),cst_xmlns$1)},
           a$0=
            caml_call2(Stdlib_list[31],_ll_,a)
             ?a
             :[0,caml_call2(Xml[6],cst_xmlns$2,Typed_xml[1][5]),a],
           doc$1=caml_call3(Xml[21],[0,a$0],n,c);
          switch$0 = 1}
        if(! switch$0)var doc$1=doc$0;
        var _lg_=caml_call2(P[9],encode,[0,doc$1,0]);
        if(caml_string_notequal(advert,cst$26))
         var
          _lh_=caml_call2(Stdlib[28],advert,cst$27),
          _li_=caml_call2(Stdlib[28],cst$28,_lh_);
        else
         var _li_=cst$29;
        var
         _lj_=caml_call1(O[3],_li_),
         _lk_=
          caml_call2
           (symbol,
            caml_call2(symbol,caml_call1(O[3],Typed_xml[1][6]),_lj_),
            _lg_);
        return caml_call1(O[4],_lk_)}
      return [0,P,symbol,print_list,print]}
    function Simple_output(M)
     {function empty(param){return 0}
      function concat(f1,f2,param){caml_call1(f1,0);return caml_call1(f2,0)}
      function put(s,param){return caml_call1(M[1],s)}
      function make(f){return caml_call1(f,0)}
      return [0,empty,concat,put,make]}
    function Make_simple(Xml,I)
     {function print_list(output)
       {return Make(Xml,I,Simple_output([0,output]))[10]}
      return [0,print_list]}
    function Make_typed_simple(Xml,Typed_xml)
     {function print_list(output)
       {return Make_typed(Xml,Typed_xml,Simple_output([0,output]))[3]}
      function print(output)
       {return Make_typed(Xml,Typed_xml,Simple_output([0,output]))[4]}
      return [0,print_list,print]}
    function _M_(_ld_,_lc_,_lb_)
     {var _le_=Make_typed(_ld_,_lc_,_lb_);return [0,_le_[3],_le_[4]]}
    function _N_(_la_,_k$_,_k__){return [0,Make(_la_,_k$_,_k__)[10]]}
    function _O_(_k9_,_k8_){return [0,Make_fmt(_k9_,_k8_)[17]]}
    var
     Xml_print=
      [0,
       encode_unsafe_char,
       encode_unsafe_char_and_at,
       [0,normalize,normalize_html],
       compose_decl,
       compose_doctype,
       string_of_number,
       pp_number,
       function(Xml,Typed_xml)
        {var P=Make_fmt(Xml,[0,Typed_xml[1][7]]);
         function pp_elt(opt,_k6_,param,fmt,foret)
          {if(opt)
            var sth=opt[1],encode=sth;
           else
            var encode=encode_unsafe_char;
           if(_k6_)var sth$0=_k6_[1],indent=sth$0;else var indent=0;
           var _k7_=caml_call1(Typed_xml[2],foret);
           return caml_call4(P[15],encode,indent,fmt,_k7_)}
         function pp(opt,_k4_,advert,param,fmt,doc$0)
          {if(opt)
            var sth=opt[1],encode=sth;
           else
            var encode=encode_unsafe_char;
           if(_k4_)var sth$0=_k4_[1],indent=sth$0;else var indent=0;
           caml_call2(Stdlib_format[7],fmt,0);
           caml_call3(Stdlib_format[125],fmt,_F_,Typed_xml[1][6]);
           if(advert)
            {var s=advert[1];caml_call3(Stdlib_format[125],fmt,_G_,s)}
           var
            doc=caml_call1(Typed_xml[3],doc$0),
            match=caml_call1(Xml[27],doc),
            switch$0=0;
           if(typeof match !== "number" && 5 === match[0])
            {var
              c=match[3],
              a=match[2],
              n=match[1],
              _k3_=
               function(a)
                {return caml_string_equal(caml_call1(Xml[25],a),cst_xmlns)},
              a$0=
               caml_call2(Stdlib_list[31],_k3_,a)
                ?a
                :[0,caml_call2(Xml[6],cst_xmlns$0,Typed_xml[1][5]),a],
              _k5_=caml_call3(Xml[21],[0,a$0],n,c);
             switch$0 = 1}
           if(! switch$0)var _k5_=doc;
           caml_call4(P[15],encode,indent,fmt,_k5_);
           return caml_call2(Stdlib_format[3],fmt,0)}
         return [0,pp_elt,pp]},
       _O_,
       _N_,
       _M_,
       Make_simple,
       Make_typed_simple];
    caml_register_global(1099,Xml_print,"Xml_print");
    var
     Xml_iter=
      [0,
       function(Xml)
        {function amap1(f,n)
          {var match=caml_call1(Xml[27],n);
           if(typeof match !== "number")
            switch(match[0])
             {case 4:
               var
                attribs=match[2],
                name=match[1],
                _k1_=[0,caml_call2(f,name,attribs)];
               return caml_call2(Xml[20],_k1_,name);
              case 5:
               var
                elts=match[3],
                attribs$0=match[2],
                name$0=match[1],
                _k2_=[0,caml_call2(f,name$0,attribs$0)];
               return caml_call3(Xml[21],_k2_,name$0,elts)
              }
           return n}
         function amap(f,n)
          {var match=caml_call1(Xml[27],n);
           if(typeof match !== "number")
            switch(match[0])
             {case 4:
               var
                attribs=match[2],
                name=match[1],
                _kW_=[0,caml_call2(f,name,attribs)];
               return caml_call2(Xml[20],_kW_,name);
              case 5:
               var
                elts=match[3],
                attribs$0=match[2],
                name$0=match[1],
                _kX_=function(_k0_){return amap(f,_k0_)},
                _kY_=caml_call2(Stdlib_list[17],_kX_,elts),
                _kZ_=[0,caml_call2(f,name$0,attribs$0)];
               return caml_call3(Xml[21],_kZ_,name$0,_kY_)
              }
           return n}
         function add_float_attrib(name,value,param)
          {if(param)
            {var head=param[1],tail=param[2];
             if(caml_string_equal(caml_call1(Xml[25],head),name))
              return [0,caml_call2(Xml[4],name,value),tail];
             var tail$0=param[2];
             return [0,head,add_float_attrib(name,value,tail$0)]}
           return [0,caml_call2(Xml[4],name,value),0]}
         function map_float_attrib(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(0 === match[0])
              {var value=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var _kU_=caml_call1(f,value),_kV_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[4],_kV_,_kU_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function add_int_attrib(name,value,param)
          {if(param)
            {var head=param[1],tail=param[2];
             if(caml_string_equal(caml_call1(Xml[25],head),name))
              return [0,caml_call2(Xml[5],name,value),tail];
             var tail$0=param[2];
             return [0,head,add_int_attrib(name,value,tail$0)]}
           return [0,caml_call2(Xml[5],name,value),0]}
         function rm_attrib(is_attrib,param)
          {var param$0=param;
           for(;;)
            {if(param$0)
              {var head=param$0[1],tail=param$0[2];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var param$0=tail;continue}
               var tail$0=param$0[2];
               return [0,head,rm_attrib(is_attrib,tail$0)]}
             return 0}}
         function map_int_attrib(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(1 === match[0])
              {var value=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var _kS_=caml_call1(f,value),_kT_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[5],_kT_,_kS_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function add_string_attrib(name,value,param)
          {if(param)
            {var head=param[1],tail=param[2];
             if(caml_string_equal(caml_call1(Xml[25],head),name))
              return [0,caml_call2(Xml[6],name,value),tail];
             var tail$0=param[2];
             return [0,head,add_string_attrib(name,value,tail$0)]}
           return [0,caml_call2(Xml[6],name,value),0]}
         function map_string_attrib(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(2 === match[0])
              {var value=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var _kQ_=caml_call1(f,value),_kR_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[6],_kR_,_kQ_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function add_space_sep_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1],match=caml_call1(Xml[26],head);
             if(3 === match[0] && ! match[1])
              {var values=match[2];
               if(caml_string_equal(caml_call1(Xml[25],head),name))
                return [0,caml_call2(Xml[7],name,[0,value,values]),tail]}
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[7],name,[0,value,0]),tail]
                     :[0,head,add_space_sep_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[7],name,[0,value,0]),0]}
         function add_comma_sep_attrib(name,value,param)
          {if(param)
            {var tail=param[2],head=param[1],match=caml_call1(Xml[26],head);
             if(3 === match[0] && match[1])
              {var values=match[2];
               if(caml_string_equal(caml_call1(Xml[25],head),name))
                return [0,caml_call2(Xml[8],name,[0,value,values]),tail]}
             return caml_string_equal(caml_call1(Xml[25],head),name)
                     ?[0,caml_call2(Xml[8],name,[0,value,0]),tail]
                     :[0,head,add_comma_sep_attrib(name,value,tail)]}
           return [0,caml_call2(Xml[8],name,[0,value,0]),0]}
         function rm_attrib_from_list(is_attrib,is_value,param)
          {if(param)
            {var tail=param[2],head=param[1],match=caml_call1(Xml[26],head);
             if(3 === match[0])
              {var values=match[2],sep=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {var
                  _kN_=function(v){return 1 - caml_call1(is_value,v)},
                  values$0=caml_call2(Stdlib_list[39],_kN_,values);
                 if(values$0)
                  {if(sep)
                    {var _kO_=caml_call1(Xml[25],head);
                     return [0,caml_call2(Xml[8],_kO_,values$0),tail]}
                   var _kP_=caml_call1(Xml[25],head);
                   return [0,caml_call2(Xml[7],_kP_,values$0),tail]}
                 return tail}}
             return [0,head,rm_attrib_from_list(is_attrib,is_value,tail)]}
           return 0}
         function map_string_attrib_in_list(is_attrib,f,l)
          {function aux(head)
            {var match=caml_call1(Xml[26],head);
             if(3 === match[0])
              {var values=match[2],sep=match[1];
               if(caml_call1(is_attrib,caml_call1(Xml[25],head)))
                {if(sep)
                  {var
                    _kJ_=caml_call2(Stdlib_list[17],f,values),
                    _kK_=caml_call1(Xml[25],head);
                   return caml_call2(Xml[8],_kK_,_kJ_)}
                 var
                  _kL_=caml_call2(Stdlib_list[17],f,values),
                  _kM_=caml_call1(Xml[25],head);
                 return caml_call2(Xml[7],_kM_,_kL_)}}
             return head}
           return caml_call2(Stdlib_list[17],aux,l)}
         function fold
          (of_empty,
           of_comment,
           of_txt,
           of_encodedpcdata,
           of_entity,
           of_leaf,
           of_node,
           n)
          {var match=caml_call1(Xml[27],n);
           if(typeof match === "number")
            return caml_call1(of_empty,0);
           else
            switch(match[0])
             {case 0:var s=match[1];return caml_call1(of_comment,s);
              case 1:var s$0=match[1];return caml_call1(of_encodedpcdata,s$0);
              case 2:var s$1=match[1];return caml_call1(of_txt,s$1);
              case 3:var s$2=match[1];return caml_call1(of_entity,s$2);
              case 4:
               var attribs=match[2],name=match[1];
               return caml_call2(of_leaf,name,attribs);
              default:
               var
                elts=match[3],
                attribs$0=match[2],
                name$0=match[1],
                _kH_=
                 function(_kI_)
                  {return fold
                           (of_empty,
                            of_comment,
                            of_txt,
                            of_encodedpcdata,
                            of_entity,
                            of_leaf,
                            of_node,
                            _kI_)};
               return caml_call3
                       (of_node,
                        name$0,
                        attribs$0,
                        caml_call2(Stdlib_list[17],_kH_,elts))}}
         function all_entities(elt)
          {function f(param){return 0}
           function _kG_(ename,attribs,elts)
            {return caml_call1(Stdlib_list[14],elts)}
           return fold(f,f,f,f,f,function(ename,attribs){return 0},_kG_,elt)}
         function flatmap(f,l)
          {var _kF_=caml_call2(Stdlib_list[17],f,l);
           return caml_call1(Stdlib_list[13],_kF_)}
         function translate
          (root_leaf,root_node,sub_leaf,sub_node,update_state,state,n)
          {function translate(state,n)
            {var match=caml_call1(Xml[27],n);
             if(typeof match !== "number")
              switch(match[0])
               {case 4:
                 var attribs=match[2],name=match[1];
                 return caml_call3(sub_leaf,state,name,attribs);
                case 5:
                 var
                  elts=match[3],
                  attribs$0=match[2],
                  name$0=match[1],
                  _kD_=caml_call3(update_state,name$0,attribs$0,state);
                 return caml_call4
                         (sub_node,
                          state,
                          name$0,
                          attribs$0,
                          flatmap(function(_kE_){return translate(_kD_,_kE_)},elts))
                }
             return [0,n,0]}
           var match=caml_call1(Xml[27],n);
           if(typeof match !== "number")
            switch(match[0])
             {case 4:
               var attribs=match[2],name=match[1];
               return caml_call2(root_leaf,name,attribs);
              case 5:
               var elts=match[3],attribs$0=match[2],name$0=match[1];
               return caml_call3
                       (root_node,
                        name$0,
                        attribs$0,
                        flatmap(function(_kC_){return translate(state,_kC_)},elts))
              }
           return n}
         return [0,
                 amap,
                 amap1,
                 rm_attrib,
                 rm_attrib_from_list,
                 map_int_attrib,
                 map_float_attrib,
                 map_string_attrib,
                 map_string_attrib_in_list,
                 add_int_attrib,
                 add_float_attrib,
                 add_string_attrib,
                 add_comma_sep_attrib,
                 add_space_sep_attrib,
                 fold,
                 all_entities,
                 translate]}];
    caml_register_global(1100,Xml_iter,"Xml_iter");
    function string_of_iri(x){return caml_call2(Stdlib_printf[4],_P_,x)}
    function to_string(f,param)
     {var unit=param[2],n=param[1];
      if(unit)
       var unit$0=unit[1],_kB_=caml_call1(f,unit$0);
      else
       var _kB_=cst$31;
      return caml_call3(Stdlib_printf[4],_Q_,n,_kB_)}
    function angle_names(param)
     {return 4099509 === param?cst_rad:793050094 <= param?cst_grad:cst_deg}
    function string_of_angle(a){return to_string(angle_names,a)}
    function length_names(param)
     {return 16389 <= param
              ?17280 === param
                ?cst_mm
                :17956 <= param
                  ?17960 <= param?cst_px:cst_pt
                  :17939 <= param?cst_pc:cst_in
              :15496 <= param
                ?15507 <= param?cst_ex:cst_em
                :15050 <= param?cst_cm:cst$32}
    function string_of_length(a){return to_string(length_names,a)}
    function list(opt,f,l)
     {if(opt)var sth=opt[1],sep=sth;else var sep=cst$33;
      var _kA_=caml_call2(Stdlib_list[17],f,l);
      return caml_call2(Stdlib_string[7],sep,_kA_)}
    function string_of_paint_whitout_icc(param)
     {if(typeof param === "number")
       return 870530776 <= param?cst_none:cst_currentColor;
      var match=param[2],icc=match[2],c=match[1];
      if(icc)
       {var x=icc[1],_kz_=caml_call2(Stdlib[28],sep,x);
        return caml_call2(Stdlib[28],c,_kz_)}
      return c}
    function string_of_paint(c)
     {if(typeof c !== "number" && 3652393 <= c[1])
       {var _kt_=c[2],_ku_=_kt_[2],_kv_=_kt_[1];
        if(_ku_)
         {var
           b=_ku_[1],
           _kw_=string_of_paint_whitout_icc(b),
           _kx_=caml_call2(Stdlib[28],cst$34,_kw_),
           _ky_=string_of_iri(_kv_);
          return caml_call2(Stdlib[28],_ky_,_kx_)}
        return string_of_iri(_kv_)}
      return string_of_paint_whitout_icc(c)}
    function Make_with_wrapped_functions(Xml,C)
     {var
       doctype=compose_doctype(cst_svg,_R_),
       Info=[0,content_type,0,0,version,standard,namespace,doctype],
       _fk_=Xml[2],
       _fl_=Xml[3];
      function tot(x){return x}
      function totl(x){return x}
      function toelt(x){return x}
      function toeltl(x){return x}
      function to_attrib(x){return x}
      function nullary(tag,a,param)
       {var _ks_=caml_call1(Xml[1][3],0);
        return caml_call3(Xml[21],a,tag,_ks_)}
      function unary(tag,a,elt)
       {var _kr_=caml_call1(Xml[1][4],elt);
        return caml_call3(Xml[21],a,tag,_kr_)}
      function star(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function to_xmlattribs(x){return x}
      var _fm_=Xml[4],_fn_=Xml[6],_fo_=C[10],_fp_=C[10],_fq_=C[11];
      function user_attrib(f,name,v)
       {var _kq_=caml_call2(Xml[1][2],f,v);
        return caml_call2(Xml[6],name,_kq_)}
      var _fr_=Xml[6];
      function metadata(a,children)
       {return caml_call3(Xml[21],a,cst_metadata,children)}
      function foreignObject(a,children)
       {return caml_call3(Xml[21],a,cst_foreignObject,children)}
      function pcdata(s){return caml_call1(Xml[17],s)}
      var
       a_version=caml_call1(_fn_,cst_version),
       a_baseProfile=caml_call1(_fn_,cst_baseProfile);
      function a_x(_kp_){return user_attrib(_fo_,cst_x,_kp_)}
      function a_y(_ko_){return user_attrib(_fo_,cst_y,_ko_)}
      function a_width(_kn_){return user_attrib(_fp_,cst_width,_kn_)}
      function a_height(_km_){return user_attrib(_fp_,cst_height,_km_)}
      var
       a_preserveAspectRatio=caml_call1(_fn_,cst_preserveAspectRatio),
       a_contentScriptType=caml_call1(_fn_,cst_contentScriptType),
       a_contentStyleType=caml_call1(_fn_,cst_contentStyleType);
      function a_zoomAndPan(x){return user_attrib(C[4],cst_zoomAndSpan,x)}
      var
       a_href=caml_call1(_fn_,cst_href),
       a_xlink_href=caml_call1(_fn_,cst_xlink_href),
       a_requiredFeatures=caml_call1(Xml[7],cst_requiredFeatures),
       a_requiredExtensions=caml_call1(Xml[7],cst_requiredExtension),
       a_systemLanguage=caml_call1(Xml[8],cst_systemLanguage),
       _fs_=C[3];
      function a_externalRessourcesRequired(_kl_)
       {return user_attrib(_fs_,cst_externalRessourcesRequired,_kl_)}
      var a_id=caml_call1(_fn_,cst_id);
      function a_user_data(name)
       {return caml_call1(_fn_,caml_call2(Stdlib[28],cst_data,name))}
      var
       a_xml_base=caml_call1(_fn_,cst_xml_base),
       a_xml_lang=caml_call1(_fn_,cst_xml_lang);
      function a_xml_space(x){return user_attrib(C[4],cst_xml_space,x)}
      var
       a_type=caml_call1(_fn_,cst_type),
       a_media=caml_call1(Xml[8],cst_media),
       a_xlink_title=caml_call1(_fn_,cst_xlink_title),
       a_class=caml_call1(Xml[7],cst_class),
       a_style=caml_call1(_fn_,cst_style),
       _ft_=C[21];
      function a_transform(_kk_){return user_attrib(_ft_,cst_transform,_kk_)}
      var _fu_=C[7];
      function a_viewBox(_kj_){return user_attrib(_fu_,cst_viewBox,_kj_)}
      var
       a_d=caml_call1(_fn_,cst_d),
       a_pathLength=caml_call1(_fm_,cst_pathLength);
      function a_rx(_ki_){return user_attrib(_fp_,cst_rx,_ki_)}
      function a_ry(_kh_){return user_attrib(_fp_,cst_ry,_kh_)}
      function a_cx(_kg_){return user_attrib(_fp_,cst_cx,_kg_)}
      function a_cy(_kf_){return user_attrib(_fp_,cst_cy,_kf_)}
      function a_r(_ke_){return user_attrib(_fp_,cst_r,_ke_)}
      function a_x1(_kd_){return user_attrib(_fo_,cst_x1,_kd_)}
      function a_y1(_kc_){return user_attrib(_fo_,cst_y1,_kc_)}
      function a_x2(_kb_){return user_attrib(_fo_,cst_x2,_kb_)}
      function a_y2(_ka_){return user_attrib(_fo_,cst_y2,_ka_)}
      var _fv_=C[5];
      function a_points(_j$_){return user_attrib(_fv_,cst_points,_j$_)}
      function a_x_list(_j__){return user_attrib(_fq_,cst_x$0,_j__)}
      function a_y_list(_j9_){return user_attrib(_fq_,cst_y$0,_j9_)}
      var _fw_=C[12];
      function a_dx(_j8_){return user_attrib(_fw_,cst_dx,_j8_)}
      var _fx_=C[12];
      function a_dy(_j7_){return user_attrib(_fx_,cst_dy,_j7_)}
      function a_dx_list(_j6_){return user_attrib(_fq_,cst_dx$0,_j6_)}
      function a_dy_list(_j5_){return user_attrib(_fq_,cst_dy$0,_j5_)}
      function a_lengthAdjust(x){return user_attrib(C[4],cst_lengthAdjust,x)}
      function a_textLength(_j4_)
       {return user_attrib(_fp_,cst_textLength,_j4_)}
      function a_text_anchor(x){return user_attrib(C[4],cst_text_anchor,x)}
      function a_text_decoration(x)
       {return user_attrib(C[4],cst_text_decoration,x)}
      function a_text_rendering(x)
       {return user_attrib(C[4],cst_text_rendering,x)}
      var _fy_=C[14];
      function a_rotate(_j3_){return user_attrib(_fy_,cst_rotate,_j3_)}
      function a_startOffset(_j2_)
       {return user_attrib(_fp_,cst_startOffset,_j2_)}
      function a_method(x){return user_attrib(C[4],cst_method,x)}
      function a_spacing(x){return user_attrib(C[4],cst_spacing,x)}
      var
       a_glyphRef=caml_call1(_fn_,cst_glyphRef),
       a_format=caml_call1(_fn_,cst_format);
      function a_markerUnits(x){return user_attrib(C[4],cst_markerUnits,x)}
      function a_refX(_j1_){return user_attrib(_fo_,cst_refX,_j1_)}
      function a_refY(_j0_){return user_attrib(_fo_,cst_refY,_j0_)}
      function a_markerWidth(_jZ_)
       {return user_attrib(_fp_,cst_markerWidth,_jZ_)}
      function a_markerHeight(_jY_)
       {return user_attrib(_fp_,cst_markerHeight,_jY_)}
      function a_orient(x){return user_attrib(C[17],cst_orient,x)}
      var a_local=caml_call1(_fn_,cst_local);
      function a_rendering_intent(x)
       {return user_attrib(C[4],cst_rendering_intent,x)}
      function a_gradientUnits(x)
       {return user_attrib(C[4],cst_gradientUnits,x)}
      var _fz_=C[21];
      function a_gradientTransform(_jX_)
       {return user_attrib(_fz_,cst_gradientTransform,_jX_)}
      function a_spreadMethod(x){return user_attrib(C[4],cst_spreadMethod,x)}
      function a_fx(_jW_){return user_attrib(_fo_,cst_fx,_jW_)}
      function a_fy(_jV_){return user_attrib(_fo_,cst_fy,_jV_)}
      function a_offset(x){return user_attrib(C[16],cst_offset,x)}
      function a_patternUnits(x){return user_attrib(C[4],cst_patternUnits,x)}
      function a_patternContentUnits(x)
       {return user_attrib(C[4],cst_patternContentUnits,x)}
      function a_patternTransform(x)
       {return user_attrib(C[21],cst_patternTransform,x)}
      function a_clipPathUnits(x)
       {return user_attrib(C[4],cst_clipPathUnits,x)}
      function a_maskUnits(x){return user_attrib(C[4],cst_maskUnits,x)}
      function a_maskContentUnits(x)
       {return user_attrib(C[4],cst_maskContentUnits,x)}
      function a_primitiveUnits(x)
       {return user_attrib(C[4],cst_primitiveUnits,x)}
      var _fA_=C[13];
      function a_filterRes(_jU_)
       {return user_attrib(_fA_,cst_filterResUnits,_jU_)}
      var a_result=caml_call1(_fn_,cst_result);
      function a_in(x){return user_attrib(C[8],cst_in$0,x)}
      function a_in2(x){return user_attrib(C[8],cst_in2,x)}
      var
       a_azimuth=caml_call1(_fm_,cst_azimuth),
       a_elevation=caml_call1(_fm_,cst_elevation),
       a_pointsAtX=caml_call1(_fm_,cst_pointsAtX),
       a_pointsAtY=caml_call1(_fm_,cst_pointsAtY),
       a_pointsAtZ=caml_call1(_fm_,cst_pointsAtZ),
       a_specularExponent=caml_call1(_fm_,cst_specularExponent),
       a_specularConstant=caml_call1(_fm_,cst_specularConstant),
       a_limitingConeAngle=caml_call1(_fm_,cst_limitingConeAngle);
      function a_mode(x){return user_attrib(C[4],cst_mode,x)}
      function a_feColorMatrix_type(x){return user_attrib(C[4],cst_type$0,x)}
      var _fB_=C[14];
      function a_values(_jT_){return user_attrib(_fB_,cst_values,_jT_)}
      function a_transfer_type(x){return user_attrib(C[4],cst_type$1,x)}
      var _fC_=C[14];
      function a_tableValues(_jS_)
       {return user_attrib(_fC_,cst_tableValues,_jS_)}
      var _fD_=C[12];
      function a_intercept(_jR_){return user_attrib(_fD_,cst_intercept,_jR_)}
      var _fE_=C[12];
      function a_amplitude(_jQ_){return user_attrib(_fE_,cst_amplitude,_jQ_)}
      var _fF_=C[12];
      function a_exponent(_jP_){return user_attrib(_fF_,cst_exponent,_jP_)}
      var _fG_=C[12];
      function a_transfer_offset(_jO_)
       {return user_attrib(_fG_,cst_offset$0,_jO_)}
      function a_feComposite_operator(x)
       {return user_attrib(C[4],cst_operator,x)}
      var _fH_=C[12];
      function a_k1(_jN_){return user_attrib(_fH_,cst_k1,_jN_)}
      var _fI_=C[12];
      function a_k2(_jM_){return user_attrib(_fI_,cst_k2,_jM_)}
      var _fJ_=C[12];
      function a_k3(_jL_){return user_attrib(_fJ_,cst_k3,_jL_)}
      var _fK_=C[12];
      function a_k4(_jK_){return user_attrib(_fK_,cst_k4,_jK_)}
      var _fL_=C[13];
      function a_order(_jJ_){return user_attrib(_fL_,cst_order,_jJ_)}
      var _fM_=C[14];
      function a_kernelMatrix(_jI_)
       {return user_attrib(_fM_,cst_kernelMatrix,_jI_)}
      var _fN_=C[12];
      function a_divisor(_jH_){return user_attrib(_fN_,cst_divisor,_jH_)}
      var _fO_=C[12];
      function a_bias(_jG_){return user_attrib(_fO_,cst_bias,_jG_)}
      var _fP_=C[13];
      function a_kernelUnitLength(_jF_)
       {return user_attrib(_fP_,cst_kernelUnitLength,_jF_)}
      var _fQ_=C[9];
      function a_targetX(_jE_){return user_attrib(_fQ_,cst_targetX,_jE_)}
      var _fR_=C[9];
      function a_targetY(_jD_){return user_attrib(_fR_,cst_targetY,_jD_)}
      function a_edgeMode(x){return user_attrib(C[4],cst_targetY$0,x)}
      var _fS_=C[3];
      function a_preserveAlpha(_jC_)
       {return user_attrib(_fS_,cst_preserveAlpha,_jC_)}
      var _fT_=C[12];
      function a_surfaceScale(_jB_)
       {return user_attrib(_fT_,cst_surfaceScale,_jB_)}
      var _fU_=C[12];
      function a_diffuseConstant(_jA_)
       {return user_attrib(_fU_,cst_diffuseConstant,_jA_)}
      var _fV_=C[12];
      function a_scale(_jz_){return user_attrib(_fV_,cst_scale,_jz_)}
      function a_xChannelSelector(x)
       {return user_attrib(C[4],cst_xChannelSelector,x)}
      function a_yChannelSelector(x)
       {return user_attrib(C[4],cst_yChannelSelector,x)}
      var _fW_=C[13];
      function a_stdDeviation(_jy_)
       {return user_attrib(_fW_,cst_stdDeviation,_jy_)}
      function a_feMorphology_operator(x)
       {return user_attrib(C[4],cst_operator$0,x)}
      var _fX_=C[13];
      function a_radius(_jx_){return user_attrib(_fX_,cst_radius,_jx_)}
      var _fY_=C[13];
      function a_baseFrenquency(_jw_)
       {return user_attrib(_fY_,cst_baseFrequency,_jw_)}
      var _fZ_=C[9];
      function a_numOctaves(_jv_)
       {return user_attrib(_fZ_,cst_numOctaves,_jv_)}
      var _f0_=C[12];
      function a_seed(_ju_){return user_attrib(_f0_,cst_seed,_ju_)}
      function a_stitchTiles(x){return user_attrib(C[4],cst_stitchTiles,x)}
      function a_feTurbulence_type(x){return user_attrib(C[4],cst_type$2,x)}
      function a_xlink_show(x){return user_attrib(C[4],cst_xlink_show,x)}
      function a_xlink_actuate(x)
       {return user_attrib(C[4],cst_xlink_actuate,x)}
      var
       a_target=caml_call1(_fn_,cst_xlink_target),
       a_viewTarget=caml_call1(_fn_,cst_viewTarget),
       a_attributeName=caml_call1(_fn_,cst_attributeName);
      function a_attributeType(x)
       {return user_attrib(C[4],cst_attributeType,x)}
      var
       a_begin=caml_call1(_fn_,cst_begin),
       a_dur=caml_call1(_fn_,cst_dur),
       a_min=caml_call1(_fn_,cst_min),
       a_max=caml_call1(_fn_,cst_max);
      function a_restart(x){return user_attrib(C[4],cst_restart,x)}
      var
       a_repeatCount=caml_call1(_fn_,cst_repeatCount),
       a_repeatDur=caml_call1(_fn_,cst_repeatDur),
       _f1_=C[18];
      function a_fill(_jt_){return user_attrib(_f1_,cst_fill,_jt_)}
      function a_animation_fill(x){return user_attrib(C[4],cst_fill$0,x)}
      function a_calcMode(x){return user_attrib(C[4],cst_calcMode,x)}
      var
       a_animation_values=caml_call1(Xml[8],cst_values$0),
       a_keyTimes=caml_call1(Xml[8],cst_keyTimes),
       a_keySplines=caml_call1(Xml[8],cst_keySplines),
       a_from=caml_call1(_fn_,cst_from),
       a_to=caml_call1(_fn_,cst_to),
       a_by=caml_call1(_fn_,cst_by);
      function a_additive(x){return user_attrib(C[4],cst_additive,x)}
      function a_accumulate(x){return user_attrib(C[4],cst_accumulate,x)}
      var _f2_=C[15];
      function a_keyPoints(_js_){return user_attrib(_f2_,cst_keyPoints,_js_)}
      var a_path=caml_call1(_fn_,cst_path),_f3_=C[4];
      function a_animateTransform_type(_jr_)
       {return user_attrib(_f3_,cst_type$3,_jr_)}
      var _f4_=C[12];
      function a_horiz_origin_x(_jq_)
       {return user_attrib(_f4_,cst_horiz_origin_x,_jq_)}
      var _f5_=C[12];
      function a_horiz_origin_y(_jp_)
       {return user_attrib(_f5_,cst_horiz_origin_y,_jp_)}
      var _f6_=C[12];
      function a_horiz_adv_x(_jo_)
       {return user_attrib(_f6_,cst_horiz_adv_x,_jo_)}
      var _f7_=C[12];
      function a_vert_origin_x(_jn_)
       {return user_attrib(_f7_,cst_vert_origin_x,_jn_)}
      var _f8_=C[12];
      function a_vert_origin_y(_jm_)
       {return user_attrib(_f8_,cst_vert_origin_y,_jm_)}
      var _f9_=C[12];
      function a_vert_adv_y(_jl_)
       {return user_attrib(_f9_,cst_vert_adv_y,_jl_)}
      var
       a_unicode=caml_call1(_fn_,cst_unicode),
       a_glyph_name=caml_call1(_fn_,cst_glyphname);
      function a_orientation(x){return user_attrib(C[4],cst_orientation,x)}
      function a_arabic_form(x){return user_attrib(C[4],cst_arabic_form,x)}
      var
       a_lang=caml_call1(_fn_,cst_lang),
       a_u1=caml_call1(_fn_,cst_u1),
       a_u2=caml_call1(_fn_,cst_u2),
       a_g1=caml_call1(_fn_,cst_g1),
       a_g2=caml_call1(_fn_,cst_g2),
       a_k=caml_call1(_fn_,cst_k),
       a_font_family=caml_call1(_fn_,cst_font_family),
       a_font_style=caml_call1(_fn_,cst_font_style),
       a_font_variant=caml_call1(_fn_,cst_font_variant),
       a_font_weight=caml_call1(_fn_,cst_font_weight),
       a_font_stretch=caml_call1(_fn_,cst_font_stretch),
       a_font_size=caml_call1(_fn_,cst_font_size),
       a_unicode_range=caml_call1(_fn_,cst_unicode_range),
       a_units_per_em=caml_call1(_fn_,cst_units_per_em),
       _f__=C[12];
      function a_stemv(_jk_){return user_attrib(_f__,cst_stemv,_jk_)}
      var _f$_=C[12];
      function a_stemh(_jj_){return user_attrib(_f$_,cst_stemh,_jj_)}
      var _ga_=C[12];
      function a_slope(_ji_){return user_attrib(_ga_,cst_slope,_ji_)}
      var _gb_=C[12];
      function a_cap_height(_jh_)
       {return user_attrib(_gb_,cst_cap_height,_jh_)}
      var _gc_=C[12];
      function a_x_height(_jg_){return user_attrib(_gc_,cst_x_height,_jg_)}
      var _gd_=C[12];
      function a_accent_height(_jf_)
       {return user_attrib(_gd_,cst_accent_height,_jf_)}
      var _ge_=C[12];
      function a_ascent(_je_){return user_attrib(_ge_,cst_ascent,_je_)}
      var
       a_widths=caml_call1(_fn_,cst_widths),
       a_bbox=caml_call1(_fn_,cst_bbox),
       _gf_=C[12];
      function a_ideographic(_jd_)
       {return user_attrib(_gf_,cst_ideographic,_jd_)}
      var _gg_=C[12];
      function a_alphabetic(_jc_)
       {return user_attrib(_gg_,cst_alphabetic,_jc_)}
      var _gh_=C[12];
      function a_mathematical(_jb_)
       {return user_attrib(_gh_,cst_mathematical,_jb_)}
      var _gi_=C[12];
      function a_hanging(_ja_){return user_attrib(_gi_,cst_hanging,_ja_)}
      var _gj_=C[12];
      function a_videographic(_i$_)
       {return user_attrib(_gj_,cst_v_ideographic,_i$_)}
      var _gk_=C[12];
      function a_v_alphabetic(_i__)
       {return user_attrib(_gk_,cst_v_alphabetic,_i__)}
      var _gl_=C[12];
      function a_v_mathematical(_i9_)
       {return user_attrib(_gl_,cst_v_mathematical,_i9_)}
      var _gm_=C[12];
      function a_v_hanging(_i8_){return user_attrib(_gm_,cst_v_hanging,_i8_)}
      var _gn_=C[12];
      function a_underline_position(_i7_)
       {return user_attrib(_gn_,cst_underline_position,_i7_)}
      var _go_=C[12];
      function a_underline_thickness(_i6_)
       {return user_attrib(_go_,cst_underline_thickness,_i6_)}
      var _gp_=C[12];
      function a_strikethrough_position(_i5_)
       {return user_attrib(_gp_,cst_strikethrough_position,_i5_)}
      var _gq_=C[12];
      function a_strikethrough_thickness(_i4_)
       {return user_attrib(_gq_,cst_strikethrough_thickness,_i4_)}
      var _gr_=C[12];
      function a_overline_position(_i3_)
       {return user_attrib(_gr_,cst_overline_position,_i3_)}
      var _gs_=C[12];
      function a_overline_thickness(_i2_)
       {return user_attrib(_gs_,cst_overline_thickness,_i2_)}
      var
       a_string=caml_call1(_fn_,cst_string),
       a_name=caml_call1(_fn_,cst_name);
      function a_alignment_baseline(x)
       {return user_attrib(C[2],cst_alignment_baseline,x)}
      function a_dominant_baseline(x)
       {return user_attrib(C[6],cst_dominant_baseline,x)}
      var
       a_onabort=caml_call1(Xml[9],cst_onabort),
       a_onactivate=caml_call1(Xml[9],cst_onactivate),
       a_onbegin=caml_call1(Xml[9],cst_onbegin),
       a_onend=caml_call1(Xml[9],cst_onend),
       a_onerror=caml_call1(Xml[9],cst_onerror),
       a_onfocusin=caml_call1(Xml[9],cst_onfocusin),
       a_onfocusout=caml_call1(Xml[9],cst_onfocusout),
       a_onload=caml_call1(Xml[9],cst_onload),
       a_onrepeat=caml_call1(Xml[9],cst_onrepeat),
       a_onresize=caml_call1(Xml[9],cst_onresize),
       a_onscroll=caml_call1(Xml[9],cst_onscroll),
       a_onunload=caml_call1(Xml[9],cst_onunload),
       a_onzoom=caml_call1(Xml[9],cst_onzoom),
       a_onclick=caml_call1(Xml[10],cst_onclick),
       a_onmousedown=caml_call1(Xml[10],cst_onmousedown),
       a_onmouseup=caml_call1(Xml[10],cst_onmouseup),
       a_onmouseover=caml_call1(Xml[10],cst_onmouseover),
       a_onmouseout=caml_call1(Xml[10],cst_onmouseout),
       a_onmousemove=caml_call1(Xml[10],cst_onmousemove),
       a_ontouchstart=caml_call1(Xml[12],cst_ontouchstart),
       a_ontouchend=caml_call1(Xml[12],cst_ontouchend),
       a_ontouchmove=caml_call1(Xml[12],cst_ontouchmove),
       a_ontouchcancel=caml_call1(Xml[12],cst_ontouchcancel),
       a_stop_color=caml_call1(_fr_,cst_stop_color),
       _gt_=C[12];
      function a_stop_opacity(_i1_)
       {return user_attrib(_gt_,cst_stop_opacity,_i1_)}
      var _gu_=C[18];
      function a_stroke(_i0_){return user_attrib(_gu_,cst_stroke,_i0_)}
      var _gv_=C[10];
      function a_stroke_width(_iZ_)
       {return user_attrib(_gv_,cst_stroke_width,_iZ_)}
      function a_stroke_linecap(x)
       {return user_attrib(C[4],cst_stroke_linecap,x)}
      function a_stroke_linejoin(x)
       {return user_attrib(C[4],cst_stroke_linejoin,x)}
      var _gw_=C[12];
      function a_stroke_miterlimit(_iY_)
       {return user_attrib(_gw_,cst_stroke_miterlimit,_iY_)}
      function a_stroke_dasharray(x)
       {return user_attrib(C[19],cst_stroke_dasharray,x)}
      var _gx_=C[10];
      function a_stroke_dashoffset(_iX_)
       {return user_attrib(_gx_,cst_stroke_dashoffset,_iX_)}
      var _gy_=C[12];
      function a_stroke_opacity(_iW_)
       {return user_attrib(_gy_,cst_stroke_opacity,_iW_)}
      function svg(opt,children)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var
         _iV_=
          [0,
           caml_call2
            (_fn_,
             cst_xmlns_xlink,
             caml_call1(Xml[1][1],cst_http_www_w3_org_1999_xlink)),
           a],
         attribs=
          [0,
           caml_call2
            (_fn_,
             cst_xmlns$3,
             caml_call1(Xml[1][1],cst_http_www_w3_org_2000_svg)),
           _iV_];
        return star(cst_svg$0,[0,attribs],children)}
      function g(_iT_,_iU_){return star(cst_g,_iT_,_iU_)}
      function defs(_iR_,_iS_){return star(cst_defs,_iR_,_iS_)}
      function desc(_iP_,_iQ_){return unary(cst_desc,_iP_,_iQ_)}
      function title(_iN_,_iO_){return unary(cst_title,_iN_,_iO_)}
      function symbol(_iL_,_iM_){return star(cst_symbol,_iL_,_iM_)}
      function use(_iJ_,_iK_){return star(cst_use,_iJ_,_iK_)}
      function image(_iH_,_iI_){return star(cst_image,_iH_,_iI_)}
      function switch$0(_iF_,_iG_){return star(cst_switch,_iF_,_iG_)}
      function style(_iD_,_iE_){return unary(cst_style$0,_iD_,_iE_)}
      function path(_iB_,_iC_){return star(cst_path$0,_iB_,_iC_)}
      function rect(_iz_,_iA_){return star(cst_rect,_iz_,_iA_)}
      function circle(_ix_,_iy_){return star(cst_circle,_ix_,_iy_)}
      function ellipse(_iv_,_iw_){return star(cst_ellipse,_iv_,_iw_)}
      function line(_it_,_iu_){return star(cst_line,_it_,_iu_)}
      function polyline(_ir_,_is_){return star(cst_polyline,_ir_,_is_)}
      function polygon(_ip_,_iq_){return star(cst_polygon,_ip_,_iq_)}
      function text(_in_,_io_){return star(cst_text,_in_,_io_)}
      function tspan(_il_,_im_){return star(cst_tspan,_il_,_im_)}
      function tref(_ij_,_ik_){return star(cst_tref,_ij_,_ik_)}
      function textPath(_ih_,_ii_){return star(cst_textPath,_ih_,_ii_)}
      function altGlyph(_if_,_ig_){return unary(cst_altGlyph,_if_,_ig_)}
      function altGlyphDef(_id_,_ie_){return unary(cst_altGlyphDef,_id_,_ie_)}
      function altGlyphItem(_ib_,_ic_)
       {return star(cst_altGlyphItem,_ib_,_ic_)}
      function glyphRef(_h$_,_ia_){return nullary(cst_glyphRef$0,_h$_,_ia_)}
      function marker(_h9_,_h__){return star(cst_marker,_h9_,_h__)}
      function color_profile(_h7_,_h8_)
       {return star(cst_color_profile,_h7_,_h8_)}
      function linearGradient(_h5_,_h6_)
       {return star(cst_linearGradient,_h5_,_h6_)}
      function radialGradient(_h3_,_h4_)
       {return star(cst_radialGradient,_h3_,_h4_)}
      function stop(_h1_,_h2_){return star(cst_stop,_h1_,_h2_)}
      function pattern(_hZ_,_h0_){return star(cst_pattern,_hZ_,_h0_)}
      function clipPath(_hX_,_hY_){return star(cst_clipPath,_hX_,_hY_)}
      function filter(_hV_,_hW_){return star(cst_filter,_hV_,_hW_)}
      function feDistantLight(_hT_,_hU_)
       {return star(cst_feDistantLight,_hT_,_hU_)}
      function fePointLight(_hR_,_hS_)
       {return star(cst_fePointLight,_hR_,_hS_)}
      function feSpotLight(_hP_,_hQ_){return star(cst_feSpotLight,_hP_,_hQ_)}
      function feBlend(_hN_,_hO_){return star(cst_feBlend,_hN_,_hO_)}
      function feColorMatrix(_hL_,_hM_)
       {return star(cst_feColorMatrix,_hL_,_hM_)}
      function feComponentTransfer(_hJ_,_hK_)
       {return star(cst_feComponentTransfer,_hJ_,_hK_)}
      function feFuncA(_hH_,_hI_){return star(cst_feFuncA,_hH_,_hI_)}
      function feFuncG(_hF_,_hG_){return star(cst_feFuncG,_hF_,_hG_)}
      function feFuncB(_hD_,_hE_){return star(cst_feFuncB,_hD_,_hE_)}
      function feFuncR(_hB_,_hC_){return star(cst_feFuncR,_hB_,_hC_)}
      function feComposite(_hz_,_hA_){return star(cst_feComposite,_hz_,_hA_)}
      function feConvolveMatrix(_hx_,_hy_)
       {return star(cst_feConvolveMatrix,_hx_,_hy_)}
      function feDiffuseLighting(_hv_,_hw_)
       {return star(cst_feDiffuseLighting,_hv_,_hw_)}
      function feDisplacementMap(_ht_,_hu_)
       {return star(cst_feDisplacementMap,_ht_,_hu_)}
      function feFlood(_hr_,_hs_){return star(cst_feFlood,_hr_,_hs_)}
      function feGaussianBlur(_hp_,_hq_)
       {return star(cst_feGaussianBlur,_hp_,_hq_)}
      function feImage(_hn_,_ho_){return star(cst_feImage,_hn_,_ho_)}
      function feMerge(_hl_,_hm_){return star(cst_feMerge,_hl_,_hm_)}
      function feMorphology(_hj_,_hk_)
       {return star(cst_feMorphology,_hj_,_hk_)}
      function feOffset(_hh_,_hi_){return star(cst_feOffset,_hh_,_hi_)}
      function feSpecularLighting(_hf_,_hg_)
       {return star(cst_feSpecularLighting,_hf_,_hg_)}
      function feTile(_hd_,_he_){return star(cst_feTile,_hd_,_he_)}
      function feTurbulence(_hb_,_hc_)
       {return star(cst_feTurbulence,_hb_,_hc_)}
      function cursor(_g$_,_ha_){return star(cst_cursor,_g$_,_ha_)}
      function a(_g9_,_g__){return star(cst_a,_g9_,_g__)}
      function view(_g7_,_g8_){return star(cst_view,_g7_,_g8_)}
      function script(_g5_,_g6_){return unary(cst_script,_g5_,_g6_)}
      function animation(_g3_,_g4_){return star(cst_animate,_g3_,_g4_)}
      function set(_g1_,_g2_){return star(cst_set,_g1_,_g2_)}
      function animateMotion(_gZ_,_g0_)
       {return star(cst_animateMotion,_gZ_,_g0_)}
      function mpath(_gX_,_gY_){return star(cst_mpath,_gX_,_gY_)}
      function animateColor(_gV_,_gW_)
       {return star(cst_animateColor,_gV_,_gW_)}
      function animateTransform(_gT_,_gU_)
       {return star(cst_animateTransform,_gT_,_gU_)}
      function font(_gR_,_gS_){return star(cst_font,_gR_,_gS_)}
      function glyph(_gP_,_gQ_){return star(cst_glyph,_gP_,_gQ_)}
      function missing_glyph(_gN_,_gO_)
       {return star(cst_missing_glyph,_gN_,_gO_)}
      function hkern(_gL_,_gM_){return nullary(cst_hkern,_gL_,_gM_)}
      function vkern(_gJ_,_gK_){return nullary(cst_vkern,_gJ_,_gK_)}
      function font_face(_gH_,_gI_){return nullary(cst_font_face,_gH_,_gI_)}
      function font_face_src(_gF_,_gG_)
       {return star(cst_font_face_src,_gF_,_gG_)}
      function font_face_uri(_gD_,_gE_)
       {return star(cst_font_face_uri,_gD_,_gE_)}
      function font_face_format(_gB_,_gC_)
       {return nullary(cst_font_face_uri$0,_gB_,_gC_)}
      function font_face_name(_gz_,_gA_)
       {return nullary(cst_font_face_name,_gz_,_gA_)}
      function doc_toelt(x){return x}
      var I=_a_(Xml);
      function of_seq(s){return caml_call1(I[1],s)}
      function data(s){return caml_call1(Xml[18],s)}
      function leaf(tag,a,param){return caml_call2(Xml[20],a,tag)}
      function node(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function coerce_elt(x){return x}
      var float_attrib=Xml[4],int_attrib=Xml[5],string_attrib=Xml[6];
      function uri_attrib(a,s){return caml_call2(Xml[13],a,s)}
      var
       space_sep_attrib=Xml[7],
       comma_sep_attrib=Xml[8],
       Unsafe=
        [0,
         data,
         leaf,
         node,
         coerce_elt,
         float_attrib,
         int_attrib,
         string_attrib,
         uri_attrib,
         space_sep_attrib,
         comma_sep_attrib];
      return [0,
              Xml,
              Info,
              _fk_,
              _fl_,
              tot,
              totl,
              toelt,
              toeltl,
              to_attrib,
              nullary,
              unary,
              star,
              to_xmlattribs,
              _fm_,
              _fn_,
              _fo_,
              _fp_,
              _fq_,
              user_attrib,
              _fm_,
              _fr_,
              metadata,
              foreignObject,
              pcdata,
              pcdata,
              a_version,
              a_baseProfile,
              a_x,
              a_y,
              a_width,
              a_height,
              a_preserveAspectRatio,
              a_contentScriptType,
              a_contentStyleType,
              a_zoomAndPan,
              a_href,
              a_xlink_href,
              a_requiredFeatures,
              a_requiredExtensions,
              a_systemLanguage,
              a_externalRessourcesRequired,
              a_id,
              a_user_data,
              a_xml_base,
              a_xml_lang,
              a_xml_space,
              a_type,
              a_media,
              a_xlink_title,
              a_class,
              a_style,
              a_transform,
              a_viewBox,
              a_d,
              a_pathLength,
              a_rx,
              a_ry,
              a_cx,
              a_cy,
              a_r,
              a_x1,
              a_y1,
              a_x2,
              a_y2,
              a_points,
              a_x_list,
              a_y_list,
              a_dx,
              a_dy,
              a_dx_list,
              a_dy_list,
              a_lengthAdjust,
              a_textLength,
              a_text_anchor,
              a_text_decoration,
              a_text_rendering,
              a_rotate,
              a_startOffset,
              a_method,
              a_spacing,
              a_glyphRef,
              a_format,
              a_markerUnits,
              a_refX,
              a_refY,
              a_markerWidth,
              a_markerHeight,
              a_orient,
              a_local,
              a_rendering_intent,
              a_gradientUnits,
              a_gradientTransform,
              a_spreadMethod,
              a_fx,
              a_fy,
              a_offset,
              a_patternUnits,
              a_patternContentUnits,
              a_patternTransform,
              a_clipPathUnits,
              a_maskUnits,
              a_maskContentUnits,
              a_primitiveUnits,
              a_filterRes,
              a_result,
              a_in,
              a_in2,
              a_azimuth,
              a_elevation,
              a_pointsAtX,
              a_pointsAtY,
              a_pointsAtZ,
              a_specularExponent,
              a_specularConstant,
              a_limitingConeAngle,
              a_mode,
              a_feColorMatrix_type,
              a_values,
              a_transfer_type,
              a_tableValues,
              a_intercept,
              a_amplitude,
              a_exponent,
              a_transfer_offset,
              a_feComposite_operator,
              a_k1,
              a_k2,
              a_k3,
              a_k4,
              a_order,
              a_kernelMatrix,
              a_divisor,
              a_bias,
              a_kernelUnitLength,
              a_targetX,
              a_targetY,
              a_edgeMode,
              a_preserveAlpha,
              a_surfaceScale,
              a_diffuseConstant,
              a_scale,
              a_xChannelSelector,
              a_yChannelSelector,
              a_stdDeviation,
              a_feMorphology_operator,
              a_radius,
              a_baseFrenquency,
              a_numOctaves,
              a_seed,
              a_stitchTiles,
              a_feTurbulence_type,
              a_xlink_show,
              a_xlink_actuate,
              a_target,
              a_viewTarget,
              a_attributeName,
              a_attributeType,
              a_begin,
              a_dur,
              a_min,
              a_max,
              a_restart,
              a_repeatCount,
              a_repeatDur,
              a_fill,
              a_animation_fill,
              a_calcMode,
              a_animation_values,
              a_keyTimes,
              a_keySplines,
              a_from,
              a_to,
              a_by,
              a_additive,
              a_accumulate,
              a_keyPoints,
              a_path,
              a_animateTransform_type,
              a_horiz_origin_x,
              a_horiz_origin_y,
              a_horiz_adv_x,
              a_vert_origin_x,
              a_vert_origin_y,
              a_vert_adv_y,
              a_unicode,
              a_glyph_name,
              a_orientation,
              a_arabic_form,
              a_lang,
              a_u1,
              a_u2,
              a_g1,
              a_g2,
              a_k,
              a_font_family,
              a_font_style,
              a_font_variant,
              a_font_weight,
              a_font_stretch,
              a_font_size,
              a_unicode_range,
              a_units_per_em,
              a_stemv,
              a_stemh,
              a_slope,
              a_cap_height,
              a_x_height,
              a_accent_height,
              a_ascent,
              a_widths,
              a_bbox,
              a_ideographic,
              a_alphabetic,
              a_mathematical,
              a_hanging,
              a_videographic,
              a_v_alphabetic,
              a_v_mathematical,
              a_v_hanging,
              a_underline_position,
              a_underline_thickness,
              a_strikethrough_position,
              a_strikethrough_thickness,
              a_overline_position,
              a_overline_thickness,
              a_string,
              a_name,
              a_alignment_baseline,
              a_dominant_baseline,
              a_onabort,
              a_onactivate,
              a_onbegin,
              a_onend,
              a_onerror,
              a_onfocusin,
              a_onfocusout,
              a_onload,
              a_onrepeat,
              a_onresize,
              a_onscroll,
              a_onunload,
              a_onzoom,
              a_onclick,
              a_onmousedown,
              a_onmouseup,
              a_onmouseover,
              a_onmouseout,
              a_onmousemove,
              a_ontouchstart,
              a_ontouchend,
              a_ontouchmove,
              a_ontouchcancel,
              a_stop_color,
              a_stop_opacity,
              a_stroke,
              a_stroke_width,
              a_stroke_linecap,
              a_stroke_linejoin,
              a_stroke_miterlimit,
              a_stroke_dasharray,
              a_stroke_dashoffset,
              a_stroke_opacity,
              svg,
              g,
              defs,
              desc,
              title,
              symbol,
              use,
              image,
              switch$0,
              style,
              path,
              rect,
              circle,
              ellipse,
              line,
              polyline,
              polygon,
              text,
              tspan,
              tref,
              textPath,
              altGlyph,
              altGlyphDef,
              altGlyphItem,
              glyphRef,
              marker,
              color_profile,
              linearGradient,
              radialGradient,
              stop,
              pattern,
              clipPath,
              filter,
              feDistantLight,
              fePointLight,
              feSpotLight,
              feBlend,
              feColorMatrix,
              feComponentTransfer,
              feFuncA,
              feFuncG,
              feFuncB,
              feFuncR,
              feComposite,
              feConvolveMatrix,
              feDiffuseLighting,
              feDisplacementMap,
              feFlood,
              feGaussianBlur,
              feImage,
              feMerge,
              feMorphology,
              feOffset,
              feSpecularLighting,
              feTile,
              feTurbulence,
              cursor,
              a,
              view,
              script,
              animation,
              set,
              animateMotion,
              mpath,
              animateColor,
              animateTransform,
              font,
              glyph,
              missing_glyph,
              hkern,
              vkern,
              font_face,
              font_face_src,
              font_face_uri,
              font_face_format,
              font_face_name,
              doc_toelt,
              I,
              of_seq,
              Unsafe]}
    function Wrapped_functions(Xml)
     {function string_of_alignment_baseline(param)
       {return -72987685 <= param
                ?354434192 <= param
                  ?881373037 <= param
                    ?1018879136 <= param?cst_after_edge:cst_alphabetic$0
                    :726666127 <= param?cst_auto:cst_hanging$0
                  :15943541 === param
                    ?cst_middle
                    :218255880 <= param?cst_mathematical$0:cst_inherit
                :-840627829 <= param
                  ?-415175851 <= param
                    ?-354838363 <= param?cst_baseline:cst_central
                    :-693588957 <= param?cst_ideographic$0:cst_text_before_edge
                  :-863864035 <= param?cst_before_edge:cst_text_after_edge}
      function string_of_big_variant(param)
       {return 3350435 <= param
                ?476616093 <= param
                  ?744337004 <= param
                    ?914009117 <= param
                      ?970483178 <= param
                        ?1040349136 <= param
                          ?1071251601 <= param?cst_stitch:cst_onRequest
                          :990972795 <= param?cst_repeat:cst_wrap
                        :958206052 <= param?cst_remove:cst_reflect
                      :870530776 <= param
                        ?884917925 <= param
                          ?889668530 <= param?cst_noStitch:cst$35
                          :881966452 <= param?cst_over:cst_none$0
                        :861714216 <= param?cst_medial:cst_never
                    :568588039 <= param
                      ?716799946 <= param
                        ?726666127 <= param
                          ?737755699 <= param?cst_butt:cst_auto$0
                          :726615284 <= param?cst_atop:cst_arithmetic
                        :698610924 <= param?cst_underline:cst_gamma
                      :512807795 <= param
                        ?518168424 <= param
                          ?557106693 <= param?cst_linear:cst_overline
                          :517347077 <= param?cst_onLoad:cst_turbulence
                        :504440814 <= param?cst_table:cst_geometricPrecision
                  :163178525 <= param
                    ?316735838 <= param
                      ?389604418 <= param
                        ?463106021 <= param
                          ?466749770 <= param?cst_optimizeSpeed:cst_miter
                          :418396260 <= param?cst_initial:cst_start
                        :384893183 <= param?cst_whenNotActive:cst_identity
                      :201080426 <= param
                        ?289998318 <= param
                          ?289998319 <= param?cst_skewY:cst_skewX
                          :226915517 <= param?cst_square:cst_scale$0
                        :172069535 <= param?cst_exact:cst_perceptual
                    :4393399 <= param
                      ?9660462 <= param
                        ?106228547 <= param
                          ?118574553 <= param?cst_discrete:cst_erode
                          :15943541 <= param?cst_middle$0:cst_round
                        :4401019 <= param?cst_xor:cst_XML
                      :3901504 <= param
                        ?4000051 <= param
                          ?4153707 <= param?cst_sum:cst_pad
                          :3954798 <= param?cst_out:cst_new
                        :3455931 <= param?cst_end:cst_CSS
                :-453122489 <= param
                  ?-72987685 <= param
                    ?66 <= param
                      ?72 <= param
                        ?86 <= param
                          ?16389 <= param?cst_in$1:cst_v
                          :82 <= param?cst_r$0:cst_h
                        :71 <= param?cst_g$0:cst_b
                      :-68046964 <= param
                        ?-4932997 <= param
                          ?65 <= param?cst_a$0:cst_rotate$0
                          :-22441528 <= param?cst_disable:cst_screen
                        :-72678338 <= param?cst_absolute_colorimetric:cst_inherit$0
                    :-262362527 <= param
                      ?-197222844 <= param
                        ?-115006565 <= param
                          ?-76840209 <= param?cst_always:cst_spacingAndGlyphs
                          :-126259180 <= param?cst_replace:cst_multiply
                        :-197983439 <= param?cst_spline:cst_matrix
                      :-384499551 <= param
                        ?-318472885 <= param
                          ?-313337870 <= param?cst_saturation:cst_dilate
                          :-346900690 <= param?cst_translate:cst_default
                        :-415993185 <= param?cst_lighten:cst_normal
                  :-839430911 <= param
                    ?-672592881 <= param
                      ?-552838301 <= param
                        ?-505547199 <= param
                          ?-474415497 <= param?cst_freeze:cst_magnify
                          :-543144685 <= param?cst_hueRotate:cst_spacing$0
                        :-621842423 <= param?cst_fractalNoise:cst_saturate
                      :-797470191 <= param
                        ?-699926424 <= param
                          ?-689066995 <= param
                            ?cst_userSpaceOnUse
                            :cst_objectBoundingBox
                          :-707876225 <= param?cst_darken:cst_paced
                        :-824137927 <= param?cst_isolated:cst_optimizeLegibility
                    :-951087346 <= param
                      ?-912466532 <= param
                        ?-851306022 <= param
                          ?-851300629 <= param?cst_luminanceToAlpha:cst_line_through
                          :-912009552 <= param?cst_other:cst_terminal
                        :-937074372 <= param?cst_blink:cst_stroke_width$0
                      :-1044642615 === param
                        ?cst_relative_colorimetric
                        :-1014056864 <= param
                          ?-1012636187 <= param?cst_stretch:cst_bevel
                          :-1024851605 <= param?cst_duplicate:cst_preserve}
      var _eX_=Stdlib[30];
      function _eY_(param)
       {var b=param[2],a=param[1];return caml_call3(Stdlib_printf[4],_S_,a,b)}
      var _eZ_=0;
      function string_of_coords(_fj_){return list(_eZ_,_eY_,_fj_)}
      function string_of_dominant_baseline(param)
       {return -72987685 <= param
                ?354434192 <= param
                  ?881373037 <= param
                    ?945233102 <= param?cst_nochange:cst_alphabetic$1
                    :726666127 <= param?cst_auto$1:cst_hanging$1
                  :15943541 === param
                    ?cst_middle$1
                    :218255880 <= param?cst_mathematical$1:cst_inherit$1
                :-840627829 <= param
                  ?-504734109 <= param
                    ?-415175851 <= param?cst_central$0:cst_usescript
                    :-693588957 <= param?cst_ideographic$1:cst_textbeforeedge
                  :-880506735 <= param?cst_resetsize:cst_textafteredge}
      function string_of_in_value(param)
       {if(typeof param === "number")
         return 198492909 <= param
                 ?885982307 <= param
                   ?976982182 <= param?cst_strokePaint:cst_sourceAlpha
                   :768130555 <= param?cst_fillPaint:cst_sourceGraphic
                 :-522189715 <= param?cst_backgroundImage:cst_backgroundAlpha;
        var svg=param[2];
        return svg}
      var _e0_=Stdlib[33],_e1_=0;
      function string_of_lengths(_fi_)
       {return list(_e1_,string_of_length,_fi_)}
      function string_of_percentage(x)
       {var _fh_=string_of_number(x);
        return caml_call2(Stdlib[28],_fh_,cst$36)}
      function string_of_fourfloats(param)
       {var
         d=param[4],
         c=param[3],
         b=param[2],
         a=param[1],
         _fd_=string_of_number(d),
         _fe_=string_of_number(c),
         _ff_=string_of_number(b),
         _fg_=string_of_number(a);
        return caml_call5(Stdlib_printf[4],_T_,_fg_,_ff_,_fe_,_fd_)}
      function string_of_number_optional_numb(param)
       {var _fb_=param[2],_fc_=param[1];
        if(_fb_){var y=_fb_[1];return caml_call3(Stdlib_printf[4],_U_,_fc_,y)}
        return caml_call2(Stdlib_printf[4],_V_,_fc_)}
      var _e2_=0;
      function string_of_numbers(_fa_)
       {return list(_e2_,string_of_number,_fa_)}
      function string_of_numbers_semicolon(_e$_)
       {return list(_W_,string_of_number,_e$_)}
      function string_of_offset(param)
       {if(-488794310 <= param[1])
         {var x=param[2];return string_of_percentage(x)}
        var x$0=param[2];
        return string_of_number(x$0)}
      function string_of_orient(param)
       {if(param){var svg=param[1];return string_of_angle(svg)}
        return cst_auto$2}
      function string_of_strokedasharray(l)
       {return l?list(0,string_of_length,l):cst_none$1}
      function string_of_transform(param)
       {var _e4_=param[1];
        if(-4932997 <= _e4_)
         {if(289998318 <= _e4_)
           {if(289998319 <= _e4_)
             {var angle=param[2],_e5_=string_of_angle(angle);
              return caml_call2(Stdlib_printf[4],_X_,_e5_)}
            var angle$0=param[2],_e6_=string_of_angle(angle$0);
            return caml_call2(Stdlib_printf[4],_Y_,_e6_)}
          if(201080426 <= _e4_)
           {var x=param[2],_e7_=string_of_number_optional_numb(x);
            return caml_call2(Stdlib_printf[4],_Z_,_e7_)}
          var match=param[2],x$0=match[2],angle$1=match[1];
          if(x$0)
           var
            match$0=x$0[1],
            y=match$0[2],
            x$1=match$0[1],
            _e8_=caml_call3(Stdlib_printf[4],___,x$1,y);
          else
           var _e8_=cst$37;
          var _e9_=string_of_angle(angle$1);
          return caml_call3(Stdlib_printf[4],_$_,_e9_,_e8_)}
        if(-262362527 <= _e4_)
         {var
           match$1=param[2],
           f=match$1[6],
           e=match$1[5],
           d=match$1[4],
           c=match$1[3],
           b=match$1[2],
           a=match$1[1];
          return caml_call7(Stdlib_printf[4],_aa_,a,b,c,d,e,f)}
        var x$2=param[2],_e__=string_of_number_optional_numb(x$2);
        return caml_call2(Stdlib_printf[4],_ab_,_e__)}
      function string_of_transforms(l)
       {var _e3_=caml_call2(Stdlib_list[17],string_of_transform,l);
        return caml_call2(Stdlib_string[7],cst$38,_e3_)}
      return [0,
              Xml,
              string_of_alignment_baseline,
              string_of_big_variant,
              _eX_,
              string_of_coords,
              string_of_dominant_baseline,
              string_of_in_value,
              _e0_,
              string_of_length,
              string_of_lengths,
              string_of_number,
              string_of_percentage,
              string_of_fourfloats,
              string_of_number_optional_numb,
              string_of_numbers,
              string_of_numbers_semicolon,
              string_of_offset,
              string_of_orient,
              string_of_paint,
              string_of_strokedasharray,
              string_of_transform,
              string_of_transforms]}
    function _ac_(_eT_,_eS_)
     {var
       _eU_=Make_with_wrapped_functions(_eT_,_eS_),
       _eV_=_eU_[342],
       _eW_=_eU_[2];
      return [0,
              _eU_[1],
              [0,_eW_[1],_eW_[2],_eW_[4],_eW_[5],_eW_[6],_eW_[7],_eW_[3]],
              _eU_[3],
              _eU_[4],
              _eU_[26],
              _eU_[27],
              _eU_[28],
              _eU_[29],
              _eU_[30],
              _eU_[31],
              _eU_[32],
              _eU_[33],
              _eU_[34],
              _eU_[35],
              _eU_[36],
              _eU_[37],
              _eU_[38],
              _eU_[39],
              _eU_[40],
              _eU_[41],
              _eU_[42],
              _eU_[43],
              _eU_[44],
              _eU_[45],
              _eU_[46],
              _eU_[47],
              _eU_[48],
              _eU_[49],
              _eU_[50],
              _eU_[51],
              _eU_[52],
              _eU_[53],
              _eU_[54],
              _eU_[55],
              _eU_[56],
              _eU_[57],
              _eU_[58],
              _eU_[59],
              _eU_[60],
              _eU_[61],
              _eU_[62],
              _eU_[63],
              _eU_[64],
              _eU_[65],
              _eU_[66],
              _eU_[67],
              _eU_[68],
              _eU_[69],
              _eU_[70],
              _eU_[71],
              _eU_[72],
              _eU_[73],
              _eU_[74],
              _eU_[75],
              _eU_[76],
              _eU_[77],
              _eU_[78],
              _eU_[79],
              _eU_[80],
              _eU_[81],
              _eU_[82],
              _eU_[83],
              _eU_[84],
              _eU_[85],
              _eU_[86],
              _eU_[87],
              _eU_[88],
              _eU_[89],
              _eU_[90],
              _eU_[91],
              _eU_[92],
              _eU_[93],
              _eU_[94],
              _eU_[95],
              _eU_[96],
              _eU_[97],
              _eU_[98],
              _eU_[99],
              _eU_[100],
              _eU_[101],
              _eU_[102],
              _eU_[103],
              _eU_[104],
              _eU_[105],
              _eU_[106],
              _eU_[107],
              _eU_[108],
              _eU_[109],
              _eU_[110],
              _eU_[111],
              _eU_[112],
              _eU_[113],
              _eU_[114],
              _eU_[115],
              _eU_[116],
              _eU_[117],
              _eU_[118],
              _eU_[119],
              _eU_[120],
              _eU_[121],
              _eU_[122],
              _eU_[123],
              _eU_[124],
              _eU_[125],
              _eU_[126],
              _eU_[127],
              _eU_[128],
              _eU_[129],
              _eU_[130],
              _eU_[131],
              _eU_[132],
              _eU_[133],
              _eU_[134],
              _eU_[135],
              _eU_[136],
              _eU_[137],
              _eU_[138],
              _eU_[139],
              _eU_[140],
              _eU_[141],
              _eU_[142],
              _eU_[143],
              _eU_[144],
              _eU_[145],
              _eU_[146],
              _eU_[147],
              _eU_[148],
              _eU_[149],
              _eU_[150],
              _eU_[151],
              _eU_[152],
              _eU_[153],
              _eU_[154],
              _eU_[155],
              _eU_[156],
              _eU_[157],
              _eU_[158],
              _eU_[159],
              _eU_[160],
              _eU_[161],
              _eU_[162],
              _eU_[163],
              _eU_[164],
              _eU_[165],
              _eU_[166],
              _eU_[167],
              _eU_[168],
              _eU_[169],
              _eU_[170],
              _eU_[171],
              _eU_[172],
              _eU_[173],
              _eU_[174],
              _eU_[175],
              _eU_[176],
              _eU_[177],
              _eU_[178],
              _eU_[179],
              _eU_[180],
              _eU_[181],
              _eU_[182],
              _eU_[183],
              _eU_[184],
              _eU_[185],
              _eU_[186],
              _eU_[187],
              _eU_[188],
              _eU_[189],
              _eU_[190],
              _eU_[191],
              _eU_[192],
              _eU_[193],
              _eU_[194],
              _eU_[195],
              _eU_[196],
              _eU_[197],
              _eU_[198],
              _eU_[199],
              _eU_[200],
              _eU_[201],
              _eU_[202],
              _eU_[203],
              _eU_[204],
              _eU_[205],
              _eU_[206],
              _eU_[207],
              _eU_[208],
              _eU_[209],
              _eU_[210],
              _eU_[211],
              _eU_[212],
              _eU_[213],
              _eU_[214],
              _eU_[215],
              _eU_[216],
              _eU_[217],
              _eU_[218],
              _eU_[219],
              _eU_[220],
              _eU_[221],
              _eU_[222],
              _eU_[223],
              _eU_[224],
              _eU_[225],
              _eU_[226],
              _eU_[227],
              _eU_[228],
              _eU_[229],
              _eU_[253],
              _eU_[254],
              _eU_[255],
              _eU_[256],
              _eU_[257],
              _eU_[258],
              _eU_[259],
              _eU_[260],
              _eU_[261],
              _eU_[262],
              _eU_[230],
              _eU_[231],
              _eU_[232],
              _eU_[233],
              _eU_[234],
              _eU_[235],
              _eU_[236],
              _eU_[237],
              _eU_[238],
              _eU_[239],
              _eU_[240],
              _eU_[241],
              _eU_[242],
              _eU_[243],
              _eU_[244],
              _eU_[245],
              _eU_[246],
              _eU_[247],
              _eU_[248],
              _eU_[249],
              _eU_[250],
              _eU_[251],
              _eU_[252],
              _eU_[24],
              _eU_[263],
              _eU_[264],
              _eU_[265],
              _eU_[266],
              _eU_[267],
              _eU_[268],
              _eU_[269],
              _eU_[270],
              _eU_[271],
              _eU_[272],
              _eU_[273],
              _eU_[274],
              _eU_[275],
              _eU_[276],
              _eU_[277],
              _eU_[278],
              _eU_[279],
              _eU_[280],
              _eU_[281],
              _eU_[282],
              _eU_[283],
              _eU_[284],
              _eU_[285],
              _eU_[286],
              _eU_[287],
              _eU_[288],
              _eU_[289],
              _eU_[290],
              _eU_[291],
              _eU_[292],
              _eU_[293],
              _eU_[294],
              _eU_[295],
              _eU_[296],
              _eU_[297],
              _eU_[298],
              _eU_[299],
              _eU_[300],
              _eU_[301],
              _eU_[302],
              _eU_[303],
              _eU_[304],
              _eU_[305],
              _eU_[306],
              _eU_[307],
              _eU_[308],
              _eU_[309],
              _eU_[310],
              _eU_[311],
              _eU_[312],
              _eU_[313],
              _eU_[314],
              _eU_[315],
              _eU_[316],
              _eU_[317],
              _eU_[318],
              _eU_[319],
              _eU_[320],
              _eU_[321],
              _eU_[322],
              _eU_[323],
              _eU_[324],
              _eU_[325],
              _eU_[326],
              _eU_[327],
              _eU_[328],
              _eU_[329],
              _eU_[330],
              _eU_[331],
              _eU_[332],
              _eU_[333],
              _eU_[334],
              _eU_[335],
              _eU_[336],
              _eU_[337],
              _eU_[338],
              _eU_[22],
              _eU_[23],
              _eU_[25],
              _eU_[341],
              _eU_[5],
              _eU_[6],
              _eU_[7],
              _eU_[8],
              _eU_[339],
              _eU_[13],
              _eU_[9],
              [0,
               _eV_[1],
               _eV_[3],
               _eV_[2],
               _eV_[4],
               _eV_[7],
               _eV_[5],
               _eV_[6],
               _eV_[8],
               _eV_[9],
               _eV_[10]]]}
    function _ad_(_eQ_)
     {var _eR_=Wrapped_functions(_eQ_);
      return [0,
              _eR_[1],
              _eR_[2],
              _eR_[4],
              _eR_[3],
              _eR_[5],
              _eR_[6],
              _eR_[13],
              _eR_[7],
              _eR_[8],
              _eR_[9],
              _eR_[10],
              _eR_[11],
              _eR_[14],
              _eR_[15],
              _eR_[16],
              _eR_[17],
              _eR_[18],
              _eR_[19],
              _eR_[20],
              _eR_[21],
              _eR_[22]]}
    var
     Svg_f=
      [0,
       function(_eM_)
        {var
          _eL_=Wrapped_functions(_eM_),
          _eP_=
           Make_with_wrapped_functions
            (_eM_,
             [0,
              _eL_[1],
              _eL_[2],
              _eL_[4],
              _eL_[3],
              _eL_[5],
              _eL_[6],
              _eL_[13],
              _eL_[7],
              _eL_[8],
              _eL_[9],
              _eL_[10],
              _eL_[11],
              _eL_[14],
              _eL_[15],
              _eL_[16],
              _eL_[17],
              _eL_[18],
              _eL_[19],
              _eL_[20],
              _eL_[21],
              _eL_[22]]),
          _eN_=_eP_[342],
          _eO_=_eP_[2];
         return [0,
                 _eP_[1],
                 [0,_eO_[1],_eO_[2],_eO_[4],_eO_[5],_eO_[6],_eO_[7],_eO_[3]],
                 _eP_[3],
                 _eP_[4],
                 _eP_[26],
                 _eP_[27],
                 _eP_[28],
                 _eP_[29],
                 _eP_[30],
                 _eP_[31],
                 _eP_[32],
                 _eP_[33],
                 _eP_[34],
                 _eP_[35],
                 _eP_[36],
                 _eP_[37],
                 _eP_[38],
                 _eP_[39],
                 _eP_[40],
                 _eP_[41],
                 _eP_[42],
                 _eP_[43],
                 _eP_[44],
                 _eP_[45],
                 _eP_[46],
                 _eP_[47],
                 _eP_[48],
                 _eP_[49],
                 _eP_[50],
                 _eP_[51],
                 _eP_[52],
                 _eP_[53],
                 _eP_[54],
                 _eP_[55],
                 _eP_[56],
                 _eP_[57],
                 _eP_[58],
                 _eP_[59],
                 _eP_[60],
                 _eP_[61],
                 _eP_[62],
                 _eP_[63],
                 _eP_[64],
                 _eP_[65],
                 _eP_[66],
                 _eP_[67],
                 _eP_[68],
                 _eP_[69],
                 _eP_[70],
                 _eP_[71],
                 _eP_[72],
                 _eP_[73],
                 _eP_[74],
                 _eP_[75],
                 _eP_[76],
                 _eP_[77],
                 _eP_[78],
                 _eP_[79],
                 _eP_[80],
                 _eP_[81],
                 _eP_[82],
                 _eP_[83],
                 _eP_[84],
                 _eP_[85],
                 _eP_[86],
                 _eP_[87],
                 _eP_[88],
                 _eP_[89],
                 _eP_[90],
                 _eP_[91],
                 _eP_[92],
                 _eP_[93],
                 _eP_[94],
                 _eP_[95],
                 _eP_[96],
                 _eP_[97],
                 _eP_[98],
                 _eP_[99],
                 _eP_[100],
                 _eP_[101],
                 _eP_[102],
                 _eP_[103],
                 _eP_[104],
                 _eP_[105],
                 _eP_[106],
                 _eP_[107],
                 _eP_[108],
                 _eP_[109],
                 _eP_[110],
                 _eP_[111],
                 _eP_[112],
                 _eP_[113],
                 _eP_[114],
                 _eP_[115],
                 _eP_[116],
                 _eP_[117],
                 _eP_[118],
                 _eP_[119],
                 _eP_[120],
                 _eP_[121],
                 _eP_[122],
                 _eP_[123],
                 _eP_[124],
                 _eP_[125],
                 _eP_[126],
                 _eP_[127],
                 _eP_[128],
                 _eP_[129],
                 _eP_[130],
                 _eP_[131],
                 _eP_[132],
                 _eP_[133],
                 _eP_[134],
                 _eP_[135],
                 _eP_[136],
                 _eP_[137],
                 _eP_[138],
                 _eP_[139],
                 _eP_[140],
                 _eP_[141],
                 _eP_[142],
                 _eP_[143],
                 _eP_[144],
                 _eP_[145],
                 _eP_[146],
                 _eP_[147],
                 _eP_[148],
                 _eP_[149],
                 _eP_[150],
                 _eP_[151],
                 _eP_[152],
                 _eP_[153],
                 _eP_[154],
                 _eP_[155],
                 _eP_[156],
                 _eP_[157],
                 _eP_[158],
                 _eP_[159],
                 _eP_[160],
                 _eP_[161],
                 _eP_[162],
                 _eP_[163],
                 _eP_[164],
                 _eP_[165],
                 _eP_[166],
                 _eP_[167],
                 _eP_[168],
                 _eP_[169],
                 _eP_[170],
                 _eP_[171],
                 _eP_[172],
                 _eP_[173],
                 _eP_[174],
                 _eP_[175],
                 _eP_[176],
                 _eP_[177],
                 _eP_[178],
                 _eP_[179],
                 _eP_[180],
                 _eP_[181],
                 _eP_[182],
                 _eP_[183],
                 _eP_[184],
                 _eP_[185],
                 _eP_[186],
                 _eP_[187],
                 _eP_[188],
                 _eP_[189],
                 _eP_[190],
                 _eP_[191],
                 _eP_[192],
                 _eP_[193],
                 _eP_[194],
                 _eP_[195],
                 _eP_[196],
                 _eP_[197],
                 _eP_[198],
                 _eP_[199],
                 _eP_[200],
                 _eP_[201],
                 _eP_[202],
                 _eP_[203],
                 _eP_[204],
                 _eP_[205],
                 _eP_[206],
                 _eP_[207],
                 _eP_[208],
                 _eP_[209],
                 _eP_[210],
                 _eP_[211],
                 _eP_[212],
                 _eP_[213],
                 _eP_[214],
                 _eP_[215],
                 _eP_[216],
                 _eP_[217],
                 _eP_[218],
                 _eP_[219],
                 _eP_[220],
                 _eP_[221],
                 _eP_[222],
                 _eP_[223],
                 _eP_[224],
                 _eP_[225],
                 _eP_[226],
                 _eP_[227],
                 _eP_[228],
                 _eP_[229],
                 _eP_[253],
                 _eP_[254],
                 _eP_[255],
                 _eP_[256],
                 _eP_[257],
                 _eP_[258],
                 _eP_[259],
                 _eP_[260],
                 _eP_[261],
                 _eP_[262],
                 _eP_[230],
                 _eP_[231],
                 _eP_[232],
                 _eP_[233],
                 _eP_[234],
                 _eP_[235],
                 _eP_[236],
                 _eP_[237],
                 _eP_[238],
                 _eP_[239],
                 _eP_[240],
                 _eP_[241],
                 _eP_[242],
                 _eP_[243],
                 _eP_[244],
                 _eP_[245],
                 _eP_[246],
                 _eP_[247],
                 _eP_[248],
                 _eP_[249],
                 _eP_[250],
                 _eP_[251],
                 _eP_[252],
                 _eP_[24],
                 _eP_[263],
                 _eP_[264],
                 _eP_[265],
                 _eP_[266],
                 _eP_[267],
                 _eP_[268],
                 _eP_[269],
                 _eP_[270],
                 _eP_[271],
                 _eP_[272],
                 _eP_[273],
                 _eP_[274],
                 _eP_[275],
                 _eP_[276],
                 _eP_[277],
                 _eP_[278],
                 _eP_[279],
                 _eP_[280],
                 _eP_[281],
                 _eP_[282],
                 _eP_[283],
                 _eP_[284],
                 _eP_[285],
                 _eP_[286],
                 _eP_[287],
                 _eP_[288],
                 _eP_[289],
                 _eP_[290],
                 _eP_[291],
                 _eP_[292],
                 _eP_[293],
                 _eP_[294],
                 _eP_[295],
                 _eP_[296],
                 _eP_[297],
                 _eP_[298],
                 _eP_[299],
                 _eP_[300],
                 _eP_[301],
                 _eP_[302],
                 _eP_[303],
                 _eP_[304],
                 _eP_[305],
                 _eP_[306],
                 _eP_[307],
                 _eP_[308],
                 _eP_[309],
                 _eP_[310],
                 _eP_[311],
                 _eP_[312],
                 _eP_[313],
                 _eP_[314],
                 _eP_[315],
                 _eP_[316],
                 _eP_[317],
                 _eP_[318],
                 _eP_[319],
                 _eP_[320],
                 _eP_[321],
                 _eP_[322],
                 _eP_[323],
                 _eP_[324],
                 _eP_[325],
                 _eP_[326],
                 _eP_[327],
                 _eP_[328],
                 _eP_[329],
                 _eP_[330],
                 _eP_[331],
                 _eP_[332],
                 _eP_[333],
                 _eP_[334],
                 _eP_[335],
                 _eP_[336],
                 _eP_[337],
                 _eP_[338],
                 _eP_[22],
                 _eP_[23],
                 _eP_[25],
                 _eP_[341],
                 _eP_[5],
                 _eP_[6],
                 _eP_[7],
                 _eP_[8],
                 _eP_[339],
                 _eP_[13],
                 _eP_[9],
                 [0,
                  _eN_[1],
                  _eN_[3],
                  _eN_[2],
                  _eN_[4],
                  _eN_[7],
                  _eN_[5],
                  _eN_[6],
                  _eN_[8],
                  _eN_[9],
                  _eN_[10]]]},
       _ad_,
       _ac_];
    caml_register_global(1101,Svg_f,"Svg_f");
    function Make_with_wrapped_functions$0(Xml,C,Svg)
     {var
       doctype=compose_doctype(cst_html,0),
       Info=
        [0,
         content_type$0,
         alternative_content_types,
         version$0,
         standard$0,
         namespace$0,
         doctype,
         emptytags],
       _aH_=Xml[2],
       _aI_=Xml[3];
      function to_xmlattribs(x){return x}
      function to_attrib(x){return x}
      var _aJ_=Xml[4],_aK_=Xml[5],_aL_=Xml[6];
      function uri_attrib(a,s){return caml_call2(Xml[13],a,s)}
      var _aM_=Xml[7],_aN_=Xml[8];
      function user_attrib(f,name,v)
       {var _eK_=caml_call2(Xml[1][2],f,v);
        return caml_call2(Xml[6],name,_eK_)}
      var _aO_=C[3];
      function bool_attrib(_eI_,_eJ_){return user_attrib(_aO_,_eI_,_eJ_)}
      function constant_attrib(a,param)
       {return caml_call2(_aL_,a,caml_call1(Xml[1][1],a))}
      function linktypes_attrib(name,x){return user_attrib(C[8],name,x)}
      function mediadesc_attrib(name,x){return user_attrib(C[9],name,x)}
      function srcset_attrib(name,x){return user_attrib(C[14],name,x)}
      var a_class=caml_call1(_aM_,cst_class$0),a_id=caml_call1(_aL_,cst_id$0);
      function a_user_data(name)
       {return caml_call1(_aL_,caml_call2(Stdlib[28],cst_data$0,name))}
      var
       a_title=caml_call1(_aL_,cst_title$0),
       a_xml_lang=caml_call1(_aL_,cst_xml_lang$0),
       a_lang=caml_call1(_aL_,cst_lang$0),
       a_style=caml_call1(_aL_,cst_style$1),
       a_property=caml_call1(_aL_,cst_property),
       a_onabort=caml_call1(Xml[9],cst_onabort$0),
       a_onafterprint=caml_call1(Xml[9],cst_onafterprint),
       a_onbeforeprint=caml_call1(Xml[9],cst_onbeforeprint),
       a_onbeforeunload=caml_call1(Xml[9],cst_onbeforeunload),
       a_onblur=caml_call1(Xml[9],cst_onblur),
       a_oncanplay=caml_call1(Xml[9],cst_oncanplay),
       a_oncanplaythrough=caml_call1(Xml[9],cst_oncanplaythrough),
       a_onchange=caml_call1(Xml[9],cst_onchange),
       a_ondurationchange=caml_call1(Xml[9],cst_ondurationchange),
       a_onemptied=caml_call1(Xml[9],cst_onemptied),
       a_onended=caml_call1(Xml[9],cst_onended),
       a_onerror=caml_call1(Xml[9],cst_onerror$0),
       a_onfocus=caml_call1(Xml[9],cst_onfocus),
       a_onformchange=caml_call1(Xml[9],cst_onformchange),
       a_onforminput=caml_call1(Xml[9],cst_onforminput),
       a_onhashchange=caml_call1(Xml[9],cst_onhashchange),
       a_oninput=caml_call1(Xml[9],cst_oninput),
       a_oninvalid=caml_call1(Xml[9],cst_oninvalid),
       a_onoffline=caml_call1(Xml[9],cst_onoffline),
       a_ononline=caml_call1(Xml[9],cst_ononline),
       a_onpause=caml_call1(Xml[9],cst_onpause),
       a_onplay=caml_call1(Xml[9],cst_onplay),
       a_onplaying=caml_call1(Xml[9],cst_onplaying),
       a_onpagehide=caml_call1(Xml[9],cst_onpagehide),
       a_onpageshow=caml_call1(Xml[9],cst_onpageshow),
       a_onpopstate=caml_call1(Xml[9],cst_onpopstate),
       a_onprogress=caml_call1(Xml[9],cst_onprogress),
       a_onratechange=caml_call1(Xml[9],cst_onratechange),
       a_onreadystatechange=caml_call1(Xml[9],cst_onreadystatechange),
       a_onredo=caml_call1(Xml[9],cst_onredo),
       a_onresize=caml_call1(Xml[9],cst_onresize$0),
       a_onscroll=caml_call1(Xml[9],cst_onscroll$0),
       a_onseeked=caml_call1(Xml[9],cst_onseeked),
       a_onseeking=caml_call1(Xml[9],cst_onseeking),
       a_onselect=caml_call1(Xml[9],cst_onselect),
       a_onshow=caml_call1(Xml[9],cst_onshow),
       a_onstalled=caml_call1(Xml[9],cst_onstalled),
       a_onstorage=caml_call1(Xml[9],cst_onstorage),
       a_onsubmit=caml_call1(Xml[9],cst_onsubmit),
       a_onsuspend=caml_call1(Xml[9],cst_onsuspend),
       a_ontimeupdate=caml_call1(Xml[9],cst_ontimeupdate),
       a_onundo=caml_call1(Xml[9],cst_onundo),
       a_onunload=caml_call1(Xml[9],cst_onunload$0),
       a_onvolumechange=caml_call1(Xml[9],cst_onvolumechange),
       a_onwaiting=caml_call1(Xml[9],cst_onwaiting),
       a_onload=caml_call1(Xml[9],cst_onload$0),
       a_onloadeddata=caml_call1(Xml[9],cst_onloadeddata),
       a_onloadedmetadata=caml_call1(Xml[9],cst_onloadedmetadata),
       a_onloadstart=caml_call1(Xml[9],cst_onloadstart),
       a_onmessage=caml_call1(Xml[9],cst_onmessage),
       a_onmousewheel=caml_call1(Xml[9],cst_onmousewheel),
       a_onclick=caml_call1(Xml[10],cst_onclick$0),
       a_oncontextmenu=caml_call1(Xml[10],cst_oncontextmenu),
       a_ondblclick=caml_call1(Xml[10],cst_ondblclick),
       a_ondrag=caml_call1(Xml[10],cst_ondrag),
       a_ondragend=caml_call1(Xml[10],cst_ondragend),
       a_ondragenter=caml_call1(Xml[10],cst_ondragenter),
       a_ondragleave=caml_call1(Xml[10],cst_ondragleave),
       a_ondragover=caml_call1(Xml[10],cst_ondragover),
       a_ondragstart=caml_call1(Xml[10],cst_ondragstart),
       a_ondrop=caml_call1(Xml[10],cst_ondrop),
       a_onmousedown=caml_call1(Xml[10],cst_onmousedown$0),
       a_onmouseup=caml_call1(Xml[10],cst_onmouseup$0),
       a_onmouseover=caml_call1(Xml[10],cst_onmouseover$0),
       a_onmousemove=caml_call1(Xml[10],cst_onmousemove$0),
       a_onmouseout=caml_call1(Xml[10],cst_onmouseout$0),
       a_ontouchstart=caml_call1(Xml[12],cst_ontouchstart$0),
       a_ontouchend=caml_call1(Xml[12],cst_ontouchend$0),
       a_ontouchmove=caml_call1(Xml[12],cst_ontouchmove$0),
       a_ontouchcancel=caml_call1(Xml[12],cst_ontouchcancel$0),
       a_onkeypress=caml_call1(Xml[11],cst_onkeypress),
       a_onkeydown=caml_call1(Xml[11],cst_onkeydown),
       a_onkeyup=caml_call1(Xml[11],cst_onkeyup),
       a_version=caml_call1(_aL_,cst_version$0);
      function a_xmlns(x){return user_attrib(C[2],cst_xmlns$4,x)}
      function a_manifest(_eH_){return uri_attrib(cst_manifest,_eH_)}
      function a_cite(_eG_){return uri_attrib(cst_cite,_eG_)}
      function a_xml_space(x){return user_attrib(C[2],cst_xml_space$0,x)}
      function a_accesskey(c){return user_attrib(C[5],cst_accesskey,c)}
      var
       a_charset=caml_call1(_aL_,cst_charset),
       a_accept_charset=caml_call1(_aM_,cst_accept_charset),
       a_accept=caml_call1(_aN_,cst_accept);
      function a_href(_eF_){return uri_attrib(cst_href$0,_eF_)}
      var a_hreflang=caml_call1(_aL_,cst_hreflang);
      function a_download(file){return user_attrib(C[16],cst_download,file)}
      function a_rel(_eE_){return linktypes_attrib(cst_rel,_eE_)}
      var
       a_tabindex=caml_call1(_aK_,cst_tabindex),
       a_mime_type=caml_call1(_aL_,cst_type$4),
       a_alt=caml_call1(_aL_,cst_alt);
      function a_height(p){return caml_call2(_aK_,cst_height$0,p)}
      function a_src(_eD_){return uri_attrib(cst_src,_eD_)}
      function a_width(p){return caml_call2(_aK_,cst_width$0,p)}
      var
       a_for=caml_call1(_aL_,cst_for),
       a_for_list=caml_call1(_aM_,cst_for$0);
      function a_selected(_eC_){return constant_attrib(cst_selected,_eC_)}
      var
       a_text_value=caml_call1(_aL_,cst_value),
       a_int_value=caml_call1(_aK_,cst_value$0),
       a_value=caml_call1(_aL_,cst_value$1),
       a_float_value=caml_call1(_aJ_,cst_value$2);
      function a_action(_eB_){return uri_attrib(cst_action,_eB_)}
      function a_formmethod(x){return user_attrib(C[2],cst_method$0,x)}
      var a_enctype=caml_call1(_aL_,cst_enctype);
      function a_checked(_eA_){return constant_attrib(cst_checked,_eA_)}
      function a_disabled(_ez_){return constant_attrib(cst_disabled,_ez_)}
      function a_readonly(_ey_){return constant_attrib(cst_readonly,_ey_)}
      var
       a_maxlength=caml_call1(_aK_,cst_maxlength),
       a_minlength=caml_call1(_aK_,cst_minlength),
       a_name=caml_call1(_aL_,cst_name$0);
      function a_allowfullscreen(_ex_)
       {return constant_attrib(cst_allowfullscreen,_ex_)}
      function a_allowpaymentrequest(_ew_)
       {return constant_attrib(cst_allowpaymentrequest,_ew_)}
      function a_referrerpolicy(x)
       {return user_attrib(C[10],cst_referrerpolicy,x)}
      function a_autocomplete(x){return user_attrib(C[4],cst_autocomplete,x)}
      function a_async(_ev_){return constant_attrib(cst_async,_ev_)}
      function a_autofocus(_eu_){return constant_attrib(cst_autofocus,_eu_)}
      function a_autoplay(_et_){return constant_attrib(cst_autoplay,_et_)}
      function a_muted(_es_){return constant_attrib(cst_muted,_es_)}
      function a_crossorigin(x){return user_attrib(C[2],cst_crossorigin,x)}
      var
       a_integrity=caml_call1(_aL_,cst_integrity),
       a_mediagroup=caml_call1(_aL_,cst_mediagroup),
       a_challenge=caml_call1(_aL_,cst_challenge);
      function a_contenteditable(ce)
       {return bool_attrib(cst_contenteditable,ce)}
      var a_contextmenu=caml_call1(_aL_,cst_contextmenu);
      function a_controls(_er_){return constant_attrib(cst_controls,_er_)}
      function a_dir(x){return user_attrib(C[2],cst_dir,x)}
      function a_draggable(d){return bool_attrib(cst_draggable,d)}
      var a_form=caml_call1(_aL_,cst_form);
      function a_formaction(_eq_){return uri_attrib(cst_formaction,_eq_)}
      var a_formenctype=caml_call1(_aL_,cst_formenctype);
      function a_formnovalidate(_ep_)
       {return constant_attrib(cst_formnovalidate,_ep_)}
      var a_formtarget=caml_call1(_aL_,cst_formtarget);
      function a_hidden(_eo_){return constant_attrib(cst_hidden,_eo_)}
      var a_high=caml_call1(_aJ_,cst_high);
      function a_icon(_en_){return uri_attrib(cst_icon,_en_)}
      function a_ismap(_em_){return constant_attrib(cst_ismap,_em_)}
      var
       a_keytype=caml_call1(_aL_,cst_keytype),
       a_list=caml_call1(_aL_,cst_list);
      function a_loop(_el_){return constant_attrib(cst_loop,_el_)}
      var
       a_low=caml_call1(_aJ_,cst_low),
       a_max=caml_call1(_aJ_,cst_max$0),
       _aP_=C[7];
      function a_input_max(_ek_){return user_attrib(_aP_,cst_max$1,_ek_)}
      var a_min=caml_call1(_aJ_,cst_min$0),_aQ_=C[7];
      function a_input_min(_ej_){return user_attrib(_aQ_,cst_min$1,_ej_)}
      function a_inputmode(x){return user_attrib(C[2],cst_inputmode,x)}
      function a_novalidate(_ei_){return constant_attrib(cst_novalidate,_ei_)}
      function a_open(_eh_){return constant_attrib(cst_open,_eh_)}
      var
       a_optimum=caml_call1(_aJ_,cst_optimum),
       a_pattern=caml_call1(_aL_,cst_pattern$0),
       a_placeholder=caml_call1(_aL_,cst_placeholder);
      function a_poster(_eg_){return uri_attrib(cst_poster,_eg_)}
      function a_preload(x){return user_attrib(C[2],cst_preload,x)}
      function a_pubdate(_ef_){return constant_attrib(cst_pubdate,_ef_)}
      var a_radiogroup=caml_call1(_aL_,cst_radiogroup);
      function a_required(_ee_){return constant_attrib(cst_required,_ee_)}
      function a_reversed(_ed_){return constant_attrib(cst_reserved,_ed_)}
      function a_sandbox(x){return user_attrib(C[12],cst_sandbox,x)}
      function a_spellcheck(sc){return bool_attrib(cst_spellcheck,sc)}
      function a_scoped(_ec_){return constant_attrib(cst_scoped,_ec_)}
      function a_seamless(_eb_){return constant_attrib(cst_seamless,_eb_)}
      function a_sizes(sizes){return user_attrib(C[13],cst_sizes,sizes)}
      var
       a_span=caml_call1(_aK_,cst_span),
       a_srclang=caml_call1(_aL_,cst_xml_lang$1);
      function a_srcset(_ea_){return srcset_attrib(cst_srcset,_ea_)}
      var
       a_img_sizes=caml_call1(_aN_,cst_sizes$0),
       a_start=caml_call1(_aK_,cst_start$0);
      function a_step(step){return user_attrib(C[15],cst_step,step)}
      function a_translate(x){return user_attrib(C[2],cst_translate$0,x)}
      function a_wrap(x){return user_attrib(C[2],cst_wrap$0,x)}
      var a_size=caml_call1(_aK_,cst_size);
      function a_input_type(it){return user_attrib(C[6],cst_type$5,it)}
      function a_menu_type(x){return user_attrib(C[2],cst_type$6,x)}
      function a_command_type(x){return user_attrib(C[2],cst_type$7,x)}
      function a_button_type(bt){return user_attrib(C[6],cst_type$8,bt)}
      function a_multiple(_d$_){return constant_attrib(cst_multiple,_d$_)}
      var
       a_cols=caml_call1(_aK_,cst_cols),
       a_rows=caml_call1(_aK_,cst_rows),
       a_summary=caml_call1(_aL_,cst_summary);
      function a_align(x){return user_attrib(C[2],cst_align,x)}
      var
       a_axis=caml_call1(_aL_,cst_axis),
       a_colspan=caml_call1(_aK_,cst_colspan),
       a_headers=caml_call1(_aM_,cst_headers),
       a_rowspan=caml_call1(_aK_,cst_rowspan);
      function a_scope(x){return user_attrib(C[2],cst_scope,x)}
      var a_border=caml_call1(_aK_,cst_border);
      function a_rules(x){return user_attrib(C[2],cst_rules,x)}
      function a_char(c){return user_attrib(C[5],cst_char,c)}
      function a_data(_d__){return uri_attrib(cst_data$1,_d__)}
      var a_codetype=caml_call1(_aL_,cst_codetype);
      function a_frameborder(x){return user_attrib(C[2],cst_frameborder,x)}
      var
       a_marginheight=caml_call1(_aK_,cst_marginheight),
       a_marginwidth=caml_call1(_aK_,cst_marginwidth);
      function a_scrolling(x){return user_attrib(C[2],cst_scrolling,x)}
      var
       a_target=caml_call1(_aL_,cst_target),
       a_content=caml_call1(_aL_,cst_content),
       a_http_equiv=caml_call1(_aL_,cst_http_equiv);
      function a_media(_d9_){return mediadesc_attrib(cst_media$0,_d9_)}
      var a_role=caml_call1(_aM_,cst_role);
      function a_aria(name)
       {return caml_call1(_aM_,caml_call2(Stdlib[28],cst_aria,name))}
      function terminal(tag,a,param){return caml_call2(Xml[20],a,tag)}
      function unary(tag,a,elt)
       {var _d8_=caml_call1(Xml[1][4],elt);
        return caml_call3(Xml[21],a,tag,_d8_)}
      function star(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function plus(tag,a,elt,elts)
       {var _d7_=caml_call2(Xml[1][5],elt,elts);
        return caml_call3(Xml[21],a,tag,_d7_)}
      function option_cons(opt,elts)
       {if(opt){var x=opt[1];return caml_call2(Xml[1][5],x,elts)}return elts}
      function body(_d5_,_d6_){return star(cst_body,_d5_,_d6_)}
      function head(_d2_,_d3_,_d4_){return plus(cst_head,_d2_,_d3_,_d4_)}
      function title(_d0_,_d1_){return unary(cst_title$1,_d0_,_d1_)}
      function html(a,head,body)
       {var
         _dZ_=caml_call1(Xml[1][4],body),
         content=caml_call2(Xml[1][5],head,_dZ_);
        return caml_call3(Xml[21],a,cst_html$0,content)}
      function footer(_dX_,_dY_){return star(cst_footer,_dX_,_dY_)}
      function header(_dV_,_dW_){return star(cst_header,_dV_,_dW_)}
      function section(_dT_,_dU_){return star(cst_section,_dT_,_dU_)}
      function nav(_dR_,_dS_){return star(cst_nav,_dR_,_dS_)}
      function pcdata(s){return caml_call1(Xml[17],s)}
      var _aR_=Xml[19];
      function space(param){return caml_call1(_aR_,cst_nbsp)}
      var _aS_=Xml[22],_aT_=Xml[23],_aU_=Xml[24];
      function h1(_dP_,_dQ_){return star(cst_h1,_dP_,_dQ_)}
      function h2(_dN_,_dO_){return star(cst_h2,_dN_,_dO_)}
      function h3(_dL_,_dM_){return star(cst_h3,_dL_,_dM_)}
      function h4(_dJ_,_dK_){return star(cst_h4,_dJ_,_dK_)}
      function h5(_dH_,_dI_){return star(cst_h5,_dH_,_dI_)}
      function h6(_dF_,_dG_){return star(cst_h6,_dF_,_dG_)}
      function hgroup(_dD_,_dE_){return star(cst_hgroup,_dD_,_dE_)}
      function address(_dB_,_dC_){return star(cst_address,_dB_,_dC_)}
      function blockquote(_dz_,_dA_){return star(cst_blockquote,_dz_,_dA_)}
      function div(_dx_,_dy_){return star(cst_div,_dx_,_dy_)}
      function p(_dv_,_dw_){return star(cst_p,_dv_,_dw_)}
      function pre(_dt_,_du_){return star(cst_pre,_dt_,_du_)}
      function abbr(_dr_,_ds_){return star(cst_abbr,_dr_,_ds_)}
      function br(_dp_,_dq_){return terminal(cst_br,_dp_,_dq_)}
      function cite(_dn_,_do_){return star(cst_cite$0,_dn_,_do_)}
      function code(_dl_,_dm_){return star(cst_code,_dl_,_dm_)}
      function dfn(_dj_,_dk_){return star(cst_dfn,_dj_,_dk_)}
      function em(_dh_,_di_){return star(cst_em$0,_dh_,_di_)}
      function kbd(_df_,_dg_){return star(cst_kbd,_df_,_dg_)}
      function q(_dd_,_de_){return star(cst_q,_dd_,_de_)}
      function samp(_db_,_dc_){return star(cst_samp,_db_,_dc_)}
      function span(_c$_,_da_){return star(cst_span$0,_c$_,_da_)}
      function strong(_c9_,_c__){return star(cst_strong,_c9_,_c__)}
      function time(_c7_,_c8_){return star(cst_time,_c7_,_c8_)}
      function var$0(_c5_,_c6_){return star(cst_var,_c5_,_c6_)}
      function a(_c3_,_c4_){return star(cst_a$1,_c3_,_c4_)}
      function dl(_c1_,_c2_){return star(cst_dl,_c1_,_c2_)}
      function ol(_cZ_,_c0_){return star(cst_ol,_cZ_,_c0_)}
      function ul(_cX_,_cY_){return star(cst_ul,_cX_,_cY_)}
      function dd(_cV_,_cW_){return star(cst_dd,_cV_,_cW_)}
      function dt(_cT_,_cU_){return star(cst_dt,_cT_,_cU_)}
      function li(_cR_,_cS_){return star(cst_li,_cR_,_cS_)}
      function hr(_cP_,_cQ_){return terminal(cst_hr,_cP_,_cQ_)}
      function b(_cN_,_cO_){return star(cst_b$0,_cN_,_cO_)}
      function i(_cL_,_cM_){return star(cst_i,_cL_,_cM_)}
      function u(_cJ_,_cK_){return star(cst_u,_cJ_,_cK_)}
      function small(_cH_,_cI_){return star(cst_small,_cH_,_cI_)}
      function sub(_cF_,_cG_){return star(cst_sub,_cF_,_cG_)}
      function sup(_cD_,_cE_){return star(cst_sup,_cD_,_cE_)}
      function mark(_cB_,_cC_){return star(cst_mark,_cB_,_cC_)}
      function rp(_cz_,_cA_){return star(cst_rp,_cz_,_cA_)}
      function rt(_cx_,_cy_){return star(cst_rt,_cx_,_cy_)}
      function ruby(_cv_,_cw_){return star(cst_ruby,_cv_,_cw_)}
      function wbr(_ct_,_cu_){return terminal(cst_wbr,_ct_,_cu_)}
      function bdo(dir,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _cs_=[0,[0,a_dir(dir),a]];
        return caml_call3(Xml[21],_cs_,cst_bdo,elts)}
      var a_datetime=caml_call1(_aL_,cst_datetime);
      function a_shape(x){return user_attrib(C[2],cst_shape,x)}
      function a_coords(coords){return user_attrib(C[11],cst_coords,coords)}
      var a_usemap=caml_call1(_aL_,cst_usemap);
      function a_defer(_cr_){return constant_attrib(cst_defer,_cr_)}
      var a_label=caml_call1(_aL_,cst_label);
      function area(alt,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _cq_=[0,[0,caml_call1(a_alt,alt),a]];
        return caml_call2(Xml[20],_cq_,cst_area)}
      function map(_co_,_cp_){return star(cst_map,_co_,_cp_)}
      function del(_cm_,_cn_){return star(cst_del,_cm_,_cn_)}
      function ins(_ck_,_cl_){return star(cst_ins,_ck_,_cl_)}
      function script(_ci_,_cj_){return unary(cst_script$0,_ci_,_cj_)}
      function noscript(_cg_,_ch_){return star(cst_noscript,_cg_,_ch_)}
      function template(_ce_,_cf_){return star(cst_template,_ce_,_cf_)}
      function article(_cc_,_cd_){return star(cst_article,_cc_,_cd_)}
      function aside(_ca_,_cb_){return star(cst_aside,_ca_,_cb_)}
      function main(_b__,_b$_){return star(cst_main,_b__,_b$_)}
      function video_audio(name,src,srcs,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        if(src)var uri=src[1],a$0=[0,a_src(uri),a];else var a$0=a;
        if(srcs)
         {var srcs$0=srcs[1],_b9_=caml_call2(Xml[1][6],srcs$0,elts);
          return caml_call3(Xml[21],[0,a$0],name,_b9_)}
        return caml_call3(Xml[21],[0,a$0],name,elts)}
      function audio(_b5_,_b6_,_b7_,_b8_)
       {return video_audio(cst_audio,_b5_,_b6_,_b7_,_b8_)}
      function video(_b1_,_b2_,_b3_,_b4_)
       {return video_audio(cst_video,_b1_,_b2_,_b3_,_b4_)}
      function canvas(_bZ_,_b0_){return star(cst_canvas,_bZ_,_b0_)}
      function command(label,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _bY_=[0,[0,caml_call1(a_label,label),a]];
        return caml_call2(Xml[20],_bY_,cst_command)}
      function menu(children,a,param)
       {if(children)
         var match=children[1],l=match[2],children$0=l;
        else
         var children$0=caml_call1(Xml[1][3],0);
        return caml_call3(Xml[21],a,cst_menu,children$0)}
      function embed(_bW_,_bX_){return terminal(cst_embed,_bW_,_bX_)}
      function source(_bU_,_bV_){return terminal(cst_source,_bU_,_bV_)}
      function meter(_bS_,_bT_){return star(cst_meter,_bS_,_bT_)}
      function output_elt(_bQ_,_bR_){return star(cst_output,_bQ_,_bR_)}
      function form(_bO_,_bP_){return star(cst_form$0,_bO_,_bP_)}
      function svg(opt,children)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _bN_=caml_call2(Svg[242],[0,a],children);
        return caml_call1(Svg[324],_bN_)}
      function input(_bL_,_bM_){return terminal(cst_input,_bL_,_bM_)}
      function keygen(_bJ_,_bK_){return terminal(cst_keygen,_bJ_,_bK_)}
      function label(_bH_,_bI_){return star(cst_label$0,_bH_,_bI_)}
      function option(_bF_,_bG_){return unary(cst_option,_bF_,_bG_)}
      function select(_bD_,_bE_){return star(cst_select,_bD_,_bE_)}
      function textarea(_bB_,_bC_){return unary(cst_textarea,_bB_,_bC_)}
      function button(_bz_,_bA_){return star(cst_button,_bz_,_bA_)}
      function datalist(children,a,param)
       {if(children)
         var match=children[1],x=match[2],children$0=x;
        else
         var children$0=caml_call1(Xml[1][3],0);
        return caml_call3(Xml[21],a,cst_datalist,children$0)}
      function progress(_bx_,_by_){return star(cst_progress,_bx_,_by_)}
      function legend(_bv_,_bw_){return star(cst_legend,_bv_,_bw_)}
      function details(summary,a,children)
       {return plus(cst_details,a,summary,children)}
      function summary(_bt_,_bu_){return star(cst_summary$0,_bt_,_bu_)}
      function fieldset(legend,a,elts)
       {var _bs_=option_cons(legend,elts);
        return caml_call3(Xml[21],a,cst_fieldset,_bs_)}
      function optgroup(label,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _br_=[0,[0,caml_call1(a_label,label),a]];
        return caml_call3(Xml[21],_br_,cst_optgroup,elts)}
      function figcaption(_bp_,_bq_){return star(cst_figcaption,_bp_,_bq_)}
      function figure(figcaption,a,elts)
       {if(figcaption)
         {var _bm_=figcaption[1];
          if(437082891 <= _bm_[1])
           var
            c=_bm_[2],
            _bn_=caml_call1(Xml[1][4],c),
            _bo_=caml_call2(Xml[1][6],elts,_bn_);
          else
           var c$0=_bm_[2],_bo_=caml_call2(Xml[1][5],c$0,elts);
          var content=_bo_}
        else
         var content=elts;
        return caml_call3(Xml[21],a,cst_figure,content)}
      function caption(_bk_,_bl_){return star(cst_caption,_bk_,_bl_)}
      function table(caption,columns,thead,tfoot,a,elts)
       {var content=option_cons(thead,option_cons(tfoot,elts));
        if(columns)
         var
          columns$0=columns[1],
          content$0=caml_call2(Xml[1][6],columns$0,content);
        else
         var content$0=content;
        var content$1=option_cons(caption,content$0);
        return caml_call3(Xml[21],a,cst_table$0,content$1)}
      function td(_bi_,_bj_){return star(cst_td,_bi_,_bj_)}
      function th(_bg_,_bh_){return star(cst_th,_bg_,_bh_)}
      function tr(_be_,_bf_){return star(cst_tr,_be_,_bf_)}
      function colgroup(_bc_,_bd_){return star(cst_colgroup,_bc_,_bd_)}
      function col(_ba_,_bb_){return terminal(cst_col,_ba_,_bb_)}
      function thead(_a__,_a$_){return star(cst_thead,_a__,_a$_)}
      function tbody(_a8_,_a9_){return star(cst_tbody,_a8_,_a9_)}
      function tfoot(_a6_,_a7_){return star(cst_tfoot,_a6_,_a7_)}
      function iframe(_a4_,_a5_){return star(cst_iframe,_a4_,_a5_)}
      function object(params,opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        if(params)
         var e=params[1],elts$0=caml_call2(Xml[1][6],e,elts);
        else
         var elts$0=elts;
        return caml_call3(Xml[21],[0,a],cst_object,elts$0)}
      function param(_a2_,_a3_){return terminal(cst_param,_a2_,_a3_)}
      function img(src,alt,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _a1_=[0,caml_call1(a_alt,alt),a],a$0=[0,a_src(src),_a1_];
        return caml_call2(Xml[20],[0,a$0],cst_img)}
      function picture(img,a,elts)
       {var content=caml_call2(Xml[1][5],img,elts);
        return caml_call3(Xml[21],a,cst_picture,content)}
      function meta(_aZ_,_a0_){return terminal(cst_meta,_aZ_,_a0_)}
      function style(opt,elts)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        return caml_call3(Xml[21],[0,a],cst_style$2,elts)}
      function link(rel,href,opt,param)
       {if(opt)var sth=opt[1],a=sth;else var a=0;
        var _aX_=[0,a_href(href),a],_aY_=[0,[0,a_rel(rel),_aX_]];
        return caml_call2(Xml[20],_aY_,cst_link)}
      function base(_aV_,_aW_){return terminal(cst_base,_aV_,_aW_)}
      function tot(x){return x}
      function totl(x){return x}
      function toelt(x){return x}
      function toeltl(x){return x}
      function doc_toelt(x){return x}
      var I=_a_(Xml);
      function of_seq(s){return caml_call1(I[1],s)}
      function data(s){return caml_call1(Xml[18],s)}
      function leaf(tag,a,param){return caml_call2(Xml[20],a,tag)}
      function node(tag,a,elts){return caml_call3(Xml[21],a,tag,elts)}
      function coerce_elt(x){return x}
      var float_attrib=Xml[4],int_attrib=Xml[5],string_attrib=Xml[6];
      function uri_attrib$0(a,s){return caml_call2(Xml[13],a,s)}
      var
       space_sep_attrib=Xml[7],
       comma_sep_attrib=Xml[8],
       Unsafe=
        [0,
         data,
         leaf,
         node,
         coerce_elt,
         float_attrib,
         int_attrib,
         string_attrib,
         uri_attrib$0,
         space_sep_attrib,
         comma_sep_attrib];
      return [0,
              Xml,
              Info,
              _aH_,
              _aI_,
              to_xmlattribs,
              to_attrib,
              _aJ_,
              _aK_,
              _aL_,
              uri_attrib,
              _aM_,
              _aN_,
              user_attrib,
              bool_attrib,
              constant_attrib,
              linktypes_attrib,
              mediadesc_attrib,
              srcset_attrib,
              a_class,
              a_id,
              a_user_data,
              a_title,
              a_xml_lang,
              a_lang,
              a_style,
              a_property,
              a_onabort,
              a_onafterprint,
              a_onbeforeprint,
              a_onbeforeunload,
              a_onblur,
              a_oncanplay,
              a_oncanplaythrough,
              a_onchange,
              a_ondurationchange,
              a_onemptied,
              a_onended,
              a_onerror,
              a_onfocus,
              a_onformchange,
              a_onforminput,
              a_onhashchange,
              a_oninput,
              a_oninvalid,
              a_onoffline,
              a_ononline,
              a_onpause,
              a_onplay,
              a_onplaying,
              a_onpagehide,
              a_onpageshow,
              a_onpopstate,
              a_onprogress,
              a_onratechange,
              a_onreadystatechange,
              a_onredo,
              a_onresize,
              a_onscroll,
              a_onseeked,
              a_onseeking,
              a_onselect,
              a_onshow,
              a_onstalled,
              a_onstorage,
              a_onsubmit,
              a_onsuspend,
              a_ontimeupdate,
              a_onundo,
              a_onunload,
              a_onvolumechange,
              a_onwaiting,
              a_onload,
              a_onloadeddata,
              a_onloadedmetadata,
              a_onloadstart,
              a_onmessage,
              a_onmousewheel,
              a_onclick,
              a_oncontextmenu,
              a_ondblclick,
              a_ondrag,
              a_ondragend,
              a_ondragenter,
              a_ondragleave,
              a_ondragover,
              a_ondragstart,
              a_ondrop,
              a_onmousedown,
              a_onmouseup,
              a_onmouseover,
              a_onmousemove,
              a_onmouseout,
              a_ontouchstart,
              a_ontouchend,
              a_ontouchmove,
              a_ontouchcancel,
              a_onkeypress,
              a_onkeydown,
              a_onkeyup,
              a_version,
              a_xmlns,
              a_manifest,
              a_cite,
              a_xml_space,
              a_accesskey,
              a_charset,
              a_accept_charset,
              a_accept,
              a_href,
              a_hreflang,
              a_download,
              a_rel,
              a_tabindex,
              a_mime_type,
              a_alt,
              a_height,
              a_src,
              a_width,
              a_for,
              a_for,
              a_for_list,
              a_for_list,
              a_selected,
              a_text_value,
              a_int_value,
              a_value,
              a_float_value,
              a_action,
              a_formmethod,
              a_formmethod,
              a_enctype,
              a_checked,
              a_disabled,
              a_readonly,
              a_maxlength,
              a_minlength,
              a_name,
              a_allowfullscreen,
              a_allowpaymentrequest,
              a_referrerpolicy,
              a_autocomplete,
              a_async,
              a_autofocus,
              a_autoplay,
              a_muted,
              a_crossorigin,
              a_integrity,
              a_mediagroup,
              a_challenge,
              a_contenteditable,
              a_contextmenu,
              a_controls,
              a_dir,
              a_draggable,
              a_form,
              a_formaction,
              a_formenctype,
              a_formnovalidate,
              a_formtarget,
              a_hidden,
              a_high,
              a_icon,
              a_ismap,
              a_keytype,
              a_list,
              a_loop,
              a_low,
              a_max,
              a_input_max,
              a_min,
              a_input_min,
              a_inputmode,
              a_novalidate,
              a_open,
              a_optimum,
              a_pattern,
              a_placeholder,
              a_poster,
              a_preload,
              a_pubdate,
              a_radiogroup,
              a_required,
              a_reversed,
              a_sandbox,
              a_spellcheck,
              a_scoped,
              a_seamless,
              a_sizes,
              a_span,
              a_srclang,
              a_srcset,
              a_img_sizes,
              a_start,
              a_step,
              a_translate,
              a_wrap,
              a_size,
              a_input_type,
              a_menu_type,
              a_command_type,
              a_button_type,
              a_multiple,
              a_cols,
              a_rows,
              a_summary,
              a_align,
              a_axis,
              a_colspan,
              a_headers,
              a_rowspan,
              a_scope,
              a_border,
              a_rules,
              a_char,
              a_data,
              a_codetype,
              a_frameborder,
              a_marginheight,
              a_marginwidth,
              a_scrolling,
              a_target,
              a_content,
              a_http_equiv,
              a_media,
              a_role,
              a_aria,
              terminal,
              unary,
              star,
              plus,
              option_cons,
              body,
              head,
              title,
              html,
              footer,
              header,
              section,
              nav,
              pcdata,
              pcdata,
              _aR_,
              space,
              _aS_,
              _aT_,
              _aU_,
              h1,
              h2,
              h3,
              h4,
              h5,
              h6,
              hgroup,
              address,
              blockquote,
              div,
              p,
              pre,
              abbr,
              br,
              cite,
              code,
              dfn,
              em,
              kbd,
              q,
              samp,
              span,
              strong,
              time,
              var$0,
              a,
              dl,
              ol,
              ul,
              dd,
              dt,
              li,
              hr,
              b,
              i,
              u,
              small,
              sub,
              sup,
              mark,
              rp,
              rt,
              ruby,
              wbr,
              bdo,
              a_datetime,
              a_shape,
              a_coords,
              a_usemap,
              a_defer,
              a_label,
              area,
              map,
              del,
              ins,
              script,
              noscript,
              template,
              article,
              aside,
              main,
              video_audio,
              audio,
              video,
              canvas,
              command,
              menu,
              embed,
              source,
              meter,
              output_elt,
              form,
              svg,
              input,
              keygen,
              label,
              option,
              select,
              textarea,
              button,
              datalist,
              progress,
              legend,
              details,
              summary,
              fieldset,
              optgroup,
              figcaption,
              figure,
              caption,
              table,
              table,
              td,
              th,
              tr,
              colgroup,
              col,
              thead,
              tbody,
              tfoot,
              iframe,
              object,
              param,
              img,
              picture,
              meta,
              style,
              link,
              base,
              tot,
              totl,
              toelt,
              toeltl,
              doc_toelt,
              I,
              of_seq,
              Unsafe]}
    function Wrapped_functions$0(Xml)
     {function string_of_sandbox_token(param)
       {return -177579325 <= param
                ?642066717 <= param
                  ?961985737 <= param?cst_allow_same_origin:cst_allow_popups
                  :-141440231 <= param?cst_allow_forms:cst_allow_pointer_lock
                :-237921695 <= param?cst_allow_script:cst_allow_top_navigation}
      function string_of_linktype(param)
       {if(typeof param === "number")
         return 381789656 <= param
                 ?814486425 <= param
                   ?870035731 <= param
                     ?1021867988 <= param
                       ?1026883179 <= param?cst_external:cst_canonical
                       :892857107 <= param?cst_prev:cst_next
                     :847656566 <= param?cst_last:cst_icon$0
                   :395967329 <= param
                     ?693914176 <= param
                       ?803495649 <= param?cst_help:cst_noreferrer
                       :672161451 <= param?cst_author:cst_license
                     :395056008 <= param?cst_search:cst_noopener
                 :-289155950 <= param
                   ?19067 <= param
                     ?212027606 <= param
                       ?332064784 <= param?cst_first:cst_bookmark
                       :4198970 <= param?cst_tag:cst_up
                     :-123098695 <= param?cst_pingback:cst_nofollow
                   :-837966724 <= param
                     ?-687429350 <= param
                       ?-543567890 <= param?cst_stylesheet:cst_alternate
                       :-784200974 <= param?cst_index:cst_sidebar
                     :-954191215 <= param?cst_archives:cst_prefetch;
        var s=param[2];
        return s}
      function string_of_mediadesc_token(param)
       {if(typeof param === "number")
         return 3256577 <= param
                 ?67844052 <= param
                   ?985170249 <= param
                     ?993823919 <= param?cst_projection:cst_aural
                     :741408196 <= param?cst_handheld:cst_embossed
                   :4203225 <= param?cst_tty:cst_all
                 :-321929715 === param
                   ?cst_braille
                   :-68046964 <= param
                     ?18850 <= param?cst_tv:cst_screen$0
                     :-275811774 <= param?cst_speech:cst_print;
        var s=param[2];
        return s}
      function string_of_referrerpolicy(param)
       {return 128179133 <= param
                ?516162486 === param
                  ?cst_unsafe_url
                  :880519217 <= param
                    ?1065162943 <= param
                      ?cst_same_origin
                      :cst_origin_when_cross_origin
                    :808133042 <= param
                      ?cst_no_referrer_when_downgrade
                      :cst_no_referrer
                :-6975994 <= param
                  ?50834029 <= param?cst$39:cst_origin
                  :-512964804 <= param
                    ?cst_strict_origin
                    :cst_strict_origin_when_cross_o}
      function string_of_big_variant(param)
       {if(typeof param === "number")
         return 4448519 <= param
                 ?748545107 <= param
                   ?892709484 <= param
                     ?936387931 <= param
                       ?984475830 <= param
                         ?1003109192 <= param
                           ?1026883179 <= param?cst_external$0:cst_0
                           :995986491 <= param?cst_formnovalidate$0:cst_audio$0
                         :936573133 === param
                           ?cst_text$0
                           :963342108 <= param?cst_async$0:cst_toolbar
                       :892857107 <= param
                         ?914891065 <= param
                           ?925976842 <= param?cst_soft:cst_rows$0
                           :914389316 <= param?cst_rect$0:cst_prev$0
                         :892711040 <= param?cst_POST:cst_poly
                     :847852583 <= param
                       ?870035731 <= param
                         ?874830961 <= param
                           ?881668074 <= param?cst_open$0:cst_decimal
                           :870530776 <= param?cst_none$2:cst_next$0
                         :848351876 <= param?cst_loop$0:cst_left
                       :803495649 <= param
                         ?836565865 <= param
                           ?847656566 <= param?cst_last$0:cst_kana
                           :814486425 <= param?cst_icon$1:cst_help$0
                         :803298059 <= param?cst_hard:cst_cols$0
                   :306241015 <= param
                     ?475573507 <= param
                       ?672161451 <= param
                         ?726666127 <= param
                           ?748194550 <= param?cst_char$0:cst_auto$3
                           :693914176 <= param?cst_noreferrer$0:cst_author$0
                         :596180811 <= param?cst_muted$0:cst_autoplay$0
                       :395056008 <= param
                         ?432776079 <= param
                           ?434500685 <= param?cst_anonymous:cst_metadata$0
                           :395967329 <= param?cst_license$0:cst_search$0
                         :332064784 <= param?cst_first$0:cst_novalidate$0
                     :140750597 <= param
                       ?186574459 <= param
                         ?212027606 <= param
                           ?292438678 <= param?cst_controls$0:cst_bookmark$0
                           :202657151 <= param?cst_required$0:cst_selected$0
                         :178382384 <= param?cst_circle$0:cst_rowgroup
                       :48900580 <= param
                         ?95509868 <= param
                           ?111644259 <= param?cst_checkbox:cst_katakana
                           :50085628 <= param?cst_email:cst_latin
                         :19559306 <= param?cst_hidden$0:cst_yes
                 :-363872942 <= param
                   ?19067 <= param
                     ?3953222 <= param
                       ?4103754 <= param
                         ?4199867 <= param
                           ?4252495 <= param?cst_url:cst_tel
                           :4198970 <= param?cst_tag$0:cst_rtl
                         :4102650 <= param?cst_row:cst_1
                       :3257036 <= param
                         ?3553398 <= param
                           ?3805386 <= param?cst_ltr:cst_GET
                           :3356704 <= param?cst_col$0:cst_any
                         :3256577 <= param?cst_all$0:cst_up$0
                     :-146439973 <= param
                       ?-116258131 <= param
                         ?-57574468 <= param
                           ?17505 <= param?cst_no:cst_right
                           :-100768656 <= param?cst_scoped$0:cst_numeric
                         :-123098695 <= param?cst_pingback$0:cst_radio
                       :-247853591 <= param
                         ?-197222864 <= param
                           ?-165772469 <= param?cst_pubdate$0:cst_multiple$0
                           :-200275514 <= param?cst_latin_name:cst_autofocus$0
                         :-289155950 <= param?cst_nofollow$0:cst_defer$0
                   :-773209244 <= param
                     ?-543567890 <= param
                       ?-514572330 <= param
                         ?-384499551 <= param
                           ?-369291781 <= param?cst_full_width_latin:cst_default$0
                           :-423051825 <= param?cst_context:cst_verbatim
                         :-529147129 <= param?cst_checked$0:cst_stylesheet$0
                       :-709493348 <= param
                         ?-687429350 <= param
                           ?-613973726 <= param?cst_reserved$0:cst_alternate$0
                           :-707104822 <= param
                             ?cst_http_www_w3_org_1999_xhtml
                             :cst_disabled$0
                         :-728306478 <= param?cst_ismap$0:cst_use_credentials
                     :-872161756 <= param
                       ?-826369749 <= param
                         ?-788068560 <= param
                           ?-784200974 <= param?cst_index$0:cst_justify
                           :-792946572 <= param?cst_groups:cst_command$0
                         :-837966724 <= param?cst_sidebar$0:cst_latin_prose
                       :-967956361 <= param
                         ?-931002593 <= param
                           ?-883155966 <= param?cst_readonly$0:cst_colgroup$0
                           :-954191215 <= param?cst_archives$0:cst_seamless$0
                         :-1000861353 <= param?cst_prefetch$0:cst_preserve$0;
        var s=param[2];
        return s}
      function string_of_input_type(param)
       {return 50085628 <= param
                ?612668487 <= param
                  ?781515420 <= param
                    ?936769581 <= param
                      ?969837588 <= param?cst_week:cst_time$0
                      :936573133 <= param?cst_text$1:cst_file
                    :758940238 <= param?cst_date:cst_datetime_local
                  :242538002 <= param
                    ?529348384 <= param
                      ?578936635 <= param?cst_password:cst_month
                      :395056008 <= param?cst_search$1:cst_button$0
                    :111644259 <= param?cst_checkbox$0:cst_email$0
                :-146439973 <= param
                  ?-101336657 <= param
                    ?4252495 <= param
                      ?19559306 <= param?cst_hidden$1:cst_url$0
                      :4199867 <= param?cst_tel$0:cst_reset
                    :-145943139 <= param?cst_range:cst_radio$0
                  :-795439301 <= param
                    ?-578166461 <= param
                      ?-528289822 <= param?cst_readonly$1:cst_color
                      :-703661335 <= param?cst_number:cst_image$0
                    :-828715976 <= param?cst_submit:cst_datetime$0}
      function string_of_number_or_datetime(param)
       {if(-703661335 <= param[1])
         {var n=param[2];return caml_call1(Stdlib[33],n)}
        var t=param[2];
        return t}
      var
       string_of_character=caml_call1(Stdlib_string[1],1),
       string_of_number$0=Stdlib[33],
       string_of_bool=Stdlib[30];
      function onoff_of_bool(param){return param?cst_on:cst_off}
      function unoption_string(param)
       {if(param){var x=param[1];return x}return cst$40}
      function string_of_step(param)
       {if(param){var x=param[1];return string_of_number(x)}return cst_any$0}
      function string_of_sizes(param)
       {if(param)
         {var
           l=param[1],
           _aF_=
            function(param)
             {var y=param[2],x=param[1];
              return caml_call3(Stdlib_printf[4],_ae_,x,y)},
           _aG_=caml_call2(Stdlib_list[17],_aF_,l);
          return caml_call2(Stdlib_string[7],cst$41,_aG_)}
        return cst_any$1}
      function string_of_sandbox(l)
       {var _aE_=caml_call2(Stdlib_list[17],string_of_sandbox_token,l);
        return caml_call2(Stdlib_string[7],cst$42,_aE_)}
      function string_of_numbers(l)
       {var _aD_=caml_call2(Stdlib_list[17],string_of_number$0,l);
        return caml_call2(Stdlib_string[7],cst$43,_aD_)}
      function string_of_mediadesc(l)
       {var _aC_=caml_call2(Stdlib_list[17],string_of_mediadesc_token,l);
        return caml_call2(Stdlib_string[7],cst$44,_aC_)}
      function string_of_linktypes(l)
       {var _aB_=caml_call2(Stdlib_list[17],string_of_linktype,l);
        return caml_call2(Stdlib_string[7],cst$45,_aB_)}
      function string_of_srcset(l)
       {function f(param)
         {var _aw_=param[1];
          if(-738802218 === _aw_)
           {var
             match=param[2],
             v=match[2],
             url=match[1],
             _ax_=caml_call1(string_of_number$0,v),
             _ay_=caml_call1(Xml[2],url);
            return caml_call3(Stdlib_printf[4],_af_,_ay_,_ax_)}
          if(4252495 <= _aw_)
           {var url$0=param[2];return caml_call1(Xml[2],url$0)}
          var
           match$0=param[2],
           v$0=match$0[2],
           url$1=match$0[1],
           _az_=string_of_number(v$0),
           _aA_=caml_call1(Xml[2],url$1);
          return caml_call3(Stdlib_printf[4],_ag_,_aA_,_az_)}
        var _av_=caml_call2(Stdlib_list[17],f,l);
        return caml_call2(Stdlib_string[7],cst$46,_av_)}
      return [0,
              Xml,
              string_of_sandbox_token,
              string_of_linktype,
              string_of_mediadesc_token,
              string_of_referrerpolicy,
              string_of_big_variant,
              string_of_input_type,
              string_of_number_or_datetime,
              string_of_character,
              string_of_number$0,
              string_of_bool,
              onoff_of_bool,
              unoption_string,
              string_of_step,
              string_of_sizes,
              string_of_sandbox,
              string_of_numbers,
              string_of_mediadesc,
              string_of_linktypes,
              string_of_srcset]}
    function _ah_(_as_,_ar_,_aq_)
     {var _at_=Make_with_wrapped_functions$0(_as_,_ar_,_aq_),_au_=_at_[363];
      return [0,
              _at_[1],
              _at_[2],
              _at_[3],
              _at_[4],
              _at_[19],
              _at_[21],
              _at_[20],
              _at_[22],
              _at_[23],
              _at_[24],
              _at_[27],
              _at_[28],
              _at_[29],
              _at_[30],
              _at_[31],
              _at_[32],
              _at_[33],
              _at_[34],
              _at_[35],
              _at_[36],
              _at_[37],
              _at_[38],
              _at_[39],
              _at_[40],
              _at_[41],
              _at_[42],
              _at_[43],
              _at_[44],
              _at_[77],
              _at_[45],
              _at_[46],
              _at_[47],
              _at_[48],
              _at_[49],
              _at_[50],
              _at_[51],
              _at_[52],
              _at_[53],
              _at_[54],
              _at_[55],
              _at_[56],
              _at_[57],
              _at_[58],
              _at_[59],
              _at_[60],
              _at_[61],
              _at_[62],
              _at_[63],
              _at_[64],
              _at_[65],
              _at_[66],
              _at_[67],
              _at_[68],
              _at_[69],
              _at_[70],
              _at_[71],
              _at_[72],
              _at_[73],
              _at_[74],
              _at_[75],
              _at_[76],
              _at_[78],
              _at_[79],
              _at_[80],
              _at_[81],
              _at_[82],
              _at_[83],
              _at_[84],
              _at_[85],
              _at_[86],
              _at_[87],
              _at_[88],
              _at_[89],
              _at_[90],
              _at_[91],
              _at_[92],
              _at_[93],
              _at_[94],
              _at_[95],
              _at_[96],
              _at_[97],
              _at_[98],
              _at_[99],
              _at_[138],
              _at_[139],
              _at_[141],
              _at_[142],
              _at_[143],
              _at_[144],
              _at_[145],
              _at_[146],
              _at_[147],
              _at_[148],
              _at_[149],
              _at_[150],
              _at_[151],
              _at_[152],
              _at_[153],
              _at_[154],
              _at_[155],
              _at_[156],
              _at_[157],
              _at_[158],
              _at_[159],
              _at_[160],
              _at_[161],
              _at_[162],
              _at_[163],
              _at_[164],
              _at_[165],
              _at_[166],
              _at_[167],
              _at_[168],
              _at_[169],
              _at_[170],
              _at_[171],
              _at_[172],
              _at_[173],
              _at_[174],
              _at_[175],
              _at_[176],
              _at_[177],
              _at_[178],
              _at_[179],
              _at_[180],
              _at_[181],
              _at_[140],
              _at_[182],
              _at_[183],
              _at_[184],
              _at_[185],
              _at_[186],
              _at_[187],
              _at_[188],
              _at_[189],
              _at_[190],
              _at_[191],
              _at_[192],
              _at_[193],
              _at_[194],
              _at_[195],
              _at_[196],
              _at_[100],
              _at_[101],
              _at_[102],
              _at_[103],
              _at_[104],
              _at_[105],
              _at_[106],
              _at_[107],
              _at_[108],
              _at_[109],
              _at_[110],
              _at_[111],
              _at_[112],
              _at_[113],
              _at_[114],
              _at_[292],
              _at_[128],
              _at_[132],
              _at_[203],
              _at_[131],
              _at_[119],
              _at_[120],
              _at_[121],
              _at_[122],
              _at_[135],
              _at_[136],
              _at_[129],
              _at_[130],
              _at_[202],
              _at_[137],
              _at_[204],
              _at_[123],
              _at_[197],
              _at_[117],
              _at_[198],
              _at_[124],
              _at_[125],
              _at_[126],
              _at_[127],
              _at_[133],
              _at_[134],
              _at_[201],
              _at_[200],
              _at_[199],
              _at_[297],
              _at_[206],
              _at_[207],
              _at_[208],
              _at_[209],
              _at_[210],
              _at_[211],
              _at_[205],
              _at_[212],
              _at_[213],
              _at_[214],
              _at_[115],
              _at_[116],
              _at_[118],
              _at_[293],
              _at_[294],
              _at_[295],
              _at_[215],
              _at_[216],
              _at_[217],
              _at_[218],
              _at_[219],
              _at_[220],
              _at_[221],
              _at_[222],
              _at_[223],
              _at_[296],
              _at_[224],
              _at_[25],
              _at_[26],
              _at_[225],
              _at_[226],
              _at_[240],
              _at_[235],
              _at_[233],
              _at_[355],
              _at_[234],
              _at_[232],
              _at_[319],
              _at_[236],
              _at_[237],
              _at_[238],
              _at_[239],
              _at_[247],
              _at_[248],
              _at_[249],
              _at_[250],
              _at_[251],
              _at_[252],
              _at_[253],
              _at_[254],
              _at_[305],
              _at_[306],
              _at_[307],
              _at_[257],
              _at_[258],
              _at_[255],
              _at_[256],
              _at_[273],
              _at_[274],
              _at_[275],
              _at_[276],
              _at_[277],
              _at_[278],
              _at_[334],
              _at_[335],
              _at_[279],
              _at_[280],
              _at_[281],
              _at_[282],
              _at_[283],
              _at_[284],
              _at_[285],
              _at_[286],
              _at_[290],
              _at_[291],
              _at_[259],
              _at_[260],
              _at_[261],
              _at_[262],
              _at_[263],
              _at_[264],
              _at_[265],
              _at_[266],
              _at_[267],
              _at_[268],
              _at_[269],
              _at_[270],
              _at_[271],
              _at_[272],
              _at_[300],
              _at_[301],
              _at_[350],
              _at_[351],
              _at_[347],
              _at_[348],
              _at_[349],
              _at_[314],
              _at_[309],
              _at_[310],
              _at_[311],
              _at_[315],
              _at_[298],
              _at_[299],
              _at_[336],
              _at_[338],
              _at_[337],
              _at_[342],
              _at_[343],
              _at_[344],
              _at_[345],
              _at_[346],
              _at_[339],
              _at_[340],
              _at_[341],
              _at_[318],
              _at_[332],
              _at_[329],
              _at_[322],
              _at_[320],
              _at_[326],
              _at_[324],
              _at_[327],
              _at_[333],
              _at_[323],
              _at_[325],
              _at_[321],
              _at_[328],
              _at_[316],
              _at_[317],
              _at_[242],
              _at_[243],
              _at_[244],
              _at_[245],
              _at_[246],
              _at_[330],
              _at_[331],
              _at_[312],
              _at_[313],
              _at_[302],
              _at_[303],
              _at_[304],
              _at_[352],
              _at_[353],
              _at_[354],
              _at_[288],
              _at_[287],
              _at_[289],
              _at_[241],
              _at_[362],
              _at_[356],
              _at_[357],
              _at_[358],
              _at_[359],
              _at_[360],
              _at_[5],
              _at_[6],
              [0,
               _au_[1],
               _au_[3],
               _au_[2],
               _au_[4],
               _au_[7],
               _au_[5],
               _au_[6],
               _au_[8],
               _au_[9],
               _au_[10]]]}
    function _ai_(_ao_)
     {var _ap_=Wrapped_functions$0(_ao_);
      return [0,
              _ap_[1],
              _ap_[6],
              _ap_[11],
              _ap_[12],
              _ap_[9],
              _ap_[7],
              _ap_[8],
              _ap_[19],
              _ap_[18],
              _ap_[5],
              _ap_[17],
              _ap_[16],
              _ap_[15],
              _ap_[20],
              _ap_[14],
              _ap_[13]]}
    var
     Html_f=
      [0,
       function(_al_,_ak_)
        {var
          _aj_=Wrapped_functions$0(_al_),
          _an_=
           Make_with_wrapped_functions$0
            (_al_,
             [0,
              _aj_[1],
              _aj_[6],
              _aj_[11],
              _aj_[12],
              _aj_[9],
              _aj_[7],
              _aj_[8],
              _aj_[19],
              _aj_[18],
              _aj_[5],
              _aj_[17],
              _aj_[16],
              _aj_[15],
              _aj_[20],
              _aj_[14],
              _aj_[13]],
             _ak_),
          _am_=_an_[363];
         return [0,
                 _an_[1],
                 _an_[2],
                 _an_[3],
                 _an_[4],
                 _an_[19],
                 _an_[21],
                 _an_[20],
                 _an_[22],
                 _an_[23],
                 _an_[24],
                 _an_[27],
                 _an_[28],
                 _an_[29],
                 _an_[30],
                 _an_[31],
                 _an_[32],
                 _an_[33],
                 _an_[34],
                 _an_[35],
                 _an_[36],
                 _an_[37],
                 _an_[38],
                 _an_[39],
                 _an_[40],
                 _an_[41],
                 _an_[42],
                 _an_[43],
                 _an_[44],
                 _an_[77],
                 _an_[45],
                 _an_[46],
                 _an_[47],
                 _an_[48],
                 _an_[49],
                 _an_[50],
                 _an_[51],
                 _an_[52],
                 _an_[53],
                 _an_[54],
                 _an_[55],
                 _an_[56],
                 _an_[57],
                 _an_[58],
                 _an_[59],
                 _an_[60],
                 _an_[61],
                 _an_[62],
                 _an_[63],
                 _an_[64],
                 _an_[65],
                 _an_[66],
                 _an_[67],
                 _an_[68],
                 _an_[69],
                 _an_[70],
                 _an_[71],
                 _an_[72],
                 _an_[73],
                 _an_[74],
                 _an_[75],
                 _an_[76],
                 _an_[78],
                 _an_[79],
                 _an_[80],
                 _an_[81],
                 _an_[82],
                 _an_[83],
                 _an_[84],
                 _an_[85],
                 _an_[86],
                 _an_[87],
                 _an_[88],
                 _an_[89],
                 _an_[90],
                 _an_[91],
                 _an_[92],
                 _an_[93],
                 _an_[94],
                 _an_[95],
                 _an_[96],
                 _an_[97],
                 _an_[98],
                 _an_[99],
                 _an_[138],
                 _an_[139],
                 _an_[141],
                 _an_[142],
                 _an_[143],
                 _an_[144],
                 _an_[145],
                 _an_[146],
                 _an_[147],
                 _an_[148],
                 _an_[149],
                 _an_[150],
                 _an_[151],
                 _an_[152],
                 _an_[153],
                 _an_[154],
                 _an_[155],
                 _an_[156],
                 _an_[157],
                 _an_[158],
                 _an_[159],
                 _an_[160],
                 _an_[161],
                 _an_[162],
                 _an_[163],
                 _an_[164],
                 _an_[165],
                 _an_[166],
                 _an_[167],
                 _an_[168],
                 _an_[169],
                 _an_[170],
                 _an_[171],
                 _an_[172],
                 _an_[173],
                 _an_[174],
                 _an_[175],
                 _an_[176],
                 _an_[177],
                 _an_[178],
                 _an_[179],
                 _an_[180],
                 _an_[181],
                 _an_[140],
                 _an_[182],
                 _an_[183],
                 _an_[184],
                 _an_[185],
                 _an_[186],
                 _an_[187],
                 _an_[188],
                 _an_[189],
                 _an_[190],
                 _an_[191],
                 _an_[192],
                 _an_[193],
                 _an_[194],
                 _an_[195],
                 _an_[196],
                 _an_[100],
                 _an_[101],
                 _an_[102],
                 _an_[103],
                 _an_[104],
                 _an_[105],
                 _an_[106],
                 _an_[107],
                 _an_[108],
                 _an_[109],
                 _an_[110],
                 _an_[111],
                 _an_[112],
                 _an_[113],
                 _an_[114],
                 _an_[292],
                 _an_[128],
                 _an_[132],
                 _an_[203],
                 _an_[131],
                 _an_[119],
                 _an_[120],
                 _an_[121],
                 _an_[122],
                 _an_[135],
                 _an_[136],
                 _an_[129],
                 _an_[130],
                 _an_[202],
                 _an_[137],
                 _an_[204],
                 _an_[123],
                 _an_[197],
                 _an_[117],
                 _an_[198],
                 _an_[124],
                 _an_[125],
                 _an_[126],
                 _an_[127],
                 _an_[133],
                 _an_[134],
                 _an_[201],
                 _an_[200],
                 _an_[199],
                 _an_[297],
                 _an_[206],
                 _an_[207],
                 _an_[208],
                 _an_[209],
                 _an_[210],
                 _an_[211],
                 _an_[205],
                 _an_[212],
                 _an_[213],
                 _an_[214],
                 _an_[115],
                 _an_[116],
                 _an_[118],
                 _an_[293],
                 _an_[294],
                 _an_[295],
                 _an_[215],
                 _an_[216],
                 _an_[217],
                 _an_[218],
                 _an_[219],
                 _an_[220],
                 _an_[221],
                 _an_[222],
                 _an_[223],
                 _an_[296],
                 _an_[224],
                 _an_[25],
                 _an_[26],
                 _an_[225],
                 _an_[226],
                 _an_[240],
                 _an_[235],
                 _an_[233],
                 _an_[355],
                 _an_[234],
                 _an_[232],
                 _an_[319],
                 _an_[236],
                 _an_[237],
                 _an_[238],
                 _an_[239],
                 _an_[247],
                 _an_[248],
                 _an_[249],
                 _an_[250],
                 _an_[251],
                 _an_[252],
                 _an_[253],
                 _an_[254],
                 _an_[305],
                 _an_[306],
                 _an_[307],
                 _an_[257],
                 _an_[258],
                 _an_[255],
                 _an_[256],
                 _an_[273],
                 _an_[274],
                 _an_[275],
                 _an_[276],
                 _an_[277],
                 _an_[278],
                 _an_[334],
                 _an_[335],
                 _an_[279],
                 _an_[280],
                 _an_[281],
                 _an_[282],
                 _an_[283],
                 _an_[284],
                 _an_[285],
                 _an_[286],
                 _an_[290],
                 _an_[291],
                 _an_[259],
                 _an_[260],
                 _an_[261],
                 _an_[262],
                 _an_[263],
                 _an_[264],
                 _an_[265],
                 _an_[266],
                 _an_[267],
                 _an_[268],
                 _an_[269],
                 _an_[270],
                 _an_[271],
                 _an_[272],
                 _an_[300],
                 _an_[301],
                 _an_[350],
                 _an_[351],
                 _an_[347],
                 _an_[348],
                 _an_[349],
                 _an_[314],
                 _an_[309],
                 _an_[310],
                 _an_[311],
                 _an_[315],
                 _an_[298],
                 _an_[299],
                 _an_[336],
                 _an_[338],
                 _an_[337],
                 _an_[342],
                 _an_[343],
                 _an_[344],
                 _an_[345],
                 _an_[346],
                 _an_[339],
                 _an_[340],
                 _an_[341],
                 _an_[318],
                 _an_[332],
                 _an_[329],
                 _an_[322],
                 _an_[320],
                 _an_[326],
                 _an_[324],
                 _an_[327],
                 _an_[333],
                 _an_[323],
                 _an_[325],
                 _an_[321],
                 _an_[328],
                 _an_[316],
                 _an_[317],
                 _an_[242],
                 _an_[243],
                 _an_[244],
                 _an_[245],
                 _an_[246],
                 _an_[330],
                 _an_[331],
                 _an_[312],
                 _an_[313],
                 _an_[302],
                 _an_[303],
                 _an_[304],
                 _an_[352],
                 _an_[353],
                 _an_[354],
                 _an_[288],
                 _an_[287],
                 _an_[289],
                 _an_[241],
                 _an_[362],
                 _an_[356],
                 _an_[357],
                 _an_[358],
                 _an_[359],
                 _an_[360],
                 _an_[5],
                 _an_[6],
                 [0,
                  _am_[1],
                  _am_[3],
                  _am_[2],
                  _am_[4],
                  _am_[7],
                  _am_[5],
                  _am_[6],
                  _am_[8],
                  _am_[9],
                  _am_[10]]]},
       _ai_,
       _ah_];
    caml_register_global(1102,Html_f,"Html_f");
    return}
  (function(){return this}()));


//# 1 "../.js/tyxml/tyxml.cma.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_register_global=runtime.caml_register_global,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    var
     global_data=runtime.caml_get_global_data(),
     cst$0=caml_string_of_jsbytes(""),
     cst=caml_string_of_jsbytes("]]>"),
     cst$1=caml_string_of_jsbytes("]]>"),
     cst_CDATA=caml_string_of_jsbytes("<![CDATA["),
     cst$2=caml_string_of_jsbytes("//]]>"),
     cst_CDATA$0=caml_string_of_jsbytes("//<![CDATA["),
     cst$3=caml_string_of_jsbytes("/* ]]> */"),
     cst_CDATA$1=caml_string_of_jsbytes("/* <![CDATA[ */"),
     Stdlib_format=global_data.Stdlib__format,
     Re=global_data.Re,
     Stdlib_printf=global_data.Stdlib__printf,
     Xml_wrap=global_data.Xml_wrap,
     Xml_print=global_data.Xml_print,
     Xml_iter=global_data.Xml_iter,
     Xml_stream=global_data.Xml_stream,
     Svg_f=global_data.Svg_f,
     Html_f=global_data.Html_f,
     _b_=[0,1],
     _c_=
      [0,
       [12,10,[2,0,[12,10,[2,0,[12,10,[2,0,[12,10,0]]]]]]],
       caml_string_of_jsbytes("\n%s\n%s\n%s\n")];
    function uri_of_string(s){return s}
    function string_of_uri(s){return s}
    function acontent(param){var a=param[2];return a}
    function aname(param){var name=param[1];return name}
    function float_attrib(name,value){return [0,name,[0,value]]}
    function int_attrib(name,value){return [0,name,[1,value]]}
    function string_attrib(name,value){return [0,name,[2,value]]}
    function space_sep_attrib(name,values){return [0,name,[3,0,values]]}
    function comma_sep_attrib(name,values){return [0,name,[3,1,values]]}
    function event_handler_attrib(name,value){return [0,name,[2,value]]}
    function mouse_event_handler_attrib(name,value){return [0,name,[2,value]]}
    function keyboard_event_handler_attrib(name,value)
     {return [0,name,[2,value]]}
    function touch_event_handler_attrib(name,value){return [0,name,[2,value]]}
    function uri_attrib(name,value){return [0,name,[2,value]]}
    function uris_attrib(name,values){return [0,name,[3,0,values]]}
    function content(elt){return elt}
    function empty(param){return 0}
    function comment(c){return [0,c]}
    function pcdata(d){return [2,d]}
    function encodedpcdata(d){return [1,d]}
    function entity(e){return [3,e]}
    var _a_=caml_call1(Re[23],cst),re_end_cdata=caml_call1(Re[2],_a_);
    function encoded_cdata(s1,s2,s)
     {var _j7_=caml_call6(Re[22],0,0,_b_,re_end_cdata,cst$0,s);
      return [1,caml_call4(Stdlib_printf[4],_c_,s1,_j7_,s2)]}
    function cdata(_j6_){return encoded_cdata(cst_CDATA,cst$1,_j6_)}
    function cdata_script(_j5_){return encoded_cdata(cst_CDATA$0,cst$2,_j5_)}
    function cdata_style(_j4_){return encoded_cdata(cst_CDATA$1,cst$3,_j4_)}
    function leaf(opt,name)
     {if(opt)var sth=opt[1],a=sth;else var a=0;return [4,name,a]}
    function node(opt,name,children)
     {if(opt)var sth=opt[1],a=sth;else var a=0;return [5,name,a,children]}
    var
     print_list=
      caml_call1
        (caml_call1
          (Xml_print[12],
           [0,
            Xml_wrap[1],
            string_of_uri,
            uri_of_string,
            float_attrib,
            int_attrib,
            string_attrib,
            space_sep_attrib,
            comma_sep_attrib,
            event_handler_attrib,
            mouse_event_handler_attrib,
            keyboard_event_handler_attrib,
            touch_event_handler_attrib,
            uri_attrib,
            uris_attrib,
            empty,
            comment,
            pcdata,
            encodedpcdata,
            entity,
            leaf,
            node,
            cdata,
            cdata_script,
            cdata_style,
            aname,
            acontent,
            content]),
         [0,0])
       [1],
     include=
      caml_call1
       (Xml_iter[1],
        [0,
         Xml_wrap[1],
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style,
         aname,
         acontent,
         content]),
     amap=include[1],
     amap1=include[2],
     rm_attrib=include[3],
     rm_attrib_from_list=include[4],
     map_int_attrib=include[5],
     map_string_attrib=include[7],
     map_string_attrib_in_list=include[8],
     add_int_attrib=include[9],
     add_string_attrib=include[11],
     add_comma_sep_attrib=include[12],
     add_space_sep_attrib=include[13],
     fold=include[14],
     all_entities=include[15],
     translate=include[16],
     pp=
      caml_call1
        (caml_call1
          (Xml_print[9],
           [0,
            Xml_wrap[1],
            string_of_uri,
            uri_of_string,
            float_attrib,
            int_attrib,
            string_attrib,
            space_sep_attrib,
            comma_sep_attrib,
            event_handler_attrib,
            mouse_event_handler_attrib,
            keyboard_event_handler_attrib,
            touch_event_handler_attrib,
            uri_attrib,
            uris_attrib,
            empty,
            comment,
            pcdata,
            encodedpcdata,
            entity,
            leaf,
            node,
            cdata,
            cdata_script,
            cdata_style,
            aname,
            acontent,
            content]),
         [0,0])
       [1],
     include$0=
      caml_call1
       (Xml_stream[2],
        [0,
         Xml_wrap[1],
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style]),
     of_seq=include$0[1];
    function print(fmt,x)
     {return caml_call3
              (print_list,caml_call1(Stdlib_format[13],fmt),0,[0,x,0])}
    var
     _d_=Xml_wrap[1],
     Tyxml_xml=
      [0,
       _d_,
       string_of_uri,
       uri_of_string,
       float_attrib,
       int_attrib,
       string_attrib,
       space_sep_attrib,
       comma_sep_attrib,
       event_handler_attrib,
       mouse_event_handler_attrib,
       keyboard_event_handler_attrib,
       touch_event_handler_attrib,
       uri_attrib,
       uris_attrib,
       empty,
       comment,
       pcdata,
       encodedpcdata,
       entity,
       leaf,
       node,
       cdata,
       cdata_script,
       cdata_style,
       aname,
       acontent,
       content,
       pp,
       of_seq,
       amap,
       amap1,
       rm_attrib,
       rm_attrib_from_list,
       map_int_attrib,
       map_string_attrib,
       map_string_attrib_in_list,
       add_int_attrib,
       add_string_attrib,
       add_comma_sep_attrib,
       add_space_sep_attrib,
       fold,
       all_entities,
       translate,
       print_list,
       print];
    caml_register_global(17,Tyxml_xml,"Tyxml_xml");
    var
     M=
      caml_call1
       (Svg_f[1],
        [0,
         _d_,
         string_of_uri,
         uri_of_string,
         float_attrib,
         int_attrib,
         string_attrib,
         space_sep_attrib,
         comma_sep_attrib,
         event_handler_attrib,
         mouse_event_handler_attrib,
         keyboard_event_handler_attrib,
         touch_event_handler_attrib,
         uri_attrib,
         uris_attrib,
         empty,
         comment,
         pcdata,
         encodedpcdata,
         entity,
         leaf,
         node,
         cdata,
         cdata_script,
         cdata_style]),
     _e_=[0,M[2],M[325],M[327]],
     include$1=
      caml_call1
       (caml_call1
         (Xml_print[8],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _e_),
     _f_=[0,M[2],M[325],M[327]],
     Make_printer=
      caml_call1
       (caml_call1
         (Xml_print[11],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _f_),
     _h_=M[2],
     _i_=M[3],
     _j_=M[4],
     _k_=M[5],
     _l_=M[6],
     _m_=M[7],
     _n_=M[8],
     _o_=M[9],
     _p_=M[10],
     _q_=M[11],
     _r_=M[12],
     _s_=M[13],
     _t_=M[14],
     _u_=M[15],
     _v_=M[16],
     _w_=M[17],
     _x_=M[18],
     _y_=M[19],
     _z_=M[20],
     _A_=M[21],
     _B_=M[22],
     _C_=M[23],
     _D_=M[24],
     _E_=M[25],
     _F_=M[26],
     _G_=M[27],
     _H_=M[28],
     _I_=M[29],
     _J_=M[30],
     _K_=M[31],
     _L_=M[32],
     _M_=M[33],
     _N_=M[34],
     _O_=M[35],
     _P_=M[36],
     _Q_=M[37],
     _R_=M[38],
     _S_=M[39],
     _T_=M[40],
     _U_=M[41],
     _V_=M[42],
     _W_=M[43],
     _X_=M[44],
     _Y_=M[45],
     _Z_=M[46],
     ___=M[47],
     _$_=M[48],
     _aa_=M[49],
     _ab_=M[50],
     _ac_=M[51],
     _ad_=M[52],
     _ae_=M[53],
     _af_=M[54],
     _ag_=M[55],
     _ah_=M[56],
     _ai_=M[57],
     _aj_=M[58],
     _ak_=M[59],
     _al_=M[60],
     _am_=M[61],
     _an_=M[62],
     _ao_=M[63],
     _ap_=M[64],
     _aq_=M[65],
     _ar_=M[66],
     _as_=M[67],
     _at_=M[68],
     _au_=M[69],
     _av_=M[70],
     _aw_=M[71],
     _ax_=M[72],
     _ay_=M[73],
     _az_=M[74],
     _aA_=M[75],
     _aB_=M[76],
     _aC_=M[77],
     _aD_=M[78],
     _aE_=M[79],
     _aF_=M[80],
     _aG_=M[81],
     _aH_=M[82],
     _aI_=M[83],
     _aJ_=M[84],
     _aK_=M[85],
     _aL_=M[86],
     _aM_=M[87],
     _aN_=M[88],
     _aO_=M[89],
     _aP_=M[90],
     _aQ_=M[91],
     _aR_=M[92],
     _aS_=M[93],
     _aT_=M[94],
     _aU_=M[95],
     _aV_=M[96],
     _aW_=M[97],
     _aX_=M[98],
     _aY_=M[99],
     _aZ_=M[100],
     _a0_=M[101],
     _a1_=M[102],
     _a2_=M[103],
     _a3_=M[104],
     _a4_=M[105],
     _a5_=M[106],
     _a6_=M[107],
     _a7_=M[108],
     _a8_=M[109],
     _a9_=M[110],
     _a__=M[111],
     _a$_=M[112],
     _ba_=M[113],
     _bb_=M[114],
     _bc_=M[115],
     _bd_=M[116],
     _be_=M[117],
     _bf_=M[118],
     _bg_=M[119],
     _bh_=M[120],
     _bi_=M[121],
     _bj_=M[122],
     _bk_=M[123],
     _bl_=M[124],
     _bm_=M[125],
     _bn_=M[126],
     _bo_=M[127],
     _bp_=M[128],
     _bq_=M[129],
     _br_=M[130],
     _bs_=M[131],
     _bt_=M[132],
     _bu_=M[133],
     _bv_=M[134],
     _bw_=M[135],
     _bx_=M[136],
     _by_=M[137],
     _bz_=M[138],
     _bA_=M[139],
     _bB_=M[140],
     _bC_=M[141],
     _bD_=M[142],
     _bE_=M[143],
     _bF_=M[144],
     _bG_=M[145],
     _bH_=M[146],
     _bI_=M[147],
     _bJ_=M[148],
     _bK_=M[149],
     _bL_=M[150],
     _bM_=M[151],
     _bN_=M[152],
     _bO_=M[153],
     _bP_=M[154],
     _bQ_=M[155],
     _bR_=M[156],
     _bS_=M[157],
     _bT_=M[158],
     _bU_=M[159],
     _bV_=M[160],
     _bW_=M[161],
     _bX_=M[162],
     _bY_=M[163],
     _bZ_=M[164],
     _b0_=M[165],
     _b1_=M[166],
     _b2_=M[167],
     _b3_=M[168],
     _b4_=M[169],
     _b5_=M[170],
     _b6_=M[171],
     _b7_=M[172],
     _b8_=M[173],
     _b9_=M[174],
     _b__=M[175],
     _b$_=M[176],
     _ca_=M[177],
     _cb_=M[178],
     _cc_=M[179],
     _cd_=M[180],
     _ce_=M[181],
     _cf_=M[182],
     _cg_=M[183],
     _ch_=M[184],
     _ci_=M[185],
     _cj_=M[186],
     _ck_=M[187],
     _cl_=M[188],
     _cm_=M[189],
     _cn_=M[190],
     _co_=M[191],
     _cp_=M[192],
     _cq_=M[193],
     _cr_=M[194],
     _cs_=M[195],
     _ct_=M[196],
     _cu_=M[197],
     _cv_=M[198],
     _cw_=M[199],
     _cx_=M[200],
     _cy_=M[201],
     _cz_=M[202],
     _cA_=M[203],
     _cB_=M[204],
     _cC_=M[205],
     _cD_=M[206],
     _cE_=M[207],
     _cF_=M[208],
     _cG_=M[209],
     _cH_=M[210],
     _cI_=M[211],
     _cJ_=M[212],
     _cK_=M[213],
     _cL_=M[214],
     _cM_=M[215],
     _cN_=M[216],
     _cO_=M[217],
     _cP_=M[218],
     _cQ_=M[219],
     _cR_=M[220],
     _cS_=M[221],
     _cT_=M[222],
     _cU_=M[223],
     _cV_=M[224],
     _cW_=M[225],
     _cX_=M[226],
     _cY_=M[227],
     _cZ_=M[228],
     _c0_=M[229],
     _c1_=M[230],
     _c2_=M[231],
     _c3_=M[232],
     _c4_=M[233],
     _c5_=M[234],
     _c6_=M[235],
     _c7_=M[236],
     _c8_=M[237],
     _c9_=M[238],
     _c__=M[239],
     _c$_=M[240],
     _da_=M[241],
     _db_=M[242],
     _dc_=M[243],
     _dd_=M[244],
     _de_=M[245],
     _df_=M[246],
     _dg_=M[247],
     _dh_=M[248],
     _di_=M[249],
     _dj_=M[250],
     _dk_=M[251],
     _dl_=M[252],
     _dm_=M[253],
     _dn_=M[254],
     _do_=M[255],
     _dp_=M[256],
     _dq_=M[257],
     _dr_=M[258],
     _ds_=M[259],
     _dt_=M[260],
     _du_=M[261],
     _dv_=M[262],
     _dw_=M[263],
     _dx_=M[264],
     _dy_=M[265],
     _dz_=M[266],
     _dA_=M[267],
     _dB_=M[268],
     _dC_=M[269],
     _dD_=M[270],
     _dE_=M[271],
     _dF_=M[272],
     _dG_=M[273],
     _dH_=M[274],
     _dI_=M[275],
     _dJ_=M[276],
     _dK_=M[277],
     _dL_=M[278],
     _dM_=M[279],
     _dN_=M[280],
     _dO_=M[281],
     _dP_=M[282],
     _dQ_=M[283],
     _dR_=M[284],
     _dS_=M[285],
     _dT_=M[286],
     _dU_=M[287],
     _dV_=M[288],
     _dW_=M[289],
     _dX_=M[290],
     _dY_=M[291],
     _dZ_=M[292],
     _d0_=M[293],
     _d1_=M[294],
     _d2_=M[295],
     _d3_=M[296],
     _d4_=M[297],
     _d5_=M[298],
     _d6_=M[299],
     _d7_=M[300],
     _d8_=M[301],
     _d9_=M[302],
     _d__=M[303],
     _d$_=M[304],
     _ea_=M[305],
     _eb_=M[306],
     _ec_=M[307],
     _ed_=M[308],
     _ee_=M[309],
     _ef_=M[310],
     _eg_=M[311],
     _eh_=M[312],
     _ei_=M[313],
     _ej_=M[314],
     _ek_=M[315],
     _el_=M[316],
     _em_=M[317],
     _en_=M[318],
     _eo_=M[319],
     _ep_=M[320],
     _eq_=M[321],
     _er_=M[322],
     _es_=M[323],
     _et_=M[324],
     _eu_=M[325],
     _ev_=M[326],
     _ew_=M[327],
     _ex_=M[328],
     _ey_=M[329],
     _ez_=M[330],
     _eA_=include$1[1],
     _eB_=include$1[2],
     _g_=M[1],
     pp$0=caml_call4(_eB_,0,0,0,0),
     pp_elt=caml_call3(_eA_,0,0,0),
     Tyxml_svg=
      [0,
       _g_,
       _h_,
       _i_,
       _j_,
       _k_,
       _l_,
       _m_,
       _n_,
       _o_,
       _p_,
       _q_,
       _r_,
       _s_,
       _t_,
       _u_,
       _v_,
       _w_,
       _x_,
       _y_,
       _z_,
       _A_,
       _B_,
       _C_,
       _D_,
       _E_,
       _F_,
       _G_,
       _H_,
       _I_,
       _J_,
       _K_,
       _L_,
       _M_,
       _N_,
       _O_,
       _P_,
       _Q_,
       _R_,
       _S_,
       _T_,
       _U_,
       _V_,
       _W_,
       _X_,
       _Y_,
       _Z_,
       ___,
       _$_,
       _aa_,
       _ab_,
       _ac_,
       _ad_,
       _ae_,
       _af_,
       _ag_,
       _ah_,
       _ai_,
       _aj_,
       _ak_,
       _al_,
       _am_,
       _an_,
       _ao_,
       _ap_,
       _aq_,
       _ar_,
       _as_,
       _at_,
       _au_,
       _av_,
       _aw_,
       _ax_,
       _ay_,
       _az_,
       _aA_,
       _aB_,
       _aC_,
       _aD_,
       _aE_,
       _aF_,
       _aG_,
       _aH_,
       _aI_,
       _aJ_,
       _aK_,
       _aL_,
       _aM_,
       _aN_,
       _aO_,
       _aP_,
       _aQ_,
       _aR_,
       _aS_,
       _aT_,
       _aU_,
       _aV_,
       _aW_,
       _aX_,
       _aY_,
       _aZ_,
       _a0_,
       _a1_,
       _a2_,
       _a3_,
       _a4_,
       _a5_,
       _a6_,
       _a7_,
       _a8_,
       _a9_,
       _a__,
       _a$_,
       _ba_,
       _bb_,
       _bc_,
       _bd_,
       _be_,
       _bf_,
       _bg_,
       _bh_,
       _bi_,
       _bj_,
       _bk_,
       _bl_,
       _bm_,
       _bn_,
       _bo_,
       _bp_,
       _bq_,
       _br_,
       _bs_,
       _bt_,
       _bu_,
       _bv_,
       _bw_,
       _bx_,
       _by_,
       _bz_,
       _bA_,
       _bB_,
       _bC_,
       _bD_,
       _bE_,
       _bF_,
       _bG_,
       _bH_,
       _bI_,
       _bJ_,
       _bK_,
       _bL_,
       _bM_,
       _bN_,
       _bO_,
       _bP_,
       _bQ_,
       _bR_,
       _bS_,
       _bT_,
       _bU_,
       _bV_,
       _bW_,
       _bX_,
       _bY_,
       _bZ_,
       _b0_,
       _b1_,
       _b2_,
       _b3_,
       _b4_,
       _b5_,
       _b6_,
       _b7_,
       _b8_,
       _b9_,
       _b__,
       _b$_,
       _ca_,
       _cb_,
       _cc_,
       _cd_,
       _ce_,
       _cf_,
       _cg_,
       _ch_,
       _ci_,
       _cj_,
       _ck_,
       _cl_,
       _cm_,
       _cn_,
       _co_,
       _cp_,
       _cq_,
       _cr_,
       _cs_,
       _ct_,
       _cu_,
       _cv_,
       _cw_,
       _cx_,
       _cy_,
       _cz_,
       _cA_,
       _cB_,
       _cC_,
       _cD_,
       _cE_,
       _cF_,
       _cG_,
       _cH_,
       _cI_,
       _cJ_,
       _cK_,
       _cL_,
       _cM_,
       _cN_,
       _cO_,
       _cP_,
       _cQ_,
       _cR_,
       _cS_,
       _cT_,
       _cU_,
       _cV_,
       _cW_,
       _cX_,
       _cY_,
       _cZ_,
       _c0_,
       _c1_,
       _c2_,
       _c3_,
       _c4_,
       _c5_,
       _c6_,
       _c7_,
       _c8_,
       _c9_,
       _c__,
       _c$_,
       _da_,
       _db_,
       _dc_,
       _dd_,
       _de_,
       _df_,
       _dg_,
       _dh_,
       _di_,
       _dj_,
       _dk_,
       _dl_,
       _dm_,
       _dn_,
       _do_,
       _dp_,
       _dq_,
       _dr_,
       _ds_,
       _dt_,
       _du_,
       _dv_,
       _dw_,
       _dx_,
       _dy_,
       _dz_,
       _dA_,
       _dB_,
       _dC_,
       _dD_,
       _dE_,
       _dF_,
       _dG_,
       _dH_,
       _dI_,
       _dJ_,
       _dK_,
       _dL_,
       _dM_,
       _dN_,
       _dO_,
       _dP_,
       _dQ_,
       _dR_,
       _dS_,
       _dT_,
       _dU_,
       _dV_,
       _dW_,
       _dX_,
       _dY_,
       _dZ_,
       _d0_,
       _d1_,
       _d2_,
       _d3_,
       _d4_,
       _d5_,
       _d6_,
       _d7_,
       _d8_,
       _d9_,
       _d__,
       _d$_,
       _ea_,
       _eb_,
       _ec_,
       _ed_,
       _ee_,
       _ef_,
       _eg_,
       _eh_,
       _ei_,
       _ej_,
       _ek_,
       _el_,
       _em_,
       _en_,
       _eo_,
       _ep_,
       _eq_,
       _er_,
       _es_,
       _et_,
       _eu_,
       _ev_,
       _ew_,
       _ex_,
       _ey_,
       _ez_,
       _eB_,
       _eA_,
       Make_printer,
       pp$0,
       pp_elt];
    caml_register_global(19,Tyxml_svg,"Tyxml_svg");
    var
     M$0=
      caml_call1
       (caml_call1
         (Html_f[1],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style]),
        [0,
         _h_,
         _i_,
         _j_,
         _k_,
         _l_,
         _m_,
         _n_,
         _o_,
         _p_,
         _q_,
         _r_,
         _s_,
         _t_,
         _u_,
         _v_,
         _w_,
         _x_,
         _y_,
         _z_,
         _A_,
         _B_,
         _C_,
         _D_,
         _E_,
         _F_,
         _G_,
         _H_,
         _I_,
         _J_,
         _K_,
         _L_,
         _M_,
         _N_,
         _O_,
         _P_,
         _Q_,
         _R_,
         _S_,
         _T_,
         _U_,
         _V_,
         _W_,
         _X_,
         _Y_,
         _Z_,
         ___,
         _$_,
         _aa_,
         _ab_,
         _ac_,
         _ad_,
         _ae_,
         _af_,
         _ag_,
         _ah_,
         _ai_,
         _aj_,
         _ak_,
         _al_,
         _am_,
         _an_,
         _ao_,
         _ap_,
         _aq_,
         _ar_,
         _as_,
         _at_,
         _au_,
         _av_,
         _aw_,
         _ax_,
         _ay_,
         _az_,
         _aA_,
         _aB_,
         _aC_,
         _aD_,
         _aE_,
         _aF_,
         _aG_,
         _aH_,
         _aI_,
         _aJ_,
         _aK_,
         _aL_,
         _aM_,
         _aN_,
         _aO_,
         _aP_,
         _aQ_,
         _aR_,
         _aS_,
         _aT_,
         _aU_,
         _aV_,
         _aW_,
         _aX_,
         _aY_,
         _aZ_,
         _a0_,
         _a1_,
         _a2_,
         _a3_,
         _a4_,
         _a5_,
         _a6_,
         _a7_,
         _a8_,
         _a9_,
         _a__,
         _a$_,
         _ba_,
         _bb_,
         _bc_,
         _bd_,
         _be_,
         _bf_,
         _bg_,
         _bh_,
         _bi_,
         _bj_,
         _bk_,
         _bl_,
         _bm_,
         _bn_,
         _bo_,
         _bp_,
         _bq_,
         _br_,
         _bs_,
         _bt_,
         _bu_,
         _bv_,
         _bw_,
         _bx_,
         _by_,
         _bz_,
         _bA_,
         _bB_,
         _bC_,
         _bD_,
         _bE_,
         _bF_,
         _bG_,
         _bH_,
         _bI_,
         _bJ_,
         _bK_,
         _bL_,
         _bM_,
         _bN_,
         _bO_,
         _bP_,
         _bQ_,
         _bR_,
         _bS_,
         _bT_,
         _bU_,
         _bV_,
         _bW_,
         _bX_,
         _bY_,
         _bZ_,
         _b0_,
         _b1_,
         _b2_,
         _b3_,
         _b4_,
         _b5_,
         _b6_,
         _b7_,
         _b8_,
         _b9_,
         _b__,
         _b$_,
         _ca_,
         _cb_,
         _cc_,
         _cd_,
         _ce_,
         _cf_,
         _cg_,
         _ch_,
         _ci_,
         _cj_,
         _ck_,
         _cl_,
         _cm_,
         _cn_,
         _co_,
         _cp_,
         _cq_,
         _cr_,
         _cs_,
         _ct_,
         _cu_,
         _cv_,
         _cw_,
         _cx_,
         _cy_,
         _cz_,
         _cA_,
         _cB_,
         _cC_,
         _cD_,
         _cE_,
         _cF_,
         _cG_,
         _cH_,
         _cI_,
         _cJ_,
         _cK_,
         _cL_,
         _cM_,
         _cN_,
         _cO_,
         _cP_,
         _cQ_,
         _cR_,
         _cS_,
         _cT_,
         _cU_,
         _cV_,
         _cW_,
         _cX_,
         _cY_,
         _cZ_,
         _c0_,
         _c1_,
         _c2_,
         _c3_,
         _c4_,
         _c5_,
         _c6_,
         _c7_,
         _c8_,
         _c9_,
         _c__,
         _c$_,
         _da_,
         _db_,
         _dc_,
         _dd_,
         _de_,
         _df_,
         _dg_,
         _dh_,
         _di_,
         _dj_,
         _dk_,
         _dl_,
         _dm_,
         _dn_,
         _do_,
         _dp_,
         _dq_,
         _dr_,
         _ds_,
         _dt_,
         _du_,
         _dv_,
         _dw_,
         _dx_,
         _dy_,
         _dz_,
         _dA_,
         _dB_,
         _dC_,
         _dD_,
         _dE_,
         _dF_,
         _dG_,
         _dH_,
         _dI_,
         _dJ_,
         _dK_,
         _dL_,
         _dM_,
         _dN_,
         _dO_,
         _dP_,
         _dQ_,
         _dR_,
         _dS_,
         _dT_,
         _dU_,
         _dV_,
         _dW_,
         _dX_,
         _dY_,
         _dZ_,
         _d0_,
         _d1_,
         _d2_,
         _d3_,
         _d4_,
         _d5_,
         _d6_,
         _d7_,
         _d8_,
         _d9_,
         _d__,
         _d$_,
         _ea_,
         _eb_,
         _ec_,
         _ed_,
         _ee_,
         _ef_,
         _eg_,
         _eh_,
         _ei_,
         _ej_,
         _ek_,
         _el_,
         _em_,
         _en_,
         _eo_,
         _ep_,
         _eq_,
         _er_,
         _es_,
         _et_,
         _eu_,
         _ev_,
         _ew_,
         _ex_,
         _ey_,
         _ez_]),
     _eC_=[0,M$0[2],M$0[339],M$0[341]],
     include$2=
      caml_call1
       (caml_call1
         (Xml_print[8],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _eC_),
     _eD_=[0,M$0[2],M$0[339],M$0[341]],
     Make_printer$0=
      caml_call1
       (caml_call1
         (Xml_print[11],
          [0,
           _d_,
           string_of_uri,
           uri_of_string,
           float_attrib,
           int_attrib,
           string_attrib,
           space_sep_attrib,
           comma_sep_attrib,
           event_handler_attrib,
           mouse_event_handler_attrib,
           keyboard_event_handler_attrib,
           touch_event_handler_attrib,
           uri_attrib,
           uris_attrib,
           empty,
           comment,
           pcdata,
           encodedpcdata,
           entity,
           leaf,
           node,
           cdata,
           cdata_script,
           cdata_style,
           aname,
           acontent,
           content]),
        _eD_),
     _j2_=include$2[1],
     _j3_=include$2[2],
     _eE_=M$0[1],
     _eF_=M$0[2],
     _eG_=M$0[3],
     _eH_=M$0[4],
     _eI_=M$0[5],
     _eJ_=M$0[6],
     _eK_=M$0[7],
     _eL_=M$0[8],
     _eM_=M$0[9],
     _eN_=M$0[10],
     _eO_=M$0[11],
     _eP_=M$0[12],
     _eQ_=M$0[13],
     _eR_=M$0[14],
     _eS_=M$0[15],
     _eT_=M$0[16],
     _eU_=M$0[17],
     _eV_=M$0[18],
     _eW_=M$0[19],
     _eX_=M$0[20],
     _eY_=M$0[21],
     _eZ_=M$0[22],
     _e0_=M$0[23],
     _e1_=M$0[24],
     _e2_=M$0[25],
     _e3_=M$0[26],
     _e4_=M$0[27],
     _e5_=M$0[28],
     _e6_=M$0[29],
     _e7_=M$0[30],
     _e8_=M$0[31],
     _e9_=M$0[32],
     _e__=M$0[33],
     _e$_=M$0[34],
     _fa_=M$0[35],
     _fb_=M$0[36],
     _fc_=M$0[37],
     _fd_=M$0[38],
     _fe_=M$0[39],
     _ff_=M$0[40],
     _fg_=M$0[41],
     _fh_=M$0[42],
     _fi_=M$0[43],
     _fj_=M$0[44],
     _fk_=M$0[45],
     _fl_=M$0[46],
     _fm_=M$0[47],
     _fn_=M$0[48],
     _fo_=M$0[49],
     _fp_=M$0[50],
     _fq_=M$0[51],
     _fr_=M$0[52],
     _fs_=M$0[53],
     _ft_=M$0[54],
     _fu_=M$0[55],
     _fv_=M$0[56],
     _fw_=M$0[57],
     _fx_=M$0[58],
     _fy_=M$0[59],
     _fz_=M$0[60],
     _fA_=M$0[61],
     _fB_=M$0[62],
     _fC_=M$0[63],
     _fD_=M$0[64],
     _fE_=M$0[65],
     _fF_=M$0[66],
     _fG_=M$0[67],
     _fH_=M$0[68],
     _fI_=M$0[69],
     _fJ_=M$0[70],
     _fK_=M$0[71],
     _fL_=M$0[72],
     _fM_=M$0[73],
     _fN_=M$0[74],
     _fO_=M$0[75],
     _fP_=M$0[76],
     _fQ_=M$0[77],
     _fR_=M$0[78],
     _fS_=M$0[79],
     _fT_=M$0[80],
     _fU_=M$0[81],
     _fV_=M$0[82],
     _fW_=M$0[83],
     _fX_=M$0[84],
     _fY_=M$0[85],
     _fZ_=M$0[86],
     _f0_=M$0[87],
     _f1_=M$0[88],
     _f2_=M$0[89],
     _f3_=M$0[90],
     _f4_=M$0[91],
     _f5_=M$0[92],
     _f6_=M$0[93],
     _f7_=M$0[94],
     _f8_=M$0[95],
     _f9_=M$0[96],
     _f__=M$0[97],
     _f$_=M$0[98],
     _ga_=M$0[99],
     _gb_=M$0[100],
     _gc_=M$0[101],
     _gd_=M$0[102],
     _ge_=M$0[103],
     _gf_=M$0[104],
     _gg_=M$0[105],
     _gh_=M$0[106],
     _gi_=M$0[107],
     _gj_=M$0[108],
     _gk_=M$0[109],
     _gl_=M$0[110],
     _gm_=M$0[111],
     _gn_=M$0[112],
     _go_=M$0[113],
     _gp_=M$0[114],
     _gq_=M$0[115],
     _gr_=M$0[116],
     _gs_=M$0[117],
     _gt_=M$0[118],
     _gu_=M$0[119],
     _gv_=M$0[120],
     _gw_=M$0[121],
     _gx_=M$0[122],
     _gy_=M$0[123],
     _gz_=M$0[124],
     _gA_=M$0[125],
     _gB_=M$0[126],
     _gC_=M$0[127],
     _gD_=M$0[128],
     _gE_=M$0[129],
     _gF_=M$0[130],
     _gG_=M$0[131],
     _gH_=M$0[132],
     _gI_=M$0[133],
     _gJ_=M$0[134],
     _gK_=M$0[135],
     _gL_=M$0[136],
     _gM_=M$0[137],
     _gN_=M$0[138],
     _gO_=M$0[139],
     _gP_=M$0[140],
     _gQ_=M$0[141],
     _gR_=M$0[142],
     _gS_=M$0[143],
     _gT_=M$0[144],
     _gU_=M$0[145],
     _gV_=M$0[146],
     _gW_=M$0[147],
     _gX_=M$0[148],
     _gY_=M$0[149],
     _gZ_=M$0[150],
     _g0_=M$0[151],
     _g1_=M$0[152],
     _g2_=M$0[153],
     _g3_=M$0[154],
     _g4_=M$0[155],
     _g5_=M$0[156],
     _g6_=M$0[157],
     _g7_=M$0[158],
     _g8_=M$0[159],
     _g9_=M$0[160],
     _g__=M$0[161],
     _g$_=M$0[162],
     _ha_=M$0[163],
     _hb_=M$0[164],
     _hc_=M$0[165],
     _hd_=M$0[166],
     _he_=M$0[167],
     _hf_=M$0[168],
     _hg_=M$0[169],
     _hh_=M$0[170],
     _hi_=M$0[171],
     _hj_=M$0[172],
     _hk_=M$0[173],
     _hl_=M$0[174],
     _hm_=M$0[175],
     _hn_=M$0[176],
     _ho_=M$0[177],
     _hp_=M$0[178],
     _hq_=M$0[179],
     _hr_=M$0[180],
     _hs_=M$0[181],
     _ht_=M$0[182],
     _hu_=M$0[183],
     _hv_=M$0[184],
     _hw_=M$0[185],
     _hx_=M$0[186],
     _hy_=M$0[187],
     _hz_=M$0[188],
     _hA_=M$0[189],
     _hB_=M$0[190],
     _hC_=M$0[191],
     _hD_=M$0[192],
     _hE_=M$0[193],
     _hF_=M$0[194],
     _hG_=M$0[195],
     _hH_=M$0[196],
     _hI_=M$0[197],
     _hJ_=M$0[198],
     _hK_=M$0[199],
     _hL_=M$0[200],
     _hM_=M$0[201],
     _hN_=M$0[202],
     _hO_=M$0[203],
     _hP_=M$0[204],
     _hQ_=M$0[205],
     _hR_=M$0[206],
     _hS_=M$0[207],
     _hT_=M$0[208],
     _hU_=M$0[209],
     _hV_=M$0[210],
     _hW_=M$0[211],
     _hX_=M$0[212],
     _hY_=M$0[213],
     _hZ_=M$0[214],
     _h0_=M$0[215],
     _h1_=M$0[216],
     _h2_=M$0[217],
     _h3_=M$0[218],
     _h4_=M$0[219],
     _h5_=M$0[220],
     _h6_=M$0[221],
     _h7_=M$0[222],
     _h8_=M$0[223],
     _h9_=M$0[224],
     _h__=M$0[225],
     _h$_=M$0[226],
     _ia_=M$0[227],
     _ib_=M$0[228],
     _ic_=M$0[229],
     _id_=M$0[230],
     _ie_=M$0[231],
     _if_=M$0[232],
     _ig_=M$0[233],
     _ih_=M$0[234],
     _ii_=M$0[235],
     _ij_=M$0[236],
     _ik_=M$0[237],
     _il_=M$0[238],
     _im_=M$0[239],
     _in_=M$0[240],
     _io_=M$0[241],
     _ip_=M$0[242],
     _iq_=M$0[243],
     _ir_=M$0[244],
     _is_=M$0[245],
     _it_=M$0[246],
     _iu_=M$0[247],
     _iv_=M$0[248],
     _iw_=M$0[249],
     _ix_=M$0[250],
     _iy_=M$0[251],
     _iz_=M$0[252],
     _iA_=M$0[253],
     _iB_=M$0[254],
     _iC_=M$0[255],
     _iD_=M$0[256],
     _iE_=M$0[257],
     _iF_=M$0[258],
     _iG_=M$0[259],
     _iH_=M$0[260],
     _iI_=M$0[261],
     _iJ_=M$0[262],
     _iK_=M$0[263],
     _iL_=M$0[264],
     _iM_=M$0[265],
     _iN_=M$0[266],
     _iO_=M$0[267],
     _iP_=M$0[268],
     _iQ_=M$0[269],
     _iR_=M$0[270],
     _iS_=M$0[271],
     _iT_=M$0[272],
     _iU_=M$0[273],
     _iV_=M$0[274],
     _iW_=M$0[275],
     _iX_=M$0[276],
     _iY_=M$0[277],
     _iZ_=M$0[278],
     _i0_=M$0[279],
     _i1_=M$0[280],
     _i2_=M$0[281],
     _i3_=M$0[282],
     _i4_=M$0[283],
     _i5_=M$0[284],
     _i6_=M$0[285],
     _i7_=M$0[286],
     _i8_=M$0[287],
     _i9_=M$0[288],
     _i__=M$0[289],
     _i$_=M$0[290],
     _ja_=M$0[291],
     _jb_=M$0[292],
     _jc_=M$0[293],
     _jd_=M$0[294],
     _je_=M$0[295],
     _jf_=M$0[296],
     _jg_=M$0[297],
     _jh_=M$0[298],
     _ji_=M$0[299],
     _jj_=M$0[300],
     _jk_=M$0[301],
     _jl_=M$0[302],
     _jm_=M$0[303],
     _jn_=M$0[304],
     _jo_=M$0[305],
     _jp_=M$0[306],
     _jq_=M$0[307],
     _jr_=M$0[308],
     _js_=M$0[309],
     _jt_=M$0[310],
     _ju_=M$0[311],
     _jv_=M$0[312],
     _jw_=M$0[313],
     _jx_=M$0[314],
     _jy_=M$0[315],
     _jz_=M$0[316],
     _jA_=M$0[317],
     _jB_=M$0[318],
     _jC_=M$0[319],
     _jD_=M$0[320],
     _jE_=M$0[321],
     _jF_=M$0[322],
     _jG_=M$0[323],
     _jH_=M$0[324],
     _jI_=M$0[325],
     _jJ_=M$0[326],
     _jK_=M$0[327],
     _jL_=M$0[328],
     _jM_=M$0[329],
     _jN_=M$0[330],
     _jO_=M$0[331],
     _jP_=M$0[332],
     _jQ_=M$0[333],
     _jR_=M$0[334],
     _jS_=M$0[335],
     _jT_=M$0[336],
     _jU_=M$0[337],
     _jV_=M$0[338],
     _jW_=M$0[339],
     _jX_=M$0[340],
     _jY_=M$0[341],
     _jZ_=M$0[342],
     _j0_=M$0[343],
     _j1_=M$0[344],
     pp$1=caml_call4(_j3_,0,0,0,0),
     pp_elt$0=caml_call3(_j2_,0,0,0),
     Tyxml_html=
      [0,
       _eE_,
       _eF_,
       _eG_,
       _eH_,
       _eI_,
       _eJ_,
       _eK_,
       _eL_,
       _eM_,
       _eN_,
       _eO_,
       _eP_,
       _eQ_,
       _eR_,
       _eS_,
       _eT_,
       _eU_,
       _eV_,
       _eW_,
       _eX_,
       _eY_,
       _eZ_,
       _e0_,
       _e1_,
       _e2_,
       _e3_,
       _e4_,
       _e5_,
       _e6_,
       _e7_,
       _e8_,
       _e9_,
       _e__,
       _e$_,
       _fa_,
       _fb_,
       _fc_,
       _fd_,
       _fe_,
       _ff_,
       _fg_,
       _fh_,
       _fi_,
       _fj_,
       _fk_,
       _fl_,
       _fm_,
       _fn_,
       _fo_,
       _fp_,
       _fq_,
       _fr_,
       _fs_,
       _ft_,
       _fu_,
       _fv_,
       _fw_,
       _fx_,
       _fy_,
       _fz_,
       _fA_,
       _fB_,
       _fC_,
       _fD_,
       _fE_,
       _fF_,
       _fG_,
       _fH_,
       _fI_,
       _fJ_,
       _fK_,
       _fL_,
       _fM_,
       _fN_,
       _fO_,
       _fP_,
       _fQ_,
       _fR_,
       _fS_,
       _fT_,
       _fU_,
       _fV_,
       _fW_,
       _fX_,
       _fY_,
       _fZ_,
       _f0_,
       _f1_,
       _f2_,
       _f3_,
       _f4_,
       _f5_,
       _f6_,
       _f7_,
       _f8_,
       _f9_,
       _f__,
       _f$_,
       _ga_,
       _gb_,
       _gc_,
       _gd_,
       _ge_,
       _gf_,
       _gg_,
       _gh_,
       _gi_,
       _gj_,
       _gk_,
       _gl_,
       _gm_,
       _gn_,
       _go_,
       _gp_,
       _gq_,
       _gr_,
       _gs_,
       _gt_,
       _gu_,
       _gv_,
       _gw_,
       _gx_,
       _gy_,
       _gz_,
       _gA_,
       _gB_,
       _gC_,
       _gD_,
       _gE_,
       _gF_,
       _gG_,
       _gH_,
       _gI_,
       _gJ_,
       _gK_,
       _gL_,
       _gM_,
       _gN_,
       _gO_,
       _gP_,
       _gQ_,
       _gR_,
       _gS_,
       _gT_,
       _gU_,
       _gV_,
       _gW_,
       _gX_,
       _gY_,
       _gZ_,
       _g0_,
       _g1_,
       _g2_,
       _g3_,
       _g4_,
       _g5_,
       _g6_,
       _g7_,
       _g8_,
       _g9_,
       _g__,
       _g$_,
       _ha_,
       _hb_,
       _hc_,
       _hd_,
       _he_,
       _hf_,
       _hg_,
       _hh_,
       _hi_,
       _hj_,
       _hk_,
       _hl_,
       _hm_,
       _hn_,
       _ho_,
       _hp_,
       _hq_,
       _hr_,
       _hs_,
       _ht_,
       _hu_,
       _hv_,
       _hw_,
       _hx_,
       _hy_,
       _hz_,
       _hA_,
       _hB_,
       _hC_,
       _hD_,
       _hE_,
       _hF_,
       _hG_,
       _hH_,
       _hI_,
       _hJ_,
       _hK_,
       _hL_,
       _hM_,
       _hN_,
       _hO_,
       _hP_,
       _hQ_,
       _hR_,
       _hS_,
       _hT_,
       _hU_,
       _hV_,
       _hW_,
       _hX_,
       _hY_,
       _hZ_,
       _h0_,
       _h1_,
       _h2_,
       _h3_,
       _h4_,
       _h5_,
       _h6_,
       _h7_,
       _h8_,
       _h9_,
       _h__,
       _h$_,
       _ia_,
       _ib_,
       _ic_,
       _id_,
       _ie_,
       _if_,
       _ig_,
       _ih_,
       _ii_,
       _ij_,
       _ik_,
       _il_,
       _im_,
       _in_,
       _io_,
       _ip_,
       _iq_,
       _ir_,
       _is_,
       _it_,
       _iu_,
       _iv_,
       _iw_,
       _ix_,
       _iy_,
       _iz_,
       _iA_,
       _iB_,
       _iC_,
       _iD_,
       _iE_,
       _iF_,
       _iG_,
       _iH_,
       _iI_,
       _iJ_,
       _iK_,
       _iL_,
       _iM_,
       _iN_,
       _iO_,
       _iP_,
       _iQ_,
       _iR_,
       _iS_,
       _iT_,
       _iU_,
       _iV_,
       _iW_,
       _iX_,
       _iY_,
       _iZ_,
       _i0_,
       _i1_,
       _i2_,
       _i3_,
       _i4_,
       _i5_,
       _i6_,
       _i7_,
       _i8_,
       _i9_,
       _i__,
       _i$_,
       _ja_,
       _jb_,
       _jc_,
       _jd_,
       _je_,
       _jf_,
       _jg_,
       _jh_,
       _ji_,
       _jj_,
       _jk_,
       _jl_,
       _jm_,
       _jn_,
       _jo_,
       _jp_,
       _jq_,
       _jr_,
       _js_,
       _jt_,
       _ju_,
       _jv_,
       _jw_,
       _jx_,
       _jy_,
       _jz_,
       _jA_,
       _jB_,
       _jC_,
       _jD_,
       _jE_,
       _jF_,
       _jG_,
       _jH_,
       _jI_,
       _jJ_,
       _jK_,
       _jL_,
       _jM_,
       _jN_,
       _jO_,
       _jP_,
       _jQ_,
       _jR_,
       _jS_,
       _jT_,
       _jU_,
       _jV_,
       _jW_,
       _jX_,
       _jY_,
       _jZ_,
       _j0_,
       _j1_,
       _j3_,
       _j2_,
       Make_printer$0,
       pp$1,
       pp_elt$0];
    caml_register_global(21,Tyxml_html,"Tyxml_html");
    var Tyxml=[0];
    caml_register_global(22,Tyxml,"Tyxml");
    return}
  (function(){return this}()));


//# 1 ".pasteur.eobjs/byte/dune__exe__Pasteur.cmo.js"
(function(joo_global_object)
   {"use strict";
    var
     runtime=joo_global_object.jsoo_runtime,
     caml_js_to_bool=runtime.caml_js_to_bool,
     caml_jsstring_of_string=runtime.caml_jsstring_of_string,
     caml_string_get=runtime.caml_string_get,
     caml_string_of_jsbytes=runtime.caml_string_of_jsbytes,
     caml_string_of_jsstring=runtime.caml_string_of_jsstring;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    function caml_call2(f,a0,a1)
     {return f.length == 2?f(a0,a1):runtime.caml_call_gen(f,[a0,a1])}
    function caml_call3(f,a0,a1,a2)
     {return f.length == 3?f(a0,a1,a2):runtime.caml_call_gen(f,[a0,a1,a2])}
    function caml_call4(f,a0,a1,a2,a3)
     {return f.length == 4
              ?f(a0,a1,a2,a3)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3])}
    function caml_call5(f,a0,a1,a2,a3,a4)
     {return f.length == 5
              ?f(a0,a1,a2,a3,a4)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4])}
    function caml_call6(f,a0,a1,a2,a3,a4,a5)
     {return f.length == 6
              ?f(a0,a1,a2,a3,a4,a5)
              :runtime.caml_call_gen(f,[a0,a1,a2,a3,a4,a5])}
    function caml_call13(f,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
     {return f.length == 13
              ?f(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)
              :runtime.caml_call_gen
                (f,[a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12])}
    var
     global_data=runtime.caml_get_global_data(),
     cst_Decrypted=caml_string_of_jsbytes("Decrypted."),
     cst_Decrypt=caml_string_of_jsbytes("Decrypt."),
     cst_Key_sanitized=caml_string_of_jsbytes("Key sanitized."),
     cst_Key_s=caml_string_of_jsbytes("Key '%s'"),
     cst_Data_is_encrypted=caml_string_of_jsbytes("Data is encrypted."),
     cst_Data_is_not_encrypted=
      caml_string_of_jsbytes("Data is not encrypted."),
     cst_Invalid_hex_value=caml_string_of_jsbytes("Invalid hex value"),
     cst$0=caml_string_of_jsbytes(""),
     cst_Invalid_hex_character=caml_string_of_jsbytes("Invalid hex character"),
     cst_hl=caml_string_of_jsbytes("hl"),
     cst_ln=caml_string_of_jsbytes("ln"),
     cst_raw=caml_string_of_jsbytes("raw"),
     cst_hl$0=caml_string_of_jsbytes("hl"),
     cst_ln$0=caml_string_of_jsbytes("ln"),
     cst_raw$0=caml_string_of_jsbytes("raw"),
     cst_Paste_element_must_be_a_st=
      caml_string_of_jsbytes("Paste element must be a string"),
     cst_No_element_found=caml_string_of_jsbytes("No element found"),
     cst_No_element_with_id_s_found=
      caml_string_of_jsbytes("No element with id '%s' found"),
     cst=caml_string_of_jsbytes(""),
     Jv=global_data.Jv,
     Fut=global_data.Fut,
     Brr=global_data.Brr,
     Brr_webcrypto=global_data.Brr_webcrypto,
     Rresult=global_data.Rresult,
     Stdlib=global_data.Stdlib,
     Jstr=global_data.Jstr,
     Stdlib_option=global_data.Stdlib__option,
     Brr_io=global_data.Brr_io,
     Match_failure=global_data.Match_failure,
     Fmt=global_data.Fmt,
     name=Brr_webcrypto[2][19],
     sym_key_gen=caml_call3(Brr_webcrypto[2][17][1],name,128,0),
     _m_=[0,caml_string_of_jsbytes("js/pasteur.ml"),78,26],
     _d_=
      [0,
       [11,
        caml_string_of_jsbytes("?ln=true&hl="),
        [2,0,[11,caml_string_of_jsbytes("&raw=true"),0]]],
       caml_string_of_jsbytes("?ln=true&hl=%s&raw=true")],
     _g_=
      [0,
       [11,caml_string_of_jsbytes("?ln=true&hl="),[2,0,0]],
       caml_string_of_jsbytes("?ln=true&hl=%s")],
     _h_=
      [0,
       [11,caml_string_of_jsbytes("?ln=true&raw=true"),0],
       caml_string_of_jsbytes("?ln=true&raw=true")],
     _i_=
      [0,
       [11,caml_string_of_jsbytes("?ln=true"),0],
       caml_string_of_jsbytes("?ln=true")],
     _j_=
      [0,
       [11,
        caml_string_of_jsbytes("?hl="),
        [2,0,[11,caml_string_of_jsbytes("&raw=true"),0]]],
       caml_string_of_jsbytes("?hl=%s&raw=true")],
     _k_=
      [0,
       [11,caml_string_of_jsbytes("?hl="),[2,0,0]],
       caml_string_of_jsbytes("?hl=%s")],
     _l_=
      [0,
       [11,caml_string_of_jsbytes("?raw=true"),0],
       caml_string_of_jsbytes("?raw=true")],
     _e_=[0,[2,0,[2,0,[12,35,[2,0,0]]]],caml_string_of_jsbytes("%s%s#%s")],
     _f_=[0,[2,0,[2,0,0]],caml_string_of_jsbytes("%s%s")],
     _a_=[0,72,59,46,196,68,13,44,176,70,244,213,118,161,148,38,13];
    function sym_exportable_key(s)
     {var usages=[0,Brr_webcrypto[1][2][1],[0,Brr_webcrypto[1][2][2],0]];
      return caml_call4(Brr_webcrypto[3][6],s,sym_key_gen,1,usages)}
    var
     iv=_a_.slice(),
     _b_=caml_call2(Brr[1][28],3,iv),
     iv$0=caml_call1(Brr[1][6],_b_);
    function sym_algo(iv,param)
     {if(iv)
       var iv$0=iv[1],iv$1=iv$0;
      else
       {var iv$2=caml_call2(Brr[1][4],3,16);
        caml_call2(Brr_webcrypto[4][3],Brr_webcrypto[4][1],iv$2);
        var iv$1=caml_call1(Brr[1][6],iv$2)}
      return caml_call3(Brr_webcrypto[2][20][1],0,iv$1,0)}
    function sym_encrypt(iv,s,key,clear)
     {var _bm_=sym_algo(iv,0);
      return caml_call4(Brr_webcrypto[3][1],s,_bm_,key,clear)}
    function sym_decrypt(iv,s,key,cipher)
     {var _bl_=sym_algo(iv,0);
      return caml_call4(Brr_webcrypto[3][2],s,_bl_,key,cipher)}
    var
     pasteur="pasteur",
     err_element_pasteur_not_found="No element with id 'pasteur' found",
     err_element_paste_not_found="No paste element found",
     err_element_paste_is_not_a_str="Paste element must be a string",
     err_invalid_hex_value="Invalid hex value",
     err_invalid_key="Invalid key!",
     on="on",
     _c_="POST";
    function symbol(f,g,x){return caml_call1(f,caml_call1(g,x))}
    function id(x){return x}
    function make_path(key,ln,hl,raw,code)
     {var switch$0=0;
      if(ln && ln[1])
       {if(hl)
         {var _a7_=hl[1],switch$1=0;
          if(raw && raw[1]){var _a8_=caml_call2(Fmt[6],_d_,_a7_);switch$1 = 1}
          if(! switch$1)var _a8_=caml_call2(Fmt[6],_g_,_a7_);
          var _a9_=_a8_}
        else
         {var switch$2=0;
          if(raw && raw[1])var _a9_=caml_call1(Fmt[6],_h_);else switch$2 = 1;
          if(switch$2)var _a9_=caml_call1(Fmt[6],_i_)}
        var args=_a9_}
      else
       switch$0 = 1;
      if(switch$0)
       if(hl)
        {var _bh_=hl[1],switch$3=0;
         if(raw && raw[1]){var _bi_=caml_call2(Fmt[6],_j_,_bh_);switch$3 = 1}
         if(! switch$3)var _bi_=caml_call2(Fmt[6],_k_,_bh_);
         var args=_bi_}
       else
        {var switch$4=0;
         if(raw && raw[1])var args=caml_call1(Fmt[6],_l_);else switch$4 = 1;
         if(switch$4)var args=cst}
      if(key)
       {var
         key$0=key[1],
         _a__=caml_string_of_jsstring(key$0),
         _a$_=caml_string_of_jsstring(code),
         _ba_=caml_jsstring_of_string,
         _bb_=Fut[9],
         _bc_=function(_bk_){return symbol(_bb_,_ba_,_bk_)};
        return caml_call5(Fmt[8],_bc_,_e_,_a$_,args,_a__)}
      var
       _bd_=caml_string_of_jsstring(code),
       _be_=caml_jsstring_of_string,
       _bf_=Fut[9];
      function _bg_(_bj_){return symbol(_bf_,_be_,_bj_)}
      return caml_call4(Fmt[8],_bg_,_f_,_bd_,args)}
    function post(param)
     {var match=caml_call2(Brr[10][2],Brr[16][2],pasteur);
      if(match)
       {var
         el=match[1],
         form=caml_call1(Brr_io[2][1],el),
         data=caml_call1(Brr_io[2][16][2],form),
         match$0=caml_call2(Brr_io[2][16][4],data,"paste"),
         match$1=caml_call2(Brr_io[2][16][4],data,"encrypted");
        if(match$0)
         {var _ag_=match$0[1];
          if(781515420 <= _ag_[1])
           {var
             _ah_=
              [0,caml_call1(Brr[12][5],cst_Paste_element_must_be_a_st),0];
            caml_call1(Brr[12][11],_ah_);
            var
             _ai_=
              [1,caml_call2(Jv[30][1],0,err_element_paste_is_not_a_str)];
            return caml_call1(Fut[3],_ai_)}
          var _aj_=_ag_[2];
          if(match$1)
           {var _ak_=match$1[1];
            if(typeof _ak_ !== "number" && -976970511 === _ak_[1])
             {var encrypted=_ak_[2];
              if(caml_call2(Jstr[28],encrypted,on))
               {var
                 subtl=caml_call1(Brr_webcrypto[4][2],Brr_webcrypto[4][1]),
                 clear=caml_call1(Brr[1][30],_aj_),
                 _ap_=
                  function(key)
                   {function _aI_(cipher)
                     {var
                       cipher$0=caml_call1(Brr[1][27],cipher),
                       cipher$1=caml_call2(Brr[1][33],0,cipher$0);
                      caml_call3(Brr_io[2][16][7],data,"paste",cipher$1);
                      var
                       _aK_=[0,caml_call1(Brr_io[3][1][3],data)],
                       init=
                        caml_call13
                         (Brr_io[3][3][6],_aK_,0,0,0,0,0,[0,_c_],0,0,0,0,0,0);
                      function _aL_(key)
                       {if(typeof key !== "number" && 98868477 === key[1])
                         {var
                           key$0=key[2],
                           _aN_=
                            function(key)
                             {function _aR_(res)
                               {function _aU_(res)
                                 {var
                                   code=res.code,
                                   _aW_=caml_call2(Jv[13],res,cst_hl$0),
                                   hl=caml_call2(Stdlib_option[7],Jv[24],_aW_),
                                   _aX_=caml_call2(Jv[13],res,cst_ln$0),
                                   ln=caml_call2(Stdlib_option[7],caml_js_to_bool,_aX_),
                                   _aY_=caml_call2(Jv[13],res,cst_raw$0),
                                   raw=caml_call2(Stdlib_option[7],caml_js_to_bool,_aY_);
                                  function _aZ_(path)
                                   {function _a1_(uri)
                                     {caml_call2(Brr[13][12],Brr[16][5],uri);
                                      return caml_call1(Fut[9],0)}
                                    var
                                     _a2_=caml_call1(Brr[13][11],Brr[16][5]),
                                     _a3_=[0,caml_call1(Brr[6][15],_a2_),[0,path,0]],
                                     _a4_=caml_call2(Jstr[9],0,_a3_),
                                     _a5_=caml_call1(Brr[6][14],_a4_),
                                     _a6_=caml_call1(Fut[3],_a5_);
                                    return caml_call2(Fut[16][1],_a6_,_a1_)}
                                  var _a0_=make_path([0,key],ln,hl,raw,code);
                                  return caml_call2(Fut[16][1],_a0_,_aZ_)}
                                var _aV_=caml_call1(Brr_io[3][1][11],res);
                                return caml_call2(Fut[16][1],_aV_,_aU_)}
                              var
                               _aS_=caml_call2(Brr_io[3][3][7],[0,init],"/"),
                               _aT_=caml_call1(Brr_io[3][8],_aS_);
                              return caml_call2(Fut[16][1],_aT_,_aR_)},
                           _aO_=caml_call1(Brr[5][1],key$0),
                           _aP_=caml_call1(Brr[4][1],_aO_),
                           _aQ_=caml_call1(Fut[3],_aP_);
                          return caml_call2(Fut[16][1],_aQ_,_aN_)}
                        throw [0,Match_failure,_m_]}
                      var
                       _aM_=
                        caml_call3
                         (Brr_webcrypto[3][10],subtl,Brr_webcrypto[1][3][4],key);
                      return caml_call2(Fut[16][1],_aM_,_aL_)}
                    var _aJ_=sym_encrypt([0,iv$0],subtl,key,clear);
                    return caml_call2(Fut[16][1],_aJ_,_aI_)},
                 _aq_=sym_exportable_key(subtl);
                return caml_call2(Fut[16][1],_aq_,_ap_)}}}
          var
           _al_=[0,caml_call1(Brr_io[3][1][3],data)],
           init=
            caml_call13(Brr_io[3][3][6],_al_,0,0,0,0,0,[0,_c_],0,0,0,0,0,0),
           _am_=
            function(res)
             {function _av_(res)
               {var
                 code=res.code,
                 _ax_=caml_call2(Jv[13],res,cst_hl),
                 hl=caml_call2(Stdlib_option[7],Jv[24],_ax_),
                 _ay_=caml_call2(Jv[13],res,cst_ln),
                 ln=caml_call2(Stdlib_option[7],caml_js_to_bool,_ay_),
                 _az_=caml_call2(Jv[13],res,cst_raw),
                 raw=caml_call2(Stdlib_option[7],caml_js_to_bool,_az_);
                function _aA_(path)
                 {function _aC_(uri)
                   {caml_call2(Brr[13][12],Brr[16][5],uri);
                    return caml_call1(Fut[9],0)}
                  var
                   _aD_=caml_call1(Brr[13][11],Brr[16][5]),
                   _aE_=[0,caml_call1(Brr[6][15],_aD_),[0,path,0]],
                   _aF_=caml_call2(Jstr[9],0,_aE_),
                   _aG_=caml_call1(Brr[6][14],_aF_),
                   _aH_=caml_call1(Fut[3],_aG_);
                  return caml_call2(Fut[16][1],_aH_,_aC_)}
                var _aB_=make_path(0,ln,hl,raw,code);
                return caml_call2(Fut[16][1],_aB_,_aA_)}
              var _aw_=caml_call1(Brr_io[3][1][11],res);
              return caml_call2(Fut[16][1],_aw_,_av_)},
           _an_=caml_call2(Brr_io[3][3][7],[0,init],"/"),
           _ao_=caml_call1(Brr_io[3][8],_an_);
          return caml_call2(Fut[16][1],_ao_,_am_)}
        var _ar_=[0,caml_call1(Brr[12][5],cst_No_element_found),0];
        caml_call1(Brr[12][11],_ar_);
        var _as_=[1,caml_call2(Jv[30][1],0,err_element_paste_not_found)];
        return caml_call1(Fut[3],_as_)}
      var
       _at_=
        [0,
         caml_call1(Brr[12][5],cst_No_element_with_id_s_found),
         [0,pasteur,0]];
      caml_call1(Brr[12][11],_at_);
      var _au_=[1,caml_call2(Jv[30][1],0,err_element_pasteur_not_found)];
      return caml_call1(Fut[3],_au_)}
    var
     raw="raw",
     output="output",
     encrypted="encrypted",
     err_source_or_output_not_found="Source or Output not found";
    function to_uint8(x,y)
     {function code(chr)
       {if(65 <= chr)
         {if(97 <= chr)
           {if(! (103 <= chr))return (10 + chr | 0) - 97 | 0}
          else
           if(! (71 <= chr))return (10 + chr | 0) - 65 | 0}
        else
         {var switcher=chr - 48 | 0;
          if(! (9 < switcher >>> 0))return chr - 48 | 0}
        return caml_call1(Stdlib[1],cst_Invalid_hex_character)}
      var _af_=code(y);
      return (code(x) << 4) + _af_ | 0}
    function _n_(str)
     {if(runtime.caml_string_equal(str,cst$0))return [0];
      var
       len=runtime.caml_ml_string_length(str),
       buf=runtime.caml_make_vect(len / 2 | 0,0),
       x=0,
       y=1;
      for(;;)
       {if(! (len <= x))
         {if(! (len <= y))
           {var
             _ac_=caml_string_get(str,y),
             _ae_=x / 2 | 0,
             _ad_=to_uint8(caml_string_get(str,x),_ac_);
            runtime.caml_check_bound(buf,_ae_)[1 + _ae_] = _ad_;
            var y$0=y + 2 | 0,x$0=x + 2 | 0,x=x$0,y=y$0;
            continue}
          caml_call1(Stdlib[1],cst_Invalid_hex_value)}
        return buf}}
    function of_hex(str)
     {try
       {var _aa_=[0,_n_(str)];return _aa_}
      catch(_ab_){return [1,caml_call2(Jv[30][1],0,err_invalid_hex_value)]}}
    function show(param)
     {var
       match=caml_call2(Brr[10][2],Brr[16][2],raw),
       match$0=caml_call2(Brr[10][2],Brr[16][2],output),
       match$1=caml_call2(Brr[10][2],Brr[16][2],encrypted);
      if(match && match$0)
       {var _y_=match$0[1],_z_=match[1];
        if(match$1)
         {var encrypted$0=match$1[1];
          if(runtime.caml_equal(encrypted$0.textContent,on))
           {var _A_=[0,caml_call1(Brr[12][5],cst_Data_is_encrypted),0];
            caml_call1(Brr[12][14],_A_);
            var
             subtl=caml_call1(Brr_webcrypto[4][2],Brr_webcrypto[4][1]),
             _B_=caml_call1(Brr[13][11],Brr[16][5]),
             key=caml_call1(Brr[6][7],_B_),
             _C_=
              function(key)
               {var
                 _K_=[0,caml_call1(Brr[5][1],key),0],
                 _L_=[0,caml_call1(Brr[12][5],cst_Key_s),_K_];
                caml_call1(Brr[12][14],_L_);
                function _M_(key)
                 {var _O_=[0,caml_call1(Brr[12][5],cst_Key_sanitized),0];
                  caml_call1(Brr[12][14],_O_);
                  var cipher=_z_.textContent;
                  function _P_(cipher)
                   {var
                     cipher$0=caml_call2(Brr[1][28],3,cipher),
                     _S_=[0,caml_call1(Brr[12][5],cst_Decrypt),0];
                    caml_call1(Brr[12][14],_S_);
                    function _T_(clear)
                     {var _V_=[0,caml_call1(Brr[12][5],cst_Decrypted),0];
                      caml_call1(Brr[12][14],_V_);
                      function _W_(err)
                       {if(0 === err[0])
                         {var clear=err[1],___=[0,caml_call2(Brr[9][2],0,clear),0];
                          caml_call2(Brr[9][15],_y_,___);
                          return caml_call1(Fut[9],0)}
                        var _$_=[0,caml_call2(Brr[9][2],0,err_invalid_key),0];
                        caml_call2(Brr[9][15],_y_,_$_);
                        return caml_call1(Fut[3],err)}
                      var
                       _X_=caml_call4(Brr[1][5],3,0,0,clear),
                       _Y_=caml_call1(Brr[1][31],_X_),
                       _Z_=caml_call1(Fut[3],_Y_);
                      return caml_call2(Fut[15][1],_Z_,_W_)}
                    var _U_=sym_decrypt([0,iv$0],subtl,key,cipher$0);
                    return caml_call2(Fut[16][1],_U_,_T_)}
                  var
                   _Q_=of_hex(caml_string_of_jsstring(cipher)),
                   _R_=caml_call1(Fut[3],_Q_);
                  return caml_call2(Fut[16][1],_R_,_P_)}
                var
                 _N_=
                  caml_call6
                   (Brr_webcrypto[3][11],
                    subtl,
                    Brr_webcrypto[1][3][4],
                    [0,98868477,key],
                    sym_key_gen,
                    0,
                    [0,Brr_webcrypto[1][2][2],0]);
                return caml_call2(Fut[16][1],_N_,_M_)},
             _D_=Brr[5][2],
             _E_=caml_call1(Brr[4][2],key),
             _F_=caml_call2(Rresult[1],_E_,_D_),
             _G_=caml_call1(Fut[3],_F_);
            return caml_call2(Fut[16][1],_G_,_C_)}}
        var _H_=[0,caml_call1(Brr[12][5],cst_Data_is_not_encrypted),0];
        caml_call1(Brr[12][14],_H_);
        var clear=_z_.textContent,_I_=[0,caml_call2(Brr[9][2],0,clear),0];
        caml_call2(Brr[9][15],_y_,_I_);
        return caml_call1(Fut[9],0)}
      var _J_=caml_call2(Jv[30][1],0,err_source_or_output_not_found);
      return caml_call1(Fut[10],_J_)}
    function const$0(x,param){return x}
    function _o_(param)
     {var _u_=post(0),_v_=Jv[5];
      function _w_(_x_){return _v_}
      return caml_call2(Fut[12],_w_,_u_)}
    Jv[12].doPost = _o_;
    function _p_(param)
     {var _q_=show(0),_r_=Jv[5];
      function _s_(_t_){return _r_}
      return caml_call2(Fut[12],_s_,_q_)}
    Jv[12].doShow = _p_;
    var
     Dune_exe_Pasteur=
      [0,
       sym_key_gen,
       sym_exportable_key,
       iv$0,
       sym_algo,
       sym_encrypt,
       sym_decrypt,
       pasteur,
       err_element_pasteur_not_found,
       err_element_paste_not_found,
       err_element_paste_is_not_a_str,
       err_invalid_hex_value,
       err_invalid_key,
       on,
       symbol,
       id,
       make_path,
       post,
       raw,
       output,
       encrypted,
       err_source_or_output_not_found,
       to_uint8,
       of_hex,
       show,
       const$0];
    runtime.caml_register_global(65,Dune_exe_Pasteur,"Dune__exe__Pasteur");
    return}
  (function(){return this}()));


//# 1 "../.js/stdlib/std_exit.cmo.js"
(function(joo_global_object)
   {"use strict";
    var runtime=joo_global_object.jsoo_runtime;
    function caml_call1(f,a0)
     {return f.length == 1?f(a0):runtime.caml_call_gen(f,[a0])}
    var global_data=runtime.caml_get_global_data(),Stdlib=global_data.Stdlib;
    caml_call1(Stdlib[103],0);
    var Std_exit=[0];
    runtime.caml_register_global(1,Std_exit,"Std_exit");
    return}
  (function(){return this}()));


//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwYXN0ZXVyLmJjLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImNhbWxfaW50NjRfaXNfemVybyIsIngiLCJjYW1sX3N0cl9yZXBlYXQiLCJuIiwicyIsInIiLCJsIiwiY2FtbF9pbnQ2NF9vZmZzZXQiLCJNYXRoIiwiY2FtbF9yYWlzZV9jb25zdGFudCIsInRhZyIsImNhbWxfZ2xvYmFsX2RhdGEiLCJjYW1sX3JhaXNlX3plcm9fZGl2aWRlIiwiTWxJbnQ2NCIsImxvIiwibWkiLCJoaSIsInRoaXMiLCJ4aGkiLCJoIiwic2lnbiIsIm9mZnNldCIsIm1vZHVsdXMiLCJkaXZpc29yIiwicXVvdGllbnQiLCJ5IiwicSIsImNhbWxfaW50NjRfb2ZfaW50MzIiLCJjYW1sX2ludDY0X3RvX2ludDMyIiwiY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSIsImNhbWxfaW50NjRfbmVnIiwiY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIiwiYSIsImkiLCJsZW4iLCJmIiwiU3RyaW5nIiwibnVsbCIsImNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMiLCJjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIiwiY2FtbF9yYWlzZV93aXRoX2FyZyIsImFyZyIsImpzb29faXNfYXNjaWkiLCJjYW1sX3V0ZjE2X29mX3V0ZjgiLCJiIiwidCIsImMiLCJjMSIsImMyIiwidiIsImoiLCJNbEJ5dGVzIiwiY29udGVudHMiLCJsZW5ndGgiLCJjb250ZW50IiwiY2FtbF9ieXRlc19vZl9qc2J5dGVzIiwiY2FtbF9zdHJpbmdfb2ZfanNieXRlcyIsImNhbWxfcmFpc2Vfd2l0aF9zdHJpbmciLCJtc2ciLCJjYW1sX2ludmFsaWRfYXJndW1lbnQiLCJjYW1sX3BhcnNlX2Zvcm1hdCIsImZtdCIsImNhbWxfZmluaXNoX2Zvcm1hdHRpbmciLCJyYXdidWZmZXIiLCJidWZmZXIiLCJjYW1sX2ludDY0X2Zvcm1hdCIsIndiYXNlIiwiY3Z0YmwiLCJwIiwiY2FtbF9leHBtMV9mbG9hdCIsInoiLCJjYW1sX2pzc3RyaW5nX29mX3N0cmluZyIsImpvb19nbG9iYWxfb2JqZWN0IiwiY2FtbF9jdXJyZW50X2RpciIsImNhbWxfbWFrZV9wYXRoIiwibmFtZSIsImNvbXAiLCJuY29tcCIsImNhbWxfaXNfbWxfYnl0ZXMiLCJjYW1sX2lzX21sX3N0cmluZyIsImNhbWxfYnl0ZXNfb2ZfYXJyYXkiLCJjYW1sX2J5dGVzX29mX3N0cmluZyIsImNhbWxfdXRmOF9vZl91dGYxNiIsImQiLCJjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIiwiY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmciLCJjYW1sX3JhaXNlX3N5c19lcnJvciIsImNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlIiwiY2FtbF9ieXRlc19ib3VuZF9lcnJvciIsImNhbWxfYnl0ZXNfdW5zYWZlX2dldCIsImNhbWxfYnl0ZXNfZ2V0IiwiY2FtbF9jcmVhdGVfYnl0ZXMiLCJjYW1sX21sX2J5dGVzX2xlbmd0aCIsImNhbWxfY29udmVydF9ieXRlc190b19hcnJheSIsIkFycmF5IiwiY2FtbF9ibGl0X2J5dGVzIiwiczEiLCJpMSIsInMyIiwiaTIiLCJjYW1sX2JsaXRfc3RyaW5nIiwiZSIsIk1sRmlsZSIsIk1sRmFrZUZpbGUiLCJvbGQiLCJidWYiLCJwb3MiLCJjbGVuIiwibmV3X3N0ciIsIm9sZF9kYXRhIiwiTWxGYWtlRGV2aWNlIiwicm9vdCIsInJlcyIsIm5hbWVfc2xhc2giLCJSZWdFeHAiLCJzZWVuIiwibSIsIm9rIiwiZmlsZSIsImJ5dGVzIiwiY2FtbF9tbF9zdHJpbmdfbGVuZ3RoIiwiY2FtbF9zdHJpbmdfdW5zYWZlX2dldCIsImNhbWxfYXJyYXlfb2Zfc3RyaW5nIiwiY2FtbF9hcnJheV9vZl9ieXRlcyIsImNhbWxfYnl0ZXNfdW5zYWZlX3NldCIsImNhbWxfYnl0ZXNfc2V0IiwiTWxOb2RlRmlsZSIsImZkIiwicmVxdWlyZSIsImVyciIsImJ1Zl9vZmZzZXQiLCJNbE5vZGVEZXZpY2UiLCJjb25zdHMiLCJrZXkiLCJvIiwiY2FtbF9yb290IiwiZnNfbm9kZV9zdXBwb3J0ZWQiLCJqc29vX21vdW50X3BvaW50IiwicmVzb2x2ZV9mc19kZXZpY2UiLCJwYXRoIiwiY2FtbF9zeXNfaXNfZGlyZWN0b3J5IiwiY2FtbF9yYWlzZV9ub3RfZm91bmQiLCJjYW1sX3N5c19nZXRlbnYiLCJnIiwidW5kZWZpbmVkIiwic2hpZnRfcmlnaHRfbmF0IiwibmF0MSIsIm9mczEiLCJsZW4xIiwibmF0MiIsIm9mczIiLCJuYml0cyIsIndyYXAiLCJjYW1sX25hbWVkX3ZhbHVlcyIsImNhbWxfbmFtZWRfdmFsdWUiLCJubSIsImNhbWxfZ3Jfc3RhdGUiLCJjYW1sX2dyX3N0YXRlX2dldCIsImNhbWxfZ3JfcG9pbnRfY29sb3IiLCJpbSIsIk1sT2JqZWN0VGFibGUiLCJOYWl2ZUxvb2t1cCIsIm9ianMiLCJjYW1sX2ZhaWx3aXRoIiwiY2FtbF9zeXNfcmVuYW1lIiwib19yb290Iiwibl9yb290IiwiY2FtbF9sb2cxMF9mbG9hdCIsImNhbWxfcnVudGltZV93YXJuaW5ncyIsImNhbWxfbWxfZW5hYmxlX3J1bnRpbWVfd2FybmluZ3MiLCJib29sIiwiY2FtbF9jbGFzc2lmeV9mbG9hdCIsImlzRmluaXRlIiwiaXNOYU4iLCJjYW1sX21sX3JlZmlsbF9pbnB1dCIsImNoYW4iLCJzdHIiLCJzdHJfbGVuIiwiY2FtbF9tbF9jaGFubmVscyIsImNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCIsImNoYW5pZCIsImNhbWxfYXJyYXlfYm91bmRfZXJyb3IiLCJjYW1sX21sX2lucHV0X3NjYW5fbGluZSIsImNhbWxfZ2NfbWlub3IiLCJjYW1sX2ludDY0X29mX2J5dGVzIiwiY2FtbF9iYV91aW50OF9nZXQ2NCIsImJhIiwiaTAiLCJvZnMiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwiYjYiLCJiNyIsImI4IiwiY2FtbF9pbnQ2NF90b19ieXRlcyIsImNhbWxfaW50NjRfbWFyc2hhbCIsIndyaXRlciIsInNpemVzIiwiY2FtbF9iYV9udW1fZGltcyIsImNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCIsImNhbWxfd3JhcF9leGNlcHRpb24iLCJjYW1sX2NyZWF0ZV9maWxlIiwiY2FtbF9mc19pbml0IiwidG1wIiwiY2FtbF9zZXRfcGFyc2VyX3RyYWNlIiwiY2FtbF9saXN0X29mX2pzX2FycmF5IiwidW5peF9nZXR0aW1lb2ZkYXkiLCJEYXRlIiwiY2FtbF9tdWwiLCJjYW1sX2hhc2hfbWl4X2ludCIsIm51bV9kaWdpdHNfbmF0IiwibmF0IiwiY2FtbF9oYXNoX25hdCIsImNhbWxfY2FsbF9nZW4iLCJhcmdzIiwiYXJnc0xlbiIsImV4dHJhX2FyZ3MiLCJhcmd1bWVudHMiLCJuYXJncyIsImNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3N5c19jaGRpciIsImRpciIsImNhbWxfZ2NfY291bnRlcnMiLCJjYW1sX2dyX3N5bmNocm9uaXplIiwibG9nMl9vayIsImpzb29fZmxvb3JfbG9nMiIsIkluZmluaXR5IiwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0IiwiZmxvYXQzMmEiLCJpbnQzMmEiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSIsImNhbWxfaW50NjRfYml0c19vZl9mbG9hdCIsImV4cCIsImsiLCJyMyIsInIyIiwicjEiLCJjYW1sX2JhX3NlcmlhbGl6ZSIsInN6IiwiY29tcGxleCIsImNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQiLCJraW5kIiwiY2FtbF9iYV9jcmVhdGVfYnVmZmVyIiwic2l6ZSIsInZpZXciLCJkYXRhIiwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzIiwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIiwiTmFOIiwiY2FtbF9iYV9nZXRfc2l6ZSIsImRpbXMiLCJuX2RpbXMiLCJjYW1sX2ludDY0X2NyZWF0ZV9sb19oaSIsImNhbWxfaW50NjRfaGkzMiIsImNhbWxfaW50NjRfbG8zMiIsImNhbWxfYmFfY3VzdG9tX25hbWUiLCJNbF9CaWdhcnJheSIsImxheW91dCIsInJlIiwidG90YWwiLCJrMSIsImsyIiwiTWxfQmlnYXJyYXlfY18xXzEiLCJjYW1sX2JhX2NyZWF0ZV91bnNhZmUiLCJzaXplX3Blcl9lbGVtZW50IiwiY2FtbF9iYV9kZXNlcmlhbGl6ZSIsInJlYWRlciIsIm51bV9kaW1zIiwic2l6ZV9kaW0iLCJzaXplX2RpbV9oaSIsInNpemVfZGltX2xvIiwic2l4dHkiLCJpbnQ2NCIsImNhbWxfYmFfY29tcGFyZSIsImNhbWxfaGFzaF9taXhfaW50NjQiLCJjYW1sX2hhc2hfbWl4X2Zsb2F0IiwidjAiLCJjYW1sX2JhX2hhc2giLCJudW1fZWx0cyIsInciLCJjYW1sX2ludDMyX3VubWFyc2hhbCIsImNhbWxfbmF0aXZlaW50X3VubWFyc2hhbCIsImNhbWxfaW50NjRfdW5tYXJzaGFsIiwiY2FtbF9pbnQ2NF9jb21wYXJlIiwiY2FtbF9pbnQ2NF9oYXNoIiwiY2FtbF9jdXN0b21fb3BzIiwiY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tIiwiY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tIiwibnVtIiwiY3VzdG9tIiwic3dhcCIsImNhbWxfY29tcGFyZV92YWxfdGFnIiwiTnVtYmVyIiwiY2FtbF9pbnRfY29tcGFyZSIsImNhbWxfYnl0ZXNfY29tcGFyZSIsImNhbWxfc3RyaW5nX2NvbXBhcmUiLCJjYW1sX2NvbXBhcmVfdmFsIiwic3RhY2siLCJ0YWdfYSIsInRhZ19iIiwiY2FtbF9ncmVhdGVydGhhbiIsImRpdl9oZWxwZXIiLCJkaXZfZGlnaXRfbmF0IiwibmF0cSIsIm9mc3EiLCJuYXRyIiwib2ZzciIsInJlbSIsIm51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCIsInNoaWZ0X2xlZnRfbmF0IiwiTWxOYXQiLCJjcmVhdGVfbmF0IiwiYXJyIiwic2V0X3RvX3plcm9fbmF0IiwiaW5jcl9uYXQiLCJjYXJyeV9pbiIsImNhcnJ5IiwiYWRkX25hdCIsImxlbjIiLCJuYXRfb2ZfYXJyYXkiLCJtdWx0X2RpZ2l0X25hdCIsIm5hdDMiLCJvZnMzIiwieDEiLCJ4MiIsIngzIiwiZGVjcl9uYXQiLCJib3Jyb3ciLCJzdWJfbmF0IiwiY29tcGFyZV9uYXQiLCJkaXZfbmF0IiwicXVvIiwiY2FtbF9iYV9ibGl0Iiwic3JjIiwiZHN0IiwiaXNfZGlnaXRfaW50IiwiY2FtbF9pbnQ2NF9kaXYiLCJjYW1sX2pzX2h0bWxfZW50aXRpZXMiLCJlbnRpdHkiLCJ0ZW1wIiwiZG9jdW1lbnQiLCJjYW1sX3N0cmluZ191bnNhZmVfc2V0IiwiY2FtbF9pbnQ2NF9vZl9mbG9hdCIsImNhbWxfbWxfY2hhbm5lbF9zaXplXzY0IiwiY2FtbF9iYV9zZXRfMiIsImNhbWxfYXJndiIsIm1haW4iLCJhcmd2IiwiYXJnczIiLCJjYW1sX2V4ZWN1dGFibGVfbmFtZSIsImNhbWxfanNfZXZhbF9zdHJpbmciLCJldmFsIiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2QiLCJsb2MiLCJzaGFwZSIsInVuZGVmX21vZHVsZSIsIl94IiwibG9vcCIsInN0cnVjdCIsImlkeCIsInNlcmlhbGl6ZV9uYXQiLCJjYW1sX21lbXByb2Zfc2V0IiwiX2NvbnRyb2wiLCJjYW1sX3N5c19leGl0IiwiY29kZSIsImNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yIiwiY2FtbF9qc19mcm9tX2FycmF5IiwiY2FtbF9iYV9yZXNoYXBlIiwidmluZCIsIm5ld19kaW0iLCJjYW1sX29vX2xhc3RfaWQiLCJjYW1sX3NldF9vb19pZCIsImNhbWxfZ3JfZmlsbF9yZWN0IiwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmEiLCJzdHIxIiwicG9zMSIsImJhMiIsInBvczIiLCJzbGljZSIsImNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZSIsImpzbmFtZSIsImNhbWxfZ2V0X2dsb2JhbF9kYXRhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodF91bnNpZ25lZCIsImNhbWxfYmFfdWludDhfZ2V0MTYiLCJjYW1sX2NvbXBhcmUiLCJjYW1sX2ZyZXNoX29vX2lkIiwiY2FtbF9pbnQ2NF90b19mbG9hdCIsImNhbWxfYmFfZ2V0XzEiLCJjYW1sX2JpZ3N0cmluZ19tZW1jbXAiLCJjYW1sX25ld19zdHJpbmciLCJjYW1sX2JhX3VpbnQ4X2dldDMyIiwiY2FtbF9yYXdfYmFja3RyYWNlX2xlbmd0aCIsImNhbWxfb2JqX2Jsb2NrIiwiY2FtbF9ncl9jbGVhcl9ncmFwaCIsImJpZ3N0cmluZ190b19hcnJheV9idWZmZXIiLCJicyIsImNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQiLCJfdW5pdCIsImx4b3JfZGlnaXRfbmF0IiwiY2FtbF9maW5hbF9yZWxlYXNlIiwiY2FtbF9qc190b19hcnJheSIsImNhbWxfZ3JfcGxvdCIsImNvbG9yIiwiY2FtbF9ieXRlc19zZXQ2NCIsImk2NCIsImNhbWxfYnl0ZXNfc2V0MTYiLCJpMTYiLCJjYW1sX3N0cmluZ19zZXQxNiIsImNhbWxfaW50NjRfYnN3YXAiLCJjYW1sX2ZpbGxfYnl0ZXMiLCJjYW1sX2ZpbGxfc3RyaW5nIiwiY2FtbF9nY19tYWpvciIsImNhbWxfbGV4X2FycmF5IiwiY2FtbF9sZXhfZW5naW5lIiwidGJsIiwic3RhcnRfc3RhdGUiLCJsZXhidWYiLCJsZXhfYnVmZmVyIiwibGV4X2J1ZmZlcl9sZW4iLCJsZXhfc3RhcnRfcG9zIiwibGV4X2N1cnJfcG9zIiwibGV4X2xhc3RfcG9zIiwibGV4X2xhc3RfYWN0aW9uIiwibGV4X2VvZl9yZWFjaGVkIiwibGV4X2Jhc2UiLCJsZXhfYmFja3RyayIsImxleF9kZWZhdWx0IiwibGV4X3RyYW5zIiwibGV4X2NoZWNrIiwic3RhdGUiLCJiYXNlIiwiYmFja3RyayIsImNhbWxfc3lzX2ZpbGVfZXhpc3RzIiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfYXJyYXlfc3ViIiwiYTIiLCJjYW1sX2J5dGVzX2VxdWFsIiwiY2FtbF9ncl9zaXplX3giLCJjYW1sX21sX2RlYnVnX2luZm9fc3RhdHVzIiwiY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiIsImNhbWxfY29zaF9mbG9hdCIsImNhbWxfZXBoZV9rZXlfb2Zmc2V0IiwiY2FtbF93ZWFrX2NoZWNrIiwiY2FtbF9lcGhlX2NoZWNrX2tleSIsImNhbWxfaGFzaF9taXhfZmluYWwiLCJjYW1sX2dyX3RleHRfc2l6ZSIsInR4dCIsImNhbWxfbGV4X3J1bl9tZW0iLCJtZW0iLCJjdXJyX3BvcyIsImNhbWxfbGV4X3J1bl90YWciLCJjYW1sX25ld19sZXhfZW5naW5lIiwibGV4X21lbSIsImxleF9iYXNlX2NvZGUiLCJsZXhfYmFja3Rya19jb2RlIiwibGV4X2RlZmF1bHRfY29kZSIsImxleF90cmFuc19jb2RlIiwibGV4X2NoZWNrX2NvZGUiLCJsZXhfY29kZSIsInBjX29mZiIsInBzdGF0ZSIsImJhc2VfY29kZSIsImNhbWxfYmFfdWludDhfc2V0NjQiLCJjYW1sX3N5c19leGVjdXRhYmxlX25hbWUiLCJjYW1sX2xlc3NlcXVhbCIsImNhbWxfbWxfZmx1c2giLCJvdXRwdXQiLCJjYW1sX21sX3NlZWtfb3V0XzY0IiwiY29tcGFyZV9uYXRfcmVhbCIsImNhbWxfZ2Nfc2V0IiwiY2FtbF9qc19nZXQiLCJjYW1sX2djX2NvbXBhY3Rpb24iLCJjYW1sX3dlYWtfZ2V0IiwiY2FtbF9lcGhlX2dldF9rZXkiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2J5dGVzX3RvX2JhIiwid2luX2NsZWFudXAiLCJjYW1sX3N5c19jbG9zZSIsImNhbWxfbWxfY2xvc2VfY2hhbm5lbCIsImNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlIiwiZXhuIiwiZm9yY2UiLCJjYW1sX3N5c19pc2F0dHkiLCJfY2hhbiIsImlzX2RpZ2l0X3plcm8iLCJ1bml4X2luZXRfYWRkcl9vZl9zdHJpbmciLCJjYW1sX2pzX3NldCIsImNhbWxfYXJyYXlfZ2V0IiwiYXJyYXkiLCJpbmRleCIsImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlIiwiY2FtbF9pbnQ2NF9zdWIiLCJjYW1sX21sX3NlZWtfaW5fNjQiLCJjYW1sX2ludDY0X3NoaWZ0X2xlZnQiLCJjYW1sX25vdGVxdWFsIiwiY2FtbF9zeXNfY29uc3RfaW50X3NpemUiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayIsImNhbWxfaXNfanMiLCJjYW1sX2JhX2RpbSIsImNhbWxfYmFfZGltXzEiLCJ1bml4X2xvY2FsdGltZSIsImRfbnVtIiwiamFudWFyeWZpcnN0IiwiZG95IiwiamFuIiwianVsIiwic3RkVGltZXpvbmVPZmZzZXQiLCJjYW1sX2pzX21ldGhfY2FsbCIsImNhbWxfd2Vha19jcmVhdGUiLCJjYW1sX2VwaGVfY3JlYXRlIiwiY2FtbF9qc190b19ieXRlX3N0cmluZyIsInVuaXhfbWt0aW1lIiwidG0iLCJ0bTIiLCJjYW1sX3RyYW1wb2xpbmUiLCJjYW1sX2J5dGVzX2dldDY0IiwiY2FtbF93ZWFrX3NldCIsImNhbWxfc3lzX3JlbW92ZSIsImNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yIiwiY2FtbF9zdHJpbmdfZ2V0MzIiLCJjYW1sX2h5cG90X2Zsb2F0IiwiY2FtbF9qc19jYWxsIiwiY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSIsImNhbWxfZXBoZV91bnNldF9rZXkiLCJjYW1sX2hhc2hfbWl4X2J5dGVzX2FyciIsImNhbWxfaGFzaF9taXhfanNieXRlcyIsImNhbWxfaGFzaF9taXhfYnl0ZXMiLCJjYW1sX2J5dGVzX2xlc3N0aGFuIiwiY2FtbF9ncl9maWxsX3BvbHkiLCJhciIsImNhbWxfZ2NfcXVpY2tfc3RhdCIsImNhbWxfcmFpc2VfZW5kX29mX2ZpbGUiLCJjYW1sX21sX2lucHV0X2ludCIsImNhbWxfZ3JfZGlzcGxheV9tb2RlIiwibnRoX2RpZ2l0X25hdCIsImNhbWxfYXJyYXlfYmxpdCIsImExIiwiY2FtbF9mbG9hdF9vZl9zdHJpbmciLCJtMyIsIm1hbnRpc3NhIiwicGFyc2VJbnQiLCJleHBvbmVudCIsImNhbWxfc3lzX2dldGN3ZCIsImNhbWxfc3lzX2NvbnN0X2JpZ19lbmRpYW4iLCJjYW1sX2xpc3RfdG9fanNfYXJyYXkiLCJjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSIsImNhbWxfb3V0cHV0X3ZhbCIsIldyaXRlciIsInZhbHVlIiwiZmxhZ3MiLCJub19zaGFyaW5nIiwiY2xvc3VyZXMiLCJpbnRlcm5fb2JqX3RhYmxlIiwibWVtbyIsImV4aXN0aW5nX29mZnNldCIsImV4dGVybl9yZWMiLCJvcHMiLCJzel8zMl82NCIsImhlYWRlcl9wb3MiLCJvbGRfcG9zIiwidHlwZV9vZl92IiwiY2FtbF9zdHJpbmdfb2ZfYXJyYXkiLCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmciLCJjYW1sX3JhaXNlX25vdF9hX2RpciIsImNhbWxfc3lzX3N5c3RlbV9jb21tYW5kIiwiY21kIiwidW5peF9pc2F0dHkiLCJmaWxlRGVzY3JpcHRvciIsInR0eSIsImNhbWxfanNfZXJyb3Jfb2ZfZXhjZXB0aW9uIiwiZGVzZXJpYWxpemVfbmF0IiwiaW5pdGlhbGl6ZV9uYXQiLCJjYW1sX2dyX29wZW5fc3Vid2luZG93IiwianNfcHJpbnRfc3Rkb3V0IiwiY2FtbF9jb3B5c2lnbl9mbG9hdCIsImNhbWxfZ3Jfc2V0X3RleHRfc2l6ZSIsImNhbWxfbWQ1X2J5dGVzIiwiYWRkIiwieHgiLCJmZiIsImdnIiwiaGgiLCJpaSIsIm1kNSIsImNhbWxfYmFfc2V0X2dlbmVyaWMiLCJjYW1sX2VwaGVfc2V0X2tleSIsImNhbWxfYnl0ZXNfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfbGVzc2VxdWFsIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsIiwiY2FtbF9pbnQ2NF9hZGQiLCJjYW1sX25leHRhZnRlcl9mbG9hdCIsImJpdHMiLCJvbmUiLCJjYW1sX2dyX3NpemVfeSIsImNhbWxfbWxfcG9zX2luIiwiY2FtbF9pbnQ2NF9hbmQiLCJjYW1sX3N5c19jb25zdF93b3JkX3NpemUiLCJjYW1sX3N0ZF9vdXRwdXQiLCJzbGVuIiwianNfcHJpbnRfc3RkZXJyIiwiY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCIsImluZm8iLCJjYW1sX3N5c19vcGVuIiwiX3Blcm1zIiwiTWxTdHJpbmdSZWFkZXIiLCJjYW1sX2Zsb2F0X29mX2J5dGVzIiwiY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciIsIl9tYWdpYyIsIl9ibG9ja19sZW4iLCJudW1fb2JqZWN0cyIsIl9zaXplXzMyIiwiX3NpemVfNjQiLCJvYmpfY291bnRlciIsImludGVybl9yZWMiLCJoZWFkZXIiLCJleHBlY3RlZF9zaXplIiwiY2FtbF9zdHJpbmdfb2ZfYnl0ZXMiLCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMiLCJjYW1sX3N0cmluZ19nZXQiLCJyZV9tYXRjaCIsInJlX3dvcmRfbGV0dGVycyIsIm9wY29kZXMiLCJpc193b3JkX2xldHRlciIsImluX2JpdHNldCIsInJlX21hdGNoX2ltcGwiLCJwYXJ0aWFsIiwicHJvZyIsImNwb29sIiwibm9ybXRhYmxlIiwibnVtZ3JvdXBzIiwibnVtcmVnaXN0ZXJzIiwic3RhcnRjaGFycyIsInBjIiwicXVpdCIsImdyb3VwcyIsInJlX3JlZ2lzdGVyIiwiYmFja3RyYWNrIiwiaXRlbSIsInB1c2giLCJhY2NlcHQiLCJyZXN1bHQiLCJwcmVmaXhfbWF0Y2giLCJvcCIsInNhcmciLCJ1YXJnIiwiZ3JvdXAiLCJFcnJvciIsInJlX3NlYXJjaF9iYWNrd2FyZCIsImNhbWxfanNfZnJvbV9zdHJpbmciLCJjYW1sX2JhX3N1YiIsImNoYW5nZWRfZGltIiwibXVsIiwibmV3X2RpbXMiLCJuZXdfZGF0YSIsImNhbWxfZ2NfZnVsbF9tYWpvciIsImNhbWxfYnl0ZXNfc2V0MzIiLCJpMzIiLCJjYW1sX2dyX3NpZ2lvX3NpZ25hbCIsImNhbWxfYmFfdWludDhfc2V0MzIiLCJjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCIsImNhbWxfc2lnbmJpdF9mbG9hdCIsImNhbWxfZ3JfY3VycmVudF94IiwiY2FtbF9ncl9zZXRfbGluZV93aWR0aCIsImNhbWxfZ3Jfc2V0X2ZvbnQiLCJjYW1sX2dyX3NldF9jb2xvciIsImNvbnZlcnQiLCJudW1iZXIiLCJjX3N0ciIsImNhbWxfZ3JfbW92ZXRvIiwiY2FtbF9ncl9yZXNpemVfd2luZG93IiwiY2FtbF9ncl9zdGF0ZV9pbml0IiwiY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IiwidGEiLCJjYW1sX2JhX2Zyb21fdHlwZWRfYXJyYXkiLCJjYW1sX21sX3NlZWtfb3V0IiwiY2FtbF9qc190eXBlb2YiLCJjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZSIsImJ0IiwiY2FtbF9ncl9saW5ldG8iLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUiLCJjYW1sX2JhX2RpbV8zIiwiY2FtbF9lcGhlX2RhdGFfb2Zmc2V0IiwiY2FtbF9lcGhlX2NoZWNrX2RhdGEiLCJjYW1sX2J5dGVzX2dldDE2IiwiY2FtbF9vYmpfbWFrZV9mb3J3YXJkIiwiY2FtbF9qc19mcm9tX2Jvb2wiLCJjYW1sX21sX3NldF9jaGFubmVsX25hbWUiLCJjYW1sX2dyX2Nsb3NlX2dyYXBoIiwiY2FtbF9jcmVhdGVfc3RyaW5nIiwiY2FtbF9tZDVfc3RyaW5nIiwiY2FtbF9tZDVfY2hhbiIsImNoYW5fbGVuIiwiY2FtbF9vYmpfZHVwIiwiY2FtbF93ZWFrX2dldF9jb3B5IiwiY2FtbF9tbF9vdXRwdXRfYnl0ZXMiLCJzdHJpbmciLCJqc3N0cmluZyIsImlkIiwiY2FtbF9tbF9vdXRwdXQiLCJjYW1sX2VwaGVfZ2V0X2RhdGEiLCJjYW1sX3htbGh0dHByZXF1ZXN0X2NyZWF0ZSIsInVuaXQiLCJjYW1sX3RyYW1wb2xpbmVfcmV0dXJuIiwiY2FtbF9hcnJheV9hcHBlbmQiLCJsMSIsImwyIiwiY2FtbF9tbF9zZXRfY2hhbm5lbF9yZWZpbGwiLCJjYW1sX2pzX2V4cHIiLCJjYW1sX2ludDY0X211bCIsImNhbWxfbWxfcnVudGltZV93YXJuaW5nc19lbmFibGVkIiwiY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMiLCJjYW1sX2hhc2hfdW5pdl9wYXJhbSIsImNvdW50IiwibGltaXQiLCJvYmoiLCJoYXNoX2FjY3UiLCJoYXNoX2F1eCIsImpzYnl0ZXMiLCJjYW1sX3N0cmluZ19lcXVhbCIsImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciIsInJlX3JlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsImN1ciIsInN0YXJ0IiwiZW5kIiwiY2FtbF9wdXJlX2pzX2V4cHIiLCJibGl0X25hdCIsImNhbWxfaW50NjRfdWx0IiwiY2FtbF9pbnQ2NF94b3IiLCJjYW1sX2JpZ3N0cmluZ19ibGl0X2JhX3RvX2J5dGVzIiwiYmExIiwiYnl0ZXMyIiwiY2FtbF9yZWdpc3Rlcl9uYW1lZF92YWx1ZSIsImNhbWxfdG9fanNfc3RyaW5nIiwiY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIiwiY2FtbF9wYXJzZV9kaWdpdCIsImNhbWxfaW50NjRfb2Zfc3RyaW5nIiwiYmFzZTY0IiwidGhyZXNob2xkIiwicmVfc2VhcmNoX2ZvcndhcmQiLCJjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfbWFrZV92ZWN0IiwiaW5pdCIsImNhbWxfbWxfc2Vla19pbiIsImNhbWxfc3lzX3JlYWRfZGlyZWN0b3J5IiwiY2FtbF9tbF9vdXRwdXRfY2hhciIsImNhbWxfc3lzX2NvbnN0X29zdHlwZV93aW4zMiIsImNhbWxfb2JqX2lzX2Jsb2NrIiwiY2FtbF9tbF9pbnB1dF9jaGFyIiwiY2FtbF9vYmpfc2V0X3Jhd19maWVsZCIsImNhbWxfanNfdmFyIiwiY2FtbF90cnVuY19mbG9hdCIsImNhbWxfZXBoZV9ibGl0X2RhdGEiLCJjYW1sX2lzX3ByaW50YWJsZSIsImNhbWxfZXF1YWwiLCJyZV9wYXJ0aWFsX21hdGNoIiwiY2FtbF9zeXNfcmFuZG9tX3NlZWQiLCJub3ciLCJjYW1sX2ZpbmFsX3JlZ2lzdGVyX2NhbGxlZF93aXRob3V0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMiIsIndpbl9oYW5kbGVfZmQiLCJjYW1sX2JhX3VpbnQ4X3NldDE2IiwiY2FtbF9qc19kZWxldGUiLCJjYW1sX2ludF9vZl9zdHJpbmciLCJjYW1sX2xpc3RfbW91bnRfcG9pbnQiLCJwcmV2IiwiY2FtbF9tYXJzaGFsX2NvbnN0YW50cyIsImNhbWxfb2JqX3Jhd19maWVsZCIsImNhbWxfanNfZXF1YWxzIiwiYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IiwiY2FtbF9ncl9hcmNfYXV4IiwiY3R4IiwiY3giLCJjeSIsInJ5IiwicngiLCJyb3QiLCJ4UG9zIiwieVBvcyIsInhQb3NfcHJldiIsInlQb3NfcHJldiIsInNwYWNlIiwiZGVsdGEiLCJjYW1sX2dyX2ZpbGxfYXJjIiwiY2FtbF9iYV9zbGljZSIsIm51bV9pbmRzIiwic3ViX2RpbXMiLCJjYW1sX21hcnNoYWxfZGF0YV9zaXplIiwiZ2V0MzIiLCJjYW1sX2lucHV0X3ZhbHVlIiwiY2FtbF9iYV9raW5kIiwiY2FtbF9qc19mdW5fY2FsbCIsImNhbWxfanNfcHVyZV9leHByIiwiY29tcGFyZV9kaWdpdHNfbmF0IiwiY2FtbF9tbF9pbnB1dCIsImNhbWxfZ3Jfd2FpdF9ldmVudCIsIl9ldmwiLCJjYW1sX2dyX3NpZ2lvX2hhbmRsZXIiLCJjYW1sX2hhc2hfbWl4X2JpZ3N0cmluZyIsImNhbWxfcmVjb3JkX2JhY2t0cmFjZSIsInVuaXhfZ210aW1lIiwiY2FtbF9zeXNfZ2V0X2NvbmZpZyIsImNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSIsInVuaXhfdGltZSIsImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QiLCJiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIiwiYWIiLCJjYW1sX21vZCIsImNhbWxfYmFfaW5pdCIsInJlX3N0cmluZ19tYXRjaCIsIkJpZ1N0cmluZ1JlYWRlciIsImNhbWxfZ3JfZHVtcF9pbWFnZSIsImNhbWxfYmFfZ2V0X2dlbmVyaWMiLCJjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIiwiY2FtbF9mb3JtYXRfZmxvYXQiLCJ0b0ZpeGVkIiwiZHAiLCJwcmVjIiwiY2FtbF9tb3VudF9hdXRvbG9hZCIsImNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmEiLCJjYW1sX2JsaXRfYmlnc3RyaW5nX3RvX2JpZ3N0cmluZyIsImNhbWxfc3RyaW5nX2xlc3N0aGFuIiwiY2FtbF9zdHJpbmdfZ3JlYXRlcnRoYW4iLCJjYW1sX2RpdiIsImNhbWxfZXBoZV9nZXRfZGF0YV9jb3B5IiwiY2FtbF9tZW1wcm9mX3N0YXJ0IiwicmF0ZSIsInN0YWNrX3NpemUiLCJ0cmFja2VyIiwiY2FtbF9zeXNfZ2V0X2FyZ3YiLCJjYW1sX2pzX3RvX2Jvb2wiLCJjYW1sX2dyX2NyZWF0ZV9pbWFnZSIsImNhbWxfZXBoZV9nZXRfa2V5X2NvcHkiLCJjYW1sX2xlc3N0aGFuIiwiY2FtbF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCIsImNhbWxfcmVnaXN0ZXJfZ2xvYmFsIiwibmFtZV9vcHQiLCJtdWx0X25hdCIsImxlbjMiLCJzcXVhcmVfbmF0IiwiY2FtbF9qc19mcm9tX2Zsb2F0IiwiY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSIsImNhbWxfZ2Nfc3RhdCIsImNhbWxfc3lzX21vZGlmeV9hcmd2IiwiY2FtbF9tZXRob2RfY2FjaGUiLCJjYW1sX2dldF9wdWJsaWNfbWV0aG9kIiwiY2FjaGVpZCIsIm1ldGhzIiwibGkiLCJjYW1sX2pzX2dldF9jb25zb2xlIiwiY2FtbF9zeXNfdW5zYWZlX2dldGVudiIsImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luIiwiY2hhbm5lbCIsImJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSIsImNhbWxfcm91bmRfZmxvYXQiLCJjYW1sX29qc19uZXdfYXJyIiwiRiIsImNvbXBsZW1lbnRfbmF0IiwiY2FtbF9qc19yZWdleHBzIiwiY2FtbF9qc19odG1sX2VzY2FwZSIsImNhbWxfYmFfZGltXzIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMiLCJjYW1sX3NpbmhfZmxvYXQiLCJjYW1sX2xkZXhwX2Zsb2F0IiwiY2FtbF9ncl9zdGF0ZV9zZXQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2tfc3RyaWN0IiwiYXJpdHkiLCJjYW1sX2JhX3NldF8xIiwiY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2siLCJsYW5kX2RpZ2l0X25hdCIsImNhbWxfaW50NjRfbW9kIiwiY2FtbF9vYmpfc2V0X3RhZyIsImNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuIiwiY2FtbF9pbnQzMl9ic3dhcCIsIndpbl9zdGFydHVwIiwiY2FtbF9iYV9zZXRfMyIsImNhbWxfanNfaW5zdGFuY2VvZiIsImNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nIiwibnRoX2RpZ2l0X25hdF9uYXRpdmUiLCJzZXRfZGlnaXRfbmF0X25hdGl2ZSIsImRpZ2l0IiwiY2FtbF9zdHJpbmdfc2V0NjQiLCJjYW1sX2dyX3N0YXRlX2NyZWF0ZSIsImNhbnZhcyIsImNvbnRleHQiLCJjYW1sX2pzX3dyYXBfY2FsbGJhY2siLCJjYW1sX2dyX2RyYXdfYXJjIiwiY2FtbF9iYV9tYXBfZmlsZSIsInZmZCIsInNoYXJlZCIsImNhbWxfYmFfbWFwX2ZpbGVfYnl0ZWNvZGUiLCJhcmduIiwiY2FtbF9iYV9jcmVhdGVfZnJvbSIsImRhdGExIiwiZGF0YTIiLCJqc3R5cCIsImNhbWxfdGFuaF9mbG9hdCIsImNhbWxfZ3JfZHJhd19zdHIiLCJkeCIsImNhbWxfZ3JfZHJhd19zdHJpbmciLCJjYW1sX2dyX2RyYXdfY2hhciIsImNhbWxfdW5tb3VudCIsImNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmciLCJjYW1sX21sX3Bvc19pbl82NCIsImNhbWxfZ3JfZHJhd19pbWFnZSIsImltYWdlIiwiY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUiLCJfY2hhbm5lbCIsImNhbWxfc3RyaW5nX3NldCIsImNhbWxfbWxfcG9zX291dCIsImNhbWxfc3BhY2V0aW1lX2VuYWJsZWQiLCJjYW1sX2J5dGVzX25vdGVxdWFsIiwiY2FtbF9ydW50aW1lX3BhcmFtZXRlcnMiLCJjYW1sX2pzX29iamVjdCIsImNhbWxfYmFfY3JlYXRlIiwiZGltc19tbCIsImNhbWxfd2Vha19ibGl0IiwiY2FtbF9ncl9yZW1lbWJlcl9tb2RlIiwiY2FtbF9ic3dhcDE2IiwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUiLCJtb2RlIiwiY2FtbF9maW5hbF9yZWdpc3RlciIsImNhbWxfZ3JfZHJhd19yZWN0IiwiY2FtbF9zdHJpbmdfZ2V0MTYiLCJjYW1sX2VwaGVfdW5zZXRfZGF0YSIsImNhbWxfb3V0cHV0X3ZhbHVlIiwiY2FtbF9iYV9nZXRfMyIsImNhbWxfZXBoZV9ibGl0X2tleSIsImNhbWxfaW5pdGlhbF90aW1lIiwiY2FtbF9zeXNfdGltZSIsImNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbiIsImNhbWxfY2hlY2tfYm91bmQiLCJjYW1sX2hhc2hfbWl4X3N0cmluZyIsImNhbWxfaGFzaCIsInNlZWQiLCJxdWV1ZSIsInJkIiwid3IiLCJjYW1sX29ial90YWciLCJGdW5jdGlvbiIsImNhbWxfYmFfdG9fdHlwZWRfYXJyYXkiLCJjYW1sX2pzX2V4cG9ydF92YXIiLCJtb2R1bGUiLCJjYW1sX2J5dGVzX2dldDMyIiwiY2FtbF9mcmV4cF9mbG9hdCIsIm5lZyIsImNhbWxfc3RyaW5nX2dldDY0IiwiY2FtbF9tbF9wb3Nfb3V0XzY0IiwiY2FtbF9ncl9jbG9zZV9zdWJ3aW5kb3ciLCJjYW1sX2Zsb2F0YXJyYXlfYmxpdCIsImNhbWxfc2V0X3N0YXRpY19lbnYiLCJjYW1sX2JhX2NoYW5nZV9sYXlvdXQiLCJjYW1sX2pzX25ldyIsImNhbWxfZ3JfY3VycmVudF95IiwiY2FtbF9mb3JtYXRfaW50IiwiY2FtbF9vYmpfdHJ1bmNhdGUiLCJjYW1sX2pzX3RvX3N0cmluZyIsImlzX2RpZ2l0X29kZCIsImNhbWxfcnVudGltZV92YXJpYW50IiwiY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3Jfb3V0IiwiY2FtbF9hcnJheV9jb25jYXQiLCJjYW1sX2dyX29wZW5fZ3JhcGgiLCJnZXQiLCJzcGVjcyIsInRhcmdldCIsInN0YXR1cyIsIndpbiIsImRvYyIsInRpdGxlIiwiYm9keSIsImNhbWxfZXBoZV9zZXRfZGF0YSIsImNhbWxfbWFrZV9mbG9hdF92ZWN0IiwiY2FtbF9tZW1wcm9mX3N0b3AiLCJjYW1sX2dyZWF0ZXJlcXVhbCIsImNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIiwiY2FtbF9sb2cxcF9mbG9hdCIsImNhbWxfaW50NjRfb3IiLCJjYW1sX2xhenlfbWFrZV9mb3J3YXJkIiwibG9yX2RpZ2l0X25hdCIsImNhbWxfZ3JfYmxpdF9pbWFnZSIsImltMiIsImNhbWxfZ3Jfd2luZG93X2lkIiwiY2FtbF9qc19vbl9pZSIsInVhIiwiY2FtbF9pbnQ2NF9zaGlmdF9yaWdodCIsImNhbWxfYmFfbGF5b3V0IiwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2UiLCJjYW1sX2FycmF5X3NldCIsIm5ld3ZhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsIiwic2V0X2RpZ2l0X25hdCIsImNhbWxfdXBkYXRlX2R1bW15IiwiY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZCIsInJlYWwiLCJjYW1sX2dyX2RvY19vZl9zdGF0ZSIsImNhbWxfbWxfb3V0cHV0X2ludCIsImNhbWxfb2JqX3dpdGhfdGFnIiwiY2FtbF9tbF9jaGFubmVsX3NpemUiLCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCIsImNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0Iiwic3R5bGUiLCJleHBfc2lnbiIsInNpZ25fc3RyIiwiY3N0IiwieF9zdHIiLCJjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QiLCJjYW1sX2JhY2t0cmFjZV9zdGF0dXMiLCJjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIiLCJjYW1sX3N5c19hcmd2IiwiY2FtbF9iYV9maWxsIiwiY2FtbF9tb2RmX2Zsb2F0IiwiY2FtbF9nY19nZXQiLCJjYW1sX2Zsb2F0X2NvbXBhcmUiLCJjYW1sX3N0cmluZ19zZXQzMiIsImNhbWxfcGFyc2VfZW5naW5lIiwidGFibGVzIiwiZW52IiwiRVJSQ09ERSIsInRlc3RzaGlmdCIsInNoaWZ0Iiwic2hpZnRfcmVjb3ZlciIsInJlZHVjZSIsIlJFQURfVE9LRU4iLCJSQUlTRV9QQVJTRV9FUlJPUiIsIkdST1dfU1RBQ0tTXzEiLCJHUk9XX1NUQUNLU18yIiwiQ09NUFVURV9TRU1BTlRJQ19BQ1RJT04iLCJDQUxMX0VSUk9SX0ZVTkNUSU9OIiwiZW52X3Nfc3RhY2siLCJlbnZfdl9zdGFjayIsImVudl9zeW1iX3N0YXJ0X3N0YWNrIiwiZW52X3N5bWJfZW5kX3N0YWNrIiwiZW52X3N0YWNrc2l6ZSIsImVudl9zdGFja2Jhc2UiLCJlbnZfY3Vycl9jaGFyIiwiZW52X2x2YWwiLCJlbnZfc3ltYl9zdGFydCIsImVudl9zeW1iX2VuZCIsImVudl9hc3AiLCJlbnZfcnVsZV9sZW4iLCJlbnZfcnVsZV9udW1iZXIiLCJlbnZfc3AiLCJlbnZfc3RhdGUiLCJlbnZfZXJyZmxhZyIsInRibF90cmFuc2xfY29uc3QiLCJ0YmxfdHJhbnNsX2Jsb2NrIiwidGJsX2xocyIsInRibF9sZW4iLCJ0YmxfZGVmcmVkIiwidGJsX2Rnb3RvIiwidGJsX3NpbmRleCIsInRibF9yaW5kZXgiLCJ0YmxfZ2luZGV4IiwidGJsX3RhYmxlc2l6ZSIsInRibF90YWJsZSIsInRibF9jaGVjayIsIm4xIiwibjIiLCJzdGF0ZTEiLCJzcCIsImVycmZsYWciLCJhc3AiLCJjYW1sX2FycmF5X2ZpbGwiLCJjYW1sX3N0cmluZ19ub3RlcXVhbCIsImNhbWxfYnl0ZXNfZ3JlYXRlcnRoYW4iLCJjYW1sX2dyX21ha2VfaW1hZ2UiLCJjYW1sX21sX3NldF9jaGFubmVsX291dHB1dCIsImNhbWxfcmVhZF9maWxlX2NvbnRlbnQiLCJjYW1sX2pzX3RvX2Zsb2F0IiwiZXJyX25vX3ByZWQiLCJlcnJfbm9fc3VjYyIsInplcm8kMiIsIm9uZSQyIiwibWludXNfb25lJDIiLCJtaW5faW50JDIiLCJtYXhfaW50JDIiLCJkdW1teV9wb3MiLCJ6ZXJvX3BvcyIsInN1Yl9mb3JtYXQiLCJmb3JtYXR0aW5nX2xpdCIsImxvY2ZtdCIsIm51bGwkMCIsImN1cnJlbnRfZGlyX25hbWUiLCJwYXJlbnRfZGlyX25hbWUiLCJkaXJfc2VwIiwicXVvdGVxdW90ZSIsIm51bGwkMSIsImN1cnJlbnRfZGlyX25hbWUkMCIsInBhcmVudF9kaXJfbmFtZSQwIiwiZGlyX3NlcCQwIiwibnVsbCQyIiwiY3VycmVudF9kaXJfbmFtZSQxIiwicGFyZW50X2Rpcl9uYW1lJDEiLCJkaXJfc2VwJDEiLCJ6ZXJvJDQiLCJvbmUkNCIsImkiLCJlcmFzZV9yZWwiLCJyZXN0IiwicmVzdCQwIiwicmVzdCQxIiwicmVzdCQyIiwicmVzdCQzIiwicmVzdCQ0IiwicmVzdCQ1IiwicmVzdCQ2IiwicmVzdCQ3IiwidHkiLCJyZXN0JDgiLCJ0eTEiLCJyZXN0JDkiLCJyZXN0JDEwIiwicmVzdCQxMSIsInJlc3QkMTIiLCJyZXN0JDEzIiwiY29uY2F0X2ZtdHR5IiwiZm10dHkxIiwiZm10dHkyIiwidHkyIiwiY29uY2F0X2ZtdCIsImZtdDEiLCJmbXQyIiwicGFkIiwicGFkJDAiLCJwcmVjIiwicGFkJDEiLCJpY29udiIsInByZWMkMCIsInBhZCQyIiwiaWNvbnYkMCIsInByZWMkMSIsInBhZCQzIiwiaWNvbnYkMSIsInByZWMkMiIsInBhZCQ0IiwiaWNvbnYkMiIsInByZWMkMyIsInBhZCQ1IiwiZmNvbnYiLCJwYWQkNiIsInN0ciIsImNociIsImZtdHR5IiwicGFkJDciLCJmbXR0eSQwIiwicGFkJDgiLCJyZXN0JDE0IiwicmVzdCQxNSIsInJlc3QkMTYiLCJmbXRpbmdfbGl0IiwicmVzdCQxNyIsImZtdGluZ19nZW4iLCJyZXN0JDE4IiwicmVzdCQxOSIsImNoYXJfc2V0Iiwid2lkdGhfb3B0IiwicmVzdCQyMCIsImNvdW50ZXIiLCJyZXN0JDIxIiwicmVzdCQyMiIsImlnbiIsInJlc3QkMjMiLCJmIiwiYXJpdHkiLCJmYWlsd2l0aCIsInMiLCJpbnZhbGlkX2FyZyIsIm1pbiIsIngiLCJ5IiwibWF4IiwiYWJzIiwibG5vdCIsImluZmluaXR5IiwibmVnX2luZmluaXR5IiwibmFuIiwibWF4X2Zsb2F0IiwibWluX2Zsb2F0IiwiZXBzaWxvbiIsIm1heF9pbnQiLCJtaW5faW50Iiwic3ltYm9sIiwiczEiLCJzMiIsImwxIiwibDIiLCJjaGFyX29mX2ludCIsIm4iLCJzdHJpbmdfb2ZfYm9vbCIsImIiLCJib29sX29mX3N0cmluZyIsImJvb2xfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9pbnQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInZhbGlkX2Zsb2F0X2xleGVtIiwibCIsImkkMCIsInRvX3N0cmluZyIsIm9mX3N0cmluZ19vcHQiLCJhcHBlbmQiLCJ0bCIsImhkIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJvcGVuX291dF9nZW4iLCJtb2RlIiwicGVybSIsIm5hbWUiLCJjIiwib3Blbl9vdXQiLCJvcGVuX291dF9iaW4iLCJmbHVzaF9hbGwiLCJpdGVyIiwiYSIsIm91dHB1dF9ieXRlcyIsIm9jIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dCIsIm9mcyIsImxlbiIsIm91dHB1dF9zdWJzdHJpbmciLCJvdXRwdXRfdmFsdWUiLCJjaGFuIiwidiIsImNsb3NlX291dCIsImNsb3NlX291dF9ub2VyciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbiIsIm9wZW5faW5fYmluIiwiaW5wdXQiLCJpYyIsInVuc2FmZV9yZWFsbHlfaW5wdXQiLCJvZnMkMCIsImxlbiQwIiwiciIsImxlbiQxIiwib2ZzJDEiLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwiaW5wdXRfbGluZSIsImJ1aWxkX3Jlc3VsdCIsImJ1ZiIsImFjY3UiLCJiZWciLCJhY2N1JDAiLCJyZXMiLCJjbG9zZV9pbl9ub2VyciIsInByaW50X2NoYXIiLCJwcmludF9zdHJpbmciLCJwcmludF9ieXRlcyIsInByaW50X2ludCIsInByaW50X2Zsb2F0IiwicHJpbnRfZW5kbGluZSIsInByaW50X25ld2xpbmUiLCJwcmVycl9jaGFyIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfYnl0ZXMiLCJwcmVycl9pbnQiLCJwcmVycl9mbG9hdCIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9uZXdsaW5lIiwicmVhZF9saW5lIiwicmVhZF9pbnQiLCJyZWFkX2ludF9vcHQiLCJyZWFkX2Zsb2F0IiwicmVhZF9mbG9hdF9vcHQiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic3ltYm9sJDAiLCJzdHIyIiwic3RyMSIsImV4aXRfZnVuY3Rpb24iLCJhdF9leGl0IiwiZyIsImZfYWxyZWFkeV9yYW4iLCJkb19hdF9leGl0IiwiZXhpdCIsInJldGNvZGUiLCJzZXRfYmluYXJ5X21vZGVfaW4iLCJjbG9zZV9pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwicG9zX2luIiwic2Vla19pbiIsImlucHV0X3ZhbHVlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X2J5dGUiLCJpbnB1dF9jaGFyIiwic2V0X2JpbmFyeV9tb2RlX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsInBvc19vdXQiLCJzZWVrX291dCIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfY2hhciIsImZsdXNoIiwiZW1wdHkiLCJyZXR1cm4kMCIsImNvbnMiLCJuZXh0IiwiYXBwZW5kJDAiLCJzZXExIiwic2VxMiIsIm1hcCIsInNlcSIsImZpbHRlcl9tYXAiLCJzZXEkMCIsImZpbHRlciIsImZsYXRfbWFwJDAiLCJmbGF0X21hcF9hcHAkMCIsInRhaWwiLCJmbGF0X21hcF9hcHAiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImFjYyIsImFjYyQwIiwiYWNjJDEiLCJ1bmZvbGQiLCJ1IiwidSQwIiwibm9uZSIsInNvbWUiLCJ2YWx1ZSIsIm8iLCJkZWZhdWx0JDAiLCJnZXQiLCJiaW5kIiwiam9pbiIsIm1hcCQwIiwiZm9sZCIsIml0ZXIkMCIsImlzX25vbmUiLCJpc19zb21lIiwiZXF1YWwiLCJlcSIsIm8wIiwibzEiLCJ2MSIsInYwIiwiY29tcGFyZSIsImNtcCIsInRvX3Jlc3VsdCIsInRvX2xpc3QiLCJ0b19zZXEiLCJvayIsImVycm9yIiwiZSIsInZhbHVlJDAiLCJnZXRfb2siLCJnZXRfZXJyb3IiLCJiaW5kJDAiLCJqb2luJDAiLCJtYXAkMSIsIm1hcF9lcnJvciIsImZvbGQkMCIsIml0ZXIkMSIsIml0ZXJfZXJyb3IiLCJpc19vayIsImlzX2Vycm9yIiwiZXF1YWwkMCIsInIwIiwibWF0Y2giLCJlMSIsImNvbXBhcmUkMCIsInRvX29wdGlvbiIsInRvX2xpc3QkMCIsInRvX3NlcSQwIiwiZXF1YWwkMSIsImNvbXBhcmUkMSIsInRvX2Zsb2F0IiwidG9fc3RyaW5nJDAiLCJlc2NhcGVkIiwicyQwIiwibG93ZXJjYXNlIiwidXBwZXJjYXNlIiwibG93ZXJjYXNlX2FzY2lpIiwidXBwZXJjYXNlX2FzY2lpIiwiY29tcGFyZSQyIiwiYzEiLCJjMiIsImVxdWFsJDIiLCJtaW4kMCIsIm1heCQwIiwibG9fYm91bmQiLCJoaV9ib3VuZCIsImJvbSIsInJlcCIsInN1Y2MiLCJwcmVkIiwiaXNfdmFsaWQiLCJvZl9pbnQiLCJpc19jaGFyIiwib2ZfY2hhciIsInRvX2NoYXIiLCJ1bnNhZmVfdG9fY2hhciIsImVxdWFsJDMiLCJjb21wYXJlJDMiLCJoYXNoIiwibWF0Y2gkMSIsImxlbmd0aCIsInBhcmFtJDAiLCJjb25zJDAiLCJudGgiLCJsJDAiLCJuJDAiLCJsJDEiLCJuJDEiLCJudGhfb3B0IiwicmV2X2FwcGVuZCIsImwxJDAiLCJsMiQwIiwibDEkMSIsImwyJDEiLCJyZXYiLCJpbml0X2F1eCIsInJldl9pbml0X3RocmVzaG9sZCIsInBhcmFtIiwiYWNjdSQxIiwiYTIiLCJhMSIsInAiLCJwYWlyIiwicmVzdWx0IiwieHMiLCJ4JDAiLCJyeSIsInJ4IiwidDIiLCJoMiIsInQxIiwiaDEiLCJyZXZfc29ydCIsIngyIiwieDEiLCJ0bCQxIiwieDMiLCJ4MiQwIiwieDEkMCIsIm4xIiwibjIiLCJzb3J0IiwidGwkMCIsImMkMCIsImMkMSIsImMkMiIsImMkMyIsImMkNCIsImMkNSIsImMkNiIsImFjY3UkMiIsImF1eCIsImRpcmVjdCIsImRlcHRoIiwic3ltYm9sJDEiLCJsZWZ0IiwicmlnaHQiLCJkc3RvZmYiLCJzcmNvZmYiLCJjcHlsZW4iLCJvZnMxIiwib2ZzMiIsInNlcCIsInNlcGxlbiIsImRzdCIsImlzX3NwYWNlIiwiaiIsImFwcGx5MSIsImluZGV4X3JlYyIsImxpbSIsImkkMSIsImluZGV4X3JlY19vcHQiLCJyaW5kZXhfcmVjIiwicmluZGV4X3JlY19vcHQiLCJuZXdfbGVuIiwibmV3X2J1ZiIsImlzX3NwYWNlJDAiLCJpbmRleF9yZWMkMCIsImluZGV4X3JlY19vcHQkMCIsInJpbmRleF9yZWMkMCIsInJpbmRleF9yZWNfb3B0JDAiLCJlcXVhbCQ2IiwiY29tcGFyZSQ2IiwidG9fc3RyaW5nJDIiLCJ0b19idWZmZXIiLCJidWZmIiwiZmxhZ3MiLCJoZWFkZXJfc2l6ZSIsImRhdGFfc2l6ZSIsInRvdGFsX3NpemUiLCJmcm9tX2J5dGVzIiwiZnJvbV9zdHJpbmciLCJpc19ibG9jayIsImRvdWJsZV9maWVsZCIsInNldF9kb3VibGVfZmllbGQiLCJtYXJzaGFsIiwib2JqIiwidW5tYXJzaGFsIiwicG9zIiwiZmlyc3Rfbm9uX2NvbnN0YW50X2NvbnN0cnVjdG9yIiwibGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfIiwibGF6eV90YWciLCJjbG9zdXJlX3RhZyIsIm9iamVjdF90YWciLCJpbmZpeF90YWciLCJmb3J3YXJkX3RhZyIsIm5vX3NjYW5fdGFnIiwiYWJzdHJhY3RfdGFnIiwic3RyaW5nX3RhZyIsImRvdWJsZV90YWciLCJkb3VibGVfYXJyYXlfdGFnIiwiY3VzdG9tX3RhZyIsImludF90YWciLCJvdXRfb2ZfaGVhcF90YWciLCJ1bmFsaWduZWRfdGFnIiwib2ZfdmFsIiwic2xvdCIsImlkIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwiZXh0ZW5zaW9uX25hbWUiLCJleHRlbnNpb25faWQiLCJtYXhfZXBoZV9sZW5ndGgiLCJjcmVhdGUiLCJsZW5ndGgkMCIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IiwibXNnIiwiZ2V0X2tleSIsImdldF9rZXlfY29weSIsInNldF9rZXkiLCJ1bnNldF9rZXkiLCJjaGVja19rZXkiLCJibGl0X2tleSIsImUyIiwibzIiLCJzeCIsInN5IiwiaW5pdCIsImxhIiwibGIiLCJyZXMkMCIsImxpc3RfbGVuZ3RoIiwicGFyYW0kMSIsImhkJDAiLCJtYXhzb24iLCJpMzEiLCJ0cmlja2xlZG93biIsInRyaWNrbGUiLCJidWJibGVkb3duIiwiYnViYmxlIiwiaSQyIiwiZSQwIiwiZmF0aGVyIiwibWVyZ2UiLCJzcmMxb2ZzIiwic3JjMWxlbiIsInNyYzIiLCJzcmMyb2ZzIiwic3JjMmxlbiIsImRzdG9mcyIsInNyYzFyIiwic3JjMnIiLCJzMiQxIiwiczEkMSIsImkxIiwiaTIiLCJkIiwiaTIkMCIsImQkMCIsInMyJDAiLCJpMSQwIiwiZCQxIiwiczEkMCIsImlzb3J0dG8iLCJzcmNvZnMiLCJzb3J0dG8iLCJ0IiwiemVybyIsIm9uZSIsIm1pbnVzX29uZSIsImlzX2Zpbml0ZSIsImlzX2luZmluaXRlIiwiaXNfbmFuIiwicGkiLCJpc19pbnRlZ2VyIiwic3VjYyQwIiwicHJlZCQwIiwiZXF1YWwkNyIsIm1pbiQxIiwibWF4JDEiLCJtaW5fbWF4IiwibWluX251bSIsIm1heF9udW0iLCJtaW5fbWF4X251bSIsImhhc2gkMCIsInVuc2FmZV9maWxsIiwidW5zYWZlX2JsaXQiLCJzcmMiLCJzb2ZzIiwiZG9mcyIsImNoZWNrIiwibWFrZSQxIiwiaW5pdCQzIiwiYXBwZW5kJDIiLCJjb25jYXQkMiIsImhsZW4iLCJzdWIkMiIsImNvcHkkMiIsImZpbGwkMSIsImJsaXQkMiIsInRvX2xpc3QkMiIsIm9mX2xpc3QkMCIsImgiLCJpdGVyJDYiLCJpdGVyMiQxIiwibWFwJDYiLCJtYXAyJDEiLCJpdGVyaSQzIiwibWFwaSQzIiwiZm9sZF9sZWZ0JDIiLCJmb2xkX3JpZ2h0JDEiLCJleGlzdHMkMSIsImZvcl9hbGwkMSIsIm1lbSQxIiwibWVtX2llZWUiLCJzb3J0JDAiLCJzdGFibGVfc29ydCIsInRvX3NlcSQ1IiwidG9fc2VxaSQyIiwib2Zfc2VxJDMiLCJtYXBfdG9fYXJyYXkiLCJtYXBfZnJvbV9hcnJheSIsInplcm8kMCIsIm9uZSQwIiwibWludXNfb25lJDAiLCJhYnMkMCIsIm1heF9pbnQkMCIsIm1pbl9pbnQkMCIsImxvZ25vdCIsImVxdWFsJDgiLCJjb21wYXJlJDciLCJ0b19zdHJpbmckMyIsInplcm8kMSIsIm9uZSQxIiwibWludXNfb25lJDEiLCJzdWNjJDEiLCJwcmVkJDEiLCJhYnMkMSIsIm1pbl9pbnQkMSIsIm1heF9pbnQkMSIsImxvZ25vdCQwIiwidW5zaWduZWRfdG9faW50IiwidG9fc3RyaW5nJDQiLCJvZl9zdHJpbmdfb3B0JDAiLCJjb21wYXJlJDgiLCJlcXVhbCQ5IiwidW5zaWduZWRfY29tcGFyZSIsIm0iLCJ1bnNpZ25lZF9kaXYiLCJxIiwidW5zaWduZWRfcmVtIiwic3VjYyQyIiwicHJlZCQyIiwiYWJzJDIiLCJsb2dub3QkMSIsIm1heF9pbnQkMyIsInVuc2lnbmVkX3RvX2ludCQwIiwidG9fc3RyaW5nJDUiLCJvZl9zdHJpbmdfb3B0JDEiLCJjb21wYXJlJDkiLCJlcXVhbCQxMCIsInVuc2lnbmVkX2NvbXBhcmUkMCIsInVuc2lnbmVkX2RpdiQwIiwidW5zaWduZWRfcmVtJDAiLCJ6ZXJvJDMiLCJvbmUkMyIsIm1pbnVzX29uZSQzIiwic3VjYyQzIiwicHJlZCQzIiwiYWJzJDMiLCJtaW5faW50JDMiLCJtYXhfaW50JDQiLCJsb2dub3QkMiIsInVuc2lnbmVkX3RvX2ludCQxIiwidG9fc3RyaW5nJDYiLCJvZl9zdHJpbmdfb3B0JDIiLCJjb21wYXJlJDEwIiwiZXF1YWwkMTEiLCJ1bnNpZ25lZF9jb21wYXJlJDEiLCJ1bnNpZ25lZF9kaXYkMSIsInVuc2lnbmVkX3JlbSQxIiwiZW5naW5lIiwidGJsIiwic3RhdGUiLCJuZXdfZW5naW5lIiwiZnJvbV9mdW5jdGlvbiIsIm9wdCIsInN0aCIsIndpdGhfcG9zaXRpb25zIiwiYXV4X2J1ZmZlciIsImxleGJ1ZiIsInJlYWQiLCJuZXdsZW4iLCJuZXdidWYiLCJmcm9tX2NoYW5uZWwiLCJmcm9tX3N0cmluZyQwIiwic2V0X3Bvc2l0aW9uIiwicG9zaXRpb24iLCJzZXRfZmlsZW5hbWUiLCJmbmFtZSIsImxleGVtZSIsInN1Yl9sZXhlbWUiLCJzdWJfbGV4ZW1lX29wdCIsInN1Yl9sZXhlbWVfY2hhciIsInN1Yl9sZXhlbWVfY2hhcl9vcHQiLCJsZXhlbWVfY2hhciIsImxleGVtZV9zdGFydCIsImxleGVtZV9lbmQiLCJsZXhlbWVfc3RhcnRfcCIsImxleGVtZV9lbmRfcCIsIm5ld19saW5lIiwibGNwIiwiZmx1c2hfaW5wdXQiLCJlbnYiLCJncm93X3N0YWNrcyIsIm9sZHNpemUiLCJuZXdzaXplIiwibmV3X3MiLCJuZXdfdiIsIm5ld19zdGFydCIsIm5ld19lbmQiLCJjbGVhcl9wYXJzZXIiLCJjdXJyZW50X2xvb2thaGVhZF9mdW4iLCJ5eXBhcnNlIiwidGFibGVzIiwic3RhcnQiLCJsZXhlciIsImluaXRfYXNwIiwiaW5pdF9zcCIsImluaXRfc3RhY2tiYXNlIiwiaW5pdF9zdGF0ZSIsImluaXRfY3Vycl9jaGFyIiwiaW5pdF9sdmFsIiwiaW5pdF9lcnJmbGFnIiwiY21kIiwiYXJnIiwiYXJnJDAiLCJhcmckMSIsImNtZCQwIiwiZXhuIiwiY3Vycl9jaGFyIiwidG9rIiwicGVla192YWwiLCJzeW1ib2xfc3RhcnRfcG9zIiwic3QiLCJlbiIsInN5bWJvbF9lbmRfcG9zIiwicmhzX3N0YXJ0X3BvcyIsInJoc19lbmRfcG9zIiwic3ltYm9sX3N0YXJ0Iiwic3ltYm9sX2VuZCIsInJoc19zdGFydCIsInJoc19lbmQiLCJpc19jdXJyZW50X2xvb2thaGVhZCIsInBhcnNlX2Vycm9yIiwiaGVpZ2h0IiwiaGwiLCJoJDAiLCJociIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiIsImxybCIsInJyIiwicnYiLCJybCIsInJsciIsInJsdiIsInJsbCIsImFkZCIsInNpbmdsZXRvbiIsImFkZF9taW5fZWxlbWVudCIsImFkZF9tYXhfZWxlbWVudCIsInJoIiwibGgiLCJtaW5fZWx0IiwibWluX2VsdF9vcHQiLCJtYXhfZWx0IiwibWF4X2VsdF9vcHQiLCJyZW1vdmVfbWluX2VsdCIsInIkMCIsImNvbmNhdCIsInNwbGl0IiwicHJlcyIsInByZXMkMCIsImlzX2VtcHR5IiwibWVtIiwicmVtb3ZlIiwidW5pb24iLCJyMiIsInYyIiwicjEiLCJyMiQwIiwicjEkMCIsImludGVyIiwic3BsaXRfYmlzIiwiZGlzam9pbnQiLCJkaWZmIiwiY29uc19lbnVtIiwicyQxIiwiZSQxIiwiZTIkMiIsImUxJDIiLCJlMiQwIiwiZTEkMCIsImUyJDEiLCJlMSQxIiwic3Vic2V0IiwiZm9yX2FsbCIsImV4aXN0cyIsInB2IiwicGFydGl0aW9uIiwibGYiLCJsdCIsInJmIiwicnQiLCJjYXJkaW5hbCIsImVsZW1lbnRzX2F1eCIsImVsZW1lbnRzIiwiZmluZCIsImZpbmRfZmlyc3QiLCJ2JDAiLCJmaW5kX2ZpcnN0X29wdCIsImZpbmRfbGFzdCIsImZpbmRfbGFzdF9vcHQiLCJmaW5kX29wdCIsInRyeV9qb2luIiwidCQwIiwidiQxIiwib2ZfbGlzdCIsInN1YiIsImwkMyIsIngwIiwibCQ0IiwieDAkMCIsImwkNSIsIngwJDEiLCJubCIsIm1pZCIsImwkMiIsIng0IiwiYWRkX3NlcSIsIm9mX3NlcSIsInNlcV9vZl9lbnVtIiwidG9fc2VxX2Zyb20iLCJsb3ciLCJsZCIsImxyZCIsInJkIiwicmxkIiwiZGF0YSIsIm1pbl9iaW5kaW5nIiwibWluX2JpbmRpbmdfb3B0IiwibWF4X2JpbmRpbmciLCJtYXhfYmluZGluZ19vcHQiLCJyZW1vdmVfbWluX2JpbmRpbmciLCJ1cGRhdGUiLCJkYXRhJDAiLCJtYXBpIiwibSQwIiwiYWRkX21pbl9iaW5kaW5nIiwiayIsImFkZF9tYXhfYmluZGluZyIsImNvbmNhdF9vcl9qb2luIiwiZDEiLCJkMiIsImQyJDAiLCJkMSQwIiwiZDIkMSIsImQxJDEiLCJwdmQiLCJmdmQiLCJtJDEiLCJtMSIsIm0yIiwiYmluZGluZ3NfYXV4IiwiYmluZGluZ3MiLCJjcmVhdGUkMCIsImNsZWFyIiwiY29weSQzIiwicHVzaCIsInBvcCIsInBvcF9vcHQiLCJ0b3AiLCJ0b3Bfb3B0IiwibGVuZ3RoJDEiLCJpdGVyJDciLCJmb2xkJDEiLCJ0b19zZXEkNiIsIm9mX3NlcSQ0IiwiY3JlYXRlJDEiLCJjbGVhciQwIiwiY2VsbCIsInBlZWsiLCJjb250ZW50IiwicGVla19vcHQiLCJ0YWtlIiwidGFrZV9vcHQiLCJjb3B5JDQiLCJxX3JlcyIsInByZXYiLCJpc19lbXB0eSQwIiwibGVuZ3RoJDIiLCJpdGVyJDgiLCJmb2xkJDIiLCJ0cmFuc2ZlciIsInExIiwicTIiLCJ0b19zZXEkNyIsImFkZF9zZXEkMCIsIm9mX3NlcSQ1IiwicmFpc2VfdW5kZWZpbmVkIiwiZm9yY2VfbGF6eV9ibG9jayIsImJsayIsImNsb3N1cmUiLCJmb3JjZV92YWxfbGF6eV9ibG9jayIsImZvcmNlIiwibHp2IiwiZm9yY2VfdmFsIiwiZnJvbV9mdW4iLCJmcm9tX3ZhbCIsImlzX3ZhbCIsImNvdW50IiwiZmlsbF9idWZmIiwiZ2V0X2RhdGEiLCJkMTEiLCJhJDAiLCJhJDEiLCJwZWVrX2RhdGEiLCJwZWVrJDAiLCJqdW5rX2RhdGEiLCJqdW5rIiwibmdldF9kYXRhIiwiYWwiLCJucGVlayIsImVtcHR5JDEiLCJpdGVyJDkiLCJzdHJtIiwiZnJvbSIsIm9mX2xpc3QkMSIsIm9mX3N0cmluZyQwIiwib2ZfYnl0ZXMiLCJvZl9jaGFubmVsIiwiaWFwcCIsImljb25zIiwiaXNpbmciLCJsYXBwIiwibGNvbnMiLCJsc2luZyIsInNlbXB0eSIsInNsYXp5IiwiZHVtcF9kYXRhIiwiZHVtcCIsImNyZWF0ZSQyIiwiY29udGVudHMiLCJ0b19ieXRlcyIsInN1YiQzIiwiYmxpdCQzIiwibnRoJDAiLCJsZW5ndGgkMyIsImNsZWFyJDEiLCJyZXNldCIsInJlc2l6ZSIsIm1vcmUiLCJvbGRfcG9zIiwib2xkX2xlbiIsIm5ld19idWZmZXIiLCJhZGRfY2hhciIsImFkZF91dGZfOF91Y2hhciIsInBvcyQwIiwicG9zJDEiLCJhZGRfdXRmXzE2YmVfdWNoYXIiLCJoaSIsImxvIiwiYWRkX3V0Zl8xNmxlX3VjaGFyIiwiYWRkX3N1YnN0cmluZyIsIm9mZnNldCIsIm5ld19wb3NpdGlvbiIsImFkZF9zdWJieXRlcyIsImFkZF9zdHJpbmciLCJhZGRfYnl0ZXMiLCJhZGRfYnVmZmVyIiwiYnMiLCJhZGRfY2hhbm5lbCIsImFscmVhZHlfcmVhZCIsInRvX3JlYWQiLCJhbHJlYWR5X3JlYWQkMCIsInRvX3JlYWQkMCIsIm91dHB1dF9idWZmZXIiLCJhZGRfc3Vic3RpdHV0ZSIsImxpbSQxIiwicHJldmlvdXMiLCJpJDciLCJjdXJyZW50IiwiaSQ4Iiwib3BlbmluZyIsImkkNiIsImxpbSQwIiwiaSQzIiwic3RvcCIsImkkNCIsImkkNSIsImskMiIsImskMCIsImskMSIsIm5leHRfaSIsImlkZW50IiwiaSQ5IiwiaSQxMCIsImkkMTEiLCJ0cnVuY2F0ZSIsInRvX3NlcSQ4IiwidG9fc2VxaSQzIiwiYWRkX3NlcSQxIiwib2Zfc2VxJDYiLCJhZGRfaW50OCIsImFkZF9pbnQxNl9uZSIsImFkZF9pbnQzMl9uZSIsImFkZF9pbnQ2NF9uZSIsImFkZF9pbnQxNl9sZSIsImFkZF9pbnQxNl9iZSIsImFkZF9pbnQzMl9sZSIsImFkZF9pbnQzMl9iZSIsImFkZF9pbnQ2NF9sZSIsImFkZF9pbnQ2NF9iZSIsImNyZWF0ZV9jaGFyX3NldCIsImFkZF9pbl9jaGFyX3NldCIsInN0cl9pbmQiLCJtYXNrIiwiZnJlZXplX2NoYXJfc2V0IiwicmV2X2NoYXJfc2V0IiwiY2hhcl9zZXQkMCIsImlzX2luX2NoYXJfc2V0IiwicGFkX29mX3BhZF9vcHQiLCJwYWRfb3B0Iiwid2lkdGgiLCJwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQiLCJmbXQiLCJwYWRfb3B0JDAiLCJwYWRfb3B0JDEiLCJwYWRfb3B0JDIiLCJwYWRfb3B0JDMiLCJwYWRfb3B0JDQiLCJwcmVjX29wdCIsInBhZF9vcHQkNSIsIm5kZWMiLCJwYWRfb3B0JDYiLCJwYWRfb3B0JDciLCJwYWRfb3B0JDgiLCJkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiIsImJ1ZmZlcl9jcmVhdGUiLCJpbml0X3NpemUiLCJidWZmZXJfY2hlY2tfc2l6ZSIsIm92ZXJoZWFkIiwibWluX2xlbiIsIm5ld19zdHIiLCJidWZmZXJfYWRkX2NoYXIiLCJidWZmZXJfYWRkX3N0cmluZyIsInN0cl9sZW4iLCJidWZmZXJfY29udGVudHMiLCJjaGFyX29mX2ljb252IiwiY2hhcl9vZl9mY29udiIsImNGIiwiYnByaW50X3BhZHR5IiwicGFkdHkiLCJicHJpbnRfaWdub3JlZF9mbGFnIiwiaWduX2ZsYWciLCJicHJpbnRfcGFkX29wdCIsImJwcmludF9wYWRkaW5nIiwicGFkdHkkMCIsImJwcmludF9wcmVjaXNpb24iLCJicHJpbnRfaWNvbnZfZmxhZyIsImJwcmludF9hbHRpbnRfZm10IiwiYnByaW50X2Zjb252X2ZsYWciLCJzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQiLCJzdHIkMCIsImJwcmludF9jaGFyX2xpdGVyYWwiLCJicHJpbnRfc3RyaW5nX2xpdGVyYWwiLCJicHJpbnRfZm10dHkiLCJzdWJfZm10dHkiLCJzdWJfZm10dHkkMCIsImludF9vZl9jdXN0b21fYXJpdHkiLCJzdHJpbmdfb2ZfZm10IiwiZm10JDEiLCJjaHIkMCIsInN0ciQxIiwiaXNfYWxvbmUkMCIsImlzX2Fsb25lIiwiYWZ0ZXIiLCJiZWZvcmUiLCJqJDAiLCJqJDEiLCJmbXQkMCIsInN5bW0iLCJ0cmFucyIsInJlc3QyIiwicmVzdDIkMCIsInJlc3QyJDEiLCJyZXN0MiQyIiwicmVzdDIkMyIsInJlc3QyJDQiLCJyZXN0MiQ1IiwicmVzdDIkNiIsInJlc3QyJDciLCJyZXN0MiQ4IiwidHkyMiIsInR5MjEiLCJmbXR0eV9yZWxfZGV0IiwiZjQiLCJmMiIsInJlc3QyJDkiLCJyZXN0MiQxMCIsInJlc3QyJDExIiwicmVzdDIkMTIiLCJyZXN0MiQxMyIsImRlIiwiZWQiLCJhZiIsImZhIiwiZGUkMCIsImVkJDAiLCJhZiQwIiwiZmEkMCIsImRlJDEiLCJlZCQxIiwiYWYkMSIsImZhJDEiLCJkZSQyIiwiZWQkMiIsImFmJDIiLCJmYSQyIiwiZGUkMyIsImVkJDMiLCJhZiQzIiwiZmEkMyIsImRlJDQiLCJlZCQ0IiwiYWYkNCIsImZhJDQiLCJkZSQ1IiwiZWQkNSIsImFmJDUiLCJmYSQ1IiwiZGUkNiIsImVkJDYiLCJhZiQ2IiwiZmEkNiIsImRlJDciLCJlZCQ3IiwiYWYkNyIsImZhJDciLCJkZSQ4IiwiZWQkOCIsImFmJDgiLCJmYSQ4IiwiamQiLCJkaiIsImdhIiwiYWciLCJkZSQ5IiwiZWQkOSIsImFmJDkiLCJmYSQ5IiwiZGUkMTAiLCJlZCQxMCIsImFmJDEwIiwiZmEkMTAiLCJkZSQxMSIsImVkJDExIiwiYWYkMTEiLCJmYSQxMSIsImRlJDEyIiwiZWQkMTIiLCJhZiQxMiIsImZhJDEyIiwiZGUkMTMiLCJlZCQxMyIsImFmJDEzIiwiZmEkMTMiLCJmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkiLCJmbXR0eV9vZl9wYWRkaW5nX2ZtdHR5IiwiZm10dHlfb2ZfY3VzdG9tIiwiYXJpdHkkMCIsImZtdHR5X29mX2ZtdCIsInR5X3Jlc3QiLCJwcmVjX3R5IiwidHlfcmVzdCQwIiwicHJlY190eSQwIiwidHlfcmVzdCQxIiwicHJlY190eSQxIiwidHlfcmVzdCQyIiwicHJlY190eSQyIiwidHlfcmVzdCQzIiwicHJlY190eSQzIiwiZm10dHkkMSIsImZtdHR5JDIiLCJmbXR0eSQzIiwidHkkMCIsImZtdHR5JDQiLCJmbXR0eSQ1IiwidHlwZV9wYWRkaW5nIiwidyIsInR5cGVfcGFkcHJlYyIsInR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aSIsInR5cGVfZm9ybWF0X2dlbiIsImZtdHR5X3Jlc3QiLCJzdWJfZm10dHlfcmVzdCIsInN1Yl9mbXR0eV9yZXN0JDAiLCJmbXR0eV9yZXN0JDAiLCJzdWJfZm10dHlfcmVzdCQxIiwic3ViX2ZtdHR5X3Jlc3QkMiIsImZtdHR5X3Jlc3QkMSIsInN1Yl9mbXR0eV9yZXN0JDMiLCJmbXQkMiIsInN1Yl9mbXR0eV9yZXN0JDQiLCJmbXR0eV9yZXN0JDIiLCJzdWJfZm10dHlfcmVzdCQ1IiwiZm10JDMiLCJzdWJfZm10dHlfcmVzdCQ2IiwiZm10dHlfcmVzdCQzIiwic3ViX2ZtdHR5X3Jlc3QkNyIsImZtdCQ0Iiwic3ViX2ZtdHR5X3Jlc3QkOCIsImZtdHR5X3Jlc3QkNCIsInN1Yl9mbXR0eV9yZXN0JDkiLCJmbXQkNSIsInN1Yl9mbXR0eV9yZXN0JDEwIiwiZm10dHlfcmVzdCQ1Iiwic3ViX2ZtdHR5X3Jlc3QkMTEiLCJmbXQkNiIsInN1Yl9mbXR0eV9yZXN0JDEyIiwiZm10dHlfcmVzdCQ2Iiwic3ViX2ZtdHR5X3Jlc3QkMTMiLCJmbXQkNyIsInN1Yl9mbXR0eV9yZXN0JDE0IiwiZm10dHlfcmVzdCQ3Iiwic3ViMl9mbXR0eSIsInN1Yl9mbXR0eV9yZXN0JDE1Iiwic3ViMl9mbXR0eSQwIiwiZm10JDgiLCJzdWJfZm10dHlfcmVzdCQxNiIsImZtdHR5X3Jlc3QkOCIsInN1YjJfZm10dHkkMSIsInN1YjFfZm10dHkiLCJzdWJfZm10dHlfcmVzdCQxNyIsInN1YjJfZm10dHkkMiIsInN1YjFfZm10dHkkMCIsImZtdCQ5Iiwic3ViX2ZtdHR5X3Jlc3QkMTgiLCJmbXR0eV9yZXN0JDkiLCJzdWJfZm10dHlfcmVzdCQxOSIsImZtdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIwIiwiZm10dHlfcmVzdCQxMCIsInN1Yl9mbXR0eV9yZXN0JDIxIiwiZm10JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjIiLCJmbXR0eV9yZXN0JDExIiwic3ViX2ZtdHR5X3Jlc3QkMjMiLCJmbXQkMTIiLCJzdWJfZm10dHlfcmVzdCQyNCIsImZtdHR5X3Jlc3QkMTIiLCJzdWJfZm10dHlfcmVzdCQyNSIsImZtdCQxMyIsInN1Yl9mbXR0eV9yZXN0JDI2IiwiZm10X3Jlc3QiLCJmbXRfcmVzdCQwIiwiZm10X3Jlc3QkMSIsImZtdF9yZXN0JDIiLCJmbXRfcmVzdCQzIiwiZm10X3Jlc3QkNCIsImZtdF9yZXN0JDUiLCJwcmVjJDQiLCJmbXR0eSQ2IiwiZm10X3Jlc3QkNiIsInByZWMkNSIsInByZWMkNiIsImZtdHR5JDciLCJmbXRfcmVzdCQ3IiwicHJlYyQ3IiwicHJlYyQ4IiwiZm10dHkkOCIsImZtdF9yZXN0JDgiLCJmbXR0eSQ5IiwiZm10X3Jlc3QkOSIsImZtdHR5JDEwIiwiZm10X3Jlc3QkMTAiLCJmbXR0eSQxMSIsImZtdF9yZXN0JDExIiwiZm10dHkkMTIiLCJmbXRfcmVzdCQxMiIsImZtdHR5JDEzIiwic3ViX2ZtdHR5MSIsImZtdF9yZXN0JDEzIiwic3ViX2ZtdHR5JDEiLCJmbXR0eSQxNCIsImZtdCQxNCIsImZtdF9yZXN0JDE0IiwiZm10dHkkMTUiLCJmbXQkMTUiLCJmbXRfcmVzdCQxNSIsImZtdHR5JDE2IiwiZm10JDE2IiwiZm10X3Jlc3QkMTYiLCJmbXR0eSQxNyIsImZtdCQxNyIsImZtdF9yZXN0JDE3IiwiZm9ybWF0dGluZ19nZW4iLCJmbXR0eTMiLCJmbXQzIiwiZm10MSQwIiwiZm10dHkyJDAiLCJmbXQyJDAiLCJmbXR0eTMkMCIsImZtdDMkMCIsImZtdHR5X3Jlc3QkMTMiLCJmbXRfcmVzdCQxOCIsImZtdHR5JDE4IiwiZm10JDE4IiwiZm10dHlfcmVzdCQxNCIsImZtdF9yZXN0JDE5IiwiZm10dHkkMTkiLCJmbXQkMTkiLCJmbXR0eV9yZXN0JDE1IiwiZm10X3Jlc3QkMjAiLCJmbXR0eSQyMCIsImZtdCQyMCIsInR5cGVfaWdub3JlZF9wYXJhbV9vbmUiLCJmbXR0eV9yZXN0JDE2IiwiZm10dHkkMjEiLCJmbXQkMjEiLCJzdWJfZm10dHkkMiIsInN1Yl9mbXR0eSQzIiwiZm10dHkkMjIiLCJmbXQkMjIiLCJzdWJfZm10dHkkNCIsInR5cGVfZm9ybWF0IiwicmVjYXN0IiwiZml4X3BhZGRpbmciLCJ3aWR0aCQwIiwiZml4X2ludF9wcmVjaXNpb24iLCJyZXMkMSIsInN0cmluZ190b19jYW1sX3N0cmluZyIsImZvcm1hdF9vZl9mY29udiIsInN5bWIiLCJ0cmFuc2Zvcm1faW50X2FsdCIsImRpZ2l0cyIsInB1dCIsImNvbnZlcnRfaW50IiwiY29udmVydF9pbnQzMiIsImNvbnZlcnRfbmF0aXZlaW50IiwiY29udmVydF9pbnQ2NCIsImNvbnZlcnRfZmxvYXQiLCJoZXgiLCJzaWduIiwiY2FtbF9zcGVjaWFsX3ZhbCIsInN0cmluZ19vZl9mbXR0eSIsIm1ha2VfcHJpbnRmJDAiLCJuZXdfYWNjIiwibWFrZV9wcmludGYiLCJtYWtlX3BhZGRpbmciLCJtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiIsInAkMCIsInAkMSIsImFjYyQyIiwiYWNjJDMiLCJhY2MkNCIsImskMyIsImthY2MiLCJrJDQiLCJtYWtlX2lnbm9yZWRfcGFyYW0kMCIsIm1ha2VfY3VzdG9tJDAiLCJtYWtlX2ludmFsaWRfYXJnIiwibWFrZV9mcm9tX2ZtdHR5JDAiLCJtYWtlX2Zyb21fZm10dHkiLCJtYWtlX2N1c3RvbSIsIm1ha2VfaWdub3JlZF9wYXJhbSIsIm1ha2VfaXByaW50ZiQwIiwibWFrZV9pcHJpbnRmIiwiZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24iLCJrb2MiLCJyZXN0JDI0IiwicmVzdCQyNSIsImZuX29mX2N1c3RvbV9hcml0eSQwIiwiZm5fb2ZfY3VzdG9tX2FyaXR5Iiwib3V0cHV0X2FjYyIsInAkMiIsInAkMyIsInAkNCIsImJ1ZnB1dF9hY2MiLCJzdHJwdXRfYWNjIiwiZmFpbHdpdGhfbWVzc2FnZSIsIm9wZW5fYm94X29mX3N0cmluZyIsImludmFsaWRfYm94IiwicGFyc2Vfc3BhY2VzIiwicGFyc2VfbHdvcmQiLCJwYXJzZV9pbnQiLCJ3c3RhcnQiLCJ3ZW5kIiwiYm94X25hbWUiLCJuc3RhcnQiLCJuZW5kIiwiaW5kZW50IiwiZXhwX2VuZCIsImJveF90eXBlIiwibWFrZV9wYWRkaW5nX2ZtdF9lYmIiLCJtYWtlX3BhZHByZWNfZm10X2ViYiIsImZtdF9lYmJfb2Zfc3RyaW5nIiwibGVnYWN5X2JlaGF2aW9yIiwiZmxhZyIsImxlZ2FjeV9iZWhhdmlvciQwIiwiaW52YWxpZF9mb3JtYXRfbWVzc2FnZSIsInVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCIsImVuZF9pbmQiLCJpbnZhbGlkX2Zvcm1hdF93aXRob3V0IiwiZXhwZWN0ZWRfY2hhcmFjdGVyIiwiZXhwZWN0ZWQiLCJhZGRfbGl0ZXJhbCIsImxpdF9zdGFydCIsInNpemUiLCJwYXJzZV9wb3NpdGl2ZSIsInN0cl9pbmQkMCIsInN0cl9pbmQkMSIsInBhcnNlX2ludGVnZXIiLCJuZXh0X2luZCIsImluY29tcGF0aWJsZV9mbGFnIiwicGN0X2luZCIsIm9wdGlvbiIsInN1YmZtdCIsImNvbXB1dGVfaW50X2NvbnYiLCJwbHVzIiwic3BhY2UiLCJwbHVzJDAiLCJzcGFjZSQwIiwic2VhcmNoX3N1YmZvcm1hdF9lbmQiLCJzdWJfZW5kIiwic3RyX2luZCQyIiwic3ViX2VuZCQwIiwic3RyX2luZCQzIiwic3ViX2VuZCQxIiwic3RyX2luZCQ0Iiwic3RyX2luZCQ1Iiwic3ViX2VuZCQyIiwic3RyX2luZCQ2Iiwic3RyX2luZCQ3IiwicGFyc2VfbWFnaWNfc2l6ZSIsInN0cl9pbmRfMSIsInN0cl9pbmRfMiIsInN0cl9pbmRfMyIsInBhcnNlIiwicGFyc2VfZ29vZF9icmVhayIsImZvcm1hdHRpbmdfbGl0JDAiLCJzdHJfaW5kXzQiLCJzdHJfaW5kXzUiLCJwYXJzZV90YWciLCJpc19vcGVuX3RhZyIsImluZCIsInN1Yl9zdHIiLCJzdWJfZm10Iiwic3ViX2Zvcm1hdCQwIiwiZm9ybWF0dGluZyQwIiwiZm9ybWF0dGluZyIsInBhcnNlX2ZsYWdzIiwibWludXMiLCJzZXRfZmxhZyIsIm5ld19pbmQiLCJwYXJzZV9hZnRlcl9wYWRkaW5nIiwicGFyc2VfbGl0ZXJhbCIsInBhcnNlX2FmdGVyX3ByZWNpc2lvbiIsInN5bWIkMCIsIm1pbnVzJDAiLCJwYXJzZV9jb252ZXJzaW9uIiwicGFyc2VfY29udiIsInBhZHByZWMiLCJwbHVzX3VzZWQiLCJoYXNoX3VzZWQiLCJzcGFjZV91c2VkIiwiaWduX3VzZWQiLCJwYWRfdXNlZCIsInByZWNfdXNlZCIsImdldF9wbHVzIiwiZ2V0X2hhc2giLCJnZXRfc3BhY2UiLCJnZXRfaWduIiwiZ2V0X3BhZCIsImdldF9wcmVjIiwiZ2V0X3BhZHByZWMiLCJnZXRfaW50X3BhZCIsImNoZWNrX25vXzAiLCJvcHRfb2ZfcGFkIiwid2lkdGgkMSIsImdldF9wYWRfb3B0IiwiZ2V0X3BhZHByZWNfb3B0IiwiZm10X3Jlc3VsdCIsImlnbm9yZWQkMiIsImNvdW50ZXIkMCIsImlnbm9yZWQkNiIsImlnbm9yZWQkNyIsImFkZF9yYW5nZSIsImZhaWxfc2luZ2xlX3BlcmNlbnQiLCJwYXJzZV9jaGFyX3NldF9jb250ZW50IiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciQwIiwicGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciIsInJldmVyc2UiLCJjaGFyX3NldCQxIiwiaWdub3JlZCQ5IiwiY2hhcl9mb3JtYXQiLCJmbXRfcmVzdCQyMSIsImZtdF9yZXN0JDIyIiwicGFkJDkiLCJmbXRfcmVzdCQyMyIsImlnbm9yZWQkMTAiLCJmbXRfcmVzdCQyNCIsInBhZCQxMCIsImZtdF9yZXN0JDI1Iiwic3ViX2ZtdCQwIiwiZm10X3Jlc3QkMjYiLCJpZ25vcmVkJDExIiwiaWdub3JlZCQzIiwiaWdub3JlZCQ1IiwiaWdub3JlZCQ4Iiwic3BhY2UkMSIsImhhc2gkMSIsInBsdXMkMiIsImtpbmQiLCJpZ25vcmVkJDQiLCJpZ25vcmVkIiwiaWdub3JlZCQwIiwiaWdub3JlZCQxIiwicGx1cyQxIiwiaWduJDAiLCJmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IiwiZm9ybWF0X29mX3N0cmluZ19mb3JtYXQiLCJrZnByaW50ZiIsImticHJpbnRmIiwiaWtmcHJpbnRmIiwiZnByaW50ZiIsImJwcmludGYiLCJpZnByaW50ZiIsImlicHJpbnRmIiwicHJpbnRmIiwiZXByaW50ZiIsImtzcHJpbnRmIiwic3ByaW50ZiIsImFzc29jMyIsInkyIiwieTEiLCJzcGxpdCQwIiwibWFrZV9zeW1saXN0IiwicHJlZml4Iiwic3VmZml4IiwiaGVscF9hY3Rpb24iLCJhZGRfaGVscCIsInNwZWNsaXN0IiwiYWRkMiIsInVzYWdlX2IiLCJlcnJtc2ciLCJkb2MiLCJzcGVjIiwia2V5IiwidXNhZ2Vfc3RyaW5nIiwidXNhZ2UiLCJib29sX29mX3N0cmluZ19vcHQkMCIsImludF9vZl9zdHJpbmdfb3B0JDAiLCJmbG9hdF9vZl9zdHJpbmdfb3B0IiwicGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfIiwiYWxsb3dfZXhwYW5kIiwiYXJndiIsImFub25mdW4iLCJpbml0cG9zIiwiY29udmVydF9lcnJvciIsInByb2duYW1lIiwiZm9sbG93JDAiLCJhY3Rpb24iLCJrZXl3b3JkIiwibm9fYXJnJDAiLCJmb2xsb3ciLCJub19hcmciLCJnZXRfYXJnJDAiLCJnZXRfYXJnIiwiY29uc3VtZV9hcmckMCIsImNvbnN1bWVfYXJnIiwidHJlYXRfYWN0aW9uJDAiLCJ0cmVhdF9hY3Rpb24iLCJmJDAiLCJmJDEiLCJyJDEiLCJmJDIiLCJyJDIiLCJhcmckMiIsImYkMyIsImFyZyQzIiwieCQxIiwiciQzIiwiYXJnJDQiLCJ4JDIiLCJzcGVjcyIsImYkNCIsImFyZyQ1IiwiZiQ1IiwiZiQ2IiwiYXJnJDYiLCJuZXdhcmciLCJwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyIsInBhcnNlX2FyZ3ZfZHluYW1pYyIsImN1cnJlbnQkMCIsInBhcnNlX2FyZ3YiLCJtc2ckMCIsIm1zZyQxIiwicGFyc2VfZHluYW1pYyIsInBhcnNlX2V4cGFuZCIsInNlY29uZF93b3JkIiwibG9vcCIsIm1heF9hcmdfbGVuIiwiY3VyIiwia3dkIiwicmVwbGFjZV9sZWFkaW5nX3RhYiIsInNlZW4iLCJhbGlnbiIsImxpbWl0IiwiY29tcGxldGVkIiwia3NkIiwiY3V0Y29sJDAiLCJzcGFjZXMkMCIsImN1dGNvbCIsImt3ZF9sZW4iLCJzcGFjZXMiLCJyZWFkX2F1eCIsInRyaW0iLCJmaWxlIiwid29yZHMiLCJzdGFzaCIsIndvcmQiLCJyZWFkX2FyZyIsInJlYWRfYXJnMCIsIndyaXRlX2F1eCIsImFyZ3MiLCJ3cml0ZV9hcmciLCJ3cml0ZV9hcmcwIiwicHJpbnRlcnMiLCJmaWVsZCIsIm90aGVyX2ZpZWxkcyIsInVzZV9wcmludGVycyIsImNvbnYiLCJ0b19zdHJpbmdfZGVmYXVsdCIsImNoYXIkMCIsImxpbmUiLCJjaGFyJDEiLCJsaW5lJDAiLCJmaWxlJDAiLCJjaGFyJDIiLCJsaW5lJDEiLCJmaWxlJDEiLCJjb25zdHJ1Y3RvciIsInRvX3N0cmluZyQ3IiwicHJpbnQiLCJmY3QiLCJjYXRjaCQwIiwiY29udmVydF9yYXdfYmFja3RyYWNlIiwiYnQiLCJmb3JtYXRfYmFja3RyYWNlX3Nsb3QiLCJpbmZvIiwiaXNfcmFpc2UiLCJwcmludF9yYXdfYmFja3RyYWNlIiwib3V0Y2hhbiIsInJhd19iYWNrdHJhY2UiLCJiYWNrdHJhY2UiLCJwcmludF9iYWNrdHJhY2UiLCJyYXdfYmFja3RyYWNlX3RvX3N0cmluZyIsImJhY2t0cmFjZV9zbG90X2lzX3JhaXNlIiwiYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lIiwiYmFja3RyYWNlX3Nsb3RfbG9jYXRpb24iLCJiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lIiwiYmFja3RyYWNlX3Nsb3RzIiwiZ2V0X2JhY2t0cmFjZSIsInJlZ2lzdGVyX3ByaW50ZXIiLCJmbiIsImV4bl9zbG90IiwiZXhuX3Nsb3RfaWQiLCJleG5fc2xvdF9uYW1lIiwiZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuIiwidW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIiLCJjb25zdCQwIiwiZmxpcCIsIm5lZ2F0ZSIsInByb3RlY3QiLCJmaW5hbGx5JDAiLCJ3b3JrIiwiZmluYWxseV9ub19leG4iLCJ3b3JrX2V4biIsIndvcmtfYnQiLCJwcmludF9zdGF0IiwiYWxsb2NhdGVkX2J5dGVzIiwibWEiLCJwcm8iLCJtaSIsImNyZWF0ZV9hbGFybSIsImRlbGV0ZV9hbGFybSIsIm51bGxfdHJhY2tlciIsInNhbXBsaW5nX3JhdGUiLCJ0cmFja2VyIiwiY2FsbHN0YWNrX3NpemUiLCJzdHJpbmciLCJieXRlcyIsInN1YnN0cmluZyIsInN1YmJ5dGVzIiwiZmlsZW5hbWUiLCJvdXRwdXQkMCIsImRpZ2VzdCIsImlucHV0JDAiLCJjaGFyX2hleCIsInRvX2hleCIsImZyb21faGV4IiwiZGlnaXQiLCJuZXdfc3RhdGUiLCJhc3NpZ24iLCJzdDEiLCJzdDIiLCJmdWxsX2luaXQiLCJzZWVkIiwic2VlZCQwIiwibWFrZSQyIiwibWFrZV9zZWxmX2luaXQiLCJjb3B5JDUiLCJiaXRzIiwiY3VydmFsIiwibmV3dmFsIiwibmV3dmFsMzAiLCJpbnQkMCIsImJvdW5kIiwiaW50MzIiLCJiMSIsImIyIiwiaW50NjQiLCJiMyIsIm5hdGl2ZWludCIsImZsb2F0JDAiLCJib29sIiwiYml0cyQwIiwiaW50JDEiLCJpbnQzMiQwIiwibmF0aXZlaW50JDAiLCJpbnQ2NCQwIiwiZmxvYXQkMSIsInNjYWxlIiwiYm9vbCQwIiwiZnVsbF9pbml0JDAiLCJpbml0JDQiLCJzZWxmX2luaXQiLCJnZXRfc3RhdGUiLCJzZXRfc3RhdGUiLCJvbmdvaW5nX3RyYXZlcnNhbCIsImZsaXBfb25nb2luZ190cmF2ZXJzYWwiLCJwYXJhbXMiLCJyYW5kb21pemVkX2RlZmF1bHQiLCJyYW5kb21pemVkIiwicmFuZG9taXplIiwiaXNfcmFuZG9taXplZCIsInBybmciLCJjcmVhdGUkMyIsImluaXRpYWxfc2l6ZSIsInJhbmRvbSIsImNsZWFyJDIiLCJyZXNldCQwIiwiY29weV9idWNrZXRsaXN0Iiwia2V5JDAiLCJuZXh0JDAiLCJjb3B5JDYiLCJsZW5ndGgkNCIsInJlc2l6ZSQwIiwiaW5kZXhmdW4iLCJvZGF0YSIsIm9zaXplIiwibnNpemUiLCJuZGF0YSIsIm5kYXRhX3RhaWwiLCJpbnBsYWNlIiwiY2VsbCQwIiwibmlkeCIsIm1hdGNoJDAiLCJpdGVyJDEwIiwiZG9fYnVja2V0Iiwib2xkX3RyYXYiLCJmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IiwiZmlsdGVyX21hcF9pbnBsYWNlIiwiZm9sZCQzIiwiYiQwIiwiYnVja2V0X2xlbmd0aCIsInN0YXRzIiwibWJsIiwiaGlzdG8iLCJ0b19zZXEkOSIsInRibF9kYXRhIiwiYnVjayIsImJ1Y2skMCIsImJ1Y2skMSIsInRvX3NlcV9rZXlzIiwidG9fc2VxX3ZhbHVlcyIsImtleV9pbmRleCIsImJ1Y2tldCIsImsxIiwibmV4dDEiLCJrMiIsIm5leHQyIiwiazMiLCJkMyIsIm5leHQzIiwiZmluZF9hbGwiLCJmaW5kX2luX2J1Y2tldCIsInJlcGxhY2UiLCJyZXBsYWNlX3NlcSIsImNvcHkiLCJzeiIsImhhc2hfcGFyYW0iLCJzZWVkZWRfaGFzaCIsImFkZCQwIiwiZmluZCQwIiwiZmluZF9vcHQkMCIsImZpbmRfYWxsJDAiLCJtZW0kMiIsImFkZF9zZXEkMiIsIm9mX3NlcSQ3Iiwid2Vha19jcmVhdGUiLCJsZW5ndGgkNSIsInJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0JDAiLCJzZXQiLCJnZXQkMCIsImdldF9jb3B5IiwiY2hlY2skMCIsImJsaXQkNCIsImZpbGwkMiIsImFyIiwiZW1wdHlidWNrZXQiLCJnZXRfaW5kZXgiLCJzeiQwIiwic3okMSIsImNvdW50X2J1Y2tldCIsImFkZF9hdXgiLCJzZXR0ZXIiLCJpbmRleCIsImJ1Y2tldCQwIiwiaGFzaGVzIiwibmV3c3oiLCJuZXdidWNrZXQkMCIsIm5ld2hhc2hlcyIsImhidWNrZXQiLCJwcmV2X2xlbiIsImxpdmUiLCJqJDIiLCJuZXdidWNrZXQiLCJuZXd0Iiwib2IiLCJvaCIsInNldHRlciQwIiwibmIiLCJuaSIsImZpbmRfb3IiLCJpZm5vdGZvdW5kIiwiZmluZF9zaGFkb3ciLCJpZmZvdW5kIiwibGVucyIsInRvdGxlbiIsImlkJDAiLCJ1bmtub3duIiwicHBfZW5xdWV1ZSIsInRva2VuIiwicHBfaW5maW5pdHkiLCJwcF9vdXRwdXRfc3RyaW5nIiwicHBfb3V0cHV0X25ld2xpbmUiLCJmb3JtYXRfcHBfdGV4dCIsInRleHQiLCJmb3JtYXRfc3RyaW5nIiwiYnJlYWtfbmV3X2xpbmUiLCJyZWFsX2luZGVudCIsImJyZWFrX2xpbmUiLCJicmVha19zYW1lX2xpbmUiLCJhZHZhbmNlX2xlZnQiLCJzaXplJDAiLCJwZW5kaW5nX2NvdW50Iiwic2l6ZSQxIiwidGFicyIsImFkZF90YWIiLCJscyIsInRhZ19uYW1lIiwibWFya2VyIiwiYnJlYWtzIiwiZml0cyIsIm9mZiIsImJveF90eXBlJDAiLCJvZmYkMCIsImluc2VydGlvbl9wb2ludCIsInRhYnMkMCIsImZpcnN0IiwiaGVhZCIsInRhYiIsIm9mZiQxIiwiaW5zZXJ0aW9uX3BvaW50JDAiLCJ3aWR0aCQyIiwiYm94X3R5cGUkMSIsInRib3giLCJ0YWdfbmFtZSQwIiwibWFya2VyJDAiLCJlbnF1ZXVlX2FkdmFuY2UiLCJlbnF1ZXVlX3N0cmluZ19hcyIsImluaXRpYWxpemVfc2Nhbl9zdGFjayIsInN0YWNrIiwicXVldWVfZWxlbSIsInNldF9zaXplIiwibGVmdF90b3RhbCIsInNjYW5fcHVzaCIsImVsZW0iLCJwcF9vcGVuX2JveF9nZW4iLCJicl90eSIsInBwX2Nsb3NlX2JveCIsInBwX29wZW5fc3RhZyIsInBwX2Nsb3NlX3N0YWciLCJwcF9vcGVuX3RhZyIsInBwX2Nsb3NlX3RhZyIsInBwX3NldF9wcmludF90YWdzIiwicHBfc2V0X21hcmtfdGFncyIsInBwX2dldF9wcmludF90YWdzIiwicHBfZ2V0X21hcmtfdGFncyIsInBwX3NldF90YWdzIiwicHBfZ2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicHBfc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9uIiwicGN0IiwicG90IiwibWN0IiwibW90IiwicHBfcmluaXQiLCJwcF9mbHVzaF9xdWV1ZSIsInBwX3ByaW50X2FzX3NpemUiLCJwcF9wcmludF9hcyIsImlzaXplIiwicHBfcHJpbnRfc3RyaW5nIiwicHBfcHJpbnRfaW50IiwicHBfcHJpbnRfZmxvYXQiLCJwcF9wcmludF9ib29sIiwicHBfcHJpbnRfY2hhciIsInBwX29wZW5faGJveCIsInBwX29wZW5fdmJveCIsInBwX29wZW5faHZib3giLCJwcF9vcGVuX2hvdmJveCIsInBwX29wZW5fYm94IiwicHBfcHJpbnRfbmV3bGluZSIsInBwX3ByaW50X2ZsdXNoIiwicHBfZm9yY2VfbmV3bGluZSIsInBwX3ByaW50X2lmX25ld2xpbmUiLCJwcF9wcmludF9jdXN0b21fYnJlYWsiLCJwcF9wcmludF9icmVhayIsInBwX3ByaW50X3NwYWNlIiwicHBfcHJpbnRfY3V0IiwicHBfb3Blbl90Ym94IiwicHBfY2xvc2VfdGJveCIsInBwX3ByaW50X3RicmVhayIsInBwX3ByaW50X3RhYiIsInBwX3NldF90YWIiLCJwcF9zZXRfbWF4X2JveGVzIiwicHBfZ2V0X21heF9ib3hlcyIsInBwX292ZXJfbWF4X2JveGVzIiwicHBfc2V0X2VsbGlwc2lzX3RleHQiLCJwcF9nZXRfZWxsaXBzaXNfdGV4dCIsInBwX2xpbWl0IiwicHBfc2V0X21heF9pbmRlbnQiLCJwcF9nZXRfbWF4X2luZGVudCIsInBwX3NldF9tYXJnaW4iLCJuZXdfbWF4X2luZGVudCIsInZhbGlkYXRlX2dlb21ldHJ5IiwibWFyZ2luIiwibWF4X2luZGVudCIsImNoZWNrX2dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJwcF9nZXRfbWFyZ2luIiwicHBfc2V0X2Z1bGxfZ2VvbWV0cnkiLCJwcF9zZXRfZ2VvbWV0cnkiLCJwcF9zYWZlX3NldF9nZW9tZXRyeSIsInBwX2dldF9nZW9tZXRyeSIsInBwX3VwZGF0ZV9nZW9tZXRyeSIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyIsInBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsInBwX2dldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aSIsImRpc3BsYXlfbmV3bGluZSIsImJsYW5rX2xpbmUiLCJkaXNwbGF5X2luZGVudCIsInBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwiLCJkZWZhdWx0X3BwX21hcmtfb3Blbl90YWciLCJkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnIiwiZGVmYXVsdF9wcF9wcmludF9vcGVuX3RhZyIsImRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnIiwicHBfbWFrZV9mb3JtYXR0ZXIiLCJwcF9xdWV1ZSIsInN5c190b2siLCJzY2FuX3N0YWNrIiwiZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMiLCJvdXRfZnVucyIsIm1ha2VfZm9ybWF0dGVyIiwicHBmIiwiZm9ybWF0dGVyX29mX291dF9jaGFubmVsIiwiZm9ybWF0dGVyX29mX2J1ZmZlciIsInBwX2J1ZmZlcl9zaXplIiwicHBfbWFrZV9idWZmZXIiLCJzdGRidWYiLCJzdGRfZm9ybWF0dGVyIiwiZXJyX2Zvcm1hdHRlciIsInN0cl9mb3JtYXR0ZXIiLCJmbHVzaF9idWZmZXJfZm9ybWF0dGVyIiwiZmx1c2hfc3RyX2Zvcm1hdHRlciIsIm1ha2Vfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJzb2IiLCJnZXRfc3ltYm9saWNfb3V0cHV0X2J1ZmZlciIsImZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIiLCJpdGVtcyIsImFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSIsIml0ZW0iLCJmb3JtYXR0ZXJfb2Zfc3ltYm9saWNfb3V0cHV0X2IiLCJvcGVuX2hib3giLCJvcGVuX3Zib3giLCJvcGVuX2h2Ym94Iiwib3Blbl9ob3Zib3giLCJvcGVuX2JveCIsImNsb3NlX2JveCIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwib3Blbl9zdGFnIiwiY2xvc2Vfc3RhZyIsInByaW50X2FzIiwicHJpbnRfc3RyaW5nJDAiLCJwcmludF9pbnQkMCIsInByaW50X2Zsb2F0JDAiLCJwcmludF9jaGFyJDAiLCJwcmludF9ib29sIiwicHJpbnRfYnJlYWsiLCJwcmludF9jdXQiLCJwcmludF9zcGFjZSIsImZvcmNlX25ld2xpbmUiLCJwcmludF9mbHVzaCIsInByaW50X25ld2xpbmUkMCIsInByaW50X2lmX25ld2xpbmUiLCJvcGVuX3Rib3giLCJjbG9zZV90Ym94IiwicHJpbnRfdGJyZWFrIiwic2V0X3RhYiIsInByaW50X3RhYiIsInNldF9tYXJnaW4iLCJnZXRfbWFyZ2luIiwic2V0X21heF9pbmRlbnQiLCJnZXRfbWF4X2luZGVudCIsInNldF9nZW9tZXRyeSIsInNhZmVfc2V0X2dlb21ldHJ5IiwiZ2V0X2dlb21ldHJ5IiwidXBkYXRlX2dlb21ldHJ5Iiwic2V0X21heF9ib3hlcyIsImdldF9tYXhfYm94ZXMiLCJvdmVyX21heF9ib3hlcyIsInNldF9lbGxpcHNpc190ZXh0IiwiZ2V0X2VsbGlwc2lzX3RleHQiLCJzZXRfZm9ybWF0dGVyX291dF9jaGFubmVsIiwic2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwiZ2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIiwic2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyIsImdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMiLCJzZXRfcHJpbnRfdGFncyIsImdldF9wcmludF90YWdzIiwic2V0X21hcmtfdGFncyIsImdldF9tYXJrX3RhZ3MiLCJzZXRfdGFncyIsInBwX3ByaW50X2xpc3QiLCJwcF92Iiwib3B0JDAiLCJwcF9zZXAiLCJ2cyIsIm9wdCQxIiwicHBfcHJpbnRfdGV4dCIsInBwX3ByaW50X29wdGlvbiIsInBwX3ByaW50X3Jlc3VsdCIsImNvbXB1dGVfdGFnIiwidGFnX2FjYyIsIm91dHB1dF9mb3JtYXR0aW5nX2xpdCIsIm91dHB1dF9hY2MkMCIsImJ0eSIsInAkNSIsInAkNiIsInN0cnB1dF9hY2MkMCIsImtmcHJpbnRmJDAiLCJpa2ZwcmludGYkMCIsImlmcHJpbnRmJDAiLCJmcHJpbnRmJDAiLCJwcmludGYkMCIsImVwcmludGYkMCIsImtkcHJpbnRmIiwiZHByaW50ZiIsImtwcmludGYiLCJzcHJpbnRmJDAiLCJrYXNwcmludGYiLCJhc3ByaW50ZiIsImZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMiLCJwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnUiLCJwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnUiLCJzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3QiLCJnZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3QiLCJicHJpbnRmJDAiLCJwcF9zZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJzdHJpbmdpZnkiLCJwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJmdW5zIiwibWFya19vcGVuX3RhZyIsIm1hcmtfY2xvc2VfdGFnIiwicHJpbnRfb3Blbl90YWciLCJwcmludF9jbG9zZV90YWciLCJzZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJnZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMiLCJudWxsX2NoYXIiLCJuZXh0X2NoYXIiLCJpYiIsInBlZWtfY2hhciIsImNoZWNrZWRfcGVla19jaGFyIiwiZW5kX29mX2lucHV0IiwiYmVnaW5uaW5nX29mX2lucHV0IiwibmFtZV9vZl9pbnB1dCIsImNoYXJfY291bnQiLCJyZXNldF90b2tlbiIsImludmFsaWRhdGVfY3VycmVudF9jaGFyIiwidG9rZW5fc3RyaW5nIiwidG9rZW5fYnVmZmVyIiwic2tpcF9jaGFyIiwiaWdub3JlX2NoYXIiLCJzdG9yZV9jaGFyIiwiZGVmYXVsdF90b2tlbl9idWZmZXJfc2l6ZSIsImNyZWF0ZSQ0IiwiaW5hbWUiLCJmcm9tX3N0cmluZyQxIiwiZnJvbV9mdW5jdGlvbiQwIiwic2Nhbl9jbG9zZV9hdF9lbmQiLCJzY2FuX3JhaXNlX2F0X2VuZCIsImZyb21faWMiLCJzY2FuX2Nsb3NlX2ljIiwiZW9mIiwic3RkaWIiLCJvcGVuX2luX2ZpbGUiLCJmcm9tX2ZpbGUiLCJmcm9tX2ZpbGVfYmluIiwiZnJvbV9jaGFubmVsJDAiLCJjbG9zZV9pbiQwIiwiaWMkMCIsIm1lbW8iLCJtZW1vX2Zyb21faWMiLCJtZW1vX2Zyb21fY2hhbm5lbCIsImJhZF9pbnB1dCIsImJhZF9pbnB1dF9lc2NhcGUiLCJiYWRfdG9rZW5fbGVuZ3RoIiwibWVzc2FnZSIsImJhZF9mbG9hdCIsImJhZF9oZXhfZmxvYXQiLCJjaGFyYWN0ZXJfbWlzbWF0Y2giLCJjaSIsImNoZWNrX3RoaXNfY2hhciIsImNoZWNrX2NoYXIiLCJ0b2tlbl9jaGFyIiwidG9rZW5fYm9vbCIsImludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIiwidG9rZW5faW50X2xpdGVyYWwiLCJ0b2tlbl9mbG9hdCIsInNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIiwic2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCIsInNjYW5fZGlnaXRfcGx1cyIsImJhc2lzIiwiZGlnaXRwIiwid2lkdGgkMyIsImlzX2JpbmFyeV9kaWdpdCIsInNjYW5fYmluYXJ5X2ludCIsImlzX29jdGFsX2RpZ2l0Iiwic2Nhbl9vY3RhbF9pbnQiLCJpc19oZXhhX2RpZ2l0Iiwic2Nhbl9oZXhhZGVjaW1hbF9pbnQiLCJzY2FuX3NpZ24iLCJzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWwiLCJzY2FuX2ludF9jb252ZXJzaW9uIiwic2Nhbl9mcmFjdGlvbmFsX3BhcnQiLCJzY2FuX2V4cG9uZW50X3BhcnQiLCJzY2FuX2Zsb2F0IiwicHJlY2lzaW9uIiwicHJlY2lzaW9uJDAiLCJjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyIsInNjYW5faGV4X2Zsb2F0Iiwid2lkdGgkNCIsIndpZHRoJDUiLCJ3aWR0aCQ2Iiwid2lkdGgkMTAiLCJ3aWR0aCQ3Iiwid2lkdGgkOCIsIndpZHRoJDkiLCJzY2FuX2NhbWxfZmxvYXRfcmVzdCIsIndpZHRoX3ByZWNpc2lvbiIsImZyYWNfd2lkdGgiLCJzY2FuX2NhbWxfZmxvYXQiLCJzY2FuX3N0cmluZyIsInN0cCIsInNjYW5fY2hhciIsImhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIiLCJjaGVja19uZXh0X2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIiLCJjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyIsInNjYW5fYmFja3NsYXNoX2NoYXIiLCJjMCIsImdldF9kaWdpdCIsImdldF9kaWdpdCQwIiwiYzEkMCIsImMyJDAiLCJzY2FuX2NhbWxfY2hhciIsImZpbmRfc3RvcCIsInNjYW5fY2FtbF9zdHJpbmciLCJmaW5kX3N0b3AkMCIsInNraXBfc3BhY2VzIiwic2Nhbl9jaGFyc19pbl9jaGFyX3NldCIsInNjYW5faW5kaWMiLCJzY2FuX2NoYXJzIiwic2NhbmZfYmFkX2lucHV0IiwiZ2V0X2NvdW50ZXIiLCJ3aWR0aF9vZl9wYWRfb3B0Iiwic3RvcHBlcl9vZl9mb3JtYXR0aW5nX2xpdCIsImZtdGluZyIsInRha2VfZm9ybWF0X3JlYWRlcnMkMCIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMkMCIsInJlYWRlciIsIm5ld19rIiwicmVhZGVyc19yZXN0IiwidGFrZV9mb3JtYXRfcmVhZGVycyIsImZtdCQyMyIsImZtdCQyNCIsImZtdCQyNSIsInRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMiLCJtYWtlX3NjYW5mIiwicmVhZGVycyIsInNjYW4kMCIsInN0cl9yZXN0IiwicGFkX3ByZWNfc2NhbmYiLCJzY2FuJDEiLCJzY2FuJDIiLCJzY2FuIiwic2NhbiQzIiwic2NhbiQ0IiwiY29udiQwIiwic2NhbiQ1IiwiY29udiQxIiwic2NhbiQ2IiwiY29udiQyIiwic2NhbiQ3Iiwic2NhbiQ4IiwiZm10aW5nX2xpdCQwIiwic3RwJDAiLCJzJDIiLCJzdHJfcmVzdCQwIiwicmVzdCQyNiIsImFyZ19yZXN0Iiwia3NjYW5mIiwiZWYiLCJhcHBseSIsImFyZ3MkMCIsImV4YyIsImJzY2FuZiIsImtzc2NhbmYiLCJzc2NhbmYiLCJzY2FuZiIsImJzY2FuZl9mb3JtYXQiLCJmb3JtYXQiLCJzc2NhbmZfZm9ybWF0IiwiZm9ybWF0X2Zyb21fc3RyaW5nIiwidW5lc2NhcGVkIiwia2ZzY2FuZiIsImZzY2FuZiIsInJlZ2lzdGVyIiwicmVnaXN0ZXJfZXhjZXB0aW9uIiwibyQwIiwicGFyYW1zJDAiLCJpbml0aWFsX29iamVjdF9zaXplIiwiZHVtbXlfaXRlbSIsInRhZyIsImNvbXBhcmUkMTEiLCJjb21wYXJlJDEyIiwiY29tcGFyZSQxMyIsImR1bW15X3RhYmxlIiwidGFibGVfY291bnQiLCJkdW1teV9tZXQiLCJmaXRfc2l6ZSIsIm5ld190YWJsZSIsInB1Yl9sYWJlbHMiLCJtZXRob2RzIiwicmVzaXplJDEiLCJhcnJheSIsIm5ld19zaXplIiwib2xkX3NpemUiLCJuZXdfYnVjayIsIm1ldGhvZF9jb3VudCIsImluc3RfdmFyX2NvdW50IiwibmV3X21ldGhvZCIsInRhYmxlIiwiZ2V0X21ldGhvZF9sYWJlbCIsImxhYmVsIiwiZ2V0X21ldGhvZF9sYWJlbHMiLCJuYW1lcyIsInNldF9tZXRob2QiLCJlbGVtZW50IiwiZ2V0X21ldGhvZCIsInRvX2xpc3QkMyIsImFyciIsIm5hcnJvdyIsInZhcnMiLCJ2aXJ0X21ldGhzIiwiY29uY3JfbWV0aHMiLCJ2YXJzJDAiLCJ2aXJ0X21ldGhzJDAiLCJjb25jcl9tZXRocyQwIiwidmlydF9tZXRoX2xhYnMiLCJjb25jcl9tZXRoX2xhYnMiLCJsYWIiLCJ0dmFycyIsImJ5X25hbWUiLCJieV9sYWJlbCIsIm1ldCIsImhtIiwid2lkZW4iLCJzYXZlZF92YXJzIiwic2F2ZWRfaGlkZGVuX21ldGhzIiwibmV3X3Nsb3QiLCJuZXdfdmFyaWFibGUiLCJ0b19hcnJheSIsIm5ld19tZXRob2RzX3ZhcmlhYmxlcyIsIm1ldGhzIiwidmFscyIsIm1ldGhzJDAiLCJubWV0aHMiLCJudmFscyIsImdldF92YXJpYWJsZSIsImdldF92YXJpYWJsZXMiLCJhZGRfaW5pdGlhbGl6ZXIiLCJjcmVhdGVfdGFibGUiLCJwdWJsaWNfbWV0aG9kcyIsInRhZ3MiLCJpbml0X2NsYXNzIiwiaW5oZXJpdHMiLCJjbGEiLCJzdXBlciQwIiwibm0iLCJtYWtlX2NsYXNzIiwicHViX21ldGhzIiwiY2xhc3NfaW5pdCIsImVudl9pbml0IiwibWFrZV9jbGFzc19zdG9yZSIsImluaXRfdGFibGUiLCJkdW1teV9jbGFzcyIsImxvYyIsInVuZGVmIiwiY3JlYXRlX29iamVjdCIsImNyZWF0ZV9vYmplY3Rfb3B0Iiwib2JqXzAiLCJpdGVyX2YiLCJydW5faW5pdGlhbGl6ZXJzIiwiaW5pdHMiLCJydW5faW5pdGlhbGl6ZXJzX29wdCIsImNyZWF0ZV9vYmplY3RfYW5kX3J1bl9pbml0aWFsaSIsImdldF9kYXRhJDAiLCJidWlsZF9wYXRoIiwia2V5cyIsImxvb2t1cF90YWJsZXMiLCJyb290IiwidGFibGVzJDIiLCJ0YWJsZXMkMCIsInRhYmxlcyQxIiwibmV3X2NhY2hlIiwic2V0X21ldGhvZHMiLCJjbG8iLCJjbG8kMCIsIm4kMiIsIm4kMyIsIm4kNCIsIm4kNSIsIm4kNiIsIngkMyIsIm4kNyIsIngkNCIsIm4kOCIsImYkNyIsIm4kOSIsIngkNSIsImYkOCIsImUkMiIsIm4kMTAiLCJ4JDYiLCJmJDkiLCJuJDExIiwieCQ3IiwibiQxMiIsIngkOCIsIm4kMTMiLCJuJDE0IiwiZSQzIiwibiQxNSIsIm0kMiIsIngkOSIsIm0kMyIsIm4kMTYiLCJtJDQiLCJlJDQiLCJuJDE3IiwibSQ1IiwibiQxOCIsInN0YXRzJDAiLCJpbml0aWFsX2J1ZmZlciIsImJ1ZmZlciIsImJ1ZnBvcyIsInJlc2V0X2J1ZmZlciIsInN0b3JlIiwibmV3YnVmZmVyIiwiZ2V0X3N0cmluZyIsIm1ha2VfbGV4ZXIiLCJrZXl3b3JkcyIsImt3ZF90YWJsZSIsImlkZW50X29yX2tleXdvcmQiLCJrZXl3b3JkX29yX2Vycm9yIiwiY29tbWVudCIsImVzY2FwZSIsImVuZF9leHBvbmVudF9wYXJ0IiwiZXhwb25lbnRfcGFydCIsIm51bWJlciIsImlkZW50MiIsIm5lZ19udW1iZXIiLCJuZXh0X3Rva2VuJDAiLCJtYXliZV9jb21tZW50IiwibmV4dF90b2tlbiIsImhrZXkiLCJjbGVhbiIsImluc2VydF9idWNrZXQiLCJjb250YWluZXIiLCJyZW1vdmVfYnVja2V0IiwiaGsiLCJyZXBsYWNlX2J1Y2tldCIsIm5ld19kIiwiYnVja2V0X2xlbmd0aF9hbGl2ZSIsInN0YXRzX2FsaXZlIiwiY3JlYXRlJDUiLCJnZXRfa2V5JDAiLCJnZXRfa2V5X2NvcHkkMCIsInNldF9rZXkkMCIsInVuc2V0X2tleSQwIiwiY2hlY2tfa2V5JDAiLCJibGl0X2tleSQwIiwiZ2V0X2RhdGEkMSIsImdldF9kYXRhX2NvcHkiLCJzZXRfZGF0YSIsInVuc2V0X2RhdGEiLCJjaGVja19kYXRhIiwiYmxpdF9kYXRhIiwic2V0X2tleV9kYXRhIiwiY3JlYXRlJDYiLCJnZXRfa2V5MSIsImdldF9rZXkxX2NvcHkiLCJzZXRfa2V5MSIsInVuc2V0X2tleTEiLCJjaGVja19rZXkxIiwiZ2V0X2tleTIiLCJnZXRfa2V5Ml9jb3B5Iiwic2V0X2tleTIiLCJ1bnNldF9rZXkyIiwiY2hlY2tfa2V5MiIsImJsaXRfa2V5MSIsImJsaXRfa2V5MiIsImJsaXRfa2V5MTIiLCJnZXRfZGF0YSQyIiwiZ2V0X2RhdGFfY29weSQwIiwic2V0X2RhdGEkMCIsInVuc2V0X2RhdGEkMCIsImNoZWNrX2RhdGEkMCIsImJsaXRfZGF0YSQwIiwiazIkMCIsImsxJDAiLCJjcmVhdGUkNyIsImxlbmd0aCQ2IiwiZ2V0X2tleSQxIiwiZ2V0X2tleV9jb3B5JDEiLCJzZXRfa2V5JDEiLCJ1bnNldF9rZXkkMSIsImNoZWNrX2tleSQxIiwiYmxpdF9rZXkkMSIsImdldF9kYXRhJDMiLCJnZXRfZGF0YV9jb3B5JDEiLCJzZXRfZGF0YSQxIiwidW5zZXRfZGF0YSQxIiwiY2hlY2tfZGF0YSQxIiwiYmxpdF9kYXRhJDEiLCJraSIsImswIiwiZ2VuZXJpY19iYXNlbmFtZSIsImlzX2Rpcl9zZXAiLCJnZW5lcmljX2Rpcm5hbWUiLCJpc19yZWxhdGl2ZSIsImlzX2ltcGxpY2l0IiwiY2hlY2tfc3VmZml4Iiwic3VmZiIsImNob3Bfc3VmZml4X29wdCIsImxlbl9zIiwibGVuX2YiLCJxdW90ZSIsInF1b3RlX2NvbW1hbmQiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJpc19kaXJfc2VwJDAiLCJpc19yZWxhdGl2ZSQwIiwiaXNfaW1wbGljaXQkMCIsImNoZWNrX3N1ZmZpeCQwIiwiY2hvcF9zdWZmaXhfb3B0JDAiLCJ0ZW1wX2Rpcl9uYW1lIiwicXVvdGUkMCIsImFkZF9icyIsImxvb3AkMCIsImxvb3BfYnMiLCJxdW90ZV9jbWRfZmlsZW5hbWUiLCJxdW90ZV9jb21tYW5kJDAiLCJkcml2ZV9hbmRfcGF0aCIsImRpcm5hbWUkMCIsInBhdGgiLCJkcml2ZSIsImRpciIsImJhc2VuYW1lJDAiLCJiYXNlbmFtZSQxIiwiZGlybmFtZSQxIiwibnVsbCQzIiwiY3VycmVudF9kaXJfbmFtZSQyIiwicGFyZW50X2Rpcl9uYW1lJDIiLCJkaXJfc2VwJDIiLCJpc19kaXJfc2VwJDEiLCJpc19yZWxhdGl2ZSQxIiwiaXNfaW1wbGljaXQkMSIsImNoZWNrX3N1ZmZpeCQxIiwiY2hvcF9zdWZmaXhfb3B0JDEiLCJ0ZW1wX2Rpcl9uYW1lJDAiLCJxdW90ZSQxIiwicXVvdGVfY29tbWFuZCQxIiwiYmFzZW5hbWUkMiIsImRpcm5hbWUkMiIsImNvbmNhdCQzIiwiY2hvcF9zdWZmaXgiLCJleHRlbnNpb25fbGVuIiwiZXh0ZW5zaW9uIiwiY2hvcF9leHRlbnNpb24iLCJyZW1vdmVfZXh0ZW5zaW9uIiwicHJuZyQwIiwidGVtcF9maWxlX25hbWUiLCJ0ZW1wX2RpciIsInJuZCIsImN1cnJlbnRfdGVtcF9kaXJfbmFtZSIsInNldF90ZW1wX2Rpcl9uYW1lIiwiZ2V0X3RlbXBfZGlyX25hbWUiLCJ0ZW1wX2ZpbGUiLCJ0cnlfbmFtZSIsImNvdW50ZXIkMSIsIm9wZW5fdGVtcF9maWxlIiwic3RoJDAiLCJwZXJtcyIsInN0aCQxIiwiYWRkJDEiLCJzdWIkNCIsIm5lZyIsImNvbmoiLCJtdWwiLCJkaXYiLCJpbnYiLCJub3JtMiIsIm5vcm0iLCJxJDAiLCJwb2xhciIsInNxcnQiLCJ3JDAiLCJleHAiLCJsb2ciLCJwb3ciLCJlbmFibGVkIiwiaWZfc3BhY2V0aW1lX2VuYWJsZWQiLCJjcmVhdGUkOCIsImNoYW5uZWwiLCJzYXZlX2V2ZW50IiwidGltZSIsImV2ZW50X25hbWUiLCJzYXZlX2FuZF9jbG9zZSIsInRha2UkMCIsImNsb3NlZCIsInNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwcyIsImZsb2F0MzIiLCJmbG9hdDY0IiwiaW50OF9zaWduZWQiLCJpbnQ4X3Vuc2lnbmVkIiwiaW50MTZfc2lnbmVkIiwiaW50MTZfdW5zaWduZWQiLCJpbnQzMiQxIiwiaW50NjQkMSIsImludCQyIiwibmF0aXZlaW50JDEiLCJjb21wbGV4MzIiLCJjb21wbGV4NjQiLCJraW5kX3NpemVfaW5fYnl0ZXMiLCJjX2xheW91dCIsImZvcnRyYW5fbGF5b3V0IiwiZGltcyIsInNpemVfaW5fYnl0ZXMiLCJjcmVhdGUkOSIsImxheW91dCIsImdldCQxIiwic2V0JDAiLCJzaXplX2luX2J5dGVzJDAiLCJvZl92YWx1ZSIsImNyZWF0ZSQxMCIsImRpbSIsInNpemVfaW5fYnl0ZXMkMSIsInNsaWNlIiwib2ZfYXJyYXkiLCJiYSIsImNyZWF0ZSQxMSIsImRpbTEiLCJkaW0yIiwic2l6ZV9pbl9ieXRlcyQyIiwic2xpY2VfbGVmdCIsInNsaWNlX3JpZ2h0Iiwib2ZfYXJyYXkkMCIsInJvdyIsImNyZWF0ZSQxMiIsImRpbTMiLCJzaXplX2luX2J5dGVzJDMiLCJzbGljZV9sZWZ0XzEiLCJzbGljZV9yaWdodF8xIiwic2xpY2VfbGVmdF8yIiwic2xpY2VfcmlnaHRfMiIsIm9mX2FycmF5JDEiLCJjb2wiLCJhcnJheTBfb2ZfZ2VuYXJyYXkiLCJhcnJheTFfb2ZfZ2VuYXJyYXkiLCJhcnJheTJfb2ZfZ2VuYXJyYXkiLCJhcnJheTNfb2ZfZ2VuYXJyYXkiLCJyZXNoYXBlXzAiLCJyZXNoYXBlXzEiLCJyZXNoYXBlXzIiLCJyZXNoYXBlXzMiLCJnbG9iYWxUaGlzIiwiU3ltYm9sIiwibnVsbCIsInVuZGVmaW5lZCIsImV4biIsIm5hbWUiLCJzeW1fa2V5X2dlbiIsInN5bV9leHBvcnRhYmxlX2tleSIsInMiLCJ1c2FnZXMiLCJpdiIsIml2JDAiLCJzeW1fYWxnbyIsIml2JDEiLCJpdiQyIiwic3ltX2VuY3J5cHQiLCJrZXkiLCJjbGVhciIsInN5bV9kZWNyeXB0IiwiY2lwaGVyIiwicGFzdGV1ciIsImVycl9lbGVtZW50X3Bhc3RldXJfbm90X2ZvdW5kIiwiZXJyX2VsZW1lbnRfcGFzdGVfbm90X2ZvdW5kIiwiZXJyX2VsZW1lbnRfcGFzdGVfaXNfbm90X2Ffc3RyIiwiZXJyX2ludmFsaWRfaGV4X3ZhbHVlIiwiZXJyX2ludmFsaWRfa2V5Iiwib24iLCJzeW1ib2wiLCJmIiwiZyIsIngiLCJpZCIsIm1ha2VfcGF0aCIsImxuIiwiaGwiLCJyYXciLCJjb2RlIiwiYXJncyIsImtleSQwIiwicG9zdCIsImVsIiwiZm9ybSIsImRhdGEiLCJlbmNyeXB0ZWQiLCJzdWJ0bCIsImNpcGhlciQwIiwiY2lwaGVyJDEiLCJpbml0IiwicmVzIiwicGF0aCIsInVyaSIsIm91dHB1dCIsImVycl9zb3VyY2Vfb3Jfb3V0cHV0X25vdF9mb3VuZCIsInRvX3VpbnQ4IiwieSIsImNociIsInN0ciIsImxlbiIsImJ1ZiIsInkkMCIsIngkMCIsIm9mX2hleCIsInNob3ciLCJlbmNyeXB0ZWQkMCIsImVyciIsImNvbnN0JDAiXSwic291cmNlcyI6WyIvYnVpbHRpbi8raW50NjQuanMiLCIvYnVpbHRpbi8rbWxCeXRlcy5qcyIsIi9idWlsdGluLytmYWlsLmpzIiwiL2J1aWx0aW4vK3N0ZGxpYi5qcyIsIi9idWlsdGluLytmb3JtYXQuanMiLCIvYnVpbHRpbi8raWVlZV83NTQuanMiLCIvYnVpbHRpbi8rZnMuanMiLCIvYnVpbHRpbi8rc3lzLmpzIiwiL2J1aWx0aW4vK2ZzX2Zha2UuanMiLCIvYnVpbHRpbi8rZnNfbm9kZS5qcyIsIi9idWlsdGluLytuYXQuanMiLCIvYnVpbHRpbi8rZ3JhcGhpY3MuanMiLCIvYnVpbHRpbi8rbWFyc2hhbC5qcyIsIi9idWlsdGluLytpby5qcyIsIi9idWlsdGluLytnYy5qcyIsIi9idWlsdGluLytiaWdhcnJheS5qcyIsIi9idWlsdGluLytqc2xpYi5qcyIsIi9idWlsdGluLytwYXJzaW5nLmpzIiwiL2J1aWx0aW4vK2pzbGliX2pzX29mX29jYW1sLmpzIiwiL2J1aWx0aW4vK3VuaXguanMiLCIvYnVpbHRpbi8raW50cy5qcyIsIi9idWlsdGluLytoYXNoLmpzIiwiL2J1aWx0aW4vK2NvbXBhcmUuanMiLCIvYnVpbHRpbi8raW50ZXJuYWxNb2QuanMiLCIvYnVpbHRpbi8rb2JqLmpzIiwiL2J1aWx0aW4vK2JpZ3N0cmluZy5qcyIsIi9idWlsdGluLytiYWNrdHJhY2UuanMiLCIvYnVpbHRpbi8rbGV4aW5nLmpzIiwiL2J1aWx0aW4vK2FycmF5LmpzIiwiL2J1aWx0aW4vK3dlYWsuanMiLCIvYnVpbHRpbi8rbWQ1LmpzIiwiL2J1aWx0aW4vK3N0ci5qcyIsIi9idWlsdGluLytiaWdzdHJpbmctY3N0cnVjdC5qcyIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3VjaGFyLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvaW50NjQubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9sZXhpbmcubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxGb3JtYXQubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9wcmludGV4Yy5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2ZpbGVuYW1lLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvY29tcGxleC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2NhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3N0ZGxpYi5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3BlcnZhc2l2ZXMubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9mbG9hdC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL25hdGl2ZWludC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2xpc3QubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9zZXEubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9vcHRpb24ubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9yZXN1bHQubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9ib29sLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvY2hhci5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2J5dGVzLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvc3RyaW5nLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvdW5pdC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL21hcnNoYWwubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9vYmoubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9hcnJheS5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2ludC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2ludDMyLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvcGFyc2luZy5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3NldC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL21hcC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3N0YWNrLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvcXVldWUubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9jYW1saW50ZXJuYWxMYXp5Lm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvbGF6eS5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3N0cmVhbS5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2J1ZmZlci5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3ByaW50Zi5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2FyZy5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2Z1bi5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2djLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvZGlnZXN0Lm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvcmFuZG9tLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvaGFzaHRibC5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL3dlYWsubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9mb3JtYXQubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9zY2FuZi5tbCIsIi9ob21lL2Rpbm9zYXVyZS8ub3BhbS80LjExLjAvbGliL29jYW1sL2NhbGxiYWNrLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvY2FtbGludGVybmFsT08ubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9nZW5sZXgubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9lcGhlbWVyb24ubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9zcGFjZXRpbWUubWwiLCIvaG9tZS9kaW5vc2F1cmUvLm9wYW0vNC4xMS4wL2xpYi9vY2FtbC9iaWdhcnJheS5tbCIsIiIsIi9ob21lL2Rpbm9zYXVyZS9kZXYvcGFzdGV1ci9fYnVpbGQvZGVmYXVsdC9qcy9wYXN0ZXVyLm1sIiwiL2hvbWUvZGlub3NhdXJlLy5vcGFtLzQuMTEuMC9saWIvb2NhbWwvc3RkX2V4aXQubWwiXSwibWFwcGluZ3MiOiI7Ozs7SUEwT0EsU0FBU0EsbUJBQW1CQyxHQUFLLFNBQVEsVUFBWTtJQ3pMckQsU0FBU0MsZ0JBQWdCQyxFQUFHQztNQUMxQixHQUFHRCxPQUFRO01BQ1gsR0FBSUMsU0FBVSxPQUFRLFNBQVNEO01BQy9CLElBQU0sS0FBUTtNQUNkO09BQVEsQ0FDTixHQUFJQSxNQUFPRSxLQUFLRDtRQUNoQkQ7UUFDQSxHQUFJQSxPQUFRLE9BQU9FO1FBQ25CRCxLQUFLQTtRQUNMRTtRQUNBLEdBQUlBLE9BQVEsYUFNaEI7SUQ3Q0EsSUFBSUMsa0JBQW9CO0lFQXhCLFNBQVNFLG9CQUFxQkMsS0FBTyxNQUFNQSxHQUFLO0lDMkNoRCxJQUFJQztJRFJKLFNBQVNDO01BQ1Asb0JBQW9CRCxrQ0FDdEI7SUZqQ0EsU0FBU0UsUUFBU0MsR0FBR0MsR0FBR0M7TUFDdEJDLFVBQVVILGNBQ1ZHLFVBQVVGLGNBQ1ZFLFVBQVVELFdBQ1o7SUFDQUg7SUFDQUE7O2VBQ0UsV0FBV0EsUUFBUUksUUFBUUEsUUFBUUEsUUFEWjtJQUl6Qko7O2FBQXVDWjtNQUNyQyxHQUFJZ0IsVUFBVWhCLEtBQU07TUFDcEIsR0FBSWdCLFVBQVVoQixLQUFNO01BQ3BCLEdBQUlnQixVQUFVaEIsS0FBTTtNQUNwQixHQUFJ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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VTs7Ozs7OztJYzdCMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NrQksraUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQ3dCQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7Ozs7S0N6QkFDO0tBb0hBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NtOUVNQztLQVFRQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0NsbEZkQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tDc0VFQztLQUNBQztLQUNBQztLQUNBQzs7O0tBL0VZQztLQXFIWkM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQW1JQUM7S0FDQUM7S0FDQUM7S0FDQUM7OztLQzFQRkM7S0FDQUM7S0FDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthQzBmSUM7O09Ba0NZOztPQWxDWjtnQkFLSixJQURRQyxjQUNBLG9CQURBQTtnQkFHUixJQURVQyxnQkFDQSxvQkFEQUE7Z0JBR1YsSUFET0MsZ0JBQ0Esb0JBREFBO2dCQUdQLElBRFNDLGdCQUNBLG9CQURBQTtnQkFLVCxJQURhQyxnQkFDQSxvQkFEQUE7Z0JBRGIsSUFEU0MsZ0JBQ0Esb0JBREFBO2dCQUtULElBRFNDLGdCQUNBLG9CQURBQTtnQkFHVCxJQURRQyxnQkFDQSxvQkFEQUE7O2NBRVdDLGdCQUFKQyxZQUNJLFVBREpBLEdBQ0ksVUFEQUQ7O2NBRVNFLGdCQUFYQztVQUNVLFVBRFZBLFFBQ1UsVUFEQ0Q7aUJBRzVCLElBRFNFLGdCQUNBLHFCQURBQTtpQkFHVCxJQURTQyxpQkFDQSxxQkFEQUE7aUJBR1QsSUFET0MsaUJBQ0EscUJBREFBO2lCQUdQLElBRFVDLGlCQUNBLHFCQURBQTtpQkFHVixJQURrQkMsaUJBQ0EscUJBREFBLFVBRVU7YUFpQnhCQyxhQVdKQyxPQUFPQztNQUFVLFVBQWpCRDtPQStCZ0IsT0EvQlRDOztPQUFVLE9BQWpCRDtnQkFFQSxJQURRbEIsS0FEUmtCLFVBRVEsdUJBREFsQixLQUREbUI7Z0JBSVAsSUFEVWxCLE9BSFZpQixVQUlVLHVCQURBakIsT0FISGtCO2dCQU1QLElBRE9qQixPQUxQZ0IsVUFNTyx1QkFEQWhCLE9BTEFpQjtnQkFRUCxJQURTaEIsT0FQVGUsVUFRUyx1QkFEQWYsT0FQRmdCO2dCQVVQLElBRGFmLE9BVGJjLFVBVWEsdUJBREFkLE9BVE5lO2dCQVlQLElBRFNkLE9BWFRhLFVBWVMsdUJBREFiLE9BWEZjO2dCQWNQLElBRFNiLE9BYlRZLFVBY1MsdUJBREFaLE9BYkZhO2dCQWdCUCxJQURRWixPQWZSVyxVQWdCUSx1QkFEQVgsT0FmRFk7O2NBMkJZWCxPQTNCbkJVLFVBMkJlVCxHQTNCZlM7VUE0Qm1CLFVBREpULEdBQ0ksYUFEQUQsT0EzQlpXOztjQTZCb0JULE9BN0IzQlEsVUE2QnNCRSxJQTdCdEJGLFVBNkJpQlAsSUE3QmpCTztVQThCMkIsVUFEVlAsSUFBS1MsSUFDSyxhQURBVixPQTdCcEJTO2lCQWtCUCxJQURTUCxPQWpCVE0sVUFrQlMsd0JBREFOLE9BakJGTzs7VUFvQlAsSUFEU04sUUFuQlRLLFVBb0JTLHdCQURBTCxRQW5CRk07O1VBc0JQLElBRE9MLFFBckJQSSxVQXNCTyx3QkFEQUosUUFyQkFLOztVQXdCUCxJQURVSixRQXZCVkcsVUF3QlUsd0JBREFILFFBdkJISTs7VUEwQlAsSUFEa0JILFFBekJsQkUsVUEwQmtCLHdCQURBRixRQXpCWEcsU0ErQmU7YUFNbEJFLFdBSUpDLEtBQUtDO01BQVEsVUFBYkQ7T0EyREEsT0EzREtDOztPQUFRLE9BQWJEO2dCQWtCQSxJQURLdEIsS0FqQkxzQixRQWtCSyxxQkFEQXRCLEtBakJBdUI7Z0JBb0JMLElBRFV0QixPQW5CVnFCLFFBb0JVLHFCQURBckIsT0FuQkxzQjs7Y0FDUXJCLE9BRGJvQixRQUNRRSxJQURSRjtVQUVhLFVBRExFLElBQ0ssV0FEQXRCLE9BRFJxQjs7Y0FHYXBCLE9BSGxCbUIsUUFHYUcsTUFIYkg7VUFJa0IsVUFETEcsTUFDSyxXQURBdEIsT0FIYm9COztjQU1rQm5CLE9BTnZCa0IsUUFNaUJJLEtBTmpCSixRQU1ZSyxNQU5aTCxRQU1LTSxNQU5MTjtVQU91QixVQURsQk0sTUFBT0QsTUFBS0QsS0FDTSxXQURBdEIsT0FObEJtQjs7Y0FRb0JsQixPQVJ6QmlCLFFBUW1CTyxPQVJuQlAsUUFRY1EsTUFSZFIsUUFRT1MsUUFSUFQ7VUFTeUIsVUFEbEJTLFFBQU9ELE1BQUtELE9BQ00sV0FEQXhCLE9BUnBCa0I7O2NBVXdCakIsT0FWN0JnQixRQVV1QlUsT0FWdkJWLFFBVWtCVyxNQVZsQlgsUUFVV1ksUUFWWFo7VUFXNkIsVUFEbEJZLFFBQU9ELE1BQUtELE9BQ00sV0FEQTFCLE9BVnhCaUI7O2NBWW9CaEIsT0FaekJlLFFBWW1CYSxPQVpuQmIsUUFZY2MsTUFaZGQsUUFZT2UsUUFaUGY7VUFheUIsVUFEbEJlLFFBQU9ELE1BQUtELE9BQ00sV0FEQTVCLE9BWnBCZ0I7O2NBY29CZixPQWR6QmMsUUFjbUJnQixPQWRuQmhCLFFBY2NpQixNQWRkakIsUUFjT2tCLE1BZFBsQjtVQWV5QixVQURsQmtCLE1BQU9ELE1BQUtELE9BQ00sV0FEQTlCLE9BZHBCZTs7Y0FxQk1iLE9BckJYWSxRQXFCTW1CLE1BckJObkI7VUFzQlcsVUFETG1CLE1BQ0ssV0FEQS9CLE9BckJOYTtpQkFnQ0wsSUFETVgsT0EvQk5VLFFBZ0NNLHNCQURBVixPQS9CRFc7O2NBa0NnQlYsUUFsQ3JCUyxRQWtDZ0JvQixJQWxDaEJwQjtVQW1DcUIsV0FETG9CLElBQ0ssV0FEQTdCLFFBbENoQlU7O2NBb0NjVCxRQXBDbkJRLFFBb0NjcUIsSUFwQ2RyQjtVQXFDcUIsV0FEUHFCLElBQ08sV0FERjdCLFFBcENkUzs7Y0F1Q21CUixRQXZDeEJPLFFBdUNpQnNCLE1BdkNqQnRCLFFBdUNZdUIsTUF2Q1p2QjtVQXdDMEIsV0FEZHVCLE1BQUtELE1BQ1MsV0FERjdCLFFBdkNuQlE7O2NBeUNxQlAsUUF6QzFCTSxRQXlDbUJ3QixRQXpDbkJ4QixRQXlDY3lCLE1BekNkekI7VUEwQzBCLFdBRFp5QixNQUFLRCxRQUNPLFdBREE5QixRQXpDckJPO2lCQXdCTCxJQURNeUIsUUF2Qk4xQixRQXdCTSxzQkFEQTBCLFFBdkJEekI7aUJBMEJMLElBRE0wQixRQXpCTjNCLFFBMEJNLHNCQURBMkIsUUF6QkQxQjs7Y0FxRHVCMkIsUUFyRDVCNUIsUUFxRGdCNkIsV0FyRGhCN0I7VUFzRDRCLFdBRFo2QixXQUNZLFdBREFELFFBckR2QjNCOztjQXVEdUI2QixRQXZENUI5QixRQXVEZ0IrQixXQXZEaEIvQjtVQXdENEIsV0FEWitCLFdBQ1ksV0FEQUQsUUF2RHZCN0I7aUJBOEJMLElBRE8rQixRQTdCUGhDLFFBOEJPLHNCQURBZ0MsUUE3QkYvQjs7Y0E0QytCZ0MsUUE1Q3BDakMsUUE0QzBCa0MsU0E1QzFCbEMsUUE0Q2VtQyxVQTVDZm5DO1VBNkNvQyxXQURyQm1DLFVBQVdELFNBQ1UsV0FEQUQsUUE1Qy9CaEM7O2NBOENzQm1DLFFBOUMzQnBDLFFBOENrQnFDLFFBOUNsQnJDO1VBK0MyQixXQURUcUMsUUFDUyxXQURBRCxRQTlDdEJuQztpQkFpREwsSUFEZXFDLFFBaERmdEMsUUFpRGUsc0JBREFzQyxRQWhEVnJDOztjQWtEZXNDLFFBbERwQnZDLFFBa0Rld0MsSUFsRGZ4QztVQW1Eb0IsV0FETHdDLElBQ0ssV0FEQUQsUUFsRGZ0Qzs7Y0EyQmF3QyxRQTNCbEJ6QyxRQTJCZTBDLEVBM0JmMUMsUUEyQlEyQyxNQTNCUjNDO1VBNEJrQixXQURWMkMsTUFBT0QsRUFDRyxXQURBRCxRQTNCYnhDLE9BMkREO29DQS9HQU4sYUFuREFsQixVQW1HQXNCOzs7SUM1bEJOLFNDSEU2QyxTRFNTQyxHQUFJLGlCQUFKQSxFQUFvQjtJQU4vQixTQ0pFQyxZRFdZRCxHQUFJLDBCQUFKQSxFQUE2QjtJQVAzQzthQ01FRSxJRDRDSUMsRUFBRUMsR0FBTyxzQkFBVEQsRUFBRUMsR0FBRkQsRUFBRUMsQ0FBMkI7SUFsRG5DLFNDT0VDLElENENJRixFQUFFQyxHQUFPLHlCQUFURCxFQUFFQyxHQUFGRCxFQUFFQyxDQUEyQjtJQW5EbkMsU0NvQ0VFLElEd0NJSCxHQUFJLFlBQUpBLFdBQTRCO0lBNUVsQyxTQzBDRUksS0R3Q0tKLEdBQUksT0FBSkEsTUFBZTtJQXNFdEI7O0tBRUE7S0FFQTtLQUVBO0tBRUE7S0FFQTtLQWxLQTs7SUFrS0EsU0MvQ0VhLE9EcUVNQyxHQUFHQztNQUNYO2dDQURRRDtPQUNSLHlCQURXQztPQUVILG9CQURKQyxLQUEwQkM7TUFFOUIsaUJBSFFILEtBRUpqQixJQURBbUI7TUFHSixpQkFKV0QsS0FFUGxCLEVBREFtQixHQUEwQkM7TUFHOUIsNEJBRklwQixFQUdvQjtJQTNCeEIsU0M3Q0VxQixZRDhFWUM7TVQxTmpCLFFTME5pQkEsaUJBQzBDLE9BRDFDQSxFQUNXLG1DQUFtRDtJQWxDNUUsU0MzQ0VDLGVEMEdlQyxHQUNqQixPQURpQkEsb0JBQ1k7SUFoRTdCLFNDMUNFQztNRDJHaUI7O2lCQUdaOztnQkFBNEI7SUFwRW5DLFNDekNFQztNRCtHcUI7O2tCQUdaO0lBekVYLFNDeENFQyxjRG1IY0wsR0FDaEIsbUNBRGdCQSxFQUNDO0lBNUVqQixTQ3RDRU0sa0JEc0hrQjVCO01BRXBCO1FBQVMsK0JBRldBOzs7K0JBR0Y7UUFQbEIsV0FPc0I7SUFuRnRCLFNDMERFNkIsa0JENkJrQjdCO01BQ3BCLDRCQURvQkEsR0FFUHJFO01BQ1g7V0FGRW1HLEtBQ1NuRyxFQUNJLGNBSEdxRTtRQUlaLDBCQUpZQSxFQUVQckU7UUFFTDs7OztRRDRQRixhQzNQa0IsUUFIWEE7UUFJSixPQU5XcUUsRUFRZDtJQS9GTixTRTNJRWdDLFVGNE9nQm5DO01BQXNCLG1EQUF0QkEsR0FBOEM7SUFqR2hFLFNFNUlFb0MsY0ZpUG9CakM7TUFFdEI7UUFBUyxpQ0FGYUE7OzsrQkFHSjtRQVBJLFdBT0E7SUF4R3RCLFNJcElFa0MsT0pnUFVmLEdBQUdDO01BQ2YsR0FEWUQsUUFHSmdCLEdBSEloQixNQUdWaUIsR0FIVWpCLE1BR1EsVUFBbEJpQixHQUFrQixPQUFaRCxHQUhPZixLQUVQLE9BRk9BLEVBR2M7SUFXbkI7O0tBQ0M7S0FDQTthQ3ZIVG9CLGFEcUlhQyxLQUFLQyxLQUFLQztNQUM0QixJQUFqREMsRUFBaUQsNEJBQTFCLGNBREZELEtBQVZGLEtBQUtDO01BRXBCLHlCQURJRSxFQURxQkQ7TUFFekIsT0FESUMsQ0FFSDtJQWpCVSxTQ3pIVEMsU0Q0SVNGLE1BQ1gsNEJBRFdBLEtBQzZEO0lBcEI3RCxTQ3hIVEcsYUQ4SWFILE1BQ2YsNEJBRGVBLEtBQzJEO0lBdkIvRCxTQ3JIVEk7TURvSkYsU0FBUUM7UVRwVlg7UVNvVmtCOztnQkFFUmxCLGFBQUhtQjs7Y0FFTSxjQUZOQTs7Ozs7d0JBQUduQjs7VUFERyxTQU9FO01BQ0osaURBQXNCO0lBeENuQixTQ2xIVG9CLGFEbUthQyxHQUFHbkQ7TUFDbEIsNEJBRGVtRCxHQUFHbkQsSUFDbEIscUJBRGtCQSxHQUNtQjtJQWxEMUIsU0NuSFRvRCxjRHVLY0QsR0FBR25EO01BQ25CLHNCQURnQm1ELEdBQUduRCxJQUNuQixzQkFEbUJBLEdBQzBCO0lBckRsQyxTQ2pIVHFELE9Ed0tPRixHQUFHbkQsRUFBRXNELElBQUlDO01UNVdyQjthUzRXaUJELFlBQUlDLGdDQUFOdkQsS0FBTXVELFdBQUpEO09BR1QsNEJBSElILEdBQUduRCxFQUFFc0QsSUFBSUM7TUFFYiw4QkFDMEI7SUExRHBCLFNDaEhUQyxpQkQ0S2lCTCxHQUFHbkQsRUFBRXNELElBQUlDO01UalgvQjs7O1FTaVgyQkQ7Ozs7UUFBSUM7OztnQ0FBTnZELEtBQU11RCxXQUFKRDtPQUduQixzQkFIY0gsR0FBR25ELEVBQUVzRCxJQUFJQztNQUV2Qix3Q0FDaUM7SUEvRDNCLFNDN0dURSxhRG1MYUMsS0FBS0MsR0FBSSx5QkFBVEQsS0FBS0MsSUFBZ0M7SUF0RXpDLFNDekdUQyxVRHFMVVQsSUFBSyxjQUFMQSxJQUFlLDZCQUFmQSxHQUFtQztJQTVFcEMsU0N4R1RVLGdCRHFMZ0JWO01BQ2xCLEtBQUssY0FEYUE7TUFFbEI7UUFBSywrQkFGYUEsSUFFa0I7MkJBQUc7SUEvRTVCLFNDcEdUVyxZRDRMWXJCLEtBQUtDLEtBQUtDO01BQzRCLElBQWhEQyxFQUFnRCwyQkFBMUIsY0FERkQsS0FBVkYsS0FBS0M7TUFFbkIseUJBRElFLEVBRG9CRDtNQUV4QixPQURJQyxDQUVIO0lBM0ZVLFNDdEdUbUIsUURtTVFwQixNQUNWLHlCQURVQSxLQUNpQztJQTlGaEMsU0NyR1RxQixZRHFNWXJCLE1BQ2QseUJBRGNBLEtBQytCO0lBakdsQyxTQ2pHVHNCLE1EeU1NQyxHQUFHbEUsRUFBRXNELElBQUlDO01UN1pwQjthUzZaZ0JELFlBQUlDLGdDQUFOdkQsS0FBTXVELFdBQUpEO09BR1IscUJBSEdZLEdBQUdsRSxFQUFFc0QsSUFBSUM7TUFFWiw2QkFDeUI7SUEzR25CLFNBNkdMWSxvQkFBb0JELEdBQUdsRSxFQUFFc0QsSUFBSUM7VUFBSmEsVUFBSUM7TUFDbkM7ZUFEbUNBO1VBRXpCLElBQUpDLEVBQUksY0FGZ0JKLEdBQUdsRSxFQUFFb0UsTUFBSUM7VUFFekIsU0FBSkMsRUFFQztVQUZHLElBR0gsTUFMNEJELFFBRTdCQyxNQUdDLE1BTHdCRixRQUV6QkUsTUFGeUJGLFlBQUlDOztRQUNsQixTQUtkO0lBbkhRLFNDaEdUSSxhRHFOYVAsR0FBR2xFLEVBQUVzRCxJQUFJQztNVDFhM0I7YVMwYXVCRCxZQUFJQyxnQ0FBTnZELEtBQU11RCxXQUFKRDtPQUdmLDJCQUhVWSxHQUFHbEUsRUFBRXNELElBQUlDO01BRW5CLG9DQUNnQztJQXhIMUIsU0MvRlRtQixvQkR5Tm9CUixHQUFHWDtNQUNqQixJQUFKdkQsRUFBSSxrQkFEaUJ1RDtNQUV6QixhQUZzQlcsR0FDbEJsRSxJQURxQnVEO01BRXpCLDRCQURJdkQsRUFFb0I7SUE3SGIsU0NsR1QyRSxXRG1PV2pCO01BQ2IsU0FBUWtCLGFBQWFDOzs7O2dCQUViMUMsY0FBTkMsY0FDTW1CLHlCQURObkI7WUFFRSxnQkFGRkEsS0FGbUJ5QyxZQUdidEI7WUFDSixrQkFESUEsNEJBREFwQjs7VUFEQSxPQURhMEM7VUFNUkMsT0FBS3ZCO01BQ2hCO1FBQVEsSUFBSmpDLEVBQUksZ0NBUkdvQztRQVFILFNBQUpwQztVQUNVLEtBRkh3RCxLQUlEO21CQUNhLCtCQUxQdkIsU0FBTHVCOztVQU1GLFVBTEx4RDtZQWNRLElBQU55RCxJQUFNLG9CQWRSekQ7WUFlSSxjQXZCR29DLEtBc0JMcUIsUUFkRnpEO1lBY1EsSUFDSixNQWhCUWlDLE1BQ1pqQyxNQWVJLFVBREZ5RCxJQWZLRCxrQkFBS3ZCOztVQU9KLElBQU4wQixJQUFNLGtCQU5SM0Q7VUFPSyxjQWZFb0MsS0FjTHVCLE1BTkYzRDtVQVFLLG1CQWhCRW9DO1VBZ0JGLEdBVEVvQjtXQVlEO21CQVpNdkIsTUFDWmpDO2lCQVltQiwrQkFEVCtDLGdCQUxSWSxJQVBLSDs7b0JBT0xHOzBDQVk2QjtJQTNKMUIsU0N2RlRDLGVEMlBlaEI7TUFBSztRQUFLLCtCQUFWQSxJQUFnQzsyQkFBRztJQXBLekMsU0N0SlRpQixXRGdVV3ZDLEdBQUksMkJDbFVmTixPRGtVV00sRUFBd0I7SUExSzFCLFNDckpUd0MsYURnVWFwRixHQUFJLHFCQ25VakJzQyxPRG1VYXRDLEVBQTBCO0lBM0s5QixTQ3BKVHFGLFlEZ1VZckYsR0FBSSxvQkNwVWhCc0MsT0RvVVl0QyxFQUF5QjtJQTVLNUIsU0NuSlRzRixVRGdVVTNKO01BQXlCLHFCQ3JVbkMyRyxPRHFVbUMsNEJBQXpCM0csR0FBMEM7SUE3SzNDLFNDbEpUNEosWURnVVkxRixHQUF5QixxQkN0VXJDeUMsT0RzVXFDLFVBQXpCekMsR0FBNEM7SUE5Sy9DLFNDakpUMkYsY0RnVWN4RjtNQUNoQixjQ3hVRXNDLE9EdVVjdEM7TUFDUSxvQkN4VXRCc0M7TUR3VStDLHFCQ3hVL0NBLE9Ed1UyRDtJQWhMbEQsU0NoSlRtRDtNRGlVbUIsb0JDelVuQm5ELFdEeVU0QyxxQkN6VTVDQSxPRHlVd0Q7SUFqTC9DLFNDL0lUb0QsV0RvVVc5QyxHQUFJLDJCQzVVZkwsT0Q0VVdLLEVBQXdCO0lBckwxQixTQzlJVCtDLGFEb1VhM0YsR0FBSSxxQkM3VWpCdUMsT0Q2VWF2QyxFQUEwQjtJQXRMOUIsU0M3SVQ0RixZRG9VWTVGLEdBQUksb0JDOVVoQnVDLE9EOFVZdkMsRUFBeUI7SUF2TDVCLFNDNUlUNkYsVURvVVVsSztNQUF5QixxQkMvVW5DNEcsT0QrVW1DLDRCQUF6QjVHLEdBQTBDO0lBeEwzQyxTQzNJVG1LLFlEb1VZakcsR0FBeUIscUJDaFZyQzBDLE9EZ1ZxQyxVQUF6QjFDLEdBQTRDO0lBekwvQyxTQzFJVGtHLGNEb1VjL0Y7TUFDaEIsY0NsVkV1QyxPRGlWY3ZDO01BQ1Esb0JDbFZ0QnVDO01Ea1YrQyxxQkNsVi9DQSxPRGtWMkQ7SUEzTGxELFNDeklUeUQ7TURxVW1CLG9CQ25WbkJ6RCxXRG1WNEMscUJDblY1Q0EsT0RtVndEO0lBNUwvQyxTQ3hJVDBELGlCRHdVZSxjQ3hWZjNELFFEd1ZlLGtCQ3pWZkQsTUR5VjZDO0lBaE1wQyxTQ3ZJVDZELGdCRHdVd0MsMEJBQWIsYUFBYTtJQWpNL0IsU0N0SVRDLG9CRHdVbUMsc0NBQWE7SUFsTXZDLFNDcklUQyxrQkR3VTRDLDRCQUFiLGFBQWE7SUFuTW5DLFNDcElUQyxzQkR3VXVDLGtDQUFhO0lBcE0zQyxTQ3pFVEMsd0JWNU9MLElTbWhCcUMvSDtJQTlOdkIsU0NyRVRnSTtNRDJTTTtPQUZzQ0M7T0FBTnBKO09BQWhCcUo7T0FBTnRKO09BRVYsWUFGZ0JzSixLQUVULGFBRitCRDtNQUN0QyxxQkFEVXJKLEtBQXNCQztJQXBPN0IsSUE0T1RzSixpQkNqV0EzRDtJRHFIUyxTQ25FVDRELFFEaVRROUc7TUFDVixNQUhFNkcsaUJBR0Y7Ozs7UUFLSSxPQUhBRyxrQkFHMkIscUJBQTZCLFdBTmxEaEg7UUFNcUQsa0JBTDNEK0csSUFNRztNQU5QLFFBTVE7SUFyUEcsU0NqRVRFLGtCRHdUZ0Isa0JBWGhCSixtQkFXbUM7SUF2UDFCLFNDcEVUSyxLRDZUS0M7TUFDUCxjQUNBLDZCQUZPQSxRQUVTO0lBRVY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09DL2hCSi9HO09BQ0FGOzs7Ozs7Ozs7Ozs7OztPQVNBRztPQUNBRztPQTZCQUM7T0VORVE7T0ZRRkM7T0FJQVI7T0NsQ0FDO09BQ0FDO09BQ0FDO09BTUFDO09BQ0FDO09BQ0FDO09EaUdBRztPQUVBSztPQUVBRTtPQUVBRztPQURBRDtPQUVBRTtPQUVBQztPQ3JHQUk7T0FEQUM7T0VRQUM7T0h1R0FHO09BQ0FDO09BQ0FDO09BQ0E0QztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBRTtPQURBRDtPQUdBRztPQURBRDtPQVlBdkQ7T0FDQUM7T0FDQU47T0FDQXlGO09BQ0FsRjtPQUNBaUY7T0FDQTVFO09BQ0FGO09BQ0FHO09BQ0FHO09BQ0F1RTtPQUNBRDtPQUNBckU7T0FDQW9FO09BQ0FEO09BQ0FEO09BQ0EvRDtPQUNBQztPQUNBNkQ7T0FDQTNEO09BQ0FDO09BQ0FGO09BQ0EyRDtPQUNBOUM7T0FDQVY7T0FDQVE7T0FDQUM7T0FDQThDO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FoQztPQUNBK0I7Ozs7Ozs7O09BYUFYO09BSUFDO09BQ0FRO09BQ0FKO09BQ0E5RTtPRCtLSXNDO09DOUtKMkM7SUQ4VEk7Ozs7O09DL2hCSjdHO09BQ0FGOztPQVNBRztPQUNBRztPQTZCQUM7T0VORVE7T0ZRRkM7T0FJQVI7T0NsQ0FDO09BQ0FDO09BQ0FDO09BTUFDO09BQ0FDO09BQ0FDO09EaUdBRztPQUVBSztPQUVBRTtPQUNBRTtPQUNBQztPQUNBQztPQUVBQztPQ3JHQUk7T0FEQUM7T0VRQUM7T0h1R0FHO09BQ0FDO09BQ0FDO09BQ0E0QztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQVdBeEQ7T0FDQUM7T0FDQU47T0FDQXlGO09BQ0FsRjtPQUNBaUY7T0FDQTVFO09BQ0FGO09BQ0FHO09BQ0FHO09BQ0F1RTtPQUNBRDtPQUNBckU7T0FDQW9FO09BQ0FEO09BQ0FEO09BQ0EvRDtPQUNBQztPQUNBNkQ7T0FDQTNEO09BQ0FDO09BQ0FGO09BQ0EyRDtPQUNBOUM7T0FDQVY7T0FDQVE7T0FDQUM7T0FDQThDO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FEO09BQ0FoQztPQUNBK0I7T0FhQVg7T0FJQUM7T0FDQVE7T0FDQUo7T0FDQTlFO09BQ0FpRjtJRDhUSTthSzFoQkpvQixhQUFXLFFBQUc7YUFFZEMsU0FBT2hJLFNBQU8sVUFBUEEsRUFGUCtILE1BRTZCO2FBRTdCRSxLQUFLakksRUFBRWtJLFlBQVUsVUFBWmxJLEVBQUVrSSxLQUF3QjthQUUzQkMsU0FBT0MsS0FBS0M7TUFDWixxQkFET0Q7TUFDUDtZQUVLRixjQUFIbEk7UUFBcUIsVUFBckJBLGlCZGpDWCxPYzhCU21JLFNBR0tELEtBSE9HO01BRVQsa0JBRlNBLE9BRzRCO2FBRXhDQyxJQUFJNUksRUFBRTZJO01BQWUscUJBQWZBO01BQWU7UUFFSTtTQUFwQkw7U0FBSGxJO1NBQXVCLG9CZHJDbEMsT2NtQ1NzSSxJQUFJNUksRUFFQ3dJO1FBQWUscUJBRmhCeEksRUFFRk07TUFEQyxRQUNpQzthQUVwQ3dJLFdBQVc5SSxFQUFFNkk7TWR2Q3RCLEljdUNzQkU7TUFBUztRQUFNLHFCQUFmQTtRQUFlO1VBR3hCLElBRENQLGNBQUhsSSxXQUNFLG1CQUhPTixFQUVUTTtVQUNFO1lBRVEsSUFBTEM7WUFBYyxVQUFkQSxpQmQ1Q2hCLE9jdUNTdUksV0FBVzlJLEVBRU53STtVQUNELElBSFNPLE1BRVJQOztRQURGLFNBSW9DO2FBRXZDUSxPQUFPaEosRUFBRTZJO01kOUNsQixJYzhDa0JFO01BQVM7UUFBTSxxQkFBZkE7UUFBZTtjQUVuQlAsY0FBSGxJO1VBQ0QsY0FITU4sRUFFTE07V0FFVSxVQUZWQSxpQmRoRFgsT2M4Q1MwSSxPQUFPaEosRUFFRndJO2NBRklPLE1BRUpQOztRQURGLFNBSWdCO2FBRW5CUyxtQkFBU2pKLEVBQUU2STtNQUFlLHFCQUFmQTtNQUFlO1FBR2YsSUFETkwsY0FBSGxJLFdBQ1MsZ0JBSEZOLEVBRVBNO1FBQ1M7O2lCQUdmNEkseUJBTmFsSixPQUVKd0k7c0NBSVRVLGtCQU5hbEosT0FFSndJO01BREYsUUFFcUI7YUFHNUJVLHVCQUFhbEosRUFBRTZJLElBQUlNO01BQWdCLHFCQUFwQk47TUFBb0I7WUFFMUJMLGNBQUhsSTtRQUNHLFVBREhBLGlCZDdEWCxPYzJESzhJLGFBQWFwSixFQUVKd0ksS0FGVVc7TUFBZ0I7TUFDNUI7O2VBUEhGLHFCQU1TakosRUFBTW1KO29DQU5mRixjQU1TakosRUFBTW1KLFdBR2U7YUFUOUJFLFNBQVNySixFQUFFNkk7TWRyRHBCLHVCY3FEU0ksYUFBU2pKLEVBQUU2STthQU1mTyxhQUFhcEosRUFBRTZJLElBQUlNO01kM0R4Qix1QmMyREtELGlCQUFhbEosRUFBRTZJLElBQUlNO2FBS25CRyxVQUNVdEosRUFBRXVKLElBQUlWO1VBQUpXLFVBQUlUO01BQU07UUFBTSxxQkFBWkE7UUFBWTtVQUdkO1dBREhQO1dBQUhsSTtXQUNNLGlCQUhKTixFQUFFd0osTUFFSmxKO1dBRklrSjtXQUFJVCxNQUVMUDs7UUFERixPQURHZ0IsTUFNRDthQUVYckcsS0FBS25ELEVBQ0s2STtNZDFFZixJYzBFZUU7TUFBTTtRQUFNLHFCQUFaQTtRQUFZO2NBRVhQLGNBQUhsSTtVQUNKLFdBSkNOLEVBR0dNO2NBRkV5SSxNQUVDUDs7UUFERixTQUtKO2FBRURrQixPQUFPMUosRUFBRTJKO01BQ1QscUJBRE8zSixFQUFFMko7TUFDVDs2QkFFS0MsZUFBSHRKO1FBQW1CLFVBQW5CQSxpQmRyRlgsT2NrRlNvSixPQUFPMUosRUFHRjRKO01BREQsUUFDNkI7Ozs7T0E3RHJDdkI7T0FFQUM7T0FFQUM7T0FFSUU7T0FLQUc7T0FXQUk7T0FQQUY7T0FjQU87T0FXSkM7T0FTQW5HO09BU0l1Rzs7UUNoRUpHO2FBQ0FDLEtBQUtoRyxHQUFJLFVBQUpBLEVBQVU7YUFDZmlHLE1BQU1DLEVBQUdDLFdBQVUsR0FBYkQsR0FBb0MsSUFBTGxHLEVBQS9Ca0csS0FBb0MsT0FBTGxHLEVBQWlCLE9BQTdDbUcsU0FBb0Q7YUFDN0RDO01BQU0sVUFBbUIsSUFBTHBHLFdBQUssT0FBTEE7TUFBaUIsc0NBQTRCO2FBQ2pFcUcsS0FBS0gsRUFBRWhLLEdBQUksR0FBTmdLLEdBQTRDLElBQUxsRyxFQUF2Q2tHLEtBQTRDLGtCQUExQ2hLLEVBQXFDOEQsR0FBWixRQUFvQjthQUNwRHNHLFlBQU8sVUFBbUIsSUFBTEosV0FBSyxPQUFMQSxFQUFpQixRQUFJO2FBQzFDSyxNQUFJckssRUFBRWdLLEdBQUksR0FBSkEsR0FBMEMsSUFBTGxHLEVBQXJDa0csS0FBK0MscUJBQWpEaEssRUFBdUM4RCxJQUFaLFFBQTJCO2FBQzFEd0csS0FBTVQsS0FBTUM7TWZ6QmpCLFVleUIyQyxJQUFMaEcsV0FBSyxrQkFBMUJnRyxLQUFxQmhHLEdBQXNCLE9BQWpEK0Y7YUFDTlUsT0FBS3ZLO01mMUJWLFVlMEJpQyxJQUFMOEQsV0FBSyxrQkFBdkI5RCxFQUFrQjhELEdBQW1CO2FBQzFDMEcsZUFBVSxnQkFBdUM7YUFDakRDLGVBQVUsZ0JBQXVDO2FBRWpEQyxNQUFNQyxHQUFHQyxHQUFHQztNQUFLLEdBQVJEO1dBQUdDLFFBQ0FDLEdBREFELE1BQ1RFLEdBRE1ILHdCQUFIRCxHQUNISSxHQUFTRDs7T0FDQSxLQUZBRCxHQUVBO01BQ1QsUUFBSzthQUVSRyxRQUFRQyxJQUFJTCxHQUFHQztNQUFLLEdBQVJEOztXQUFHQyxJQUNHLElBQU5DLEdBREdELE1BQ0csa0JBRFZJLFNBQ0lIO1FBR0U7TUFEQSxPQUhDRCxPQUlBO2FBRWZLLFVBQVdyQjtNZnpDaEIsVWV5QytELElBQUwvRixXQUFLLFVBQUxBLEdBQWxCLFVBQXhCK0Y7YUFDWHNCLGVBQVUsVUFBZ0MsSUFBTHJILFdBQUssVUFBTEEsS0FBVixRQUFrQjthQUM3Q3NIO01BQVMsVUFBdUMsSUFBTHRILFdBQUssc0JmM0NyRCxPYzBCS3dFLFNDaUIyQ3hFO01BQWpCLE9EbkIxQnVFLEtDbUI0RDs7OztPQXpCNUR3QjtPQUNBQztPQUNBQztPQUNBRztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQUtBTTtPQU1BRTtPQUNBQztPQUNBQzs7YUN6QkFDLEdBQUd2SCxHQUFJLFVBQUpBLEVBQVE7YUFDWHdILE1BQU1DLEdBQUksVUFBSkEsRUFBVzthQUNqQkMsUUFBTS9HLEVBQUd3RjtNQUFVLFNBQWJ4RixNQUFrQyxJQUFMWCxFQUE3QlcsS0FBa0MsT0FBTFgsRUFBb0IsT0FBOUNtRyxTQUFxRDthQUM5RHdCO01BQVMsbUJBQWlCLElBQUwzSCxXQUFLLE9BQUxBO01BQW9CLHVDQUErQjthQUN4RTRIO01BQVksa0JBQWdDO01BQVosSUFBTEg7TUFBSyxPQUFMQSxDQUE2QzthQUN4RUksT0FBS2xILEVBQUV6RTtNQUFJLFNBQU55RSxNQUEyQixJQUFMWCxFQUF0QlcsS0FBMkIsa0JBQXpCekUsRUFBb0I4RCxHQUEyQixPQUFqRFcsQ0FBa0Q7YUFDdkRtSCxPQUE0QkwsR0FBckIsU0FBcUJBLE1BQUosSUFBTDlHLEVBQVM4RyxLQUFKLE9BQUw5RyxFQUF5QixPQUFoQjhHLENBQWlCO2FBQzdDTSxNQUFJN0wsRUFBZ0N1TDtNaEJ6QnpDLFNnQnlCeUNBLE1BQVgsSUFBTHpILEVBQWdCeUgsS0FBUixxQkFBeEJ2TCxFQUFnQjhELElBQWdDLE9BQWhCeUg7YUFDcENPLFVBQVU5TCxFQUFzQzhEO01oQjFCckQsU2dCMEJxREEsS0FBYSxPQUFiQSxFQUFkLElBQUx5SCxFQUFtQnpILEtBQVIscUJBQTlCOUQsRUFBbUJ1TDthQUM3QlEsT0FBTVYsR0FBSUM7TWhCM0JmLG1CZ0IyQndDLElBQUx4SCxXQUFLLGtCQUE3QnVILEdBQXdCdkg7TUFBdUIsSUFBTHlIO01BQUssa0JBQTNDRCxNQUFzQ0M7YUFDaERTLE9BQUtoTTtNaEI1QlYsbUJnQjRCK0IsSUFBTDhELFdBQUssa0JBQXJCOUQsRUFBZ0I4RCxHQUFzQjthQUMzQ21JLFdBQVdqTTtNaEI3QmhCLGtCZ0I2QnNELFNBQWQsSUFBTHVMLFdBQUssa0JBQXhCdkwsRUFBbUJ1TDthQUM5QlcsYUFBUSx5QkFBd0M7YUFDaERDLGdCQUFXLHlCQUF3QzthQUVuREMsUUFBT2YsR0FBSUMsTUFBTWUsR0FBR0M7TUFBSyxTQUFSRDs7aUJBQUdDLFVBQ04sSUFBTnhCLEdBRFl3QixTQUNOLGtCQURQakIsUUFDQ1A7O2lCQURTdUI7aUJBQUdDLFVBRUEsSUFBTkMsR0FGTUQsU0FFQSxrQkFGVGhCLFdBRUdpQjtNQUNSLFFBQUs7YUFFWEMsVUFBU25CLEdBQUlDLE1BQU1lLEdBQUdDO01BQUssU0FBUkQ7O2lCQUFHQyxVQUNSLElBQU54QixHQURjd0IsU0FDUixrQkFETGpCLFFBQ0RQO1FBRU87ZUFISXVCO2VBQUdDLFNBSVA7TUFGSyxJQUFOQyxHQUZRRDtNQUVGLGtCQUZQaEIsV0FFQ2lCLEdBRUU7YUFFaEJFO01BQVksbUJBQWlCLElBQUwzSSxXQUFLLFVBQUxBLEdBQXlCLFFBQUk7YUFDckQ0STtNQUFVLG1CQUFpQixJQUFMNUksV0FBSyxVQUFMQSxLQUFzQixRQUFFO2FBQzlDNkk7TUFBUztRQUFpQixJQUFMN0ksV0FBSyxzQmhCOUMvQixPYzBCS3dFLFNFb0JxQnhFO01BQStCLE9GdEJwRHVFLEtFc0I2RDs7OztPQTVCN0RnRDtPQUNBQztPQUNBRTtPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQUtBSTtPQU1BQztPQUNBQztPQUNBQzs7SUN6QitCLFNBQS9CQyxtQmpCckJMO0lpQnFCb0MsSUFDL0JDO0lBRCtCLFNBRy9CQyxnQkFBVyxrQkFBaUM7SUFIYixTQVkvQkMsbUJBQVksbUNBQTBDO0lBWnZCLG1CQVluQixXQUEwQztJQVp2Qjs7O3NCakJyQnBDO09pQnFCS0g7T0FDQUM7O09BRUFDO09BU0FDO0lBWitCO2FDQS9CcE8sSUFBSThDO01sQnJCVCxRa0JxQlNBLGlCQUMrQyxPQUQvQ0EsRUFDbUIsZ0NBQXdDO2FBTy9EdUwsUUFPQWpLO01sQnBDTDtNa0I2QmUsU0FPVkE7b0JBTFEsMEJBS1JBOzs7b0JBTlE7O29CQU1SQTs7a0JBRFE7a0JBRkE7bUJBREE7bUJBRUE7O01WOGVKO1FVM2VNLElBQUprSyxJQUFJOzhCQUFKQSxNQURObEs7UUFDVSw0QkFBSmtLO01BS0osSUFBSTlNLEVBQUo7NEJBQUlBO01BQUosc0JBQUlBLFVBTk40QztNQU1FLHNCQUFJNUMsV0FOTjRDO01BTUUsc0JBQUk1QyxVQU5ONEM7TUFNRSw0QkFBSTVDLEVBS2M7YUFFcEIrTSxVQUNBbks7TUFEWSxTQUNaQTtNQURZOzs7O01WK2RSLGdCVTlkSkEsWUFJTTthQUVOb0ssVUFDQXBLO01BRFksU0FDWkE7TUFEWTs7OztNVndkUixnQlV2ZEpBLFlBSU07YUFFTnFLLGdCQUNBcks7TUFEa0IsYUFDbEJBLFdBRGtCLDJCQUNsQkEsWUFDTTthQUVOc0ssZ0JBQ0F0SztNQURrQixhQUNsQkEsV0FEa0IsMkJBQ2xCQSxZQUNNO2FBSU51SyxVQUFRQyxHQUFHQyxJQUFLLE9BQVJELEtBQUdDLE1BQXNCO2FBQ2pDQyxRQUFPRixHQUFRQyxJQUFTLGNBQWpCRCxLQUFRQyxXQUEwQjs7OztPQXJEekM3TztPQVFBcU87T0FvQkFFO09BT0FDO09BT0FDO09BSUFDO09BTUFDO09BQ0FHOzs7S2pCakRBQztLQUNBQztLQUNBQztLQUNBQztLQUVBQztLQUNBQzthQUVBQyxLQUFLckU7TUFDUCxPQURPQTtlQUxMa0U7ZUFLS2xFLGNBRVMsWUFoQmR2UCxhQWNLdVAsU0FHRjthQUVIc0UsS0FBS3RFO01BQ1AsT0FET0EsWUFYTGlFLFNBV0tqRSxRQUVTLFlBdEJkeFAsYUFvQkt3UCxTQUdGO2FBRUh1RSxTQUFTcFM7TUFBSSxjQUFKQSxNQUFJLFVBQUpBOzs7OztNQUpYLFdBSXlFO2FBQ3ZFcVMsT0FBT3JTO01BQU8sZ0JBQVBBOztlU3pCUHNFO2lCVENlO3lDQXdCUnRFLG1DQUF3RDthQUkvRHNTLFFBQVF6RSxHQUFJLE9BQUpBLFdBQVc7YUFDbkIwRSxRQUFRdEwsR0FBSSxPQUFKQSxDQUFlO2FBQ3ZCdUwsUUFBUTNFO01BQ1YsYUFEVUE7ZVMvQlJ2SjtpQlRFMEI7Ozs2Q0E2QmxCdUo7Z0JBRU87YUFFZjRFLHFCQUhGLFdBQ2lCO2FBSWZDLG1CRHhETDtRQ3lES0M7YUFDQUMsV0QxREw7Ozs7O09DeUJLaEI7T0FDQUM7T0FJQUc7T0FDQUM7T0FFQUM7T0FLQUM7T0FLQUM7T0FDQUM7c0JENUNMOztPQ2dES0M7T0FDQUM7T0FDQUM7T0FJQUM7T0FFQUM7T0FDQUM7T0FDQUM7O0lEMURMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09ZK0NLQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SVovQ0w7YWF5QktDLE9BQU8zTTs7OztVQUZDLHVEQUFMNE07O1FBREcsV0FHbUI7YUFFekJDLE9BQUsxTCxFQUFFbkIsR0FBSSxVQUFObUIsRUFBRW5CLEVBQVE7YUFFZk07TUFBSyxVQUVHLElBQVJhLFdBQVEsT0FBUkEsRUFETSx1QkFDRzthQUVUZDtNQUFLLFVBRUcsSUFBTEwsV0FBSyxPQUFMQSxFQURHLHVCQUNHO2FBRVQ4TSxJQUVjOU0sRUFBRVI7TUFEbEIsUUFDa0JBO1lBQUZ1TixNQUFFQztRQUNoQjthQURjRDtnQkFHVEUsSUFIU0YsT0FHWjVMLEVBSFk0TDtxQkFBRUMsSUFHUSxPQUF0QjdMO1lBQTZCLFFBSGY2TCxZQUFGRCxJQUdURSxJQUhXRDs7VUFFUjtNQUhJLGdDQUtBO2FBRVpHLFFBRWNuTixFQUFFUjtNQURsQixRQUNrQkE7WUFBRnVOLE1BQUVDO1FBQ2hCO2FBRGNEO2dCQUdURSxJQUhTRixPQUdaNUwsRUFIWTRMO3FCQUFFQyxJQUdRLFVBQXRCN0w7WUFBa0MsUUFIcEI2TCxZQUFGRCxJQUdURSxJQUhXRDs7VUFFUjtNQUhJLGtDQUtBO2FBSVJJLFdBQVcvTixHQUFHQztVQUFIK04sUUFBR0M7TUFDcEI7V0FEaUJEOzJCQUdmbE0sRUFIZWtNLFFBQUdHLFFBR2xCck0sRUFIa0JtTSxNQUFIRCxVQUFHQzs7UUFFWixPQUZZQSxLQUdjO2FBRWhDRyxJQUFJek4sR0FBSSxrQkFBSkEsSUFBbUI7YUFNbkIwTixTQUFTN1QsRUFBRTJGLEVBQUV6QjtNQUNuQixHQURpQnlCLEtBQUYzRixFQUNBO01BRUwsSUFBSjJJLEVBQUksV0FIU3pFLEVBQUpsRTtNQUlSLFVBREQySSxFQUNDLFNBSlEzSSxVQUFFMkYsRUFBRXpCLEdBSU07UUFFdkI0UDtrQkFPS2xNLElBQUkxRDtNQUNYLFFBRE8wRDtRQUVQLEdBVEVrTSxxQkFPS2xNO2NBakJnQjZGLE1BQUl6TjtVQUMzQjtlQWdCTzRILE9BakJvQjVILFNBRnpCNFQsSUFFcUJuRztZQUVsQixRQUZzQnpOLFVBRUosb0JBZVprRSxFQWpCZ0JsRSxHQUFKeU4sZUFBSXpOOztRQW9CdEIsa0JBSEU0SCxJQUFJMUQ7TUFDSyxpQ0FFSzs7TUFFTCxjQUVYeUUsV0FBSHhDLFdBQVksY0FBWkEsRUFBWSxRQUFUd0M7TUFERyxRQUNlO21CQUliekU7TWIxRmI7UWE0RnFCLElBQWJpQyxXQUFIbUIsV0FBZ0IsYUFGUnBELEVBRVJvRCxHQUE0QixVQUFoQnFCLEVBQWdCLE1BRnBCekUsRUFFTGlDO01BREc7aUJBR0duRyxFQUFFa0U7TWI5RmhCO1FhZ0dxQixJQUFiaUMsV0FBSG1CLFdBQWdCLGFBRkxwRCxFQUFGbEUsRUFFVHNIO1FBQThCLFVBQWxCcUIsRUFBa0IsSUFGckIzSSxVQUFFa0UsRUFFUmlDO01BREc7a0JBR0RqQyxFQUFFaUMsR0FBSSxhQUFOakMsRUFBRWlDLEVBQWM7cUJBRWJqQyxFQUFFNlA7Ozs7VUFHUTtXQUFiNU47V0FBSG1CO1dBQWdCLHFCQUhWcEQsRUFHTm9EOzttQkFBR25COztRQURHLFlBR0M7b0JBR0FqQztNYjVHZDs7O2NhOEdRaUMsYUFBSG1CO1VBQVEsV0FGQ3BELEVBRVRvRDtzQkFBR25COztRQURHO21CQU9BakMsRUFBRWdQOzs7O2NBRkwvTSxXQUFIbUI7VUFBUSxXQUVGcEQsSUFGTm9EO1VBQVEsOEJBQUxuQjs7UUFERyxTQUdpQjt5QkFFVGpDLEVBQUVpRixLQUFLaEQ7VUFBTGtELFlBQUs2SjtNQUN2QjtXQUR1QkE7VUFHRDtXQUFqQkUsSUFIa0JGO1dBR3JCNUwsRUFIcUI0TDtXQUdELGtCQUhOaFAsRUFBRW1GLE9BR2hCL0I7V0FIZ0IrQjtXQUFLNkosSUFHbEJFOztRQURHLE9BRlUvSixPQUdnQjt3QkFFakJuRixFQUFFaUMsRUFBRWdEO01BQ3JCLEdBRG1CaEQsT0FHZCtNLElBSGMvTSxLQUdqQm1CLEVBSGlCbkIsS0FHTCxrQkFIR2pDLEVBR2ZvRCxFQUFZLFdBSEdwRCxFQUdaZ1AsSUFIZ0IvSjtNQUViLE9BRmFBLElBR2M7a0JBRXhCakYsRUFBRXNCLEdBQUdDO01BQ2hCLEdBRGFEO1dBQUdDO1VBR2MsSUFBZmdPLEtBSENoTyxNQUdMd08sR0FIS3hPLE1BR1QrTixLQUhNaE8sTUFHVjBPLEdBSFUxTyxNQUdpQixhQUhuQnRCLEVBR1JnUSxHQUFRRDtVQUFtQyxVQUFwQnRMLEVBQW9CLEtBSG5DekUsRUFHSnNQLEtBQVFDOztPQURELEtBRkVoTyxHQUVGO01BRUYsaUNBQXVCO3NCQUV4QnZCLEVBQ1VzQixHQUFHQztVQUFSMEQsT0FBS3FLLFFBQUdDO01BQ3RCO1dBRG1CRDthQUFHQztZQUdTO2FBQWhCRSxLQUhPRjthQUdYUSxHQUhXUjthQUdmQyxLQUhZRjthQUdoQlUsR0FIZ0JWO2FBR1kscUJBSnRCdFAsRUFJTmdRLEdBQVFELElBSEc5Szs7YUFBS3FLLEtBR1pFO2FBSGVELEtBR1BFOzs7U0FERCxLQUZRRixLQUVSLE9BRkF0SztRQUlGLHNDQUVFO21CQUdKakYsRUFBRXNCLEdBQUdDO1VBQUgrTixRQUFHQztNQUNqQjtXQURjRDthQUFHQztnQkFHRkUsS0FIRUYsUUFHTlEsR0FITVIsUUFHVkMsS0FIT0YsUUFHWFUsR0FIV1Y7WUFHUSxXQUhWdFAsRUFHVGdRLEdBQVFEO2dCQUhHVCxLQUdQRSxLQUhVRCxLQUdGRTs7O1NBREQsS0FGR0YsS0FFSDtRQUVGLG1DQUF3Qjt3QkFFbkJ2UCxFQUFFaUYsS0FBSzNELEdBQUdDO1VBQVI0RCxZQUFLbUssUUFBR0M7TUFDM0I7V0FEd0JEO2FBQUdDO1lBR1E7YUFBcEJFLEtBSFlGO2FBR2hCUSxHQUhnQlI7YUFHcEJDLEtBSGlCRjthQUdyQlUsR0FIcUJWO2FBR1csa0JBSGxCdFAsRUFBRW1GLE9BR2hCNkssR0FBUUQ7YUFIUTVLO2FBQUttSyxLQUdqQkU7YUFIb0JELEtBR1pFOzs7U0FERCxLQUZhRixLQUViLE9BRktwSztRQUlQLHdDQUE2Qjt5QkFFdkJuRixFQUFFc0IsR0FBR0MsR0FBRzBEO01BQzFCLEdBRG9CM0Q7V0FBR0M7Y0FHUmdPLEtBSFFoTyxNQUdad08sR0FIWXhPLE1BR2hCK04sS0FIYWhPLE1BR2pCME8sR0FIaUIxTztVQUdVLGtCQUhadEIsRUFHZmdRLEdBQVFELEdBQW1CLFlBSFovUCxFQUdYc1AsS0FBUUMsS0FIV3RLOztPQUVaLEtBRlMxRCxHQUVULE9BRlkwRDtNQUlkLHdDQUE4QjtxQkFFNUJnTDtNYmxLakI7OztVYW9LYSxJQUFMaE8sYUFBSG1CLGFBQVEsZ0JBRkk2TSxFQUVaN007VUFBUSxxQkFBTG5CO1VBREc7O29CQUdLZ087TWJ0S2hCOzs7VWF3S2EsSUFBTGhPLGFBQUhtQixhQUFRLGdCQUZHNk0sRUFFWDdNO1VBQVEsUUFERjtVQUNFLFlBQUxuQjs7UUFERztzQkFHT2dPLEVBQUUzTyxHQUFHQztVQUFIK04sUUFBR0M7TUFDcEI7V0FEaUJEO2FBQUdDO1lBR0U7YUFBUEUsS0FIS0Y7YUFHVFEsR0FIU1I7YUFHYkMsS0FIVUY7YUFHZFUsR0FIY1Y7YUFHSyxnQkFIUFcsRUFHWkQsR0FBUUQ7WUFBVyxhQUhMVCxLQUdWRSxLQUhhRCxLQUdMRTs7O1NBREQsS0FGTUYsS0FFTjtRQUVGLHNDQUEyQjtxQkFFekJVLEVBQUUzTyxHQUFHQztVQUFIK04sUUFBR0M7TUFDbkI7V0FEZ0JEO2FBQUdDO1lBR0c7YUFBUEUsS0FISUY7YUFHUlEsR0FIUVI7YUFHWkMsS0FIU0Y7YUFHYlUsR0FIYVY7YUFHTSxnQkFIUlcsRUFHWEQsR0FBUUQ7WUFBVztnQkFITlQsS0FHVEUsS0FIWUQsS0FHSkU7OztTQURELEtBRktGLEtBRUw7UUFFRixxQ0FBMEI7aUJBRTVCalA7TWJ0TGI7OztVYXdMYSxJQUFMMkIsYUFBSG1CLGFBQVEsd0JBQVJBLEVBRlE5QztVQUVBLFFBREY7VUFDRSxZQUFMMkI7O1FBREc7a0JBR0czQjtNYjFMZDs7O2NhNExRMkIsYUFBSG1CLHdCQUZTOUM7a0JBQ0g7c0JBQ0gyQjs7UUFERzttQkFHSTNCO01iOUxmOzs7Y2FnTVkyQiw4QkFBSk4sV0FBRnlCO1VBQWMsc0JBQWRBLEVBRlM5QyxHQUUwQixPQUFqQ3FCO3NCQUFJTTs7UUFERDt1QkFHUTNCO01ibE1uQjs7O2Nhb01ZMkIsOEJBQUpOLFdBQUZ5QjtVQUFjLHNCQUFkQSxFQUZhOUMsR0FFc0IsVUFBakNxQjtzQkFBSU07O1FBREQ7a0JBR0czQjtNYnRNZDs7O2Nhd01ZMkIsOEJBQUpOLFdBQUZ5QjttQkFGUTlDLEVBRWtCLE9BQXhCcUI7c0JBQUlNOztRQUREO3NCQUdPM0I7TWIxTWxCOzs7Y2E0TVkyQiw4QkFBSk4sV0FBRnlCO21CQUZZOUMsRUFFYyxVQUF4QnFCO3NCQUFJTTs7UUFERDt1QkFHUTNCO01iOU1uQjs7O1VhZ05vQjtXQUFMMkI7O1dBQVRtQjtXQUFjLHdCQUFkQSxFQUZhOUM7VUFFQyxRQURUO1VBQ1MsWUFBTDJCOztRQURKO3NCQUdPM0I7TWJsTmxCOzs7Y2FvTmUyQiw4QkFBVG1CLHNCQUZZOUM7a0JBQ1A7c0JBQ0kyQjs7UUFESjswQkFHVzNCO01idE50QjtZYXdOdUIyQixXQUFsQmlPLGNBQUM5TSxFQUFEOE07UUFDSywwQkFESjlNLEVBRmdCOUMsR0FFQzJCLEtBQWxCaU8sS0FDeUMsYUFIeEI1UCxFQUVDMkI7TUFEWjt5QkFJVTNCO01iM05yQjtZYTZOdUIyQixXQUFsQmlPLGNBQUM5TSxFQUFEOE07ZUFBQzlNLE1BRmU5QyxFQUVFMkIsS0FBbEJpTyxLQUFxRCxZQUZyQzVQLEVBRUUyQjtNQURaO2tCQUdHZ087TWIvTmQ7OztjYWlPVWhPLGFBQUwzQjtVQUFhLGNBRkoyUCxFQUVUM1AsR0FBc0IsT0FBdEJBO3NCQUFLMkI7O1FBREM7c0JBR09nTztNYm5PbEI7OztjYXFPVWhPLGFBQUwzQjtVQUFhLGNBRkEyUCxFQUViM1AsR0FBc0IsVUFBdEJBO3NCQUFLMkI7O1FBREM7c0JBR09qQztNYnZPbEI7OztVYTBPa0IsSUFEUmlDLGFBQUwzQixhQUNhLGtCQUhBTixFQUViTTtVQUNhLEdBQ1I2UCxPQUFvQixPQUFwQkE7VUFEUSxZQURSbE87O1FBREM7c0JBT0dnTztNQUNYOzs7OztnQkFFT2hPLFdBQUwzQjtZQUFhLGNBSEoyUCxFQUdUM1A7Y0FBc0IsY0FBdEJBLDhCQUFLMkI7OztVQURDLG9CQUVEO3FCQUlHZ08sRUFBRUo7Ozs7VUFHYztXQUFyQjVOO1dBQUgzQjtXQUF3QixpQkFIaEIyUCxJQUdSM1A7Ozs7bUJBQUcyQjs7UUFERyxnQkFHRTswQkFFR2pDO01BQ2I7Ozs7O1lBR1ksSUFESGlDLFdBQUwzQixXQUNRLGlCQUpDTixFQUdUTTtZQUNRO2NBRU0seUJBQUx3RCw4QkFISjdCOztZQUNHLFVBREhBOztVQURDLG9CQU1KO3dCQUdNakMsRUFERzZQOzs7O1VBSUQ7V0FETDVOO1dBQUwzQjtXQUNVLGNBSEZOLEVBRVJNO1dBRU8saUJBREY4UDs7bUJBREFuTzs7UUFEQyxnQkFJRzsyQkFFR2pDLEVBQUVpRixLQUFLNEs7aUJBQUw1SyxzQkFBSzRLOzs7VUFJSDtXQURYNU47V0FBTDNCO1dBQ2dCLGlCQUpKTixTQUdaTTtXQUNnQjs7dUJBQUorUDtrQkFBTlA7O21CQUREN047O1FBRE8sOEJBSUg7dUJBRURnTyxFQUFFSjs7OztjQUdQNU4sYUFBTDNCO1VBQWEsY0FISDJQLEVBR1YzUDtZQUFzQixhQUF0QkEseUJBQUsyQjtVQUEyQyxZQUFoRDNCLHNCQUFLMkI7O1FBRFc7UUFBVCx5QkFFRzs7TUFFRTtRQUdLO1NBRFZBOztTQUFKMUI7U0FBRkQ7U0FDZ0IsY0FEVjJCO1NBQ1U7O3FCQURoQjNCLEVBQ01pUSxPQURKaFEsRUFDUStQO01BRkwsVUFFb0M7cUJBRTlCaFAsR0FBR0M7TUFDakIsR0FEY0Q7V0FBR0M7Y0FHRmdPLEtBSEVoTyxNQUdOd08sR0FITXhPLE1BR1YrTixLQUhPaE8sTUFHWDBPLEdBSFcxTztVQUdvQixhQUEvQjBPLEdBQVFELElBQXVCLFFBQTNCVCxLQUFRQzs7T0FERCxLQUZHaE8sR0FFSDtNQUVGLG9DQUEwQjttQkFJMUIwSixJQUdWM0osR0FESWdMO01BRE4sR0FFRWhMO1dBRElnTDtjQUVZa0UsR0FGWmxFLFNBRU1tRSxHQUZObkUsU0FFRW9FLEdBRE5wUCxNQUNBcVAsR0FEQXJQO1VBRUssc0JBTEsySixJQUlWMEYsR0FBVUY7eUJBR0csTUFQSHhGLElBR1YzSixHQUNnQmtQO3NCQUFoQkcsR0FFYSxNQU5IMUYsSUFJSnlGLEdBRkZwRTtRQUNNLE9BQVZoTDtNQURVLE9BQU5nTCxLQUt3Qjt1QkFHaEJyQixJQUFJaEo7TUFDbEIsU0F3Q0kyTyxTQUFTblAsRUFBRVE7UUFDYixTQURXUjthQUFFUTs7O2NBR0U7ZUFERUs7ZUFBTnVPO2VBQU5DLEdBRlE3TztlQUdFLGlCQTVDSGdKLElBMkNQNkYsR0FBTUQsT0FBTkMsTUFBTUQsZ0JBQU5DO2NBQzJDLFVBQXhDM1EsRUFEU21DOztrQkFGTmIsS0FBRVE7Ozs7O2VBT0o7Z0JBRmM4TztnQkFBTkM7Z0JBQU5DO2dCQUFOQyxLQUxRalA7Z0JBT0o7Z0NBaERHZ0osSUE4Q1BpRyxLQUFNRDt1QkFHQSxXQWpEQ2hHLElBOENEZ0csS0FBTUQ7d0JBQVpFLFFBQU1ELFFBQU1EO3lCQUlELFdBbERKL0YsSUE4Q1BpRyxLQUFZRjswQkFBWkUsUUFBWUYsTUFBTkM7MEJBQU1ELE1BQVpFLFFBQU1EO3VCQU1HLFdBcERGaEcsSUE4Q1BpRyxLQUFZRjt3QkFBTkMsUUFBTkMsUUFBWUY7eUJBT0gsV0FyREYvRixJQThDRGdHLEtBQU1EOzBCQUFOQyxRQUFNRCxNQUFaRTswQkFBWUYsTUFBTkMsUUFBTkM7ZUFRTSxVQVBIakUsSUFEZThEO1FBWW5CO1lBakJPdFA7U0FpQlAsR0FqQk9BLElBaUJIMFA7U0FFUyxXQUZUQSxHQWpCS2xQO1NBbUJJOztTQUNBLGFBRlRtUCxHQUNJN0I7U0FDSzs7U0E1RERqTyxHQTJEUkY7U0EzRFdHLEdBNERYRjtTQTVEYzREO1FBQ3RCO2FBRGdCM0Q7ZUFBR0M7a0JBSUxpUCxHQUpLalAsTUFJVGtQLEdBSlNsUCxNQUlibVAsR0FKVXBQLE1BSWRxUCxHQUpjclA7Y0FLVCxrQkFOSzJKLElBS1YwRixHQUFRRjtnQkFHRCxjQUhDQSxHQUpZeEwsTUFBSDFELEdBSUxpUCxHQUpRdkw7Y0FNYixjQUZQMEwsR0FKb0IxTCxNQUFOM0QsR0FJVm9QLEdBSmdCekw7O3FCQUdWLFdBSEkzRCxHQUFNMkQ7O29CQUVWLFdBRk8xRCxHQUFHMEQ7eUJBNERWcU0sTUFDZ0I7TUE3RDlCLFNBa0JRRCxLQUFLNVAsRUFBRVE7UUFDYixTQURXUjthQUFFUTs7O2NBR0U7ZUFERUs7ZUFBTnVPO2VBQU5DLEdBRlE3TztlQUdFLGlCQXRCSGdKLElBcUJQNkYsR0FBTUQsYUFBTkMsZ0JBQU1EO2NBQ3NDLFVBQXpDMVEsRUFEU21DOztrQkFGTmIsS0FBRVE7Ozs7O2VBT0o7Z0JBRmM4TztnQkFBTkM7Z0JBQU5DO2dCQUFOQyxLQUxRalA7Z0JBT0o7Z0NBMUJHZ0osSUF3QlBpRyxLQUFNRDt1QkFNRyxXQTlCRmhHLElBd0JQaUcsS0FBWUY7eUJBT0gsV0EvQkYvRixJQXdCRGdHLEtBQU1EO2dDQUFOQyxRQUFOQzswQkFBTUQsUUFBTUQsTUFBWkU7d0JBQU1ELFFBQU5DLFFBQVlGO3VCQUdOLFdBM0JDL0YsSUF3QkRnRyxLQUFNRDt5QkFJRCxXQTVCSi9GLElBd0JQaUcsS0FBWUY7Z0NBQVpFLFFBQU1EOzBCQUFOQyxRQUFZRixNQUFOQzt3QkFBTkMsUUFBTUQsUUFBTUQ7ZUFRTixVQVBIL0QsSUFEZThEO1FBWW5CO1lBakJPdFA7U0FpQlAsR0FqQk9BLElBaUJIMFA7U0FFUyxlQUZUQSxHQWpCS2xQO1NBbUJJOztTQUNBLGlCQUZUbVAsR0FDSTdCO1NBQ0s7O1NBN0JHak8sR0E0QlpGO1NBNUJlRyxHQTZCZkY7U0E3QmtCNEQ7UUFDMUI7YUFEb0IzRDtlQUFHQztrQkFJVGlQLEdBSlNqUCxNQUlia1AsR0FKYWxQLE1BSWpCbVAsR0FKY3BQLE1BSWxCcVAsR0FKa0JyUDtjQUtiLGtCQWZLMkosSUFjVjBGLEdBQVFGO2dCQUVELGNBRlBFLEdBSndCMUwsTUFBTjNELEdBSWRvUCxHQUpvQnpMO2NBT2pCLGNBSEN3TCxHQUpnQnhMLE1BQUgxRCxHQUlUaVAsR0FKWXZMOztxQkFHZCxXQUhRM0QsR0FBTTJEOztvQkFFZCxXQUZXMUQsR0FBRzBEO3lCQTZCZHFNLE1BQ29CO01Bd0J4QixJQUFONU4sSUFBTSxPQWhFUXpCO01BZ0VSLFlBQU55QixJQUN1QixLQUR2QkEsSUFoRWN6QixPQWlFcUI7dUJBeUMzQmdKLElBQUloSjtNQUNoQixTQThESTJPLFNBQVNuUCxFQUFFUTtRQUNiLFNBRFdSO2FBQUVROzs7Y0FJQztlQUZHSztlQUFOdU87ZUFBTkMsR0FGUTdPO2VBSUMsZUFuRUpnSixJQWlFTDZGLEdBQU1EO2VBRUcsUUFBSlUsT0FGTFQsVUFFS1MsT0FGTFQsTUFBTUQsZ0JBQU5DO2NBR3FELFVBRmxEM1EsRUFEU21DOztrQkFGTmIsS0FBRVE7Ozs7O2VBVUM7Z0JBRlM4TztnQkFBTkM7Z0JBQU5DO2dCQUFOQyxLQVJRalA7Z0JBVUMsZUF6RUpnSixJQXVFTGlHLEtBQU1EO2VBRUcsU0FBSk87Z0JBRU07Z0NBM0VOdkcsSUF1RUNnRyxLQUFNRDtpQkFJRDt3QkFBSlM7dUJBSkRSO3dCQUlDUSxPQUpEUixRQUFNRCxnQkFBTkM7aUJBQ0hoRTs7Z0JBS0csT0FKRHVFO2tCQUtNLElBQUpFLElBQUksV0E5RU56RyxJQXVFQ2dHLEtBQU1EO2tCQU9ELFNBQUpVOytCQVBQUixRQUFNRDs7bUJBU0UsT0FGRFM7Z0NBUFBSLFFBQU1ELFFBQU1EOztvQkFXQztvQ0FsRlIvRixJQXVFTGlHLEtBQVlGO3FCQVdDOzRCQUFKVzsyQkFYVFQsUUFBTUQ7NEJBV0dVOzZCQVhUVCxRQUFZRixNQUFOQzs2QkFBTUQsTUFBWkUsUUFBTUQ7O2tCQU9LLElBTlJoRTs7a0JBZVEsSUFBSjJFLElBQUksV0F2Rk4zRyxJQXVFTGlHLEtBQVlGO2tCQWdCRCxTQUFKWTsrQkFoQkRYLFFBQU5DOzttQkFrQlEsT0FGRFU7Z0NBaEJEWCxRQUFOQyxRQUFZRjs7b0JBb0JDO29DQTNGUi9GLElBdUVDZ0csS0FBTUQ7cUJBb0JDOzRCQUFKYTsyQkFwQkhaLFFBQU5DOzRCQW9CU1c7NkJBcEJIWixRQUFNRCxNQUFaRTs2QkFBWUYsTUFBTkMsUUFBTkM7O2tCQWdCVyxJQWZSakU7ZUF3QkosVUF4QklBLElBRGU4RDtRQTJCbkI7WUFuQ090UDtTQW1DUCxHQW5DT0EsSUFtQ0gwUDtTQUVTLFdBRlRBLEdBbkNLbFA7U0FxQ0k7O1NBQ0EsYUFGVG1QLEdBQ0k3QjtTQUNLOztTQXBHRGpPLEdBbUdSRjtTQW5HV0csR0FvR1hGO1NBcEdjNEQ7UUFDdEI7YUFEZ0IzRDtlQUFHQztjQUtQLElBREVpUCxHQUpLalAsTUFJVGtQLEdBSlNsUCxNQUlibVAsR0FKVXBQLE1BSWRxUCxHQUpjclAsTUFLSixhQU5GMkosSUFLUjBGLEdBQVFGO2NBQ0UsU0FBSjFOO2dCQUNVLGNBRmhCNE4sR0FKb0IxTCxNQUFOM0QsR0FJVm9QLEdBSmFuUCxHQUlMaVAsR0FKUXZMO2NBT2IsUUFGRGxDLEdBSUMsY0FMQzBOLEdBSll4TCxNQUFIMUQsR0FJTGlQLEdBSlF2TDtjQUtWLElBR0gsVUFKUDBMLEdBSm9CMUwsTUFBTjNELEdBSVZvUCxHQUpnQnpMOztxQkFHVixXQUhJM0QsR0FBTTJEOztvQkFFVixXQUZPMUQsR0FBRzBEO3lCQW9HVnFNLE1BQ2dCO01Bckc5QixTQXNCUUQsS0FBSzVQLEVBQUVRO1FBQ2IsU0FEV1I7YUFBRVE7OztjQUlDO2VBRkdLO2VBQU51TztlQUFOQyxHQUZRN087ZUFJQyxlQTNCSmdKLElBeUJMNkYsR0FBTUQ7ZUFFRyxRQUFKVSxPQUZMVCxXQUVLUyxPQUZDVixNQUFOQyxnQkFBTUQ7Y0FHK0MsVUFGbEQxUSxFQURTbUM7O2tCQUZOYixLQUFFUTs7Ozs7ZUFVQztnQkFGUzhPO2dCQUFOQztnQkFBTkM7Z0JBQU5DLEtBUlFqUDtnQkFVQyxlQWpDSmdKLElBK0JMaUcsS0FBTUQ7ZUFFRyxTQUFKTztnQkFFTTtnQ0FuQ052RyxJQStCQ2dHLEtBQU1EO2lCQUlEO3dCQUFKUzt1QkFKRFI7eUJBSUNRLE9BSktULE1BQU5DLG9CQUFNRDtpQkFDVC9EOztnQkFLRyxRQUpEdUU7a0JBY00sSUFBSkUsSUFBSSxXQS9DTnpHLElBK0JMaUcsS0FBWUY7a0JBZ0JELFNBQUpVOytCQWhCRFQsUUFBTkM7O21CQWtCUSxRQUZEUTtvQkFJTTtvQ0FuRFJ6RyxJQStCQ2dHLEtBQU1EO3FCQW9CQzs0QkFBSlc7MkJBcEJIVixRQUFOQzs2QkFvQlNTOzZCQXBCR1gsTUFBTkMsUUFBTkM7NkJBQU1ELFFBQU1ELE1BQVpFOzs7Z0NBQU1ELFFBQU5DLFFBQVlGO2tCQWdCRCxJQWZSL0Q7O2tCQU1RLElBQUoyRSxJQUFJLFdBdENOM0csSUErQkNnRyxLQUFNRDtrQkFPRCxTQUFKWTsrQkFQUFYsUUFBTUQ7O21CQVNFLFFBRkRXO29CQUlNO29DQTFDUjNHLElBK0JMaUcsS0FBWUY7cUJBV0M7NEJBQUphOzJCQVhUWCxRQUFNRDs2QkFXR1k7NkJBWEdiLE1BQVpFLFFBQU1EOzZCQUFOQyxRQUFZRixNQUFOQzs7O2dDQUFOQyxRQUFNRCxRQUFNRDtrQkFPRCxJQU5SL0Q7ZUF3QkosVUF4QklBLElBRGU4RDtRQTJCbkI7WUFuQ090UDtTQW1DUCxHQW5DT0EsSUFtQ0gwUDtTQUVTLGVBRlRBLEdBbkNLbFA7U0FxQ0k7O1NBQ0EsaUJBRlRtUCxHQUNJN0I7U0FDSzs7U0FqREdqTyxHQWdEWkY7U0FoRGVHLEdBaURmRjtTQWpEa0I0RDtRQUMxQjthQURvQjNEO2VBQUdDO2NBS1gsSUFERWlQLEdBSlNqUCxNQUlia1AsR0FKYWxQLE1BSWpCbVAsR0FKY3BQLE1BSWxCcVAsR0FKa0JyUCxNQUtSLGFBakJGMkosSUFnQlIwRixHQUFRRjtjQUNFLFNBQUoxTjtnQkFDVSxjQUZoQjROLEdBSndCMUwsTUFBTjNELEdBSWRvUCxHQUppQm5QLEdBSVRpUCxHQUpZdkw7Y0FPakIsT0FGRGxDLEdBR0MsY0FKUDROLEdBSndCMUwsTUFBTjNELEdBSWRvUCxHQUpvQnpMO2NBS2QsSUFJSCxVQUxDd0wsR0FKZ0J4TCxNQUFIMUQsR0FJVGlQLEdBSll2TDs7cUJBR2QsV0FIUTNELEdBQU0yRDs7b0JBRWQsV0FGVzFELEdBQUcwRDt5QkFpRGRxTSxNQUNvQjtNQTBDeEIsSUFBTjVOLElBQU0sT0F4R016QjtNQXdHTixZQUFOeUIsSUFDdUIsS0FEdkJBLElBeEdZekIsT0F5R3VCOzZCQUdqQlgsR0FBR0M7VUFBSCtOLFFBQUdDO01BQ3pCO1dBRHNCRDthQUFHQyx1QkFBSEMsdUJBQUdEO1VBSWQ7UUFEQSxPQUhjQSxVQUtrQjtpQ0FHakJ0TixFQUFFUjtVQUFGdU4sTUFBRUM7TUFDNUI7V0FEMEJEO1VBTXhCLElBREtFLElBTG1CRjtVQU14QixPQU4wQkMsS0FPeEIsUUFQd0JBLFlBQUZELElBS25CRSxJQUxxQkQ7VUFNWDtRQUhmLGFBSDBCQSxtQkFPRztzQkFLdEJoTjtNQUNULFNBQVE4UCxJQUFJOVA7UUFBTyxHQUFQQTtjQUVIa0gsS0FGR2xILEtBRVIzQixFQUZRMkI7VUFFa0IsVUFBMUIzQixpQmJsaUJQLE9hZ2lCV3lSLElBRUM1STtRQURDLFFBQzZCO01BRnZDLHNCYmhpQkgsT2FnaUJXNEksSUFEQzlQLFFBS0o7b0JBRUk0RztNQUNULFNBQVFtSixPQUFPQyxNQUFNcEo7UUFDbkIsU0FEYW9KO1VBR1g7d0NBQW1CMUksSUFBSWpKLEdBQUssVUFBTEEsRUFBSmlKLElBQWUsT0FIakJWO1FBS1IscUJBTFFBO1FBS1I7Y0FFTUwsY0FBSGxJO1VBQWlCLFVBQWpCQSxFQUFpQixPQVBsQjJSLGNBT0l6SjtRQURGLFFBQ3FDO01BUHRELGtCQURTSyxJQVVLOzs7O09BdmhCWitGOzs7T0FFQUU7T0FFQXZNO09BSUFEO09BSUF5TTtPQVFBSztPQWVBTTs7T0FQQXJOO09BRUlnTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQk1kQzVOLEVBQUVzQjtNQUNELElBQUo1QyxFQUFJLGtCQUREc0IsR0FFUCxnQkFESXRCLElBREdzQixFQUFFc0IsR0FFVCxPQURJNUMsQ0FFSDtvQkFFTXNCLEVBQUV6QjtNQUNELHdCQUREeUIsR0FDQyxLQUREQSxVQUNDOztZQUNSM0Y7UUFDRTtVQUFlLHNCQUZicUUsRUFDSnJFLEVBQ2lCLFdBSFJrRSxFQUVUbEU7VUFDaUIsU0FEakJBOzs7TUFHQSxPQUpJcUUsQ0FJSDtJQUVTO2tCQUVIQTtNQUNQLDZCQURPQSxHQUVQLG9CQURJdUQ7TUFFSixnQkFIT3ZELElBRUhzRSxJQURBZjtNQUVKLE9BREllLENBRUg7SUFOUyxxQkFRRTlDLEdBQXFCLGlDQUFyQkEsR0FBNkI7SUFSL0IsbUJBU0V4QixHQUFJLGlDQUFKQSxHQUE2QjtJQVQvQixhQVdKQSxFQUFFc0QsSUFBSUM7TW5CaEVmO2FtQmdFV0QsWUFBSUMsZ0NBQU52RCxLQUFNdUQsV0FBSkQ7UUFJRSxJQUFKZ0IsRUFBSSxrQkFKRWYsS0FLVixnQkFMSXZELEVBQUVzRCxJQUlGZ0IsSUFKTWYsS0FLVixPQURJZTtNQUZELDRDQUtGO0lBbEJPLG9CQW9CRzlDLEVBQUU4QixJQUFJQztNQUF1QixnQ0FBN0IvQixFQUFFOEIsSUFBSUMsS0FBc0M7SUFwQi9DLFNBdUJSd08sU0FBSzlPLEVBQUV6QjtNQUNULE1BRE95QixJQUFFekIsTUFDVCxLQURTQSxVQUNULE1BQUlvQjtNQUFKLEdBRE9LOzs7T0FLQTtNWCtiRCxnQldoY21CLDhCQUhyQkwsQ0FJSTtJQTVCRSxnQkE4QkQ1QyxFQUFFZ1MsS0FBS0M7TUFDTjs2QkFBVixxQkFEU2pTLEdBQUVnUyxNQUFLQztPQUVoQixvQkFESTFPO01BQ0osUUFGV3lPO1dBR0VFLE9BSEZGLEtBR05HOztXQUFRRCxTQUFSQyxTQUhNSDtNQUNELElBR05JLE9BQVMsSUFBYixxQkFKU3BTLEtBR0ptUyxXQUZENU8sTUFFUzJPO01BQ0EsT0FBVEUsT0FDZSxnQkFMVnBTLEVBR0ptUyxPQUREN04sRUFDUzROLE9BQ1RFO01BQ21ELE9BSG5EOU4sQ0FJSDtJQXBDUyxjQXNDSHRFLEVBQUVzRCxJQUFJQyxJQUFJWDtNbkIzRnBCO2FtQjJGWVUsWUFBSUMsZ0NBQU52RCxLQUFNdUQsV0FBSkQ7T0FHSix1QkFIRXRELEVBQUVzRCxJQUFJQyxJQUFJWDtNQUVaLDhDQUN1QjtJQXpDbEIsY0EyQ0gzQixHQUFHb1IsS0FBS25SLEdBQUdvUixLQUFLL087TW5CaEcxQjs7O1FtQmdHMEJBOzs7O1FBQWI4Tzs7OytCQUFIcFIsTUFBZ0JzQyxXQUFiOE87Ozs7UUFBUUM7OzsrQkFBSHBSLE1BQVFxQyxXQUFMK087T0FJYix1QkFKRXJSLEdBQUdvUixLQUFLblIsR0FBR29SLEtBQUsvTztNQUdsQixrQ0FDK0I7SUEvQzFCLGdCQWlESXRDLEdBQUdvUixLQUFLblIsR0FBR29SLEtBQUsvTztNbkJ0R2pDOzs7UW1Cc0dpQ0E7Ozs7UUFBYjhPOzs7Z0NBQUhwUixNQUFnQnNDLFdBQWI4Tzs7OztRQUFRQzs7OytCQUFIcFIsTUFBUXFDLFdBQUwrTztPQUlwQix3QkFKU3JSLEdBQUdvUixLQUFLblIsR0FBR29SLEtBQUsvTztNQUd6QixrREFDc0M7SUFyRGpDLGdCQXdESDFELEVBQUVvRDtNQUNULDhCQURTQSxXQUNUOzs7UUFBNkI7cUJBRHRCcEQsRUFDc0Isc0JBRHBCb0QsRUFDVHRIO1VBQTZCLFNBQTdCQTs7O2NBQW1EO0lBekR6QyxpQkE0REZrRSxFQUFFb0Q7TUFDViw4QkFEVUEsV0FDVjs7O1FBQTZCO3FCQURyQnBELEVBQ1JsRSxFQUE2QixzQkFEbkJzSCxFQUNWdEg7VUFBNkIsU0FBN0JBOzs7Y0FBc0Q7SUE3RDVDLGdCQStFRDRXLElBRVB6UTtNbkJ0SUwsR21Cc0lLQTtRQUFLLGdDQUZFeVEsaUJBRVB6USxFQUFLOzs7OztjQWxCaUI7ZUFLaEJLO2VBTEtoQyxnQ0FPa0JxUztlQVBQLGFBQVhyUyxJQUFpQzs7cUJBS3RDZ0M7O3FCQURNOzs7VUFnQjRCLGtEQUZ4Q0w7Ozs7O29CQVBNcVA7Z0JBQ04sdUJBTGlCc0I7Z0JBTWpCO2tCQUdPRixNQVRVRSxVQUtqQiwrQkFMNkJEO2dCQU03QjtnRUFONkJBOzt5QkFJdkJyQjs7Y0FETix1QkFIaUJzQixRQUdqQjtxQkFIaUJBO1lBQ1gsT0FEV0E7TUFVWDtJQWhGRSxhQXNGSnhSLEdBQUdDO01BQ1Q7K0JBRE1EO09BQ04sd0JBRFNDO09BR0Qsb0JBRkpDLEtBQ0FDO01BRUosZ0JBSk1ILEtBR0ZxRCxJQUZBbkQ7TUFJSixnQkFMU0QsS0FHTG9ELEVBRkFuRCxHQUNBQztNQUdKLE9BRklrRCxDQUdIO0lBNUZTLFNBa0dSb087TUFBVzs7Ozs7TVh5WFAsbUJXdlhNO0lBcEdGLGNBc0dIMVM7TUFDUCw2QkFET0EsR0FDUDs7UUFFa0IsR0FEZHJFLE9BREE0SCxPQUVjLCtCQUhYdkQsRUFFSHJFO1VBRUY7UUFFRixJQUFJZ1gsS0FMQXBQOztVQU1jLEdBTGQ1SCxRQUlBZ1gsUUFDYywrQkFQWDNTLEVBTUgyUztZQUVGO1VBRUYsT0FSSWhYLFFBSUFnWCxLQUtGLElBWEszUyxFQUVIckUsTUFJQWdYLE9BSkFoWCw0QkFXRztJQW5IRyxtQkFxSEFxRTtNQUNWLHNDQURVQSxXQUNWOztZQUNBK0I7UUFDRTswQ0FIUS9CLEVBRVYrQjtVQUNFOzs7Ozs7Ozs7Ozs7VVhtV0k7VVdyV0ZUO1VBRUYsU0FERlM7OztNQU9BLEdBUklULFNBUUoscUJBVFV0QixHQVNZLFlBVFpBO01BQ1YsSUFTTThNLElBQUssa0JBVFB4TDtNQVNPO01BVFgsSUFTVywwQkFWRHRCLFdBVUM7O1lBRVRyRTtRQUNFO3NDQWJNcUUsRUFZUnJFO1VBQ0UsU0FXRWlIOzs7Ozs7Ozs7Ozs7OztnQkFERSxzQkFiRmtLLElBVEZ4TDtnQkFzQkk7c0NBYkZ3TCxJQVRGeEw7OztnQkFrQkksc0JBVEZ3TCxJQVRGeEw7Z0JBa0JJO3NDQVRGd0wsSUFURnhMOzs7Z0JBZ0JJLHNCQVBGd0wsSUFURnhMO2dCQWdCSTtzQ0FQRndMLElBVEZ4TDs7O2dCQW9CSSxzQkFYRndMLElBVEZ4TDtnQkFvQkk7c0NBWEZ3TCxJQVRGeEw7Ozs7O2FBeUJJLHNCQWhCRndMLElBVEZ4TDthQXlCSTttQ0FoQkZ3TCxJQVRGeEwsV0F1QkVzQjthQUVFO21DQWhCRmtLLElBVEZ4TCxZQXVCRXNCO2FBRUU7bUNBaEJGa0ssSUFURnhMLFdBdUJFc0I7OzthQVRFLHNCQUxGa0ssSUFURnhMO2FBY0k7bUNBTEZ3TCxJQVRGeEwsS0F1QkVzQjs7bUJBQXFCLHNCQWRyQmtLLElBVEZ4TCxLQXVCRXNCOztVQVdGO1VBdEJBLFNBREZqSDs7O01BeUJBLE9BM0JJbVIsR0E0Qkg7SUEzSk8sZUE2SkpqTixFQUFFRztNQUNSLElBQUk4QixFQUFKLHFCQURROUI7TUFDUixTQUFJOEIsRUFDVSxPQUZOOUI7TUFDUixJQUVVLG9CQUZOOEIsR0FFTSxLQUZOQSxVQUVNOztZQUNSbkc7UUFBc0I7VUFBZSxzQkFEakMySSxFQUNKM0ksRUFBcUMsV0FKakNrRSxFQUlrQixzQkFKaEJHLEVBSU5yRTtVQUFxQyxTQUFyQ0E7OztNQUNBLE9BRkkySSxDQUdIO0lBbktPLGdCQXFLSHpFLEVBQUVHO01BQ1QsSUFBSThCLEVBQUoscUJBRFM5QjtNQUNULFNBQUk4QixFQUNVLE9BRkw5QjtNQUNULElBRVUsb0JBRk44QixHQUVNLEtBRk5BLFVBRU07O1lBQ1JuRztRQUFzQjtVQUFlO1lBRGpDMkksRUFDSjNJLEVBQXFDLFdBSmhDa0UsRUFJTGxFLEVBQXNCLHNCQUpmcUUsRUFJUHJFO1VBQXFDLFNBQXJDQTs7O01BQ0EsT0FGSTJJLENBR0g7SUEzS08sMkJBNktRdEUsR0FBSSxhRC9KcEJrTixnQkMrSmdCbE4sRUFBOEI7SUE3S3RDLDJCQThLUUEsR0FBSSxhRHBLcEJpTixnQkNvS2dCak4sRUFBOEI7SUE5S3RDLFNBZ0xSNFMsT0FBTy9TLEVBQUVHO01BQ1gsOEJBRFdBLEdBQ1UsT0FEVkE7TUFFRCxJQUFKc0UsRUFBSSxLQUZDdEU7TUFHTSxzQkFEWHNFLElBQ1csV0FIUnpFLEVBRUMsc0JBRkNHO01BR00sT0FEWHNFLENBR0g7SUFyTE8sMEJBdUxTdEUsR0FBSSxjRHpLckJrTixnQkN5S2lCbE4sRUFBaUM7SUF2TDFDLDRCQXdMV0EsR0FBSSxjRDlLdkJpTixnQkM4S21Cak4sRUFBaUM7SUF4TDVDLFNBMkxKNlMsVUFBVTdTLEVBQUU4UyxJQUFJblgsRUFBRWlIO01uQmhQM0IsSW1CZ1B5QmI7TUFDdEI7V0FEa0IrUSxPQUFJL1EsSUFDTDtRQUNqQix5QkFGZ0IvQixFQUFNK0IsU0FBRWEsRUFFRyxPQUZMYjtRQUVZLFFBRlpBO2lCQUVxQztJQTdMakQsZUFnTUYvQixFQUFFNEMsR0FBSSxpQkFBTjVDLEVBQU0scUJBQU5BLEtBQUU0QyxFQUE4QjtJQWhNOUIsU0FtTUpvUSxjQUFjaFQsRUFBRThTLElBQUluWCxFQUFFaUg7TW5CeFAvQixJbUJ3UDZCYjtNQUMxQjtXQURzQitRLE9BQUkvUSxJQUNUO1FBQ2pCLHlCQUZvQi9CLEVBQU0rQixTQUFFYSxFQUVELFVBRkRiO1FBRWEsUUFGYkE7aUJBRTBDO0lBck0xRCxtQkF3TUUvQixFQUFFNEM7TUFBSSxxQkFBTjVDLEVBQU0scUJBQU5BLEtBQUU0QyxFQUFrQztJQXhNdEMsb0JBMk1HNUMsRUFBRXJFLEVBQUVpSDtNQUNqQixJQUFJZCxFQUFKLHFCQURhOUI7Y0FBRXJFLFFBQ1htRyxJQURXbkcsR0FHZixpQkFIYXFFLEVBQ1Q4QixFQURXbkcsRUFBRWlIO01BRU0sa0RBQ047SUE5TVAsd0JBaU5PNUMsRUFBRXJFLEVBQUVpSDtNQUNyQixJQUFJZCxFQUFKLHFCQURpQjlCO2NBQUVyRSxRQUNmbUcsSUFEZW5HLEdBS2pCLHFCQUxlcUUsRUFDYjhCLEVBRGVuRyxFQUFFaUg7TUFHbkIsa0RBRXFCO0lBdE5iLFNBeU5KcVEsV0FBV2pULEVBQUVyRSxFQUFFaUg7TW5COVF4QixJbUI4UXNCYjtNQUNuQjtnQkFEbUJBO1VBRW5CLHlCQUZpQi9CLEVBQUUrQixTQUFFYSxFQUVNLE9BRlJiO1VBRWUsUUFGZkE7O1FBQ0wsZ0JBQzBDO0lBM045QyxnQkE4TkQvQixFQUFFNEM7TUFBSSxrQkFBTjVDLEVBQU0scUJBQU5BLFdBQUU0QyxFQUFpQztJQTlObEMscUJBaU9JNUMsRUFBRXJFLEVBQUVpSDtNbkJ0UnJCLFNtQnNSbUJqSCw2QkFBRnFFLE1BQUVyRSxHQUlkLGtCQUpZcUUsRUFBRXJFLEVBQUVpSDtNQUVoQixrREFFZ0I7SUFyT1IsU0F3T0pzUSxlQUFlbFQsRUFBRXJFLEVBQUVpSDtNbkI3UjVCLEltQjZSMEJiO01BQ3ZCO2dCQUR1QkE7VUFFdkIseUJBRnFCL0IsRUFBRStCLFNBQUVhLEVBRUUsVUFGSmI7VUFFZ0IsUUFGaEJBOztRQUNULFNBQ21EO0lBMU92RCxvQkE2T0cvQixFQUFFNEM7TUFBSSxzQkFBTjVDLEVBQU0scUJBQU5BLFdBQUU0QyxFQUFxQztJQTdPMUMseUJBZ1BRNUMsRUFBRXJFLEVBQUVpSDtNbkJyU3pCLFNtQnFTdUJqSCw2QkFBRnFFLE1BQUVyRTtPQUlsQixzQkFKZ0JxRSxFQUFFckUsRUFBRWlIO01BRXBCLGtEQUVvQjtJQXBQWix1QkF3UE01QyxFQUFFckUsRUFBRWlIO01BQ3BCLElBQUlkLEVBQUoscUJBRGdCOUI7Y0FBRXJFLFFBQ2RtRyxJQURjbkc7T0FLaEI7U0FBVyxVQUxHcUUsRUFDWjhCLEVBRGNuRyxFQUFFaUgsR0FLUDs7OytCQUE0Qzs7TUFGdkQsa0RBRTREO0lBN1BwRCxrQkFpUUM1QyxFQUFFNEMsR0FBSSxxQkFBTjVDLElBQUU0QyxFQUF1QjtJQWpRMUIsd0JBb1FPNUMsRUFBRXJFLEVBQUVpSDtNbkJ6VHhCLFFtQnlUc0JqSCw2QkFBRnFFLE1BQUVyRTtPQUlqQjtTQUFXLFdBSklxRSxFQUFFckUsRUFBRWlILEdBSVI7OzsrQkFBMkM7O01BRnRELGtEQUUyRDtJQXhRbkQsbUJBNlFDekMsRUFBT0MsR0FBUSxrQ0FBZkQsRUFBT0MsRUFBMEI7SUE3UWxDLHFCQWtSRUosR0FBSSxhRC9RZGdOLFVDK1FVaE4sRUFBd0I7SUFsUjFCLHFCQW1SRUEsR0FBSSxhRHZSZCtNLFVDdVJVL00sRUFBd0I7SUFuUjFCLG9CQXFSR0EsR0FBSSxjRGxSZmdOLFVDa1JXaE4sRUFBMkI7SUFyUjlCLHNCQXNSS0EsR0FBSSxjRDFSakIrTSxVQzBSYS9NLEVBQTJCO0lBdFJoQyxrQkEwUkRBO01BQ1QsU0FBUTRSLElBQUlqVztRQUNWLEdBRFVBLE1BQ1YscUJBRk9xRSxHQUVjO1FBRVgscUJBSkhBLEVBQ0dyRSxHQUdBLEtBSEFBO1FBSUssVUFEVHdFLGlCbkJuVlgsT21CZ1ZXeVIsZ0JBSW1CO01BSjNCOzRCbkJoVkgsT21CZ1ZXQSxlQU1IO0lBalNLLGlCQW1TQTVSO01BQ1YsU0FBUTRSLElBQUlqVztRQUNWLEdBRFVBLE1BQ1YscUJBRlFxRSxHQUVhO1FBRVgscUJBSkZBLEVBQ0VyRSxHQUdBLEtBSEFBO1FBSVMsYUFKVEEsRUFHSndFLGtCbkI1VlgsT21CeVZXeVIsZ0JBSXVCO01BSi9COzRCbkJ6VkgsT21CeVZXQSxlQU1IO0lBMVNLLGtCQTRTRGpXO01BQ1QsWUFDYztNQVNkO2lCQUNPaUg7VUFDRixHQVpEdEIsU0FZQyxxQkFYRHVEO1lBR1k7YUFBVnNPO2NBQVUsUUFBZCxxQkFIRXRPO1lBR1ksd0JBSFpBLFlBR0VzTzthQUMwQjtZQURoQixJQUVWQyxRQUFVLEtBRlZEO1lBR0osS0FORXRPLFNBS0V1TyxVQU5GOVI7WUFPRixTQURJOFI7VUFPRCxlQVpEdk8sT0FEQXZELEtBV0dzQjtVQUVGO2tCQUNNO1FBZkZqSDtNQVdULFdBVElrSixTQURBdkQsS0FnQlM7SUE3VEgsa0JBNlVDRSxFQUFFN0YsR0FDWixzQkFEVTZGLEVBQUU3RixjQUNrRDtJQTlVckQsdUJBZ1ZNNkYsRUFBRTdGLEdBRWIsd0JBRlc2RixFQUFFN0YsRUFFSTtJQWxWWix1QkFvVk02RixFQUFFN0YsR0FDZ0IscUNBRGxCNkYsRUFBRTdGLEdBRUk7SUF0Vlosc0JBd1ZLNkYsRUFBRTdGLEdBQ2hCLHdCQURjNkYsRUFBRTdGLGNBQ29EO0lBelYzRCxzQkEyVks2RixFQUFFN0YsR0FDaEIsd0JBRGM2RixFQUFFN0YsY0FDb0Q7SUE1VjNELHNCQThWSzZGLEVBQUU3RixHQUNoQixxQkFEYzZGLEVBQUU3RixjQUNvRDtJQS9WM0Qsc0JBaVdLNkYsRUFBRTdGLEdBRVosd0JBRlU2RixFQUFFN0YsRUFFSTtJQW5XWCxzQkFxV0s2RixFQUFFN0YsR0FDbUMsd0JBQWxCLGlCQURuQjZGLEVBQUU3RixHQUVJO0lBdldYLHNCQXlXSzZGLEVBQUU3RixHQUVaLHdCQUZVNkYsRUFBRTdGLEVBRUk7SUEzV1gsc0JBNldLNkYsRUFBRTdGLEdBQ21DLHdCQUFsQixpQkFEbkI2RixFQUFFN0YsR0FFSTtJQS9XWCxzQkFpWEs2RixFQUFFN0YsRUFBRXdFLEdBRWQsd0JBRlVxQixFQUFFN0YsRUFBRXdFLEVBRUk7SUFuWGIsc0JBcVhLcUIsRUFBRTdGLEVBQUV3RSxHQUNRLHdCQURacUIsRUFBRTdGLEVBQ1UsYUFEUndFLEdBRUk7SUF2WGIsc0JBeVhLcUIsRUFBRTdGLEVBQUV3RSxHQUVkLHdCQUZVcUIsRUFBRTdGLEVBQUV3RSxFQUVJO0lBM1hiLHNCQTZYS3FCLEVBQUU3RixFQUFFd0U7TUFDUSx3QkFEWnFCLEVBQUU3RixFQUMyQixpQkFEekJ3RSxHQUVJO0lBL1hiLHNCQWlZS3FCLEVBQUU3RixFQUFFd0UsR0FFZCx3QkFGVXFCLEVBQUU3RixFQUFFd0UsRUFFSTtJQW5ZYixzQkFxWUtxQixFQUFFN0YsRUFBRXdFO01BQ1Esd0JBRFpxQixFQUFFN0YsRUFDMkIsaUJBRHpCd0UsR0FFSTtJQXZZYjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkNiSG1CLEVBQUVzQixHQUNULGlDQURPdEIsRUFBRXNCLEdBQ1E7b0JBQ1Z0QixFQUFFekIsR0FDVCxtQ0FET3lCLEVBQUV6QixHQUNRO29CQUNWRztNQUNQLGlDQUFPLHFCQURBQSxJQUNjO21CQUNmQSxFQUFFc0QsSUFBSUM7TUFDWixnQ0FBTSxxQkFEQXZELEdBQUVzRCxJQUFJQyxLQUNnQjtzQkFzQm5CZ1AsSUFFUHpRO01wQnZFTCxHb0J1RUtBO1FBQUssaUNBRkV5USxpQkFFUHpRLEVBQUs7Ozs7O2NBbEJpQjtlQUtoQks7ZUFMS2hDLGlDQU9rQnFTO2VBUFAsYUFBWHJTLElBQWlDOztxQkFLdENnQzs7cUJBRE07OztVQWdCOEIsa0RBRjFDTDs7Ozs7b0JBUE1xUDtnQkFDTix3QkFMaUJzQjtnQkFNakI7a0JBR09GLE1BVFVFLFVBS2pCLGdDQUw2QkQ7Z0JBTTdCO2lFQU42QkE7O3lCQUl2QnJCOztjQUROLHdCQUhpQnNCLFFBR2pCO3dDQUhpQkE7TUFVWDtvQkFPRDVTLEVBQUVHO01BQ1QsK0JBRFNBLFdBQ1Q7OztRQUE2QjtxQkFEdEJILEVBQ3NCLHVCQURwQkcsRUFDVHJFO1VBQTZCLFNBQTdCQTs7O2NBQW9EO3FCQUc1Q2tFLEVBQUVHO01BQ1YsK0JBRFVBLFdBQ1Y7OztRQUE2QjtxQkFEckJILEVBQ1JsRSxFQUE2Qix1QkFEbkJxRSxFQUNWckU7VUFBNkIsU0FBN0JBOzs7Y0FBc0Q7bUJBRWhEa0UsRUFBRUc7TUFDUixrQ0FETUgsRUFDRSxxQkFEQUcsSUFDYztvQkFDZkgsRUFBRUc7TUFDVCxtQ0FET0gsRUFDRSxxQkFEQUcsSUFDYzthQU1yQnFUO01BQVc7Ozs7O01abWJQLG1CWWpiTTtvQkFFTHJUO01BQ0oscUJBRElBLFNBQ1EsT0FEUkE7TUFFOEI7O1FBQTdCLFdBQUgsdUJBRkVBOzs7UUFFOEIsa0NBRjlCQTtPQUlGLE9BSkVBO01BR0ksaUNBQVEscUJBSFpBLElBSUQ7dUJBR21CQTtNQUF6Qiw0QkFBeUJBLEdBQUlyRTtNQUMzQjtXQUR5QjJGLEtBQUUzRixFQUNaLE9BRFFxRTtRQUVyQixpQ0FGcUJBLEVBQUlyRSxHQUV6Qjs7Ozs7UVpzYUU7U1lwYU0sc0NBQVcscUJBSkVxRTtRQUVyQixJQUdPLElBTGtCckU7aUJBT0U7YUFHekIyWCxZQUFVdFQsRUFBRThTLElBQUluWCxFQUFFaUg7TXBCbEgzQixJb0JrSHlCYjtNQUN0QjtXQURrQitRLE9BQUkvUSxJQUNMO1FBQ2pCLDBCQUZnQi9CLEVBQU0rQixTQUFFYSxFQUVHLE9BRkxiO1FBRVksUUFGWkE7aUJBRXFDO3FCQUduRC9CLEVBQUU0QyxHQUFJLG1CQUFONUMsRUFBTSxzQkFBTkEsS0FBRTRDLEVBQThCO2FBR2xDMlEsZ0JBQWN2VCxFQUFFOFMsSUFBSW5YLEVBQUVpSDtNcEIxSC9CLElvQjBINkJiO01BQzFCO1dBRHNCK1EsT0FBSS9RLElBQ1Q7UUFDakIsMEJBRm9CL0IsRUFBTStCLFNBQUVhLEVBRUQsVUFGRGI7UUFFYSxRQUZiQTtpQkFFMEM7eUJBR3hEL0IsRUFBRTRDO01BQUksdUJBQU41QyxFQUFNLHNCQUFOQSxLQUFFNEMsRUFBa0M7MEJBR25DNUMsRUFBRXJFLEVBQUVpSDtNQUNqQixJQUFJZCxFQUFKLHNCQURhOUI7Y0FBRXJFLFFBQ1htRyxJQURXbkcsR0FHYixtQkFIV3FFLEVBQ1Q4QixFQURXbkcsRUFBRWlIO01BRU0sb0RBQ0o7OEJBR0Y1QyxFQUFFckUsRUFBRWlIO01BQ3JCLElBQUlkLEVBQUosc0JBRGlCOUI7Y0FBRXJFLFFBQ2ZtRyxJQURlbkcsR0FLakIsdUJBTGVxRSxFQUNiOEIsRUFEZW5HLEVBQUVpSDtNQUduQixvREFFcUI7YUFHakI0USxhQUFXeFQsRUFBRXJFLEVBQUVpSDtNcEJoSnhCLElvQmdKc0JiO01BQ25CO2dCQURtQkE7VUFFbkIsMEJBRmlCL0IsRUFBRStCLFNBQUVhLEVBRU0sT0FGUmI7VUFFZSxRQUZmQTs7UUFDTCxnQkFDMEM7c0JBRy9DL0IsRUFBRTRDO01BQUksb0JBQU41QyxFQUFNLHNCQUFOQSxXQUFFNEMsRUFBaUM7MkJBRzlCNUMsRUFBRXJFLEVBQUVpSDtNcEJ4SnJCLFNvQndKbUJqSCw4QkFBRnFFLE1BQUVyRTtPQUlkLG9CQUpZcUUsRUFBRXJFLEVBQUVpSDtNQUVoQixvREFFZ0I7YUFHWjZRLGlCQUFlelQsRUFBRXJFLEVBQUVpSDtNcEIvSjVCLElvQitKMEJiO01BQ3ZCO2dCQUR1QkE7VUFFdkIsMEJBRnFCL0IsRUFBRStCLFNBQUVhLEVBRUUsVUFGSmI7VUFFZ0IsUUFGaEJBOztRQUNULFNBQ21EOzBCQUdwRC9CLEVBQUU0QztNQUFJLHdCQUFONUMsRUFBTSxzQkFBTkEsV0FBRTRDLEVBQXFDOytCQUdsQzVDLEVBQUVyRSxFQUFFaUg7TXBCdkt6QixTb0J1S3VCakgsOEJBQUZxRSxNQUFFckU7T0FJbEIsd0JBSmdCcUUsRUFBRXJFLEVBQUVpSDtNQUVwQixvREFFb0I7NkJBR041QyxFQUFFckUsRUFBRWlIO01BQ3BCLElBQUlkLEVBQUosc0JBRGdCOUI7Y0FBRXJFLFFBQ2RtRyxJQURjbkc7T0FLaEI7U0FBVyxZQUxHcUUsRUFDWjhCLEVBRGNuRyxFQUFFaUgsR0FLUDs7OytCQUE0Qzs7TUFGdkQsb0RBRTREO3dCQUduRDVDLEVBQUU0QyxHQUFJLHVCQUFONUMsSUFBRTRDLEVBQXVCOzhCQUduQjVDLEVBQUVyRSxFQUFFaUg7TXBCekx4QixRb0J5THNCakgsOEJBQUZxRSxNQUFFckU7T0FJakI7U0FBVyxhQUpJcUUsRUFBRXJFLEVBQUVpSCxHQUlSOzs7K0JBQTJDOztNQUZ0RCxvREFFMkQ7K0JBRTNDNUM7TUFDbEIsOENBQWtCLHFCQURBQSxJQUNjOytCQUNkQTtNQUNsQiw4Q0FBa0IscUJBREFBLElBQ2M7Z0NBQ2JBO01BQ25CLDZDQUFtQixxQkFEQUEsSUFDYztrQ0FDWkE7TUFDckIsK0NBQXFCLHFCQURBQSxJQUNjO3VCQUl4QkcsRUFBT0MsR0FBUSwyQkFBZkQsRUFBT0MsRUFBMEI7MkJBRzVCbVMsSUFBSXZTO01BQ3BCOztrQ0FEb0JBO09BQ3BCLDJCQURvQkE7TUFDcEI7WUFFQXJFO1FBQ0U7b0NBSmtCcUUsRUFHcEJyRSxPQUhnQjRXO1lBSWUsU0FIM0JqTztZQUlLLGdCQUxXdEUsRUFHcEJyRSxXQURJZ1gsT0FDSmhYO1lBRVMsT0FGVEE7Ozs7TUFGQSxTQUFJMkk7TUFRSixnQkFUb0J0RSxJQUVoQjJTLFdBT1k7eUJBSUozUztNQUNaLHdDQUFZLHFCQURBQSxJQUNjO3lCQUNkQTtNQUNaLHdDQUFZLHFCQURBQSxJQUNjOzBCQUNiQTtNQUNiLHVDQUFhLHFCQURBQSxJQUNjOzRCQUNaQTtNQUNmLHlDQUFlLHFCQURBQSxJQUNjO3NCQUlwQkEsR0FBSSxxQ0FBSkEsR0FBcUI7dUJBRXBCQSxHQUFJLG9DQUFKQSxHQUFzQjtzQkFFdkI0RyxHQUFJLHFDQUFKQSxHQUFxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7YUN2TjVCOE0sb0JBQWMsUUFBSTthQUNsQkMsc0JBQWdCLFFBQUM7YUFDakJDLG1CQUFlLFlBQUk7dUJBRm5CRixRQUNBQyxVQUNBQzs7YUNZQUMsVUFBVUMsS0FBS3hRLElBQUlDLElBQUlJLEVBQUVvUTtNdEJoQzlCOzs7UXNCZ0NvQnpROzs7O1FBQUlDOzs7K0JBQVR1USxRQUFTdlEsV0FBSkQ7T0FHWiwyQ0FIT3dRLEtBQUt4USxJQUFJQyxJQUFJSSxFQUFFb1E7TUFFdEIsa0RBQ3FDO1FBWXhDQzthQUNBQyxVQUFVSCxLQUFLeFE7TXRCaERwQixRc0JnRG9CQSxnQ0FBTHdRLGtCQUFLeFE7T0FHWiw4QkFIT3dRLEtBQUt4UTtNQUVaLHlDQUN5QjthQUM1QjRRLFdBQVdKLEtBQUt4USxLQUFvQixzQkFBekJ3USxLQUFLeFEsUUFBc0M7YUFFdEQ2USxXQUFXTCxLQUFLeFE7TXRCdERyQixRc0JzRHFCQSxnQ0FBTHdRLGtCQUFLeFE7UUFJTixJQUFOQyxJQUFNLHVCQUpDdVEsS0FBS3hRO1FBSU4sNkJBSkN3USxjQUlQdlEsZ0JBSllEO2lCQU1YO2lCQUNBLG9DQVBNd1EsS0FBS3hRO01BRWIsMENBTUY7YUFFRDhRLFlBQVlOLEtBQUt4UTtNQUdSLHVDQUhHd1EsTUFBS3hRLElBR3lCOzs7OztPQW5DMUN1UTs7T0FzQkFNO09BVUFDO09BakJBSjtPQUNBQztPQUlBQzs7YUM1QmlCRyxTQUFTcFIsR0FBSSxtQkFBSkEsbUJBQWtCO2FBVTNCcVIsYUFBYW5VLEVBQUV4RSxHQUFJLHNCQUFOd0UsRUFBRXhFLEVBQXlDO2FBQ3hENFksaUJBQWlCcFUsRUFBRXhFLEVBQUVnSSxHQUN4QyxzQkFEb0N4RCxFQUFFeEUsRUFBRWdJLEVBQ0Q7YUFPckM2USxRQUFTQyxLQUNYLDBDQURXQSxNQUNZO2FBQ3JCQyxVQUFVblcsSUFBSW9XO01BQ21CLFNBRG5CQSxNQUNtQixXQUR2QnBXLElBQUlvVztNQUNmLHFCQURXcFcsSUFBSW9XLFVBQzhDOztLQUU1REM7S0FDQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FFQUM7S0FFQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FJQUM7S0FDQUM7S0FDQUM7YUFLRUMsT0FDRXpWO012QjNFVDtTdUI2RVUsU0FGREEsTUFFaUIsYUFGakJBO1lBQ0EwVixLQURBMVY7TWZxY0Esa0JlcGNBMFYsS0FEQTFWOztNQU1vQixHQUFuQixTQUxEMFYsU0FLb0IsYUFMcEJBO1lBSUFsVCxLQUpBa1Q7d0JBSUFsVCxLQUVHO01BRUYsb0JBSkRBO2VBSkFrVDtlQVNHLDBDQUF1QzthQUUzQmxULEtBQU1rVCxNQUNwQixPQURvQkEsT0FDQzthQUVQQyxHQUFJRCxNQUNsQixPQURrQkEsT0FDRzs7OEJBakJ4QkQsT0FhaUJqVCxLQUdBbVQ7S0FJbkJDO0tBQ0FDO0tBQ0FDO0tBU0VDO2FBR0FDLE9BQU9yVTtNQUNULGNBRFNBLE1BQ1QsVUFEU0EsS0FIUG9VO01BS0E7TUFDRixnQ0FIU3BVLEVBR0Q7YUFFTnNVLFNBQU9qVyxHQUFJLE9BQUpBLG9CQUFvQzthQUUzQ2tXLHdCQUF3QmpMLEVBQUV2QixFQUFFeU07TUFDOUIsY0FENEJ6TSxNQUM1QixVQUQ0QkEsSUFDTixTQURJdUIsWUFFeEI7OEJBRjRCa0wsU0FFYjthQUdmQyxRQUFRbkwsRUFBRXZCO01BQ1osd0JBRFV1QixFQUFFdkI7TUFFWixpQ0FGVXVCLEVBQUV2QixFQUVEO2FBR1QyTSxhQUFhcEwsRUFBRXZCO01BQ2pCLHdCQURldUIsRUFBRXZCO01BRWpCLHNDQUZldUIsRUFBRXZCLEVBRUQ7YUFHZDRNLFFBQVFyTCxFQUFFdkIsRUFBRTFKO01BQ2Qsd0JBRFVpTCxFQUFFdkI7TUFFWix5QkFGVXVCLEVBQUV2QixFQUFFMUosRUFFRDthQUdYdVcsVUFBVXRMLEVBQUV2QjtNQUNkLHdCQURZdUIsRUFBRXZCO01BRWQsMkJBRll1QixFQUFFdkIsRUFFRDthQUdYOE0sVUFBVXZMLEVBQUV2QjtNQUNkLHdCQURZdUIsRUFBRXZCO01BRWQsbUNBRll1QixFQUFFdkIsRUFFRDthQUtYK00sU0FBU3hLLEdBQUcxQixHQUFHbU0sR0FBR0MsR0FBR2hWO01BRUY7OztRQUZFQTs7OztRQUFUNEk7OztVQUNhLFNBRGhCMEIsTUFBWXRLLFNBQVQ0STs7OztRQUFNb007OztVQUVDLFNBRkpELE1BQU0vVSxTQUFIZ1Y7UUFJZjtvQkFKa0JoVjtTQUlsQixVQUFlLDJCQUpUc0ssR0FBRzFCLEdBQUdtTSxHQUFHQyxHQUFHaFY7UUFJbUI7TUFEckMsOENBQ3FDOzs7Ozs7T0EzQ3hDcVU7T0FLQUM7T0FPQUc7T0FLQUM7T0FLQUM7T0FLQUM7T0FLQUM7T0FPQUM7Ozs7c0J2Qm5KUDs7O091QnlHT1Y7OztPQWpGZTdCO09BVUFDO09BQ0FDO09BYWpCSztPQUNBQztPQUVBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQztPQUVBQztPQUVBQztPQUNBQztPQUNBQztPQUNBQztPQUNBQzs7T0FJQUM7T0FDQUM7T0FDQUM7O09BeUJBSTtPQUNBQztPQUNBQztPQXJEQXpCO09BRUFFOzs7SUNUYTtvQkFZUjVTLEVBQUVqQztNQUNULFNBRE9pQyxFQUNPO01BQ2QsUUFGT0E7UUFNSSx1QkFOSkEsRUFNYSxXQU5YakMsTUFNRSxLQU5KaUMsVUFNSTs7Y0FDVm5HO1VBQ0U7b0JBREZBLEtBQ21CLFdBUlhrRSxFQU9SbEU7WUFDRSxTQURGQTs7O1FBR0EsT0FKSXNKO01BSlMsa0NBUVY7SUF0QlcsdUJBd0JEOFIsR0FBR0MsR0FBR0M7TUFDVix1QkFESUYsUUFDSixLQURJQSxXQUNKOztZQUNWNVc7UUFDRTtVQUFpQixRQURuQkEsS0FDbUIsZUFIRjZXLEdBQUdDO1VBR0QsU0FEbkI5Vzs7O01BR0EsT0FKSThFLEdBSUQ7SUE3QlksZ0JBaUNSaEM7TUFDUCxJQUFJbkIsRUFER21CLGFBQ1AsYUFBSW5CLE1BQXdDLGVBRHJDbUIsSUFDSG5CLEVBQXdEO0lBbEM3QyxrQkFvQ04rTixHQUFHRDtNQUNaLElBQUl6TyxHQURLME87TUFDVCxhQUFJMU87ZUFDVyxPQUZIeU87O2lCQUdlLGVBSGxCQyxLQUNMMU87aUJBR0MsMEJBSkkwTyxHQUFHRCxHQUlVO0lBeENQLGVBMENUM00sRUFBRUssSUFBSUM7TXhCOUVmLFF3QjhFV0QsWUFBSUMsV0FBTk4sZUFBTU0sV0FBSkQ7T0FHSCxzQkFIQ0wsRUFBRUssSUFBSUM7TUFFUCxpQ0FDb0I7SUE3Q1YsZ0JBK0NSTixFQUFFSyxJQUFJQyxJQUFJSTtNeEJuRnBCLFF3Qm1GWUwsWUFBSUMsV0FBTk4sZUFBTU0sV0FBSkQ7T0FHSiwrQkFIRUwsRUFBRUssSUFBSUMsSUFBSUk7TUFFWixrQ0FDdUI7SUFsRGIsZ0JBb0RSa00sR0FBR3dDLEtBQUt6QyxHQUFHMEMsS0FBSy9PO014QnhGMUI7OztRd0J3RjBCQTs7OztRQUFiOE87OztVQUFIeEMsZ0JBQWdCdE0sV0FBYjhPOzs7O1FBQVFDOzs7VUFBSDFDLGdCQUFRck0sV0FBTCtPO09BSWIsK0JBSkV6QyxHQUFHd0MsS0FBS3pDLEdBQUcwQyxLQUFLL087TUFHbEIsa0NBQytCO0lBeERyQixnQkEwRFIxRCxFQUFFb0Q7TUFDVCxTQURTQSxxQkFDVDs7O1FBQTZCO3FCQUR0QnBELEVBQUVvRCxNQUNUdEg7VUFBNkIsU0FBN0JBOzs7Y0FBbUQ7SUEzRHBDLGlCQTZEUGtFLEVBQUVvRCxFQUFFekI7TUFDWixHQURVeUIsaUJBQUV6QjtPQUVWO01BRUEsU0FKUXlCLHFCQUlSOzs7UUFBNkI7cUJBSnZCcEQsRUFBRW9ELE1BSVJ0SCxHQUpVNkYsTUFJVjdGO1VBQTZCLFNBQTdCQTs7O2NBQXFFO0lBakV4RCxlQW1FVGtFLEVBQUVvRDtNQUNSLElBQUluQixFQURJbUI7TUFDUixTQUFJbkIsRUFDVTtNQURkLElBRVUsaUJBRk5BLEVBRWUsV0FIYmpDLEVBQUVvRCxPQUdFLEtBRk5uQixVQUVNOztZQUNSbkc7UUFDRTtnQkFERkEsS0FDaUIsV0FMYmtFLEVBQUVvRCxNQUlOdEg7VUFDRSxTQURGQTs7O01BR0EsT0FKSTJJLENBS0g7SUEzRVksZ0JBNkVSekUsRUFBRW9ELEVBQUV6QjtNQUNYLE9BRFN5QixhQUNULEdBRFd6QjtNQUNYLEdBQUkwVixPQUNBQyxHQUVGO01BQ0csU0FKREQsR0FLYTtNQUxqQixJQU1ZLGlCQU5SQSxHQU1rQixXQVBmclgsRUFBRW9ELEtBQUV6QixPQU9DLEtBTlIwVixXQU1ROztZQUNSdmI7UUFDRTtnQkFERkEsS0FDaUIsV0FUZGtFLEVBQUVvRCxNQVFMdEgsR0FSTzZGLE1BUVA3RjtVQUNFLFNBREZBOzs7TUFHQSxPQUpJMkksQ0FNTDtJQTFGWSxpQkE0RlB6RSxFQUFFb0Q7TUFDVixTQURVQSxxQkFDVjs7O1FBQTZCO3FCQURyQnBELEVBQ1JsRSxFQURVc0gsTUFDVnRIO1VBQTZCLFNBQTdCQTs7O2NBQXNEO0lBN0Z2QyxnQkErRlJrRSxFQUFFb0Q7TUFDVCxJQUFJbkIsRUFES21CO01BQ1QsU0FBSW5CLEVBQ1U7TUFEZCxJQUVVLGlCQUZOQSxFQUVlLFdBSFpqQyxJQUFFb0QsT0FHQyxLQUZObkIsVUFFTTs7WUFDUm5HO1FBQ0U7Z0JBREZBLEtBQ2lCLFdBTFprRSxFQUlMbEUsRUFKT3NILE1BSVB0SDtVQUNFLFNBREZBOzs7TUFHQSxPQUpJMkksQ0FLSDtJQXZHWSxtQkF5R0xyQjtNQUNWLFFBRFVBLHFCQUNLdEgsTUFBRXNKO01BQ2Y7Z0JBRGF0SjtVQUMwQixhQUYvQnNILE1BQ0t0SCxHQUFFc0osS0FDd0IsSUFEMUJ0SixnQkFBRXNKO1FBQ0QsT0FEQ0EsSUFFTztJQTVHVCxTQStHVG9TOzs7O1VBRUk7Ozs7bUJBQUxDOztRQURHO0lBaEhPLGlCQXFIYnhWO01BRlUsR0FFVkE7UUFDa0M7U0FEOUJLLEdBQUpMOztTQUNrQyxpQkFBakIsY0FEakJBOztlQUFJSzs7O2dCQUlNZ1AsY0FBSm9HO1lBQVUsV0FBVkE7WUFBVSw4QkFBTnBHOztVQURFLE9BRk5sTztNQUZBLFVBTUs7SUExSEUscUJBNEhIcEQsRUFBRU0sRUFBRThDO01BQ2hCLFNBRGM5QyxHQUNkLEtBRGdCOEMscUJBQ2hCOztZQUNBdEg7UUFDRTtVQUFLLGtCQUhLa0UsRUFDUnlFLEtBRFlyQixNQUVoQnRIO1VBQ08sU0FEUEE7OztNQUdBLE9BSkkySSxJQUlGO0lBaklhLHNCQW1JRnpFLEVBQUVvRCxFQUFFOUM7TUFDakIsU0FEaUJBLEdBQ2pCLEtBRGU4QztNQUNmO1lBQ0F0SDtRQUNFO1VBQUssa0JBSE1rRSxFQUFFb0QsTUFFZnRILEdBREkySTtVQUVHLFNBRFAzSTs7O01BR0EsT0FKSTJJLElBSUY7SUF4SWEsa0JBMElOd0wsRUFBRTdNO01BQ1gsTUFEV0EsYUFFRXRIO01BQ1g7V0FEV0EsTUFEVDJGLEVBRVk7UUFDTixjQUpEd08sRUFBRTdNLE1BRUV0SCxJQUVxQjtRQUMzQixRQUhNQTtpQkFJUDtJQWhKUyxtQkFrSkxtVSxFQUFFN007TUFDWixNQURZQSxhQUVDdEg7TUFDWDtXQURXQSxNQURUMkYsRUFFWTtRQUNOLGNBSkF3TyxFQUFFN00sTUFFQ3RILEtBRXFCLFFBRnJCQTtRQUdOLFNBQ0Q7SUF4SlMsb0JBMEpKbVUsRUFBRTNPLEdBQUdDO01BQ2hCLE9BRGFELGNBQ2IsR0FEZ0JDO01BQ2hCLEdBQUk0UCxPQUNBQyxHQUNhO01BRmpCLElBR2tCdFY7TUFDaEI7V0FEZ0JBLE1BSGRxVixHQUlhO1FBQ1AsY0FOQ2xCLEVBQUUzTyxPQUlLeEYsR0FKRnlGLE9BSUV6RjtVQUVtQyxRQUZuQ0E7UUFHWCxTQUNEO0lBbEtTLG1CQW9LTG1VLEVBQUUzTyxHQUFHQztNQUNmLE9BRFlELGNBQ1osR0FEZUM7TUFDZixHQUFJNFAsT0FDQUMsR0FDYTtNQUZqQixJQUdrQnRWO01BQ2hCO1dBRGdCQSxNQUhkcVYsR0FJYTtRQUNQLGNBTkFsQixFQUFFM08sT0FJTXhGLEdBSkh5RixPQUlHekYsSUFFbUM7UUFDOUMsUUFIV0E7aUJBSVo7SUE1S1MsZUE4S1R3RSxFQUFFOEM7TUFDUixNQURRQSxhQUVLdEg7TUFDWDtXQURXQSxNQURUMkYsRUFFWTtRQUNrQixzQkFKMUIyQixNQUVLdEgsR0FGUHdFLEdBSXdDO1FBQ3ZDLFFBSE14RTtpQkFJUDtJQXBMUyxnQkFzTFJ3RSxFQUFFOEM7TUFDVCxNQURTQSxhQUVJdEg7TUFDWDtXQURXQSxNQURUMkYsRUFFWTtRQUNELEdBSlJuQixNQUFFOEMsTUFFSXRILEdBRXdCO1FBQzlCLFFBSE1BO2lCQUlQO0lBNUxTO2tCQStMUm1QLElBQUk3SDtNQUNYLFNBQUl1VSxPQUFPMVYsRUFBRW5HO1FBQ1gsVUFEV0EsNEJBQ1gsS0FBSThiO1FBQUosSUFBSUEsZUFESzNWO1VBR1MsU0FGZDJWLFlBR2lCLHNCQUxaeFU7VUFLSixjQUxBNkgsSUFLSSxpQkFMQTdILEVBRUx3VTtXQUcwQyxPQUgxQ0E7VUFFYztXQUVoQixLQUpFQTtXQUlnQixzQkFOWHhVO1dBTVcsS0FIaEI5QztVQUdDLGNBTkEySyxJQU1JLGlCQU5BN0g7V0FNb0MsT0FKekN3VTtVQUtGLE9BSkV0WDtRQU1GLElBUEVzWCxlQURLM1Y7VUFReUIsU0FQOUIyVixZQU84QixzQkFUekJ4VTtVQVNTLHNCQVRiNkgsSUFTaUIsaUJBVGI3SCxFQUVMd1U7V0FRRyxPQVJIQTtRQVNHLEdBVEhBLE1BREszVixFQVVjLE9BVG5CMlY7UUFTNEIsZ0JBVnJCOWIsRUFVcUM7TUFWbEQsU0FZUStiLFlBQVk1VixFQUFFbkcsRUFBRXlQO1F4QmhQM0IsSXdCZ1B5QnJKO1FBQ3BCO1VBQVEsSUFBSjRRLEVBQUksT0FEVTdRLEVBQUVDO1VBRWpCLGtCQWZFK0ksSUFlRSxpQkFmRTdILEVBY0wwUCxVQURrQnZIO1lBR1osMEJBaEJEbkksRUFjTDBQO1lBRUYsaUJBaEJPMVAsRUFhV2xCO1lBR1YsSUFIVUEsSUFDaEI0UTs7VUFJSyxpQkFsQkExUCxFQWFXbEIsZ0JBQUVxSjtVQUtiLFNBRUw7TUFuQk4sU0FxQkl1TSxRQUFRN1YsRUFBRW5HLEVBQUV5UDtRQUFJO1VBQUkscUJBQVp0SixFQUFFbkcsRUFBRXlQOzs7O1lBQTJDLElBQUxySixXQUFLLGlCQXRCaERrQixFQXNCMkNsQixnQkFBdENxSixFQUEyQztvQkFBUztNQXJCcEUsU0FzQlF3TSxXQUFXOVYsRUFBRW5HO1F4QjFQeEIsSXdCMFB3Qm9HO1FBQ25CO1VBQVEsZUFEU0QsRUFBRUMsS0FFWCxzQkF6QkNrQixFQXVCVThQO1VBRW5CLGlCQXpCUzlQLEVBdUJVbEI7VUFDWCxJQURXQTttQkFHTDtNQXpCaEIsU0EyQkk4VixPQUFPL1YsRUFBRW5HO1FBQUk7VUFBSSxvQkFBVm1HLEVBQUVuRzs7O2dDQUF3QyxJQUFMb0csV0FBSyxPQUFMQTtvQkFBTTtNQTNCdEQsTUFEV2tCLGFBQ1gsT0FzQ0luQjtNQXRDSjtZQXVDQWdXO1FBQW9DO2tCQURoQ2hXLEVBQ0pnVyxJQUFnRCxpQkF4Q3JDN1UsRUF3Q1g2VTtVQUFvQyxTQUFwQ0E7OztNQXZDQSxTQXNDSWhXO01BRUo7OztRQUNFO1VBQVE7Z0NBMUNDbUIsRUF5Q1hsQjtXQUVVLHNCQTNDQ2tCO1VBMkNULGlCQTNDU0EsRUF5Q1hsQjtVQUNVLElBRUUsV0FIWkEsT0Faa0JwRztVQUNoQjtnQkFBSXFjLFFBRFlyYztZQUNoQixHQURnQkEsTUFDWnFjO1lBRUQ7OEJBaENFbE4sSUFnQ0UsaUJBaENFN0gsRUE4QkwrVSxvQkFEY0Q7YUFNVCxpQkFuQ0E5VSxFQTZCT3RILFlBQUVvYzs7Y0FJUiwwQkFqQ0Q5VSxFQThCTCtVO2NBR0YsaUJBakNPL1UsRUE2Qk90SDtjQUlkLE9BSEVxYyxZQURZcmMsRUFDWnFjO2NBSXlDLGlCQWxDcEMvVSxVQTZCUzhVO1lBQ2xCLFNBV0ZoVzs7OztNQXhDQSxhQXNDSUQ7TUFPSjtRQUF1Qix1QkE5Q1ptQixRQThDaUMsc0JBOUNqQ0E7UUE4Q3lCLGlCQTlDekJBO1FBOEM0QyxpQkE5QzVDQSxVQThDUW1JO1FBQUk7OztNQXBEckIsV0FvRCtEO0lBN09sRCxxQkFpUEROLElBQUk3SDtNQUNsQixTQUFJZ1YsTUFBTUMsUUFBUUMsUUFBUUMsS0FBS0MsUUFBUUMsUUFBUTdGLElBQUk4RjtRQUNqRDtlQURRTCxVQUFRQztTQUNoQixNQUQ2QkUsVUFBUUM7U0FrQkcsc0JBbEJoQkYsS0FBS0M7U0FrQmIsc0JBbkJBcFYsRUFDUmlWO1NBRUtVLEdBRkxWO1NBRVFqWDtTQUFHNFgsR0FGVVI7U0FFUG5YO1NBQUc0WCxFQUZ3QlA7UUFHL0M7VUFBRyxrQkFKT3pOLElBR0k3SixHQUFNQztZQVNsQixpQkFYeUN1UixJQUVwQnFHLFlBQUg1WDtZQVNsQixJQUNJNlgsS0FWV0Y7WUFTZixHQUNJRSxPQVgwQk47Y0FhNUI7bUJBWm1CSztlQVlMLHNCQWRJVixLQVloQlc7ZUFWV0YsR0FVWEU7ZUFWYzdYO2VBQUc0WDs7WUFjbkIsY0FqQlU3VixFQUdIMlYsR0FGZ0NuRyxJQUVwQnFHLFVBRHJCTixRQUNTSTtVQUVULGlCQUp5Q25HLElBRXBCcUcsWUFBVDdYO1VBRVosSUFDSWlZLEtBSEtOO1VBRVQsR0FDSU0sT0FKSlY7WUFNRTtpQkFMbUJNO2FBS1gsc0JBUkU3VixFQU1SaVc7YUFIS04sR0FHTE07YUFIUWpZO2FBQVM2WDs7VUFPbkIsY0FUa0JWLEtBRUxTLEdBRjBCcEcsSUFFcEJxRyxVQURTTCxRQUNmSSxRQWdCK0M7TUFsQnBFLFNBb0JJUSxRQUFRQyxPQUFPN0csSUFBSThGLE9BQU9oVjtRQUM1QixTQUQ0QkEsWUFDNUI7Ozs7VUFDRTs7a0JBRlErVixTQUNWM2Q7YUFDVSxtQkF2Qk1zSDthQXVCTixNQUZXc1YsU0FDckI1Yzs7aUJBRHFCNGMsVUFHZjVGOztnQkFDbUIsa0JBekJiN0gsSUF5QmlCLGlCQUpaMkgsb0JBRVhySDtrQkFHRjt3QkFGRXVIO21CQUVlLHNCQUxKRjttQkFLSSxLQUZmRTtrQkFFRixpQkFMYUY7a0JBS2I7O2NBR0YsU0FMSUU7Y0FLSixpQkFSZUYsc0JBRVhySDtjQU1KLFNBUEZ6UDs7OztnQkFRSTtNQTdCTixTQStCUTRkLE9BQU9ELE9BQU83RyxJQUFJOEYsT0FBT2hWO1FBQy9CLEdBRCtCQSxTQUNULGVBRFQrVixPQUFPN0csSUFBSThGLE9BQU9oVjtRQUMwQixPQUQxQkEsWUFDMEIsR0FEMUJBLE1BRXpCcEM7UUFFSixPQUpXbVksU0FFUG5ZLE9BRmNzUixJQUFJOEYsU0FFbEJwWCxPQUNBQztRQUVKLE9BTFdrWSxPQWhDR3JXLEVBZ0NIcVcsU0FHUGxZLE9BREFEO1FBR0osYUFMV21ZLFNBR1BsWSxPQURBRCxHQUZjc1IsSUFBSThGLFNBRWxCcFgsT0FDQUMsR0FIY3FSLElBQUk4RixPQU9yQjtNQXRDTCxJQXdDSXpXLEVBekNjbUI7TUFDbEIsR0F3Q0luQixPQUNnQixpQkExQ0ZtQixJQXlDZG5CO01BeENKO09BeUN5QyxHQURyQ0E7T0FDcUMsR0FEckNBLElBRUVYO09BRUksaUJBREpDLEdBQ1ksaUJBN0NBNkI7TUE4Q2hCLE9BSEk5QixHQUVBcVksSUFEQXBZO01BR0osU0EvQ2dCNkIsRUE0Q1o3QixHQURBRDtNQUlKLGFBSElDLEdBREFELEdBRUFxWSxJQURBcFksR0E1Q1k2QixJQWlEZjtJQWxTWSxrQkF5U05BO01BQ1QsU0FBUTJPLElBQUlqVztRQUNWLEdBRFVBLElBREhzSDtVQUlHLE1BSkhBLE1BQ0d0SCxHQUdBLEtBSEFBO1VBSUssVUFEVHdFLGlCeEJqVlgsT3dCOFVXeVI7UUFLRCxRQUFPO01BTGQ7NEJ4QjlVSCxPd0I4VVdBLGVBT0g7SUFqVFUsbUJBbVRMM087TUFDVixTQUFRMk8sSUFBSWpXO1FBQ1YsR0FEVUEsSUFERnNIO1VBSUUsTUFKRkEsTUFDRXRILEdBR0EsS0FIQUE7VUFJUyxhQUpUQSxFQUdKd0Usa0J4QjNWWCxPd0J3Vld5UjtRQUtELFFBQU87TUFMZDs0QnhCeFZILE93QndWV0EsZUFPSDtJQTNUVSxrQkF3VU5rRztNQUNULFdBQVEscUJBQW1CMU8sSUFBSWpKLEdBQUssVUFBTEEsRUFBSmlKLElBQWUsT0FEakMwTztNQVhPLEdBRWRoVztRQUNZO1NBRFJLLEdBQUpMOztTQUNZLGtCQURaQTtTQUVVLGlCQURKeUIsSUFETm5CO1NBRVUsSUFESm1COztlQURGcEI7OztnQkFLTWdQLGNBQUpvRztZQUFVLFdBQVZBO1lBQVUsOEJBQU5wRzs7VUFERSxPQUZObE87TUFIQSxVQVlLO0lBMVVFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRYlJid1csUUFDQUMsT0FDQUM7YUFJQUMsVUFBV3paLEdBQVksT0FBWkEsZUFBdUI7YUFDbEMwWixZQUFhMVosR0FBWSxZQUFaQSxXQUF3QjthQUNyQzJaLE9BQVEzWixHQUFZLE9BQVpBLFVBQWtCO1FBRTFCNFo7YUF5REFDLFdBQVc3WjtNQUFRLFNBQVJBLEtBQVEseUJBQVJBO01BQVEsWUE3RG5CeVosVUE2RFd6WixPQUE4QjthQUt6QzhaLE9BQUs5WixHQUFJLDRCQUFKQSxFQXJFTEssU0FxRThCO2FBQzlCMFosT0FBSy9aLEdBQUksNEJBQUpBLEVBckVMTSxhQXFFa0M7YUFjbEMwWixRQUFNaGEsRUFBRUMsR0FBSSxnQ0FBTkQsRUFBRUMsTUFBbUI7YUFFbEJnYSxNQUFLamEsRUFBV0M7TUFDM0IsTUFEZ0JELElBQVdDOztRQUNLLEdBQWhCLG1CQURXQSxRQUNLLG1CQURoQkQ7UUgyWlYsWUd4WkUsT0FIUUEsU0FBV0M7TUFFdEIsT0FGc0JBLFNBQVhELENBR2M7YUFFbkJrYSxNQUFLbGEsRUFBV0M7TUFDM0IsTUFEZ0JELElBQVdDOztRQUNLLEdBQWhCLG1CQURXQSxRQUNLLG1CQURoQkQ7UUhzWlYsWUduWkUsT0FIbUJDLFNBQVhEO01BRVgsT0FGV0EsU0FBV0MsQ0FHRzthQUVuQmthLFFBQVNuYSxFQUFXQztNQUNoQixHQURLRCxVQUFXQztRQUUxQixNQUZlRCxJQUFXQzs7VUFFTSxHQUFoQixtQkFGVUEsUUFFTSxtQkFGakJEO1VIaVpkLFlHL1k0RCxVQUZuQ0MsRUFBWEQ7UUFFa0MsVUFGbENBLEVBQVdDO01BQ0YsVUEvRjNCTSxRQWdHc0U7YUFFN0Q2WixRQUFTcGEsRUFBV0M7TUFDL0IsTUFEb0JELElBQVdDOztRQUNDLEdBQWhCLG1CQURlQSxRQUNDLG1CQURaRDtRSDZZZCxZRzFZRSxPQUh1QkMsT0FBWEQsRUFBV0M7TUFFMUIsT0FGZUQsT0FBV0MsRUFBWEQsQ0FHVTthQUVuQnFhLFFBQVNyYSxFQUFXQztNQUMvQixNQURvQkQsSUFBV0M7O1FBQ0MsR0FBaEIsbUJBRGVBLFFBQ0MsbUJBRFpEO1FId1lkLFlHcllFLE9BSFlBLE9BQVdDLEVBQVhEO01BRWYsT0FGMEJDLE9BQVhELEVBQVdDLENBR0Q7YUFFbkJxYSxZQUFhdGEsRUFBV0M7TUFDaEMsR0FEcUJELE9BQ1AsVUFEa0JDO01BRTNCLEdBRjJCQSxPQUViLFVBRkVEO01BR25CLE1BSG1CQSxJQUFXQzs7UUFHRSxHQUFoQixtQkFIY0EsUUFHRSxtQkFIYkQ7UUhtWWxCLFlHaFkyRCxVQUg5QkMsRUFBWEQ7TUFHOEIsVUFIOUJBLEVBQVdDLEVBR21DO2FBSXBFc2EsT0FBS3ZhLEdBQUksMEJBQUpBLEVBQWdDO2FBYW5Dd2EsWUFBWTFYLEVBQUVLLElBQUlDLElBQUlJO01BQ3hCLFVBRGdCTCxNQUFJQztNQUNwQixhQURnQkQ7WUFDaEIzSCxFQURnQjJIO1FBQ2dCO2dCQUFoQzNILEtBRHdCZ0k7VUFDUSxTQUFoQ2hJOzs7TUFkUyxRQWM0QzthQUVuRGlmLFlBQVlDLElBQUlDLEtBQUtySSxJQUFJc0ksS0FBS3hYO01BQ2hDLFNBRGdDQSxZQUNoQzs7O1FBQ0U7bUJBRnlCd1gsT0FDM0JwZixVQURja2YsU0FBSUMsT0FDbEJuZjtVQUNFLFNBREZBOzs7Y0FFSTthQUVGcWYsTUFBTS9YLEVBQUVLLElBQUlDLElBQUkrUztNQUNsQixTQURVaFQ7TUFDVjs7O2lCQURjQzs7Ozs7Z0JBQUpELE1BQUlDO3dCQUFOTixnQkFBRUssTUFBSUM7TUFFWix3QkFGZ0IrUyxTQUVEO2FBRWYyRSxPQUFLM1osRUFBRXFDO01BQ0ksSUFBVHFNLE9BQVMsdUJBRE4xTztNQUVQLFlBREkwTyxTQURHMU8sRUFBRXFDO01BRVQsT0FESXFNLE1BRUU7YUFFSmtMLE9BQUtwWixFQUFFakM7TUFDVCxRQURPaUM7UUFHSywrQkFITEEsR0FHSyxLQUhMQSxVQUdLOztjQUNWbkc7VUFDRTtvQkFERkEsS0FDbUIsV0FMWmtFLEVBSVBsRTtZQUNFLFNBREZBOzs7UUFHQSxPQUpJc0o7TUFGUSx3Q0FNVDthQUVIa1csU0FBT3RMLEdBQUdEO01BQ1o7VUFEU0M7T0FDVCxHQURZRDtPQUdDLDhCQUZUek8sS0FDQUM7TUFFSixZQUpTeU8sS0FHTEcsU0FGQTdPO01BSUosWUFMWXlPLEtBR1JJLE9BRkE3TyxHQUNBQztNQUdKLE9BRkk0TyxNQUdFO2FBVUpvTCxTQUFPdFo7Ozs7VUFOVDtXQUlRSztXQUFOQztXQUxXakMsRUFLWGlDO1dBSkYsYUFEYWpDLElBQ1M7O2lCQUlkZ0M7O1FBSVIsdUNBQ2EwTSxJQUhKL00sRUFHTW5HO1FBQ2I7YUFEV2tUO2dCQUdIc0MsS0FIR3RDLE9BR1QwSSxLQUhTMUksT0FJTHdNLEtBREo5RDtZQUVBLFlBRkFBLE9BSkF2SCxPQUNXclUsRUFJUDBmO1lBQ0osUUFMVzFmLElBSVAwZixTQUpLeE0sSUFHSHNDLEtBSEt4Vjs7VUFFTCxHQUZLQSxpQkFEWHFVO3dDQVVFO2FBRUpzTCxNQUFJclksRUFBRUssSUFBSUM7TUFDWixNQURNTixFQUFFSyxJQUFJQztNQUVDLElBQVR5TSxPQUFTLHVCQUZEek07TUFHWixZQUhNTixFQUFFSyxJQUVKME0sU0FGUXpNO01BR1osT0FESXlNLE1BRUU7YUFFSnVMLE9BQUt0WTtNQUNQLE1BRE9BLGFBRVAsOEJBREluQjtNQUVKLFlBSE9tQixJQUVIK00sU0FEQWxPO01BRUosT0FESWtPLE1BRUU7YUFFSndMLE9BQUt2WSxFQUFFSyxJQUFJQyxJQUFJSTtNQUNqQixNQURPVixFQUFFSyxJQUFJQywwQkFDYixtQkFET04sRUFBRUssSUFBSUMsSUFBSUksRUFFTTthQUVyQjhYLE9BQUtaLElBQUlDLEtBQUtySSxJQUFJc0ksS0FBS3hYO01BQ3pCLE1BRE9zWCxJQUFJQyxLQUFjdlg7TUFFekIsTUFGZ0JrUCxJQUFJc0ksS0FBS3hYO01BRXpCLG1CQUZPc1gsSUFBSUMsS0FBS3JJLElBQUlzSSxLQUFLeFgsSUFHUTthQUUvQm1ZLFVBQVF6WTtNQUNZLFlBRFpBLDRCWDlPZixPVzhPZUEsYUFDeUI7YUFFakMwWSxVQUVhN1o7TUFEb0Isa0NBQWYsT0FDTEEsSUFBRm5HLElBQUVrVDtNQUNiO1dBRGFBO2NBR04ySyxFQUhNM0ssT0FHWCtNLEVBSFcvTTtVQUdELFdBSERsVCxLQUdUaWdCO1VBQVUsUUFIRGpnQixnQkFBRWtULElBR04ySzs7UUFEQyxPQUhOeEosT0FNSTthQUdONkwsT0FBS2hjLEVBQUVvRDtNQUNULFNBRFNBLHFCQUNUOzs7UUFBNkI7cUJBRHRCcEQsRUFBRW9ELE1BQ1R0SDtVQUE2QixTQUE3QkE7OztjQUFvRDthQUdsRG1nQixRQUFNamMsRUFBRW9ELEVBQUV6QjtNQUNaLEdBRFV5QixpQkFBRXpCO09BRVY7TUFFQSxTQUpReUIscUJBSVI7OztRQUE2QjtxQkFKdkJwRCxFQUFFb0QsTUFJUnRILEdBSlU2RixNQUlWN0Y7VUFBNkIsU0FBN0JBOzs7Y0FBcUU7YUFFckVvZ0IsTUFBSWxjLEVBQUVvRDtNQUNSLE1BRFFBLGFBRVIseUJBREluQixHQUNKLEtBRElBLFVBQ0o7O1lBQ0FuRztRQUNFO2dCQURGQSxLQUNpQixXQUpYa0UsRUFBRW9ELE1BR1J0SDtVQUNFLFNBREZBOzs7TUFHQSxPQUpJMkksQ0FJSDthQUVDMFgsT0FBS25jLEVBQUVvRCxFQUFFekI7TUFDWCxPQURTeUIsYUFDVCxHQURXekI7TUFDWCxHQUFJMFYsT0FDQUMsR0FFRjtNQUhGLElBS1UseUJBTE5ELElBS00sS0FMTkEsV0FLTTs7WUFDUnZiO1FBQ0U7Z0JBREZBLEtBQ2lCLFdBUlprRSxFQUFFb0QsTUFPUHRILEdBUFM2RixNQU9UN0Y7VUFDRSxTQURGQTs7O01BR0EsT0FKSTJJLENBS0g7YUFHRDJYLFFBQU1wYyxFQUFFb0Q7TUFDVixTQURVQSxxQkFDVjs7O1FBQTZCO3FCQURyQnBELEVBQ1JsRSxFQURVc0gsTUFDVnRIO1VBQTZCLFNBQTdCQTs7O2NBQXNEO2FBRXBEdWdCLE9BQUtyYyxFQUFFb0Q7TUFDVCxNQURTQSxhQUVULHlCQURJbkIsR0FDSixLQURJQSxVQUNKOztZQUNBbkc7UUFDRTtnQkFERkEsS0FDaUIsV0FKVmtFLEVBR1BsRSxFQUhTc0gsTUFHVHRIO1VBQ0UsU0FERkE7OztNQUdBLE9BSkkySSxDQUlIO2FBR0M2WCxZQUFVdGMsRUFBRU0sRUFBRThDO01BQ2hCLFNBRGM5QyxHQUNkLEtBRGdCOEMscUJBQ2hCOztZQUNBdEg7UUFDRTtVQUFLLGtCQUhLa0UsRUFDUnlFLEtBRFlyQixNQUVoQnRIO1VBQ08sU0FEUEE7OztNQUdBLE9BSkkySSxJQUlGO2FBR0E4WCxhQUFXdmMsRUFBRW9ELEVBQUU5QztNQUNqQixTQURpQkEsR0FDakIsS0FEZThDO01BQ2Y7WUFDQXRIO1FBQ0U7VUFBSyxrQkFITWtFLEVBQUVvRCxNQUVmdEgsR0FESTJJO1VBRUcsU0FEUDNJOzs7TUFHQSxPQUpJMkksSUFJRjthQUdBK1gsU0FBT3ZNLEVBQUU3TTtNQUNYLE1BRFdBLGFBRUV0SDtNQUNYO1dBRFdBLE1BRFQyRixFQUVZO1FBQ04sY0FKRHdPLEVBQUU3TSxNQUVFdEgsSUFFcUI7UUFDM0IsUUFITUE7aUJBSVA7YUFHSjJnQixVQUFReE0sRUFBRTdNO01BQ1osTUFEWUEsYUFFQ3RIO01BQ1g7V0FEV0EsTUFEVDJGLEVBRVk7UUFDTixjQUpBd08sRUFBRTdNLE1BRUN0SCxLQUVxQixRQUZyQkE7UUFHTixTQUNEO2FBR0o0Z0IsTUFBSXBjLEVBQUU4QztNQUNSLE1BRFFBLGFBRUt0SDtNQUNYO1dBRFdBLE1BRFQyRixFQUVZO1FBQ0UsNEJBSlYyQixNQUVLdEgsR0FGUHdFLEdBSXdDO1FBQ3ZDLFFBSE14RTtpQkFLUDthQUdKNmdCLFNBQVNyYyxFQUFFOEM7TUFDYixNQURhQSxhQUVBdEg7TUFDWDtXQURXQSxNQURUMkYsRUFFWTtRQUNGLEdBSkhuQixLQUFFOEMsTUFFQXRILEdBRXVCO1FBQzdCLFFBSE1BO2lCQUtQOzthQUlKOGdCLE9BQUszUixJQUFJN0g7TUFDWCxTQUFJdVUsT0FBTzFWLEVBQUVuRztRQUNYLFVBRFdBLDRCQUNYLEtBQUk4YjtRQUFKLElBQUlBLGVBREszVjtVQUlKOztjQUxBZ0osSUFLSSxlQUxBN0gsRUFFTHdVLEtBR2lCLGVBTFp4VSxFQUVMd1U7OztXQUcwQyxPQUgxQ0E7VUFJQzs7Y0FOQTNNLElBTUksZUFOQTdILEVBR0w5QyxNQUdnQixlQU5YOEMsRUFFTHdVOzs7V0FJeUMsT0FKekNBO1VBS0YsT0FKRXRYO1FBTWM7V0FQZHNYOztVQURLM1Y7Ozs7O1dBUVMsV0FUYmdKLElBU2lCLGVBVGI3SCxFQUVMd1UsS0FPOEIsZUFUekJ4VSxFQUVMd1U7U0FRRyxPQVJIQTtRQVNHLEdBVEhBLE1BREszVixFQVVjLE9BVG5CMlY7UUFTNEIsa0JBVnJCOWIsRUFVcUM7TUFWbEQsU0FZUStiLFlBQVk1VixFQUFFbkcsRUFBRXlQO1FYM1c3QixJVzJXMkJySjtRQUNwQjtVQUFRLElBQUo0USxFQUFJLE9BRFU3USxFQUFFQztVQUVqQixrQkFmRStJLElBZUUsZUFmRTdILEVBY0wwUCxHQURrQnZIO1lBR3BCLGVBaEJPbkksRUFhV2xCLElBR1YsZUFoQkRrQixFQWNMMFAsUUFEZ0I1USxJQUNoQjRRO1VBSUssc0JBbEJBMVAsRUFhV2xCLElBQUVxSixHQU9sQjtNQW5CTixTQXFCSXVNLFFBQVE3VixFQUFFbkcsRUFBRXlQO1FBQUk7VUFBSSxxQkFBWnRKLEVBQUVuRyxFQUFFeVA7Ozs7WUFBMkMsSUFBTHJKLFdBQUssc0JBdEJoRGtCLEVBc0IyQ2xCLElBQXRDcUo7b0JBQW9EO01BckJwRSxTQXNCUXdNLFdBQVc5VixFQUFFbkc7UVhyWDFCLElXcVgwQm9HO1FBQ25CO1VBQVEsSUFEV2dSLElBQ1gsT0FEU2pSLEVBQUVDO1VBRW5CLGVBekJTa0IsRUF1QlVsQixJQUVYLGVBekJDa0IsRUF1QlU4UDtVQUNYLElBRFdoUjttQkFHTDtNQXpCaEIsU0EyQkk4VixPQUFPL1YsRUFBRW5HO1FBQUk7VUFBSSxvQkFBVm1HLEVBQUVuRzs7O2tDQUF3QyxJQUFMb0csV0FBSyxPQUFMQTtvQkFBTTtNQTNCdEQsTUFEV2tCLGFBQ1gsT0FzQ0luQjtNQXRDSjtZQXVDQWdXO1FBQW9DO2tCQURoQ2hXLEVBQ0pnVyxJQUFnRCxlQXhDckM3VSxFQXdDWDZVO1VBQW9DLFNBQXBDQTs7O01BdkNBLFNBc0NJaFc7TUFFSjs7O1FBQ0U7VUFBUSxJQWJVaVcsSUFhVixlQTFDQzlVLEVBeUNYbEI7VUFFRSxlQTNDU2tCLEVBeUNYbEIsSUFFVSxlQTNDQ2tCO1VBMENELElBRUUsV0FIWmxCLE9BWmtCcEc7VUFDaEI7Z0JBQUlxYyxRQURZcmM7WUFDaEIsR0FEZ0JBLE1BQ1pxYztZQUVELG1CQWhDRWxOLElBZ0NFLGVBaENFN0gsRUE4QkwrVSxRQURjRDthQU1ULGVBbkNBOVUsRUE2Qk90SCxFQUFFb2M7O2NBSWhCLGVBakNPOVUsRUE2Qk90SCxFQUlOLGVBakNEc0gsRUE4QkwrVTtjQUdGLE9BSEVBLFlBRFlyYyxFQUNacWM7Y0FJeUMsZUFsQ3BDL1UsSUE2QlM4VTtZQUNsQixTQVdGaFc7Ozs7TUF4Q0EsYUFzQ0lEO01BT0o7UUFBdUIsSUFBSnNKLEVBQUksZUE5Q1puSTtRQThDeUIsZUE5Q3pCQSxJQThDaUMsZUE5Q2pDQTtRQThDWSxTQUFnQyxlQTlDNUNBLElBOENRbUk7OztNQXREakIsV0FzRCtEO2FBSS9Ec1IsWUFBWTVSLElBQUk3SDtNQUNsQixTQUFJZ1YsTUFBTUMsUUFBUUMsUUFBUUMsS0FBS0MsUUFBUUMsUUFBUTdGLElBQUk4RjtRQUNqRDtlQURRTCxVQUFRQztTQUNoQixNQUQ2QkUsVUFBUUM7U0FrQkcsb0JBbEJoQkYsS0FBS0M7U0FrQmIsb0JBbkJBcFYsRUFDUmlWO1NBRUtVLEdBRkxWO1NBRVFqWDtTQUFHNFgsR0FGVVI7U0FFUG5YO1NBQUc0WCxFQUZ3QlA7UUFHL0M7VUFBRyxrQkFKT3pOLElBR0k3SixHQUFNQztZQVNsQixlQVh5Q3VSLElBRXBCcUcsRUFBSDVYO1lBU2xCLElBQ0k2WCxLQVZXRjtZQVNmLEdBQ0lFLE9BWDBCTjtjQWE1QjttQkFabUJLO2VBWUwsb0JBZElWLEtBWWhCVztlQVZXRixHQVVYRTtlQVZjN1g7ZUFBRzRYOztZQWNuQixjQWpCVTdWLEVBR0gyVixHQUZnQ25HLElBRXBCcUcsVUFEckJOLFFBQ1NJO1VBRVQsZUFKeUNuRyxJQUVwQnFHLEVBQVQ3WDtVQUVaLElBQ0lpWSxLQUhLTjtVQUVULEdBQ0lNLE9BSkpWO1lBTUU7aUJBTG1CTTthQUtYLG9CQVJFN1YsRUFNUmlXO2FBSEtOLEdBR0xNO2FBSFFqWTthQUFTNlg7O1VBT25CLGNBVGtCVixLQUVMUyxHQUYwQnBHLElBRXBCcUcsVUFEU0wsUUFDZkksUUFnQitDO01BbEJwRSxTQW9CSVEsUUFBUUMsT0FBTzdHLElBQUk4RixPQUFPaFY7UUFDNUIsU0FENEJBLFlBQzVCOzs7O1VBQ0U7WUFBUTs4QkF2Qk1OLEVBcUJOcVcsU0FDVjNkO2FBQ1UsTUFGVzRjLFNBQ3JCNWM7O2NBR3lCO2dCQUpKNGM7O2dCQUdmNUY7Ozs7Z0JBQ21CLFdBekJiN0gsSUF5QmlCLGVBSloySCxJQUdYRSxNQURBdkg7Z0JBR0YsZUFMYXFILElBR1hFLGFBRWUsZUFMSkYsSUFHWEU7Z0JBRUY7O2NBR0YsZUFSZUYsSUFHWEUsYUFEQXZIO2NBTUosU0FQRnpQOzs7O2dCQVFJO01BN0JOLFNBK0JRNGQsT0FBT0QsT0FBTzdHLElBQUk4RixPQUFPaFY7UUFDL0IsR0FEK0JBLFNBQ1QsZUFEVCtWLE9BQU83RyxJQUFJOEYsT0FBT2hWO1FBQzBCLE9BRDFCQSxZQUMwQixHQUQxQkEsTUFFekJwQztRQUVKLE9BSldtWSxTQUVQblksT0FGY3NSLElBQUk4RixTQUVsQnBYLE9BQ0FDO1FBRUosT0FMV2tZLE9BaENHclcsRUFnQ0hxVyxTQUdQbFksT0FEQUQ7UUFHSixhQUxXbVksU0FHUGxZLE9BREFELEdBRmNzUixJQUFJOEYsU0FFbEJwWCxPQUNBQyxHQUhjcVIsSUFBSThGLE9BT3JCO01BdENMLElBd0NJelcsRUF6Q2NtQjtNQUNsQixHQXdDSW5CLE9BQ2dCLGlCQTFDRm1CLElBeUNkbkI7TUF4Q0osSUF5Q3lDLEdBRHJDQSxVQUNxQyxHQURyQ0EsSUFFRVgsT0FFSix5QkFESUM7TUFFSixPQUhJRCxHQUVBcVksSUFEQXBZO01BR0osU0EvQ2dCNkIsRUE0Q1o3QixHQURBRDtNQUlKLGFBSElDLEdBREFELEdBRUFxWSxJQURBcFksR0E1Q1k2QixJQWlEZjthQUtEMFosU0FBTzFaO01BQ1QsU0FBUTJPLElBQUlqVztRQUNWLEdBRFVBLElBREhzSDtVQUlHLE1BSkhBLE1BQ0d0SCxHQUdBLEtBSEFBO1VBSUssVUFEVHdFLGlCWDFjYixPV3VjYXlSO1FBS0QsUUFBTztNQUxkOzRCWHZjTCxPV3VjYUEsZUFPSDthQUdIZ0wsVUFBUTNaO01BQ1YsU0FBUTJPLElBQUlqVztRQUNWLEdBRFVBLElBREZzSDtVQUlFLE1BSkZBLE1BQ0V0SCxHQUdBLEtBSEFBO1VBSVMsYUFKVEEsRUFHSndFLGtCWHJkYixPV2tkYXlSO1FBS0QsUUFBTztNQUxkOzRCWGxkTCxPV2tkYUEsZUFPSDthQWFIaUwsU0FBTy9FO01BQ1Q7O09BQVEsMkJBQW1CMU8sSUFBSWpKLEdBQUssVUFBTEEsRUFBSmlKLElBQWUsT0FEakMwTztPQVRDLFdBRElwSjtPQUVkLHlCQURJbkw7T0FDSixJQURJQTs7YUFEVW1MOzs7Y0FLTnZNLFlBQUpDO1VBQVUsV0FBVkE7VUFBVSw4QkFBTkQ7O1FBREUsT0FGTmMsRUFVUzthQUdYNlosYUFBYWpkLEVBQUVvRDtNQUNqQixJQUFJbkIsRUFEYW1CO01BQ2pCLFNBQUluQixFQUNVO01BRGQsSUFFVSxpQkFGTkEsRUFFbUIsV0FIUmpDLEVBQUVvRCxPQUdQLEtBRk5uQixVQUVNOztZQUNSbkc7UUFDRTtnQkFERkEsS0FDdUIsV0FMVmtFLEVBQUVvRCxNQUlmdEg7VUFDRSxTQURGQTs7O01BR0EsT0FKSTJJLENBS0g7YUFFRHlZLGVBQWVsZCxFQUFFb0Q7TUFDbkIsTUFEbUJBLGFBRW5CLHlCQURJbkIsR0FDSixLQURJQSxVQUNKOztZQUNBbkc7UUFDRTtnQkFERkEsS0FDaUIsV0FKQWtFLEVBQUVvRCxNQUduQnRIO1VBQ0UsU0FERkE7OztNQUdBLE9BSkkySSxDQUlIOzs7Ozs7O3NCWDNmTjs7O09XNktPMlc7O09BS0FDO09BU0FDO09BZ0JBQztPQWNBRTtPQU1BQztPQU1BQztPQUlBQztPQUtBQztPQUdBQztPQVVBRTtPQWdDQUk7T0F0QkFGO09BeUJBRztPQVNBQztPQVFBQztPQWhEQU47T0FjQUU7T0FtREFNO09BVEFEO09Ba0JBRTtPQVVBQztPQVdBQztPQWtEQUM7O09Bc0RBQztPQVdBQztPQXFCQUM7T0FLQUM7T0FVQUM7Ozs7OztPQXpkRnREO09BQ0FDO09BQ0FDO09Bc0VBTTtPQUNBQztPQXRFQTFaO09BQ0FDO09BQ0FDO09BS0FxWjtPQUNBcFo7T0FDQUM7T0FDQUM7T0FQQStZO09BQ0FDO09BQ0FDO09BMkRBRTtPQWxEQS9YO09BQ0FEOztPQXFFQW1ZO09BRVNDO09BS0FDO09BS0FDO09BSUFDO09BS0FDO09BS0FDO09BT1RDOzt1QlhwSkw7OztRVzZLT087O1FBS0FDO1FBU0FDO1FBZ0JBQztRQWNBRTtRQU1BQztRQU1BQztRQUlBQztRQUtBQztRQUdBQztRQVVBRTtRQWdDQUk7UUF0QkFGO1FBeUJBRztRQVNBQztRQVFBQztRQWhEQU47UUFjQUU7UUFtREFNO1FBVEFEO1FBa0JBRTtRQVVBQztRQVdBQztRQWtEQUM7O1FBc0RBQztRQVdBQztRQXFCQUM7UUFLQUM7UUFVQUM7OztRY25lRkMsU0FDQUMsUUFDQUM7YUFTQUMsTUFBSWhkLEdBQUksWUFBSkEsV0FBNEI7UUFDaENpZCxxQkFDQUM7YUFJQUMsT0FBT25kLEdBQUksT0FBSkEsTUFBaUI7YUFJeEJvZCxtQnpCdkNMO1F5QndDS0M7YUFVQUMsWUFBVXRkLEdBQUksbUNBQUpBLEVBQXFCOzs7O09BaEMvQjZjO09BQ0FDO09BQ0FDO09BU0FDO09BQ0FDO09BQ0FDO09BSUFDO09BSUFDO09BQ0FDO09BVUFDOztRQ0xBQyxTQUNBQyxRQUNBQzthQUNBQyxPQUFLdmMsR0FBSSxPQUFKQSxTQUFZO2FBQ2pCd2MsT0FBS3hjLEdBQUksT0FBSkEsU0FBWTthQUNqQnljLE1BQUl6YyxHQUFPLHlCQUFQQSxjQUFnQztRQUNwQzBjLHNCQUNBQzthQUNBQyxTQUFPNWMsR0FBSSxPQUFKQSxNQUFrQjtJQUtULFNBSGhCNmMsZ0JBSU03YztNQUN3Qjs7YUFBdkIsbUJBRERBOzs7YUFDd0IsaUJBRHhCQTtPQUVBLFVBRkFBO01BSUEsUUFBSTthQVNWOGMsWUFBVTljLEdBQUksNkJBQUpBLEVBQWlCO2FBSTNCK2MsZ0JBQWNyZTtNQUVoQjtRQUFTLCtCQUZPQTs7OytCQUdFO1FBUEYsV0FPTTthQUlwQnNlLFVBQVNuZSxFQUFPQyxHQUFRLHdCQUFmRCxFQUFPQyxFQUEwQjthQUMxQ21lLFFBQU9wZSxFQUFPQyxHQUFRLDhCQUFmRCxFQUFPQyxNQUF1QjthQUVyQ29lLGlCQUFpQmxkLEVBQUVtZDtNQUNiLHdCQURXbmQsbUJBQUVtZCxtQkFDa0I7YUFLckNDLGFBQWFwZCxFQUFFd1g7TUFDZCxpQkFEY0EsS0FFWiw2QkFGVXhYLEVBQUV3WCxHQTlDZjZFLE1BREFEO01BbURvRCxNQUFILFNBSnBDcGMsWUFBRXdYLFFBS1AsRUFMS3hYLElBS0MsU0FEVnFkLEVBSlc3RjtNQU1aLDZCQURDeFUsRUFMV3dVLEdBSVg2RixXQUUyQzthQUUvQ0MsYUFBYXRkLEVBQUV3WCxHQUNqQixPQURleFgsSUFDYyxTQUFsQixhQURJQSxFQUFFd1gsU0FDZTs7OztPQXhEOUI0RTtPQUNBQztPQUNBQztPQTZDQWM7T0FRQUU7T0FwREFmO09BQ0FDO09BQ0FDO09BRUFFO09BREFEO09BRUFFO09BRUFDO09BcUJBRTtPQUpBRDtPQVdBRTtPQUdBRTtPQUZBRDs7YXhCdENBTSxPQUFLdmQsR0FBSSxzQkFBSkEsTUFBWTthQUNqQndkLE9BQUt4ZCxHQUFJLHNCQUFKQSxNQUFZO2FBQ2pCeWQsTUFBSXpkO01BQU8seUJBQVBBLFNBQTJCLHVCQUEzQkEsRUFBZ0M7YUFHcEMwZCxTQUFPMWQsR0FBSSw4QkFBSkEsTUFBa0I7SUFHYixJQUFWMmQsVUFBVTthQURaQyxrQkFFRTVkO01BQ3dCOzthQUF2QixtQkFiSHBILE9BWUVvSDs7O2FBQ3dCLG1CQUR4QkEsRUFEQTJkO09BR0Esc0NBRkEzZDtNQUlBLFFBQUk7SUFMTSxTQVFaNmQsWUFBVTdkLEdBQUksaUNBQUpBLEVBQWlCO0lBUmYsU0FZWjhkLGdCQUFjcGY7TUFFaEI7UUFBUyxpQ0FGT0E7OzsrQkFHRTtRQVBGLFdBT007SUFmUixTQTRCWnFmLFVBQVNsZixFQUFPQyxHQUFRLDBCQUFmRCxFQUFPQyxFQUEwQjtJQTVCOUIsU0E2QlprZixTQUFPbmYsRUFBT0MsR0FBUSxnQ0FBZkQsRUFBT0MsTUFBdUI7SUE3QnpCLFNBK0JabWYsbUJBQWlCamUsRUFBRW1kO01BQ2I7OEJBRFduZCxFQXBDakJqSCxXQXFDc0IsZUFESG9rQixFQXBDbkJwa0IsV0FxQ3FDO0lBaEN6QixTQXFDWm1sQixlQUFhbGUsRUFBRXdYO01BQ2QsaUJBRGNBLEVBaERmNWU7T0FrREcsK0JBRlVvSCxFQUFFd1gsR0EvQ2YzZSxNQURBRDtNQW9Eb0Q7OztVQUFIO1lBQXpCLHdDQUpYb0gsS0FBRXdYOztPQUtQLGlCQUxLeFgsRUFLQyxlQURWcWQsRUFKVzdGO01BTVosK0JBREN4VSxFQUxXd1UsR0FNbUIsT0FGOUI2RixJQUUyQztJQTNDbkMsU0E2Q1pjLGVBQWFuZSxFQUFFd1g7TUFDakIsc0JBRGV4WCxFQUNjLGVBQWxCLGVBRElBLEVBQUV3WCxNQUNlO0lBOUNsQjs7O09BWFo1ZTtPQUNBQztPQUNBQztPQThDQW9sQjtPQVFBQztPQXJEQVo7T0FDQUM7T0FDQUM7T0FFQXprQjtPQURBRDtPQUVBMmtCO09BRUFFO09BYUFFO09BSkFEO09Bb0JBRTtPQUdBRTtPQUZBRDtJQTdCWTtRVWJaSSxTQUNBQyxRQUNBQzthQUNBQyxPQUFLdmUsR0FBSSxPQUFKQSxTQUFZO2FBQ2pCd2UsT0FBS3hlLEdBQUksT0FBSkEsU0FBWTthQUNqQnllLE1BQUl6ZSxHQUFPLHlCQUFQQSxjQUFnQztJQUUxQiwwQkFDQTthQUNWNGUsU0FBTzVlLEdBQUksT0FBSkEsTUFBa0I7SUFHYixTQURaNmUsa0JBRUU3ZTtNQUN3Qjs7YUFBdkIsbUJBRERBOzs7YUFDd0IsaUJBRHhCQTtPQUVBLFVBRkFBO01BSUEsUUFBSTtJQUxNLFNBUVo4ZSxZQUFVOWUsR0FBSSwrQkFBSkEsRUFBaUI7SUFSZixTQVlaK2UsZ0JBQWNyZ0I7TUFFaEI7UUFBUywrQkFGT0E7OzsrQkFHRTtRQVBGLFdBT007SUFmUixTQW1CWnNnQixXQUFTbmdCLEVBQU9DLEdBQVEsd0JBQWZELEVBQU9DLEVBQTBCO0lBbkI5QixTQW9CWm1nQixTQUFPcGdCLEVBQU9DLEdBQVEsOEJBQWZELEVBQU9DLE1BQXVCO0lBcEJ6QixTQXNCWm9nQixtQkFBaUJsZixFQUFFbWQ7TUFDYix3QkFEV25kLG1CQUFFbWQsbUJBQ2tCO0lBdkJ6QixTQTRCWmdDLGVBQWFuZixFQUFFd1g7TUFDZCxpQkFEY0EsS0FFWiwrQkFGVXhYLEVBQUV3WCxHQXZDZjZHLE1BREFEO01BNENvRCxNQUFILFNBSnBDcGUsWUFBRXdYLFFBS1AsRUFMS3hYLElBS0MsU0FEVnFkLEVBSlc3RjtNQU1aLCtCQURDeFUsRUFMV3dVLEdBSVg2RixXQUUyQztJQWxDbkMsU0FvQ1orQixlQUFhcGYsRUFBRXdYO01BQ2pCLE9BRGV4WCxJQUNjLFNBQWxCLGVBRElBLEVBQUV3WCxTQUNlO0lBckNsQjs7O09BWlo0RztPQUNBQztPQUNBQztPQXNDQWE7T0FRQUM7T0E3Q0FiO09BQ0FDO09BQ0FDO09BQ0F2UjtPQUVBeVI7T0FEQUQ7T0FFQUU7T0FFQUM7T0FhQUU7T0FKQUQ7T0FXQUU7T0FHQUU7T0FGQUQ7SUFwQlk7YVRXWkksT0FBT0MsSUFBSUMsTUFBTWhjO01BQ047c0NBREorYixJQUFJQyxNQUFNaGM7T0FDTixVQUFUbUw7T0FBUyxVQURNbkwsWUF2Q2pCdEs7TUF5Q2lEO2tCQUZoQ3NLO1FBRWdDLFNBRmhDQTtRQUVnQyxxQ0FGaENBO01BT25CLE9BTkltTCxNQU1FO2FBR0o4USxXQUFXRixJQUFJQyxNQUFNaGM7TUFDVjswQ0FEQStiLElBQUlDLE1BQU1oYztPQUNWLFVBQVRtTDtPQUFTLFVBRFVuTCxZQWpEckJ0SztNQW1EaUQ7a0JBRjVCc0s7UUFFNEIsU0FGNUJBO1FBRTRCLHFDQUY1QkE7TUFPdkIsT0FOSW1MLE1BTUU7YUFtRUorUSxjQUFnQkMsSUFBdUJuaEI7TUFDekMsR0FEa0JtaEIsSUFBaUIsUUFBakJBLHNCQUFpQkMsYUFBakJDO01BQ2xCO1lBRGtCQSxlQVBoQjFtQixTQXBIQUQ7T0FzSXFDLEtBWHJCMm1CLGVBUGhCMW1CLFNBcEhBRDtPQTRIMkI7T0FRakI7Ozs7Ozs7O09BUEc7TUFEQzt1QkFqRWlCNm1CO2dCQUUvQjs7NkJBOER1Q3ZoQixFQWhFbkJzaEIsV0FDdEIscUJBRHNCQTtpQkFFcEIsTUFERUUsV0FENkJEO2dCQWFqQyx3QkFiaUNBLDBCQUc3QjlmO2tCQVUrRDtzQkFibEM4Ziw2QkFHN0I5Zjs7b0JBVStELHFCQWJsQzhmO21CQWlCMUI7cUJBakIwQkE7O29CQTRCM0I7cUJBREVFO3NCQUNGOzRCQUxLLHFCQXZCc0JGO29CQTRCM0IsR0FERUUsV0EzQnlCRiw2QkFHN0I5ZjtxQkEyQks7b0JBRkgsSUFHRWlnQixPQUFTLGtCQUpURDtvQkFNSixLQWpDNkJGLG9CQStCekJHLFNBL0J5Qkg7b0JBaUM3QixZQUZJRztrQkFTTixJQUFJdmhCLEVBeEMyQm9oQjtrQkF3Qy9CLFlBeEMrQkEsWUF3QzNCcGhCO2tCQUFKLFlBeEMrQm9oQixZQXdDM0JwaEI7a0JBQUo7OEJBeEMrQm9oQixZQXdDM0JwaEI7a0JBQUosWUF4QytCb2hCLFlBd0MzQnBoQjtrQkFBSixNQXhDK0JvaEIsV0F3Qy9CLEtBTUk1SCxxQkFOSjs7d0JBT0E3ZDtvQkFDRTtzQkFBUSxJQUFKZ0ksRUFBSSxpQkFGTjZWLEVBQ0o3ZDtzQkFDVSxRQUFKZ0ksRUFFRixpQkFKQTZWLEVBQ0o3ZCxZQUNNZ0ksSUFSRjNEO3NCQVFNLFNBRFZyRTs7O2dCQU9GLEtBdERzQndsQixhQUFXQyxvQkFHN0I5ZjtnQkFtREosWUF0RGlDOGYsWUFHN0I5ZjtnQkFtREo7Ozs7Ozs7Ozs7O21CQXVCQzthQUVDa2dCLGFBQWNOLGVBQWVoZDtNQUMvQjtlQURnQmdkLHdCQUNtQnJjLElBQUl2RCxHQUFLLGFBRGI0QyxHQUNJVyxNQUFJdkQsRUFBcUIsRUFBQzthQUUzRG1nQixjQUFjVCxJQUF1QmhoQjtNQUN2QyxHQURnQmdoQixJQUFpQixRQUFqQkEsc0JBQWlCQyxhQUFqQkM7TUFDaEI7WUFEZ0JBLGVBekJkMW1CLFNBcEhBRDtPQXlKcUMsS0FadkIybUIsZUF6QmQxbUIsU0FwSEFEO09BdUpVOzs7Ozs7O2tDQVYyQnlGO09BRXhCLGVBRndCQTtNQUV4Qjt1QkFETW9oQixRQUFVLHNCQUE4Qjs7Ozs7Ozs7Ozs7bUJBYTVEO2FBRUNNLGFBQWFOLE9BQU9PO01BQ3RCLGdCQURlUCxjQUFPTztNQUN0QixZQURzQkE7TUFDdEIsUUFDdUM7YUFFckNDLGFBQWFSLE9BQU9TO01BQ3RCLFNBRGVUO01BQ2YsZ0JBRHNCUztNQUN0QixRQUErRDthQUU3RFgsZUFBZUUsUUFBUyxPQUFUQSxlQXBLZjdtQixhQW9Lc0Q7YUFFdER1bkIsT0FBT1Y7TUFDVCxJQUFJN2QsSUFESzZkO01BQ1Qsa0JBRFNBLG9CQUNMN2QsSUFDdUQ7YUFFekR3ZSxXQUFXWCxPQUFPeEksR0FBR0M7TUFDdkIsSUFBSXRWLElBRG1Cc1YsS0FBSEQsT0FDcEIsa0JBRGF3SSxVQUFPeEksR0FDaEJyVixJQUNxQzthQUV2Q3llLGVBQWVaLE9BQU94SSxHQUFHQztNQUMzQixRQUR3QkQsSUFDUixJQUNWclYsSUFGcUJzVixLQUFIRCxPQUdqQixxQkFIVXdJLFVBQU94SSxHQUVsQnJWO01BRUcsUUFFTjthQUVEMGUsZ0JBQWdCYixPQUFPemxCLEdBQUksc0JBQVh5bEIsVUFBT3psQixFQUFpQzthQUV4RHVtQixvQkFBb0JkLE9BQU96bEI7TUFDN0IsWUFENkJBLEtBRXRCLGVBRmV5bEIsVUFBT3psQixLQUl2QjthQUdKd21CLFlBQVlmLE9BQU96bEI7TUFDckIsc0JBRGN5bEIsc0JBQU96bEIsTUFDaUM7YUFFcER5bUIsYUFBYWhCLFFBQVMsT0FBVEEsYUFBb0M7YUFDakRpQixXQUFXakIsUUFBUyxPQUFUQSxhQUFtQzthQUU5Q2tCLGVBQWVsQixRQUFTLE9BQVRBLFVBQTJCO2FBQzFDbUIsYUFBYW5CLFFBQVMsT0FBVEEsVUFBMEI7YUFFdkNvQixTQUFTcEI7TUFDWDtXQURXQTtPQUNYLEtBQUlxQixRQXpNRmxvQjtPQXlNRixXQURXNm1CLGdCQUNQcUI7TUFIb0IsV0FTbkI7YUFNSEMsWUFBWXZMO01BQ2Q7O1VBRUlzTCxJQUhVdEw7TUFDZCxHQUVJc0wsUUF4TkZsb0I7T0EwTkEsWUFGRWtvQixPQXBHRmpvQjtNQXVHRjtjQUF1Qjs7OztPQTNOckJEO09BMElBaW5CO09BR0FDO09BbEJBVjtPQWtDQVc7T0FJQUU7T0FHQVY7T0FFQVk7T0F5QkFLO09BR0FDO09BQ0FDO09BRUFDO09BQ0FDO09BRUFDO09BYUFFO09BM0NBWDtPQUlBQztPQVFBQztPQUVBQztPQWpKQXZCO09BVUFHOztJd0JlVTs7Ozs7O09BQ0E7T0FDUyxtQnhCbEVuQnZtQjtPd0JtRWlCLG1CeEJuRWpCQTs7Ozs7Ozs7Ozs7OztJd0JnRVUsU0FpQlZxb0I7TUFDRjtlQW5CRUQ7T0FtQkYsUUFBSUU7T0FFUSxxQkFEUkM7T0FFUSxxQkFGUkE7T0FHWSx5QkFIWkEsUXhCbkZGdm9CO093QnVGWSx1QkFKVnVvQixReEJuRkZ2b0I7TXdCd0ZBLE9BekJBb29CLFNBcUJFSSxRQUZBRjtNQU1GLFNBSkVFO01BTUYsT0EzQkFKLFNBc0JFSyxRQUhBSDtNQVFGLFNBTEVHO01BT0YsT0E3QkFMLFNBdUJFTSxZQUpBSjtNQVVGLFNBTkVJO01BUUYsT0EvQkFOLFNBd0JFTyxVQUxBTDtNQVlGLFNBUEVLO01BT0YsU0FYRUo7TUFXRixRQUV3QjtJQWhDZCxTQWtDVks7TUFDRixPQXBDRVIsbUJBb0NGLG1CQUN1QjtJQXBDWCxJQXNDVlMseUNBQWdELFFBQUs7SUF0QzNDLFNBd0NWQyxRQUFRQyxPQUFPQyxNQUFNQyxNQUFNcEM7TUFDN0I7Z0JBMUNFdUI7T0EwQ0YsUUExQ0VBO09BMENGLGVBMUNFQTtPQTBDRixXQTFDRUE7T0EwQ0YsZUExQ0VBO09BMENGLFVBMUNFQTtPQTBDRixhQTFDRUE7TUEwQ0YsU0ExQ0VBO01BMENGLFNBRGlCWTtNQUNqQixVQUQ2Qm5DO01BQzdCO1lBQWE0QyxNQUFJQztRQUNmO1VBQU0sb0NBRkVYLE9BekNSWCxJQTBDV3FCLElBQUlDO1VBQ1Q7O2FBRWMsSUFITEMsTUFHSyxXQUpDVixNQUFNcEM7YUFJUCxTQUpPQTthQUlQLFVBSk9BO2FBSVAsSUFIVDRDLE1BQUlDOzttQkFRWDttQkFTQSxtQkFqQk9ELE1BQUlDO21CQW1CWCxtQkFuQk9ELE1BQUlDOzthQVVYO2VBRStEO3FCQXREbkV0QjtnQkFzRG1FOzRCQUFoQyxpQkFiM0JXLDBCQXpDUlg7Z0JBc0RtRTtnQkFacER3QjtnQkFBSkM7Ozt1Q0FlUDttQkFmV0QsUUFBSkM7MkJBQUlIOzs7YUFxQlgsV0F0QklYLGlDQUNHVSxNQUFJQztZQW1DWkk7O1FBQ0gsSUFBSUMsVUE5RUozQjtRQThFQSxVQWJFYztRQWFGLFVBWkVDO1FBWUYsU0FYRUM7UUFXRixVQVZFQztRQVVGLFNBVEVDO1FBU0YsU0FSRUM7UUFRRixVQVBFQztRQU9GLEdBREdNLG1CQVdDLElBREsxZ0IsRUFWTjBnQixPQVdDLE9BREsxZ0I7UUFHTDs7aUJBQ080Z0I7VUFDQSxZQURBQTtZQUV1QixzQkFGdkJBO1lBRUUsd0JBcERMakIsOEJBcUNKZ0I7OztVQWdCUyx3QkFyRExoQixVQWtER2lCLGtCQWJQRCxhQWdCd0Q7UUFKeEQsTUFiREQsSUFrQlU7SUE5RkgsU0FnR1ZHLFNBQVM3QixJQUFJcmhCO01BQ2YsU0FEV3FoQixVQUFJcmhCLE1BQ0wsd0JBRENxaEIsc0JBQ3dCO0lBakd2QixTQW1HVjhCO00zQjVMTCxJMkI2TGdCOW9CLEVBckdYZ25CO01Bc0dBO2VBRFdobkI7VUFFTjtpQkF2R0xnbkIsVUFxR1dobkI7V0FHQSxvQkF4R1hnbkI7V0F3R1csTUF4R1hBLFVBcUdXaG5CO1dBSUEsb0JBekdYZ25CO1VBMEdLLGlCQUZDK0IsR0FDQUMsSUFDYSxPQUZiRDtVQURELElBR3NCLElBTGhCL29COztRQUNJLFNBdEdmZ25CO1FBc0dlLHdCQXRHZkEsdUJBNkdlO0lBNUdMLFNBOEdWaUM7TUFBb0IsU0EvR3BCakMsUUErR29CLHdCQS9HcEJBLHNCQStHZ0Q7SUE5R3RDLFNBK0dWa0MsY0FBY3ZqQjtNQUFJLFNBaEhsQnFoQixxQkFnSGNyaEI7TUFBSSx3QkFoSGxCcWhCLHNCQWdIcUU7SUEvRzNELFNBZ0hWbUMsWUFBWXhqQjtNQUFJLFNBakhoQnFoQixxQkFpSFlyaEI7TUFBSSx3QkFqSGhCcWhCLHNCQWlIaUU7SUFoSHZELFNBa0hWb0Msb0JBQWtCLDZCQUE4QjtJQWxIdEMsU0FtSFZDLGtCQUFnQiwyQkFBNEI7SUFuSGxDLFNBb0hWQyxVQUFVM2pCLEdBQUkscUJBQUpBLEtBQThCO0lBcEg5QixTQXFIVjRqQixRQUFRNWpCLEdBQUksbUJBQUpBLEtBQTRCO0lBckgxQixTQXVIVjZqQixxQkFBcUJaO01BQ3ZCLGtCQWxGRW5CLHlCQWlGcUJtQixJQUNlO0lBeEgxQixTQTBIVmEsbUJBQTJCLFFBQUU7SUExSG5COzs7T0FrSFZMO09BQ0FDO09BQ0FDO09BQ0FDO09BbEJBVDtPQVdBRztPQUNBQztPQUNBQztPQTlFQTNCOztzQjNCM0hMOztPMkJpSUtFO09Bd0RBbUI7T0F1QkFXO09BR0FDO0lBMUhVOzs7OztrQkNWTkMsY0FBUyxVQUVHLElBQU56SixXQUFNLE9BQU5BLEVBREcsUUFDSTtrQkFPYnpGLE9BQU9yVSxFQUFFNkIsRUFBRVc7V0FDYixHQURTeEMsRUFDc0MsTUFEdENBLEtBQ0x3akIsR0FBcUMxSixXQUFyQzBKO1dBQ0osR0FGYWhoQixFQUVrQyxRQUZsQ0EsS0FFVGtoQixHQUFxQ0QsYUFBckNDO1dBQ0osU0FESUEsTUFEQUYsY0FDQUU7cUJBRksxakIsRUFBRTZCLEVBQUVXLE9BR3lDO2tCQU9wRG1oQixJQUFJM2pCLEVBQUU2QixFQUFFVztXQUNWLEdBRE14QyxFQUN5QyxNQUR6Q0EsS0FDRndqQixHQUFxQzFKLFdBQXJDMEo7V0FDSixHQUZVaGhCLEVBRXFDLFFBRnJDQSxLQUVOa2hCLEdBQXFDRCxhQUFyQ0M7V0FDSixJQURJQSxjQURBRjthQUVnQixHQUhkeGpCO2VBT2dCLElBREM0akIsR0FOakI1akIsS0FNVzZqQixHQU5YN2pCLEtBTUs4akIsR0FOTDlqQixLQU9nQixZQURDNGpCO2VBQ2Qsa0JBREVFLElBRVUsY0FGVkEsR0FBTUQsR0FFSSxPQUZFRCxHQU5mL2hCLEVBQUVXO2VBU0MsR0FIWW9oQjtpQkFPbUIsSUFEWEcsSUFOUkgsTUFNQ0ksSUFOREosTUFNTkssSUFOTUwsTUFPbUIsWUFEWEcsSUFadkJsaUIsRUFBRVc7aUJBYVMscUJBUFJzaEIsR0FBTUQsR0FNQUksS0FBT0Q7ZUFETDthQU5OO1dBVUosSUFkTFIsY0FDQUU7YUFheUIsR0FmbkJsaEI7ZUFtQlksSUFEQzBoQixHQWxCYjFoQixLQWtCTzJoQixHQWxCUDNoQixLQWtCQzRoQixHQWxCRDVoQixLQW1CWSxZQURYNGhCO2VBQ0Ysa0JBRGNGLElBRVIscUJBcEJUbGtCLEVBQUU2QixFQWtCR3VpQixJQUFNRCxHQUFNRDtlQUdaLEdBSEFFO2lCQU82QixJQURUQyxJQU5wQkQsTUFNYUUsSUFOYkYsTUFNTUcsSUFOTkgsTUFPNkIsWUFEVEMsSUFOZEYsR0FBTUQ7aUJBT0oscUJBekJibGtCLEVBQUU2QixFQXdCUzBpQixLQUFPRDtlQURMO2FBTk47V0FXWCxTQTFCRVosTUFEQUYsY0FDQUU7cUJBRkUxakIsRUFBRTZCLEVBQUVXLE9BNEI4QztrQkFJbERnaUIsSUFBSW5tQixFQUVScVo7VzVCcElULEc0Qm9JU0E7YUFDVSxJQURDbFYsRUFBWGtWLEtBQVE3VixFQUFSNlYsS0FBSzFYLEVBQUwwWCxLQUNVLG9CQUhGclosRUFFQXdEO2FBQ0UsU0FBSmYsRUFDVSxPQUZoQjRXO2FBR0UsUUFGSTVXLEdBTU8sSUFBTG9qQixHQUFLLElBVEw3bEIsRUFFR21FLEdBT0UsT0FQRkEsTUFPSDBoQixHQVBSeE0sRUFRMkIsSUFSdEIxWCxFQUFHNkIsRUFPQXFpQjthQU5FLElBR0ZKLEdBQUssSUFOTHpsQixFQUVIMkI7YUFJUSxPQUpSQSxNQUlHOGpCLEdBSlJwTSxFQUsyQixJQURuQm9NLEdBSkFqaUIsRUFBR1c7V0FERixZQUREbkU7a0JBWVJvbUIsVUFBVXBtQixHQUFJLFlBQUpBLE1BQW9DO2tCQVMxQ3FtQixnQkFBZ0JybUI7VzVCdko3QjtpQjRCeUpxQm1FLFdBQUhYLFdBQUg3QjthQUNGLDJCQUhnQjNCLEVBRWQyQixHQUFHNkIsRUFBR1c7V0FESCxpQkFEV25FO2tCQUtoQnNtQixnQkFBZ0J0bUI7VzVCNUo3QjtpQjRCOEpxQm1FLFdBQUhYLFdBQUg3QjthQUNFLFdBREZBLEVBQUc2QixFQUNELGdCQUhZeEQsRUFFUm1FO1dBREgsaUJBRFduRTtrQkFRaEI4SixLQUFLbkksRUFBRTZCLEVBQUVXO1dBQ2YsR0FEV3hDO2dCQUFJd0M7O2dCQUkyQ29pQixHQUozQ3BpQjtnQkFJcUMwaEIsR0FKckMxaEI7Z0JBSStCMmhCLEdBSi9CM2hCO2dCQUl5QjRoQixHQUp6QjVoQjtnQkFJYXFpQixHQUpqQjdrQjtnQkFJVzRqQixHQUpYNWpCO2dCQUlLNmpCLEdBSkw3akI7Z0JBSUQ4akIsR0FKQzlqQjt1QkFJK0M0a0IsY0FBOUJDO3dCQUNNLElBRHhCZixHQUFNRCxHQUNrQixLQURaRCxHQUpUL2hCLEVBQUVXO3lCQUlhcWlCLGNBQThCRCxHQUU5QixTQU5qQjVrQixFQUFFNkIsRUFJMkJ1aUIsSUFBTUQsR0FBTUQsSUFHaEQsT0FQT2xrQixFQUFFNkIsRUFBRVc7YUFHQyx1QkFISFgsRUFBRjdCO1dBRUssdUJBRkg2QixFQUFFVyxFQU9DO2tCQUlWc2lCO1c1Qi9LYjtXNEIrS3VCOzs7O2VBRU0sSUFBTmpqQjtlQUFNLE9BQU5BO2FBREwsZ0JBRVc7a0JBRWhCa2pCO1c1QnBMYjtXNEJvTDJCOzs7O2VBRUUsSUFBTmxqQjtlQUFNLFVBQU5BO2FBREwsU0FFZTtrQkFFcEJtakI7VzVCekxiO1c0QnlMdUI7OzhCQUdILCtCQUFOeFA7ZUFEZSxJQUFmM1Q7ZUFBZSxPQUFmQTthQURJLGdCQUVXO2tCQUVoQm9qQjtXNUI5TGI7VzRCOEwyQjs7OEJBR1AsK0JBQU56UDtlQURlLElBQWYzVDtlQUFlLFVBQWZBO2FBREksU0FFZTtrQkFJcEJxakI7V0FBaUI7OzttQkFHVjFpQixXQUFIWCxXQUFhLGdDQUFiQSxFQUFHVzthQURTLElBQU4yaUI7YUFBTSxPQUFOQTtXQURMLDBDQUVrQztrQkFnQjNDQyxPQUdDMU4sRUFET3JOO1dBRFYsR0FFR3FOO2FBQ1MsR0FGRnJOO2VBRXVCLHdCQUZ2QkE7ZUFFVSxZQURqQnFOLEVBQ2lCLFFBRlZyTjthQUNNLE9BQWJxTjtXQURhLE9BQU5yTixLQUUwQztrQkFROUNnYixNQUFNaG5CO1c1QnBPbkI7YTRCd09tQixJQURDbUUsV0FBSFgsV0FBSDdCLFdBQ0ssb0JBSkEzQixFQUdGd0Q7YUFDRSxTQUFKZixFQUNVLFVBRlhkLElBQU13QzthQUdKLFFBRkQxQjtlQUttQixnQkFUZnpDLEVBR0NtRSxHQU1jO2VBQWMsZUFObEN4QyxFQUFHNkIsRUFNQytoQixJQUFJMEIsS0FBTXBCO2FBTFQ7Y0FHZSxjQVBmN2xCLEVBR0wyQjtjQUlvQjs7O2FBQXdCLFVBQXhDOGpCLEdBQUl5QixPQUFvQyxLQUE5Qm5CLEdBSlh2aUIsRUFBR1c7V0FEVDthQVdGNEQ7a0JBRUFvZixnQkFBVyxnQkFBbUM7a0JBRTFDQyxJQUFJcG5CO1c1QnJQakI7OztlNEJ3UG1CO2dCQURDbUU7Z0JBQUhYO2dCQUFIN0I7Z0JBQ0ssb0JBSEYzQixFQUVBd0Q7Z0JBQ0UsV0FBSmY7ZUFBSSxRQUZEO2VBRUMsSUFEQzBVLGFBQ0wxVSxFQURLMEIsRUFBTnhDLFVBQU13Vjs7YUFERjtrQkFLTGtRLE9BQU9ybkIsRUFFWHFaO1c1QjdQVCxHNEI2UFNBO2FBQ1UsSUFERWxWLEVBQVprVixLQUFTN1YsRUFBVDZWLEtBQU0xWCxFQUFOMFgsS0FDVSxvQkFIQ3JaLEVBRUZ3RDthQUNDLFNBQUpmO2VBL0NSLEdBOENRZDtpQkEzQ0ksR0EyQ0V3QzttQkEzQ2tCLHdCQTJDbEJBLEdBM0NLLFdBMkNYeEMsRUEzQ1csUUEyQ0x3QztpQkE1Q0UsT0E0Q1J4QztlQTdDUSxPQTZDRndDO2FBSVIsUUFIRTFCLEdBUVMsSUFBTG9qQixHQUFLLE9BWEo3bEIsRUFFQ21FLEdBU0csT0FUSEEsTUFTRjBoQixHQVRWeE0sRUFXVyxJQVhMMVgsRUFBRzZCLEVBU0NxaUI7YUFSQSxJQUlBSixHQUFLLE9BUEp6bEIsRUFFTDJCO2FBS1MsT0FMVEEsTUFLSThqQixHQUxWcE0sRUFPVyxJQUZEb00sR0FMRGppQixFQUFHVztXQURIO2tCQWNMbWpCLE1BR0hsWCxHQURPcEU7V0FEVixHQUVHb0U7Z0JBRE9wRTs7Z0JBRWdEbUUsR0FGaERuRTtnQkFFMEN1YixHQUYxQ3ZiO2dCQUVvQ3diLEdBRnBDeGI7Z0JBRThCL0ssR0FGOUIrSztnQkFFa0JxRSxHQUR6QkQ7Z0JBQ21CcVgsR0FEbkJyWDtnQkFDYTVGLEdBRGI0RjtnQkFDT3BQLEdBRFBvUDtrQkFDdURELE1BQTlCRTtpQkFFdEIsU0FGb0RGLEdBRXJDLFdBRnlCcVgsR0FEM0NwWDtpQkFJdUI7Z0NBSFY1RixHQUZOd0I7a0JBS2dCOztrQkFDSSxXQUpSeWIsR0FHRkM7aUJBQ1Asa0JBSkgxbUIsR0FHR2lPLE1BSEd6RTtlQU9WLFNBUHNCNkYsR0FPUCxXQVBMN0YsR0FGTndCO2VBVWdCOzhCQVJvQndiLEdBRDNDcFg7Z0JBU3VCOztnQkFDSSxXQURWdVgsS0FSZ0NKO2VBU3ZDLGtCQURBdlksS0FSMkIvTixJQUFNdW1CO2FBRDdCLE9BQWRwWDtXQURjLE9BQVBwRSxLQVlEO2tCQUVINGIsTUFBTTltQixHQUlla0w7V0FIM0IsR0FEWWxMO2dCQUlla0w7ZUFDakI7Z0JBRFl5YixHQUpWM21CO2dCQUlJMEosR0FKSjFKO2dCQUlGRSxHQUpFRjtnQkFLRixXQURNMEosR0FBV3dCO2dCQUNqQjs7aUJBSW9CLElBRGJ1YixXQUNhLFdBTFJFLEdBSUxGO2lCQUNKLGtCQUxIdm1CLFNBQU13SjtlQUNOLElBRUYsYUFBcUIsV0FIUGlkLEdBRUpDO2VBQ0gsb0JBSEwxbUI7YUFETTtXQURBLFFBTzJCO2tCQVVyQzZtQixVQUFVN25CO1c1QjdTdkI7YTRCaVRtQixJQURDbUUsV0FBSFgsV0FBSDdCLFdBQ0ssb0JBSkkzQixFQUdOd0Q7YUFDRSxTQUFKZixFQUNVO2FBQ1QsUUFGREE7ZUFPSSxvQkFYSXpDLEVBR0htRTtlQVFEO3FCQUVVMGhCLFlBQUpOLFlBQXFCLGVBVmhDNWpCLEVBQUc2QixFQVVRK2hCLElBQUlNO2VBREw7YUFSTCxZQUdBLFVBUEk3bEIsRUFHVDJCO2FBSUs7bUJBRVVva0IsY0FBSk47Ozt1Q0FBeUMsdUJBQXJDTSxNQU5admlCLEVBQUdXLEVBTXlEO2FBRHJEO1dBTmIsNEJBQTRCLFFBQUs7a0JBYS9CMmpCLFNBQVNobkIsR0FBR0M7ZUFBSGtZLFFBQUdIO1dBQ2xCO2dCQURlRyxRQUFHSDttQkFHSTJPLEdBSFB4TyxRQUdDek8sR0FIRHlPLFFBR0xqWSxHQUhLaVk7MkJBQUdILEtBSUc7ZUFDTixvQkFGQ3RPLEdBSEVzTztlQUtIO2lCQUNhLElBQVB5TyxZQUFKdG1CLFlBQVcsY0FIbEJELEdBR09DO2lCQUFXO21CQUE4QixvQkFBckNzbUIsTUFOTnRPLEtBR093TyxHQUhKM087aUJBT0Q7O2FBTFksU0FLUDtrQkFFaEJpUCxLQUdIM1gsR0FDd0JwRTtXQUgzQixHQUVHb0U7Z0JBQ3dCcEU7ZUFDakI7Z0JBRFl5YixHQURuQnJYO2dCQUNhNUYsR0FEYjRGO2dCQUNPcFAsR0FEUG9QO2dCQUVPLFdBRE01RixHQUFXd0I7Z0JBQ2pCOztpQkFJa0IsSUFEWHViLFdBQ1csVUFMTkUsR0FJTEY7aUJBQ0YsbUJBTEx2bUI7ZUFDQSxJQUVGLGFBQXFCLFVBSFB5bUIsR0FFSkM7ZUFDTCxpQkFISDFtQixTQUFNd0o7YUFEQyxPQUFkNEY7V0FEYSxRQU93QjtrQkFJbEM0WCxVQUFVbm9CLEVBQUVvTDtlQUFGMEIsTUFBRWlMO1dBQ2xCO2dCQURnQmpMOztnQkFHSHhJLEVBSEd3STtnQkFHTm5KLEVBSE1tSjs7Z0JBQUV1YixPQUdSMWtCLEVBQUdXLEVBSEt5VDtnQkFBRmpMO2dCQUFFaUw7O2FBRVAsT0FGT0EsSUFHNEI7a0JBYTVDbE4sUUFBUTVKLEdBQUdDO1dBQ2tCLG1CQURsQkEsTUFDRCxlQURGRCxNQVhRbUwsUUFBR3lLO1dBQ25CO2dCQURnQnpLO2tCQUFHeUs7aUJBTVQ7a0JBRHNCMlIsS0FMYjNSO2tCQUtTNlEsR0FMVDdRO2tCQUtLOFEsR0FMTDlRO2tCQUtMNFIsS0FMRXJjO2tCQUtOd2IsR0FMTXhiO2tCQUtWekIsR0FMVXlCO2tCQU1OLG9CQURKekIsR0FBa0JnZDtpQkFDZCxTQUFKL2tCO21CQUcrQjttQ0FKVDhrQixHQUFJYztvQkFJYixlQUpUWixHQUFJYTtvQkFMRXJjO29CQUFHeUs7O2lCQVFaLE9BRkRqVTtlQUZNO2FBREMsT0FITWlVLFFBWTRCO2tCQUUvQ3RNLE1BQU10SixHQUFHQyxJQUNYLHFCQURRRCxHQUFHQyxPQUNNO2tCQUVYMG5CLE9BQU8zbkIsR0FBR0M7ZUFBSGtZLFFBQUdIO1dBQ2hCO2dCQURhRztrQkFBR0g7aUJBT0o7a0JBRG9DeU8sR0FOaEN6TztrQkFNMEIwTyxHQU4xQjFPO2tCQU1vQjdYLEdBTnBCNlg7a0JBTU0yTyxHQU5UeE87a0JBTUd6TyxHQU5IeU87a0JBTUhqWSxHQU5HaVk7a0JBT0Qsb0JBREl6TyxHQUEwQmdkO2lCQUM5QixTQUFKL2tCO21CQUVGLGdCQUhJekIsR0FBMEJDO21CQUc5QixhQVRPZ1ksS0FNU3dPLEdBTk4zTyxLQU1nQ3lPO21CQUl2Qzt5QkFIRDlrQjttQkFNRixxQkFQVStILEdBQU1pZCxNQUEwQkY7bUJBTzFDLGFBYk90TyxLQU1Ialk7bUJBRE47aUJBRVEsU0FJTixVQUxJQSxHQUFNd0osUUFBb0J2SjtpQkFLOUIsYUFYT2dZLEtBTVN3TztpQkFPaEI7ZUFSRjthQUZBLFNBVTZEO2tCQUUzRDVrQixLQUFLbkQ7VzVCdlhsQjs7O21CNEJ5WG9CeUUsYUFBSFgsYUFBSDdCO2VBQVksS0FGUmpDLEVBRUppQztlQUFzQixXQUZsQmpDLEVBRUQ4RDsyQkFBR1c7O2FBREY7a0JBR0w2RixLQUFLdEssRUFBRUcsRUFBRThFO2VBQUZnSSxNQUFFOUg7V0FDZjtnQkFEYThIO2VBR2U7Z0JBQWZ4SSxFQUhBd0k7Z0JBR0huSixFQUhHbUo7Z0JBR05oTCxFQUhNZ0w7Z0JBR2Usa0JBSGpCak4sRUFHRDhELEVBQXVCLEtBSHRCOUQsRUFHSmlDLEVBSFFrRDtnQkFBRjhILElBR0F4STtnQkFIRVU7O2FBRUosT0FGSUEsT0FHa0M7a0JBRTNDNmpCLFFBQVEvWTtXNUJoWXJCOzs7ZTRCa1kwQjtnQkFBTnhMO2dCQUFIWDtnQkFBSDdCO2dCQUFZLGdCQUZMZ08sRUFFSm5NO2VBQVM7aUJBQU8saUJBRlptTSxFQUVQaE87aUJBQW1CLHFCQUFid0M7aUJBQWE7OztlQURmOztrQkFHTHdrQixPQUFPaFo7VzVCcFlwQjs7O2U0QnNZMEI7Z0JBQU54TDtnQkFBSFg7Z0JBQUg3QjtnQkFBWSxnQkFGTmdPLEVBRUhuTTtlQUFTOzs7aUJBQU8sZ0JBRmJtTSxFQUVOaE87aUJBQW1CLHVCQUFid0M7aUJBQWE7ZUFEZjs7a0JBR0x1RSxPQUFPaUgsRUFFWDBKO1c1QjFZVCxHNEIwWVNBO2FBRVc7Y0FGQ2xWLEVBQVprVjtjQUFTN1YsRUFBVDZWO2NBQU0xWCxFQUFOMFg7Y0FFVyxXQUpBMUosRUFFTGhPO2NBR0ssY0FMQWdPLEVBRUZuTTtjQUlFLFdBTkFtTSxFQUVDeEw7YUFJRCxHQURMeWtCLE9BSEFqbkIsTUFFQStNLE9BRk12SyxNQUlOMmlCLElBRXFCLE9BTjNCek4sRUFNa0MsWUFKNUIzSyxJQUZHbEwsRUFJSHNqQjthQUdDLGNBTERwWSxJQUVBb1k7V0FMRztrQkFVTCtCLFVBQVVsWjtXNUJuWnZCO2E0QnVaMEI7Y0FGTnhMO2NBQUhYO2NBQUg3QjtjQUVZLGdCQUpIZ08sRUFFVGhPO2NBRVk7O2NBQ04sY0FMR2dPLEVBRU5uTTtjQUlTLGtCQU5IbU0sRUFFSHhMO2NBSU07O2dCQURYeWtCLElBR2dCLGdCQUpYRSxHQUVBRSxJQUVILGVBSkRELEdBRkN2bEIsRUFJRHlsQjthQUZVLFNBS0ssS0FMWEgsR0FGSHRsQixFQUlHd2xCO2FBR0gsaUJBTERELEdBRUFFO1dBTEU7a0JBVUxDO1dBQVc7YUFFZ0IsSUFBdkIva0IsV0FBSHhDLFdBQTBCLGNBQXZCd0M7YUFBTSxpQkFBVHhDO1dBREksUUFDZ0M7a0JBRXJDd25COzs7O2VBRWdDO2dCQUF6QmhsQjtnQkFBSFg7Z0JBQUg3QjtnQkFBK0IsVUFBNUI2QixFQUE0QixvQkFBekJXOzt3QkFBTnhDOzthQURJO2tCQUdUeW5CLFNBQVN2cEIsR0FDWCxzQkFEV0EsRUFDTTtrQkFNWHdwQixLQUFLcnBCO1c1QjdhbEI7OztlNEJnYm1CO2dCQURDbUU7Z0JBQUhYO2dCQUFIN0I7Z0JBQ0ssb0JBSEQzQixFQUVEd0Q7ZUFDRSxTQUFKZixFQUNVLE9BRlJlO2VBQ0UsSUFFSCxhQUZEZixFQURLMEIsRUFBTnhDLFVBQU13Vjs7YUFERjtrQkFlTG1TLFdBVGtCNXBCO1c1QnBiL0I7OzttQjRCZ2NvQm9uQixlQUFIeUMsZUFBSDdhO2VBQ0EsY0FiaUJoUCxFQVlkNnBCO2tDQUFIN2E7Ozt5QkFUTXZLLFdBQUhYLFdBQUg3QjtxQkFDQSxjQUppQmpDLEVBR2Q4RCxtQkFBSDdCOytCQUFNd0M7O21CQURUOzJCQVVTMmlCOzthQURUO2tCQWdCRTBDLGVBVHNCOXBCO1c1QnRjbkM7OzttQjRCa2RvQm9uQixlQUFIeUMsZUFBSDdhO2VBQ0EsY0FicUJoUCxFQVlsQjZwQjtrQ0FBSDdhOzs7eUJBVE12SyxXQUFIWCxXQUFIN0I7cUJBQ0EsY0FKcUJqQyxFQUdsQjhELG1CQUFIN0I7K0JBQU13Qzs7bUJBRFQ7MkJBVVMyaUI7O2FBRFQ7a0JBZ0JFMkMsVUFUaUIvcEI7VzVCeGQ5Qjs7O21CNEJvZW9Cb25CLGVBQUh5QyxlQUFIN2E7ZUFDQSxjQWJnQmhQLEVBWWI2cEI7a0NBQUd6Qzs7O3lCQVRBM2lCLFdBQUhYLFdBQUg3QjtxQkFDQSxjQUpnQmpDLEVBR2I4RCxtQkFBR1c7K0JBQU54Qzs7bUJBREg7MkJBVUcrTTs7YUFESDtrQkFnQkVnYixjQVRxQmhxQjtXNUIxZWxDOzs7bUI0QnNmb0JvbkIsZUFBSHlDLGVBQUg3YTtlQUNBLGNBYm9CaFAsRUFZakI2cEI7a0NBQUd6Qzs7O3lCQVRBM2lCLFdBQUhYLFdBQUg3QjtxQkFDQSxjQUpvQmpDLEVBR2pCOEQsbUJBQUdXOytCQUFOeEM7O21CQURIOzJCQVVHK007O2FBREg7a0JBT0VpYixTQUFTM3BCO1c1QjVmdEI7OztlNEIrZm1CO2dCQURDbUU7Z0JBQUhYO2dCQUFIN0I7Z0JBQ0ssb0JBSEczQixFQUVMd0Q7ZUFDRSxTQUFKZixFQUNVLFVBRlJlO2VBQ0UsSUFFSCxhQUZEZixFQURLMEIsRUFBTnhDLFVBQU13Vjs7YUFERjtrQkFNVHlTLFNBQVNqb0IsRUFBRTZCLEVBQUVXO1c1Qm5nQnRCO1c0QnVnQk8sU0FKV3hDO2FBSWtCLGlCQUpsQkE7YUFJTSwrQkFKSjZCO1dwQmFYOztzQm9CYmFXO2VBS2dCLGlCQUxoQkE7ZUFLRSwwQkFMSlg7MkJBTVIsWUFOTTdCLEVBQUU2QixFQUFFVztXQU9GLGFBUEZ4QyxFQU9FLElBUEE2QixFQUFFVyxHQU9PO2tCQUVoQm1FLElBQUk1SSxFQUVSMlo7VzVCOWdCVCxHNEI4Z0JTQTthQUVVO2NBRkNsVixFQUFYa1Y7Y0FBUTdWLEVBQVI2VjtjQUFLMVgsRUFBTDBYO2NBRVUsUUFKRjNaLEVBRUhpQztjQUdLLGVBTEZqQyxFQUVBOEQ7Y0FJRSxRQU5GOUQsRUFFR3lFO2dCQUFOeEMsTUFFQStNLE9BRkdsTCxNQUdIK2xCLE9BSE1wbEIsTUFJTjJpQixJQUNrQyxPQUx2Q3pOO2FBTU0sZ0JBSkQzSyxJQUNBNmEsSUFDQXpDO1dBTEk7a0JBZUx0ZSxXQUFXOUksRUFFZjJaO1c1QjloQlQsRzRCOGhCU0E7YUFFVTtjQUZDbFYsRUFBWGtWO2NBQVE3VixFQUFSNlY7Y0FBSzFYLEVBQUwwWDtjQUVVLGVBSkszWixFQUVWaUM7Y0FHSyxlQUxLakMsRUFFUDhEO2NBSUUsaUJBTks5RCxFQUVKeUU7YUFJRCxHQURMb2xCO2VBSUMsSUFESU8sSUFITFA7a0JBSEE1bkIsTUFMSmtvQixPQUtPcm1CLE1BTUVzbUIsT0FOQzNsQixNQU5INkgsTUFhb0MsT0FQNUNxTjtlQVFXLGdCQWJWd1EsSUFXU0MsSUFaRjlkO2FBRFYsR0FFRzZkO2VBQ1MsR0FGRjdkO2lCQUUyQix3QkFGM0JBO2lCQUVjLGdCQURyQjZkLElBQ3FCLFFBRmQ3ZDtlQUNNLE9BQWI2ZDthQURhLE9BQU43ZDtXQUtDO2tCQW1DVCtkLFFBQVFwb0I7V0FDVixHQURVQTs7Ozs7Ozs7Ozt1QkFRWTs2Q0FSWkE7d0JBcEJWO2tDQUFZUixFQUFFUTsyQkFDWixVQURVUjs7cUNBRUEsWUFGRVE7O3lDQUdEc29CLElBSEN0b0IsS0FHUHVvQixHQUhPdm9CLG9CQUdQdW9CLFFBQU1EOzs7a0NBSEN0b0I7Ozt1Q0FJS3dvQixZQUFOM1osV0FBTjRaLEtBSk96b0I7cURBSVB5b0IsVUFBTTVaLFFBQU0yWjs7O2tDQUpMeG9COzs7Ozt5Q0FNVzBvQixZQUFOOVosV0FBTkssYUFBTjBaLEtBTk8zb0I7dURBTVAyb0IsVUFBTTFaLFVBQU1MLFdBQU04WjsyQkFJckIsT0FWUWxwQixVQVdNLFVBRFZvcEIsR0FWTTVvQixHQVdJOzhCQUFKK007NkJBSU87OEJBRFJFLElBSENGOzhCQUdSOGIsSUFIUTliOzhCQUlPLGFBZlR2TixJQVVKb3BCLGdCQUlLM2I7OEJBQ1E7OzZCQUNmLGlCQUxFaUQsS0FHRjJZLElBQ0kxWSxPQUFPMlk7MkJBRkwsNEJBR2tCO3VCQUUxQixXQUFLLE9BbkJRL2I7eUJBNEJFZ2M7cUJBQWMsV0FBZEEsR0FBYyxTQUFRLFNBQVEsU0FBUTttQkFENUIseUJBQVEsU0FBUTtpQkFEcEIseUJBQVE7ZUFEWjthQURYO1dBREYsT0FqVk4zaUIsS0F1VmtEO2tCQUVsRDRpQixRQUFRbnZCLEVBQUU4aUI7V0FDWiwwQkFBbUJ6ZSxFQUFFRyxHQUFLLFdBQUxBLEVBQUZILEVBQWMsRUFEckJ5ZSxFQUFGOWlCLEVBQzRCO2tCQUVwQ292QixPQUFPcHZCLEdBQUksZUFBSkEsRUE1VlB1TSxNQTRWMEI7a0JBRXRCOGlCLFlBQWFwb0I7V0FBTyxHQUFQQTthQUU4QixJQUFuQy9HLEtBRksrRyxLQUVSNFcsRUFGUTVXLEtBRVh6QyxFQUZXeUMsS0FFOEIsZUFBdEM0VyxFQUFHM2Q7YUFBc0IsVUFBNUJzRSxpQjVCamxCZixPNEIra0JhNnFCO1dBQ0csUUFDMkQ7a0JBRWxFL2YsT0FBT3JJO1dBQWlCLG1CQUFqQkE7V0FBaUIsc0I1Qm5sQmpDLE80QitrQmFvb0IsdUJBSXFDO2tCQUV6Q0MsWUFBWUMsSUFBSWxyQjtlQUNGOE0sSUFERTlNLEVBQ0E0QztXQUFJO2dCQUFOa0s7ZUFHRSxJQURMeEksRUFGR3dJLE9BRUFuSixFQUZBbUosT0FFTmhMLEVBRk1nTCxPQUdFLG9CQURGbkosRUFIRnVuQjtlQUlJLFNBRVI1cEI7aUJBQU8sUUFBUEEsR0FDSyxXQUpDcUMsRUFBSFcsRUFGSzFCLEdBQUZrSyxJQUVOaEwsRUFGUWM7cUJBQUZrSyxJQUVIeEk7O2VBQ0ssWUFERlgsRUFBSFcsRUFGSzFCOzs7bUM1QnRsQnpCLE80QitrQmFvb0Isd0JBZ0JzQjs7aUJBOVcxQjlpQjtpQkFFQW9mO2lCQUVJQztpQkFuSEFqQjtpQkFZSkM7aUJBNkdJaUI7aUJBZUFDO2lCQWdCQU07aUJBa0NBRTtpQkFTQUM7aUJBNkJKcmQ7aUJBR0FOO2lCQUdJcWU7aUJBZUE1bEI7aUJBcUpBeUY7aUJBakpBMEI7aUJBS0EwZTtpQkFJQUM7aUJBSUFqZ0I7aUJBb0pBRjtpQkF6SUFxZ0I7aUJBV0FLO2lCQVFKRTtpQkF2UEkzQztpQkFLQUM7aUJBS0FDO2lCQUtBQztpQkFmQUg7aUJBS0FDO2lCQWdEQU07aUJBeU1BcUM7aUJBK0VBTTtpQkEvREFMO2lCQWtCQUU7aUJBa0JBQztpQkFrQkFDO2lCQTZFSks7aUJBcUJBZTtpQkFGQWhnQjtpQkFUQTZmO2lCQUdBQztJQXRnQkc7SURrQkc7Ozs7a0JFYk4xRixjQUFTLGNBRUh6SixvQkFERyxRQUNJO2tCQUViekYsT0FBT3JVLEVBQUUzQixFQUFFMlksRUFBRXhVO1dBQ04sY0FEQXhDLEdBQ2tCLFVBRFp3QyxHQUNZLEtBQUxraEIsTUFBbEJGLGNBQWtCRTtxQkFEYjFqQixFQUFFM0IsRUFBRTJZLEVBQUV4VSxPQUU0QztrQkFFekRpaUIsVUFBVXBtQixFQUFFMlksR0FBSSxZQUFOM1ksRUFBRTJZLE1BQXVDO2tCQUVuRDJNLElBQUkzakIsRUFBRTNCLEVBQUUyWSxFQUFFeFU7V0FDWixHQURNeEMsTUFDbUM4WixFQURuQzlaLEtBQ0Z3akIsR0FBcUMxSixXQUFyQzBKO1dBQ0osR0FGWWhoQixNQUU2QmloQixJQUY3QmpoQixLQUVSa2hCLEdBQXFDRCxhQUFyQ0M7V0FDSixJQURJQSxjQURBRjthQUVnQixHQUhkeGpCO2VBT2dCLElBRE80akIsR0FOdkI1akIsS0FNaUJxcEIsR0FOakJycEIsS0FNVzZqQixHQU5YN2pCLEtBTUs4akIsR0FOTDlqQixLQU9nQixZQURPNGpCO2VBQ3BCLGtCQURFRSxJQUVhLGNBRmJBLEdBQU1ELEdBQU13RixHQUVDLE9BRkt6RixHQU5yQnZsQixFQUFFMlksRUFBRXhVO2VBU0QsR0FIa0JvaEI7aUJBT29CO2tCQURYRyxJQU5USDtrQkFNRTBGLElBTkYxRjtrQkFNTEksSUFOS0o7a0JBTVpLLElBTllMO2tCQU9vQixZQURYRyxJQVo5QjFsQixFQUFFMlksRUFBRXhVO2lCQWFPLHFCQVBSc2hCLEdBQU1ELEdBQU13RixHQU1OcEYsS0FBT0QsSUFBT3NGO2VBRFo7YUFOTjtXQVVKLElBZEw5RixjQUNBRTthQWF5QixHQWZqQmxoQjtlQW1CVSxJQURPMGhCLEdBbEJqQjFoQixLQWtCVyttQixHQWxCWC9tQixLQWtCSzJoQixHQWxCTDNoQixLQWtCRDRoQixHQWxCQzVoQixLQW1CVSxZQURYNGhCO2VBQ0Ysa0JBRG9CRixJQUVkLHFCQXBCVGxrQixFQUFFM0IsRUFBRTJZLEVBa0JDb04sSUFBTUQsR0FBTW9GLEdBQU1yRjtlQUdsQixHQUhBRTtpQkFPbUM7a0JBRFJDLElBTjNCRDtrQkFNb0JvRixJQU5wQnBGO2tCQU1hRSxJQU5iRjtrQkFNTUcsSUFOTkg7a0JBT21DLFlBRFJDLElBTnJCRixHQUFNb0YsR0FBTXJGO2lCQU9WLHFCQXpCYmxrQixFQUFFM0IsRUFBRTJZLEVBd0JPdU4sS0FBT0QsSUFBT2tGO2VBRFo7YUFOTjtXQVdYLFNBMUJFOUYsTUFEQUYsY0FDQUU7cUJBRkUxakIsRUFBRTNCLEVBQUUyWSxFQUFFeFUsT0E0QmlEO2FBRTNENEQ7a0JBRUFvZixnQkFBVyxnQkFBbUM7a0JBRTFDaEIsSUFBSW5tQixFQUFFb3JCLEtBR1Y5TTtXN0IzSFQsRzZCMkhTQTthQUNVLElBRFE3QyxFQUFsQjZDLEtBQWVuYSxFQUFmbWEsS0FBWTNGLEVBQVoyRixLQUFTOWEsRUFBVDhhLEtBQU0zYyxFQUFOMmMsS0FDVSxvQkFKRnRlLEVBR0N3RDthQUNDLFNBQUpmLEVBRUYsT0FIUWtXLE1BSEZ5UyxLQUdWOU0sS0FBTTNjLEVBSEUzQixFQUFFb3JCLEtBR0tqbkIsRUFBR3NYO2FBSVgsUUFIRGhaLEdBT08sSUFBTG9qQixHQUFLLElBWEw3bEIsRUFBRW9yQixLQUdLam5CLEdBUUYsT0FSRUEsTUFRUDBoQixHQVJSdkgsRUFTMkIsSUFUckIzYyxFQUFHNkIsRUFBR21WLEVBUUprTjthQVBFLElBSUZKLEdBQUssSUFSTHpsQixFQUFFb3JCLEtBR0p6cEI7YUFLTyxPQUxQQSxNQUtFOGpCLEdBTFJuSCxFQU0yQixJQURuQm1ILEdBTENqaUIsRUFBR21WLEVBQUd4VTtXQURiLFlBRk1uRSxFQUFFb3JCO2tCQWNOL0IsS0FBS3JwQjtXN0J0SWxCOzs7ZTZCMEltQjtnQkFES21FO2dCQUFId1U7Z0JBQUhuVjtnQkFBSDdCO2dCQUNJLG9CQUpEM0IsRUFHQXdEO2VBQ0MsU0FBSmYsRUFDVSxPQUZKa1c7ZUFDRixJQUVILGFBRkRsVyxFQURTMEIsRUFBVHhDLFVBQVN3Vjs7YUFEYjtrQkFlRW1TLFdBVHFCNXBCO1c3QjlJbEM7Ozs7Z0I2QjBKd0JvbkI7Z0JBQUhqTztnQkFBSDBRO2dCQUFIN2E7ZUFDRCxjQWJvQmhQLEVBWWhCNnBCOytCQUFHMVEsVUFBTm5LOzs7eUJBVFN2SyxXQUFId1UsV0FBSG5WLFdBQUg3QjtxQkFDRCxjQUpvQmpDLEVBR2hCOEQsZ0JBQUdtVixRQUFOaFg7K0JBQVN3Qzs7bUJBRGI7MkJBVWEyaUI7O2FBRGI7a0JBZ0JFMEMsZUFUeUI5cEI7VzdCaEt0Qzs7OztnQjZCNEt3Qm9uQjtnQkFBSGpPO2dCQUFIMFE7Z0JBQUg3YTtlQUNELGNBYndCaFAsRUFZcEI2cEI7K0JBQUcxUSxVQUFObks7Ozt5QkFUU3ZLLFdBQUh3VSxXQUFIblYsV0FBSDdCO3FCQUNELGNBSndCakMsRUFHcEI4RCxnQkFBR21WLFFBQU5oWDsrQkFBU3dDOzttQkFEYjsyQkFVYTJpQjs7YUFEYjtrQkFnQkUyQyxVQVRvQi9wQjtXN0JsTGpDOzs7O2dCNkI4THdCb25CO2dCQUFIak87Z0JBQUgwUTtnQkFBSDdhO2VBQ0QsY0FibUJoUCxFQVlmNnBCOytCQUFHMVEsVUFBR2lPOzs7eUJBVEEzaUIsV0FBSHdVLFdBQUhuVixXQUFIN0I7cUJBQ0QsY0FKbUJqQyxFQUdmOEQsZ0JBQUdtVixRQUFHeFU7K0JBQVR4Qzs7bUJBREo7MkJBVUkrTTs7YUFESjtrQkFnQkVnYixjQVR3QmhxQjtXN0JwTXJDOzs7O2dCNkJnTndCb25CO2dCQUFIak87Z0JBQUgwUTtnQkFBSDdhO2VBQ0QsY0FidUJoUCxFQVluQjZwQjsrQkFBRzFRLFVBQUdpTzs7O3lCQVRBM2lCLFdBQUh3VSxXQUFIblYsV0FBSDdCO3FCQUNELGNBSnVCakMsRUFHbkI4RCxnQkFBR21WLFFBQUd4VTsrQkFBVHhDOzttQkFESjsyQkFVSStNOzthQURKO2tCQU9FaWIsU0FBUzNwQjtXN0J0TnRCOzs7ZTZCME5tQjtnQkFES21FO2dCQUFId1U7Z0JBQUhuVjtnQkFBSDdCO2dCQUNJLG9CQUpHM0IsRUFHSndEO2VBQ0MsU0FBSmYsRUFDVSxVQUZKa1c7ZUFDRixJQUVILGFBRkRsVyxFQURTMEIsRUFBVHhDLFVBQVN3Vjs7YUFEYjtrQkFNRWlRLElBQUlwbkI7VzdCOU5qQjs7O2U2QmtPbUI7Z0JBREVtRTtnQkFBSFg7Z0JBQUg3QjtnQkFDSSxvQkFKRjNCLEVBR0N3RDtnQkFDQyxXQUFKZjtlQUFJLFFBRlI7ZUFFUSxJQURFMFUsYUFDTjFVLEVBRE0wQixFQUFOeEMsVUFBTXdWOzthQURWO2tCQUtFa1U7VzdCck9iO1c2QnFPMkI7Ozs7bUJBRUExUyxhQUFIblY7MkJBQUdtVjthQURULGdCQUVnQjtrQkFFckIyUztXN0IxT2I7VzZCME8rQjs7OzttQkFFSjNTLGFBQUhuVjs4QkFBR21WO2FBRFQsU0FFbUI7a0JBRXhCNFM7VzdCL09iO1c2QitPMkI7OzhCQUdOLCtCQUFOcFU7bUJBREd3QixhQUFIblY7MkJBQUdtVjthQURBLGdCQUVnQjtrQkFFckI2UztXN0JwUGI7VzZCb1ArQjs7OEJBR1YsK0JBQU5yVTttQkFER3dCLGFBQUhuVjs4QkFBR21WO2FBREEsU0FFb0I7a0JBRXpCOFM7V0FBcUI7OzttQkFHVnRuQixXQUFId1UsV0FBSG5WO2VBQWdCLG9DQUFoQkEsRUFBR21WLEVBQUd4VTthQURNLElBQU4yaUI7YUFBTSxPQUFOQTtXQUROLDBDQUU0Qzt1QkFLcER6TixFQURPck47V0FEVixHQUVHcU47YUFFQyxHQUhNck47ZUFHTyx3QkFIUEEsT0FHTztlQUNGLFdBSFpxTixFQUVNclosRUFBRzJZLEVBQ0csbUJBSkwzTTthQUNNLE9BQWJxTjtXQURhLE9BQU5yTixLQUk0QjtrQkFFaENxYixPQUFPcm5CLEVBR1hzZTtXN0J6UVQsRzZCeVFTQTthQUNVLElBRE1uYSxFQUFoQm1hLEtBQWEzRixFQUFiMkYsS0FBVTlhLEVBQVY4YSxLQUFPM2MsRUFBUDJjLEtBQ1Usb0JBSkN0ZSxFQUdEd0Q7YUFDQSxTQUFKZixFQUNVLFlBRlRkLEVBQVN3QzthQUdULFFBRkQxQixHQUtPLElBQUxvakIsR0FBSyxPQVRGN2xCLEVBR0ttRSxHQU1ILE9BTkdBLE1BTVIwaEIsR0FOUnZILEVBTWtELElBTjNDM2MsRUFBRzZCLEVBQUdtVixFQU1Ma047YUFMRSxJQUdGSixHQUFLLE9BUEZ6bEIsRUFHSjJCO2FBSU0sT0FKTkEsTUFJQzhqQixHQUpSbkgsRUFJa0QsSUFBMUNtSCxHQUpFamlCLEVBQUdtVixFQUFHeFU7V0FEZDtrQkFTRXVuQixPQUFPMXJCLEVBQUVOLEVBTWI0ZTtXN0J2UlQsRzZCdVJTQTthQUNVLElBRFE3QyxFQUFsQjZDLEtBQWVuYSxFQUFmbWEsS0FBWTNGLEVBQVoyRixLQUFTOWEsRUFBVDhhLEtBQU0zYyxFQUFOMmMsS0FDVSxvQkFQQ3RlLEVBTUZ3RDthQUNDLFNBQUpmO2VBRUkscUJBVEcvQyxLQU1EaVo7ZUFHRjtpQkFHRixJQURHeVMsY0FDSCxPQU5JelMsTUFLRHlTLEtBTFg5TSxLQUFNM2MsRUFOSzNCLEVBV0FvckIsS0FMSWpuQixFQUFHc1g7ZUFJSixZQUpSOVosRUFBU3dDO2FBT0osUUFOTDFCLEdBVU8sSUFBTG9qQixHQUFLLE9BakJGN2xCLEVBQUVOLEVBTUV5RSxHQVdGLE9BWEVBLE1BV1AwaEIsR0FYUnZILEVBWTJCLElBWnJCM2MsRUFBRzZCLEVBQUdtVixFQVdKa047YUFWRSxJQU9GSixHQUFLLE9BZEZ6bEIsRUFBRU4sRUFNUGlDO2FBUU8sT0FSUEEsTUFRRThqQixHQVJSbkgsRUFTMkIsSUFEbkJtSCxHQVJDamlCLEVBQUdtVixFQUFHeFU7V0FKRCx1QkFGRHpFO1dBRUMsWUFFRyxJQUFSaXNCLGtCQUFRLFlBSk4zckIsRUFJRjJyQjtXQURHO2tCQWlCUjlvQixLQUFLbkQ7VzdCclNsQjs7O21CNkJ1U3dCeUUsYUFBSHdVLGFBQUhuVixhQUFIN0I7ZUFDSixLQUhPakMsRUFFSGlDO2VBQ00sV0FISGpDLEVBRUE4RCxFQUFHbVY7MkJBQUd4VTs7YUFETjtrQkFJTG1FLElBQUk1STtXN0IxU2pCO2E2QjhTb0I7Y0FETytiO2NBQUh0WDtjQUFId1U7Y0FBSG5WO2NBQUg3QjtjQUNLLFFBSkhqQyxFQUdGaUM7Y0FFSyxlQUxIakMsRUFHSWlaO2NBR0QsUUFOSGpaLEVBR095RTthQUdKLFVBRkx1SyxJQURHbEwsRUFFSHFWLElBQ0FpTyxJQUhZckw7V0FEaEI7a0JBT0VtUSxLQUFLbHNCO1c3Qm5UbEI7YTZCdVRvQjtjQURPK2I7Y0FBSHRYO2NBQUh3VTtjQUFIblY7Y0FBSDdCO2NBQ0ssU0FKRmpDLEVBR0hpQztjQUVLLGVBTEZqQyxFQUdBOEQsRUFBR21WO2NBR0QsU0FORmpaLEVBR015RTthQUdKLFVBRkx1SyxJQURHbEwsRUFFSHFWLElBQ0FpTyxJQUhZckw7V0FEaEI7a0JBT0V6UixLQUFLdEssRUFBRTRlLEVBQUUzWjtlQUFGa25CLE1BQUVobkI7V0FDZjtnQkFEYWduQjtlQUlBO2dCQURJMW5CLEVBSEowbkI7Z0JBR0NsVCxFQUhEa1Q7Z0JBR0Zyb0IsRUFIRXFvQjtnQkFHTGxxQixFQUhLa3FCO2dCQUlBLGtCQUpGbnNCLEVBR0E4RCxFQUFHbVYsRUFDTSxLQUpUalosRUFHSGlDLEVBSE9rRDtnQkFBRmduQixJQUdJMW5CO2dCQUhGVTs7YUFFSixPQUZJQSxPQUlxQjtrQkFFOUI2akIsUUFBUS9ZO1c3QmxVckI7OztlNkJvVThCO2dCQUFOeEw7Z0JBQUh3VTtnQkFBSG5WO2dCQUFIN0I7Z0JBQWUsZ0JBRlRnTyxFQUVIbk0sRUFBR21WO2VBQVM7aUJBQVMsaUJBRmxCaEosRUFFTmhPO2lCQUF3QixxQkFBZndDO2lCQUFlOzs7ZUFEckI7O2tCQUdMd2tCLE9BQU9oWjtXN0J0VXBCOzs7ZTZCd1U4QjtnQkFBTnhMO2dCQUFId1U7Z0JBQUhuVjtnQkFBSDdCO2dCQUFlLGdCQUZWZ08sRUFFRm5NLEVBQUdtVjtlQUFTOzs7aUJBQVMsZ0JBRm5CaEosRUFFTGhPO2lCQUF3Qix1QkFBZndDO2lCQUFlO2VBRHJCOztrQkFXTDJuQixnQkFBZ0JDLEVBQUUvckI7VzdCbFYvQjtpQjZCb1Z3Qm1FLFdBQUh3VSxXQUFIblYsV0FBSDdCO2FBQ0YsMkJBSGdCb3FCLEVBQUUvckIsRUFFaEIyQixHQUFHNkIsRUFBR21WLEVBQUd4VTtXQUROLGlCQURXNG5CLEVBQUUvckI7a0JBS2xCZ3NCLGdCQUFnQkQsRUFBRS9yQjtXN0J2Vi9CO2lCNkJ5VndCbUUsV0FBSHdVLFdBQUhuVixXQUFIN0I7YUFDSSxXQURKQSxFQUFHNkIsRUFBR21WLEVBQ0YsZ0JBSFVvVCxFQUFFL3JCLEVBRVBtRTtXQUROLGlCQURXNG5CLEVBQUUvckI7a0JBUWxCOEosS0FBS25JLEVBQUU2QixFQUFFbVYsRUFBRXhVO1dBQ2pCLEdBRFd4QztnQkFBTXdDOztnQkFLaUJvaUIsR0FMakJwaUI7Z0JBS1cwaEIsR0FMWDFoQjtnQkFLSyttQixHQUxML21CO2dCQUtEMmhCLEdBTEMzaEI7Z0JBS1A0aEIsR0FMTzVoQjtnQkFJaUJxaUIsR0FKdkI3a0I7Z0JBSWlCNGpCLEdBSmpCNWpCO2dCQUlXcXBCLEdBSlhycEI7Z0JBSUs2akIsR0FKTDdqQjtnQkFJRDhqQixHQUpDOWpCO3VCQUt1QjRrQixjQURBQzt3QkFFRyxJQUYzQmYsR0FBTUQsR0FBTXdGLEdBRWUsS0FGVHpGLEdBSmYvaEIsRUFBRW1WLEVBQUV4VTt5QkFJaUJxaUIsY0FDQUQ7MEJBRU4sU0FQakI1a0IsRUFBRTZCLEVBQUVtVixFQUtMb04sSUFBTUQsR0FBTW9GLEdBQU1yRjswQkFHeEIsT0FST2xrQixFQUFFNkIsRUFBRW1WLEVBQUV4VTthQUdELHVCQUhIWCxFQUFFbVYsRUFBSmhYO1dBRUssdUJBRkg2QixFQUFFbVYsRUFBRXhVLEVBUUM7a0JBTWhCNGlCLE9BR0MxTixFQURPck47V0FEVixHQUVHcU47YUFFQyxHQUhNck47ZUFHTyx3QkFIUEEsT0FHTztlQUNELFlBSGJxTixFQUVNclosRUFBRzJZLEVBQ0ksbUJBSk4zTTthQUNNLE9BQWJxTjtXQURhLE9BQU5yTixLQUk2QjtrQkFFckNpZ0IsZUFBZTdiLEdBQUc1TSxFQUFFbVYsRUFBRXpJO1dBQ3hCLEdBRHNCeUksR0FFVixJQUFMRSxJQUZlRixLQUVWLFlBRkt2SSxHQUFHNU0sRUFFYnFWLElBRmlCM0ksSUFHZCxjQUhPRSxHQUFPRixHQUdGO2tCQUVoQjhXLE1BQU1obkI7VzdCMVhuQjthNkI4WG1CO2NBREttRTtjQUFId1U7Y0FBSG5WO2NBQUg3QjtjQUNJLG9CQUpBM0IsRUFHRHdEO2FBQ0MsU0FBSmYsRUFDVSxVQUZWZCxLQUFNZ1gsR0FBR3hVO2FBR1IsUUFGRDFCO2VBS21CLGdCQVRmekMsRUFHS21FLEdBTVU7ZUFBYyxlQU5qQ3hDLEVBQUc2QixFQUFHbVYsRUFNSDRNLElBQUkwQixLQUFNcEI7YUFMVDtjQUdlLGNBUGY3bEIsRUFHSjJCO2NBSW1COzs7YUFBd0IsVUFBeEM4akIsR0FBSXlCLE9BQW9DLEtBQTlCbkIsR0FKVnZpQixFQUFHbVYsRUFBR3hVO1dBRGI7a0JBU0UyVCxNQUFNcFksRUFBRW9CLEdBQUdDO1dBQ2pCLEdBRGNEO2lCQUdxQnVQLEdBSHJCdlAsTUFHZTJtQixHQUhmM21CLE1BR1NvckIsR0FIVHByQixNQUdHMEosR0FISDFKLE1BR0hFLEdBSEdGO2FBR3dDLFVBSHJDQyxPQUdrQnNQO2VBQ1o7NEJBRE43RixHQUhBeko7Z0JBSU07OztnQkFDbUMsV0FMOUNyQixFQUdpQituQixHQUNaRjtnQkFDcUIsZ0JBTDFCN25CLEVBR0s4SyxNQUFNMGhCLElBQ1ZDO2VBQ00sNEJBTFB6c0IsRUFHRHNCLEdBQ0ZDLElBRFF1Sjs7WUFERyxLQUZIekosR0FFRztjQUZIQTthQU9NO2NBRFMybUIsS0FOZjNtQjtjQU1TcXJCLEtBTlRyckI7Y0FNR3ltQixHQU5Iem1CO2NBTUhrTyxLQU5HbE87Y0FPTSxjQURIeW1CLEdBTk4xbUI7Y0FPUzs7O2NBQ21DLFdBUjlDcEIsRUFPS2lvQixLQURlRDtjQUVNLGdCQVIxQmhvQixFQU1ROG5CLEdBQ1A2RSxRQURhRDthQUVQLDRCQVJQMXNCLEVBT0hzUCxLQURLQyxNQUFNdVk7V0FJaEIsNEJBQVk7a0JBRVZGLE1BQU01bkIsRUFBRW9CLEdBQUdDO1dBQ2pCLEdBRGNEO2dCQUFHQzs7Z0JBSWtCb1AsR0FKbEJwUDtnQkFJWXdtQixHQUpaeG1CO2dCQUlNb3JCLEdBSk5wckI7Z0JBSUF5bUIsR0FKQXptQjtnQkFJTkUsR0FKTUY7Z0JBR2tCc1AsR0FIckJ2UDtnQkFHZTJtQixHQUhmM21CO2dCQUdTb3JCLEdBSFRwckI7Z0JBR0cwSixHQUhIMUo7Z0JBR0hFLEdBSEdGO2tCQUlxQnFQLE1BREFFO2lCQUdWOzhCQUhSN0YsR0FIQXpKO2tCQU1ROzs7a0JBQ1gsUUFQRnJCLEVBR0RzQixHQUdBaU87a0JBQ3lCLFFBUHhCdlAsRUFHaUIrbkIsR0FHVkM7aUJBQ2lCLEdBRHJCMEU7bUJBSUksSUFBTkUsS0FKRUY7bUJBSXdCLHNCQUg3QnpxQixFQUpPNkksR0FPc0IsV0FWM0I5SyxFQUdLOEssR0FBTTBoQixHQU9WSSxNQUhtQm5vQjtpQkFFaEIsWUFGTnhDLEVBSk82SSxHQUFNMGhCLEdBSVMvbkI7ZUFLUDs4QkFSUnFqQixHQUpIMW1CO2dCQVlXOzs7Z0JBQ1gsVUFiRnBCLEVBWURzUCxLQVJBL047Z0JBU3lCLFVBYnhCdkIsRUFZT2lvQixLQVJVSjtlQVNPLEdBRHJCOEU7aUJBSUksSUFBTkUsS0FKRUY7aUJBSXdCLHNCQUg3QjNkLElBVE84WSxHQVlzQixXQWhCM0I5bkIsRUFJSzhuQixHQVlKK0UsS0FaVUosSUFTU3JGO2VBRWhCLFlBRk5wWSxJQVRPOFksR0FBTTJFLEdBU1NyRjtpQkFYdEJqbkIsRUFGSWlCOztnQkFFSmpCLEVBRk9rQjtXQUVZLE9BQW5CbEIsQ0FjMkM7a0JBRS9DNkksT0FBT2lILEVBRVgyTztXN0JyYVQsRzZCcWFTQTthQUVXO2NBRkluYSxFQUFmbWE7Y0FBWTNGLEVBQVoyRjtjQUFTOWEsRUFBVDhhO2NBQU0zYyxFQUFOMmM7Y0FFVyxXQUpBM08sRUFFTGhPO2NBR00sZUFMRGdPLEVBRUZuTSxFQUFHbVY7Y0FJRCxXQU5BaEosRUFFSXhMO2FBSUosR0FETHFvQjtrQkFIQTdxQixNQUVBK00sT0FGU3ZLLE1BSVQyaUIsSUFDK0IsT0FMckN4SSxFQUs0QyxZQUh0QzVQLElBRkdsTCxFQUFHbVYsRUFJTm1PO2FBRUMsY0FKRHBZLElBRUFvWTtXQUxHO2tCQVNMdGUsV0FBVzlJO1c3QjdheEI7YTZCaWJvQjtjQUZJeUU7Y0FBSHdVO2NBQUhuVjtjQUFIN0I7Y0FFSyxlQUpJakMsRUFFVGlDO2NBR00sZUFMR2pDLEVBRU44RCxFQUFHbVY7Y0FJRCxlQU5JalosRUFFQXlFO2FBSUosR0FETHNvQixLQUdXLElBQU41VCxJQUhMNFQsT0FHVyxZQUpYL2QsSUFGR2xMLEVBTUVxVixJQUZMaU87YUFHUSxjQUxScFksSUFFQW9ZO1dBTEc7a0JBV0wrQixVQUFVbFo7VzdCemJ2QjthNkI2YjBCO2NBRkZ4TDtjQUFId1U7Y0FBSG5WO2NBQUg3QjtjQUVXLGdCQUpIZ08sRUFFUmhPO2NBRVc7O2NBQ0wsZUFMRWdPLEVBRUxuTSxFQUFHbVY7Y0FJSyxrQkFOSGhKLEVBRUN4TDtjQUlFOztnQkFEWHFvQixLQUdrQixnQkFKYjFELEdBRUFFLElBRUgsZUFKREQsR0FGRXZsQixFQUFHbVYsRUFJTHNRO2FBRlUsU0FLSyxLQUxYSCxHQUZGdGxCLEVBQUdtVixFQUlEcVE7YUFHSCxpQkFMREQsR0FFQUU7V0FMRTtrQkFZTGpCLFVBQVUxSixFQUFFclQ7ZUFBRjRnQixNQUFFalU7V0FDbEI7Z0JBRGdCaVU7O2dCQUdDMW5CLEVBSEQwbkI7Z0JBR0ZsVCxFQUhFa1Q7Z0JBR0xyb0IsRUFIS3FvQjs7Z0JBQUUzRCxPQUdQMWtCLEVBQUdtVixFQUFHeFUsRUFIQ3lUO2dCQUFGaVU7Z0JBQUVqVTs7YUFFUCxPQUZPQSxJQUdtQztrQkFFbkRsTixRQUFRQyxJQUFJZ2lCLEdBQUdDO1dBWWlCLG1CQVpqQkEsTUFZRixlQVpERCxNQUNNMWdCLFFBQUd5SztXQUNuQjtnQkFEZ0J6SztrQkFBR3lLO2lCQU1UO2tCQUQ4QjJSLEtBTHJCM1I7a0JBS2lCNlEsR0FMakI3UTtrQkFLYXlWLEdBTGJ6VjtrQkFLUzhRLEdBTFQ5UTtrQkFLRDRSLEtBTEZyYztrQkFLRndiLEdBTEV4YjtrQkFLTmlnQixHQUxNamdCO2tCQUtWekIsR0FMVXlCO2tCQU1OLG9CQURKekIsR0FBc0JnZDtpQkFDbEIsU0FBSi9rQjttQkFFSSxJQUFKd08sSUFBSSxXQVRKdEcsSUFNSXVoQixHQUFzQkM7bUJBR3RCLFNBQUpsYjtxQkFFMEI7cUNBTElzVyxHQUFJYztzQkFLMUIsZUFMQVosR0FBSWE7c0JBTEZyYztzQkFBR3lLOzttQkFTRixPQURYekY7aUJBRFcsT0FEWHhPO2VBRk07YUFEQyxPQUhNaVUsUUFXNkI7a0JBRWxEdE0sTUFBTU8sSUFBSWdpQixHQUFHQztXQVNpQixtQkFUakJBLE1BU0YsZUFUREQsTUFDTTFnQixRQUFHeUs7V0FDakI7Z0JBRGN6SztrQkFBR3lLO2lCQU1mO2tCQURzQzJSLEtBTHZCM1I7a0JBS21CNlEsR0FMbkI3UTtrQkFLZXlWLEdBTGZ6VjtrQkFLVzhRLEdBTFg5UTtrQkFLQzRSLEtBTEpyYztrQkFLQXdiLEdBTEF4YjtrQkFLSmlnQixHQUxJamdCO2tCQUtSekIsR0FMUXlCO2tCQU1aLDZCQURJekIsR0FBc0JnZDtpQkFDMUI7bUJBQXlCLG9CQVB2QjdjLElBTU11aEIsR0FBc0JDO21CQUNMO3FCQUNHO3FDQUZNNUUsR0FBSWM7c0JBRTVCLGVBRkVaLEdBQUlhO3NCQUxKcmM7c0JBQUd5Szs7bUJBTVU7OztpQkFGZjs7YUFEQyxPQUhJQSxPQVE2QjtrQkFFNUN3UztXQUFXO2FBRWlCLElBQXZCL2tCLFdBQUh4QyxXQUEwQixjQUF2QndDO2FBQU0saUJBQVR4QztXQURHLFFBQ2lDO2tCQUV0Q2tyQjs7OztlQUV5QztnQkFBOUIxb0I7Z0JBQUh3VTtnQkFBSG5WO2dCQUFIN0I7Z0JBQXVDLGFBQXBDNkIsRUFBR21WLEdBQWlDLG9CQUE5QnhVOzt3QkFBVHhDOzthQURHO2tCQUdUbXJCLFNBQVNqdEIsR0FDWCxzQkFEV0EsRUFDTTtrQkFNZjhxQixRQUFRbnZCLEVBQUU4aUI7V0FDWjs2QkFBbUJBO3NCQUFMLHFDQUFReU4sRUFBRXZvQixFQUFMOGEsRUFBcUI7b0JBRDVCQTtvQkFBRjlpQixFQUNrQztrQkFFMUNvdkIsT0FBT3B2QixHQUFJLGVBQUpBLEVBbFlQdU0sTUFrWTBCO2tCQUV0QjhpQixZQUFhcG9CO1dBQU8sR0FBUEE7YUFFa0MsSUFBdkMvRyxLQUZLK0csS0FFUDRXLEVBRk81VyxLQUVUZSxFQUZTZixLQUVYc3BCLEVBRld0cEIsS0FFa0MsZUFBekM0VyxFQUFFM2Q7YUFBMEIsYUFBaENxd0IsRUFBRXZvQixrQjdCMWZqQixPNkJ3ZmFxbkI7V0FDRyxRQUMrRDtrQkFFdEUvZixPQUFPd1Q7V0FDSSxtQkFESkE7V0FDSSxzQjdCN2ZwQixPNkJ3ZmF1TSx1QkFLd0I7a0JBRTVCQyxZQUFZQyxJQUFJek07ZUFDRnVOLElBREV2TixFQUNBN2I7V0FBSTtnQkFBTm9wQjtlQUdFO2dCQURDMW5CLEVBRkgwbkI7Z0JBRUFsVCxFQUZBa1Q7Z0JBRUhyb0IsRUFGR3FvQjtnQkFFTmxxQixFQUZNa3FCO2dCQUdFLG9CQURMcm9CLEVBSEN1bkI7ZUFJSSxTQUVSNXBCO2lCQUFPLFFBQVBBLEdBQ0ssV0FKRnFDLEVBQUdtVixFQUFHeFUsRUFGRDFCLEdBQUZvcEIsSUFFTmxxQixFQUZRYztxQkFBRm9wQixJQUVHMW5COztlQUNELFlBRExYLEVBQUdtVixFQUFHeFUsRUFGRDFCOzs7bUM3QmhnQnpCLE82QndmYW9vQix3QkFpQnNCOztpQkFyWjFCOWlCO2lCQUVBb2Y7aUJBd0dJQztpQkF0R0FqQjtpQkF5SkF1RjtpQkE3TEp0RjtpQkFrTElpQjtpQkErSEF2UDtpQkFZQXdQO2lCQTBESjVjO2lCQWNBTjtpQkFwTEl2SDtpQkF1QkFtSDtpQkFNQTBlO2lCQUlBQztpQkE2RkFqZ0I7aUJBVUFGO2lCQVlBcWdCO2lCQTJDQUs7aUJBUUo0RDtpQkF2UUl6QjtpQkFLQUM7aUJBS0FDO2lCQUtBQztpQkFmQUg7aUJBS0FDO2lCQWdKQXRFO2lCQXBQQXFDO2lCQWdGQU07aUJBL0RBTDtpQkFrQkFFO2lCQWtCQUM7aUJBa0JBQztpQkE2RkFwaEI7aUJBU0FzakI7aUJBeU1KOWdCO2lCQUdBZ2dCO2lCQVpBSDtpQkFHQUM7SUFsYkc7SUZxQkc7YUdyRVZtQyxnQkFBWSxjQUFvQjthQUVoQ0MsTUFBTW50QixHQUFJLDBCQUFxQjthQUUvQm90QixPQUFLcHRCLEdBQUksVUFBSkEsVUFBNkI7YUFFbENxdEIsS0FBS2x0QixFQUFFSCxHQUFJLFVBQU5HLEVBQUVILE1BQUksT0FBSkEsYUFBSSxRQUFtQzthQUU5Q3N0QixJQUFJdHRCO01BQ04sU0FETUE7TUFDTjtZQUNNbUMsV0FBSkMsV0FGSXBDLE9BRUFtQyxHQUZBbkMsMkJBRUpvQztNQUNVLFdBQVc7YUFFckJtckIsUUFBUXZ0QjtNQUNWLFNBRFVBO01BQ1Y7WUFDTW1DLFdBQUpDLFdBRlFwQyxPQUVKbUMsR0FGSW5DLDhCQUVSb0M7TUFDVSxRQUFJO2FBRWRvckIsSUFBSXh0QjtNQUNOLFNBRE1BLEtBQ04sU0FDVyxJQUFUb0MsV0FBUyxPQUFUQSxHQUNTLFdBQVc7YUFFcEJxckIsUUFBUXp0QjtNQUNWLFNBRFVBLEtBQ1YsU0FDVyxJQUFUb0MsV0FBUyxVQUFUQSxJQUNTLFFBQUk7YUFFYmtsQixTQUFTdG5CLEdBQUksYUFBSkEsUUFBYzthQUV2QjB0QixTQUFPMXRCLEdBQUksT0FBSkEsSUFBUzthQUVoQjJ0QixPQUFLOXRCLEVBQUVHLEdBQUksY0FBTkgsRUFBRUcsS0FBbUI7YUFFMUI0dEIsT0FBSy90QixFQUFFdUosSUFBSXBKLEdBQUksbUJBQVZILEVBQUV1SixJQUFJcEosS0FBNEI7YUFJdkM2dEIsU0FBTzd0QixHQUFJLGdCQUFKQSxLQUFtQjthQUUxQjhxQixRQUFRbk0sRUFBRWhqQixHQUFJLHFCQUFjd0UsR0FBSyxZQUFMQSxFQUFwQndlLEVBQWlDLEVBQS9CaGpCLEVBQWtDO2FBRTVDbXlCLFNBQU9sbkIsR0FDRCxJQUFKNUcsRUFBSSxZQUNSLFFBRElBLEVBREs0RyxHQUVULE9BREk1RyxDQUVIOzs7OztPQTdDQ2t0QjtPQU1BRztPQUVBQztPQUtBQztPQUtBQztPQUtBQztPQXJCQU47T0FFQUM7T0F3QkE5RjtPQUVBb0c7T0FFQUM7T0FFQUM7T0FJQUM7T0FFQS9DO09BRUFnRDs7O2FDakNBQyxnQkFBWSxnQkFJZjthQUVHQyxRQUFNclAsR0FDUixtQ0FFYTthQUVYMkgsSUFBSW5tQixFQUFFd2U7TUFDUixZQURNeGUsS0FDTixLQURRd2U7TUFDUjtnQkFEUUEsOEJBQ0pzUCxLQURJdFAsT0FDSnNQO2dCQURJdFAsZ0JBQ0pzUCxLQURJdFAsT0FDSnNQLE9BWVk7YUFLZEMsS0FBS3ZQO01BQ1AsU0FET0EsS0FDUCxTQUVzQixJQUFid1AsZ0JBQWEsT0FBYkEsUUFEQSxhQUNvQjthQUUzQkMsU0FBU3pQO01BQ1gsU0FEV0EsS0FDWCxTQUVzQixJQUFid1AsZ0JBQWEsVUFBYkEsU0FEQSxRQUN5QjthQUtoQ0UsS0FBSzFQO01BQ1AsU0FET0E7TUFDUDs7O2NBS2tCdFcsYUFOWHNXLDJCQU1XdFc7UUFGaEIsUUFKS3NXO1FBSUw7TUFGTyxhQU9BO2FBRVAyUCxTQUFTM1A7TUFDWCxTQURXQTtNQUNYOzs7Y0FLa0J0VyxhQU5Qc1csMkJBTU90VztRQUZoQixRQUpTc1c7UUFJVDtNQUZPLFFBT0s7YUFLWjRQLE9BWUU1UDtNQUFLLGFBQUxBLFVBWGU4UCxPQUFLUixLQVdwQnRQO01BVkY7V0FEc0JzUDtjQUdiRSxRQUhhRixRQUdKNWxCLEtBSEk0bEIsUUFJaEJocEIsT0FER2twQjthQUhRTSxLQU9ILFVBSFJ4cEIsU0FFSyxXQUZMQTtjQUpXd3BCLEtBSVh4cEIsSUFKZ0JncEIsS0FHSjVsQjs7UUFEVCxXQUZRb21CO1FBRVIsT0FGRUQsTUFXMkQ7YUFFdEVFLFdBQVMvUCxHQUNYLGFBRFdBLFFBQ0M7YUFFVmdRLFNBQU9oUSxHQUNULE9BRFNBLElBQ0Q7YUFFTmlRLE9BUUUvdUIsRUFBRThlO00vQjVIVCxJK0JxSGtCc1AsS0FPVHRQO01BTko7V0FEYXNQO2NBR0pFLFFBSElGLFFBR0s1bEIsS0FITDRsQjtVQUlYLFdBR0FwdUIsRUFKT3N1QjtjQUhJRixLQUdLNWxCOztRQURULFNBS2M7YUFFdkJ3bUIsT0FRRWh2QixFQUFFOFAsT0FBS2dQO1VBUEk3WixLQU9UNkssT0FQY3NlLEtBT1R0UDtNQU5UO1dBRGtCc1A7VUFJTDtXQURKRSxRQUhTRjtXQUdBNWxCLEtBSEE0bEI7V0FJTCxrQkFHWHB1QixFQVBXaUYsS0FHSnFwQjtXQUhJcnBCO1dBQUttcEIsS0FHQTVsQjs7UUFEVCxPQUZJdkQsS0FPb0I7YUFFakNncUIsU0FBU0MsR0FBR0M7TUFDZCxhQURXRDtNQUNYO1FBQ0UsU0FGWUM7UUFFWjtrQkFGWUE7Ozs7a0JBQUhEOzs7Ozs7a0JBQUdDOztrQkFBSEQ7a0JBU1AsUUFUT0E7a0JBQUdDLFFBQUhELE1BQUdDLFFBQUhELE1BQUdDLFFBQUhELE1BSVAsUUFKT0E7aUJBWUM7YUFJVkUsU0FBT3RRO01BQ1QsU0FBUS9NLElBQUloUDtRQUFPLEdBQVBBO2NBRU96QyxFQUZQeUMsS0FFVXlGLEtBRlZ6RjtVQUVrQyxVQUEzQnpDLGlCL0IzSnRCLE8rQnlKV3lSLElBRWN2SjtRQURYLFFBQzRDO01BRnZELFNBRFNzVztNQUNULHNCL0J6SkgsTytCeUpXL00sZUFJRzthQUVUc2QsVUFBUXZRLEVBQUVoakIsR0FBSSxxQkFBY3dFLEdBQUssV0FBTEEsRUFBcEJ3ZSxFQUFpQyxFQUEvQmhqQixFQUFrQzthQUU1Q3d6QixTQUFPdm9CLEdBQ0QsSUFBSitYLEVBQUksWUFDUixVQURJQSxFQURLL1gsR0FFVCxPQURJK1gsQ0FFSDs7Ozs7T0F2SUNvUDtPQVdBekg7O09BK0JBK0g7T0FXQUM7T0FYQUQ7T0FiQUg7T0FLQUU7T0FMQUY7T0F2QkFGO09BNkRBTztPQWNBRztPQUdBQztPQUdBQztPQVVBQztPQVVBQztPQWdCQUc7T0FPQUM7T0FFQUM7OzthQzNJQUMsdUJBQXNDLGVBQWU7YUFLckRDLGlCQUFrQkM7TUFDRyxJQUFuQkMsUUFEZ0JEO01BRXBCLFNBUEVGO01BT0Y7UUFFZSxJQUFUcGYsT0FBUyxXQUhYdWY7UUFJRixzQkFMa0JELElBSWR0ZjtRQUlKLE9BSklBO1lBR0Q1RTttQ0FDSCx5QkFBb0QsTUFEakRBLENBQ3dELEVBQTNELE1BREdBLEVBRUk7YUFJUG9rQixxQkFBc0JGO01BQ0QsSUFBbkJDLFFBRG9CRDtNQUV4QixTQXBCRUY7TUFtQnFCLElBRW5CcGYsT0FBUyxXQUZUdWY7TUFHSixzQkFKd0JELElBR3BCdGY7TUFDSixPQURJQSxNQUVFO2FBT0p5ZixNQUFPQztNQUVULElBQUlsVyxFQUFKLGFBRlNrVztNQUVULE9BQUlsVyxVQUZLa1csT0FFTGxXLFVBRktrVyxJQUtKLGlCQUxJQSxJQUtnQjthQ0d2QkMsVURBV0Q7TUFFYixJQUFJbFcsRUFBSixhQUZha1c7TUFFYixPQUFJbFcsVUFGU2tXLE9BRVRsVyxVQUZTa1csSUFLUixxQkFMUUEsSUFLZ0I7OzttQkF0QzNCTCxpQkFhQUcscUJBWUFDLE1DUUFFOzthQUVBQyxTQUFVL3ZCLEdBQ0osSUFBSk0sRUFBSSxzQkFDUixPQUZZTixFQUVaLE9BRElNLENBRWdCO2FBR2xCMHZCLFNBQVVsc0I7TUFDSixJQUFKNlYsRUFBSSxhQURJN1Y7U0FDUjZWLG9DQUlELE9BTFM3VjtNQUUwRCxzQ0FGMURBLEVBTVQ7YUFHRG1zQixPQUFRaHVCLEdBQWMsb0JBQWRBLGNBQWtEOzs7OztPQWpCMUQ2dEI7T0FFQUM7T0FNQUM7T0FTQUM7T0FmQUY7T0FNQUM7T0FTQUM7Ozs7O2FDN0NBQztNQUFRLDZCQUVEQSw0QkFEQyxRQUNlO2FBQ3ZCeEU7TUFBTyw2QkFFQUEsMEJBREMsUUFDYTthQUVyQnlFLFVBQVV4dUI7TUFDSCxhQURHQSxZQUNaLHFCQURZQSxPQUNILGlCQUFxRDthQUd4RHl1QixTQUFpREYsTUFBTWpYO01sQzNDaEUsSWtDMkNnRUU7TUFBSztrQkFBTEE7U0FBSyxPQUFMQTs7WUFPOUMsSUFESnNULEdBTmtEdFQsT0FNdERxVCxHQU5zRHJULE9BTzlDLGVBUHdDK1csTUFNaEQxRDtZQUNRO2tCQVA4Q3JULElBTWxEc1Q7O2NBQ0k7b0JBQ0E0RCxhQUFIanRCLDBCQUFHaXRCLElBRko1RDtjQUlEOztZQWlCRTtlQTNCaUR0VDthQTJCakQsa0JBQUxuWjthQUFLLGlCQUFMQSxrQkYzQ0x3dkIsaUJFMkNLeHZCO2FBM0JzRG1aOzs7Ozs7dUJBYzFELElBRHNCbVgsWUFDdEIsc0JBRHNCQSxJQWJvQ25YO2NBWWpDO1lBSWIsK0JBaEJ3QytXO1lBZ0J4QyxZQUVBLElBQUxLLGVBQUssVUFBTEEsSUFsQm1EcFg7WUFpQmhEOzs7WUFLVixJQURNeFgsRUFyQm9Ed1g7WUFzQjFELEdBRE14WCxhQUNpQixVQURqQkE7WUFDNEIsU0FENUJBLEtBRWE7WUFEbkIsSUFFTThDLEVBQUosc0JBSEk5QztZQUdKLE9BSElBO1lBR0osVUFBSThDLEVBeEJvRDBVOztRQUtuQyxPQUxtQ0EsSUEyQnBCO2FBR25DcVgsVUFBNkNyd0I7TUFFcEQ7aUJBRm9EQTtRQUVwRDtTQUNZOztTQURaO2tCQUVrQixJQUFUaUQsVUFBUyxVQUFUQTs7WUFFTyxJQUNWNlYsRUFEVSxTQU5vQzlZO1lBTXBDLFVBQ1Y4WTthQUNVOztjQUZBLFNBQ1ZBLE1BQW9CLElBQWRxWCxJQUFOclgsS0FBb0IsT0FBcEJBLEVBQW9CLFVBQWRxWDtjQUVEOztZQUVFOzsrQkFBTHR3QjthQUFLLGtCQUFMQSxrQkZ6REx3dkIsaUJFeURLeHZCO1lBQWU7Ozs7cUJBQ0csSUFBTnV3QixZQUFNLE9BQU5BO1lBQ0EsSUFBSmp3QixFQUFJLG1CQWJnQ0g7WUFhaEMsYUFBSkc7WUFBSSxPQUFKQTs7WUFFWixJQURNcUI7WUFDTixHQURNQSxhQUNpQixVQURqQkE7WUFDNEIsYUFENUJBO3NCQWQwQ3hCO3dCQWlCM0Msc0JBSEN3QixhQUdtQzthQUcxQzh1QjtNQUFPLFVBRUcsSUFBTHR3QixXQUFLLGlCQUFMQSxHQURHLFFBQ2E7YUFHakJ1d0IsVUFBeUN2d0I7TUFDL0M7aUJBRCtDQTtRQUMvQzs7a0JBQ2tCLElBQU44WSxVQUFNLE9BRjZCOVksYUFFN0IsT0FBTjhZLEVBQU07Ozt3QkFDZSxPQUhjOVksYUFHZDs7O1lBRTdCLElBRE13QjtZQUNOLEdBRE1BLGFBQ2lCLFVBRGpCQTtZQUM0QixhQUQ1QkE7c0JBSnFDeEI7MENBSXJDd0I7O1FBSFYsVUFRVSxVQVRxQ3hCO1FBU3JDO1FBQ0ksU0FDYTthQUd6Qnd3QjtNQUFPLFVBRU0sSUFBUmpGLGNBQVEsaUJBQVJBLE1BREcsUUFDbUI7YUFFdkJrRixVQUFVbnZCLEVBQUV0QjtNQUNsQixPQURnQnNCO1FBR1Isb0JBSFV0QjtRQUdWO1VBRUYsSUFER2lEO1VBQ0gsVUFMWWpEO1VBS1o7V0FDaUIsa0JBTlBzQixVQUFFdEI7V0FNSzs7O3VCQUZkaUQsRUFFRXl0QixPQUZGenRCLEVBRU02VixHQUFHb1Q7UUFDTixZQVBNbHNCO01BQ0gsWUFER0EsT0FPTzthQVV2QjJ3QixNQUFNcnZCO01sQ3JJWDtRa0N1SWU7O1NBUk8sZ0JBTVhBLEVBRUQwWDtTQVJZOzs7aUJBUVpBLFNBUkt6VjtRQUFPLFNBQVZ1VjtRQUFVLE9BQWQ0WDtNQU9LO2FBR1Jyb0IsS0FBS3JJO01BQ0QsaUJBRENBO01BQ0QsVUFDTSxJQUFMaUQsV0FBSyxLQUZMakQsR0FFSyxPQUFMaUQ7TUFDRyxlQUFhO2FBR3JCMnRCLFFBQU01d0IsR0FDRixpQkFERUEsR0FDRixTQUNNLGdCQUNGLFFBQUU7YUFHVjZ3QixPQUFLaHhCLEVBQUVpeEI7TUFFUDtRQUFNLGlCQUZDQTtRQUVELGNBQ0M3dEIsV0FBSyxLQUhMNnRCLE1BR3NCLFdBSHhCanhCLEVBR0VvRDtRQUNHLFNBRUg7YUFLUDh0QixLQUFLbHhCLEdBQUksdUJBQUpBLEtBQXlEO2FBRTlEbXhCLFVBQVFsdkI7TUFDVjtNQUF3QixtQ0FBcUIzQixFQUFFMkIsR0FBSyxVQUFQM0IsRUFBRTJCLEVBQWlCLEVBRHREQSxTQUNpRTthQUd6RW12QixZQUFVanhCO01BQ1osSUFBSSt2QjtNQUFKOztpQkFRRSxJQUFJbnRCLEVBUkZtdEI7aUJBUUYsT0FBSW50QixJQUFKLHNCQVRVNUM7MkJBQ1IrdkIsY0FVcUIsZ0JBWGIvdkIsRUFTTjRDOzJCQUdLLEVBQUM7YUFHVnN1QixTQUFTbHhCO01BQ1gsSUFBSSt2QjtNQUFKOztpQkFFRSxJQUFJbnRCLEVBRkZtdEI7aUJBRUYsT0FBSW50QixJQUFKLHFCQUhTNUM7MkJBQ1ArdkIsY0FJcUIsZUFMZC92QixFQUdMNEM7MkJBR0ssRUFBQzthQUdWdXVCLFdBQVdqdEI7TUFFeUIscUJBRnpCQSxHQUV5QiwrQkFBcUM7YUFLekVrdEIsS0FBS3oxQixFQUFFcUUsR0FBMEMsY0FBMUNBLEdBQWtDLHVCQUFwQ3JFLFVBQW9EO2FBQ3pEMDFCLE1BQU0xMUIsRUFBRXFFLEdBQXNDLGtCQUF4Q3JFLEVBQXdDLEtBQXRDcUUsS0FBOEM7YUFDdERzeEIsTUFBTTMxQixHQUFJLGtCQUFKQSxNQUE4QzthQUVwRDQxQixLQUFLMXhCLEVBQUVHO01BQ1Q7Ozs7OzttQkFBdUQsY0FEOUNBLEdBQ2lDLGVBQUssV0FEeENILFdBQ3NELEtBQUk7YUFFL0QyeEIsTUFBTTN4QixFQUFFRztNQUFJOzs7Ozs7bUJBQWlELGNBQXJEQSxHQUErQyxxQkFBakRILFVBQTZELEtBQUk7YUFDdkU0eEIsTUFBTTV4QjtNQUFJLHNDQUEyQyxxQkFBL0NBLFlBQStEO1FBRXJFNnhCO2FBQ0FDLE1BQU05eEI7TUFBSSxzQ0FBeUMsdUJBQTdDQSxLQUFtRCxLQUFHO2FBVzVEK3hCLFVBQXdEL3hCO01BQXhEO09BRVU7O09BRlY7O2NBR1VpWixXQUFIN1Y7VUFDTDtVQUNBLFdBTHNEcEQsRUFHakRvRDtVQUdMO1VBQ0EsVUFQc0RwRCxFQUc5Q2laO1VBSVI7O2NBRVF3VCxZQUFKRDtVQUNKO1VBQ0EsVUFYc0R4c0IsRUFTbER3c0I7VUFHSjtVQUNBLFVBYnNEeHNCLEVBUzlDeXNCO1VBSVI7Z0JBRVM7Z0JBQ0Q7aUJBQ0csaUNBQXNCO2FBeEIvQnVGLEtBQWdEaHlCLEVBQUVHO01BQ3hEO01BQ0EsVUFBVSxNQUY4Q0E7TUFHeEQ7TUFDQSxVQUpzREgsRUFJMUMsS0FKNENHO01BS3hEOzZCQUNnQjs7Ozs7O09BMURkK3dCO09BRUFDO09BSUFDO09BZUFDO09BU0FDO09BekNBTjtPQVpBeG9CO09BTUF1b0I7T0FsREFOO09BbUJBRTtPQWhGQVQ7T0FxR0FZO09BZ0VBUztPQUNBQztPQUNBQztPQUVBQztPQUdBQztPQUNBQztPQUVBQztPQUNBQztPQUlJRTs7YUNyTEpDLFNBQU94d0I7TUFDVjtnQkFEVUE7T0FFVix3QkFESXdOO09BRUosb0JBRElFO01BQ0osVUFBSWhQLElBREFnUCxJQUNBaFAsRUFDc0Q7YUFFdkQreEIsU0FBU3Z3QixHQUFJLGtCQUFKQSxZQUEwQzthQUNuRHd3QixTQUFTeHdCLEdBQUksV0FBSkEsWUFBbUM7YUFFNUN5d0IsTUFBSXp3QixFQUFFOEIsSUFBSUM7TW5DeENmLFFtQ3dDV0QsWUFBSUMsV0FBTi9CLE9BQU0rQixXQUFKRDtPQUdILGtCQUhDOUIsS0FBRThCLElBQUlDO01BRVAsa0NBQ2lDO2FBR3BDMnVCLE9BQUtyWCxJQUFJMUksT0FBT00sSUFBSVAsT0FBTzNPO01uQzlDaEM7OztRbUM4Q2dDQTs7OztRQUFsQjRPOzs7VUFBSjBJLFNBQXNCdFgsV0FBbEI0Tzs7OztRQUFXRDs7OytCQUFKTyxPQUFXbFAsV0FBUDJPO09BS3BCLHVCQUxLMkksT0FBSTFJLE9BQU9NLElBQUlQLE9BQU8zTztNQUd4QixtQ0FFK0M7YUFHbEQ0dUIsTUFBSTN3QixFQUFFOEI7TW5DdERYLFFtQ3NEV0EsVUFBRjlCLFFBQUU4QixLQUdILDZCQUhDOUIsS0FBRThCO01BRVAsa0NBQ2lDO2FBR2hDOHVCLFNBQU81d0IsR0FBSSxPQUFKQSxJQUFjO2FBRXJCNndCLFFBQU03d0IsR0FBSSxpQkFBZTthQUV6Qjh3QixNQUFNOXdCO01BQ1IsZ0JBRFFBLEtBQ1IsNEJBRFFBLE1BQ1IsUUFFaUM7YUFVL0Ird0IsT0FBTy93QixFQUFFZ3hCO01BQ1gsWUFEU2h4QixLQUNULFFBRFNBLEtBQ1QsV0FDSWt4Qjs7V0FDQXZmLGNBRkFzZixVQURPRDtVQUl3QixpQkFEL0JyZjtRQUVKLHVCQUZJQTtTQUVxQyxJQUpyQ3NmLFVBRE9EO1VBT0o7O1VBQ0E7UUFFVSxJQUFiRyxXQUFhLGtCQVBieGY7UUFVSixLQWJTM1IsT0FVTG14QixhQVZLbnhCO1FBYVQsT0FISW14QjtRQUdKLE9BVkl4ZjtRQVVKLElBYlMzUixPQUFFZ3hCLGFBQUZoeEI7VUFpQlQsSUFoQklpeEIsVUFET0QsYUFBRmh4QixLQWtCVDs7cUNBQUU7YUFvQ0FveEIsU0FBU3B4QixFQUFFb0I7TUFDYixJQUFJK1IsSUFET25UO01BQ1gsR0FEV0EsUUFDUG1ULElBQ29CLE9BRmJuVDtNQUV1QixzQkFGdkJBLEtBQ1BtVCxJQURTL1I7TUFFcUIsT0FEOUIrUjtNQUM4QixRQUViO2FBRWxCa2UsZ0JBQWdCcnhCLEVBQ2xCZ0k7TW5DMUlKLFFtQzBJSUE7UUFDTyxTQURQQTtVQUdPLFVBSFBBO1lBV08sV0FYUEE7Y0FxQk8sYUFyQlBBLEVBaUNLO2NBWEgsSUFBSW1MLElBdkJZblQ7Y0F1QmhCLEdBdkJnQkEsUUF1QlptVCxhQUN1QixPQXhCWG5UO2NBd0JxQixzQkF4QnJCQSxLQXVCWm1ULFVBdEJObkw7Y0F1QnVDO2dCQXhCckJoSSxLQXVCWm1ULG1CQXRCTm5MO2NBdUJ1QyxzQkF4QnJCaEksS0F1QlptVCxtQkF0Qk5uTDtjQXVCdUMsc0JBeEJyQmhJLEtBdUJabVQsa0JBdEJObkw7Y0F1QnVDLE9BRGpDbUw7Y0FDaUM7WUFYckMsSUFBSW1lLE1BYll0eEI7WUFhaEIsR0FiZ0JBLFFBYVpzeEIsZUFDdUIsT0FkWHR4QjtZQWNxQixzQkFkckJBLEtBYVpzeEIsWUFaTnRwQjtZQWF1QyxzQkFkckJoSSxLQWFac3hCLHFCQVpOdHBCO1lBYXVDLHNCQWRyQmhJLEtBYVpzeEIsb0JBWk50cEI7WUFhdUMsT0FEakNzcEI7WUFDaUM7VUFUckMsSUFBSUMsTUFMWXZ4QjtVQUtoQixHQUxnQkEsUUFLWnV4QixlQUN1QixPQU5YdnhCO1VBTXFCLHNCQU5yQkEsS0FLWnV4QixZQUpOdnBCO1VBS3VDLHNCQU5yQmhJLEtBS1p1eEIsb0JBSk52cEI7VUFLdUMsT0FEakN1cEI7VUFDaUM7UUFIckMsZ0JBSGdCdnhCLEVBQ2xCZ0k7TUFBZ0IsNEJBaUNDO2FBRWZ3cEIsbUJBQW1CeHhCLEVBQ3JCZ0k7TW5DOUtKLFFtQzhLSUE7UUFDTyxXQURQQTtVQU9PLGFBUFBBLEVBa0JLO1VBVkg7ZUFSRkE7V0FRRSxXQUFJQztXQUFKLFdBQUlBO1dBQUosSUFUbUJqSTtVQVNuQixHQVRtQkEsUUFZZm1ULGFBQ3VCLE9BYlJuVDtVQWFrQixzQkFibEJBLEtBWWZtVCxJQUZBc2U7VUFHaUMsc0JBYmxCenhCLEtBWWZtVCxZQUZBc2U7VUFHaUMsc0JBYmxCenhCLEtBWWZtVCxZQURBdWU7VUFFaUMsc0JBYmxCMXhCLEtBWWZtVCxZQURBdWU7VUFFaUMsT0FEakN2ZTtVQUNpQztRQVZyQyxJQUFJbWUsTUFIZXR4QjtRQUduQixHQUhtQkEsUUFHZnN4QixlQUN1QixPQUpSdHhCO1FBSWtCLHNCQUpsQkEsS0FHZnN4QixNQUZOdHBCO1FBR3VDLHNCQUpsQmhJLEtBR2ZzeEIsY0FGTnRwQjtRQUd1QyxPQURqQ3NwQjtRQUNpQztNQUh2Qiw0QkFrQkM7YUFFZkssbUJBQW1CM3hCLEVBQ3JCZ0k7TW5Dbk1KLFFtQ21NSUE7UUFDTyxXQURQQTtVQU9PLGFBUFBBLEVBa0JLO1VBVkg7ZUFSRkE7V0FRRSxXQUFJQztXQUFKLFdBQUlBO1dBQUosSUFUbUJqSTtVQVNuQixHQVRtQkEsUUFZZm1ULGFBQ3VCLE9BYlJuVDtVQWFrQixzQkFibEJBLEtBWWZtVCxJQUZBc2U7VUFHaUMsc0JBYmxCenhCLEtBWWZtVCxZQUZBc2U7VUFHaUMsc0JBYmxCenhCLEtBWWZtVCxZQURBdWU7VUFFaUMsc0JBYmxCMXhCLEtBWWZtVCxZQURBdWU7VUFFaUMsT0FEakN2ZTtVQUNpQztRQVZyQyxJQUFJbWUsTUFIZXR4QjtRQUduQixHQUhtQkEsUUFHZnN4QixlQUN1QixPQUpSdHhCO1FBSWtCLHNCQUpsQkEsS0FHZnN4QixNQUZOdHBCO1FBR3VDLHNCQUpsQmhJLEtBR2ZzeEIsY0FGTnRwQjtRQUd1QyxPQURqQ3NwQjtRQUNpQztNQUh2Qiw0QkFrQkM7YUFFaEJNLGNBQWM1eEIsRUFBRXhCLEVBQUVxekIsT0FBTzl2QjtNQUMzQixTQURvQjh2QjtNQUNwQjs7OzthQUQyQjl2Qjs2Q0FBVHZELEtBQVN1RCxXQUFQOHZCO01BRWY7TUFETCxJQUVJQyxhQUhZOXhCLE9BQVcrQjtNQUV5QixHQUZwQy9CLE9BR1o4eEIsYUFDNEIsT0FKaEI5eEIsRUFBVytCO01BSzNCLGlCQUxrQnZELEVBQUVxekIsT0FBSjd4QixVQUFXK0I7TUFLM0IsT0FGSSt2QjtNQUVKLFFBQzBCO2FBRXhCQyxhQUFhL3hCLEVBQUV4QixFQUFFcXpCLE9BQU85dkI7TUFDVixxQkFERC9CLEVBQ0MscUJBREN4QixHQUFFcXpCLE9BQU85dkIsSUFDMkI7YUFFbkRpd0IsV0FBV2h5QixFQUFFeEI7TUFDZiw4QkFEZUEsR0FDZixhQURhd0IsT0FDVCtCO01BQUosR0FEYS9CLE9BRVQ4eEIsYUFDNEIsT0FIbkI5eEIsRUFDVCtCO01BR0osaUJBSmV2RCxJQUFGd0IsVUFDVCtCO01BR0osT0FGSSt2QjtNQUVKLFFBQzBCO2FBRXhCRyxVQUFVanlCLEVBQUV4QixHQUFpQixrQkFBbkJ3QixFQUFtQixxQkFBakJ4QixHQUEyQzthQUV2RDB6QixXQUFXbHlCLEVBQUVteUIsSUFDZixvQkFEYW55QixFQUFFbXlCLGNBQ3VCO2FBK0JwQ0MsWUFBWXB5QixFQUFFMEMsR0FBR1g7TUFDbkIsU0FEbUJBLFlBQ25CLGtDQURtQkE7TUFFakI7TUFiRixHQVdjL0IsZUFBSytCLFNBWGlCLE9BV3RCL0IsRUFBSytCO01BQ25CLElBNUJxQnN3QixlQUFjdndCLElBMkJyQjlCLEtBM0IwQnN5QixRQTJCckJ2d0IsSUFYNkIsS0FXbEMvQjtNQTFCWjtpQkFEc0NzeUI7VUFHNUIsSUFBSnh2QixFQUFJLE1Bd0JJSixRQTNCbUJaLElBQUt3d0I7VUFHNUIsU0FBSnh2QjtZQUVDOzRCQUxZdXZCLGVBR2J2dkI7YUFFQyxNQUwwQmhCLE1BRzNCZ0I7YUFFQyxVQUwrQnd2QixVQUdoQ3h2QjthQUhhdXZCO2FBQWN2d0I7YUFBS3d3Qjs7WUEyQjFCdHlCLE9BM0JPcXlCLHFCQTJCUHJ5QjtVQUhkLE9BR2NBLE9BM0JPcXlCOzRCQTJCRnR3QixJQU1IO1VBQ2hCO3FDQUFFO2FBRUEwd0IsY0FBYzl3QixHQUFHM0IsR0FDbkIsY0FEZ0IyQixHQUFHM0IsWUFDWTthQTRDN0IweUIsZUFBZTF5QixFQUFFM0IsRUFBRUc7TUFDckIsZ0NBRHFCQSxHQUVQbzBCLFlBQVNDO01BQ3JCO1dBRHFCQSxNQWpCRkY7VUFtQlgsSUFlSkcsUUFmSSxnQkFKV3QwQixFQUVFcTBCO1VBRWIsVUFlSkM7WUFkb0IsVUFIWkY7Y0FJUCxTQU5VNXlCLEVBbUJYOHlCO2NBYkMsUUFKZ0JELFlBQVRELFlBQVNDOztZQU9oQixJQXhCUTlRLE1BaUJROFE7WUFoQnZCLEdBRHFCRixTQUFONVEsTUFDTTtZQXVCZCxJQXRCRCx3QkFhZXZqQixFQWZOdWpCO3NCQWxCTWlSO2NBNEJsQixRQVZZalIsY0FSZiw0QkF1QnFCdmpCLEdBdkJMMjBCO2NBQ2Q7bUJBRGdCRCxTQUFGQztxQkFrQlRDLEtBbEJXRjs7a0JBRVYsMEJBcUJhMTBCLEVBdkJMMjBCO2tCQUVSOzs7Ozs7Ozs7OytCQUMwQyxRQUhsQ0E7a0JBRVIsSUFnQkRDLEtBbEJTRDsrQkFtQmIsTUFJa0IzMEIsRUFmTnVqQixNQVVScVIsT0FWUXJSLFdBVVJxUjs7O1kzQm9ORDtjMkJ6TkgsUUFMWXJSLGNBS1o7Y0FoQ1MsVUFTU2lSOzs7bUNBTmQ7Y0E2QkosSUF0QkgsMEJBZ0NxQngwQixHQWhDTGtzQixNQUFFdndCO2NBQ2hCO21CQURrQm1YLE9BQUZuWCxFQUNDO2dCQUNkLG1CQThCZ0JxRSxFQWhDSHJFLE9BREc2NEI7a0JBR0ssUUFGUjc0QixVQUVRLElBRlZ1d0IsZ0JBQUV2d0I7Z0JBR2IsbUJBNkJnQnFFLEVBaENIckU7a0JBS1gsUUFMV0E7Z0JBSWQsU0FKWXV3QjtrQkFJUyxRQUpQdndCLFVBSU8sSUFKVHV3QixnQkFBRXZ3Qjs7O3FCQXdCZixNQVFrQnFFLEVBaENIODBCLFNBaUJIdlIsb0JBakJHNW5COztZQXlDWCxJQUNXdTVCLGtCQUFQQztZQUNKLFdBWFUzekIsRUFXRyxXQVhEM0IsRUFVUnMxQjtZQURKLElBUE9mLFlBQVNDLElBUUxhOztVQUdDLFVBWExkO1lBWVAsU0FkVTV5QjtZQWVWLFNBZlVBLEVBbUJYOHlCO1lBSkMsUUFiZ0JELFlBQVRELFlBQVNDOztvQkFpQmpCQztZQURDLFNBaEJnQkQsWUFBVEQsU0FpQlJFLFFBakJpQkQ7VUFrQmhCLFNBcEJVN3lCLEVBbUJYOHlCO1VBZkksSUFnQkgsS0FsQmdCRCxZQUFURCxTQWlCUkUsUUFqQmlCRDs7UUFxQnJCLGdCQXJCWUQ7UUFxQlosWUFBd0IsU0F2QlQ1eUIsRUFFSDR5QixlQXNCSDthQUVUbUIsU0FBUy96QixFQUFFK0I7TUFDUyxRQURUQSxVQUFGL0IsT0FBRStCLE1BSVQsT0FKU0EsSUFJVDtNQUZBLHVDQUVpQjthQUluQml5QixTQUFPaDBCO01BQ1QsU0FBUW9RLElBQUlqVztRQUVWLEdBSE82RixRQUNHN0YsRUFFYztRQUV0Qiw0QkFMSzZGLEtBQ0c3RixHQUlSLEtBSlFBO1FBS0ssVUFEVHdFLGlCbkN4V1gsT21Db1dXeVIsZ0JBS21CO01BTDNCOzRCbkNwV0gsT21Db1dXQSxlQU9IO2FBRUg2akIsVUFBUWowQjtNQUNWLFNBQVFvUSxJQUFJalc7UUFFVixHQUhRNkYsUUFDRTdGLEVBRWM7UUFFdEIsNEJBTE02RixLQUNFN0YsR0FJUixLQUpRQTtRQUtTLGFBTFRBLEVBSUp3RSxrQm5DbFhYLE9tQzhXV3lSLGdCQUt1QjtNQUwvQjs0Qm5DOVdILE9tQzhXV0EsZUFPSDthQUVIOGpCLFVBQVFsMEIsRUFBRWtIO01BQWUsMkJuQ3ZYOUIsT21DbUlLa3FCLFNBb1BRcHhCLFNBQUVrSCxJQUErQjthQUV6Q2l0QixTQUFPaDZCLEdBQ0QsSUFBSjZGLEVBQUksYUFDUixVQURJQSxFQURLN0YsR0FFVCxPQURJNkYsQ0FFSDthQWFDbzBCLFNBQVNwMEIsRUFBRXJCO01BQ2IsSUFBSW16QixhQURPOXhCO01BQ1gsR0FEV0EsT0FDUDh4QixhQUM0QixPQUZyQjl4QjtNQUUrQixzQkFGL0JBLFVBQUVyQjtNQUU2QixPQUR0Q216QjtNQUNzQyxRQUVoQjthQUV4QnVDLGFBQWFyMEIsRUFBRXJCO01BQ2pCLElBQUltekIsYUFEVzl4QjtNQUNmLEdBRGVBLE9BQ1g4eEIsYUFDNEIsT0FGakI5eEI7TUFHZixpQkFIZUEsVUFBRXJCO01BR2pCLE9BRkltekI7TUFFSixRQUMwQjthQUV4QndDLGFBQWF0MEIsRUFBRXJCO01BQ2pCLElBQUltekIsYUFEVzl4QjtNQUNmLEdBRGVBLE9BQ1g4eEIsYUFDNEIsT0FGakI5eEI7TUFHZixpQkFIZUEsVUFBRXJCO01BR2pCLE9BRkltekI7TUFFSixRQUMwQjthQUV4QnlDLGFBQWF2MEIsRUFBRXJCO01BQ2pCLElBQUltekIsYUFEVzl4QjtNQUNmLEdBRGVBLE9BQ1g4eEIsYUFDNEIsT0FGakI5eEI7TUFHZixpQkFIZUEsVUFBRXJCO01BR2pCLE9BRkltekI7TUFFSixRQUMwQjthQUV4QjBDLGFBQWF4MEIsRUFBRXJCLEduQ2phcEIsT21DK1lLMDFCLGFBa0JhcjBCLEVBQUVyQixFQUNzQzthQUVyRDgxQixhQUFhejBCLEVBQUVyQjtNQUM2QixJQUQ3QitQLElBQzZCLGFBRDdCL1AsVUFyQmYwMUIsYUFxQmFyMEIsRUFBRTBPLElBQ3NDO2FBRXJEZ21CLGFBQWExMEIsRUFBRXJCLEduQ3ZhcEIsT21DcVpLMjFCLGFBa0JhdDBCLEVBQUVyQixFQUNzQzthQUVyRGcyQixhQUFhMzBCLEVBQUVyQjtNQUM2QixJQUQ3QitQLElBQzZCLGlCQUQ3Qi9QLEdBQ3FDLG9CQUR2Q3FCLEVBQUUwTyxJQUNzQzthQUVyRGttQixhQUFhNTBCLEVBQUVyQixHbkM3YXBCLE9tQzJaSzQxQixhQWtCYXYwQixFQUFFckIsRUFDc0M7YUFFckRrMkIsYUFBYTcwQixFQUFFckI7TUFDNkIsSUFEN0IrUCxJQUM2QixpQkFEN0IvUCxHQUNxQyxvQkFEdkNxQixFQUFFME8sSUFDc0M7Ozs7T0FsWnJENGhCO09BTUFDO09BQ0FDO09BRUFDO09BTUFDO09BUUFDO09BTUFDO09BRUFDO09BRUFDO09BbUVBTTtPQU1DQztPQXlEQU07T0FyQkFIO09BcUREUTtPQU9BQztPQWxCQUw7T0FRQUc7T0FrR0FXO09BdEZBUjtPQWdDQUU7T0FTQUs7T0F1RUFzQjtPQVFBQztPQVVBQztPQVVBQztPQUVBQztPQWdCQUM7O09BTUFDO09BcUJBSTtPQUhBRDtPQWxCQUg7T0FxQkFJO09BSEFEO09BWkFGO09BcUJBSztPQUhBRDtPQVpBSDtPQXFCQU07T0FIQUQ7O2EvQnJaQUUsdUJBQXFCLGlCQUFvQjthQUd6Q0MsZ0JBQWdCbDNCLFNBQVN1RDtNQUMzQixZQUQyQkEsWUFDM0IsV0FEMkJBO01BRzNCO2VBSGtCdkQ7ZUFFZG0zQjtlQUVGLFlBQTBCLGVBSlZuM0IsU0FFZG0zQixXQUF3QkMsTUFFdUM7YUFFakVDLGdCQUFnQnIzQixVQUNsQixtQkFEa0JBLFNBQ007YUFHdEJzM0IsYUFBYXQzQjtNQUNDLGtDQUNoQjFEO01BQ0U7O1VBRkVpN0IsV0FDSmo3QixFQUVJLFlBQTBCLGdCQUpmMEQsU0FFZjFEO1FBQ0UsU0FERkE7O1FBSUEsNEJBTElpN0IsWUFLNEI7YUFHOUJDLGVBQWV4M0IsU0FBU3VEO01BQzFCLFlBRDBCQSxZQUMxQixXQUQwQkE7TUFHYiw4QkFISXZELFNBRWJtM0IsV0FBd0JDLFNBQzhCO2FBYXhESyxlQUFlQztNQUFVLEdBQVZBLFNBRUQsSUFBVEMsTUFGVUQsV0FFRCxZQUFUQyxPQURHLFFBQ2dDO2FBU3hDQywrQkFHQXQzQixJQUFJdTNCO01BQU8sVUFBWHYzQjtPQUFXLE9BQVhBO2dCQUVBLGFBRkl1M0I7Z0JBSUosYUFKSUE7Z0JBZ0NKLGNBaENJQTtpQkFzQ0osY0F0Q0lBOztPQUFPLE9BQVh2M0I7Z0JBTUEsSUFEZW8zQixRQUxmcDNCLE9BTTBCLDRCQURYbzNCLFNBTFhHOztVQVFKLElBRG9CQyxVQVBwQngzQixPQVErQiw0QkFEWHczQixXQVBoQkQ7O2NBU2dCRSxVQVRwQnozQixPQVNhbEMsTUFUYmtDO1VBVThCLGFBRGpCbEMsTUFDaUIsZUFEVjI1QixhQVRoQkY7O2NBV2tCRyxVQVh0QjEzQixPQVdlL0IsUUFYZitCO1VBYWlCLGFBRkYvQixRQUVFLGVBRkt5NUIsYUFYbEJIOztjQWNzQkksVUFkMUIzM0IsT0FjbUI1QixRQWRuQjRCO1VBZ0JxQixhQUZGNUIsUUFFRSxlQUZLdTVCLGFBZHRCSjs7Y0FpQmtCSyxVQWpCdEI1M0IsT0FpQmV6QixRQWpCZnlCO1VBbUJpQixhQUZGekIsUUFFRSxlQUZLcTVCLGFBakJsQkw7O2NBb0JvQk0sU0FwQnhCNzNCLE9Bb0JlODNCLFVBcEJmOTNCO1VBVDRCLEdBNkJKNjNCLFNBM0JYLFNBMkJXQSxvQkEzQm5CRTtVQThCSyxnQ0FIS0QsZ0JBcEJYUDs7VUF5QkosSUFEYVMsVUF4QmJoNEIsT0F5QndCLDRCQURYZzRCLFdBeEJUVDs7Y0EwQnlCejRCLE1BMUI3QmtCLE9BMEJvQmk0QixVQTFCcEJqNEI7d0JBMEJvQmk0QixVQUFTbjVCLE1BMUJ6Qnk0Qjs7Y0E0QjJCdjRCLFFBNUIvQmdCLE9BNEJzQms0QixVQTVCdEJsNEI7d0JBNEJzQms0QixVQUFTbDVCLFFBNUIzQnU0Qjs7Y0FpQzhCNzNCLFNBakNsQ00sT0FpQ3VCTCxVQWpDdkJLO3dCQWlDdUJMLFVBQVdELFNBakM5QjYzQjtpQkFvQ0osSUFEeUIxM0IsUUFuQ3pCRyxPQW9DQSxjQUR5QkgsUUFuQ3JCMDNCLE1Bc0NpQzthQTBHckNZLHdCQUF3Qno1QixPQUMxQixhQUQwQkEsY0FPWDthQTZCYjA1QixjQUFjQztNQUErQiw4QkFBL0JBLFdBQXVEO2FBR3JFQyxrQkFBa0JwekIsSUFBSXF6QjtNQUN4QjtnQ0FEb0JyekI7T0FDcEIsUUFEb0JBLFNBQUlxekI7T0FDeEIsS0FBSTMwQixNQUNBNDBCO01BREo7UUFHZ0I7cUJBSFo1MEIsWUFDQTQwQjtTQUdGLDBCQURJaGxCO1FBRUosS0FOa0J0TyxTQUtkdXpCLFVBSkY3MEI7UUFLRixTQURJNjBCO1FBRFU7OztNQVBZLFdBVzNCO2FBR0NDLGdCQUFnQnh6QixJQUFJakM7TUFDdEIsa0JBRGtCaUM7TUFFbEIsZUFGa0JBLGNBQUlqQztNQUV0QixTQUZrQmlDO01BRWxCLFFBQ3NCO2FBR3BCeXpCLGtCQUFrQnp6QixJQUFJN0U7TUFDeEIsSUFBSXU0QixRQUFKLHNCQUR3QnY0QjtNQUV4QixrQkFGb0I2RSxJQUNoQjB6QjtNQUVKLE9BSHdCdjRCLElBQUo2RSxjQUNoQjB6QjtNQUVKLFNBSG9CMXpCLFNBQ2hCMHpCO01BRUosUUFDNEI7YUFHMUJDLGdCQUFnQjN6QixLQUNsQixrQkFEa0JBLGdCQUNrQjthQUtsQzR6QixjQUFjaDdCO01BQVEsT0FBUkE7O2VBRW9COztlQUF3Qjs7Z0JBQ2hEOztnQkFBd0I7Ozs7Z0JBRkU7Z0JBQzFCLFdBQzJCO2FBSXJDaTdCLGNBQWdCMVgsSUFBUTNpQjtNQUFRLEdBQWhCMmlCLElBQUcsUUFBSEEsVUFBR0MsYUFBSDBYO01BQWdCLE9BQVJ0NkI7ZUFDYjtlQUFpQjtlQUNqQjtlQUFpQjtlQUNqQjtlQUFpQixPQUhaczZCO2VBSUw7ZUFBaUI7Z0JBQ2hCLFVBQUc7YUF5RWZDLGFBQWEvekIsSUFBSWcwQjtNQUFRLE9BQVJBO2VBQ1IsdUJBREloMEI7ZUFFSjtnQkFDQSx1QkFISUEsUUFHbUI7YUFHaENpMEIsb0JBQW9CajBCLElBQUlrMEI7TUFDMUIsT0FEMEJBLFNBQ1QsZ0JBREtsMEIsUUFBSWswQixRQUNjO2FBSXRDQyxlQUFlbjBCLElBQUlreUI7TUFBVSxHQUFWQTtRQUVMLElBQVRDLE1BRmNEO1FBRWlCLHlCQUZyQmx5QixJQUVxQiw0QkFBL0JteUI7TUFERyxRQUNpRDthQUt6RGlDLGVBQ0FwMEIsSUFBSXhIO01BQU8sVUFBUEE7T0FDVTs7UUFESCxTQUFQQTtjQUVnQmlFLEVBRmhCakUsT0FFU3c3QixNQUZUeDdCO1VBR0osYUFIQXdILElBRWFnMEI7VUFFUyx5QkFKdEJoMEIsSUFJc0IsNEJBRkZ2RDtRQUlwQixJQURZNDNCLFFBTFI3N0I7UUFNSixhQU5Bd0gsSUFLWXEwQjtRQUNaLHVCQU5BcjBCLFFBT3VCO2FBR3ZCczBCLGlCQUNFdDBCLElBQUl0SDtNQUFRLFVBQVJBLGtCQU1OLE9BTk1BLEtBTU4sa0JBTkVzSDtVQUVZdkQsRUFGUi9EO01BR04sZ0JBSEVzSDtNQUlvQix5QkFKcEJBLElBSW9CLDRCQUZSdkQsR0FJWTthQUsxQjgzQixrQkFBa0J2MEIsSUFBSXBIO01BQVEsT0FBUkE7O2VBQ0gsdUJBRERvSDs7ZUFFQyx1QkFGREE7Ozs7OztnQkFJaEIsdUJBSmdCQTtnQkFLK0IsU0FBRTthQVluRHcwQixrQkFBa0J4MEIsSUFBSWswQixTQUFTdDdCLE1BQU1KLElBQUlFLEtBQUtxRjtNQUNoRCxnQkFEb0JpQztNQUVwQixvQkFGb0JBLElBQUlrMEI7TUFHeEIsa0JBSG9CbDBCLElBQWFwSDtNQUlqQyxlQUpvQm9ILElBQW1CeEg7TUFLdkMsaUJBTG9Cd0gsSUFBdUJ0SDtNQU0zQyxnQkFOb0JzSCxJQUE0QmpDO01BTzVCLHVCQVBBaUMsSUFPQSxjQVBhcEgsT0FPUTthQUt2QzY3QixrQkFBa0J6MEIsSUFBSXhHO01BQ3hCLE9BRHdCQTs7ZUFFTixnQkFGRXdHO2dCQUdGLGdCQUhFQTtNQUtwQixZQUx3QnhHLFNBTVYsZ0JBTk13RyxTQVFlO2FBYWpDMDBCLHlCQUF5QjcrQjtNQUFpQixVQUFqQkE7T0FBaUIsT0FBakJBO2dCQUNEO2dCQUNBO2dCQUVBO2dCQUNBO2dCQUNBO2dCQUVBO2lCQUNBOztPQVRrQixPQUFqQkE7Z0JBR0QsSUFBakI2RCxJQUhrQjdELGtCQUdELE9BQWpCNkQ7Z0JBSWlCLElBQVppN0IsTUFQYTkrQixrQkFPRCxPQUFaOCtCO2lCQUdJLElBQUw1MkIsRUFWY2xJLGtCQVVILDhCQUFYa0ksSUFBNEI7YUFLdkM2MkIsb0JBQW9CNTBCLElBQUlyRztNQUFNLGNBQU5BLElBQ2pCLGtCQURhcUcsWUFFZixnQkFGZUEsSUFBSXJHLElBRUk7YUFHNUJrN0Isc0JBQXNCNzBCLElBQUl0RztNQUM1QiwrQkFENEJBLGFBQzVCOzs7UUFDRTs4QkFGc0JzRyxJQUVFLGdCQUZFdEcsSUFDNUI1QztVQUNFLFNBREZBOzs7Y0FFSTthQU1FZytCLGFBRUo5MEIsSUFBSXBHO01KaGZULElJZ2ZTRTtNQUFTO2lCQUFUQTtRQXlCWTs7UUF6QkgsT0FBVEE7O2VBQ0k5QyxLQURKOEM7V0FDaUIsa0JBRHJCa0c7ZUFBSWxHLFFBQ0k5Qzs7O2VBQ0VDLE9BRk42QztXQUVpQixrQkFGckJrRztlQUFJbEcsUUFFTTdDOzs7ZUFDSEMsT0FISDRDO1dBR2lCLGtCQUhyQmtHO2VBQUlsRyxRQUdHNUM7OztlQUNFQyxPQUpMMkM7V0FJaUIsa0JBSnJCa0c7ZUFBSWxHLFFBSUszQzs7O2VBQ0lDLE9BTFQwQztXQUtpQixrQkFMckJrRztlQUFJbEcsUUFLUzFDOzs7ZUFDSkMsT0FOTHlDO1dBTWlCLGtCQU5yQmtHO2VBQUlsRyxRQU1LekM7OztlQUNBQyxPQVBMd0M7V0FPaUIsa0JBUHJCa0c7ZUFBSWxHLFFBT0t4Qzs7O2VBQ0RDLE9BUkp1QztXQVFpQixrQkFSckJrRztlQUFJbEcsUUFRSXZDOzs7ZUFVa0JDLE9BbEJ0QnNDLFdBa0JXaTdCLFVBbEJYajdCO1dBbUJKLGtCQW5CQWtHO1dBbUI0QixhQW5CNUJBLElBa0JlKzBCO1dBRWYsa0JBcEJBLzBCO2VBQUlsRyxRQWtCc0J0Qzs7O2VBR0tFLE9BckIzQm9DLFdBcUJhazdCLFlBckJibDdCO1dBc0JKLGtCQXRCQWtHO1dBc0I0QixhQXRCNUJBLElBcUJpQmcxQjtXQUVqQixrQkF2QkFoMUI7ZUFBSWxHLFFBcUIyQnBDOzs7ZUFadEJFLE9BVExrQztXQVNpQixrQkFUckJrRztlQUFJbEcsUUFTS2xDOzs7ZUFDQUMsUUFWTGlDO1dBVWlCLGtCQVZyQmtHO2VBQUlsRyxRQVVLakM7OztlQUNGQyxRQVhIZ0M7V0FXaUIsa0JBWHJCa0c7ZUFBSWxHLFFBV0doQzs7O2VBQ0dDLFFBWk4rQjtXQVlpQixrQkFackJrRztlQUFJbEcsUUFZTS9COzs7ZUFFUUMsUUFkZDhCO1dBZUosa0JBZkFrRztlQUFJbEcsUUFjYzlCO29CQVdBO2FBSWRpOUI7Z0JBSWEsSUFBTDM1QixXQUFTLCtCQUFUQSxPQURHLFFBQzJCO2FBa0gxQzQ1QixjQUFjQztNQUNOLDBCQTdHTjlDLElBNEdZOEMsTUE1R1JqQjs7TUFBWTtpQkFBaEI3QjtlQTVQRnNCLGdCQXlQVzN6Qjs7UUFHTyxPQUFoQnF5Qjs7ZUEwQktyN0IsS0ExQkxxN0I7V0EyQkEsZ0JBOUJTcnlCO1dBOEJnQixvQkE5QmhCQSxJQUdMazBCO1dBNEJKLGdCQS9CU2wwQjtlQUdUcXlCLElBMEJLcjdCLEtBMUJEazlCOzs7ZUE2Qk1qOUIsT0E3QlZvN0I7V0E4QkEsZ0JBakNTcnlCO1dBaUNnQixvQkFqQ2hCQSxJQUdMazBCO1dBK0JKLGdCQWxDU2wwQjtlQUdUcXlCLElBNkJVcDdCLE9BN0JOaTlCOzs7ZUFDU2g5QixPQURibTdCLE9BQ1E3NUIsSUFEUjY1QjtXQUVBLGdCQUxTcnlCO1dBS2dCLG9CQUxoQkEsSUFHTGswQjtXQUdKLGVBTlNsMEIsSUFJRHhIO1dBRWdCLGdCQU5md0g7ZUFHVHF5QixJQUNhbjdCLE9BRFRnOUI7OztlQUtjLzhCLE9BTGxCazdCLE9BS2E1NUIsTUFMYjQ1QjtXQU1BLGdCQVRTcnlCO1dBU2dCLG9CQVRoQkEsSUFHTGswQjtXQU9KLGVBVlNsMEIsSUFRSXZIO1dBRVcsZ0JBVmZ1SDtlQUdUcXlCLElBS2tCbDdCLE9BTGQrOEI7OztlQVVtQjk4QixPQVZ2Qmk3QixPQVVpQjM1QixLQVZqQjI1QixPQVVZMTVCLE1BVlowNUIsT0FVS3o1QixNQVZMeTVCO1dBL0dKLGdCQTRHYXJ5QjtXQTNHYixvQkEyR2FBLElBR0xrMEI7V0E3R1Isa0JBMEdhbDBCLElBYUpwSDtXQXRIVCxlQXlHYW9ILElBYUdySDtXQXJIaEIsaUJBd0dhcUgsSUFhUXRIO1dBcEhELGdCQXVHUHNILElBdkdPLGNBb0hYcEg7ZUFWTHk1QixJQVV1Qmo3QixPQVZuQjg4Qjs7O2VBYXFCNzhCLE9BYnpCZzdCLE9BYW1CeDVCLE9BYm5CdzVCLE9BYWN2NUIsTUFiZHU1QixPQWFPdDVCLFFBYlBzNUI7V0FjQSxrQkFqQlNyeUIsSUFHTGswQixTQWFHbjdCLFFBQU9ELE1BQUtEO2VBYm5CdzVCLElBYXlCaDdCLE9BYnJCNjhCOzs7ZUFnQnlCNThCLE9BaEI3Qis2QixPQWdCdUJyNUIsT0FoQnZCcTVCLE9BZ0JrQnA1QixNQWhCbEJvNUIsT0FnQlduNUIsUUFoQlhtNUI7V0FpQkEsa0JBcEJTcnlCLElBR0xrMEIsU0FnQk9oN0IsUUFBT0QsTUFBS0Q7ZUFoQnZCcTVCLElBZ0I2Qi82QixPQWhCekI0OEI7OztlQW1CcUIzOEIsT0FuQnpCODZCLE9BbUJtQmw1QixPQW5CbkJrNUIsT0FtQmNqNUIsTUFuQmRpNUIsT0FtQk9oNUIsUUFuQlBnNUI7V0FvQkEsa0JBdkJTcnlCLElBR0xrMEIsU0FtQkc3NkIsUUFBT0QsTUFBS0Q7ZUFuQm5CazVCLElBbUJ5Qjk2QixPQW5CckIyOEI7OztlQXNCcUIxOEIsT0F0QnpCNjZCLE9Bc0JtQi80QixPQXRCbkIrNEIsT0FzQmM5NEIsTUF0QmQ4NEIsT0FzQk83NEIsTUF0QlA2NEI7V0EvRUosZ0JBNEVhcnlCO1dBM0ViLG9CQTJFYUEsSUFHTGswQjtXQTdFUixrQkEwRWFsMEIsSUF5QkZ4RztXQWxHWCxlQXlFYXdHLElBeUJLekc7V0FqR2xCLGlCQXdFYXlHLElBeUJVMUc7V0FoR0gsZ0JBdUVQMEcsSUF2RU8sZ0JBZ0dUeEc7ZUF0QlA2NEIsSUFzQnlCNzZCLE9BdEJyQjA4Qjs7O2VBZ0NPeDhCLE9BaENYMjZCLE9BZ0NNNTRCLE1BaENONDRCO1dBaUNBLGdCQXBDU3J5QjtXQW9DZ0Isb0JBcENoQkEsSUFHTGswQjtXQWtDSixlQXJDU2wwQixJQW1DSHZHO1dBRWtCLGdCQXJDZnVHO2VBR1RxeUIsSUFnQ1czNkIsT0FoQ1B3OEI7OztlQW1ERXQ4QixPQW5ETnk2QjtXQW9EQSxrQkF2RFNyeUI7ZUFHVHF5QixJQW1ETXo2Qjs7O2VBSWVDLFFBdkRyQnc2QixPQXVEZ0IzNEIsSUF2RGhCMjRCO1dBd0RBLHNCQTNEU3J5QixJQTBET3RHO2VBdkRoQjI0QixJQXVEcUJ4NkI7OztlQUdGQyxRQTFEbkJ1NkIsT0EwRGMrQyxNQTFEZC9DO1dBMkRBLG9CQTlEU3J5QixJQTZES28xQjtlQTFEZC9DLElBMERtQnY2Qjs7O2VBSVNDLFFBOUQ1QnM2QixPQThEcUJ6NEIsTUE5RHJCeTRCLE9BOERZSCxRQTlEWkc7V0ErREEsZ0JBbEVTcnlCO1dBa0VnQixvQkFsRWhCQSxJQUdMazBCO1dBZ0VKLGVBbkVTbDBCLElBaUVHa3lCO1dBRWdCLGdCQW5FbkJseUI7V0FvRVQsYUFwRVNBLElBaUVZcEc7V0FHRyxnQkFwRWZvRztXQW9Fd0MsZ0JBcEV4Q0E7ZUFHVHF5QixJQThENEJ0NkIsUUE5RHhCbThCOzs7ZUFtRTBCbDhCLFFBbkU5QnE2QixPQW1FdUJ2NEIsUUFuRXZCdTRCLE9BbUVjQyxVQW5FZEQ7V0FvRUEsZ0JBdkVTcnlCO1dBdUVnQixvQkF2RWhCQSxJQUdMazBCO1dBcUVKLGVBeEVTbDBCLElBc0VLc3lCO1dBRWMsZ0JBeEVuQnR5QjtXQXlFVCxhQXpFU0EsSUFzRWNsRztXQUdDLGdCQXpFZmtHO1dBeUV3QyxnQkF6RXhDQTtlQUdUcXlCLElBbUU4QnI2QixRQW5FMUJrOEI7OztlQW9DRWw2QixRQXBDTnE0QjtXQXFDQSxnQkF4Q1NyeUI7V0F3Q2dCLG9CQXhDaEJBLElBR0xrMEI7V0FzQ0osZ0JBekNTbDBCO2VBR1RxeUIsSUFvQ01yNEIsUUFwQ0ZrNkI7OztlQXVDRWo2QixRQXZDTm80QjtXQXdDQSxnQkEzQ1NyeUI7V0EyQ2dCLG9CQTNDaEJBLElBR0xrMEI7V0F5Q0osZ0JBNUNTbDBCO2VBR1RxeUIsSUF1Q01wNEIsUUF2Q0ZpNkI7OztlQXlGd0JoNkIsUUF6RjVCbTRCLE9BeUZnQmw0QixXQXpGaEJrNEI7V0EwRkEsc0JBN0ZTcnlCLElBNkZpQix5QkFEVjdGO2VBekZoQms0QixJQXlGNEJuNEI7OztlQUdBRSxRQTVGNUJpNEIsT0E0RmdCaDRCLFdBNUZoQmc0QjtvQkE0RmdCaDRCO3VDQUVPczZCO2FBQ3JCLGtCQWxHTzMwQjthQWtHcUIsa0JBbEdyQkEsSUFpR2MyMEI7O3lCQUZQdDZCLGNBSU9nN0I7YUFDckIsa0JBcEdPcjFCO2FBb0dxQixrQkFwR3JCQSxJQW1HY3ExQjtlQWhHdkJoRCxJQTRGNEJqNEI7OztlQTVDckJFLFFBaERQKzNCO1dBaURBLGdCQXBEU3J5QjtXQW9EZ0Isb0JBcERoQkEsSUFHTGswQjtXQWtESixnQkFyRFNsMEI7ZUFHVHF5QixJQWdETy8zQixRQWhESDQ1Qjs7O2VBeUVnQzM1QixRQXpFcEM4M0IsT0F5RTBCNzNCLFNBekUxQjYzQixPQXlFZTUzQixVQXpFZjQzQjtXQTBFQSxnQkE3RVNyeUI7V0E2RWdCLG9CQTdFaEJBLElBR0xrMEI7V0EyRUosZUE5RVNsMEIsSUE0RU12RjtXQXRTbkI7WUE0Q0k2RjtzQkFBV04sSUFBSWxKO2VBQVUsSUFHekJpSCxFQUh5QixZQUFWakg7ZUFBVSxjQUd6QmlIO3lCQUZPLGdCQURJaUMsUUFDSixnQkFESUE7K0JBR1hqQzsyQkFETyxnQkFGSWlDLFFBRUosZ0JBRklBOzBCQUdKLGdCQUhJQSxJQUdYakMsRUFBNkI7V0FFakMsZ0JBeUthaUM7V0ExTmI7WUFtREs7NEJBbVB5QnhGO2dCQWxQckIsZ0JBc0tJd0YsUUF0S3FCLGFBa1BKeEY7O1lBclM1Qjs7d0JBQUkrNkIsU0FBU3gzQjtpQkFDaUM7NEJBRGpDQTtrQkFDZSxXQURmQTtrQkFFWCx5QkFGV0E7aUJBRVg7a0JBQ1E7NENBRkowM0I7bUJBRUksVUFBNkIsb0JBRnpCRDs7OztpQkFEZCxXQUdnRTtzQkFINUREO1lBQUo7V0FJRyxnQkFBa0IsZ0JBcU5WdjFCO1dBMU5iLElBUWtCbEo7O1dBQ2hCO2dCQURnQkE7ZUFFWCx5QkFBbUIsWUFGUkE7aUJBR1QsUUFIU0E7ZUFLVixzQkFMVUEsR0FLVjs7bUNBQ00sV0E0TURrSjs7OzJDQTNNSSxRQVBDbEo7O2VJOE1aO2lCSnRNRyxJQUNZb1gsSUFUSHBYO2lCQVViLHlCQUFtQixZQURIb1g7bUJBZ0JqQixXQXlMU2xPLElBek1Ra087bUJBZ0JqQixRQWhCaUJBLFlBVEhwWDs7aUJBUVQ7a0JBR0Msb0JBRldvWDtrQkFFWDs7OztvQkFFSixXQXFNT2xPLFNBck1QLFdBcU1PQTs7Ozs7O3FCQW5NWSx5QkFBb0IsWUFOeEJrTzt1QkFPZixXQWtNT2xPLElBek1Ra087dUJBT2YsUUFQZUEsWUFUSHBYOzs7Ozs7bUJBa0JELHlCQUFvQixZQVRoQm9YO3FCQVVmLFdBK0xPbE8sSUF6TVFrTztxQkFXZixXQThMT2xPLElBek1Ra087cUJBV2YsUUFYZUEsWUFUSHBYOzttQkF1QlosTUFkZW9YLFlBY2YsSUFkZUEsWUFtQkZ3bkI7bUJBQ2pCO3FCQUFrQixXQUREQSxPQUNDLG9CQUFvQixZQURyQkE7dUJBT2YsUUFQZUE7cUJBRWYsV0FvTFMxMUIsSUF0TEk4dkI7cUJBR2IsV0FtTFM5dkI7cUJBbExULFdBa0xTQSxJQXRMTTAxQjtxQkFJZixHQUplQSxXQUtDLFFBTERBLFlBNUJENStCOzthQURiLGdCQUFrQixnQkFtTlZrSjthQXRRWHd6QixnQkFzUVd4ekI7aUJBR1RxeUIsSUF5RW9DOTNCLFFBekVoQzI1Qjs7O2VBNkV1Qng1QixRQTdFM0IyM0IsT0E2RWtCMTNCLFFBN0VsQjAzQjtXQThFQSxnQkFqRlNyeUI7V0FpRmdCLG9CQWpGaEJBLElBR0xrMEI7V0F0T29CLE9BbVROdjVCOzs7O1dBRWxCLGdCQWxGU3FGO2VBR1RxeUIsSUE2RTJCMzNCLFFBN0V2Qnc1Qjs7O2VBaUZXdDVCLFFBakZmeTNCO1dBa0ZBLGdCQXJGU3J5QjtXQXFGZ0Isb0JBckZoQkEsSUFHTGswQjtXQW1GSixzQkF0RlNsMEI7ZUFHVHF5QixJQWlGZXozQixRQWpGWHM1Qjs7O1dBc0Z3QjtZQURScjVCLFFBckZwQnczQjtZQXFGZXYzQixJQXJGZnUzQjtZQXNGNEIsdUNBRGJ2M0IsSUFBS0Q7WUFDUTtZQXRGNUJ3M0I7WUFBSTZCOzs7V0EyQ1U7WUFESW41QixRQTFDbEJzM0I7WUEwQ1FwM0IsTUExQ1JvM0I7WUEyQ2MseUJBRE5wM0I7O1dBQ007aUJBQWR5MEI7YUFDRTsrQkEvQ08xdkI7ZUErQ2tCLG9CQS9DbEJBLElBR0xrMEI7ZUE2Q0YsZ0JBaERPbDBCO2VBZ0RQLFNBRkYwdkI7OztXQUFjLElBM0NkMkMsSUEwQ2tCdDNCLFFBMUNkbTVCO29CQStHVzthQVdiMkI7O09BdUJZOztPQXZCWjtnQkFNWSxJQUFSNytCLGNBQWdCLGVBQWhCQTtnQkFPVSxJQUFSQyxnQkFBa0IsZUFBbEJBO2dCQU5LLElBQVJDLGdCQUFlLGVBQWZBO2dCQUNVLElBQVJDLGdCQUFpQixlQUFqQkE7Z0JBRVksSUFBUkMsZ0JBQXFCLGVBQXJCQTtnQkFESSxJQUFSQyxnQkFBaUIsZUFBakJBO2dCQUVRLElBQVJDLGdCQUFpQixlQUFqQkE7Z0JBQ08sSUFBUkMsZ0JBQWdCLGVBQWhCQTtvQkFPV0MsZ0JBQUpDLFlBQ0ksVUFESkEsR0FDSSxLQURBRDs7Y0FFUUUsZ0JBQUxVLGFBQUxUO1VBQ1UsVUFETFMsSUFBTFQsSUFDVSxLQURBRDtpQkFOVixJQUFSRSxnQkFBaUIsZ0JBQWpCQTtpQkFEUSxJQUFSQyxpQkFBaUIsZ0JBQWpCQTtpQkFFTSxJQUFSQyxpQkFBZSxnQkFBZkE7aUJBQ1csSUFBUkMsaUJBQWtCLGdCQUFsQkE7aUJBQ2dCLElBQVJDLGlCQUEwQixnQkFBMUJBLFVBS1U7YUFnSDVCODlCLE1BV0VuK0IsSUFBSTJQO01KbnlCWDtNSW15QmtCLFVBQVgzUDtpQkFBSTJQO1FBOEN3Qjs7ZUE5Q3hCQTs7Ozs7Ozs7a0JBK0NhOztPQS9DTixPQUFYM1A7OztvQkFBSTJQOztvQkFDMEIsSUFBVHl1QixNQURqQnp1QixTQUNrQyxxQkFBakJ5dUI7Ozs7Ozs7Ozs7Ozs4QkFEckJwK0I7b0JBQUkyUDs7b0JBRThCLElBQVQwdUIsUUFGckIxdUIsU0FFd0MscUJBQW5CMHVCOzs7Ozs7Ozs7Ozs7OEJBRnpCcitCO29CQUFJMlA7Ozs7b0JBSXdCLElBQVQydUIsUUFKZjN1QixTQUkrQixxQkFBaEIydUI7Ozs7Ozs7Ozs7Ozs4QkFKbkJ0K0I7b0JBQUkyUDs7OztvQkFLNEIsSUFBVDR1QixRQUxuQjV1QixTQUtxQyxxQkFBbEI0dUI7Ozs7Ozs7Ozs7Ozs4QkFMdkJ2K0I7b0JBQUkyUDs7OztvQkFPb0MsSUFBVDZ1QixRQVAzQjd1QixTQU9pRCxxQkFBdEI2dUI7Ozs7Ozs7Ozs7Ozs4QkFQL0J4K0I7b0JBQUkyUDs7OztvQkFNNEIsSUFBVDh1QixRQU5uQjl1QixTQU1xQyxxQkFBbEI4dUI7Ozs7Ozs7Ozs7Ozs4QkFOdkJ6K0I7b0JBQUkyUDs7OztvQkFRNEIsSUFBVCt1QixRQVJuQi91QixTQVFxQyxxQkFBbEIrdUI7Ozs7Ozs7Ozs7Ozs4QkFSdkIxK0I7b0JBQUkyUDs7OztvQkFHMEIsSUFBVGd2QixRQUhqQmh2QixTQUdrQyxxQkFBakJndkI7Ozs7Ozs7Ozs7Ozs4QkFIckIzK0I7b0JBQUkyUDs7Ozs7Y0FnQ3dCLElBRGtCaXZCLFFBL0IxQ2p2QixTQStCcUNsUCxJQS9CckNrUCxTQWdDd0IsZ0JBRGtCaXZCO2NBQ2pDLHFCQUQ0Qm4rQjs7Ozs7OztzQkFFckI7OzsrQkFqQ3BCVDtvQkFBSTJQOzs7Ozs7Y0FzQ0c7ZUFEb0JrdkIsUUFyQ3ZCbHZCO2VBcUNpQm12QixLQXJDakJudkI7ZUFxQ1dvdkIsS0FyQ1hwdkI7ZUFzQ0csU0FBTSxXQURFb3ZCO2VBRUUsc0JBRGZqL0I7ZUFDZTs7Y0FDUixXQURKby9CO2NBRUksV0FGR0Q7Y0FHZSxlQUxOSCxLQUtNLFdBTEFEOzs7Ozs7O3VCQU1MOzs7bUJBM0N0QjcrQjtvQkFBSTJQO1lBVTRCLElBQVR3dkIsUUFWbkJ4dkIsU0FVcUMsc0JBQWxCd3ZCO1VBQ1I7OytCQVhmbi9CO29CQUFJMlA7Ozs7O3FCQWM0QixJQUFUeXZCLFNBZG5CenZCLFNBY3FDLHNCQUFsQnl2Qjs7dUJBQ1I7OzsrQkFmZnAvQjtvQkFBSTJQOzs7Ozs7cUJBa0J3QixJQUFUMHZCLFNBbEJmMXZCLFNBa0IrQixzQkFBaEIwdkI7O3VCQUNOOzs7K0JBbkJici9CO29CQUFJMlA7Ozs7Ozs7cUJBc0I4QixJQUFUMnZCLFNBdEJyQjN2QixTQXNCd0Msc0JBQW5CMnZCOzt1QkFDVDs7OytCQXZCaEJ0L0I7b0JBQUkyUDs7Ozs7Ozs7cUJBMkJOLElBRDJDNHZCLFNBMUJyQzV2QixTQTJCWSxzQkFEeUI0dkI7O3VCQUVqQjtNSS9TdEI7ZUorUmE7ZUFJQTtlQUlGO2VBSUc7ZUFLUTtlQUtKO2VBVUU7Z0JBSUwsOEJBQVk7YUF6SzNCUDs7UUFTSjs4QkFHYSxRQUFJO1NBSGpCLHFCQUVhLFFBQUk7U0FGakIscUJBQ2EsUUFBSTtRQURqQiwwQkFBYSxRQUFJOztPQVRiOztVQWNKOztXQUFxQixvQkFEYjMvQjtXQUNhOzs7O2dDQUVHLFdBRmhCcWdDLE1BRWdCLFFBQWU7VUFGbEIsMEJBQ0csV0FEcEJDLE1BQ29CLFFBQWUsT0FEM0JGLEdBQUlEOztVQUtoQjs7V0FBcUIsc0JBRFhsZ0M7V0FDVzs7OztnQ0FFRyxXQUZoQndnQyxRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFLaEI7O1dBQXFCLHNCQURkcmdDO1dBQ2M7Ozs7Z0NBRUcsV0FGaEIyZ0MsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBS2hCOztXQUFxQixzQkFEWnhnQztXQUNZOzs7O2dDQUVHLFdBRmhCOGdDLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQVVoQjs7V0FBcUIsc0JBRFIzZ0M7V0FDUTs7OztnQ0FFRyxXQUZoQmloQyxRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFMaEI7O1dBQXFCLHNCQURaOWdDO1dBQ1k7Ozs7Z0NBRUcsV0FGaEJvaEMsUUFFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsUUFDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBVWhCOztXQUFxQixzQkFEWmpoQztXQUNZOzs7O2dDQUVHLFdBRmhCdWhDLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtoQjs7V0FBcUIsc0JBRGJwaEM7V0FDYTs7OztnQ0FFRyxXQUZoQjBoQyxRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFpQ2hCOztXQUFxQixzQkFERHZoQztXQUNDOzs7O2dDQUVHLFdBRmhCNmhDLFFBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFFBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtLO1dBRE16aEM7V0FBTFU7V0FBTFQ7V0FDSSxzQkFETUQ7V0FDTjs7OztXQUNaLFNBQU0sS0FGRUMsS0FBS1M7V0FHRCxzQkFEakJYO1dBQ2lCOzs7O2dDQUlHLFdBSlJraUMsTUFJOEIsV0FOOUJKLFFBTThCLFFBQWU7V0FKeEMscUJBR0csV0FMWkMsUUFLa0MsV0FIbENJLE1BR2tDLFFBQWU7V0FIeEMscUJBRUcsV0FGaEJDLE1BRXNDLFdBSnRDSixRQUlzQyxRQUFlO1VBRnhDOztvQkFDRyxXQUhwQkMsUUFHMEMsV0FEMUNJLE1BQzBDLFFBQWU7Ozs7O1VBOUI3RDs7V0FBcUIsdUJBRFpsaUM7V0FDWTs7OztnQ0FFRyxXQUZoQnFpQyxRQUVnQixRQUFlO1VBRmxCO2tDQUNHLFdBRHBCQyxRQUNvQixRQUFlOztrQkFEM0JGO2tCQUFJRDs7VUFMaEI7O1dBQXFCLHVCQURabGlDO1dBQ1k7Ozs7Z0NBRUcsV0FGaEJ3aUMsU0FFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsU0FDb0IsUUFBZTs7a0JBRDNCRjtrQkFBSUQ7O1VBVWhCOztXQUFxQix1QkFEZHJpQztXQUNjOzs7O2dDQUVHLFdBRmhCMmlDLFNBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFNBQ29CLFFBQWU7O2tCQUQzQkY7a0JBQUlEOztVQUtoQjs7V0FBcUIsdUJBRFh4aUM7V0FDVzs7OztnQ0FJRyxXQUpSNGlDLFNBSVEsUUFBZTtXQUpsQixxQkFHRyxXQUhaQyxTQUdZLFFBQWU7V0FIbEIscUJBRUcsV0FGaEJDLFNBRWdCLFFBQWU7VUFGbEI7a0NBQ0csV0FEcEJDLFNBQ29CLFFBQWU7Ozs7O1VBS3ZDOztXQUFxQix1QkFESDlpQztXQUNHOzs7O2dDQUlHLFdBSlIraUMsU0FJUSxRQUFlO1dBSmxCLHFCQUdHLFdBSFpDLFNBR1ksUUFBZTtXQUhsQixxQkFFRyxXQUZoQkMsU0FFZ0IsUUFBZTtVQUZsQjtrQ0FDRyxXQURwQkMsU0FDb0IsUUFBZTs7O3dCQWdCdUI7YUF1TDlEQyx5QkFFRXppQyxLQUFLa0I7TUFBUyxjQUFkbEIsMEJBQUtrQixrQkFHMEI7YUFiakN3aEMsdUJBRUU1aUMsSUFBSW9CO01BQVMsY0FBYnBCLGlCQUFJb0IsWUFBSnBCLE9BQUlvQixlQUd5QjthQXJDL0J5aEMsZ0JBR0FwZ0MsTUFBTXJCO01BQVMsR0FBZnFCO1FBRXFCLElBQVRxZ0MsUUFGWnJnQyxTQUU0QiwyQkFBaEJxZ0MsUUFGTjFoQztNQUNTLE9BRFRBLEtBRW1EO2FBOUR6RDJoQyxhQUVBM2hDO01KLzFCTCxJSSsxQktFO01BQVM7aUJBQVRBO1FBcUQ4Qjs7UUFyRHJCLE9BQVRBO2lCQTJCOEIsSUFBekI5QyxLQTNCTDhDLFdBMkJzQyx1QkFBakM5QztpQkFDeUIsSUFBcEJDLE9BNUJWNkMsV0E0QnNDLHVCQUE1QjdDOztlQTNCR0MsT0FEYjRDLFdBQ1F0QixJQURSc0I7V0FFc0MsOEJBRDlCdEIsT0FDOEIsYUFEekJ0Qjs7ZUFFS0MsT0FIbEIyQyxXQUdhckIsTUFIYnFCO1dBSXNDLDhCQUR6QnJCLFNBQ3lCLGFBRHBCdEI7O1dBSUo7WUFES0MsT0FObkIwQztZQU1hcEIsS0FOYm9CO1lBTVFuQixNQU5SbUI7WUFPYyxxQkFESzFDO1lBRUwsaUNBRkRzQixRQUNUOGlDO1dBQ1UsOEJBRk43aUMsTUFFSjhpQzs7V0FHVTtZQURPcGtDLE9BVnJCeUM7WUFVZWpCLE9BVmZpQjtZQVVVaEIsTUFWVmdCO1lBV2MsdUJBRE96QztZQUVQLG1DQUZDd0IsVUFDWDZpQztXQUNVLDhCQUZKNWlDLE1BRU42aUM7O1dBR1U7WUFEV3JrQyxPQWR6QndDO1lBY21CZCxPQWRuQmM7WUFjY2IsTUFkZGE7WUFlYyx1QkFEV3hDO1lBRVgsbUNBRkswQixVQUNmNGlDO1dBQ1UsOEJBRkEzaUMsTUFFVjRpQzs7V0FHVTtZQURPdGtDLE9BbEJyQnVDO1lBa0JlWCxPQWxCZlc7WUFrQlVWLE1BbEJWVTtZQW1CYyx1QkFET3ZDO1lBRVAsbUNBRkM0QixVQUNYMmlDO1dBQ1UsOEJBRkoxaUMsTUFFTjJpQzs7V0FHVTtZQURPdmtDLE9BdEJyQnNDO1lBc0JlUixPQXRCZlE7WUFzQlVQLE1BdEJWTztZQXVCYyx1QkFET3RDO1lBRVAsbUNBRkM4QixVQUNYMGlDO1dBQ1UsOEJBRkp6aUMsTUFFTjBpQzs7ZUFLT3ZrQyxPQTdCWG9DLFdBNkJNTCxNQTdCTks7V0E4QnNDLDhCQURoQ0wsU0FDZ0MsYUFEM0IvQjtrQkFZbUIsWUF6QzlCb0M7a0JBMEM4QixZQTFDOUJBO2tCQTJDOEIsWUEzQzlCQTs7ZUFvQ21CbEMsT0FwQ25Ca0MsV0FvQ2VyQyxHQXBDZnFDO1dBcUNtQixVQURKckMsR0FDSSxhQURBRzs7ZUFFRUMsUUF0Q3JCaUMsV0FzQ2lCdWlDLEtBdENqQnZpQztXQXVDeUIsVUFEUnVpQyxVQUNRLGFBREp4a0M7a0JBUFMsSUFBeEJDLFFBL0JOZ0MsV0ErQnVDLHdCQUFqQ2hDO2tCQUN3QixJQUF4QkMsUUFoQ04rQixXQWdDdUMsd0JBQWpDL0I7a0JBaUJ3QixZQWpEOUIrQjs7V0FtRGtEO1lBRHRCOUIsUUFsRDVCOEI7WUFrRGdCTyxXQWxEaEJQO1lBbURrRCxrQkFEdEI5QjtXQXpEVixTQXlERnFDO29DQXhERWc0QixrQkFJbEJrSixhQUprQmxKOzs7cUJBd0RGaDRCO2FBdkRFdTdCO2tCQUdsQjJGLGFBSGtCM0Y7a0JJdlJkMzlCO2tCSjhUMEIsSUFBdkIrQixRQWxDUEYsV0FrQ3dDLHdCQUFqQ0U7a0JBV3VCLElBQVRDLFFBN0NyQkgsV0E2Q3dDLHVCQUFuQkc7a0JBQ1MsSUFBVEMsUUE5Q3JCSixXQThDcUMsdUJBQWhCSTtrQkFDUyxJQUFmRSxRQS9DZk4sV0ErQ3NDLHVCQUF2Qk07O2VBQ0tFLFFBaERwQlIsV0FnRGVnQixJQWhEZmhCO1dBb0VXLFVBcEJJZ0I7WUFvQkosT0FwQklBO3lCQWhEZmhCLFFBZ0RvQlE7eUJBaERwQlIsUUFnRG9CUTtxQkFpQ2lDLHdCQWpDakNBOzBCQWhEcEJSLFFBZ0RvQlE7O1lBb0JULE9BcEJJUTt5QkFoRGZoQixRQWdEb0JRO3lCQWhEcEJSLFFBZ0RvQlE7eUJBaERwQlIsUUFnRG9CUTt5QkFoRHBCUixRQWdEb0JRO3lCQWhEcEJSLFFBZ0RvQlE7eUJBaERwQlIsUUFnRG9CUTt5QkFoRHBCUixRQWdEb0JRO3lCQWhEcEJSLFFBZ0RvQlE7eUJBaERwQlIsUUFnRG9CUTs7ZUFnQ2UsSUFBVmlpQyxRQWhDVnpoQztlQWdDdUMsb0JBQTdCeWhDLFFBQTZCLGFBaENsQ2ppQzswQkFoRHBCUixRQWdEb0JROzBCQWhEcEJSLFFBZ0RvQlE7O2VBZkZDLFFBakNsQlQsV0FpQ1FtQixNQWpDUm5CO1dBaUNvRCx1QkFBNUNtQixNQUE0QyxhQUFsQ1YsVUFvQndCOzs7O2FBMEQxQ2lpQyxhQUdBaGtDLElBQUk4TztNQUFTLFVBQWI5TztPQUNpQixZQURiOE87O1FBQVMsU0FBYjlPO2NBRW9CaWtDLEVBRnBCamtDLE9BRWF3N0IsTUFGYng3QixvQkFFYXc3QixNQUFPeUksR0FGaEJuMUI7O2NBR3NCdFEsS0FIdEJzUSxTQUdRK3NCLFFBSFo3N0Isb0JBR1k2N0IsU0FBY3I5QjtRQUNyQixvQkFBbUI7YUFLeEIwbEMsYUFHQWxrQyxJQUFJRSxLQUFLa0I7TUFBcUIsdUJBQTlCcEIsSUFBU29CO01BQXFCLFVBQTFCbEI7Ozs7Z0JBSzBDMUIsYUFBWnlCLGlDQUFZekI7VUFFZjtZQU5PQyxnQkFBTDBCOzBCQUFLMUI7TUFEUixJQUdXQyxnQkFBTDRCLGVBQXRCbVMsRUFIVnZTO2dCQUdnQ0ksU0FBdEJtUyxHQUEyQi9ULE9BSVM7YUEwTWxEeWxDLCtCQUlBNUgsVUFBVTFDLElBQUkvcUI7TUFBUyxVQUF2Qnl0QjtPQTBFNkIsNEJBMUVuQjFDLElBQUkvcUI7O09BQVMsT0FBdkJ5dEI7O29CQUFjenRCO1lBR1o7YUFGOEJ1MUIsV0FEbEJ2MUI7YUFDTncxQixlQURSL0g7YUFHRTs2Q0FGTStILGVBREV6SyxJQUNzQndLO2FBRTlCOzt5QkFEaUJFLGtCQUFpQm5IOzs7b0JBRnRCdHVCO1lBT1o7YUFGa0MwMUIsYUFMdEIxMUI7YUFLSjIxQixpQkFMVmxJO2FBT0U7O2dCQUZRa0ksaUJBTEE1SyxJQUswQjJLO2FBRWxDOzt5QkFEaUJFLGtCQUFpQi9IOzs7b0JBTnRCN3RCO1lBV1o7YUFGNEI2MUIsYUFUaEI3MUI7YUFTUDgxQixpQkFUUHJJO2FBV0U7O2dCQUZLcUksaUJBVEcvSyxJQVNvQjhLO2FBRTVCOzt5QkFEaUJHLGtCQUFpQkQ7OztvQkFWdEIvMUI7WUFlWjthQUZnQ2kyQixhQWJwQmoyQjthQWFMazJCLGlCQWJUekk7YUFlRTs7Z0JBRk95SSxpQkFiQ25MLElBYXdCa0w7YUFFaEM7O3lCQURpQkcsa0JBQWlCRDs7O29CQWR0Qm4yQjtZQW1CWjthQUZ3Q3EyQixhQWpCNUJyMkI7YUFpQkRzMkIsaUJBakJiN0k7YUFtQkU7O2dCQUZXNkksaUJBakJIdkwsSUFpQmdDc0w7YUFFeEM7O3lCQURpQkcsa0JBQWlCRDs7O29CQWxCdEJ2MkI7WUF1Qlo7YUFGZ0N5MkIsYUFyQnBCejJCO2FBcUJMMDJCLGlCQXJCVGpKO2FBdUJFOztnQkFGT2lKLGlCQXJCQzNMLElBcUJ3QjBMO2FBRWhDOzt5QkFEaUJHLG1CQUFpQkQ7OztvQkF0QnRCMzJCO1lBMkJaO2FBRmdDNjJCLGFBekJwQjcyQjthQXlCTDgyQixrQkF6QlRySjthQTJCRTs7Z0JBRk9xSixrQkF6QkMvTCxJQXlCd0I4TDthQUVoQzs7eUJBRGlCRyxtQkFBaUJEOzs7b0JBMUJ0Qi8yQjtZQStCWjthQUY4QmkzQixhQTdCbEJqM0I7YUE2Qk5rM0Isa0JBN0JSeko7YUErQkU7O2dCQUZNeUosa0JBN0JFbk0sSUE2QnNCa007YUFFOUI7O3lCQURpQkcsbUJBQWlCRDs7O29CQTlCdEJuM0I7O2FBbURjcTNCLGFBbkRkcjNCO2FBbURDczNCLFdBbkREdDNCO2FBa0RhdTNCLGtCQWxEM0I5SjthQWtEZStKLGFBbERmL0o7WUFvREcsb0JBRlkrSixpQkFDQUY7YUFDdUM7WUFFcEQ7OztnQkFKeUJDLGtCQWxEakJ4TSxJQW1Ea0JzTTthQUcxQjs7eUJBSGFDLFdBRUlJLG1CQUFpQkQ7OztvQkFyRHRCejNCO1lBMkRtQzthQUZOMjNCLGFBekQ3QjMzQjthQXlEZ0I0M0IsYUF6RGhCNTNCO2FBeURHNjNCLFdBekRINzNCO2FBd0Q2QjgzQixrQkF4RDNDcks7YUF3RDhCc0ssYUF4RDlCdEs7YUF3RGlCdUssYUF4RGpCdks7YUEyRGlELGtCQUZoQ29LO1lBRWQsb0JBQVUsVUFISUc7YUFJWjtZQUQ0QyxZQUVBLFVBSm5CSjtZQUkzQixvQkFBVSxVQUxpQkc7YUFNekI7WUFINEM7YUFJaEMsa0JBQU0sS0FOTkYsWUFBYUQ7YUFPWCxzQkFEZmxLO2FBQ2U7O1lBQ1IsV0FESjZCO1lBRUksV0FGR0Q7WUFMbUM7YUFTL0M7O2dCQUFpQyxVQVpRd0ksbUJBeERqQy9NLElBeURpQzRNO2FBV3pDOztZQUc4Qjt1QkFkZkUsV0FBYUQsYUFjRSxLQUpiTTtvQkFBaUJEOzs7b0JBbkV0Qmo0QjtZQW1DWjthQUZnQ200QixhQWpDcEJuNEI7YUFpQ0xvNEIsa0JBakNUM0s7YUFtQ0U7O2dCQUZPMkssa0JBakNDck4sSUFpQ3dCb047YUFFaEM7OzBCQURpQkcsbUJBQWlCRDs7O29CQWxDdEJyNEI7WUF1Q1o7YUFGZ0N1NEIsY0FyQ3BCdjRCO2FBcUNMdzRCLGtCQXJDVC9LO2FBdUNFOztnQkFGTytLLGtCQXJDQ3pOLElBcUN3QndOO2FBRWhDOzswQkFEaUJHLG1CQUFpQkQ7OztvQkF0Q3RCejRCO1lBMkNaO2FBRmtDMjRCLGNBekN0QjM0QjthQXlDSjQ0QixrQkF6Q1ZuTDthQTJDRTs7Z0JBRlFtTCxrQkF6Q0E3TixJQXlDMEI0TjthQUVsQzs7MEJBRGlCRyxtQkFBaUJEOzs7b0JBMUN0Qjc0QjtZQStDWjthQUZrRCs0QixjQTdDdEMvNEI7YUE2Q0lnNUIsa0JBN0NsQnZMO2FBK0NFOztnQkFGZ0J1TCxrQkE3Q1JqTyxJQTZDMENnTzthQUVsRDs7MEJBRGlCRyxtQkFBaUJEOzs7TUE2Qi9CLG1CQUFtQjthQXpReEIzRCxnQkFNRXZLLElBNElNejRCO01BNUlPLFVBQWJ5NEI7T0FtSDJCLFlBeUJyQno0Qjs7T0E1SU8sT0FBYnk0Qjs7b0JBNElNejRCO1lBMUkyQjthQURaaWpDLFdBMklmampDO2FBM0lINm1DLFNBREhwTzthQUVpQyxzQkFEOUJvTyxTQUFrQjVEO2FBQ1k7O3lCQUFoQmpILE9BQU05N0I7OztvQkEwSWpCRjtZQXZJMkI7YUFEUG9qQyxhQXdJcEJwakM7YUF4SUU4bUMsV0FKUnJPO2FBS2lDLHdCQUR6QnFPLFdBQWtCMUQ7YUFDTzs7eUJBQWhCN0gsT0FBTStHOzs7VUFHbkI7V0FET3lFLFdBUFh0TztXQU9NNzVCLElBUE42NUI7V0FRSSxxQkFERTc1QixJQXFJQW9CO1dBcElGOzs7WUFFSjs7YUFBbUMsd0JBSHhCK21DLFdBRXVCeEQ7YUFDQzs7OEJBQWhCRSxPQUFNbEI7VUFFRzs7VUFHeEI7V0FEWXlFLFdBZGhCdk87V0FjVzU1QixNQWRYNDVCO1dBZUkscUJBRE81NUIsTUE4SExtQjtXQTdIRjs7O1lBRUo7O2FBQW1DLHdCQUhuQmduQyxXQUVrQnJEO2FBQ0M7OzhCQUFoQkUsT0FBTXJCO1VBRUc7O1VBR3hCO1dBRGlCeUUsV0FyQnJCeE87V0FxQmUzNUIsS0FyQmYyNUI7V0FxQlUxNUIsTUFyQlYwNUI7V0FxQkd6NUIsTUFyQkh5NUI7V0FzQkkscUJBRE0xNUIsTUFBS0QsS0F1SFRrQjtXQXRIRjs7O1lBRStCO2FBREUrakM7YUFBYjlrQzthQUNXLHdCQUhkZ29DLFdBRWdCbEQ7YUFDRjs7eUJBSGhDL2tDLFdBRXFCQyxPQUNMZ2xDLE9BQU12QjtVQUVNOztVQUczQjtXQURtQndFLFdBNUJ2QnpPO1dBNEJpQnI1QixPQTVCakJxNUI7V0E0Qll2NUIsTUE1Qlp1NUI7V0E0Qkt0NUIsUUE1QkxzNUI7V0E2QkkscUJBRFF2NUIsTUFBS0UsT0FnSFhZO1dBL0dGOzs7WUFFK0I7YUFESW1rQzthQUFmNWtDO2FBQ1csd0JBSFoybkMsV0FFZ0IvQzthQUNKOzt5QkFIOUJobEMsYUFFbUJJLE9BQ0w4a0MsT0FBTTFCO1VBRU07O1VBRzNCO1dBRHVCd0UsV0FuQzNCMU87V0FtQ3FCLzRCLE9BbkNyQis0QjtXQW1DZ0JwNUIsTUFuQ2hCbzVCO1dBbUNTbjVCLFFBbkNUbTVCO1dBb0NJLHFCQURZcDVCLE1BQUtLLE9BeUdmTTtXQXhHRjs7O1lBRStCO2FBRFF1a0M7YUFBbkI2QzthQUNXLHlCQUhSRCxXQUVnQjVDO2FBQ1I7O3lCQUgxQmpsQyxhQUVlOG5DLE9BQ0wzQyxPQUFNNEM7VUFFTTs7VUFHM0I7V0FEbUJDLFdBMUN2QjdPO1dBMENpQjhPLE9BMUNqQjlPO1dBMENZajVCLE1BMUNaaTVCO1dBMENLaDVCLFFBMUNMZzVCO1dBMkNJLHNCQURRajVCLE1BQUsrbkMsT0FrR1h2bkM7V0FqR0Y7OztZQUUrQjthQURJMmtDO2FBQWY2QzthQUNXLHlCQUhaRixXQUVnQjNDO2FBQ0o7O3lCQUg5QmxsQyxhQUVtQituQyxPQUNMM0MsT0FBTTRDO1VBRU07O1VBRzNCO1dBRG1CQyxXQWpEdkJqUDtXQWlEaUJrUCxPQWpEakJsUDtXQWlEWTk0QixNQWpEWjg0QjtXQWlESzc0QixNQWpETDY0QjtXQWtESSxzQkFEUTk0QixNQUFLZ29DLE9BMkZYM25DO1dBMUZGOzs7WUFFK0I7YUFESStrQzthQUFmNkM7YUFDVyx5QkFIWkYsV0FFZ0IzQzthQUNKOzt5QkFIOUJubEMsV0FFbUJnb0MsT0FDTHpDLE9BQU0wQztVQUVNOztVQUczQjtXQURLQyxXQXhEVHJQO1dBd0RJNTRCLE1BeERKNDRCO1dBeURJLHNCQURBNTRCLE1Bb0ZFRztXQW5GRjs7O1lBRUo7O2FBQW1DLHlCQUgxQjhuQyxXQUV1QnpDO2FBQ0c7OzhCQUFoQk0sT0FBTW9DO1VBRUc7O1VBR0s7V0FEN0JDLFdBL0RKdlA7V0FnRWlDLHlCQUQ3QnVQLFdBNkVFaG9DO1dBNUUyQjs7d0JBQWhCK2xDLFFBQU1rQzs7VUFJVTtXQURkQyxZQW5FbkJ6UDtXQW1FYzM0QixJQW5FZDI0QjtXQW9FaUMseUJBRGR5UCxZQXlFYmxvQztXQXhFMkI7O3dCQURuQkYsSUFDR3FtQyxRQUFNZ0M7O1VBR1U7V0FEaEJDLFlBdEVqQjNQO1dBc0VZMTRCLElBdEVaMDRCO1dBdUVpQyx5QkFEaEIyUCxZQXNFWHBvQztXQXJFMkI7O3dCQURyQkQsSUFDS3dtQyxRQUFNOEI7O29CQXFFakJyb0M7O2FBakVtQjZsQyxhQWlFbkI3bEM7YUFqRU9tN0IsVUFpRVBuN0I7YUFsRXdCc29DLFlBMUU5QjdQO2FBMEVtQjJDLFlBMUVuQjNDO2FBMEVVSCxRQTFFVkc7WUE0RUMsb0JBRmtCMkMsZ0JBQ05EO2FBQ3FDO1lBQ2pCO3NDQUhIbU4sWUFDTHpDO2FBRVE7OzBCQUh2QnZOLFFBQ0c2QyxVQUVJd0wsUUFBTTRCOzs7b0JBK0RqQnZvQztZQTNEd0M7YUFETmltQyxjQTREbENqbUM7YUE1RFN3b0MsV0E0RFR4b0M7YUE3RDBCeW9DLFlBL0VoQ2hRO2FBK0VxQmlRLFlBL0VyQmpRO2FBK0VZQyxVQS9FWkQ7YUFpRjhDLGtCQUQvQitQO1lBQ2Qsb0JBQVUsVUFGVUU7YUFHckI7WUFEOEM7YUFHOUMseUJBTGdDRCxZQUtQLFVBSmV4QzthQUl4Qzs7MEJBTFl2TixVQUNHOFAsV0FHRUksUUFBTUQ7OztvQkF5RGpCM29DO1lBbkQyQjthQURWcW1DLGNBb0RqQnJtQzthQXBERjZvQyxZQXhGSnBRO2FBeUZpQyx5QkFEN0JvUSxZQUFtQnhDO2FBQ1U7OzBCQUFoQjBDLFFBQU1EOzs7b0JBbURqQjlvQztZQWhEMkI7YUFEVnltQyxjQWlEakJ6bUM7YUFqREZncEMsWUEzRkp2UTthQTRGaUMseUJBRDdCdVEsWUFBbUJ2QzthQUNVOzswQkFBaEJ5QyxRQUFNRDs7O1VBS1U7V0FESEUsWUFoRzlCMVE7V0FnR2N4OEIsZUFoR2R3OEI7V0FpR2lDLHlCQURIMFEsWUE0Q3hCbnBDO1dBM0MyQjs7d0JBRG5CL0QsZUFDR290QyxRQUFNRDs7Y0FFT0UsWUFuRzlCN1EsT0FtR2M4USxlQW5HZDlRO1VBNEg0QixTQXpCZDhRO1lBMkJtQjtzQkEzQm5CQTthQTBCUXhPO2FBQU5yOEI7YUFDaUIseUJBRGpCQSxLQWVWc0I7YUFkMkI7O2FBQ0EseUJBNUJIc3BDLFlBMkJQL3FDO2FBQ1U7O2dDQURoQkksS0FES284QixRQUVMME8sTUFBTUQ7VUFHVTtvQkEvQm5CRDtXQThCUTlOO1dBQU5pTztXQUNpQix5QkFEakJBLE9BV1YxcEM7V0FWMkI7O1dBQ0EseUJBaENIc3BDLFlBK0JQSztXQUNVOzs4QkFEaEJDLE9BREtuTyxRQUVMcU8sUUFBTUQ7O29CQVNqQjdwQztZQXBDMkI7YUFEUitwQyxjQXFDbkIvcEM7YUFyQ0RncUMsWUF2R0x2UjthQXdHaUMseUJBRDVCdVIsWUFBb0JEO2FBQ1E7OzBCQUFoQkcsUUFBTUQ7OztvQkFvQ2pCanFDO1lBakMyQjthQURzQm1xQyxjQWtDakRucUM7YUFsQzRCb3FDLFlBMUdsQzNSO2FBMEd3QjczQixTQTFHeEI2M0I7YUEwR2E1M0IsVUExR2I0M0I7YUEyR2lDLHlCQURDMlIsWUFBcUJEO2FBQ3RCOzswQkFEcEJ0cEMsVUFBV0QsU0FDUDBwQyxRQUFNRDs7O29CQWlDakJycUM7WUE5QjJCO2FBRFV1cUMsY0ErQnJDdnFDO2FBL0JtQndxQyxZQTdHekIvUjthQTZHZ0IxM0IsUUE3R2hCMDNCO2FBOEdpQyx5QkFEUitSLFlBQWtCRDthQUNWOzswQkFEakJ4cEMsUUFDQzJwQyxRQUFNRDs7O2NBRUxydEMsS0FoSGxCcTdCLE9BZ0hhdjNCLElBaEhidTNCO1VBNEllLFVBNUJGdjNCO1dBNEJFLE9BNUJGQTtvQkE2QnVCLDhCQTdCdkJBLElBQUs5RCxLQTRCWjRDO29CQUU4Qiw4QkE5QnZCa0IsSUFBSzlELEtBNEJaNEM7O2NBc0JVLFVBdEJWQTtnQkF5Qk47K0JBekJNQTtpQkF5QjZCLHlCQXJEakI1QyxLQW9EQXd0QztpQkFDaUI7O2dDQUFoQkUsUUFBTUQ7Y0FFcEI7cUJBZCtCLDhCQXpDdkIzcEMsSUFBSzlELEtBNEJaNEM7O1dBQVMsT0E1QkZrQjtvQkErQnVCLDhCQS9CdkJBLElBQUs5RCxLQTRCWjRDO29CQUk4Qiw4QkFoQ3ZCa0IsSUFBSzlELEtBNEJaNEM7b0JBSzhCLDhCQWpDdkJrQixJQUFLOUQsS0E0Qlo0QztvQkFNOEIsOEJBbEN2QmtCLElBQUs5RCxLQTRCWjRDO29CQU84Qiw4QkFuQ3ZCa0IsSUFBSzlELEtBNEJaNEM7b0JBUThCLDhCQXBDdkJrQixJQUFLOUQsS0E0Qlo0QztvQkFTOEIsOEJBckN2QmtCLElBQUs5RCxLQTRCWjRDO29CQVU4Qiw4QkF0Q3ZCa0IsSUFBSzlELEtBNEJaNEM7O2tCQWNxQitxQyxZQTFDZDdwQyxPQTBDS3kzQixVQTFDTHozQjtxQkEwRGZ5cEM7MEJBaEJvQmhTLFVBQVNvUyxhQTFDVDN0QyxLQTRCWjRDOztjQWtCTjtlQUY2QmdyQyxZQTVDaEI5cEM7ZUE0Q08wM0IsVUE1Q1AxM0I7ZUE4Q2Isb0NBRjZCOHBDLFlBNUNYNXRDLEtBNEJaNEM7ZUFrQk47Ozs7K0JBRm9CNDRCLFVBQ0h1UyxhQUEyQkQsUUFBTUQ7cUJBTmQsOEJBdkN2Qi9wQyxJQUFLOUQsS0E0Qlo0QztxQkFZOEIsOEJBeEN2QmtCLElBQUs5RCxLQTRCWjRDOztNQXZCSCxtQkFBbUI7YUFxRHhCMnFDLHVCQUtFenBDLElBQUl1M0IsSUFBSXo0QjtNQUN1QiwwQkFEM0J5NEIsSUFBSXo0QixPQUN1QjtvQkFEL0JrQixJQUNlODZCLE9BQU05N0IsUUFDd0I7YUFqTTNDa3JDLFlBTUYzUyxJQUFJejRCO01BQWUseUJBQW5CeTRCLElBQUl6NEI7TUFBZSxnQ0FDaUIsSUFBdkJnOEIsY0FBdUIsT0FBdkJBO01BQ1YsbUJBQW1CO2FBcVN4QnFQLE9BUUU1UyxJQUFJejRCLE9BQ1EsbUJBRFp5NEIsSUFDWSxVQUFXLEtBRG5CejRCLFFBQ2dDO2FBTXRDc3JDLFlBQVlsUixNQUFNN0IsTUFBTXo0QjtNQUMxQjtpQ0FEMEJBO09BQzFCLGFBRG9CeTRCLE1BQU42QjtPQUdaLFlBSGtCN0I7TUFHbEIsR0FERWdULFdBREF6bUMsSUFhaUIsT0FkS2hGO01BQzFCLElBY0UsV0FmWTI2QixjQWVGLFNBYlI4UTtNQWFRLE9BZkU5UTtlQWlCRCxPQWpCYTM2QixNQWVwQjBHLE1BZEYxQjtlQWlCUyxPQWxCYWhGLE1BZXBCMEcsSUFiRitrQyxVQURBem1DOzs7U0FrQlcsT0FsQlhBOztXQWtCeUQ7OzthQUFsQyxnQkFuQkRoRjs7OzthQW1Ca0IsZ0JBbkJsQkE7Ozs7YUFtQm1DLGdCQW5CbkNBOzs7YUFvQnRCLGVBTEUwRyxNQUtjLGdCQXBCTTFHO2FBcUJ0QixPQXJCc0JBLE1BZXBCMEcsS0FiRitrQyxVQURBem1DOzs7U0l2eEJFOztXSjR5Qm9CLE9BckJ0QkEsY0FxQnNCLGdCQXRCQWhGOzthQXNCbUM7OztlQUFqQixnQkF0QmxCQTs7OztlQXNCbUMsZ0JBdEJuQ0E7OztlQXVCdEIsZUFSRTBHLE1BUWMsZ0JBdkJNMUc7ZUF3QnRCLE9BeEJzQkEsTUFlcEIwRyxLQWJGK2tDLFVBREF6bUM7Ozt1QkF5QkEsT0ExQnNCaEYsTUFlcEIwRyxJQWJGK2tDLFVBREF6bUM7TUEyQkYsNEJBYkkwQixJQWFzQjthQUcxQmdsQyxrQkFBa0Ixc0MsS0FBS2dCO01BQ2Q7a0JBRFNoQjtPQUNULDBCQURjZ0I7T0FHbkIsa0JBSG1CQTs7TUFHbkIsU0FDSnFFOzs7Ozs7Ozs7Ozs7aUJBRkVXLE9BREE3Rix1QkFDQTZGOztnQkFPc0Q7OztrQkFBakIsZ0JBVGhCaEY7Ozs7a0JBU2lDLGdCQVRqQ0E7OztrQkFVYixJQUFOMnJDLE1BQU0sS0FUUnhzQztrQkFVRixlQURJd3NDLFFBQ1ksZ0JBWE8zckM7a0JBWXZCLE9BWnVCQSxNQVVuQjJyQyxPQVRGeHNDLFNBQ0E2RjtrQkFVRiw0QkFGSTJtQzs7Ozs7Ozs7Ozs7O1FBTndCLGlCQUYxQjNtQyxPQURBN0Y7VUFJUSxJQUFOMFosTUFBTSxLQUpSMVo7VUFLRixlQURJMFosUUFESnhVO1VBR0EsT0FQdUJyRSxNQUtuQjZZLE9BSkYxWixTQUNBNkY7VUFLRiw0QkFGSTZUO01BU3NDLGVBWnhDN1QsTUFEQTdGO1FBY1EsSUFBTnVILElBQU0sS0FkUnZIO1FBZUYsT0FoQnVCYSxNQWVuQjBHLElBZEZ2SCxTQUNBNkY7UUFjRiw0QkFESTBCO01BSUosT0FuQnVCMUcsR0FtQnBCO2FBR0g0ckMsc0JBQXNCNXJDO01BQ2Q7dUJBRGNBO09BQ2Qsd0JBQU5pN0I7T0FFTSxTQUROMTNCO01BRUosaUJBSEkwM0IsUUFFQXYwQixNQURBbkQ7TUFFSiw0QkFESW1ELElBRXNCO2FBcUN4Qm1sQyxnQkFBZ0IvckMsTUFBTWQ7TUFDWDtrQkFEV0E7T0FFWCx3QkFGS2M7T0FHTjtNQUNWLGdCQURJd0c7TUFFSixrQkFGSUEsSUFIWXhHO01BTWhCLGdCQUhJd0c7TUFJSixrQkFKSUEsSUFJa0IsNEJBTmxCbkg7TUFPSixnQkFMSW1ILElBREF3bEM7TUFNSix1QkFMSXhsQyxJQU1lO2FBRW5CeWxDLGtCQUFrQjdzQyxNQUFNdUM7TUFDMUIsU0FEb0J2QztRQUdsQix1Q0FId0J1QyxXQUd4Qjs7Y0FFRStCO1VBQ0U7NkNBTm9CL0IsRUFLdEIrQixLQUNFO3dDQUNjO1lBRGQsU0FERkE7OztRQUZGO1NBT0UsT0FOSVQ7U0FRSTs7WUFGUixzQkFWc0J0QixPQUdwQnVxQztTQVNNO3NCQUVGM25DLEdBQUksZUFGUmlDLElBQ0E4UCxPQUNJL1IsR0FBSSxpQkFBOEI7U0FGaEMsVUFUTjJuQztTQVNNLDJCQVpjdnFDO1NBWWQ7O2NBSVZyRTtVQUNFO3lDQWpCc0JxRSxFQWdCeEJyRSxHQUNFLFNBQ0VpSDtZQURGO2FBR08sSUFGTEE7O2NBQ0UsU0FKRm9QLFNBSXFCLG9CQUFxQixjQUFXLElBRHJEcFA7WUFERixTQURGakg7OztRQU1BLDRCQVZJa0o7TUFXQyxPQXZCbUI3RSxDQXVCbEI7YUFHTnlxQyxZQUFZaHRDLE1BQU02RDtNQXRFQSxPQXNFTjdEOzs7Ozs7Ozs7Ozs7Ozs7O01BQzZDLHlCQUQ3Q0EsTUFDNkMscUJBRHZDNkQsR0FDMEM7YUFDNURvcEMsY0FBY2p0QyxNQUFNNkQ7TUF4REQsT0F3REw3RDs7Ozs7Ozs7Ozs7Ozs7OztNQUM4Qyx5QkFEOUNBLE1BQzhDLHFCQUR4QzZELEdBQzJDO2FBQy9EcXBDLGtCQUFrQmx0QyxNQUFNNkQ7TUFsREwsT0FrREQ3RDs7Ozs7Ozs7Ozs7Ozs7OztNQUM4Qyx5QkFEOUNBLE1BQzhDLHFCQUR4QzZELEdBQzJDO2FBQ25Fc3BDLGNBQWNudEMsTUFBTTZEO01BcEVELE9Bb0VMN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7TUFDOEMseUJBRDlDQSxNQUM4Qyx1QkFEeEM2RCxHQUMyQzthQUkvRHVwQyxjQUFjeHNDLE1BQU1kLEtBQUs0QztNQUMzQixTQUFJMnFDO1FBQ0YsT0FGY3pzQztxQkFFVjBzQzs7O1FBS0osdUNBUHlCNXFDLEVBQUw1QyxLQUVoQnd0QyxLQUswQjtNQU5oQyxTQWVJQyxpQkFBaUJ6c0M7UUFBWSxzQ0FoQk40QjtRQWdCTTtpQkFoQk5BO29DQWdCTjVCLEdBR0Y7TUFsQm5CLE9BRGdCRjs7U0F5QnFDO2dDQUE1QixnQkF6QlRBLE1BQU1kLE1BQUs0QztVQVN6QiwwQkFEb0I1QjtVQUVINUM7U0FDZjtjQURlQSxNQURiNEg7OzthQUdNLDBCQUpVaEYsSUFFSDVDLEdBRVA7Ozs7O2FJajdCTixlSm03Qk8sUUFKTUE7YUFFUDt5QkFKVTRDLElBT1EsT0FQUkE7a0JBUWxCeXNDO2VBS1M7ZUFDdUI7ZUFDTDtnQkFLWSx5QkFBNUIsZ0JBNUJDM3NDLE1BQU1kLE1BQUs0QyxHQTRCa0I7YUFXM0M4cUMsZ0JBQWdCeHNDO01BQ1IsSUFBTm9HLElBQU07TUFDVixhQURJQSxJQURjcEc7TUFFbEIsdUJBRElvRyxJQUVlO2FBWWJxbUMsc0JBR0poZixFQUFFOWlCLElBQUk4dEI7VUFBTmxDLE1BQUUzckIsVUFBSW94QjtNQUFPO2lCQUFQQTtRQXVGTixrQkF2RkF6RixJQUFFM3JCOztRQUFXLE9BQVBveEI7O1dBRU4sSUFESzUrQixLQURDNCtCO1dBRU4sZ0JBQUk3M0I7YUFDRixJQUFJdW9DLFdBSEo5aEMsTUFFRXpHLEdBQ0YsbUJBSEZveUIsSUFHTW1XLFFBRkR0dkMsS0FHdUI7O1dBRTVCLElBRFVDLE9BTEoyK0I7V0FNTixnQkFBSTczQjthQS9CSTswQkErQkpBO2NBL0JJLHdCQUFOckU7Y0FFTSxTQUROdUQ7YUFFSixpQkFISXZELE1BRUEwRyxNQURBbkQ7YUFETSxJQWdDRnFwQyxXQVBKOWhDLE1BdEJKLHFCQURJcEU7b0JBb0JFbW1DLFlBR0pwVyxJQU9NbVcsUUFGSXJ2QyxPQUdrQjs7ZUFDZkMsT0FUUDArQixTQVNFcDlCLElBVEZvOUI7a0JBb0pONFEsYUFwSkFyVyxJQUFFM3JCLE1BU1d0TixPQUFMc0IsYUFDeUJrQixLQUFPLE9BQVBBLEdBQVU7O2VBQ3pCdkMsT0FYWnkrQixTQVdPbjlCLE1BWFBtOUI7a0JBb0pONFEsYUFwSkFyVyxJQUFFM3JCLE1BV2dCck4sT0FBTHNCLE1BOUpiNnNDOztlQWdLdUJsdUMsT0FiakJ3K0IsU0FhV2w5QixLQWJYazlCLFNBYU1qOUIsTUFiTmk5QixTQWFEaDlCLE1BYkNnOUI7a0JBd0tONlE7b0JBeEtBdFcsSUFBRTNyQixNQWFxQnBOLE9BQVh1QixNQUFLRCxLQWpGakJrdEMsWUFpRktodEM7OztZQUVvQnZCLE9BZm5CdStCO1lBZWEvOEIsT0FmYis4QjtZQWVROThCLE1BZlI4OEI7WUFlQzc4QixRQWZENjhCO2tCQXdLTjZRO29CQXhLQXRXLElBQUUzckIsTUFldUJuTixPQUFYeUIsTUFBS0QsT0FqRm5CZ3RDLGNBaUZPOXNDOzs7WUFFc0J6QixPQWpCdkJzK0I7WUFpQmlCNThCLE9BakJqQjQ4QjtZQWlCWTM4QixNQWpCWjI4QjtZQWlCSzE4QixRQWpCTDA4QjtrQkF3S042UTtvQkF4S0F0VyxJQUFFM3JCLE1BaUIyQmxOLE9BQVgyQixNQUFLRCxPQWpGdkI4c0Msa0JBaUZXNXNDOzs7WUFFYzNCLE9BbkJuQnErQjtZQW1CYXo4QixPQW5CYnk4QjtZQW1CUXg4QixNQW5CUnc4QjtZQW1CQ3Y4QixRQW5CRHU4QjtrQkF3S042UTtvQkF4S0F0VyxJQUFFM3JCLE1BbUJ1QmpOLE9BQVg2QixNQUFLRCxPQWpGbkI0c0MsY0FpRk8xc0M7O2VBRWtCN0IsT0FyQm5CbytCLFNBcUJhdDhCLE9BckJiczhCLFNBcUJRcjhCLE1BckJScThCLFNBcUJDcDhCLE1BckJEbzhCO1dBeU53QixVQXBNaEJyOEI7dUJBQUtEO2NBOE1uQixPQTlNbUJBO2dDQThNZjJSLEVBQUUzUDt5QkFDTSxJQUFONUIsSUFBTSxjQS9NTEYsTUE4TUh5UixFQUFFM1A7eUJBQ00sbUJBcE9aNjBCLE9BQUUzckIsTUFvT0k5SyxLQS9NbUJsQyxPQWdOdUI7Z0NBVjVDOEQ7eUJBQ1E7MEJBQU41QjsyQkFBTSxjQXZNTEYsTUF1TXlCLHdCQXZNekJBLE9Bc01IOEI7eUJBQ1EsbUJBNU5aNjBCLE9BQUUzckIsTUE0Tkk5SyxLQXZNbUJsQyxPQXdNdUI7YUFFaEQsSUFEMEJ5VCxFQXpNUDNSO2FBME1uQixnQkFBSWdDO2VBQ1EsSUFBTjVCLElBQU0sY0EzTUxGLE1BeU1tQnlSLEVBQ3RCM1A7ZUFDUSxtQkFoT1o2MEIsT0FBRTNyQixNQWdPSTlLLEtBM01tQmxDLE9BNE11Qjs7YUFSbEIsU0FwTWhCK0I7O3lCQUFLRDs7a0NBMk5mMlIsRUFBRTNQOzJCQUNNLElBQU41QixJQUFNLHNCQUFvQixjQTVOekJGLE1BMk5IeVIsRUFBRTNQOzJCQUNNLG1CQWpQWjYwQixPQUFFM3JCLE1BaVBJOUssS0E1Tm1CbEMsT0E2TnVCO2tDQVg1QzhEOzJCQUNROzhDQW5OTDlCLE1BbU55Qix3QkFuTnpCQSxPQWtOSDhCOzRCQUVTLDRCQURQNUI7MkJBQ08sbUJBek9ieTJCLE9BQUUzckIsTUF5T0ltd0IsT0FwTm1CbjlCLE9BcU53QjttQkFDWGt2QyxJQXRObkJwdEM7K0JBdU5mZ0M7aUJBQ1EsSUFBTjVCLElBQU0sc0JBQW9CLGNBeE56QkYsTUFzTitCa3RDLElBQ2xDcHJDO2lCQUNRLG1CQTdPWjYwQixPQUFFM3JCLE1BNk9JOUssS0F4Tm1CbEMsT0F5TnVCO3NCQXpObEMrQjt1QkFBS0Q7O2dDQXdPZm1qQyxFQUFFeHhCLEVBQUUzUDt5QkFDSSxJQUFONUIsSUFBTSxpQkFEUitpQyxFQUM0QixjQXpPekJqakMsTUF3T0R5UixFQUFFM1A7eUJBQ0ksbUJBOVBaNjBCLE9BQUUzckIsTUE4UEk5SyxLQXpPbUJsQyxPQTBPdUI7Z0NBWDVDaWxDLEVBQUVuaEM7eUJBQ007NENBaE9MOUIsTUFnT3lCLHdCQWhPekJBLE9BK05EOEI7MEJBRU8sdUJBRlRtaEMsRUFDRS9pQzt5QkFDTyxtQkF0UGJ5MkIsT0FBRTNyQixNQXNQSW13QixPQWpPbUJuOUIsT0FrT3dCO2lCQUNoQm12QyxJQW5PZHJ0Qzs2QkFvT2ZtakMsRUFBRW5oQztlQUNNLElBQU41QixJQUFNLGlCQURSK2lDLEVBQzRCLGNBck96QmpqQyxNQW1PMEJtdEMsSUFDM0JyckM7ZUFDTSxtQkExUFo2MEIsT0FBRTNyQixNQTBQSTlLLEtBck9tQmxDLE9Bc091Qjs7ZUFwT3JDRSxPQXZCTGsrQixTQXVCQW44QixNQXZCQW04QjtrQkFvSk40USxhQXBKQXJXLElBQUUzckIsTUF1QlM5TSxPQUFMK0IsTU12M0NOaUQ7O1dOMDRDQSxVQTFDTWs1QixTQTBDTixTQTFDRXB4QixtQkFBSW94Qjs7Ozs7WUE0Q1VsOEIsSUE1Q1ZrOEI7WUFBSmdSLGVBNENjbHRDO1lBNUNkOEs7WUFBSW94Qjs7Ozs7WUE4Q1FqOEIsSUE5Q1JpOEI7WUFBSmlSLGVBOENZbHRDO1lBOUNaNks7WUFBSW94Qjs7O1dBa0RHO1lBRGlCaCtCLE9BakRwQmcrQjtZQWlEU2IsVUFqRFRhO1lBa0RHLG1CQURNYjtXQUNOLGdCQUNKcjdCLEtBQ0gsbUJBcERGeTJCLE9BQUUzckIsTUFrREUvTSxJQURzQkcsT0FJc0I7O2VBQ3hCQyxRQXREbEIrOUIsU0FzRFdoOEIsTUF0RFhnOEI7O2FBdUROLElBQWF2RDthQUNYO3NCQXhERmxDLElBQUUzckIsTUF3REEsV0FBWSxPQURENnRCLElBREl6NEIsT0FBTy9CLFNBRWM7O1dBOUJ0QyxJQURNQyxRQXpCQTg5QjtXQTBCTixnQkFBSTU2QixFQUFFTTthQUFLO3NCQTFCWDYwQjt5QkFBRTNyQixlQTBCNENRLEdBQUssa0JBQS9DaEssRUFBMENnSyxFQUF4QzFKLEVBQWtEO3NCQURsRHhELFFBQ3lEOztXQUUvRCxJQURNQyxRQTNCQTY5QjtXQTRCTixnQkFBSTU2QixHQUFLLG1CQTVCVG0xQixPQUFFM3JCLE1BNEJFeEosR0FERWpELFFBQzBDOzs7WUE1QjFDOGxDO1lBMkVVMWpDLFdBM0VWeTdCO1lBQUprUixlQTJFYzNzQztZQTNFZHFLO1lBQUlveEI7Ozs7OztjQTZFdUM1OUIsUUE3RXZDNDlCOzs7Y0FBTm1SO3dCQUFFeGlDLElBQUY4aUIsRUE2RTZDcndCOzBCQTdFN0NtNUIsSUE4RU82VzttQkFDTCxtQkEvRUYzZixLQUFFOWlCLE9BOEVLeWlDLE9BRHNDaHdDLEtBRXFCO3dCQS9FbEVtNUI7c0JBQUUzckIsTUFBRjJyQixJQTZFNkNuNEI7Y0E3RTdDbTRCO2NBQUUzckI7Y0FBSW94Qjs7O1lBaUZ1QzU3QixRQWpGdkM0N0I7OztZQUFOcVI7c0JBQUUxaUMsSUFBRjhpQixFQWlGNkNyd0I7d0JBakY3Q201QixJQWtGTzZXLE1BQ0wsbUJBbkZGM2YsS0FBRTlpQixPQWtGS3lpQyxPQURzQ2h3QyxLQUVxQjtzQkFuRmxFbTVCO29CQUFFM3JCLE1BQUYyckIsSUFpRjZDbjJCO1lBakY3Q20yQjtZQUFFM3JCO1lBQUlveEI7O2tCQXdDTjs7ZUFrQnFCMzdCLFFBMURmMjdCLFNBMkRGMFEsV0EzREY5aEM7a0NBNERPLG1CQTVEVDJyQixJQTJESW1XLFFBRGlCcnNDLFFBRWM7O1dBS25DLElBSnFCQyxRQTdEZjA3QjtXQWlFTixnQkFBSW41QjthQUNrQyxJQUFoQzZwQyxXQWxFSjloQyxNQWtFb0Msd0JBRGxDL0g7YUFDa0MsbUJBbEV0QzB6QixJQWtFTW1XLFFBTGVwc0MsUUFNTzs7V0FFNUIsSUFEZUUsUUFwRVR3N0I7V0FxRU4sZ0JBQUk3M0I7YUFDRixJQUFJdW9DLFdBdEVKOWhDLE1BcUVFekcsR0FDRixtQkF0RUZveUIsSUFzRU1tVyxRQUZTbHNDLFFBR2E7O2VBQ1JFLFFBeEVkczdCLFNBd0VTOTZCLElBeEVUODZCOzs7b0JBMkZOc1IsK0JBM0ZBL1csSUFBRTNyQixNQXdFYTFKLElBQUtSOztvQkFtQnBCNHNDLHdCQTNGQS9XLElBQUUzckIsTUF3RWExSixJQUFLUjs7V0ExQ1M7WUFEWEMsUUE3QlpxN0I7WUE2QlM1NkIsRUE3QlQ0NkI7WUE2QkUzNkIsTUE3QkYyNkI7WUE4QnVCLGdCQURkNTZCO1dBQ2M7O29CQWtPN0Jtc0Msd0JBaFFBaFgsSUFBRTNyQixNQTZCZ0JqSyxRQUFWVTs7b0JBbU9Sa3NDLGlCQWhRQWhYLElBQUUzckIsTUE2QmdCakssUUFBVlUsYUEwREg7YUFJTGlzQyw2QkFJQTdmLEVBQUU5aUIsSUFBSXpKLElBQUl1M0I7TUFBTyxVQUFYdjNCO09BQVcsT0FBWEE7O1VBQzZCOzttQkE2Q25Dc3NDLDJCQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjt3Q0E4Q1YrVSxvQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7O1VBRXlCOzttQkE0Q25DK1UsMkJBOUNBL2YsRUFBRTlpQixJQUFROHRCO3dDQThDVitVLG9CQTlDQS9mLEVBQUU5aUIsSUFBUTh0QjtnQkFheUI7O1VBR0E7O21CQThCbkMrVSwyQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7d0NBOENWK1Usb0JBOUNBL2YsRUFBRTlpQixJQUFROHRCOztPQUFPLE9BQVh2M0I7O1VBRzZCOzttQkEyQ25Dc3NDLDJCQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjt3Q0E4Q1YrVSxvQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7O1VBSXlCOzttQkEwQ25DK1UsMkJBOUNBL2YsRUFBRTlpQixJQUFROHRCO3dDQThDVitVLG9CQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjs7VUFLeUI7O21CQXlDbkMrVSwyQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7d0NBOENWK1Usb0JBOUNBL2YsRUFBRTlpQixJQUFROHRCOztVQU15Qjs7bUJBd0NuQytVLDJCQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjt3Q0E4Q1YrVSxvQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7O1VBT3lCOzttQkF1Q25DK1UsMkJBOUNBL2YsRUFBRTlpQixJQUFROHRCO3dDQThDVitVLG9CQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjs7VUFReUI7O21CQXNDbkMrVSwyQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7d0NBOENWK1Usb0JBOUNBL2YsRUFBRTlpQixJQUFROHRCOztVQVN5Qjs7bUJBcUNuQytVLDJCQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjt3Q0E4Q1YrVSxvQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7O1VBVXlCOzttQkFvQ25DK1UsNEJBOUNBL2YsRUFBRTlpQixJQUFROHRCO3dDQThDVitVLG9CQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjs7VUFXeUI7O21CQW1DbkMrVSw0QkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7d0NBOENWK1Usb0JBOUNBL2YsRUFBRTlpQixJQUFROHRCOztVQVl5QixJQUFWejRCLE1BWm5Ca0I7VUFZNkI7O21CQVFuQ3VzQyw2QkFwQkFoZ0IsRUFBRTlpQixJQVl1QjNLLE1BWmZ5NEI7d0NBb0JWZ1YscUJBcEJBaGdCLEVBQUU5aUIsSUFZdUIzSyxNQVpmeTRCOztVQWN5Qjs7bUJBZ0NuQytVLDRCQTlDQS9mLEVBQUU5aUIsSUFBUTh0Qjt3Q0E4Q1YrVSxvQkE5Q0EvZixFQUFFOWlCLElBQVE4dEI7O1VBZXlCOzttQkErQm5DK1UsNEJBOUNBL2YsRUFBRTlpQixJQUFROHRCO3dDQThDVitVLG9CQTlDQS9mLEVBQUU5aUIsSUFBUTh0QixNQWdCbUQ7YUFJN0RnViwwQkFJQWhnQixFQUFFOWlCLElBQUkzSyxNQUFNeTRCO01BQU8sVUFBYno0QjtRQWVxQjs7aUJBTzNCd3RDLDJCQXRCQS9mLEVBQUU5aUIsSUFBVTh0QjtzQ0FzQlorVSxvQkF0QkEvZixFQUFFOWlCLElBQVU4dEI7O09BQU8sT0FBYno0Qjs7VUFDcUIsSUFBbkI1QyxLQURGNEM7VUFDcUIsdUJBQVMsdUJBRHBDeXRCLEVBQUU5aUIsSUFDTXZOLEtBRElxN0IsSUFDc0Q7O1VBQ3ZDLElBQWpCcDdCLE9BRkoyQztVQUVxQix1QkFBUyx1QkFGcEN5dEIsRUFBRTlpQixJQUVRdE4sT0FGRW83QixJQUVzRDs7VUFDdkMsSUFBcEJuN0IsT0FIRDBDO1VBR3FCLHVCQUFTLHVCQUhwQ3l0QixFQUFFOWlCLElBR0tyTixPQUhLbTdCLElBR3NEOztVQUN2QyxJQUFsQmw3QixPQUpIeUM7VUFJcUIsdUJBQVMsdUJBSnBDeXRCLEVBQUU5aUIsSUFJT3BOLE9BSkdrN0IsSUFJc0Q7O1VBQ3ZDLElBQWRqN0IsT0FMUHdDO1VBS3FCLHVCQUFTLHVCQUxwQ3l0QixFQUFFOWlCLElBS1duTixPQUxEaTdCLElBS3NEOztVQUN2QyxJQUFsQmg3QixPQU5IdUM7VUFNcUIsdUJBQVMsdUJBTnBDeXRCLEVBQUU5aUIsSUFNT2xOLE9BTkdnN0IsSUFNc0Q7O1VBQ3ZDLElBQWxCLzZCLE9BUEhzQztVQU9xQix1QkFBUyx1QkFQcEN5dEIsRUFBRTlpQixJQU9Pak4sT0FQRys2QixJQU9zRDs7VUFDdkMsSUFBbkI5NkIsT0FSRnFDO1VBUXFCLHVCQUFTLHVCQVJwQ3l0QixFQUFFOWlCLElBUU1oTixPQVJJODZCLElBUXNEOztVQU12QyxJQUFUNzZCLE9BZFpvQztVQWNxQix1QkFBUyx1QkFkcEN5dEIsRUFBRTlpQixJQWNnQi9NLE9BZE42NkIsSUFjc0Q7O1VBR3pEO1dBRGtCMzZCLE9BaEJyQmtDO1dBZ0JnQnhCLElBaEJoQndCO1dBZ0JXakMsSUFoQlhpQztXQWlCRyxTQUFNLEtBREVqQyxLQUFLUztVQUNiO1lBQ3NCLHVCQWxCL0JpdkIsRUFBRTlpQixJQWtCNkIsYUFEM0I5TSxHQUR1QkMsUUFoQmYyNkIsSUFrQjZDOztVQVQ5QixJQUFsQno2QixPQVRIZ0M7VUFTcUI7WUFBVyx1QkFUdEN5dEIsRUFBRTlpQixJQVNPM00sT0FUR3k2QixJQVN3RDs7VUFDekMsSUFBbEJ4NkIsUUFWSCtCO1VBVXFCLHVCQUFTLHVCQVZwQ3l0QixFQUFFOWlCLElBVU8xTSxRQVZHdzZCLElBVXNEOztVQUN2QyxJQUFwQnY2QixRQVhEOEI7VUFXcUIsdUJBQVMsdUJBWHBDeXRCLEVBQUU5aUIsSUFXS3pNLFFBWEt1NkIsSUFXc0Q7aUJBQ3ZDO2lCQUNBLDhCQUs4QjthQUl6RCtVLHlCQUdBL2YsRUFBRTlpQixJQUFJOHRCO01BQ1IsWUFESTl0QjtNQUNKOztlQXBKTThoQyx3QkFtSkpoZixPQUFNZ0w7b0NBbkpGZ1UsaUJBbUpKaGYsT0FBTWdMLEtBQzhEO2FBK0dwRThVLHNCQUlFOWYsRUFBRTlpQixJQUFJdk4sS0FBS2lFLE1BQU1EO01BQUssR0FBWEM7UUFHYixJQURZcWdDLFFBRkNyZ0M7UUFHYixnQkFBSUs7VUFDMkIsbUJBSjdCK3JCLEVBQUU5aUIsSUFBSXZOLEtBRUlza0MsUUFFbUIsV0FKWnRnQyxFQUdmTSxHQUNnQztNQUhyQixZQURYaUosSUFBZXZKO01BQ0o7O2VBeFFYcXJDLHdCQXVRRmhmLE9BQU1yd0I7b0NBdlFKcXZDLGlCQXVRRmhmLE9BQU1yd0IsTUFJNEI7YUEzUWhDdXZDLFlBR0psZixFQUFFOWlCLElBQUk4dEI7TUo5K0NYLHVCSTIrQ1NnVSxnQkFHSmhmLEVBQUU5aUIsSUFBSTh0QjthQTJGTm1WLG1CQUlBbmdCLEVBQUU5aUIsSUFBSXpKLElBQUl1M0I7TUo3a0RmLHVCSXlrREs2VSx1QkFJQTdmLEVBQUU5aUIsSUFBSXpKLElBQUl1M0I7YUFvQlZpVixnQkFJQWpnQixFQUFFOWlCLElBQUkzSyxNQUFNeTRCO01Kcm1EakIsdUJJaW1ES2dWLG9CQUlBaGdCLEVBQUU5aUIsSUFBSTNLLE1BQU15NEI7YUF5SVprVixZQUlFbGdCLEVBQUU5aUIsSUFBSXZOLEtBQUtpRSxNQUFNRDtNSmx2RHhCLHVCSTh1REttc0MsZ0JBSUU5ZixFQUFFOWlCLElBQUl2TixLQUFLaUUsTUFBTUQ7YUFoSG5Cd3JDLGFBSUVuZixFQUFFOWlCLElBQUk4dEIsSUFBSTc1QixJQUFJczlCO01BQVMsVUFBYnQ5QjtPQUVaLGdCQUFJOEM7U0FDa0MsSUFBaENnckMsV0FIRi9oQyxJQUdrQyxXQUh0QnV4QixNQUVaeDZCO1NBQ2tDLG1CQUhwQytyQixFQUdJaWYsUUFIRWpVLElBSW1COztRQUpGLFNBQWI3NUI7Y0FLUTI1QixNQUxSMzVCLE9BS0N3N0IsTUFMRHg3QjswQkFNUjhDO1lBQ2tDLElBQWhDZ3JDLFdBUEYvaEMsSUFPa0MsWUFGekJ5dkIsTUFBTzdCLE1BRTBDLFdBUDlDMkQsTUFNWng2QjtZQUNrQyxtQkFQcEMrckIsRUFPSWlmLFFBUEVqVSxJQVFtQjtRQUUzQixJQURZZ0MsUUFUQTc3QjtRQVVaLGdCQUFJaWtDLEVBQUVuaEM7VUFDZ0MsSUFBaENnckMsV0FYRi9oQyxJQVdrQyxZQUYxQjh2QixRQUNSb0ksRUFDc0QsV0FYMUMzRyxNQVVWeDZCO1VBQ2dDLG1CQVhwQytyQixFQVdJaWYsUUFYRWpVLElBWW1CO2FBSTNCb1UsMkJBS0VwZixFQUFFOWlCLElBQUk4dEIsSUFBSTc1QixJQUFJOE8sTUFBS3d1QixNQUFNbDlCO01BQVMsVUFBeEJKO2tCQUFJOE87U0FVaEIsT0FWZ0JBOzJCQVVaMkQsRUFBRTNQO29CQUNNLElBQU41QixJQUFNLGtCQURSdVIsRUFDNEIsV0FYWDZxQixNQUFNbDlCLE1BVXJCMEM7b0JBQ00sbUJBWFYrckIsS0FBRTlpQixJQVdFN0ssS0FYRTI0QixJQVl3QzsyQkFWNUMvMkI7b0JBQ1EsSUFBTjVCLElBQU0sV0FIU284QixNQUFNbDlCLE1BRXZCMEM7b0JBQ1EsbUJBSFYrckIsS0FBRTlpQixJQUdFN0ssS0FIRTI0QixJQUl3QztRQUVoRCxJQUQwQnBuQixFQUxWM0Q7UUFNaEIsZ0JBQUloTTtVQUNRLElBQU41QixJQUFNLGtCQUZjdVIsRUFFTSxXQVBYNnFCLE1BQU1sOUIsTUFNdkIwQztVQUNRLG1CQVBWK3JCLEtBQUU5aUIsSUFPRTdLLEtBUEUyNEIsSUFRd0M7O1FBUlosU0FBeEI3NUI7O29CQUFJOE87OzZCQXNCWjJELEVBQUUzUDtzQkFDTTt1QkFBTjVCO3dCQUFNO29DQUFvQixrQkFENUJ1UixFQUNpRCxXQXZCaEM2cUIsTUFBTWw5QixNQXNCckIwQztzQkFDTSxtQkF2QlYrckIsS0FBRTlpQixJQXVCRTdLLEtBdkJFMjRCLElBd0J3Qzs2QkFWNUMvMkI7c0JBQ1EsSUFBTjVCLElBQU0sc0JBQW9CLFdBZlhvOEIsTUFBTWw5QixNQWN2QjBDO3NCQUNRLG1CQWZWK3JCLEtBQUU5aUIsSUFlRTdLLEtBZkUyNEIsSUFnQndDO2NBQ1ZxVSxJQWpCdEJwL0I7MEJBa0JaaE07WUFDUTthQUFONUI7Y0FBTTswQkFBb0Isa0JBRk1ndEMsSUFFZSxXQW5CaEM1USxNQUFNbDlCLE1Ba0J2QjBDO1lBQ1EsbUJBbkJWK3JCLEtBQUU5aUIsSUFtQkU3SyxLQW5CRTI0QixJQW9Cd0M7aUJBcEJwQzc1QjtrQkFBSThPOzsyQkFrQ1ptMUIsRUFBRXh4QixFQUFFM1A7b0JBQ0k7cUJBQU41QjtzQkFBTTs2QkFEUitpQyxFQUM0QixrQkFEMUJ4eEIsRUFDK0MsV0FuQ2hDNnFCLE1BQU1sOUIsTUFrQ25CMEM7b0JBQ0ksbUJBbkNWK3JCLEtBQUU5aUIsSUFtQ0U3SyxLQW5DRTI0QixJQW9Dd0M7MkJBVjVDb0ssRUFBRW5oQztvQkFDTSxJQUFONUIsSUFBTSxpQkFEUitpQyxFQUM0QixXQTNCWDNHLE1BQU1sOUIsTUEwQnJCMEM7b0JBQ00sbUJBM0JWK3JCLEtBQUU5aUIsSUEyQkU3SyxLQTNCRTI0QixJQTRCd0M7WUFDZnNVLElBN0JqQnIvQjt3QkE4QlptMUIsRUFBRW5oQztVQUNNO1dBQU41QjtZQUFNO21CQURSK2lDLEVBQzRCLGtCQUZDa0ssSUFFb0IsV0EvQmhDN1EsTUFBTWw5QixNQThCckIwQztVQUNNLG1CQS9CVityQixLQUFFOWlCLElBK0JFN0ssS0EvQkUyNEIsSUFnQ3dDLEVBSUE7YUEyRDVDb1YsdUJBRUZwZ0IsRUFBRXJpQixFQUFFcXRCO1VBQUpsQyxNQUFJeUY7TUFBTztpQkFBUEE7UUFzRUYsa0JBdEVGekYsSUFBRW5yQjs7UUFBUyxPQUFQNHdCOztXQUVGLFNBRkVBLFNBRUksa0JBRlJ6RixJQUFFbnJCLEVBQ0doTztXQUNHLHNCSjl2RGY7O1dJZ3dEUyxXQUpFNCtCLFNBSUksa0JBSlJ6RixJQUFFbnJCLEVBR1EvTjtXQUNGLHNCSmh3RGY7O29CSTR2RFcyK0I7O2FBTUYsV0FORUEsU0FNSSxrQkFOUnpGLElBQUVuckIsRUFLa0I5TjthQUNaLHNCSmx3RGY7OztlSW93RFMsV0FSRTArQixTQVFJLGtCQVJSekYsSUFBRW5yQixFQU9xQjdOO2VBQ2Ysc0JKcHdEZjthSXN3RFM7cUJBVkV5K0I7Y0FVVyxrQkFWZnpGLElBQUVuckIsRUFTcUI1TjtjQUNmLG9CSnR3RGY7YUlzd0RlLHNCSnR3RGY7O29CSTR2RFd3K0I7O2FBWUYsV0FaRUEsU0FZSSxrQkFaUnpGLElBQUVuckIsRUFXdUIzTjthQUNqQixzQkp4d0RmOzs7ZUkwd0RTLFdBZEV1K0IsU0FjSSxrQkFkUnpGLElBQUVuckIsRUFhMEIxTjtlQUNwQixzQkoxd0RmO2FJNHdEUztxQkFoQkVzK0I7Y0FnQlcsa0JBaEJmekYsSUFBRW5yQixFQWUwQnpOO2NBQ3BCLG9CSjV3RGY7YUk0d0RlLHNCSjV3RGY7O2VJNndEMEJDLE9BakJmbytCLFNBaUJTbDlCLEtBakJUazlCLFNBaUJJcDlCLElBakJKbzlCO2tCQXVFTitSLHdCQXZFRXhYLElBQUVuckIsRUFpQmlCeE4sT0FBWGdCLElBQUtFOztlQUVRaEIsT0FuQmpCaytCLFNBbUJXLzhCLE9BbkJYKzhCLFNBbUJNbjlCLE1BbkJObTlCO2tCQXVFTitSLHdCQXZFRXhYLElBQUVuckIsRUFtQm1CdE4sT0FBWGUsTUFBS0k7O2VBRVVqQixPQXJCckJnK0IsU0FxQmU1OEIsT0FyQmY0OEIsU0FxQlVqOUIsTUFyQlZpOUI7a0JBdUVOK1Isd0JBdkVFeFgsSUFBRW5yQixFQXFCdUJwTixPQUFYZSxNQUFLSzs7ZUFFRW5CLFFBdkJqQis5QixTQXVCV3o4QixPQXZCWHk4QixTQXVCTTk4QixNQXZCTjg4QjtrQkF1RU4rUix3QkF2RUV4WCxJQUFFbnJCLEVBdUJtQm5OLFFBQVhpQixNQUFLSzs7ZUFFTXJCLFFBekJqQjg5QixTQXlCV3Q4QixPQXpCWHM4QixTQXlCTTM4QixNQXpCTjI4QjtrQkF1RU4rUix3QkF2RUV4WCxJQUFFbnJCLEVBeUJtQmxOLFFBQVhtQixNQUFLSzs7b0JBekJYczhCOzthQTRCRixZQTVCRUEsU0E0Qkksa0JBNUJSekYsSUFBRW5yQixFQTJCZ0JqTjthQUNWLHNCSnh4RGY7OztlSTB4RFMsWUE5QkU2OUIsU0E4Qkksa0JBOUJSekYsSUFBRW5yQixFQTZCbUJoTjtlQUNiLHNCSjF4RGY7YUk0eERTO3NCQWhDRTQ5QjtjQWdDVyxrQkFoQ2Z6RixJQUFFbnJCLEVBK0JtQmhMO2NBQ2Isb0JKNXhEZjthSTR4RGUsc0JKNXhEZjtrQkl3eURTLFVBNUNFNDdCO2tCQThDRixVQTlDRUE7a0JBZ0RGLFVBaERFQTs7V0FrREYsWUFsREVBLFNBa0RJLGtCQWxEUnpGLElBQUVuckIsRUFpRGdCL0s7V0FDVixzQko5eURmOztlSSt5RCtCQyxRQW5EcEIwN0IsU0FtRGFoOEIsTUFuRGJnOEI7O2FBb0RGLElBQWF2RDthQUVULG9CQXRETmxDLElBQUVuckIsRUFzREksV0FBWSxPQUZIcXRCLElBREV6NEIsT0FBT00sU0FHa0I7O1dBcEJ4QztvQkFsQ0UwN0I7WUFrQ1csa0JBbENmekYsSUFBRW5yQixFQWlDSTVLO1lBQ0Usb0JKOXhEZjtXSTh4RGUsc0JKOXhEZjs7V0lneURTLFlBcENFdzdCLFNBb0NJLGtCQXBDUnpGLElBQUVuckIsRUFtQ0kxSztXQUNFLHNCSmh5RGY7a0JJNHpEUyxVQWhFRXM3Qjs7Ozs7Y0FpRXlDcjdCLFFBakV6Q3E3Qjs7O2NBQUptUjswQkFpRTZDL3ZDOzBCQWpFN0NtNUIsSUFrRW9CeVgsS0FBTyxvQkFsRTNCdmdCLEVBa0VvQnVnQixJQUR5QjV3QyxLQUNLLFFBbEVsRG01QjswQkFpRTZDNTFCO2NBakU3QzQxQjtjQUFJeUY7OztZQW1FeUNsN0IsUUFuRXpDazdCOzs7WUFBSnFSO3dCQW1FNkNqd0M7d0JBbkU3Q201QixJQW9Fb0J5WCxLQUFPLG9CQXBFM0J2Z0IsRUFvRW9CdWdCLElBRHlCNXdDLEtBQ0ssUUFwRWxEbTVCO3dCQW1FNkN6MUI7WUFuRTdDeTFCO1lBQUl5Rjs7a0JBMENGOztXQWNBLFlBeERFQSxTQXdESSxrQkF4RFJ6RixJQUFFbnJCLEVBdURtQnBLO1dBQ2Isc0JKcHpEZjs7V0lzekRTLFlBMURFZzdCLFNBMERJLGtCQTFEUnpGLElBQUVuckIsRUF5RG1Cbks7V0FDYixzQkp0ekRmOztXSXd6RFMsWUE1REUrNkIsU0E0REksa0JBNURSekYsSUFBRW5yQixFQTJEYWpLO1dBQ1Asc0JKeHpEZjs7ZUl5ekQyQjhzQyxRQTdEaEJqUyxTQTZEVzk2QixJQTdEWDg2QjtrQkFuTE40UjtvQ0FpUGlDLGtCQTlEL0JyWCxJQUFFbnJCLEVBOERnQyxPQURuQmxLLElBQUsrc0M7O2VBeEJGQyxRQXJDZGxTLFNBcUNJMzZCLE1BckNKMjZCOzs7b0JBOEZObVMsK0JBOUZFNVgsSUFBRW5yQixFQXFDZ0I4aUMsUUFBVjdzQzs7b0JBeURWOHNDLHdCQTlGRTVYLElBQUVuckIsRUFxQ2dCOGlDLFFBQVY3c0MsUUFpQ0g7YUF3QlA4c0MsNkJBR0UxZ0IsRUFBRXJpQixFQUFFcXRCO01BSE47UUFPSSxtQkFBTSx3QkFKUmhMLEVBQUVyaUIsRUFBRXF0QixJQUdRcDNCO1FBQ0osc0JKajJEZjtNSSsxRFM7O2VBckdBd3NDLHlCQW1HRnBnQixFQUFFcmlCLEVBQUVxdEI7b0NBbkdGb1Ysa0JBbUdGcGdCLEVBQUVyaUIsRUFBRXF0QixLQUlzQzthQXZHeENxVixhQUVGcmdCLEVBQUVyaUIsRUFBRXF0QjtNSjV2RFgsdUJJMHZEU29WLGlCQUVGcGdCLEVBQUVyaUIsRUFBRXF0QjthQThGTjJWLG1CQUdFM2dCLEVBQUVyaUIsRUFBRXF0QjtNSjcxRFgsdUJJMDFESzBWLHVCQUdFMWdCLEVBQUVyaUIsRUFBRXF0QjthQTFCTnNWLHdCQUlFdGdCLEVBQUVyaUIsRUFBRXF0QixJQUFJNzVCLElBQUlFO01BQVEsVUFBWkY7a0JBQUlFO1VBTVYsR0FOVUE7WUFNRyxzQkFOZjJ1QixFQUFFcmlCLEVBQUVxdEIsS0FNSSxvQko3MERmO1lJNjBEZSxzQko3MERmO1VJeTBEZSxzQkFGUmhMLEVBQUVyaUIsRUFBRXF0QjtVQUVJLHNCSnowRGY7UUkyMERlLHNCQUpSaEwsRUFBRXJpQixFQUFFcXRCO1FBSUksc0JKMzBEZjs7UUl1MEQyQixTQUFaNzVCO29CQUFJRTtZQVlWLEdBWlVBO2NBWUcsc0JBWmYydUIsRUFBRXJpQixFQUFFcXRCLEtBWUksb0JKbjFEZjtjSW0xRGUsc0JKbjFEZjtZSSswRGUsc0JBUlJoTCxFQUFFcmlCLEVBQUVxdEI7WUFRSSxzQkovMERmO1VJaTFEZSxzQkFWUmhMLEVBQUVyaUIsRUFBRXF0QjtVQVVJLHNCSmoxRGY7a0JJdTBEbUIzNUI7VUFrQlYsR0FsQlVBO1lBa0JVOytCQWxCdEIydUIsRUFBRXJpQixFQUFFcXRCO2FBa0JXLG9CSnoxRHRCO2FJeTFEZSxvQkp6MURmO1lJeTFEZSxzQkp6MURmO1VJcTFEc0Isc0JBZGZoTCxFQUFFcmlCLEVBQUVxdEIsS0FjSSxvQkpyMURmO1VJcTFEZSxzQkpyMURmO1FJdTFEc0Isc0JBaEJmaEwsRUFBRXJpQixFQUFFcXRCLEtBZ0JJLG9CSnYxRGY7UUl1MURlLHNCSnYxRGYsYUl5MURxRDthQWdCNUM0VixXQUFXampDLEVBQUVUO01KejJEdEIsSUl5MkRzQkM7TUFBTTtpQkFBTkE7UUFlVzs7UUFmTCxPQUFOQTs7V0FFVDtZQURlckssV0FETnFLO1lBQ0d5RyxFQURIekc7WUFFVCwyQkFEZXJLO1dBRXZCLFdBSGU2SyxFQUNLaUc7V0FFcEIscUJBSGVqRyxFQUVYN0o7O29CQUZhcUo7O2FBS2pCLElBRG9DQzthQUNwQyxXQUxlTzthQUtDLGNBTERBO2FBS2YsSUFMaUJSLE1BSW1CQzs7ZUFFQW1pQztXQUNwQyxXQVBlNWhDO1dBT0MsY0FQREE7ZUFBRVIsTUFNbUJvaUM7OztlQU10QjVyQyxFQVpHd0osU0FZTjBqQyxJQVpNMWpDO1dBWVcsV0FaYlEsRUFZSmtqQztXQUFpQixrQkFBZGx0QyxFQVpDZ0s7aUJBYWEsSUFBbEJtakMsSUFiTzNqQyxTQWFXLFdBYmJRLEVBYUxtakMsS0FBa0IscUJBYmJuakM7O2VBY0t5TSxJQWRIak4sU0FjQTRqQyxJQWRBNWpDO1dBY1csV0FkYlEsRUFjRW9qQztXQUFXLG1CQUFSMzJCOzs7ZUFOR3hKLElBUk56RCxTQVFHa2lDLElBUkhsaUM7V0FTVyxXQVRiUSxFQVFLMGhDO1dBQ1EscUJBVGIxaEMsRUFRUWlEOztlQUVGbEssRUFWSnlHLFNBVUNtaUMsSUFWRG5pQztXQVdXLFdBWGJRLEVBVUcyaEM7V0FDVSwyQkFYYjNoQyxFQVVNakgsR0FLUzthQUsxQnNxQyxXQUFXMXJDLEVBQUU0SDtNSjczRHRCLElJNjNEc0JDO01BQU07aUJBQU5BO1FBZVc7O1FBZkwsT0FBTkE7O1dBRVQ7WUFEZXJLLFdBRE5xSztZQUNHeUcsRUFESHpHO1lBRVQsMkJBRGVySztXQUV2QixXQUhld0MsRUFDS3NPO1dBRXBCLGtCQUhldE8sRUFFWHhCOztvQkFGYXFKOzthQUtqQixJQURvQ0M7YUFDcEMsV0FMZTlIO2FBS0MsV0FMREE7YUFLZixJQUxpQjZILE1BSW1CQzs7ZUFFQW1pQztXQUNwQyxXQVBlanFDO1dBT0MsV0FQREE7ZUFBRTZILE1BTW1Cb2lDOzs7ZUFNdEI1ckMsRUFaR3dKLFNBWU4wakMsSUFaTTFqQztXQVlXLFdBWmI3SCxFQVlKdXJDO1dBQWlCLGtCQUFkbHRDLEVBWkMyQjtpQkFhYSxVQWJYNkg7O2VBY0dpTixJQWRIak4sU0FjQTJqQyxJQWRBM2pDO1dBY1csV0FkYjdILEVBY0V3ckM7V0FBVyxtQkFBUjEyQjs7O2VBTkd4SixJQVJOekQsU0FRR2tpQyxJQVJIbGlDO1dBU1csV0FUYjdILEVBUUsrcEM7V0FDUSxrQkFUYi9wQyxFQVFRc0w7O2VBRUZsSyxFQVZKeUcsU0FVQ21pQyxJQVZEbmlDLFNBV1csV0FYYjdILEVBVUdncUMsS0FDVSxnQkFYYmhxQyxFQVVNb0IsR0FLUzthQU0xQnVxQyxXQUFXM3JDLEVBQUU0SDtNSmw1RHRCLElJazVEc0JDO01BQU07aUJBQU5BO1FBZVc7O1FBZkwsT0FBTkE7O1dBRVQ7WUFEZXJLLFdBRE5xSztZQUNHeUcsRUFESHpHO1lBRVQsMkJBRGVySztXQUV2QixXQUhld0MsRUFDS3NPO1dBRXBCLGtCQUhldE8sRUFFWHhCOztvQkFGYXFKOzthQUtqQixJQURvQ0M7YUFDcEMsV0FMZTlIO2FBS0MsV0FMREE7YUFLZixJQUxpQjZILE1BSW1CQzs7ZUFFQW1pQztXQUNwQyxXQVBlanFDO1dBT0MsV0FQREE7ZUFBRTZILE1BTW1Cb2lDOzs7ZUFNdEI1ckMsRUFaR3dKLFNBWU4wakMsSUFaTTFqQztXQVlXLFdBWmI3SCxFQVlKdXJDO1dBQXFELGtCQVpqRHZyQyxFQVlpRCxXQUFsRDNCO2lCQUNjLFVBYlh3Sjs7ZUFjR2lOLElBZEhqTixTQWNBMmpDLElBZEEzakM7V0FjVyxXQWRiN0gsRUFjRXdyQztXQUFXLG1CQUFSMTJCOzs7ZUFOR3hKLElBUk56RCxTQVFHa2lDLElBUkhsaUM7V0FTVyxXQVRiN0gsRUFRSytwQztXQUNRLGtCQVRiL3BDLEVBUVFzTDs7ZUFFRmxLLEVBVkp5RyxTQVVDbWlDLElBVkRuaUMsU0FXVyxXQVhiN0gsRUFVR2dxQyxLQUNVLGdCQVhiaHFDLEVBVU1vQixHQUtTO2FBTTlCd3FDO01BQ1EsSUFEa0JsVyxhQUNsQjtlQUNOaEwsRUFBRTlpQixLQUFNLFdBRFJ2RSxJQUNFdUUsS0FBbUMseUJBRHJDdkUsS0FDMEQ7TUFEcEQsbUJBQ05xbkIsSUFGd0JnTDthQVMxQm1XLG1CQUFtQjl1QztNQUNsQixxQkFEa0JBLFlBQ0o7TUFDZixJQUFJZ0YsSUFBSixzQkFGbUJoRjtNQUVuQixTQUNJK3VDO1FBQWlCLHlDQUhGL3VDLElBR21EO01BRHRFLFNBRVFndkMsYUFBYTV4QztRSnA3RDFCLElJbzdEMEJvRztRQUNuQjthQURtQkEsUUFGakJ3QixJQUdjLE9BREd4QjtVQUVYLDBCQU5TeEQsSUFJRXdEO3lDQUlWLE9BSlVBO1VBRVgsSUFDVSxJQUhDQTttQkFJVDtNQU5aLFNBT0l5ckMsWUFBWTd4QyxFQUFFZ1g7UUp6N0R2QixJSXk3RHVCNG5CO1FBQ2hCO2FBRGdCQSxRQVBkaDNCLElBUWMsT0FEQWczQjtVQUVSLDBCQVhTaDhCLElBU0RnOEIsS0FFUjtpQ0FFQyxPQUpPQTtVQUVSLElBQ1UsSUFIRkE7bUJBSU47TUFYWixTQVlJa1QsVUFBVTl4QyxFQUFFZ1g7UUo5N0RyQixJSTg3RHFCNG5CO1FBQ2Q7YUFEY0EsUUFaWmgzQixJQWFjLE9BREZnM0I7VUFFTiwwQkFoQlNoOEIsSUFjSGc4QjtVQUVOOzs7O1VJaDdDTixhSmk3Q3NCLFFBSFZBO1VBSUwsT0FKS0EsSUFJSjtNQUNDOztPQUNGLGlCQURQbVQ7T0FFVyxlQXJCSW52QyxJQW1CZm12QyxPQUNBQyxPQURBRDtPQUdTLG9CQUZUQztPQUdPLGVBRFBFO01BQ08sR0FEUEEsV0FDQUM7V0FDQUM7O09BRUE7U0FBeUQ7a0NBQXZDLE1BMUJIeHZDLElBc0Jmc3ZDLE9BQ0FDLE9BREFEO1VBRUFFOzs7O29CQUdrQjtNQVJULElBU1RDLFFBQVUsYUFMVkY7TUFLVSxHQUFWRSxZQTFCQXpxQyxJQTJCbUI7TUFWVjs7UUFVd0IscUJBUmpDcXFDOzs7O1FBU0FLOzhCQVRBTDs7O29EQWVZOzs7Ozs7TUlwOENaLGdCSjg3Q0FLO01BT0osVUFiSUYsT0FNQUUsU0FPYzthQU9sQkMscUJBR0E3d0MsSUFBSTY1QjtNQUFPLFVBQVg3NUI7T0FDc0IsWUFEbEI2NUI7O1FBQU8sU0FBWDc1QixZQUVnQmlrQyxFQUZoQmprQyxPQUVhMkMsRUFGYjNDLG9CQUVhMkMsRUFBR3NoQyxHQUZacEs7UUFHa0IsSUFBVnBxQixJQUhaelA7UUFHc0IsYUFBVnlQLEtBSFJvcUIsS0FHc0Q7YUFlMURpWCxxQkFJQTl3QyxJQUFJRSxLQUN1QjI1QjtNQWJmLFVBWVIzNUI7T0FUZSxVQVNmQSxVQUN1QjI1Qjs7T0FYUixNQVVmMzVCLG9CQVZVdVMsR0FXYW9uQjtVQUFOeDVCO2dCQURyQkw7T0FHc0IsWUFGREssT0FBTXc1Qjs7aUJBRDNCNzVCLFlBSWdCaWtDLEVBSmhCamtDLE9BSWEyQyxFQUpiM0Msb0JBSWEyQyxFQUFHc2hDLEdBSEs1akMsT0FBTXc1QjtRQUlMLElBQVZwcUIsSUFMWnpQO1FBS3NCLGFBQVZ5UCxLQUpTcFAsT0FBTXc1QixLQUlzQzthQU9qRWtYLGtCQUFtQkMsZ0JBQWdCOXZDO01BaUJyQyxHQWpCcUI4dkM7T0FrQkosU0FsQklBLG1CQWlCakJFLGtCQUNLRDs7V0FETEM7TUFpQkosU0FBSUMsdUJBQXVCaFksUUFBUWxnQjtRQUNqQyx5Q0FuQ21DL1gsSUFrQ1ZpNEIsUUFBUWxnQixJQUdoQjtNQUhuQixTQVFJbTRCLHlCQUF5QkM7UUFDM0IsOEJBRDJCQSxxQ0FFQztNQVY5QixTQW9CSUMsdUJBQXVCblksUUFBUTV6QixFQUFFNUM7UUFDbkMseUNBdkRtQ3pCLElBc0RWaTRCLFFBQVE1ekIsRUFBRTVDLEVBR2xCO01BdkJuQixTQTRCSTR1QyxtQkFBbUJwWSxRQUFRcVksU0FBU3h0QjtRQUN0Qyx5Q0EvRG1DOWlCLElBOERkaTRCLFFBQVFxWSxTQUFTeHRCLEtBR1g7TUEvQjdCLFNBcXZCSXl0QixZQUdBQyxVQUFVdlksUUFBUVU7UUFBTyxJQUd6QjhYLEtBSFV4WSxVQUFWdVk7UUFBeUIsYUFHekJDO29CQUhrQjlYO3VCQUdsQjhYOzBCQUQrQixnQkE1eEJFendDLElBMHhCakN3d0MsV0FBa0I3WDswQkFHZSxNQTd4QkEzNEIsSUEweEJqQ3d3QyxVQUdBQyxNQUhrQjlYLEtBR21EO01BM3ZCekUsU0FzdEJJK1gsZUFBZXpZLFFBQVFrWSxRQUFRdGxDO1lBQWhCOGxDLGtCQUFnQjdsQztRQUNqQzthQURpQjZsQyxjQUFRUixRQUNDLHlCQUREQTtVQUVuQixzQkExdkI2Qm53QyxJQXd2QmxCMndDLFdBRVgsU0FDSnRzQztVQURJLHNCQVNDLFVBWFVzc0MsVUFBZ0I3bEM7VUFFM0IsSUFGMkJDLDBCQUcvQjFHO1VBQ0EsdUJBSitCMEc7V0FNN0I7MkNBOXZCK0IvSyxJQXd2QkYrSztVQUUzQixJQVFGLFVBVmE0bEMsc0NBQWdCN2xDO21CQVdkO01BanVCckIsU0FxdUJJK2xDLGNBQWM1WSxRQUFRa1k7UUFDeEIsR0FEZ0JsWSxZQUFRa1ksUUFDRSx5QkFERkE7UUFFbEIsMEJBendCNkJud0MsSUF1d0JuQmk0QjtRQUVWOzZCQUNVLHNCQUhBQSxRQUFRa1k7OztXQUlmLElBSk9sWSxxQkFBUWtZLFFBS1EseUJBTFJBO1dBTWhCLHNCQTd3QjJCbndDLElBdXdCbkJpNEIsaUJBTVIsU0FJSjV6QjtXQUpJO1lBS0osMEJBWFk0ekIsMEJBVVo1ekI7V0FKSTtZQUVjLHVCQVJONHpCLGdCQUFRa1k7WUFRRjs7cUJBQWRXLFdBQVUvdEM7UUFLWCw2QkFBWTtNQWx2QnJCLFNBZ3RCSWlzQyxhQUFhL1csUUFBUWtZO1FKbnZGNUIsSUltdkZvQlE7UUFDZjthQURlQSxjQUFRUixRQUNHLHlCQURIQTtVQUVwQiwwQkFwdkJnQ253QyxJQWt2QnBCMndDO1lBRWEsY0FGYkE7VUFFcUQsT0FGckRBLFVBRTREO01BbHRCN0UsU0E4MkJJSSxrQkFDRUMsUUFBUS9ZLFFBQVE2VCxLQUFLbUY7UUFDVixJQUFUQyxPQUFTLE1BbDVCb0JseEMsSUFpNUIvQmd4QyxRQUFRL1ksVUFBUitZO1FBQ1c7d0NBbDVCb0JoeEMsSUFpNUIvQmd4QyxRQUFxQkMsT0FBTG5GLEtBQ2RvRixPQUk0QjtNQXAzQnBDLFNBbXpCSUMsaUJBQWlCSCxRQUFRL1ksUUFBUW1aLEtBQUtwaEMsS0FBS3FoQyxNQUFNdkY7WUFBaEJ3RixZQUFLbjFCLFlBQUtvMUI7UUFDN0M7O2FBRG1DRDtlQUFLbjFCOzs7a0JBQUtvMUIsb0JBQU16RixLQUlyQixvQkFKcUJBLEtBSWdCOztjQUozQjN2QjtlQUFLbzFCOzs7NkJBQU16Rjs7Ozs7d0JBTWdCO3lCQUlyQzt5QkFDQTt5QkFIQTt5QkFJQTt5QkFOQTs7O2VBTmV5Rjt5QkFBTXpGLEtBR3JCLG9CQUhxQkEsS0FHZ0I7OzZCQUhoQkE7Ozt3QkFLZ0I7eUJBSHJDO3lCQUFxQzt5QkFLckM7eUJBRUE7eUJBSkE7O1VJMzBFMUI7eUJKczBFK0NBOzs7c0JBYzVCLEdBbDFCckJrRSxrQkFrMUJ3Qzt1QkFDbkIsR0FuMUJyQkEsa0JBbTFCd0M7dUJBRm5CLEdBajFCckJBLGtCQWkxQndDOzs7O2dCQUl4QyxHQXIxQkFBLHVCQW8wQnNDN3pCO2dCQW1CakMseUJBbkJZNjBCLFFBQVEvWSxRQUF3QjZUOzthQUFoQndGO1lBcUJqQyxHQXJCMkNDO2NBcUIzQyxHQXoxQkF2Qix1QkFvMEIyQ3VCO2NBd0J0Qyx5QkF4QllQLFFBQVEvWTtZQThCekIsR0FsMkJBK1gsdUJBbzBCaUNzQjtZQWdDNUIseUJBaENZTixRQUFRL1ksUUFBd0I2VDtVQTBCakQsR0ExQjJDeUY7WUEwQjNDLEdBOTFCQXZCLHVCQW8wQjJDdUI7WUE0QnRDLHlCQTVCWVAsUUFBUS9ZLFFBQXdCNlQ7VUFpQzNCLDhCQUFZO01BcDFCdEMsU0ErdkJJMEYscUJBQXFCdlosUUFBUWtZLFFBQVE5ckM7UUpseUY1QyxJSWt5RjRCc3NDO1FBQ3ZCO2FBRHVCQSxjQUFRUjtXQUU3QixrQ0FueUJpQ253QyxJQWl5QklxRSxFQUFSOHJDO1VBS3pCLDBCQXR5QjZCbndDLElBaXlCWjJ3QztVQUtqQjtZQUVKLElBUHFCQSx1QkFBUVI7YUFPQyx5QkFQREE7WUFRMUIsbUJBenlCOEJud0MsSUFpeUJaMndDLHVCQUFnQnRzQyxFQVFtQixPQVJuQ3NzQztZQVNQLDRCQTF5Qm1CM3dDLElBaXlCWjJ3QztZQVNQOzs7Ozs7cUJBZUk7bURBeEJHQSxrQkFBUVI7c0JBd0JYLFVBQVZzQjtzQkF4QmFkOzs7O3FCQWdDakI7OEJBaENpQkE7OztpQkFZakIsSUFaaUJBLHVCQUFRUjtrQkFZSyx5QkFaTEE7aUJBYWIsNEJBOXlCaUJud0MsSUFpeUJaMndDO2lCQWFMO21CQUtJO21EQWxCQ0Esa0JBQVFSO29CQWtCVCxVQUFWd0I7b0JBbEJXaEI7OzttQkFlRDs7MENBZkNBLGtCQUFRUjtvQkFlVCxVQUFWMEI7b0JBZldsQjs7aUJBYUwsSUFPTCxVQXBCVUE7Ozs7Z0JBNEJIO2dEQTVCR0Esa0JBQVFSO2lCQTRCWCxVQUFWNkI7aUJBNUJhckI7OztlQW1DakIsMEJBbkNpQkE7WUFTUCxJQTRCVixVQXJDaUJBOztVQUtqQixJQWtDQyxVQXZDZ0JBO21CQXVDNEI7TUF0eUJyRCxTQWltQkl3QixpQkFDQWxhLFFBQVFrWTtRQUNWO1VBRW9CO2tDQUhsQmxZLFFBQVFrWTtXQUlBLHdCQXhvQnlCbndDLElBdW9CM0JveUM7O1VBQ0U7Ozs7VUl6bkVOO1lKMm5Fd0I7bUNBSHBCQSxVQUhFakM7YUFNa0I7O2FBQ04sdUJBRFprQyxVQU5BbEM7WUFRRCwwQkE1b0IwQm53QyxJQTJvQnpCc3lDLFdBQzJCO1lBRlQ7YUFHZCxRQTdvQnFCdHlDLElBb29CakNpNEIsaUJBT1FxYSxZQVBScmE7d0JBT1FxYSxxQkFFQTd3QyxFQUhXZ3ZDOzs7VUFIRDs7Ozs7O1VBYUs7O1dBRFB0MEM7V0FBVjIwQztXQUNpQixjQURqQkEsU0FmRVg7V0FnQmU7d0JBRFBoMEMsZUFDSjRxQztRQUdXLGtCQW5CdkI5TyxRQUFRa1ksU0FtQmU7MkJBQVhuSixZQUN1QztNQXRuQnZELFNBbWtCSXdMLGlCQUNBdmEsUUFBUWtZO1FBQ1Y7O2dCQURFbFksWUFBUWtZO2dDQUdrQixnQkF6bUJPbndDLElBc21CakNpNEI7VUFHb0Q7VUFDbEM7a0NBSmxCQSxnQkFBUWtZO1dBS0Esd0JBM21CeUJud0MsSUEwbUIzQm95Qzs7VUFDRTs7OztVSTVsRU4sY0o0bUVPO1VBakJTO1dBR1Msc0JBSHJCQSxVQUpFakM7V0FPbUI7O1dBQ0wsdUJBRGRrQyxVQVBBbEM7V0FTSSx3QkEvbUJxQm53QyxJQThtQnZCc3lDO1dBQ0U7Ozs7WUFFTTtxQkFqbkJldHlDLElBc21CakNpNEIsaUJBUVVxYSxZQVJWcmE7YUFXa0IsUUFBSngyQixFQUpLZzNCO2FBSUQsS0FIUjZaO2FBUEVHO2FBQVYzQjs7Ozs7O2NBYWdDO3FDQU54QndCLFVBUkZuQztlQWMwQjs7ZUFDUix1QkFEWnVDLFVBZE52QztjQWdCSywwQkF0bkJvQm53QyxJQXFuQm5CMnlDLFdBQzJCO2NBRlA7ZUFHaEI7c0JBdm5CZTN5QyxJQXNtQmpDaTRCLGlCQWVjMGEsWUFmZDFhO2VBaUJrQixRQUFKMXBCLElBVktrcUIsTUFPTTNEO2VBR1AsS0FGSjZkO2VBZEZGO2VBQVYzQjs7O3NCQWtCYTs7O3VEQUliO2NBdEJVMkIsZ0NBQVYzQixTQURGN1k7UUF5QnFCLGdCQXhCbkI2WSxTQURNWCxTQXlCYTtzQkF4QlRzQyxpQkF3QkYxTCxVQUN1QztNQTlsQnJELFNBMGlCSTZMLFVBQ0FDLFlBQVk1YSxRQUFRa1k7UUFDdEI7YUFEY2xZLFlBQVFrWSxRQUVNO1VBQ3BCLDRCQWhsQjJCbndDLElBNmtCckJpNEI7VUFHTjtZQUVNLElBQU42YSxJQUFNLGFBbGxCcUI5eUMsSUE2a0JyQmk0QjtZQUtBLEdBTFFrWSxXQUtkMkMsSUFDbUI7WUFEYjthQUVJLGNBcGxCaUI5eUMsSUE2a0JyQmk0QixTQUtONmEsTUFMTTdhO2FBUWEsY0FIbkI2YSxZQUxjM0M7YUFRSzthQUNELGNBVFpsWSxRQUtONmE7YUFJa0I7NkJBQVZFLFFBRlJEO2FBRWtCLGFBVHhCRixlQVVNSTthQUUyQyxZQUQzQ0MsYUFIUWxNOztVQU9aOzs7O1lBRXFCO3lCQWpCWC9PLFFBQVFrWTthQWlCRzt3QkFqQnZCMEMsZUFrQkkzMkM7WUFFMkMsY0FEM0NpM0MsV0FGUXBNO3FCQUltQztNQWhrQm5ELFNBK0RJcU0sWUFpQ0FwQyxRQW5CaUIvWSxRQW1CRGtZLFFBQW1DL3VDO1FBOUJyRDtpQkFHSWt5QyxTQUFTcmIsUUFBUThYO1VBRW5CLFNBRm1CQSxRQUVuQixjQXhGQUM7VUF5RkU7WUFFYyx5QkE1R2lCaHdDLElBdUd0Qmk0QjtZQUdULGtDQTFHK0JqNEIsSUF1R3RCaTRCO1VBS2tCO2tCQUNoQjtZQUVJMFk7UUFDakI7YUFEaUJBLGNBbUJEUixRQWxCVSx5QkFrQlZBO1VBakJKLDBCQWpIcUJud0MsSUErR2hCMndDLFdBRUw7Ozs7Y0FLSCxTQVBRQSxVQVZNVTtjQWlCZCxjQVBRVjs7O2NBTVIsU0FOUUEsVUFUZjNnQztjQWVPLGNBTlEyZ0M7OztjQUtSLFNBTFFBLFVBVmZTO2NBZU8sY0FMUVQ7OztjQUlSLFNBSlFBLFVBWE0wQztjQWVkLGNBSlExQzs7O2NBR1IsU0FIUUEsVUFYZnoxQjtjQWNPLGNBSFF5MUI7OztVQUVMO1dBT1YsS0FuQnFCVTtXQW1CckIsS0FsQkFyaEM7V0FrQkEsS0FuQkFvaEM7V0FtQkEsS0FwQnFCaUM7V0FvQnJCLEtBcEJBbjRCO1VBK0JKLEdBcEJtQnkxQixjQW1CRFIsUUFDUSx5QkFEUkE7VUFqQko7V0FrQjRDOzs7Z0JBbEh4REg7O2tCQXlITyxrQkFSUGdCLFFBbkJpQkw7OztXQTRCYix3QkEzSTZCM3dDLElBK0doQjJ3QztVQTRCYjs7Y0FFaUI7c0NBOUJKQSxVQW1CRFI7ZUFXSzs7O3VCQVhyQmE7dUJBV0l1Qzt1QkFYWXBEOzs7Ozt1QkFBbUMvdUM7MEJBRWpEazVCLE1BU1c3Qjs7O1lBSWI7cUJBZkF1WTtxQkFuQmlCTDtxQkFtQkRSOzs7OztxQkFBbUMvdUM7d0JBRWpEazVCO1VBZ0JGLE9BaEJFQTs7YUFrQkEsT0FySUYwVjtjQXNJSSx1QkF4Q2FXO2FBd0NxQztzQkFyQnRESyxRQW5CaUJMLFVBbUJEUiw0QkFBbUMvdUM7O2FBK0JqRDtzQkEvQkY0dkMsUUFuQmlCTCxVQW1CRFIsNEJBQW1DL3VDOzthQTRCakQ7c0JBNUJGNHZDLFFBbkJpQkwsVUFtQkRSLDRCQUFtQy91QyxXQU5uQztNQTFGcEIsU0FvSUlveUM7UUFpQkF4QyxRQWRRL1ksUUFjUWtZLFFBQVFrRCxNQUFNakMsS0FBS3BoQyxLQUFLcWhDLE1BQU1qd0MsSUFBSXRDO1FBYnBELEdBRFVtNUIsWUFjUWtZLFFBYlEseUJBYVJBO1FBWlosSUFJSnJFLEtBSkksZ0JBM0s2QjlyQyxJQXlLekJpNEI7UUFFSixVQUlKNlQ7VUFGQSxJQVVRNkUsVUFkQTFZO1VBZVYsR0FEVTBZLGNBQVFSLFFBQ1EseUJBRFJBO1VBVmhCO1dBV3dEO3FCQUN4Q2tELE1BQU1wYjtjQUNGO29DQURFQSxRQUZOa1k7ZUFHSTs7O3VCQUhwQmE7dUJBR0l1Qzt1QkFIWXBEO3VCQUVBa0Q7dUJBRmNqQzt1QkFBS3BoQzt1QkFBS3FoQzt1QkFBTWp3Qzt1QkFBSXRDOzBCQUdyQ0UsTUFFYTtXQUN0Qix1QkE3TDZCZ0IsSUF1THpCMndDO1VBTUosU0FFSmdEO2dDQURjLHFCQVBVTixNQUFoQjFDOztvQkFRUmdEOzs7O2dCQVdBO3lCQW5CQTNDO3lCQUFRTDt5QkFBUVI7eUJBQVFrRDt5QkFBTWpDO3lCQUFLcGhDO3lCQUFLcWhDO3lCQUFNandDO3lCQUFJdEM7Ozs7Z0JBUXpCLEdBOUt6Qmt4QztrQkF1TEE7d0JBakJRVzttQkFpQlIsUUFqQndCMEMsaUJBUXhCTTtrQkFjQSxxQkF0QndCQzs7O1VBc0J4QixPQTVMQTVEO21CQWdNRTtxQkExQkZnQjtxQkFBUUw7cUJBQVFSO3FCQUFRa0Q7cUJBQU1qQztxQkFBS3BoQztxQkFBS3FoQztxQkFBTWp3QztxQkFBSXRDOzttQkE2QmhELHVCQTdCTTZ4QztRQVBSO2lCQU9BSztpQkFkUS9ZO2lCQWNRa1k7aUJBQWNpQjtpQkFBS3BoQztpQkFBS3FoQztpQkFBTWp3QztpQkFBSXRDOzs7aUJBUmxEZ3RDLEtBRXVCO01BL0kzQixTQXFMSTRIO1FBR0ExQyxRQUFRL1ksUUFBUWtZLFFBQVFrRCxNQUFNakMsS0FBS3BoQyxLQUFLcWhDLE1BQU1qd0MsSUFvQjlDdEMsSUFwQnNEOE87UUFDeEQsR0FEVXFxQixZQUFRa1ksUUFDUSx5QkFEUkE7UUFDd0MsU0FDdEQyRCxXQUE4QkM7VUFFakI7bUJBSmYvQzttQkFBUS9ZO21CQUFRa1k7bUJBQWNpQjttQkFBS3BoQzttQkFBS3FoQzttQkFBTWp3QzttQkFvQjlDdEM7bUJBcEJzRDhPO21CQUV0Qm1tQzttQkFFakIsZ0JBOU5rQi96QyxJQTBOekJpNEIsU0FJb0I7UUFINEIsVUFtQnhEbjVCO1VBTnVCLFVBZCtCOE8sOEJBYy9CO2FBZEN5bEM7c0JBQThCemxDLG1CQWtCM0I7WUFGRSxJQUFMN0ssRUFoQjhCNks7WUFnQnpCLHVCQUFMN0s7b0JBaEI4QjZLLG1CQWlCMUI7VUFGRSxJQUFMMkMsSUFmNkIzQztVQWV4Qix1QkFBTDJDO1FBS2xCLGtCQUFQelIsSUFBcUI7TUE1TXpCLFNBK01JKzBDO1FBd29CbUI3QyxRQUFRL1ksUUE5TkprWSxRQXZhQ2lCLEtBQUtwaEMsS0FBS3FoQyxNQUFNandDLElBQUl0QyxJQUFJRSxLQUFLKzBDLFFBcW9CRmpJO1FBbm9CckQ7Ozs7Ozs7aUJBS0l3SSxnQkFBaUIsd0JBUEtsRCxJQU9tQjtRQUw3QyxTQU1JbUQsZ0JBQWdCLHdCQVJXdmtDLElBUVk7UUFOM0MsU0FPSXdrQyxpQkFBaUIseUJBVGVuRCxLQVNVO1FBUDlDLFNBUUlvRCxlQUFpQix1QkFWcUJyekMsR0FVRTtRQVI1QyxTQVNJc3pDLGVBQWlCLHVCQVh5QjUxQyxHQVdGO1FBVDVDLFNBVUk2MUMsZ0JBQWlCLHdCQVo2QjMxQyxJQVlMO1FBVjdDLFNBV0k0MUMsbUJBQWlCLHVCQWJrQ2IsT0FhUDtRQVhoRCxTQWFJYztVQVlLLG1CQUFZO2tEQUNPLE9BQXJCLzFDOztXQUNxQjs7cUJBRHJCQTs7Z0JBR0EsSUFEb0JpRSxFQUZwQmpFO2dCQUdBLE9BbFFMa3hDOzhCQWlReUJqdEM7eUJBRWYsa0JBcW1CU2l1QyxRQUFRL1k7Y0FqbUJLLE9BUjNCbjVCOztxQkEvUExreEM7O3VCQXNRVSxrQkFrbUJTZ0IsUUFBUS9ZO3FCQXptQnRCbjVCLElBUzhCO1FBbkNyQyxTQXNDSWcyQyxXQUFXaEosS0FBd0JodEM7VUFDckMsVUFEcUNBO1dBRXJCLE9BRnFCQTs7WUFDckMsU0FEcUNBOztnQkFNbkMsSUFEb0IyNUIsTUFMZTM1QjtnQkFNbkMsT0FqUkZreEM7OEJBZ1JzQnZYO3lCQUVmLGtCQXNsQll1WSxRQUFRL1ksUUE3bEJkNlQ7Y0FHd0IsT0FIQWh0Qzs7cUJBM1FyQ2t4Qzs7dUJBcVJPLGtCQW1sQllnQixRQUFRL1ksUUE3bEJkNlQ7cUJBQXdCaHRDLElBVVk7UUFoRG5ELFNBc0RJaTJDLFdBQVcxd0MsRUFBcUJ2RjtVQUF3QixVQUF4QkE7V0FDbEI7O1lBRDBDLFNBQXhCQTs7O2dCQU9oQyxJQURtQjI1QixNQU5hMzVCO2dCQU9oQyxPQWxTRmt4Qzs0QkFpU3FCdlg7eUJBRWQsa0JBcWtCWXVZLFFBQVEvWSxRQTdrQmQ1ekI7c0JBRW1CLElBQVZvbkMsUUFGWTNzQyxPQUVGLFVBQVYyc0M7O2dCQUVwQixJQURvQnVKLFFBSFlsMkM7Z0JBSWhDLE9BL1JGa3hDOzRCQThSc0JnRjt5QkFFZixrQkF3a0JZaEUsUUFBUS9ZLFFBN2tCZDV6QjtZQVNNLHlCQW9rQkEyc0MsUUFBUS9ZLFFBN2tCZDV6QixVQVMrQztRQS9EOUQsU0FpRUk0d0MsWUFBWTV3QyxHQUFpQixrQkFBakJBLEVBQWlCLFdBQVk7UUFqRTdDLFNBa0VJNndDLGdCQUFnQjd3QyxHQUFpQixrQkFBakJBLEVBQWlCLGVBQWdCOztRQWxFckQsVUFtb0JxRHluQzs7Ozs7WUF2YTVCOzJCQXVhSTdULFFBOU5Ka1k7YUF6TUE7YUEvSXJCZ0Ysa0JBK0lVOU47OztZQWdCRTswQ0F1WmFwUCxRQTlOSmtZO2FBeExBLGNBRG5Cc0IsZ0JBeUxtQnRCO2FBeExBO2FBQ0QsY0FxWktsWSxRQXZadkJ3WjthQUVrQjthQUNOLHVCQURKdUI7WUFFVDthQUNtQzsyQ0FGbEMzWDswQkFFRStaLFVBSk14Tjs7NkJBT2EsZ0JBTHJCdk0sVUFGUXVNO1lBREUsSUEvSlp1Tjs7a0NBRUYsTUFvakIyQmxkLFFBOU5Ka1k7O1lBaFVBOzRCQThoQklsWSxRQTlOSmtZO2FBaFVBO2FBQ3BCLHlCQURTL0g7YUF4QlYrTTs7O1lBMkRxQjs0QkEyZklsZCxRQTlOSmtZO2FBN1JBOztZQUVwQjthQUNELGtCQUZFa0YsdUJBRUVDLFVBSE12TTs7NkJBQ1JzTSxVQURRdE07WUFBVyxJQTNEckJvTTs7O1lBc0NROzhCQWdoQnlDckosS0FoaEJ6QjthQUNILGVBK2dCSTdULFFBOU5Ka1k7YUFqVEE7WUFDcEI7YUFDaUM7OzBCQUE5Qm9GLFVBRk1yTTs7YUFNUjs0Q0FQQW5wQyxNQUNRbXBDO2NBTVI7O3lCQURtQi9vQyxNQUFNa3BDO1lBTm5CLElBdENSOEw7OztZQXlWSixHQTZONkJsZCxZQTlOSmtZLFFBQ0MseUJBRERBO1lBR1Y7OytCQUNGOXJDLEdBQ1gsdUJBRkV2RCxTQUNTdUQsRUFDZTthQUZiO3VCQUlEd08sSUFBRXhPO2dCQUNkLE1BRGNBLElBQUZ3TztzQkFDWnpWLEVBRFl5VjtrQkFFVjtvQ0FOQS9SLFNBTXlCLFlBRDNCMUQ7b0JBQ0UsU0FERkE7dUJBRGNpSCxNQUNkakg7O2dCQUhBLFFBS0k7YUFQUzt1QkFVUzY2QjtnQkFDdEIseUNBenFCaUNqNEIsSUF3cUJYaTRCLFFBRzBCO2FBYm5DOytCQXVCWUEsUUFBUWtZO2dCSnRyRnhDLElJc3JGZ0NRO2dCQUN6QjtxQkFEeUJBLGNBQVFSLFFBQ1AseUJBRE9BO2tCQUUzQixJQU1KOXJDLEVBTkksZ0JBdnJCMkJyRSxJQXFyQlIyd0M7a0JBRW5CLFVBTUp0c0M7b0JBRkE7a0NBTnVCc3NDOzs0QkFRdkJ0c0MsRUFKQSxPQUp1QnNzQztrQkFFbkIsU0FGbUJBO2tCQVN2Qjs7MkJBR0FnRiwyQ0FaK0J4RixRQVEvQjlyQzs7MkJBSUFzeEMsb0NBWitCeEYsUUFRL0I5ckMsSUFDaUQ7YUFoQ3RDOytCQW1DZTR6QixRQW9CU2tZLFFBcEJPOXJDO29CQUFoQnNzQyxrQkFBZ0I5OUI7Z0JBQzVDO3FCQUQ0Qjg5QixjQW9CU1IsUUFuQlgseUJBbUJXQTtrQkFsQi9CLHdCQW5zQjJCbndDLElBaXNCTDJ3QztrQkFFdEIsU0FGc0M3OUI7Ozs7b0NBSTFDLFNBSjBDRCxLQUkxQyxPQUowQjg5Qjs7NkJBQWdCNzlCOzs7O3NCQU8xQyxJQWEyQjQrQixVQXBCRGY7c0JBcUI1QixHQUQ2QmUsY0FBUXZCLFFBQ1gseUJBRFdBO3NCQWJuQyxJQTRCQXA5QixJQWJJLGdCQXZ0QjJCL1MsSUFxdEJKMHhDO3NCQUV2QixVQWFKMytCO3dCQVBBLElBUjJCMitCLHVCQUFRdkI7eUJBUUwseUJBUktBO3dCQVN2QixJQUNSbjlCLElBRFEsZ0JBOXRCbUJoVCxJQXF0QkoweEM7a0NBVXZCMStCO3lCQUdLLDJCQWJrQjArQjt3QkFXdkIsVUEvQnNDNytCLElBOEJ0Q0c7d0JBRFEsU0FUZTArQjt3QkFXdkI7O2lDQTNDSmdFLHNDQWdDbUN2Rjs7aUNBaENuQ3VGLCtCQWdDbUN2RjtnQ0FlbkNwOUI7d0JBWEEsU0F4QjBDRixLQXlCMUMsb0JBTDJCNitCO3NCQWdCM0IsVUFwQzBDNytCLElBbUMxQ0U7c0JBNUJBLFNBYTJCMitCO3NCQWdCM0I7OytCQWhEQWdFLHNDQWdDbUN2Rjs7K0JBaENuQ3VGLCtCQWdDbUN2RjtrQkFaWixzQkFSbUJ0OUI7b0JBUzFDLFNBVDBDQztvQkFTMUMsU0FUMEI2OUI7b0JBUzFCOzs2QkFyQkErRSxzQ0FnQ21DdkY7OzZCQWhDbkN1RiwrQkFnQ21DdkY7a0JBUm5DLFVBWjBDdDlCLElBWTFCLG9CQVpVODlCO2tCQWdCMUIsU0FoQjBDOTlCO2tCQUV0QyxJQWNKLFVBaEIwQjg5QixzQ0FBZ0I5OUI7MkJBaUJRO2FBcER2Qzt1QkFtQ2VvbEIsUUFvQlNrWSxRQXBCTzlyQztnQkpsc0ZuRDt5Qklrc0ZTc3hDLDhCQUEwQjFkLFFBb0JTa1ksUUFwQk85ckM7WUFuQy9CLEdBMk5jNHpCLFlBOU5Ka1ksUUE4RUcseUJBOUVIQTtZQUdWLGFBNEVQLGdCQTF1QjJCbndDLElBeTNCTmk0QjtZQS9JckI7YUFDSyxjQThJZ0JBLGdCQWpKaEI0ZCxVQUFUakY7O2lCQUFTaUYsVUFBVGpGLFVBaUp5QjNZO1lBek0zQixHQXdERTJZLGNBN0VxQlQsUUFxQkcseUJBckJIQTtZQUdWO2FBbUJMLGtCQWpyQnlCbndDLElBd3VCL0I0d0M7YUF2RE0sbUNBdUROQSxrQkE3RXFCVCxRQXNCbkI5ckM7YUE2RFMsMkJBaEZYdkQ7YUFnRlcsV0FORiswQyxRQU9jLGFBRHZCeGQ7YUFqUXFCLGVBZ1FyQnlZLFNBbEZxQlg7YUE5S0E7WUFDcEI7YUFDb0M7NENBSHpCMkY7MEJBR1JDLFVBRk16TDs7NkJBS2MsZ0JBTlp3TCxXQUNGeEw7WUFpTEMsSUEzVlg2Szs7O1lBcUlxQjs0QkFpYklsZCxRQTlOSmtZO2FBbk5BO2FBcklyQmdGLGtCQXFJVXpLOzs7WUFqSVo7O3VCQUFnQjNEO2dCQUNYLDJCQURXQSwyQkFHYzthQU9QLGVBd2lCSTlPLFFBOU5Ka1k7YUExVUE7YUFDWDs7O2VBTFA7eUNBSU84Rjs7O2VBS1A7O2lCQXJVTGpHO21CQXVVeUMsWUFQN0JpRzttQkFoU2Q7cUJBdzBCNkJoZTs7O3NCQXRpQmYsWUFGQWdlO1lBVlosSUFKRWQ7OztZQTJJcUI7NEJBMmFJbGQsUUE5TkprWTthQTdNQTthQUNwQix5QkFEUytGO2FBM0lWZjs7O1lBNEJROzhCQTBoQnlDckosS0ExaEJ6QjthQUNILGVBeWhCSTdULFFBOU5Ka1k7YUEzVEE7WUFDcEI7YUFDNEI7OzBCQUF6QmtHLFdBRk1EOzthQU1SOzRDQVBBRCxNQUNRQztjQU1SOzt5QkFEbUJHLE9BQU1EO1lBTm5CLElBNUJSbkI7OztZQXdJcUI7NEJBOGFJbGQsUUE5TkprWTthQWhOQTthQXhJckJnRixrQkF3SVVxQjs7O1lBYUU7NENBaWFhdmUsUUE5TkprWTthQWxNRCxlQWdhS2xZLFFBamF2QjBaO2FBQ2tCO2FBQ0MsZUFGbkJBLGtCQW1NbUJ4QjthQWpNQTthQUNQLHlCQUZKc0c7WUFHVDthQUNpQzs0Q0FGaENuYjswQkFFRXFiLFdBSE1EOzs2QkFNVyxpQkFMbkJwYixZQURRb2I7WUFGRSxJQXJKWnZCOzs7O1lBMkhROzhCQTJieUNySixLQTNiekI7YUFDSCxlQTBiSTdULFFBOU5Ka1k7YUE1TkE7WUFDcEI7YUFDMEI7OzBCQUF2QnlHLFVBRk01Tzs7YUFNUjs0Q0FQQXpvQyxNQUNReW9DO2NBTVI7O3lCQURtQnRvQyxNQUFNd29DO1lBTm5CLElBM0hSaU47Ozs7WUFrSnFCOzJCQW9hSWxkLFFBOU5Ka1k7YUF0TUE7YUFsSnJCZ0Ysa0JBc2pCaURySixLQXBhdkN0RTs7Ozs7O1lBaEZTLEdBb2ZNdlAsWUE5TkprWTtjQXRSa0M7c0NBcll4Qm53QyxJQXkzQk5pNEI7ZUE5Q1IsS0FBUDBiOztjQUFPOzs7Ozs7Ozs7Ozs7Y0FyY0k7OEJBbWZJMWIsUUE5TkprWTtlQXJSQTs7Y0EwY0EsVUF5QzRCckU7Ozs7K0JBbGYvQzdxQzs7Ozt5QkFrZitDNnFDLFVBbGYvQzdxQzs0QkEyY3dCO2NBMWN6QjtlQUNELGtCQUZFQSxxQkFFRTQxQyxVQUhNbE87OytCQUNSMW5DLFFBRFEwbkM7Y0FBVyxJQW5FckJ3TTs7Ozs7Ozs7O2NBaUxGLGtDQXBmaUNuMUMsSUF5M0JkZ3hDLFFBQWdDbEY7Ozs7Ozs7O1lBcmdCakQ7O2FBRHlEO2FBQS9DOytCQXNnQk9rRixRQUFRL1ksUUF0Z0JrQixzQkFzZ0JNNlQ7YUFwZ0I1QixlQW9nQkk3VCxRQTlOSmtZO2FBdFNBO1lBQ3BCO2FBQ2lDOzJCQUpoQ3h3QyxRQUlnQzswQkFBOUJtM0MsVUFGTXROOzthQU04Qjs7Y0FBdEMsOEJBQXFCLG9CQU5iQTtjQU1SOzs7eUJBUkE3cEMsUUFPbUJVLE1BQU1pbkMsT0FBTzRDO1lBTmxDLElBakRBaUw7Ozs7Ozs7Ozs7WUFpSDhCOzthQUFkO2FBQWQ7YUFzY047Y0FEcUM4QjtnQkFBVUY7a0JBeDJCN0MvRzs7b0JBZzNCSyxrQkFSY2dCLFFBQVEvWTs7Z0JBQWtCOGU7O1lBUy9DLFNBVHFEakw7Ozs7Ozs7Ozs7b0JBU2pEb0w7O3NCQVRpRHBMOzs7Ozs7O2lDQVNqRG9MOzs7OztpQkFUc0NGO3lCQUFXbEwsU0FTakRvTDs7eUJBVGlEcEwsU0FTakRvTDswQkFVRztZQXhkMkI7YUF5ZGxDLFNBbkJJbkgsS0FRQW1IO2FBN2NxQixlQW9jSWpmLFFBOU5Ka1k7YUF0T0E7WUFDcEI7Y0F6SHVCOztlQUdGLGlDQXlqQkxhLFFBQVEvWTs7ZUExakJILDBCQUFSa0I7Y0FGVTtlQTBISzsyQkFBekJnZSxVQUZNN087O2FBTTBCOztjQUFsQyw4QkFBcUIsZ0JBTmJBO2NBTVI7Ozt5QkFUQXhvQyxNQVFtQkQsTUFBTUQsT0FBTzRvQztZQU5KLElBakg5QjJNOzs7UUlwekRBOztvQkowMkVpRHJKOzs7Ozs7O2dCQXplaEM7c0NBaFpjOXJDLElBeTNCTmk0QjtpQkF6ZXZCO2lCQURtRDtpQkFBckQ7O29CQTBlaUIrWSxRQUFRL1ksZ0JBMWVjO2lCQUVsQixjQXdlSUEsZ0JBOU5Ka1k7aUJBMVFBO2dCQUNwQjtpQkFDbUM7NkJBTGxDanhDLE1BS2tDOzhCQUFoQ2s0QyxRQUZNclE7O2lCQU04Qjs7a0JBQXRDLDZCQUFxQixvQkFOYkE7a0JBTVI7Ozs2QkFUQTduQyxNQVFtQkgsTUFBTUksT0FBTzZuQztnQkFOakI7Ozs7Z0JBWWM7c0NBNVpBaG5DLElBeTNCTmk0QjtpQkE3ZFQ7aUJBQWQ7aUJBREY7O29CQThkaUIrWSxRQUFRL1ksZ0JBOWRjO2lCQUVsQixjQTRkSUEsZ0JBOU5Ka1k7aUJBOVBBO2dCQUNwQjtpQkFDdUM7K0JBTHRDOXdDLFFBS3NDOzhCQUFwQ2c0QyxVQUZNcFE7O2lCQU04Qjs7a0JBQXRDLDZCQUFxQixvQkFOYkE7a0JBTVI7Ozs2QkFUQTVuQyxRQVFtQkosTUFBTUssT0FBTzRuQztnQkFOSDsrQkF6Ri9CaU87O3FCQXNqQmlEcko7YUFqZGhDO21DQXhhYzlyQyxJQXkzQk5pNEI7Y0FqZHZCO2NBRG1EO2NBQXJEOztpQkFrZGlCK1ksUUFBUS9ZLGdCQWxkYztjQUVsQixjQWdkSUEsZ0JBOU5Ka1k7Y0FsUEE7YUFDcEI7Y0FDbUM7NEJBTGxDM3dDLFFBS2tDOzJCQUFoQzgzQyxVQUZNblE7O2NBTThCOztlQUF0Qyw2QkFBcUIsb0JBTmJBO2VBTVI7OzswQkFUQTNuQyxRQVFtQkosTUFBTUssT0FBTzJuQzthQU5qQixJQXJHakIrTjs7Ozs7O2FBc0xGLGtDQXpmaUNuMUMsSUF5M0JOaTRCLGdCQUF3QjZUO1FBOVhHLE9BMWV0RGtFO1VBZ2YwQixhQTNReEJnRSxhQTJRd0IsWUE3UUY1QztVQStReEIsR0EvUXdCRSxPQStReEIsa0JBc1htQk4sUUFBUS9ZLFFBQXdCNlQ7VUF4WHpCLElBRWtCLFNBN1FmbUksYUE2UWUsWUEvUWZqa0M7VUFpUjdCLEdBalI2Qm1NLE9BaVI3QixrQkFvWG1CNjBCLFFBQVEvWSxRQUF3QjZUO1VBeFh6QixJQUlrQixTQTlRMUNvSSxjQThRMEMsYUFqUlY3QztVQW1SbEMsR0FuUmtDRSxRQW1SbEMsa0JBa1htQlAsUUFBUS9ZLFFBQXdCNlQ7VUF4WHpCLElBTWtCLFNBL1ExQ3NJLFlBK1EwQyxVQUN6QixpQkFwUnlCdDFDO1VBb1JnQixRQUM1RCxrQkFnWG1Ca3lDLFFBQVEvWSxRQUF3QjZUO1VBeFh6QjtXQVF3QixTQWpSckJ1STtXQWlScUIsVUFDL0IsaUJBdFI2QnIxQztVQXNSbUI7WUFDbkUsU0F2UndDb0MsT0Fxb0JXMHFDO1lBOVduRCxrQkE4V21Ca0YsUUFBUS9ZO1VBeFhELElBN1FGc2YsT0FBZ0JuMkMsSUFBaEJnd0MsS0FBZ0Jod0M7VUF5UnRCLEdBelJNbTJDLE9BeVJOLGtCQTRXQ3ZHLFFBQVEvWTtRQTVXa0MsYUF0UmhDa2MsWUFzUmdDLFdBelJyQi95QztRQStSeEMsR0EvUndDbzJDOztVQStSeEMsU0FzV21EMUw7Ozs7O1VBcFdsQixpQkFwZ0JqQ2tFO3VCQXNnQkksa0JBa1dlZ0IsUUFBUS9ZLFFBQXdCNlQ7UUFsV0gsT0FwTjlDcUosVUFzTk07TUF2ZlosU0FtQ1E1QyxNQUtKL0IsVUFtZFFMO1FKOWhGZixJSTJrRWlCbFksUUFBVnVZO1FBQ0Y7YUFEWXZZLFlBbWRGa1ksUUFsZGdCLG1CQUR4QkssVUFBVXZZO1VBRUosMEJBNUUyQmo0QixJQTBFdkJpNEI7VUFFSjtZQVlhLElBR1h5WixVQWpCRXpaO1lBa0JaLEdBRFV5WixjQWtjQXZCLFFBamNnQix5QkFpY2hCQTtZQXJjVzthQUtmLHdCQTdGNkJud0MsSUEyRnpCMHhDO2FBRUo7O2dCQUNLLFlBcEJDelosUUFpQkZ5WixrQkFrY0F2QjtnQkE5YkQsWUFyQkdsWSxRQWlCRnlaLFVBa2NBdkI7YUEvY01wSjttQkF5c0Jkd0osWUE3c0JBQyxVQUFVdlksUUFJSThPOztZQUdaLElBNGNGNEosVUFuZFUxWTtZQW9kWixHQURFMFksY0FBUVI7OztjQUdGLHNCQWhpQjJCbndDLElBNmhCakMyd0M7Y0FHTSxTQXVDSnRzQzs7Ozs7Ozs7aUNBaENBLFlBVkZzc0Msa0JBQVFSOzs7cUJBWWlCO29DQVp6QlEsa0JBQVFSO3NCQVlpQjt1Q0FBWGpKOzt5QkE4Qlo3aUM7Ozs7aUNBckNBLFlBTEZzc0Msa0JBQVFSOzs7cUJBT2lCO29DQVB6QlEsa0JBQVFSO3NCQU9pQjt1Q0FBWGhKOzs7O3lCQW1DWjlpQztnQkFoQnVCOytCQTFCekJzc0Msa0JBQVFSO2lCQTBCaUI7a0NBQVgvSTs7eUJBZ0JaL2lDOzs7O3FCQXhCdUI7b0NBbEJ6QnNzQyxrQkFBUVI7c0JBa0JpQjswQ0FBWDlJOzs7O3FCQWtCc0I7d0JBcENwQ3NKOzt1QkFBUVI7Ozs7dUJBb0M0QixnQkFqa0JIbndDLElBNmhCakMyd0M7dUJBcUN5QjtzQ0FyQ3pCQSxrQkFBUVI7d0JBcUNpQjt5Q0FBWDNJOzs7c0JBR1c7cUNBeEN6Qm1KLFVBQVFSO3VCQXdDaUI7eUNBQVh2STs7O3FCQXpCVztvQ0FmekIrSSxrQkFBUVI7c0JBZWlCOzBDQUFYbkk7OztxQkFjVztxQ0E3QnpCMkksa0JBQVFSO3NCQTZCaUI7dUNBQVhqSTs7O2lDQVJaLGlCQXJCRnlJLGtCQUFRUjs7O2lDQWdDTixpQkFoQ0ZRLGtCQUFRUjs7O3FCQXVCaUI7cUNBdkJ6QlEsa0JBQVFSO3NCQXVCaUI7dUNBQVgvSDs7O3FCQVdXO3FDQWxDekJ1SSxrQkFBUVI7c0JBa0NpQjt1Q0FBWDdIOzs7OztjSWhqRVo7ZUp5akV1Qjs4QkEzQ3pCcUksa0JBQVFSO2dCQTJDaUI7a0NBRHZCOXJDLEdBQ1k0aUM7WUF2ZlosSUFBWUQ7bUJBc3NCZHVKLFlBN3NCQUMsVUFBVXZZLFFBT0krTztVQUxSLElBUUosVUFWUS9PO21CQUo4QztNQXBDNUQscUNBbENxQ2o0QixLQXc1QlA7YUFPNUJ5M0MsdUJBQXVCejNDLElBQUlFO01BQ1gsOEJBRE9GLEtBQ1A7O1FBQ04sd0JBREEyNEIsSUFEaUJ6NEIsT0FBSkY7Ozs7VUFNakIseUJBTnFCRTtVQU1yQix5Q0FOaUJGO21CQU1NO2FBSTdCMDNDLHdCQUF3QjEzQztNQUNSO09BRDJCaTdCO09BQU50QztPQUNyQiwwQkFEUTM0QjtPQUNSOztRQUNOLHdCQURBazhCLE1BQ2dCLGFBRld2RCxNQUFiMzRCOzs7O1NBSXhCLHlDQUp3QkEsSUFBbUJpN0I7Ozs7O09BNTNGM0MzQztPQVRBRjtPQWJBTDtPQUdBQztPQU1BRztPQXdDQU87T0FrNkNJbVU7T0ErUUFtQjtPQStHQU87T0FvQkFJO09BcUJBQztPQXg2QkF0RDtPQXVoQ0p1RTtPQSs1QkE0SDtPQVVBQztPQXpvRkF4ZDtPQWdMQWM7T0EyZ0NBMFI7T0F6MUJBbFI7T0E2eUNBc1Q7T0EveENJM1M7T0F1SUpDO09BK2ZBbVA7O2FnQ3B3Q0FvTSxTQUFTaHFCLEVBQUVyaUI7VUFBV3F0QjthaEN3OUNsQmtVO3dCZ0N2OUNXaGlDLEtBQU8sV0FEWFMsRUFDSVQsS0FBTyxrQkFEYjhpQixFQUFFcmlCLEVBQ2dDOztlQURyQnF0QjthQUV0QmlmLFNBQVNqcUIsRUFBRTFxQjtVQUFXMDFCO2FoQ3M5Q2xCa1U7d0JnQ3I5Q1doaUMsS0FBTyxXQURYNUgsRUFDSTRILEtBQU8sa0JBRGI4aUIsRUFBRTFxQixFQUNnQzs7ZUFEckIwMUI7YUFFdEJrZixVQUFVbHFCLEVBQUUvb0I7TXBDdkJqQixJb0N1QjZCK3pCLG9CaENtdURwQnFWLGFnQ251RE1yZ0IsRUFBRS9vQixHQUFZK3pCO2FBSXhCbWYsUUFBUWx6QyxHQUFHK3pCLEtBQU0sK0JwQzNCdEIsVW9DMkJhL3pCLEdBQUcrekIsSUFBNEI7YUFDdkNvZixRQUFROTBDLEVBQUUwMUIsS0FBTSwrQnBDNUJyQixVb0M0QmExMUIsRUFBRTAxQixJQUEyQjthQUNyQ3FmLFNBQVNwekMsR0FBRyt6QjtNQUFNLGdDcEM3QnZCLFVvQzZCYy96QixHQUFHK3pCLElBQTZCO2FBQ3pDc2YsU0FBU2gxQyxFQUFFMDFCLEtBQU0sZ0NwQzlCdEIsVW9DOEJjMTFCLEVBQUUwMUIsSUFBNEI7YUFDdkN1ZixPQUFPdmYsS0FBTSxlMUI4SGI1MEIsTzBCOUhPNDBCLElBQXdCO2FBQy9Cd2YsUUFBUXhmLEtBQU0sZTFCOEhkMzBCLE8wQjlIUTIwQixJQUF3QjthQUVoQ3lmLFNBQVN6cUI7TXBDbENkLElvQ2tDeUJnTDtlQUNsQmxDLElBQUc1ckI7UUFDSyxJQUFOdkUsSUFBTTtRQUNWLFdBRElBLElBREN1RTtRQUdILGtCQUpPOGlCLEVBSVAsU0FGRXJuQixLQUVtQjthaENxOENuQnVtQyxZZ0N4OENGcFcsTUFEa0JrQzthQU9wQjBmLFFBQVExZixLQUFNLHlCQUFjbDNCLEdBQUssT0FBTEEsQ0FBTSxFQUExQmszQixJQUErQjs7OztPQWR2Q21mO09BSUFJO09BQ0FDO09BU0FFO09BYkFOO09BQ0FDO09BQ0FDO09BWEFOO09BSUFFO09BV0FPO09BYkFSO09BRUFDO09BV0FPOzs7Ozs7YUMwQklFLE9BQU8xMkMsRUFBRTJCO01yQzVEbEIsSXFDNERrQitNO01BQ2Y7V0FEZUE7MkJBR1Jpb0MsWUFBSkM7VUFBcUIsY0FBckJBLEdBSFU1MkMsR0FHcUIsT0FBM0IyMkM7VUFDSyxRQUpHam9DOztRQUVQLGdCQUVjO2FBR3BCbW9DLFFBQU1oM0M7TUFDQTtpQkFEQUE7T0FDQSwwQkFEQUE7T0FHVSxXQUhWQSxFQUNKckUsVUFDQTRILE9BREE1SDtNQUVKLGdCQUhRcUUsSUFDSnJFLFFBRTRDO2FBRzlDczdDLGFBQWFDLE9BQU8za0MsSUFBSTRrQyxPQUFPcjFDO01BQ2pDLEdBRGlDQTtRQUdrQixJQUE5QzBYLEVBSDRCMVgsS0FHL0I4WixFQUgrQjlaLEtBR2tCLFlBSHBDbzFDLE9BR2J0N0I7UUFBUTs7NEJBQXFCemIsRUFBRUMsR0FBUyxjQUFYRCxFQUFXLE9BSHBCb1MsSUFHV25TLEdBQWdCLE9BQTVDb1o7aUJBSHFCMjlCO01BRWxCLGVBQ21FO2FBWXpFQyxtQkFBaUIsbUJBQThCO2FBRS9DQyxTQUFTQztNQUNYO1FBQ2Esa0JBRkZBLFVBRUU7Ozs7Ozs0QkFKWEY7O1FBUVcsa0JBTkZFLFVBTUUsV0FEVEM7Ozs7Ozs7NEJBUEZIOztNQVlTLGNBVkFFLFNBVUEsWUFMUEMsTUFLb0I7YUFHdEJDLFFBQVEzeUMsSUFBSXl5QyxTQUFTRztNQUN2QixtQkFEVTV5QyxVQUFhNHlDO01BRUksa0JBRmJIO01BRUo7OztrQkExQm1CSTtrQkFBTkM7a0JBQUxDO2lEQUFXRjs7bUJBRTNCLFVBRnFCQztxQkFJakIsTUFKaUJBLFFBSWEsdUNBRHhCNzFDO3FCQUN3QiwwQkFvQjFCK0MsVUF4QlEreUMsU0FBV0Y7bUJBTXZCLDBCQWtCSTd5QyxVQXhCUSt5QyxJQUFXRjs7b0JBMEJpQjthQUc1Q0csYUFBYVAsU0FBU0c7TUFDaEIsSUFBSmoyQyxFQUFJLGNBQ1IsUUFESUEsRUFEVzgxQyxTQUFTRyxRQUV4QixnQkFESWoyQyxFQUVhO2FBR2ZzMkMsTUFBTVIsU0FBU0c7TUFDSixzQkFETEgsU0FBU0c7TUFDSixxQ0FBOEI7UUFHekNuakI7YUFFQXlqQixxQkFBbUI1M0M7TUFDckI7UUFBUywyQkFEWUE7Ozt3Q0FFTTttQkFBSTthQUU3QjYzQyxvQkFBa0I3M0M7TUFDcEI7UUFBUywrQkFEV0E7OzsrQkFFRjtRQUxsQixXQUtzQjthQUVwQjgzQyxvQkFBb0I5M0M7TUFDdEI7UUFBUyxpQ0FEYUE7OzsrQkFFSjtRQUxsQixXQUtzQjthQUVwQiszQztNQUFrQ0MsYUFBYTdqQixRQUFROGpCLEtBQUtkLFNBQVNlLFFBQ25DWjtNQUNwQyxJQUFJYSxRQUY2Q2hrQjtNQUVqRCxTQUNJaWtCLGNBQWNwdEM7UUFLUjs7O1VBTk5tdEMsVUFGcURGO1lBVWQsaUJBVmNBLFFBRXJERTs7UUFTRixPQVJnQm50Qzs7Ozs7OztZQVlWLG1CQVBGM0osUUFDQWczQzs7O2VBU2lCM0osU0FmTDFqQyxTQWVBOFksSUFmQTlZLFNBZUw2VixJQWZLN1Y7V0FnQlYsbUJBWEYzSixRQUNBZzNDLFNBU1l2MEIsSUFBTGpELElBQVU2dEI7O2lCQURmLElBRE03dUMsRUFiSW1MLFNBY1YsbUJBVEYzSixRQUNBZzNDLFNBT1F4NEM7a0JBTU4sSUFETThNLElBbEJJM0IsU0FtQlYsbUJBZEYzSixRQUNBZzNDLFNBWVExckM7UUFHWixRQWhCSXRMLEVBUndEODFDLFlBQzFCRztRQXdCSixLQUEzQixXQXRCYXRzQyxpQkFzQmMsV0F0QmRBO1NBd0JQLHVCQW5CTDNKO1FBa0JNLHdCQWxCTkEsR0FtQndCO01BekI5Qjs7V0FGaUQ4eUIsYUFBUThqQjtVQStCdkQ7WUFDVTtrQkFoQ3FDOWpCO2FBZ0NyQyxtQkFoQzZDOGpCOztZQWlDMUIsUUFEbkIsc0JBQUpwNEMsYUFDdUIsZ0JBRHZCQTtjQUN3QztnQkFFcEM7OzZCQUhKQSxFQWhDc0RzM0M7aUJBa0M1Q21CO2lCQUFSQzs7OztnQkFHRjtrQkFDcUI7aUNBTnJCMTRDO21CQU1xQjs7NkJBQU5pa0I7bUJBQ2IsWUFESTAwQixRQXRDZ0RyQjs7O3dDQXdDcEMsaUJBUmxCdDNDOzs7b0JBRVV5NEMsZ0JBQVJDO2NBUUo7O3lCQVZFMTRDLEVBRVU2NEM7MkJBUVJDO29CQUNGLEdBVFVEOzBCQVdINTBCLElBWEc0MEIsMkJBRlY3NEMsRUFhT2lrQjtvQkFERyxRQUNnRDt5QkFIeEQ2MEI7ZUFBSixnQkFWRTk0QyxFQUVVeTRDO2VBUVo7eUJBVkV6NEMsRUFFVTY0QzsyQkFZUkc7b0JBQ0YsR0FiVUgsWUFpQkg1MEIsSUFqQkc0MEIsaUJBaUJINTBCO29CQUZILElBakRxQ3FRLHNCQUFROGpCO3NCQWlERCxTQWpEUDlqQjtzQkFpRE8sd0JBakRDOGpCO29CQWtEeEMsaUJBbEJUcDRDLEdBbUJpQjt5QkFMZmc1QztlQUpKLGtCQVZFaDVDLEVBRVV5NEM7ZUFRWjt5QkFSWUk7MkJBbUJSSztvQkFDRixPQXBCVUwsVUFsQytCdmtCLGVBd0QzQjt5QkFIWjRrQjtlQVhKLDBCQVJZVDtlQVFaO3lCQVZFejRDLEVBVUU4NEMsT0FJQUUsUUFPQUU7MkJBS0lFO29CQUFlOzZCQUNYLElBQUx2NUMsV0FBSyw0QkFBTEE7O3VCQUVIOzt3QkFBVTt3QkFDRSwyQkFEUm9rQjt1QkFDUTt5QkFFQSxJQUFMblgsYUFBSyxXQUpUdXNDLElBSUl2c0MsS0FFUDt1QkFIVSxpQkEvQlo5TSxFQTZCTWlrQjs2QkFNRyxJQUFMM2YsV0FBSzs2QkFDRSxJQUFMMmlCLGFBQUs7O3VCQUVULGlCQUFVO3VCQUNWLFdBRktxeUIsSUFDRHAxQjt1QkFDSjs7dUJBWUEsSUFEU3ExQixhQUNKOzt1QkFHTDs7d0JBQVU7d0JBQ0UsNEJBRFJwMUI7dUJBQ1E7eUJBRUEsSUFBTGhrQixhQUFLLFdBSlZxNUMsSUFJS3I1QyxHQUVQO3VCQUhVLGlCQXhEWkgsRUFzRE1ta0I7O3VCQU9KOzt3QkFBVTt3QkFDRSw0QkFEUnUxQjt1QkFDUTt5QkFFQSxJQUFMeHBDLGVBQUssU0FBTEEsSUFFUDt1QkFIVSxpQkEvRFpsUSxFQTZETTA1Qzs7dUJBT0o7O3dCQUFVO3dCQUNFLDRCQURSRTt1QkFDUTt5QkFFQSxJQUFMQzt5QkFBSyxXQUpSRixJQUlHRTt5QkFFUDt1QkFIVSxpQkF0RVo3NUMsRUFvRU00NUM7O3VCQU9KOzt3QkFBVTt3QkFDRSw0QkFEUkc7dUJBQ1E7eUJBRUEsSUFBTEMsZUFBSyxTQUFMQSxJQUVQO3VCQUhVLGlCQTdFWmg2QyxFQTJFTSs1Qzs7dUJBT0osSUFESUU7dUJBQ0o7cUNBeERJYixhQXVEQWE7O3VCQXZDTSxJQURFQyxhQUFON1AsY0FDSTt1QkFDUCxPQURDOFAsTUFERTlQO3lCQUdKLFdBSFU2UCxJQUNSQyxPQUVGO3VCQUc0Qjs7OytCQS9DaENuNkM7K0JBMENNbTZDOytCQUswQixrQkFDRSxrQ0FQMUI5UDs7dUJBNENOLElBREcrUDt1QkFDSDt1QkFHZ0I7NEJBeEh1QjlsQixjQUFROGpCOzJCQXVIN0MsU0F2SHFDOWpCOzJCQXVIckMsV0FIQzhsQixJQUdDLGlCQXZIMkNoQzsyQkF3SDdDOzs7OzJCQUVHaUM7OEJBMUhxQmxDO3dCQTRIeEI7dUJBRVEscUJBQ0csa0JBTFJrQyxJQUlEQzt1QkFFSjt1QkFGVTt3QkFHRyxhQWpJa0NsQyxVQUFSOWpCO3dCQW1JckM7OzJCQW5JNkM4akI7MkJBQVI5akI7NEJBQVE4akIscUJBQVI5akI7dUJBcUloQzs7NENBSkhnRyxVQUZBaWdCLFVBR0FsZ0I7dUJBR0csU0FBbUM7eUJBM0V0QytlO2VBaEJSLDRCQVZFcDVDLEVBVUU4NEMsT0FJQUUsUUFPQUU7Y0FrRkosYUFyR0lSOztZN0IwV0osYzZCcFFHLFdBeEk4REwsUUFnQy9EcjRDOzs7aUNBeUdVLElBQUx5ZSxXQUFXLHVCQUFYQTtrQ0FDTSxJQUFMclQsV0FBVyxvQkFBWEE7OztVQUVaOztRQS9JRixTQWdKSTthQUVGb3ZDO01BQThCbG1CLFFBQVE4akIsS0FBS2QsU0FBU2UsUUFBUVo7TUFDOUQ7aUJBRGdDbmpCLFFBQVE4akIsS0FBS2QsU0FBU2UsUUFBUVosT0FDYTthQUV6RWdELG1CQUFxQno1QixJQUFpQm8zQixLQUFLZCxTQUFTZSxRQUFRWjtNQUM5RCxHQUR1QnoyQixJQUFRLFFBQVJBLGlCQUFRQyxhQUFSeTVCLFVBaEtyQnBtQjtNQWlLRjtpQkFEdUJvbUIsYUFBaUJ0QyxNQUFLZCxTQUFTZSxRQUFRWixPQUV0RDthQUdOa0QsV0FBYTM1QixJQUFpQm8zQixLQUFLZCxTQUFTZSxRQUFRWjtNQUN0RCxHQURlejJCLElBQVEsUUFBUkEsaUJBQVFDLGFBQVJ5NUIsVUFyS2JwbUI7TUFzS0Y7a0JBRGVvbUIsV0FBaUJ0QyxRQUFLZCxVQUFTZSxRQUFRWixPQUNnQjthQUdwRTNHLE1BQU1odkMsRUFBRWpDLEVBQUV5VztNQUNaO1FBQ0UsdUNBRk14VSxFQUFFakMsRUFBRXlXOzs7O1VBSUMsSUFBUHNrQyxhQUFPLHlCQUFQQSxPQUFPOztVQUNDLElBQVBDLGFBQU8sd0JBQVBBLE9BQU87a0JBQXVCO2FBR25DQyxjQUFjaDVDLEVBQUVqQyxFQUFFeVc7TUFDcEI7UUFDRSwrQ0FGY3hVLEVBQUVqQyxFQUFFeVc7Ozs7VUFJUCxJQUFQc2tDLGFBQU8seUJBQVBBLE9BQU87O1VBQ0MsSUFBUEMsYUFBTyx3QkFBUEEsT0FBTztrQkFBdUI7YUFFbkNFLGFBQWFqNUMsRUFBRWpDLEVBQUV5VztNQUNuQjtRQUlFO1NBSEk4aEM7U0FDQVQsUUFIUzcxQztTQUlUNDRDLGFBNUxKcG1CO1NBNkxBLG1DQURJb21CLFVBRkF0QyxLQUNBVCxLQUhXOTNDLEVBQUV5Vzs7Ozs7VUFPTixJQUFQc2tDLGFBQU8seUJBQVBBLE9BQU87O1VBQ0MsSUFBUEMsYUFBTyx3QkFBUEEsT0FBTztrQkFBdUI7YUFHbkNHLFlBQVloN0M7TUFDZCxJQUFJdUQsSUFBSixzQkFEY3ZEO01BQ2QsU0FDUWk3QyxLQUFLMzVDO1FyQzNUaEIsSXFDMlRnQndOO1FBQ1g7YUFGRXZMLE9BQ1N1TCxJQUNNLE9BRmZ2TDtVQUdNLDBCQUpJdkQsRUFFRDhPO1lBRWMsUUFGZEE7VUFHTixPQUhNQSxJQUdMO01BSlI7UUFNTSxJQUNKQSxJQURJLFFBUFE5Tzs7OztVQVVWO1lBQVksSUFDVnNCLEVBRFUsUUFWRnRCOzs7a0NBWWUsT0FYekJ1RDtZQVVPO3NCQUFMakM7UUFIQztrQkFBTHdOLFlBS0s7YUFHTG9zQyxZQUFZQztVQUFnQnpELGFBQU5DLGNBQUx5RDtvQkFBS3pEO2VBRVYsSUFGQXdELElBRUEsc0JBRktDO2VBR2lCLElBSHRCRCxJQUdzQixzQkFIakJDLE9BR2lCLFlBSE4xRDthQU01QjJELG9CQUFvQnI3QztNQUN0QixJQUFJczdDO01BQUo7d0JBQ2dFMTRDO2lCQUFqQyxTQUFpQ0EsT0FENUQwNEMsU0FDd0Msc0JBQXlCLE9BQUwxNEMsQ0FBTztlQUZqRDVDLEVBRW1EO2FBeUJ2RXU3QyxNQUFRdjZCLElBQWVzMkI7TUFDekIsR0FEVXQyQixJQUFNLFFBQU5BLGFBQU1DLGFBQU51NkIsTXpCclROMTZDO015QnNUWTswQkFEU3cyQztPQUVmLGdCQW5DUjRELGNBa0NFTztPQUVNLFVBRE5sNEMsSUFGTWk0QztNQUlEO3dCQTNCU0U7aUJBQ2xCLFNBRGtCQSxPQUNsQixLQURrQkE7aUJBQ2xCLHdCQURrQkE7O3FCQU9kOzRCQVBjQTtzQkFPRCxxQkFEV2Q7c0JBRVgsZ0JBQWEsTUFSaEJ2MkMsUUFPTnMzQztxQkFFUTs7OzJDQUFPLE9BRGZDLFNBQ3dCLG9CQUhKaEI7bUJBS1g7b0JBREh0a0MsSUFWSW9sQztvQkFVVi9ELEtBVlUrRDtvQkFXRCxtQkFESHBsQztvQkFDRzswQkFYSGpTLFFBWU55M0MsZUFEQUQ7bUJBQVMsT0FFVDN6QjtxQkFJVztvQ0FKWEE7c0JBS1csYUFBVyxvQkFSaEI1UixPQUNOdWxDO3NCQVFXOzZCQVRMdmxDLElBQ051bEMsT0FPVyxzQkFSTHZsQyxPQUNOdWxDO3FCQVNVLGVBVlZsRSxLQVVVLE9BRlJULE9BRWlCLE9BSGpCNkUsT0FFQTVFO21CQUpRLGVBTFZRLEtBS1Usb0JBTEpyaEM7aUJBTFYsT0FMY29sQztlQXdCZEQsVUFHZ0M7YUFTbENPLFNBQVNDLEtBQUsxcEMsSUFBSTJwQztNQUNYLG1CQURXQSxNQUVWO2VBRU5FO1FBQ1MsSUFaSHA4QyxFQVlHLFNBSFQ2RTtRQUdTLEdBTEZvM0M7VUFOWCw4QkFEVWo4QztVQUVJLE9BRFZ1RCxjQUNVLGdCQUZKdkQsRUFDTnVEO3FCQUVGLE1BSFF2RCxJQUNOdUQ7VTdCK0pFLHVCNkJoS0l2RDtVQUNWLElBWU1xOEM7O2tCQWJJcjhDO1FBY1IsY0FESXE4QyxLQUhGRjtRQUlGLGVBTEV0M0MsSUFNYztNQU5SOztVQVVJLElBQUpqQyxFQUFJLG1CQVhWc0I7VUFXVSxHQUFKdEIsTUFaTTJQLElBYU0sY0FBYyxTQVhoQzFOLElBVU1qQzs7Ozs7VUFLUCxPQWZDaUMsT0FlMEI7VUFDOUIsc0JBakJJWDtVQWtCVSxtQkFoQlZpNEM7bUJBZ0IyQjs7SUFFbEIsU0FBWEcsZXJDNVlMLE9xQ3VYS047SUFxQlc7SUFFQyxTQUFaTyxnQnJDOVlMLE9xQ3VYS1A7SUF1QlksU0FFWlEsVUFBVWpxQyxJQUFJMnBDLEtBQUtPO01BQ1osSUFBTHQ1QyxHQUFLLGFBRE8rNEM7TUFFaEIsZ0JBQWdCbDhDLEdBQUssMEJBRGpCbUQsU0FDWW5ELEVBRkp1UyxJQUVnQyxFQUZ2QmtxQztNQUVyQixpQkFESXQ1QyxHQUVRO0lBTEU7SUFPQSxTQUFadTVDLHFCckNyWkwsT3FDZ1pLRjtJQUtZO0lBRUMsU0FBYkcsc0JyQ3ZaTCxPcUNnWktIO0lBT2E7OztPQXhIYjFMO09BUUFnSztPQVpBSDtPQUxBRjtPQUhBRDtPQTJCQU87OztPQTVMQWpEO09BTkFEO09BOFBBMEQ7T0FwUEFqbkI7T0FzUkFnb0I7T0FFQUM7T0FPQUc7T0FFQUM7SUFBYTtRaENuWWJDO0lBQVcsU0FJWEMsTUFBTTE4QyxFQUFFeEU7TUFDRixJQUFKa0UsRUFESU0sTUFBRXhFO01BRUgsZ0JBREhrRTtlQUdJLGFBSEpBO2lCQUlGLHlCQUpFQTtpQkFLSSxhQUxKQSxXQU1GLFVBTkVBO2VBRUYseUJBRkVBLEVBUUM7SUFiUSxTQWVQaTlDLGFBQWEzOEMsRUFBRXhFO01BQ3JCLEdBRG1Cd0UsZ0JBQUV4RSxFQUNHO01BQ1Usc0JBRmZ3RSxFQUFFeEUsV0FFQyxXQUZId0UsRUFBRXhFO01BRUMsMENBQWtDO0lBakIzQyxTQTBCWG9oRCxhQUFhNThDO01BQ2YsU0FBUTY4QztRTC9DWDtRSytDa0I7O2dCQUNMNzZDLGNBQU5DOztjQUNTLDhCQURUQSxHQUZXakM7O2dDQUtJLElBQUxILFNBQUssVUFBTEE7d0JBSEptQzs7VUFJQSxTQUFJO01BTGQsWUEzQkV5NkMsWUFpQ1k7SUFqQ0QsU0FtQ1hLLGtCQVVNOThDO01BVmMsR0FVZEEsb0JBVFc7U0FTWEEscUJBUlk7U0FRWkE7eUJBUG9CKzhDLGtCQUFOQyxnQkFBTmpCOztpQitCakJkdEYsUS9CbkJBajhDO2lCQW9DY3VoRDtpQkFBTWlCO2lCQUFNRDs7O1NBT3BCLzhDOzs7U0FMcUJpOUM7U0FBTkM7U0FBTkM7O2lCK0JuQmYxRyxRL0JuQkFqOEM7aUJBc0NlMmlEO2lCQUFNRDtpQkFBTUQ7OztTQUtyQmo5Qzs7O1NBSGlDbzlDO1NBQU5DO1NBQU5DOztpQitCckIzQjdHLFEvQm5CQWo4QztpQkF3QzJCOGlEO2lCQUFNRDtpQkFBTUQ7OztNQUlyQyxzQkFESXA5QztRQUtxQyxnQkFMckNBLFFBekJSLE1BeUJRQTtRQXpCUjtTQUlvQzs0QkFxQjVCQTtVQXJCZ0IsV0FxQmhCQTtlQXJCZ0I7Ozs7O21CQURGLGVBc0JkQSxVQXRCYztlSytGcEJhLE9MckVRMDhDO01BRk8sT0FGVHY5QyxJQU1zQjtJQW5EakIsU0FxRFh3OUMsWUFBVXZ5QztNQUNOLHVCQURNQTtNQUNOLFVBQ00sSUFBTHBMLFdBQUssT0FBTEE7TUFDRyx5QkFIRW9MLEVBR2lCO0lBeERoQixTQTBEWHd5QyxNQUFNQyxJQUFJNTVCO01BQ1o7UUFDRSxvQkFGTTQ1QixJQUFJNTVCLEtBSVY7WUFERzlqQjs7UUFDZ0MscUJBRGhDQTtRQUNIO1FBQ0EsY0syRUFvQztRTDNFQSxNQUZHcEMsRUFHSTtJQWhFSSxTQWtFWDI5QyxRQUFNRCxJQUFJNTVCO01BQ1o7UUFDRSxvQkFGTTQ1QixJQUFJNTVCO1lBR1A5akI7O1FBQ0gsY0ttRUFtQztRTGxFbUMscUJBRmhDbkM7UUFFSDt1QkFDTTtJQXhFSyxTQTZHWDQ5QyxzQkFBc0JDO01MakkzQixVS2tJWSxtQ0FEZUEsSUFFRjtJQS9HVCxTQWlIWEMsc0JBQXNCdHBDLElBQUlrQjtNQUM1QixTQUFJcW9DLEtBQUtDO1FBQ1AsT0FET0E7dUJBRGV4cEM7eUVBS2lEO01BSnpFLFNBRDRCa0I7UUFjeEI7Y0Fkd0JBO1NBY3hCLEtBZHdCQTtTQWN4QixLQWR3QkE7U0FjeEIsS0Fkd0JBOzs7U0FlaEIsVUFmZ0JBO1FBY25COztNQUxMLEdBVHdCQSxRQVVvQjtNQUVOO01BQS9CLHlDQUt1QztJQWxJckMsU0FnSlh1b0Msb0JBQW9CQyxRQUFRQztNQUNJLElBYkVDLFVBYUYsc0JBREpEO01BWDlCLEdBRG9DQztRQU1oQyxNQU5nQ0EsYUFNaEMsS0FER3Q3QyxxQkFDSDs7O1VBQ0U7WUFBTSxnQ0FEUnRILEVBQ2dDLGlCQUY3QnNILEVBQ0h0SDtZQUNRLFVBRVUsSUFBUDRDLGFBQU8sbUJBR0E4L0MsY0FIUDkvQztZQUZILFNBRFI1Qzs7O1FBSEE7cUJBU2tCMGlELGFBQ2lEO0lBakoxRCxTQW9KWEcsZ0JBQWdCSDtNQUNVLDJCQURWQSxRQUNVLGtDQUFzQjtJQXJKckMsU0FvS1hJLHdCQUF3Qkg7TUFDTixJQWRFQyxVQWNGLHNCQURNRDtNQVoxQixHQURzQkM7UUFLVixJQURMdDdDLEVBSmVzN0MsYUFLVixzQkFETHQ3QyxxQkFDSzs7Y0FDUnRIO1VBQ0U7WUFBTSxnQ0FEUkEsRUFDZ0MsaUJBSDdCc0gsRUFFSHRIO1lBQ1EsVUFFVSxJQUFQNEMsYUFBTyxtQkFKZGlELFFBSU9qRDtZQUZILFNBRFI1Qzs7O1FBS0EsZ0JBTkk2RjtNQUZMLHFDQVdzRDtJQXJLNUMsU0F1S1hrOUMsd0JBRWlCaHZDO01BRlMsYUFFVEEsMEJBQWU7SUF6S3JCLFNBMktYaXZDLHlCQUNlanZDLE9BRFksYUFDWkEsbUJBQ1k7SUE3S2hCLFNBc0xYa3ZDLHdCQUVlbHZDO01BRlcsYUFFWEEsc0RBTWQ7SUE5TFUsU0FnTVhtdkMsdUJBR2VudkM7TUx2TnBCLFNLdU5vQkE7T0FBSyxVQUFMQTtNQURvQixRQUNEO0lBbk12QixTQXFNWG92QyxnQkFBZ0JSO01BT1osZ0NBUFlBO01BT1o7UUFHRiwyQkFES0M7UUFJbUI7Ozs7WUFFSDtvQ0FOaEJBO2FBQ2E7O1lBS0c7eUJBTmhCQTtNQURHLFFBVUM7SUF2TkEsU0E4T1hRO01BQTJDLGlFQUFzQjtJQTlPdEQsU0FtUFhDLGlCQUFpQkMsSUFDbkIsaUJBRG1CQSxHQW5QakJyQyxhQW9QRixRQUEyQjtJQXBQZCxTQXdQWHNDLFNBQ0UvK0MsR0FDSiwwQkFESUEsU0FDc0M7SUExUDdCLFNBNFBYZy9DLFlBQVloL0MsR0FDSCxJQUFQMFYsS0FBTyxTQURHMVYsR0FFTCxPQURMMFYsT0FDOEI7SUE5UHJCLFNBZ1FYdXBDLGNBQWNqL0MsR0FDTCxJQUFQMFYsS0FBTyxTQURLMVYsR0FFUCxPQURMMFYsT0FDaUM7SUFsUXhCLFNBb1FYd3BDLCtCQUFtQ2g3QixJQUFJaTZCO01BQ0gscUJBRERqNkI7TUFDckM7TUFDQSxvQks1SEU5aEIsT0wwSHVDKzdDO01BRXpDLHFCSzVIRS83QyxPTDZIVTtJQXZRQyxJQXlRWCs4Qyw4QkFMQUQ7SUFwUVcsU0EyUVhFLCtCQUErQk47TUFBSyxnQ0FBTEEsR0FBSyxRQUFnQztJQWlEdEUsb0JMaFZIO0lLZ1ZHLG9CTGhWSDtJS2dWRztNTGhWSDtJS2dWRyxvQkxoVkg7SUtnVkc7OztPQXJKRVA7T0FJQUM7T0FXQUM7T0FVQUM7T0EvRUFaO0lBMk1GLG9CTGhWSDtJS2dWRyxvQkxoVkg7SUtnVkc7OztPQXZRRU47T0FsQkFWO09BdUJBVztPQVFBRTtPQWtGQVU7T0EwRkFPO3NCTGxRTDs7T0t1UUtDO09Bek5BakM7O09Bc0hBcUI7T0FvQkFLO09BZ0dBWTtPQU9BRTtPQXRFQVQ7Ozs7OztPQXVEQUs7T0FJQUM7SUE0REY7YWlDL1RFSSxRQUFNNThDLFNBQU0sT0FBTkEsQ0FBTzthQUNiNjhDLEtBQUs1L0MsRUFBRU0sRUFBRUMsR0FBSSxrQkFBUlAsRUFBSU8sRUFBRkQsRUFBVzthQUNsQnUvQyxPQUFPNXZDLEVBQUVuTSxHQUFRLHNCQUFWbU0sRUFBRW5NLEVBQWE7Ozs7SUFJakI7O1FBQTZCO1VBQ2QsSUFBUDBnQjtVQUFZLHdDQUEwQixZQUF0Q0E7UUFDVixRQUFJO0lBRkYsU0FJTHM3QixRQUFVQyxVQUF3QkM7TUFDcEMsU0FBSUM7UUFDRjtVQUFJLG9CQUZNRixhQUdSO2NBRGtCeDBDOztVQUNULCtEQURTQTtVQUNULCtCQUFMNHlDO1VBQUssVUFDMEM7TUFIdkQ7UUFLTSxJQUNKaHVDLE9BREksV0FOOEI2dkM7WUFReEJFOztRQUNNLElBQVZDLFFBQVU7UUFDZDttQ0FGUUQsU0FDSkM7UUFDSixNQUZRRDtNQURBO2FBQVYvdkMsTUFJZ0Q7SUFmM0Msa0JBTkx3dkMsUUFDQUMsS0FDQUMsT0FRQUM7SUFKSzthQ2dETE0sV0FBV3I5QztNQUNKLG9DQUFMOGhCO01BQ0osbUJBRmE5aEI7TUFDSixTQUFMOGhCO01BRUosbUJBSGE5aEI7TUFDSixTQUFMOGhCO01BR0osbUJBSmE5aEI7TUFLYixRQUxhQTtNQUNKO09BSVQsS0FKSThoQjtPQUttQjtZQUxuQkE7TUFNSixtQkFQYTloQixRQU1UekI7TUFMSyxTQUFMdWpCO01BT0osbUJBUmE5aEIsUUFNVHpCO01BTEssU0FBTHVqQjtNQVFKLG1CQVRhOWhCLFFBTVR6QjtNQUlKLFFBVmF5QjtNQUNKO09BU1QsS0FUSThoQjtPQVVtQjtZQVZuQkE7TUFXSixtQkFaYTloQixRQVdUeEI7TUFWSyxTQUFMc2pCO01BWUosbUJBYmE5aEIsUUFXVHhCO01BVkssU0FBTHNqQjtNQWFKLG1CQWRhOWhCLFFBV1R4QjtNQVZLLFNBQUxzakI7TUFjSixtQkFmYTloQixRQVdUeEI7TUFWSyxTQUFMc2pCO01BZUosbUJBaEJhOWhCLFFBV1R4QjtNQVZLLFNBQUxzakI7TUFnQkosbUJBakJhOWhCLFFBV1R4QjtNQU9KLFFBbEJhd0I7TUFDSixTQUFMOGhCO01Ba0JKLG1CQW5CYTloQjtNQUNKLFNBQUw4aEI7TUFtQkosbUJBcEJhOWhCO01BQ0osU0FBTDhoQjtNQW1CSiwwQkFwQmE5aEIsYUFxQitCO2FBRzFDczlDO01BQ2tCOzs7OztNQUNILFFBRFpHLEtBQVNGLEtBQUxDLFFBQzRDO2FBbUJuREUsYUFBYXpnRCxHQUVmLFlBQ1c7YUFHVDBnRCxhQUFhdDlDLEdBQUksaUJBQVU7eUJBdUJDLFFBQUU7eUJBREYsUUFBRTt5QkFEUixRQUFJO3lCQURBLFFBQUk7UUFGMUJ1OUMsZ0NBQ3NCLFFBQUk7YUFXMUJqOUIsTUFDRGs5QixjQUNDei9CLElBQ0YwL0I7TUFDQSxHQUZFMS9CO09BQWlCLFFBQWpCQSxzQkFBaUJDOztXQUFqQjAvQixlM0JyR0Y3L0M7TTJCdUdBLGtDQUhDMi9DLGNBQ0NFLGVBQ0ZELFFBQzRDO2dCQWhCMUNGLGFBWUFqOUI7d0J2Q3hKVDs7Ozs7O091Q3VFSzA4QjtPQXdCQUM7MkJ2Qy9GTDs7O091Q29IS0k7T0FNQUM7OzthQ2hHQUssT0FBT3JpRDtNQUNULHVCQURTQSxNQUNULHNCQURTQSxLQUM4QjthQUVyQ3NpRCxNQUFNci9DLEdBQVcsbUNBQVhBLEdBQXFDO2FBRTNDcy9DLFVBQVV2aUQsSUFBSStFLElBQUlDO014Qy9CdkI7OztRd0MrQm1CRDs7OztRQUFJQzs7O2dDQUFSaEYsT0FBUWdGLFdBQUpEO09BR1gsdUJBSE8vRSxJQUFJK0UsSUFBSUM7TUFFZix3Q0FDeUI7YUFFNUJ3OUMsU0FBU3YvQyxFQUFFOEIsSUFBSUM7TUFBZ0Isc0NBQXRCL0IsR0FBRThCLElBQUlDLElBQWtEO2FBRWpFMjRDLEtBQUs4RTtNQUNFLElBQUw5OEMsR0FBSyxZQURGODhDO01BQ0U7UUFDSCxJQUNGbG9DLEVBREUsc0JBREY1VTtZQUdVa0gsOEJBQUssc0JBSGZsSCxJQUdlLE1BQUxrSDtNQURMLHNCQUZMbEg7TUFFSyxPQUFMNFUsQ0FDbUM7YUFFckNtb0MsU0FBT3Y5QyxLQUFLdzlDLFFBQ2QscUJBRFN4OUMsS0FBS3c5QyxPQUNXO2FBRXZCQyxRQUFNejlDLE1BQU8sMkJBQVBBLFFBQWtDO2FBRXhDMDlDLFNBQVM5L0MsR0FDWCxlQURXQSwyQkFDaUU7YUFFMUUrL0MsT0FBT3ZvQztNQUNULGdDQURTQSxHQUNxQjtNQUNqQixpQ0FDYm5kO01BQ0U7UUFBa0IsSUFBZHdFLEVBQWMsZ0JBSlgyWSxFQUdUbmQ7UUFFZ0Msc0JBSDVCcVUsT0FDSnJVLFVBRWdDLFNBRDFCd0U7UUFFNEIsc0JBSjlCNlAsUUFDSnJVLG1CQUdrQyxTQUY1QndFO1FBQWMsU0FEcEJ4RTs7UUFLQSw0QkFOSXFVLFFBTXlCO2FBRTNCc3hDLFNBQVN0aEQ7TUFDWCxnQ0FEV0EsR0FDbUI7TUFBNkIsU0FDdkR1aEQsTUFBTTMrQztRQUNSLFNBRFFBOzs0QkFJTSxRQUpOQTs7MEJBR00sUUFITkE7OzREQUVNLE9BRk5BO1FBS0QsZ0RBQTBDO01BR25ELGlDQUNBakg7TUFDRTtvQkFERkEsTUFGaUMsV0FBTSxnQkFUNUJxRSxFQVNGK0I7UUFHUDtVQUZFaU8sT0FDSnJVLEVBQ3FCLEtBSFIsTUFBTSxnQkFUUnFFLEVBU0YrQjtRQUdQLFNBREZwRzs7UUFHQSw0QkFKSXFVLFFBSXlCOzs7Ozs7T0FsRDNCNHdDO09BR0FDO09BRUFDO09BS0FDO09BRUE3RTtPQU1BK0U7T0FHQUU7T0FLQUU7T0FVQUM7O2FDNUJFRSxpQkFBc0IsaUNBQTBCO2FBQ2hEQyxPQUFPQyxJQUFJQztNQUNiLE9BRGFBLFNBQUpELGFBQ1QsU0FEYUMsT0FDYixRQUNrQjthQUdoQkMsVUFBVTVoRCxFQUFFNmhEO01BQ2QsaUJBRGNBLDJCQU9kLEVBRElDLGtCQUVKLy9DO01BQ0U7eUJBVFUvQixLQVFaK0I7UUFDRSxTQURGQTs7UUFDRSxJQUVGLGlCQUNrQixpQkFMZEQsT0FJSjtRQUNrQjtjQUFsQm5HO1VBQ0U7O2VBREZBO2FBQ0UsV0FERkEsRUFMSW1HO2FBUW9CLG1CQVRwQmdnRCxPQVFFNTFCO1lBSEZwbkIsVUFWK0IsY0FVL0JBLFFBVnVDLDRCQUExQjNFO1lBWWY7a0JBRkUyRTthQVBXO2FBRDBDO2FBQTFCO2FBQW5CO2FBYUcsdUJBaEJIOUUsS0FhTjJTO1lBR0osaUJBaEJVM1MsS0FhTjJTO1lBQUosU0FERmhYOzs7UUFNQTtpQkFBVTthQUdSb21ELE9BQUtGO01BQ00sSUFBVDd4QyxPQUFTLGFBQ2IsVUFESUEsT0FERzZ4QyxNQUVQLE9BREk3eEMsTUFFRTthQUdKZ3lDLHNCQUF5QixzQ0FBZ0I7YUFFekNDLE9BQUtqaUQsR0FDTSxJQUFUZ1EsT0FBUyxhQUNiLE9BRElBLE9BREdoUSxHQUVQLE9BRElnUSxNQUVFO2FBSUpreUMsS0FBS2xpRDtNQUNQLFFBRE9BO01BQ1A7WUFET0E7T0FFTSx3QkFGTkE7T0FFTSxNQUZOQTtPQUdNO3lCQUhOQTs7U0FFSG1pRDs7O09BQ1MsU0FBVEM7T0FBUyxLQUhOcGlEO01BTVAsaUJBTk9BLHVCQUtIcWlEO01BQ0osT0FESUEsUUFFSTthQVFOQyxNQUFJdGlELEVBQUV1aUQ7TXpDM0ZiLG1CeUMyRmFBO09BSlI7U0FBUSxXQUlGdmlELEdBSkUsV0FBSnNFLEVBSUlpK0M7U0FKQSxrQkFJQUEsdUJBSkpqK0MsSUFDQVg7U0FDK0MsT0FEL0NBO01BS0Msa0NBQ2M7YUFZakI2K0MsTUFBTXhpRCxFQUFFdWlEO01BQ1Asa0JBRE9BLFNBRUw7TUFWTDtRQUFzQixZQVFkdmlELEdBUGdELElBQWYsS0FPakNBLGNBTkEsRUFGSnlpRCxLQUNBQyxHQUVJLFdBREpwK0MsRUFNTWkrQztRQUpNLG9CQUZaaitDLElBQ0FYLG9CQUtNNCtDOztRQUZMLE9BSEQ1K0MsRUFRaUI7YUFhbkJnL0MsTUFBTTNpRCxFQUFFdWlEO01BQ1Asa0JBRE9BLFlBRUw7TUFYTDtRQUE4QjtnQ0FBUixLQVNkdmlEO1NBUnlDLHlCQUFELG9CQUFSLEtBUWhDQTtTQVBnRCx5QkFBOUIsb0JBQWUsS0FPakNBO1NBTkEsZ0JBSEp5aUQsR0FHbUIsY0FGbkJDLEdBQ0FFO1NBRUkseUJBREp0K0MsRUFNTWkrQztRQUpNOztZQUFiLGVBRkNqK0MsRUFDQVg7WUFDb0QsZUFBM0IsZXZDcEU3QnJKLFV1Q3dFVWlvRDs7UUFGTCxPQUhENStDLEVBUWlCO0lBS2hCLFNBRkhrL0MsVUFFTzdpRCxFQUFFdWlELE9BQWdFLE9BQXBDLE1BQTlCdmlELEVBQUV1aUQsTUFBZ0U7SUFDdEUsU0FXSE8sUUFBTTlpRCxFQUFFdWlEO01BTFksWUFLZHZpRCxHQUpjLFFBSWRBO01BQW9CLFFBTHhCNG5CLG1CQUNBRixvQkFJTTY2QixLQUEyQjtJQVhoQyxTQWFIUSxLQUFLL2lELEdBQUssbUJBQUxBLFdBQXVCO0lBYnpCLElBbUJMOEosYUFuQks7YUFtQ0xrNUMsY0FBVSxZQWhCVmw1QyxVQWdCNEI7SUFuQ3ZCLFNBb0NMbTVDLE1BQUlWLE9BQVEsYUFqQlp6NEMsVUFpQkl5NEMsTUFBK0I7SUFwQzlCLFNBcUNMVyxRQUFNWCxPQUFRLGFBbEJkejRDLFVBa0JNeTRDLE1BQWlDO0lBckNsQyxTQXNDTFksWUFBVVosT0FBUSxpQkFuQmxCejRDLFVBbUJVeTRDLE1BQXFDO0lBdEMxQyxTQXVDTGEsUUFBTWIsT0FBUSxhQXBCZHo0QyxVQW9CTXk0QyxNQUFpQztJQXZDbEMsU0F3Q0xjLFFBQU1DLE9BQVEsZUFyQmR4NUMsVUFxQk13NUMsTUFBaUM7SUF4Q2xDLFNBeUNMQyxjQUFVLFlBdEJWejVDLFVBc0I0QjtJQXpDdkIsU0EyQ0wwNUMsWUFBVTNCLE1BQU8saUJBeEJqQi8zQyxVQXdCVSszQyxLQUFtQztJQTNDeEMsU0E0Q0w0QixPQUFLNUIsTUFBTyxpQkF6QlovM0MsYUF5QksrM0MsTUFBeUM7SUE1Q3pDLFNBNkNMNkIsaUJBQXlCLDJDQUFlO0lBN0NuQyxTQWlETEMsaUJBQWUsY0E5QmY3NUMsVUE4QmlDO0lBakQ1QixTQWtETDg1QyxVQUFVNWpELEdBQUksY0EvQmQ4SixVQStCVTlKLEVBQTBCO0lBbEQvQjs7O09BdEVIK2hEO09BTUFDO09BRUFDO09BT0FDO09BZUFJO09BZUFFO09Bc0JBSztPQU5BRjtPQW9CQUc7T0FFQUM7S0FiRzs7T0E0Q0xVO09BREFEO09BRUFFO09BVkFWO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FFOztPQVFBSTtPQUNBQztJQWxESzthQzNGTEMsa0JBQWtCam9DO01BQ3BCLFNBRG9CQSxxQkFDcEIsY0FEb0JBLHlCQUVDO2FBRW5Ca29DLHVCQUF1QmxvQyxHQUN6QixTQUR5QkEsU0FDekIsUUFBa0M7O01BTTVCLDRDQURGbW9DOzs7O01BRUY7UUFBSTs7Ozs7VUFGRkE7SUFHSjttQ0FISUE7S0FHSixjQUpFQztJQUlGLFNBSUVFLGlCQUFlLDBCQUFrQjtJQUpuQyxTQUtFQyxxQkFBbUIsT0FIbkJGLGFBRzhCO0lBTGhDLElBT0VHLHlCMUM1REw7STBDcURHLFNBbVNNQyxTQS9RS3JqQyxJQUFzQnNqQztNQUNqQyxHQURXdGpDLElBQVMsUUFBVEEsY0FBU0MsYUFBVHNqQyxPQWxCVE47VUFha0I5akQ7TUFDcEI7UUFDSyxNQUc0Qm1rRCxnQkFMYm5rRDtVQUdmLFFBSGVBO1dBS1Rva0Q7U0FFZTs0QkFmeEJIO1VBZXdCLGtCQWZ4QkEscUJWakNBLzBCLGlCVWlDQSswQjtVQWVFdkMsS0FBc0I7O2FBQXRCQTtRQUM4QywyQkFSOUIxaEQsS0FPaEIwaEQsS0FQZ0IxaEQsR0FRa0Q7SUF2QnRFLFNBeUJFcWtELFFBQU01b0M7TUFDUixhQURRQTtNQUNSLGFBRFFBLFNBQ1csT0FEWEEsK0JBSUw7SUE3QkgsU0ErQkU2b0MsUUFBTTdvQztNQUNSLElBQUlyWSxJQURJcVk7TUFHRyxRQUhIQSxnQkFDSnJZLFFBRU8sSUFISHFZO1FBS0gsU0FFc0Msc0JBQXBCLElBUGZBLFNBT21DO01BSHpDLGVBSk1BLEVBUUw7SUF2Q0gsU0F5Q0U4b0M7TUFBa0I7O1NBRVo5TTtTQUFLcnNCO1NBQU1sakI7U0FXWDNLLFVBWEFrNkMsSUFBS3JzQixLQUFNbGpCO2NBV1gzSztpQkFYVzJLOzs7O2FBR0xzOEM7YUFBSzc0QjthQUFNODRCO2FBQ1h0Z0QsS0FEQXFnRCxNQUFLNzRCLE9BQU04NEI7cUJBSUMsVUFIWnRnRCxxQkFEV3NnRDtZQUdKO2lCQUtibG5EO01BWkcsUUFjTjtJQXhETCxTQTBERW1uRCxPQUFLNXRDO01BQUksU0FBSkEsUUFBSSxLQUFKQSxRQUFvQixXQWpCekJ5dEMsZ0JBaUJLenRDO01BQW9CLFVBQXBCQSx1QkFBc0Q7SUExRDdELFNBNERFNnRDLFNBQU9scEMsR0FBSSxPQUFKQSxJQUFVO0lBNURuQixTQThERW1wQyxTQUFPQyxTQUFTcHBDO01BQ2xCO2FBRGtCQTtPQUNsQixNQUFJcXBDO09BQUosTUFDSUM7T0FESixLQUVJQztNQUZKO1FBSWM7OEJBRlZBO1NBR2UsMEJBSGZBO1NBSWdCLDhCQVBGdnBDO1FBT0UsT0FGZHdwQztRQUFRLElBRU0sS0FMaEJGLGNBS2dCOztjQWlCbEJuakQ7O1VBQ0U7WUFBYyw0QkF4QmRrakQsTUF1QkZsakQ7WUFmd0I7O2dCQU9QO2lCQUxQNjFDO2lCQUFLcnNCO2lCQUFNbGpCO2lCQUNYazlDLE9BTE5ELGdCQUlNMU4sSUFBS3JzQjtpQkFLRSxnQkFoQlZ5NUIsU0FBU3BwQyxFQVdOZzhCO2lCQU1RLHVCQVhkeU4sV0FVTUc7Z0JBQ1EsR0FFTHI1QztpQkFBUSxXQVBYbzVDOztpQkFNTyxpQkFiYkgsTUFXTUksa0JBSkFEO2dCQVNKLGlCQWZGRixXQVVNRyxrQkFKQUQ7Z0JBSU8sU0FMSWw5Qzs7dUJBYXJCdEc7Ozs7UUFHQSxHQXBCSXVqRDtVQXFCRixTQXpCQUgsY0F5QkE7OztZQUNFO2NBQU0sSUFFQ00sUUFGRCxpQkF2Qk5KLFdBc0JGMXBEO2NBQ1EsR0FFQzhwRCxRQUFRO2NBRlQsU0FEUjlwRDs7Ozs7a0JBckJFMnBEO1FBRlE7OztNQVBELFdBbUNWO0lBL0ZILFNBaUdFSSxRQUFLN2xELEVBQUUrYjtNQUNULFNBQVErcEM7UTFDdkpYO1EwQ3VKdUI7O2dCQUdYL04sZUFBS3JzQixnQkFBTWxqQjtZQUNkLFdBTEN4SSxFQUlFKzNDLElBQUtyc0I7d0JBQU1sakI7O1VBRGQsU0FFMEI7TUFDakIsSUFBWHU5QyxTQUFXLGtCQU5OaHFDO01BTU0sT0FBWGdxQyxTQUNpQix1QkFQWmhxQztNQU9vQztRQUczQyxNQVZPQSxLQVVQLEtBREk5QyxxQkFDSjs7O1VBQ0U7c0JBQVUsaUJBRlJBLEVBQ0puZDtZQUNFLFNBREZBOzs7WUFHQSxTQVBFaXFELFNBT0YsVUFBcUIsdUJBYmRocUM7UUFjSztZQUFUeUk7O1FBQVMsR0FSVnVoQyxTQWhDc0IsTUF3Q3JCdmhDO1FBQ0gsdUJBZk96STtRQWVQLE1BREd5SSxJQUVNO0lBakhYLFNBbUhNd2hDLDBCQUEwQmhtRCxFQUFFK2IsRUFBRWpnQjs7OztVQU9wQjtXQUROaThDO1dBQUtyc0I7V0FBTWxqQjtXQUNMLGlCQVBnQnhJLEVBTXRCKzNDLElBQUtyc0I7VUFDQztnQkFJTE87Ozs7YUFFUSxpQkFiZWxRLEtBQUVqZ0I7WUFhQyxZQUYxQm13QjtxQ0FMVXpqQjs7VUFHYixPQVQwQnVUO1VBT2xCLFdBREt2VDs7UUFKakI7O2tCQUNXLGlCQUhtQnVULEtBQUVqZ0I7SUFuSHBDLFNBdUlFbXFELG1CQUFtQmptRCxFQUFFK2I7TUFDdkIsTUFEdUJBLEtBRVIsMkJBRlFBO01BRVIsT0FBWGdxQyxTQUNpQix1QkFIRWhxQztNQUdzQjtpQkFGekM5Qzs7Y0FJRm5kO1VBQ0U7c0NBTmlCa0UsRUFBRStiLEVBS3JCamdCLElBQ3dDLGlCQU5uQmlnQixLQUtyQmpnQjtZQUNFLFNBREZBOzs7O1FBR1k7WUFBVDBvQjs7UUFBUyxHQU5WdWhDLFNBdkNnQixNQTZDZnZoQztRQUNILHVCQVRxQnpJO1FBU3JCLE1BREd5SSxJQUVNO0lBakpYLFNBbUpFMGhDLE9BQUtsbUQsRUFBRStiLEVBQUUzRTtNQUNYLFNBQVEwdUMsVUFBVW5rRCxFQUFFc0Q7WUFBRmtoRCxNQUFFaGhEO1FBQ2xCO2FBRGdCZ2hEO1lBS0c7YUFEWnBPLElBSlNvTzthQUlKejZCLEtBSkl5NkI7YUFJRTM5QyxLQUpGMjlDO2FBS0csa0JBTmRubUQsRUFLRSszQyxJQUFLcnNCLEtBSk12bUI7YUFBRmdoRCxJQUlFMzlDO2FBSkFyRDs7VUFHZCxPQUhjQSxPQUtrQjtNQUN2QixJQUFYNGdELFNBQVcsa0JBUE5ocUM7TUFPTSxPQUFYZ3FDLFNBQ2lCLHVCQVJaaHFDO01BUW9DO1lBRXZDOUMsRUFWRzhDLEtBV0g5VyxRQVhLbVMsV0FVTDZCOztjQUVKbmQ7VUFDRTtxQkFGRW1KO1lBRU0sb0JBQVUsaUJBSGhCZ1UsRUFFSm5kO1lBQ0UsU0FERkE7OztRQUdBLE9BUkVpcUQsU0FRbUIsdUJBZmRocUM7UUFlc0MsU0FKekM5VztRQU1RO1lBQVR1Zjs7UUFBUyxHQVZWdWhDLGVBVUN2aEM7UUFDSCx1QkFsQk96STtRQWtCUCxNQURHeUksSUFFTTtJQXRLWCxTQStLTTRoQzs7OztVQUVVOzs7O21CQUFUM3VDOztRQURJO0lBaExYLFNBbUxFNHVDLE1BQU10cUM7TUFDUjtZQURRQTtPQUNSO09BQ0U7NkJBQXFCNkMsRUFBRWpkLEdBQVcsV0FBYmlkLEVBQWEsZ0JBQVhqZCxHQUE4QjtPQUMzQyxxQkFGUjJrRDtPQUVRLEtBSEp2cUM7TUFJUjtpQkFDT3BhO1VBQ0s7NkJBRExBO1dBRVUsc0JBSmI0a0QsTUFHSXRrRDtVQUNKLGlCQUpBc2tELE1BR0l0a0Q7VUFDSixRQUEwQjs7TUFIOUIsVUFKUThaLHFCQUNKdXFDLElBRUFDLE1BU3dCO0lBL0w1QixTQW1NRUMsU0FBT3psQztNQUdULElBQUkwbEMsU0FISzFsQztNQUdULFNBRVFoUCxJQUFJalcsRUFBRTRxRDtZQUFGeGtELE1BQUV5a0Q7UUFBVTthQUFWQTtnQkFLSjVPLElBTEk0TyxVQUtDajdCLEtBTERpN0IsVUFLT24rQyxLQUxQbStDO1lBTWUsYUFEbkI1TyxJQUFLcnNCLHFCMUNsUWxCLE8wQzZQVzNaLElBQUk3UCxJQUtTc0c7VUFIZixHQUZNdEcsUUFGUnVrRCxvQkFLTztVQUNTO21DQU5oQkEsU0FFUXZrRDtXQUlRLElBSlJBOztXQUFFeWtEO21CQU0wQjtNQVJ4Qzs0QjFDM1BILE8wQzZQVzUwQyxvQkFRRztJQWhOWCxTQWtORTgwQyxZQUFZam9DO01BQWdCLGtCQUFoQkE7TUFBZ0Isb0IxQ3ZRakM7TTBDdVFpQyxzQjFDdlFqQyxPY21DU2hXLG9CNEJvT2tDO0lBbE54QyxTQW9ORWsrQyxjQUFjbG9DO01BQWdCLGtCQUFoQkE7TUFBZ0Isb0IxQ3pRbkM7TTBDeVFtQyxzQjFDelFuQyxPY21DU2hXLG9CNEJzT29DO0lBcE4xQztlQXdTTW0rQyxVQUFVaHJDLEVBQUVnOEI7UUFDZCxTQURZaDhCO1FBQ1osdUJBRFlBLEtBQUVnOEIsV0FDb0M7ZUFFaER0eEIsSUFBSTFLLEVBQUVnOEIsSUFBSXJzQjtRQUNKO3FCQURGM1AsRUFBRWc4QjtTQUUwQixVQUYxQkEsSUFBSXJzQixLQUVzQixpQkFGNUIzUCxLQUNGamdCO1FBRUosaUJBSE1pZ0IsS0FDRmpnQixZQUNBa3JEO1FBQ0osT0FITWpyQztRQUNFLFNBREZBO1FBR04sWUFFMkMsU0FSekNnckMsVUFHSWhyQyxPQUt1RDtlQWUzRDRMLE9BQU81TCxFQUFFZzhCO1FBQ0g7cUJBRENoOEIsRUFBRWc4QjtTQUVpQixxQkFGbkJoOEIsS0FiYWpnQjs7Ozs7Z0JBR1R1d0IsT0FBRzdqQjtZQUNULG1CQURNNmpCLEVBVUYwckI7Y0FSRixPQVFBaDhCO2NBUkE7a0NBRk92VDt3QkFLQyxpQkFLUnVULEtBYmFqZ0IsWUFHTjBNOzs7VUFEWixTQWFrQztlQVFwQ21oQixLQUFLNU4sRUFBRWc4QjtRQUNLLG1CQURQaDhCLEVBQUVnOEIsS0FDSCx1QkFEQ2g4QjtRQUNEO2NBRUtrckMsWUFBU3o2QixZQUFTMDZCO1VBQ3RCLG1CQUpFblAsSUFHRWtQLElBQ2dCLE9BRFB6NkI7VUFFaEIsR0FGeUIwNkI7Z0JBSWRDLEdBSmNELFNBSUx6NkIsR0FKS3k2QixTQUlJRSxNQUpKRjtZQUtsQixtQkFSRm5QLElBT01vUCxJQUNnQixPQURQMTZCO1lBRWhCLEdBRnlCMjZCO2tCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtjQUtsQixtQkFaTnJQLElBV1VzUCxJQUNnQixPQURQQzt3QkFBU0M7OztzQkFkMUJsN0IsV0FBR1gsY0FBTWxqQjtrQkFDYixtQkFFRXV2QyxJQUhFMXJCLEdBQ2UsT0FEWlg7NEJBQU1sakI7O2dCQURoQjtZQWNlO1VBSko7UUFKSixlQVVrRDtlQVEzRHloQixTQUFTbE8sRUFBRWc4QjtRQUNDLG1CQURIaDhCLEVBQUVnOEIsS0FDUCx1QkFES2g4QjtRQUNMO2NBRUtrckMsWUFBU3o2QixZQUFTMDZCO1VBQ3RCLG1CQUpNblAsSUFHRmtQLElBQ2dCLFVBRFB6NkI7VUFFaEIsR0FGeUIwNkI7Z0JBSWRDLEdBSmNELFNBSUx6NkIsR0FKS3k2QixTQUlJRSxNQUpKRjtZQUtsQixtQkFSRW5QLElBT0VvUCxJQUNnQixVQURQMTZCO1lBRWhCLEdBRnlCMjZCO2tCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtjQUtsQixtQkFaRnJQLElBV01zUCxJQUNnQixVQURQQzt3QkFBU0M7OztzQkFkMUJsN0IsV0FBR1gsY0FBTWxqQjtrQkFDYixtQkFFTXV2QyxJQUhGMXJCLEdBQ2UsVUFEWlg7NEJBQU1sakI7O2dCQURoQjtZQWNlO1VBSko7UUFKSixRQVUyRDtlQUVwRWcvQyxTQUFTenJDLEVBQUVnOEI7UUFDYixTQUFRMFA7VTFDamFmO1UwQ2lhZ0M7O2tCQUdkcDdCLGFBQVFwVCxhQUFHelE7Y0FDZixtQkFESTZqQixFQUpFMHJCLEtBTUMsVUFGSzkrQixFQUVMLGVBRlF6UTs7O1lBRGxCLFNBSXdCO1FBQ0wsbUJBUlp1VCxFQUFFZzhCO1FBUUUsdUNBUkpoOEIscUJBUTRCO2VBVXJDMnJDLFFBQVEzckMsRUFBRWc4QixJQUFJcnNCO1FBQ1I7cUJBREUzUCxFQUFFZzhCO1NBRUoseUJBRkVoOEIsS0FDTmpnQjtlQUNBK1M7OztnQkFQU3dkLFdBQUc3akI7WUFDVCxxQkFETTZqQixFQUtEMHJCLGdCQUxJdnZDO1lBRVAsV0FHR3V2QztZQUhILFdBR09yc0I7Ozs7O1lBSWQsaUJBSlEzUCxLQUNOamdCLGVBRFFpOEMsSUFBSXJzQixLQUVaN2M7WUFFRixPQUpRa047WUFJUixTQUpRQTtZQUlSLFFBRTJDLGdCQTNGM0NnckMsVUFxRlFockM7WUFJUjs7O1VBckJ1QixZQXdCdEI7ZUFFRDJMLElBQUkzTCxFQUFFZzhCO1FBTWM7d0JBTmhCaDhCLEVBQUVnOEI7U0FNTSx5QkFOUmg4Qjs7UUFDa0I7O1lBSXBCLElBRE9zUSxXQUFHN2pCLGNBQ1YscUJBRE82akIsRUFKSDByQjtZQUtKLFFBRkE7WUFFQSxVQURVdnZDOztVQURWLFNBR2tDO2VBRXBDeWlCLFFBQVFsSyxJQUFJamxCO1FBQ2Q7O21CQUFTLHFDQURDaWxCLElBQ0tzTCxFQUFFdm9CLEVBQWtCO2lCQURyQmhJLEVBQ3VCO2VBRW5DNnJELFlBQVk1bUMsSUFBSWpsQjtRQUNsQjs7bUJBQVMseUNBREtpbEIsSUFDQ3NMLEVBQUV2b0IsRUFBc0I7aUJBRHJCaEksRUFDdUI7ZUFFdkNvdkIsT0FBT3B2QixHQUNDLElBQU5pbEIsSUFBTSxlQUNWLFlBRElBLElBREtqbEIsR0FFVCxPQURJaWxCLEdBRUQ7O2NBcEhEeWpDO2NBMVFKRztjQU1BQztjQTJCQUk7Y0FpUEl2K0I7Y0FvQkFrQjtjQVVBZ0M7Y0FvQkFNO2NBY0F1OUI7Y0FrQkFFO2NBU0FoZ0M7Y0FyU0ptK0I7Y0FzQ0FJO2NBWUFDO2NBdkZBakI7Y0F1SEFvQjtjQWdCQUc7Y0FlQUs7Y0FFQUM7Y0EwTEk3N0I7Y0FHQTA4QjtjQUdBejhCO0lBcFpOO00xQ3JESCxJMEM0ZGF4Z0I7ZUFDQWdFLEtBQU1zekMsS0FBWTFoRCxHQUFJLHVCQUFKQSxFQUFZOzs2QkFEOUJvSyxNQUNBZ0U7T0FqS1I0ZTtPQUNBbUY7T0FDQW0xQjtPQUNBbmhDO09BQ0FrQjtPQUNBZ0M7T0FDQU07T0FDQXU5QjtPQUNBRTtPQUNBaGdDO09BQ0F2a0I7T0FDQThpRDtPQUNBMzdDO09BQ0FzRTtPQUNBeTNDO09BQ0FqN0M7T0FDQXk3QztPQUNBQztPQUNBNzdCO09BQ0EwOEI7O2VBZ0pJcnhDLE9BQU91eEMsSUFBSyw0QkFBTEEsR0FBNEI7ZUFDbkMzOEIsT0FBT3B2QjtRQUNDLElBQU5pbEIsSUFBTSxXQUNWLFdBbkpGNG1DLFlBa0pNNW1DLElBREtqbEIsR0FFVCxPQURJaWxCLEdBRUQ7O2NBSkR6SztjQW5LSmdYO2NBQ0FtRjtjQUNBbTFCO2NBQ0FuaEM7Y0FDQWtCO2NBQ0FnQztjQUNBTTtjQUNBdTlCO2NBQ0FFO2NBQ0FoZ0M7Y0FDQXZrQjtjQUNBOGlEO2NBQ0EzN0M7Y0FDQXNFO2NBQ0F5M0M7Y0FDQWo3QztjQUNBeTdDO2NBQ0FDO2NBQ0E3N0I7Y0FDQTA4QjtjQWlKSXo4QjtJQTNhTixTQTBiRXdxQixPQUFLcDFDLEdBQUksMEJBQUpBLEVBQWdDO0lBMWJ2QyxTQTJiRXduRCxXQUFXMzJDLEdBQUdDLEdBQUc5USxHQUFJLGlCQUFWNlEsR0FBR0MsS0FBRzlRLEVBQStCO0lBM2JsRCxTQTRiRXluRCxZQUFZL0YsS0FBSzFoRCxHQUFJLHdCQUFUMGhELEtBQUsxaEQsRUFBbUM7SUE1YnRELFNBOGJFeW1ELFVBQVVockMsRUFBRWc4QjtNQUVkLFlBRlloOEI7ZUFHUCxpQkFIT0EsS0FBRWc4QixRQUFGaDhCO2VBSVA7cURBSlNnOEIsS0FBRmg4QixnQkFJOEM7SUFsYzFELFNBb2NFaXNDLE1BQUlqc0MsRUFBRWc4QixJQUFJcnNCO01BQ0o7bUJBREYzUCxFQUFFZzhCO09BRTBCLFVBRjFCQSxJQUFJcnNCLEtBRXNCLGlCQUY1QjNQLEtBQ0ZqZ0I7TUFFSixpQkFITWlnQixLQUNGamdCLFlBQ0FrckQ7TUFDSixPQUhNanJDO01BQ0UsU0FERkE7TUFHTixZQUUyQyxTQVh6Q2dyQyxVQU1JaHJDLE9BS3VEO0lBemM3RCxTQXdkRTRMLE9BQU81TCxFQUFFZzhCO01BQ0gsZ0JBRENoOEIsRUFBRWc4QixLQUVpQixxQkFGbkJoOEIsS0FiYWpnQjs7O2NBR1R1d0IsT0FBRzdqQjtVQUNULHNCQURNNmpCLEVBVUYwckI7WUFSRixPQVFBaDhCO1lBUkE7Z0NBRk92VDtzQkFLQyxpQkFLUnVULEtBYmFqZ0IsWUFHTjBNOzs7UUFEWixTQWFrQztJQTFkdEMsU0FrZUV5L0MsT0FBS2xzQyxFQUFFZzhCO01BQ0ssbUJBRFBoOEIsRUFBRWc4QixLQUNILHVCQURDaDhCO01BQ0Q7WUFFS2tyQyxZQUFTejZCLFlBQVMwNkI7UUFDdEIsc0JBSkVuUCxJQUdFa1AsSUFDb0IsT0FEWHo2QjtRQUVoQixHQUZ5QjA2QjtjQUlkQyxHQUpjRCxTQUlMejZCLEdBSkt5NkIsU0FJSUUsTUFKSkY7VUFLbEIsc0JBUkZuUCxJQU9Nb1AsSUFDb0IsT0FEWDE2QjtVQUVoQixHQUZ5QjI2QjtnQkFJZEMsR0FKY0QsU0FJTEUsR0FKS0YsU0FJSUcsTUFKSkg7WUFLbEIsc0JBWk5yUCxJQVdVc1AsSUFDb0IsT0FEWEM7c0JBQVNDOzs7b0JBZDFCbDdCLFdBQUdYLGNBQU1sakI7Z0JBQ2Isc0JBRUV1dkMsSUFIRTFyQixHQUNtQixPQURoQlg7MEJBQU1sakI7O2NBRGhCO1VBY2U7UUFKSjtNQUpKLGVBVXNEO0lBOWVqRSxTQXNmRTAvQyxXQUFTbnNDLEVBQUVnOEI7TUFDQyxtQkFESGg4QixFQUFFZzhCLEtBQ1AsdUJBREtoOEI7TUFDTDtZQUVLa3JDLFlBQVN6NkIsWUFBUzA2QjtRQUN0QixzQkFKTW5QLElBR0ZrUCxJQUNvQixVQURYejZCO1FBRWhCLEdBRnlCMDZCO2NBSWRDLEdBSmNELFNBSUx6NkIsR0FKS3k2QixTQUlJRSxNQUpKRjtVQUtsQixzQkFSRW5QLElBT0VvUCxJQUNvQixVQURYMTZCO1VBRWhCLEdBRnlCMjZCO2dCQUlkQyxHQUpjRCxTQUlMRSxHQUpLRixTQUlJRyxNQUpKSDtZQUtsQixzQkFaRnJQLElBV01zUCxJQUNvQixVQURYQztzQkFBU0M7OztvQkFkMUJsN0IsV0FBR1gsY0FBTWxqQjtnQkFDYixzQkFFTXV2QyxJQUhGMXJCLEdBQ21CLFVBRGhCWDswQkFBTWxqQjs7Y0FEaEI7VUFjZTtRQUpKO01BSkosUUFVK0Q7SUFsZ0IxRSxTQW9nQkUyL0MsV0FBU3BzQyxFQUFFZzhCO01BQ2IsU0FBUTBQO1ExQzFqQlg7UTBDMGpCNEI7O2dCQUdkcDdCLGFBQUdYLGdCQUFNbGpCO1lBQ2Isc0JBREk2akIsRUFKRTByQixLQU1JLFVBRkhyc0IsS0FFRyxlQUZHbGpCOzs7VUFEaEIsU0FJd0I7TUFDTCxtQkFSWnVULEVBQUVnOEI7TUFRRSx1Q0FSSmg4QixxQkFRNEI7SUE1Z0J2QyxTQXNoQkUyckMsUUFBUTNyQyxFQUFFZzhCLElBQUlyc0I7TUFDUjttQkFERTNQLEVBQUVnOEI7T0FFSix5QkFGRWg4QixLQUNOamdCO2FBQ0ErUzs7O2NBUFN3ZCxXQUFHN2pCO1VBQ1Qsc0JBRE02akIsRUFLRDByQixnQkFMSXZ2QztVQUVQLFdBR0d1dkM7VUFISCxXQUdPcnNCOzs7OztVQUlkLGlCQUpRM1AsS0FDTmpnQixlQURRaThDLElBQUlyc0IsS0FFWjdjO1VBRUYsT0FKUWtOO1VBSVIsU0FKUUE7VUFJUixRQUUyQyxnQkE5RjNDZ3JDLFVBd0ZRaHJDO1VBSVI7OztRQXJCdUIsWUF3QnRCO0lBN2hCSCxTQStoQkVxc0MsTUFBSXJzQyxFQUFFZzhCO01BTWM7c0JBTmhCaDhCLEVBQUVnOEI7T0FNTSx5QkFOUmg4Qjs7TUFDa0I7O1VBSXBCLElBRE9zUSxXQUFHN2pCLGNBQ1Ysd0JBRE82akIsRUFKSDByQjtVQUtKLFFBRkE7VUFFQSxVQURVdnZDOztRQURWLFNBR2tDO0lBcmlCdEMsU0F1aUJFNi9DLFVBQVF0bkMsSUFBSWpsQjtNQUNkOztpQkFBUyx1Q0FEQ2lsQixJQUNLc0wsRUFBRXZvQixFQUFrQjtlQURyQmhJLEVBQ3VCO0lBeGlCckMsU0EwaUJFNnJELFlBQVk1bUMsSUFBSWpsQjtNQUNsQjs7aUJBQVMseUNBREtpbEIsSUFDQ3NMLEVBQUV2b0IsRUFBc0I7ZUFEckJoSSxFQUN1QjtJQTNpQnpDLFNBNmlCRXdzRCxTQUFPeHNELEdBQ0MsSUFBTmlsQixJQUFNLGVBQ1YsWUFESUEsSUFES2psQixHQUVULE9BRElpbEIsR0FFRDtJQWhqQkg7OztPQW1TTXlqQztPQTFRSkc7T0FNQUM7T0EyQkFJO09BMFlBZ0Q7T0E4QkFDO09Bb0JBQztPQWNBQztPQTJCQUM7T0F2RUF6Z0M7T0E4REErL0I7T0FyYkE3QjtPQXNDQUk7T0FZQUM7T0F2RkFqQjtPQXhEQVo7T0FDQUM7T0E4S0ErQjtPQWdCQUc7T0FlQUs7T0FFQUM7T0FtVkF1QjtPQUdBVjtPQUdBVzs7O09BbkhBNVM7T0FFQXFTO09BREFEOztJQTNiRjthQ2dESVMsWUEvRUt0bUQ7TUFDVCxjQURTQSxNQUNULFVBRFNBO01BRVA7TUFDRixnQ0FIU0EsRUFHRDthQUtOdW1ELFNBQU9sb0QsR0FBSSxPQUFKQSxvQkFBNEM7YUFFbkRtb0QsMEJBQXdCbDlDLEVBQUV2QixFQUFFeU07TUFDOUIsY0FENEJ6TSxNQUM1QixVQUQ0QkEsSUFDTixTQURJdUIsWUFFeEI7OEJBRjRCa0wsU0FFWjthQUloQml5QyxJQUFJbjlDLEVBQUV2QixFQUFFMUo7TUFDViwwQkFETWlMLEVBQUV2QjtNQUNSLEdBRFUxSixHQUlFLElBQUwrUCxJQUpHL1AsS0FJRSx5QkFKTmlMLEVBQUV2QixFQUlEcUc7TUFERywyQkFISjlFLEVBQUV2QixFQUljO2FBR3BCMitDLE1BQUlwOUMsRUFBRXZCO01BQ1IsMEJBRE11QixFQUFFdkI7TUFFUiw2QkFGTXVCLEVBQUV2QixFQUVEO2FBR0w0K0MsU0FBU3I5QyxFQUFFdkI7TUFDYiwwQkFEV3VCLEVBQUV2QjtNQUViLGtDQUZXdUIsRUFBRXZCLEVBRUQ7YUFHVjYrQyxRQUFNdDlDLEVBQUV2QjtNQUNWLDBCQURRdUIsRUFBRXZCO01BRVYsK0JBRlF1QixFQUFFdkIsRUFFRDthQUtQOCtDLE9BQUt2OEMsR0FBRzFCLEdBQUdtTSxHQUFHQyxHQUFHaFY7TUFFRTs7O1FBRkZBOzs7O1FBQVQ0STs7O1VBQ2lCLFNBRHBCMEIsTUFBWXRLLFNBQVQ0STs7OztRQUFNb007OztVQUVLLFNBRlJELE1BQU0vVSxTQUFIZ1Y7UUFJWDtvQkFKY2hWO1NBSWQsVUFBZSx1QkFKYnNLLEdBQUcxQixHQUFHbU0sR0FBR0MsR0FBR2hWO1FBSW1CO01BRGpDLGlDQUNpQzthQUVwQzhtRCxPQUFLQyxHQUFHdmxELElBQUlDLElBQUlwRDtNQUNhLFFBRHJCbUQsWUFBSUMsV0FDaUIsU0FEeEJzbEQsTUFBT3RsRCxXQUFKRDtRQUdMLFVBSEtBLE1BQUlDO1FBR1QsYUFIS0Q7Y0FHTDNILEVBSEsySDtVQUtOO2dCQUxHdWxELEdBR0ZsdEQsRUFIYXdFO1lBS2QsU0FGQ3hFOzs7O01BREEsd0NBS0Y7O01BMkJlLElBQWRtdEQsWUFBYztlQVlkQyxVQUFVdnZDLEVBQUVvQyxHQUFJLGdCQUFKQSxlQUFGcEMsZ0JBQWlEO01BWjdDLElBY2RnaUM7TUFkYyxTQWlCZHJsQyxPQUFPdXhDO1FBQ1Q7bUJBRFNBO1NBRVQsd0JBRElzQjtRQUdNOytCQUZOQyxLQW5CRkg7Z0JBc0JTLGVBSFBHO2dCQUxGek47O2tCQVlEO01BMUJlLFNBNEJkcnVCLE1BQU0zVDtRQUNSLFNBRFFBLHdCQUNSOzs7VUFDRTs2QkFGTUEsS0FDUjdkLFlBN0JFbXREO1lBK0JBLGlCQUhNdHZDLEtBQ1I3ZDtZQUVFLFNBRkZBOzs7UUFJQSxPQW5CRTYvQztRQW1CRjtnQkFDZTtNQWxDQyxTQXFDZHJ4QyxLQUFLdEssRUFBRTJaLEVBQUV2QztRQUNYLFNBRFN1QyxLQUNUO1FBTWlCOzBCQU5LaFksRUFBRW1PO3VCQUFKNU4sTUFBSStDO21CQUN0QjtxQkFBUSxZQURZdEQsTUFBRk8sSUFDSSxPQURBK0M7cUJBRWhCLGdCQUZjdEQsRUFBRk87cUJBRVo7dUJBQ007O3dCQUFvQixrQkFKM0JsQyxFQUlFOEQsRUFIZW1CO3dCQUdVLElBSGQvQzs7d0JBQUkrQzs7cUJBRWhCLElBRUksSUFKUS9DOzs7aUJBRFRrVixLQU9rQztNQTVDN0IsU0ErQ2RqVSxLQUFLbkQsRUFBRTJaO1FBQ1QsU0FEU0EsS0FDVDtRQU1XOzBCQU5XaFk7bUIzQ3RKM0IsSTJDc0p5Qk87bUJBQ2xCO3FCQUFRLFlBRFlQLE1BQUZPLElBQ0k7cUJBQ2hCLGdCQUZjUCxFQUFGTztxQkFFWjt1QkFDTSxJQUFMNEI7dUJBQUssV0FKUDlELEVBSUU4RDt1QkFBSyxRQUhNNUI7O3FCQUVaLElBRUksSUFKUUE7O3NCQU1jO01BdERsQixTQW1FVm1uRCxhQUFhdnRELEVBQUU2RixFQUFFc0Q7WUFBSi9DLE1BQUlpRDtRQUN2QjtVQUFRLFlBRGF4RCxNQUFGTyxJQUNHLE9BRENpRDtVQUVVO3dCQUZaeEQsRUFBRk87V0FBSTROO1dBQUpvRDs7V0FBSS9OO21CQUVtQztNQXJFMUMsU0F3RWQrcUIsTUFBTXZXO1FBQ1IsZ0JBRFFBLEtBQ1I7UUFBaUI7cUMzQy9LdEIsTzJDeUtXMHZDOztzQkFNcUM7TUF6RTNCLFNBb0lkQyxRQUFRM3ZDLEVBQUU0dkMsT0FBT3R3QyxFQUFFOEMsRUFBRXl0QztRQUNWO21DQURIN3ZDLEtBQWE2dkM7U0FFVix3QkFGSDd2QyxLQUFhNnZDO1NBR2QsWUFGTEM7U0FHUzMwQjtRQUNYO2FBRkUreUIsTUFDUy95QjtZQUdQO2FBREU2MEI7Y0FDRixVQUpGOUI7WUFJRSxHQURFOEIsU0FISjlCLEdBTW9CO1lBRmxCO2FBR2Msd0JBSlo4QjthQUtZLHlCQUxaQTtZQU1KLE9BWEFGLFdBU0lHLGNBUEovQjtZQVVBLE9BWEE2QixTQVNJRyxZQVJKaEM7WUFXQSxXQWRRMEIsT0FVSkssWUFQSi9CLEdBSGU1dUM7WUFlZixpQkFKSTR3QyxVQVJKaEMsY0FIaUI5ckM7WUFnQmpCLGlCQWhCTXBDLEtBQWE2dkMsb0JBVWZJO1lBT0osaUJBakJNandDLEtBQWE2dkMsb0JBV2ZLO1lBSkYsSUFVRixLQWRBaEMsTUFITWx1QyxTQWlCTixVQWpCTUEsT0FNRmd3QztZQVlxQztxQkFsQm5DaHdDO2tCQW9CSnFiO2NBQTRCO2dCQXhFbEM7c0JBb0RVcmI7aUJBcERHLHdCQW9ESEE7aUJBcERHLEtBb0RIQTtpQkFuREkseUJBbURKQTtpQkFsREEsV0FGTnF0QztpQkFIVSxZQUFKdmxEO2lCQU9DLG9CQUpQdWxEO2dCQUlPLEdBQVBnRCxRQURBRDtrQkFhTSxpQkFoQk4vQyxnQkFNVzlrRCxNQUFFNFE7a0JBQ2I7dUJBSkFpM0MsWUFHYWozQztzQkFFUixXQVJMazBDLE9BTVc5a0Q7d0JBRWMsUUFGZEE7c0JBR0QsV0FUVjhrRCxPQU1hbDBDO3dCQUlULE9BVkprMEMsT0FNYWwwQyxFQU5iazBDLE9BTVc5a0Q7d0JBS1EsMEJBVm5CNG5ELFFBS2FoM0M7d0JBS1QsaUJBVkpnM0MsUUFLVzVuRDt3QkFLUSxJQUFmLElBTFM0USxVQUtULElBTE81USxvQkFBRTRROztzQkFPRixRQVBFQTs7NkJBSGJpM0M7c0JBY21CLFNBbUNicHdDO3NCQWxDTixpQkFrQ01BLHVCQXBJUnN2QztzQkFpR3FCLFNBbUNidHZDO3NCQWpDTixpQkFpQ01BOztzQkEvQlUsSUFBWnV3QyxVQUFZLFlBbEJoQkg7c0JBbUJBLE9BdEJBL0MsU0FxQklrRCxZQWxCSkg7c0JBa0JnQixTQStCVnB3QztzQkE3Qk4saUJBNkJNQSx1QkEvQkZ1d0M7c0JBQVksSUFHTSxXQXZCdEJKLFVBRUFDLFVBcUJzQixLQTRCaEJwd0M7c0JBNUJOLGlCQTRCTUE7b0JBMUJSLFNBMEJRQSxPQXZEQWxZLE1BNkJSLFVBdkJFc29ELFlBaURNcHdDO29CQTFCcUMsZUEwQnJDQTs7Z0JBeEJWLGdCQXdCVUE7Z0JBcERWLFNBd0VNcWI7OztZQWJBLFdBUElyYjtZQXNCTjtjQTFDSjttQkFvQlVBO2VBeERJLGlCQUFKMUs7dUJBcUNOd1M7Z0JBRVMsZ0JBRlRBLFFBdkRKLEtBMEVVOUgsS0ExRVY7Z0JBTVk7MkJBTlU3RyxFQTBEUHMzQztvQjNDMU5wQixJMkNnS3lCbG9EO29CQUNsQjtzQkFBUSxZQXlES2tvRCxPQTFES2xvRCxJQUNJO3NCQUNoQixrQkF3RE9rb0QsR0ExREtsb0Q7c0JBRVo7d0JBQ1E7NkNBdUVOeVgsS0ExRVk3Rzt5QkEyRGxCO21DQTNEZ0JoWDtxQ0EyRFp5dEQsT0FBT2dCLEdBQUdDLFVBQU8sY0FEVkosR0ExREt0dUQsRUEyREx5dUQsR0FBR0MsS0FBeUI7bUNBQW5DakI7eUJBQUosZ0JBM0RnQnJuRDt5QkE0RFIsbUJBRk1tb0QsR0ExREVub0Q7d0JBNkRXLFFBSnpCaW9ELEtBRUVaLFNBQ0F4dEMsRUFDdUIsVUFKekJvdUMsS0FHRXB1Qzt3QkF6RFEsSUFISTdJOztzQkFFWixJQUVLLElBSk9oUjs7O2dCQTBFVnlYLE9BakJKd3dDO2dCQWlCSXh3QyxPQWpCSnd3QztnQkFpQkl4d0MsT0FqQkp3d0M7Z0JBaUJJeHdDLE9BakJKd3dDO2dCQWlCSXh3QyxxQkFqQkp3d0M7O2NBWUcsTy9CaExQbHBEO2MrQmdMTzs7WUE0QkU7VUFBRyxXQXRCVndvRCxTQUdTMzBCLE1BbUJxQixRQW5CckJBO1VBc0JULFdBMUJReTBCLE9BQ1JFLFNBR1MzMEIsSUFKTTdiO1VBMkJmLGlCQXpCQXl3QyxPQUVTNTBCLGdCQUpRL1k7VUEyQmpCLFNBR0U7TUFsS1UsU0FxS2QwSyxJQUFJOU0sRUFBRVY7UUFDQSxJQUFKOEMsRUFBSSxnQkFEQTlDLEdBRWlCLGVBRm5CVSxFQXJPTit1QyxPQXFPUXp2QyxHQUNKOEMsRUFDcUIsVUFGbkJwQyxFQUNGb0MsR0FDb0M7TUF2S3hCLFNBMEtkMHVDLFFBQVE5d0MsRUFBRVYsRUFBRXl4QztRQUNOOzJCQURJenhDO1NBRUEsZ0JBRkZVLEVBQ05vQztTQUVTLHdCQUhIcEMsS0FFTjZ2QztTQUVTLHdCQUpIN3ZDLEtBRU42dkM7U0FHSyxZQUZMeEM7U0FHU2xyRDtRQUNYO2FBRkUrckQsTUFDUy9yRCxFQUNLLGtCQVBKNHVELFdBQ1YzdUMsRUFDQXl0QztVQU1VLEdBUFZ6dEMsTUFPVSxpQkFKVjJ0QyxPQUVTNXREO1lBR0gsbUJBTk5rckQsT0FHU2xyRDtZQUdIO2tCQUNDZ0k7Y0FBTyxtQkFBUEEsRUFWQ21WO2dCQVdVLGtCQVJsQit0QyxPQUdTbHJEO2dCQUtTLFlBQ0EsSUFBTCt0QixlQUFLLE9BQUxBO2dCQURLLElBRUYsSUFQUC90Qjs7WUFHSCxJQU1DLElBVEVBOztVQVVGLFFBVkVBO21CQVlQO01BNUxVLFNBK0xkc2MsTUFBTXVCLEVBQUVWO1FBQ1Y7aUJBRFFVLEVBQUVWLFdBQ084QyxFQUFFeXRDLE9BQVMsUUFEcEI3dkMsRUEvUFIrdUMsT0ErUFV6dkMsR0FDTzhDLEVBQUV5dEMsT0FBUyxPQURsQnZ3QyxDQUNtRCxFQUFDO01BaE05QyxTQW1NZDBRLEtBQUtoUSxFQUFFVjtRQUFJLGVBQU5VLEVBQUVWLFdBQXFCOEMsRUFBR3l0QyxPQUFVLGVBQWUsRUFBQztNQW5NM0MsU0FxTWR2L0IsU0FBU3RRLEVBQUVWO1FBQ0w7MkJBREtBO1NBRUQsZ0JBRkRVLEVBQ1BvQztTQUVTLHdCQUhGcEMsS0FFUDZ2QztTQUVTLHdCQUpGN3ZDLEtBRVA2dkM7U0FHSyxZQUZMeEM7U0FHU2xyRDtRQUNYO2FBRkUrckQsTUFDUy9yRCxFQUNLO1VBQ0osR0FQVmlnQixNQU9VLGlCQUpWMnRDLE9BRVM1dEQ7WUFHSCxtQkFOTmtyRCxPQUdTbHJEO1lBR0g7a0JBQ0NnSTtjQUFPLG1CQUFQQSxFQVZFbVY7Z0JBV1MsSUFDVjRRLElBRFUsTUFSbEJtOUIsT0FHU2xyRDtnQkFLUyxHQUNWK3RCLElBQWUsT0FBZkE7Z0JBRFUsSUFFRixJQVBQL3RCOztZQUdILElBTUMsSUFURUE7O1VBVUYsUUFWRUE7bUJBWVA7TUF2TlUsU0EwTmQ2dUQsWUFBWWh4QyxFQUFFVixFQUFFMnhDLFFBQVFGO1FBQ2xCOzJCQURRenhDO1NBRUosZ0JBRkVVLEVBQ1ZvQztTQUVTLHdCQUhDcEMsS0FFVjZ2QztTQUVTLHdCQUpDN3ZDLEtBRVY2dkM7U0FHSyxZQUZMeEM7U0FHU2xyRDtRQUNYO2FBRkUrckQsTUFDUy9yRCxFQUNLLE9BUFE0dUQ7VUFRWixHQVBWM3VDLE1BT1UsaUJBSlYydEMsT0FFUzV0RDtZQUdILG1CQU5Oa3JELE9BR1NsckQ7WUFHSDtjQUNRLElBQVBnSTtjQUFPLG1CQUFQQSxFQVZLbVYsR0FVaUIsa0JBVmYyeEMsUUFHZDVELE9BR1NsckQ7WUFHSCxJQUVDLElBTEVBOztVQU1GLFFBTkVBO21CQVFQO01BeE9VLFNBMk9kNnJCLE9BQU9oTyxFQUFFVjtRQUFJOzJCQUFOVSxFQUFFVixXQUF5QndvQixFQUFFM2xDLEdBQUssV0FBUDJsQyxFQUFFM2xDLElBQWlCLE9BQUk7TUEzTzNDLFNBOE9kNHJCLElBQUkvTixFQUFFVjtRQUFJLDhCQUFOVSxFQUFFVixXQUF5QndvQixFQUFHM2xDLEdBQU0sUUFBSSxPQUFPO01BOU9yQyxTQWlQZDByRCxTQUFTN3RDLEVBQUVWO1FBQ0w7MkJBREtBO1NBRUQsZ0JBRkRVLEVBQ1BvQztTQUVTLHdCQUhGcEMsS0FFUDZ2QztTQUVTLHdCQUpGN3ZDLEtBRVA2dkM7U0FHSyxZQUZMeEM7U0FHU2xyRDtTQUFFbUo7UUFDYjthQUZFNGlELE1BQ1MvckQsRUFDSyxPQURIbUo7VUFFRCxHQVBWOFcsTUFPVSxpQkFKVjJ0QyxPQUVTNXREO1lBR0gsbUJBTk5rckQsT0FHU2xyRDtZQUdIO2tCQUNDZ0k7Y0FBTyxtQkFBUEEsRUFWRW1WO2dCQVdTLGtCQVJsQit0QyxPQUdTbHJEO2dCQUtTO2tCQUNBOzs2QkFBTCt0QixJQU5GNWtCO21CQU1PLElBTlRuSjs7bUJBQUVtSjs7Z0JBS08sSUFFRixJQVBQbko7O1lBR0gsSUFNQyxJQVRFQTs7VUFVRixRQVZFQTttQkFZSjtNQW5RTyxTQXNRZHVxRCxNQUFNMXNDO1FBQ1IsUUFEUUEsZ0JBRUcsV0FoVlg2dUMsU0E4VVE3dUM7UUFHUixzQkFESWt4QztRQURKO1NBRUE7U0FDYTswQzNDaFhsQiw2QjJDOFdTQTtTQUVTLEtBSFRubkQ7U0FJMkMsS0FKM0NBO1NBSTJDLHNCQUgzQ21uRDtTQUc2QixzQkFIN0JBO1NBR21CLHNCQUhuQkE7UUFHRSxVQUpGbm5ELElBSUUsTUFMRWlXLEdBSUpteEMsc0JBQ3dEO01BM1E1QztjQWlCZHgwQztjQVdBZ1g7Y0FtS0FsVjtjQTFCQXFPO2NBc0VBa0I7Y0F4Q0FnQztjQUVBTTtjQTRDQXU5QjtjQUhBOS9CO2NBL0xBdmtCO2NBVkFtSDtjQW1DQTRsQjtjQThMQW0yQjs7O1NBdlFBa0MsWUF2RUZDLFNBUUFFLElBT0FDLE1BS0FDLFNBS0FDLFFBYUFFLE9BTkFEOzthQ3ZDQWlDLEtBQUd6cUQsR0FBSSxPQUFKQSxDQUFLOzs7S0E0ckJKNnVDO0tBMXFCRjZiO2FBaUxGQyxXQUFXanFDLE1BQU1rcUM7TUFDbkIsWUFEYWxxQyxZQUFNa3FDLGFBQ25CLFdBRG1CQSxNQUFObHFDLFVBRWlCO1FBNEI1Qm1xQzthQUdBQyxpQkFBaUJwcUMsTUFBTTdnQjtNQUFJLGtCQUFWNmdCLFVBQU03Z0IsSUFBSSxzQkFBSkEsR0FBNkM7YUFDcEVrckQsa0JBQWtCcnFDLE9BQVEsa0JBQVJBLFlBQStCO2FBS2pEc3FDLGVBQWV0cUMsTUFBTW11QixLQUFLb2M7TUFDNUIsV0FEaUJ2cUMsV0FBTW11QjtNQUV2QixpQkFGaUJudUIsTUFBV3VxQztNQUU1QjtjQUM2QjthQUczQkMsY0FBY3hxQyxNQUFNN2dCO01BQ25CLDhCQURtQkE7TUFDbkIsWUFBYSxlQURBNmdCLE1BQ0Esc0JBRE03Z0IsVUFDa0M7YUFHdERzckQsZUFBZXpxQyxZQUE4Qm1XO1VBQVBxRCxlQUFSaEgsZ0JBQVJpSDtNQUN4QixjQURpQnpaLE1BQU95WjtNQUV4QixrQkFGaUJ6WjtNQUVqQjs7ZUFGaUJBLFdBQThCbVcsYUFBZjNEO09BTWQsZ0JBTkR4UyxTQUlia3RCO01BRWMsWUFBZHdkO01BQWMsV0FORDFxQztNQWJZLFdBYVpBO2FBSmZ3cUMsY0FJZXhxQyxNQUF1QndaO2FBY3RDbXhCLFdBQVczcUMsTUFBTW1XLE9BQVEsc0JBQWRuVyxXQUFNbVcsTUFBOEM7YUFHL0R5MEIsZ0JBQWdCNXFDO1VBQXNCd1osZUFBUHJELGVBQVJzRDtNQUN6QixjQURrQnpaLE1BQU95WjtNQUN6QixXQURrQnpaLFdBQWVtVztNQS9CSixXQStCWG5XLFVBQWVtVzthQXJCL0JxMEIsY0FxQmdCeHFDLE1BQXNCd1o7YUFrSmxDcXhCLGFBQWE3cUM7TUFDbkI7UUFBTSxzQkFEYUE7UUFDYjtVQUlEOztXQUZJOHFDO1dBQWF2MUM7V0FBUDIwQztXQUNUYSxjQUphL3FDO1dBS2QsVUFGSThxQztXQUVKLGNBTGM5cUMsWUFJYitxQztVQUMrRDtZQUNqRSxLQU5lL3FDO1lBT0QsSUFBVmdyQyxZQUpDRixjQXpMUFg7c0JBeUxhRDs7O2dCQXJGRCxvQkFrRktscUM7Z0JBbEZMOzs7bUJBRUlpckM7bUJBQ05DOzZCQUFRenFELEVBRVowcUQ7c0I1Q2pXWCxHNENpV1dBOzRCQUFLbHFELEVBQUxrcUQ7d0JBQW1CLHFCQUZQMXFELEVBRVpuQixNQUZZbUIsRUFFWjBxRCxTQUFnRCxRQUZwQzFxRCxFQUVQUTtzQkFEQyxVQURNUjtrQkFHUixrQkE0RU91Zix3QkFoRkRpckM7O3NCQVhoQixRQTJGaUJqckM7c0JBckZqQixRQXFGaUJBOztnQkFwREwsb0JBb0RLQTtnQkFwREw7eUNBRUhtcEI7a0JBbkdUd2hCLFdBcUppQjNxQyxNQWxEUm1wQjs7aUJBREMsa0JBbURPbnBCOzs7Z0JBOUNqQixHQThDaUJBO2tCQTVIYixxQkE0SGFBO2tCQTVIYjsyQ0FFR211QixnQkFBTXZnQztvQkEwSElvUyx3QkExSEpwUztvQkEwSElvUyxzQkExSFZtdUI7OztnQkErR00sb0JBV0ludUI7Z0JBWEo7a0JBR1Y7O21CQUFhLGtCQVFDQSxVQVRUb3JDO2tCQUNRLGlCQVFDcHJDLE1BUlZxckM7O29CQVdNbkI7c0JBOUdiLElBRFEvcUQsRUErR0srcUQsU0E5R2IsZUEyR2lCbHFDLE1BT1hnckMsT0FuSEU3ckQ7O2dCQW1FSTtpQkFGS21zRCxPQThDSnBCO2lCQTlDRnFCLEtBOENFckI7aUJBN0NEc0IsSUFES0Y7aUJBQ2I3eEIsT0FEYTZ4QjtpQkFFTCxnQkF5Q0t0ckM7Z0JBekNMOzs7bUJBRU8weUI7bUJBQVYrWTs7MkJBa0JNLGdCQXFCRXpyQyxNQTNDTnVyQzsyQkFxQkksZUFzQkV2ckMsTUEzQ0FzckMsT0FJRTVZOzJCQWVILGVBd0JDMXlCLE1BM0NBc3JDLE9BSUU1WTs7cUJBR2YsR0FvQ2ExeUIsWUFPWGdyQyxTQTNDRixzQkFOQXZ4QjtzQkFPSyxlQW1DUXpaLE1BM0NBc3JDLE9BSUU1WTs7c0JBS1YsZ0JBa0NRMXlCLE1BM0NOdXJDOzs7cUJBWVAsR0ErQmF2ckM7c0JBL0JnQixnQkErQmhCQSxNQTNDTnVyQzs7c0JBYVAsR0E4QmF2ckMsWUFPWGdyQyxTQXJDRixzQkFaQXZ4Qjt1QkFhTyxlQTZCTXpaLE1BM0NBc3JDLE9BSUU1WTs7dUJBWWYsS0EyQmExeUIsV0F2Q0UweUIsZUFIUDhZLFdBMENLeHJDO3dCQTFCUixlQTBCUUEsTUEzQ0FzckMsT0FJRTVZOzt3QkFjVixnQkF5QlExeUIsTUEzQ051ckM7OzRCQW9CSSxnQkF1QkV2ckMsTUEzQ051ckM7OztnQkE1QkM7aUJBRkVHLE1BNEVEeEI7aUJBNUVGenBELEVBNEVFeXBEO2lCQTNFVHlCLGdCQXdFYTNyQztpQkF2RUwsaUJBdUVLQTtnQkF2RUw7MkNBRUk0ckM7O29CQUtWLHdCQUxVQTtvQkFLSzs7NEJBQ0h6akQsY0FBUjJqRDs4QkFUTkgsbUJBU01HLGlCQUFRM2pEO2lDQUFSMmpEOztnQ0FGSkQ7MEJBSEFFOzs7MkJBSkZKO2tCQWFGLElBQUluNUIsT0FUQXU1QixNQUpGSjtrQkFhRixRQUFJbjVCO21CQUVDLGdCQXlEVXhTLGdCQTNEWHdTLFNBZEsveEI7O21CQWlCSjtxQkF3RFV1ZixnQkFwRVgrckMsTUFMUUwsa0JBeUVHMXJDOzs7O2lCQXpHRnZrQixHQTRHRnl1RDtpQkE1R0g4QixNQTRHRzlCO2lCQTNHVCtCLGtCQXdHYWpzQzs4QkF4R2Jpc0M7a0JBL0JBLGtCQXVJYWpzQztrQkF2SWI7eUNBRWFtVyxpQkFBVmlYO3VCQXFJVXB0QixXQXJJQW1XO3NCQUVmLGFBRktpWDtzQkFFTCwwQkFFNkMsV0FpSTlCcHRCLE1BcklBbVc7O21CQURULGtCQXNJU25XO2dCQXJHb0I7eUJBcUdwQkEsV0F6R1Bnc0M7aUJBSTJCLGlCQUp0QnZ3RCxLQXlHRXVrQixXQU9YZ3JDLE9BaEhTdnZEO2dCQVdmLFFBTEkwd0QsV0FEQUQsU0FvR2Fsc0M7O3NCQXhGakIsSUFEVW9zQyxLQTRGR2xDLFNBM0ZiLEtBRFVrQyxLQXlGT3BzQzs7Z0JBaEJoQjs0QkFtQllrcUM7aUJBbkJDLG9CQWdCR2xxQyxVQWpCSnFzQztnQkFFWixpQkFlZ0Jyc0MsTUFoQlpzc0M7Z0JBQ0osS0FGWUQsV0FpQklyc0M7d0JBR0d6SyxXQUhIeUs7O1VBRVQ7aUJBU0w7YUFJSHVzQyxnQkFBZ0J2c0MsTUFBTTBEO01BQU0sV0FBWjFELE1BQU0wRCxLQUFNLG9CQUFaMUQsTUFBb0Q7YUFJcEV3c0Msa0JBQWtCeHNDLE1BQU1tdUIsS0FBS2h2QztNNUNqY2xDLE80QzZiS290RCxnQkFJa0J2c0MsU0FBTW11QixRQUFLaHZDLEdBQUxndkMsTUFDa0Q7YUFXMUVzZSxzQkFBc0JDO01BQ3hCLE1BRHdCQTtNQUN4QixJQUNJQyxjQXRhQTNDO01BcWFKLGtCQUNJMkMsWUFGb0JELE1BR3dCO2FBVzlDRSxTQUFTNXNDLE1BQU12a0I7TUFDWCxrQkFES3VrQjtNQUNMOzs7U0FFZTJzQztTQUFaRTtjQUFZRjtXQUFaRSxhQUhFN3NDLFVBT1AsNkJBUE9BO1FBU1AsU0FOaUIyc0M7UUFNakI7OztZQU9FLGFBaEJXbHhEO1lBZ0JYO3NCQWJla3hELGdCQUhWM3NDLHFCQWtCSCxRQWxCR0E7Ozs7WUFXTCxPQVhXdmtCO3NCQUdJa3hELGdCQUhWM3NDLHFCQWFILFFBYkdBO3FCQUFNdmtCOztRQXNCWDtNQXBCSSxRQW9CRjthQUtOcXhELFVBQVU5c0MsTUFBTXJmLEVBQUV1cEQ7TUFDcEIsV0FEWWxxQyxNQUFRa3FDO01BQ3BCLEdBRGtCdnBELEVBRVIsU0FGRXFmO01BRWlCLElBQ3pCK3NDLFFBSFEvc0MsVUFBUWtxQztNQUVTLFlBQ3pCNkMsS0FIUS9zQyxTQUl1QjthQU1qQ2d0QyxnQkFBZ0JodEMsTUFBTWt0QixPQUFPK2Y7TUFDL0IsWUFEa0JqdEM7TUFDbEIsR0FEa0JBO1FBR2hCLFdBSGdCQSxjQUlaK3NDLFFBREE1ZSxRQUhrQmpCLE9BQU8rZjtlQVY3QkgsVUFVZ0I5c0MsUUFJWitzQztNQUVOLFNBTmtCL3NDO01BTWxCO1FBQ0ssU0FQYUE7ZUEvRGhCd3NDLGtCQStEZ0J4c0MsTUExRGxCO2lCQWlFMkM7YUFPekNrdEMsYUFBYWx0QztNQUNmLGFBRGVBO01BQ2Y7UUFDQSxHQUZlQTtVQUtYLFdBTFdBLFNBcU1UbXVCLFdBL0xGLFNBTldudUIsU0FNVSxTQU5WQTtRQU04QixZQU45QkE7Ozs7TUFIVyxXQVl2QjthQUlEbXRDLGFBQWFudEMsTUFBTW9yQztNQUNyQixHQURlcHJDLFdBR2IsS0FIbUJvckMsU0FBTnByQyxVQUliLFdBSmFBLFVBQU1vckM7TUFJYSxTQUpuQnByQztNQUltQjtRQUdoQyxJQUFJa3FDLFNBUGVrQixVQU9uQixrQkFQYXByQyxTQXdMVG11QixLQWpMQStiO2lCQUNvRDthQUl4RGtELGNBQWNwdEM7TUFDaEIsR0FEZ0JBLFVBRWQsV0FGY0EsU0E0S1ZtdUI7TUExS21FLFNBRnpEbnVCO01BRXlEO1FBRWpFLGtCQUpRQTtRQUlSLFVBR0osSUFES29yQyxrQkFDTCxrQkFQWXByQyxVQU1Qb3JDO1FBRkQ7OztpQkFHNkI7YUFFbkNpQyxZQUFZcnRDLE1BQU03Z0IsR0FBSSxvQkFBVjZnQixvQkFBTTdnQixHQUFxQzthQUN2RG11RCxhQUFhdHRDLGFBQVcscUJBQVhBLFFBQWlDO2FBRTlDdXRDLGtCQUFrQnZ0QyxNQUFNcmYsR0FBSSxZQUFKQSxFQUFJLFFBQXdCO2FBQ3BENnNELGlCQUFpQnh0QyxNQUFNcmYsR0FBSSxZQUFKQSxFQUFJLFFBQXVCO2FBQ2xEOHNELGtCQUFrQnp0QyxhQUFXLE9BQVhBLFNBQThCO2FBQ2hEMHRDLGlCQUFpQjF0QyxhQUFXLE9BQVhBLFNBQTZCO2FBQzlDMnRDLFlBQVkzdEMsTUFBTXJmO01BQ3BCLGtCQURjcWYsTUFBTXJmLEdBQ3BCLHdCQURjcWYsTUFBTXJmLEVBQytCO2FBSWpEaXRELCtCQUFnQzV0QztNQUFXLFVBQVhBLHdDQUtuQzthQUdHNnRDLCtCQUFnQzd0QztVQUlaOHRDLGFBRERDLGFBREFDLGFBRERDO01BRGNqdUMsWUFDZGl1QztNQURjanVDLFlBRWJndUM7TUFGYWh1QyxZQUdiK3RDO01BSGEvdEMsWUFJWjh0Qzs7YUFTcEJJLFNBQVNsdUM7TUFqWFg7O2NBaVhXQTtNQUVYLHNCQUZXQTtNQUdYLE1BSFdBO01BSVgsTUFKV0E7TUFLWCxNQUxXQTtNQU1YLE1BTldBO01BTVg7O2lCQU5XQTtNQXRFZSx1QkFzRWZBLFVBVVU7YUFPbkJtdUMsZUFBZW51QyxNQUFNcmY7TUFKdkIsU0FJaUJxZjtNQUpqQix1QkFBcUIsb0JBSUpBLFFBSnlCO01BT25CO2VBSE5BLFdBR2YsYUFIZUE7UUFLakIsWUEvV0VtcUM7UUFnWEYsYUFOaUJucUM7UUFNakIsR0FOdUJyZixFQU9iLGtCQVBPcWY7UUFPZ0IsZ0JBUGhCQSxPQVFIO2FBU1pvdUMsaUJBQWlCcHVDLE1BQU1tdUIsS0FBS2h2QztNQUM5QixTQURtQjZnQjtNQUNuQixZQUNLLGtCQUZjQSxNQUFNbXVCLEtBQUtodkMsT0FFSzthQUdqQ2t2RCxZQUFZcnVDLE1BQU1zdUMsTUFBTW52RDtNNUN4bkI3QixPNENtbkJLaXZELGlCQUtZcHVDLE1BQU1zdUMsTUFBTW52RCxFQUNrQjthQUcxQ292RCxnQkFBZ0J2dUMsTUFBTTdnQjtNQUN4QixtQkFEa0I2Z0IsTUFDbEIsc0JBRHdCN2dCLEtBQ2E7YUFJbkNxdkQsYUFBYXh1QyxNQUFNbGxCO01BQTBCLHVCQUFoQ2tsQixNQUFnQyw0QkFBMUJsbEIsR0FBMkM7YUFHOUQyekQsZUFBZXp1QyxNQUFNaGhCO01BQTBCLHVCQUFoQ2doQixNQUFnQyxVQUExQmhoQixHQUE2QzthQUdsRTB2RCxjQUFjMXVDLE1BQU1yZjtNQUEwQix1QkFBaENxZixNQUFnQyxlQUExQnJmLEdBQTRDO2FBR2hFZ3VELGNBQWMzdUMsTUFBTWplLEdBQ0YsbUJBREppZSxRQUNJLFNBREVqZSxHQUNlO2FBSW5DNnNELGFBQWE1dUMsYUFBVyx1QkFBWEEsVUFBMEM7YUFDdkQ2dUMsYUFBYTd1QyxNQUFNa3RCO01BQVMsdUJBQWZsdEIsTUFBTWt0QixTQUE2QzthQUVoRTRoQixjQUFjOXVDLE1BQU1rdEI7TUFBUyx1QkFBZmx0QixNQUFNa3RCLFNBQThDO2FBQ2xFNmhCLGVBQWUvdUMsTUFBTWt0QjtNQUFTLHVCQUFmbHRCLE1BQU1rdEIsU0FBK0M7YUFDcEU4aEIsWUFBWWh2QyxNQUFNa3RCLFFBQVMsdUJBQWZsdEIsTUFBTWt0QixTQUE0QzthQVc5RCtoQixpQkFBaUJqdkM7TUFDbkIsZUFEbUJBLFNBQ25CLGtCQURtQkEsWUFDNkI7YUFDOUNrdkMsZUFBZWx2QztNQUNqQixlQURpQkEsU0FDakIsa0JBRGlCQSxZQUNnQzthQUkvQ212QyxpQkFBaUJudkM7TUFDbkIsU0FEbUJBO01BQ25CLFlBQ0UsZ0JBRmlCQSxTQTZDYm11QixlQTNDc0U7YUFJMUVpaEIsb0JBQW9CcHZDO01BQ3RCLFNBRHNCQTtNQUN0QixZQUNFLGdCQUZvQkEsU0F1Q2hCbXVCLGVBcENxRDthQUt6RGtoQixzQkFBc0JydkMsTUFBT3VyQyxLQUFNRDtNQUNyQzthQUQrQkM7T0FDL0IsTUFEK0JBO09BQy9CLE9BRCtCQTtPQUMvQixLQUR3QnZyQztNQUN4QjtRQUVFO2dCQUhzQkE7U0FJbEJrcUMsU0FKeUJxQixLQUFNRDtTQUsvQjE5QztpQ0FKRjZyQixVQUFRdEQ7O2dDQUFPcUQ7OztTQUtidXpCLFFBSEE1ZSxLQUNBK2IsTUFDQXQ4QztlQW5NSmsvQyxVQThMc0I5c0MsUUFNbEIrc0M7aUJBQ3FCO2FBTXpCdUMsZUFBZXR2QyxNQUFNbVcsTUFBTTNEO01BQzdCO2VBRGlCeFMsZ0JBQU1tVyx3QkFBTTNELGVBRW1CO2FBUTlDKzhCLGVBQWV2dkMsYUFBVyxzQkFBWEEsVUFBbUM7YUFDbER3dkMsYUFBYXh2QyxhQUFXLHNCQUFYQSxVQUFtQzthQUloRHl2QyxhQUFhenZDO01BQ2YsWUFEZUE7TUFDZixTQURlQTtNQUNmO1FBRUUsSUFDSStzQyxRQURBNWUsc0JBQUosdUJBSGFudUIsTUFJVCtzQztpQkFDc0I7YUFJMUIyQyxjQUFjMXZDO01BQ2hCLGFBRGdCQTtNQUNoQjtRQUNBLFNBRmdCQTtRQUVoQjtVQUVHLElBQUkrc0MsUUFWRDVlO1VBV0gsZ0JBTGFudUIsTUFJVCtzQztVQUNKLFlBTGEvc0M7VUFJYjs7Ozs7aUJBR0E7YUFJRDJ2QyxnQkFBZ0IzdkMsTUFBTW1XLE1BQU0zRDtNQUM5QixTQURrQnhTO01BQ2xCO1FBQ0UsV0FGZ0JBLGNBR1orc0MsUUFEQTVlLFFBRmtCaFksTUFBTTNELFFBQU4yRDtlQTlPdEIyMkIsVUE4T2dCOXNDLFFBR1orc0M7aUJBQ3FCO2FBR3pCNkMsYUFBYTV2QyxhQUFXLHVCQUFYQSxVQUFvQzthQUVqRDZ2QyxXQUFXN3ZDO01BQ2IsU0FEYUE7TUFDYixTQUNFLElBQUkrc0MsUUE1QkE1ZSxVQTRCSix1QkFGV251QixNQUVQK3NDO2lCQUNzQjthQVUxQitDLGlCQUFpQjl2QyxNQUFNdmY7TUFBSSxhQUFKQSxNQUFJLFdBQVZ1ZixZQUFNdmYscUJBQXlDO2FBR2hFc3ZELGlCQUFpQi92QyxhQUFXLE9BQVhBLFNBQTZCO2FBRTlDZ3dDLGtCQUFrQmh3QztNQUFXLE9BQVhBLDJCQUFtRDthQUdyRWl3QyxxQkFBcUJqd0MsTUFBTTdnQixHQUFJLFlBQUpBLEVBQUksUUFBc0I7YUFDckQrd0QscUJBQXFCbHdDLGFBQVcsT0FBWEEsU0FBNEI7YUFJakRtd0MsU0FBUzF2RCxHQUNYLE9BRFdBLDJCQUNvQzthQWU3QzJ2RCxrQkFBa0Jwd0MsTUFBTS9SO01BQzFCLGFBRDBCQTtNQUMxQjtRQUNFLFFBRmtCK1IsV0FBTS9SLFFBVjFCLFVBRDhCRTtRQUM5QjtVQUNVLElBQUoxTixFQUFJLFNBRm9CME47VUFFcEIsV0FBSjFOO1VBQUksV0FTVXVmO1VBVFYsZ0JBU1VBO1FBZnBCO2lCQWlCbUQ7YUFHakRxd0Msa0JBQWtCcndDLGFBQVcsT0FBWEEsUUFBOEI7YUFFaERzd0MsY0FBY3R3QyxNQUFNdmY7TUFDdEIsY0FEc0JBO01BQ3RCO1FBQ1UsSUFBSndOLElBQUksU0FGWXhOO1FBRVosV0FBSndOO1FBQUk7U0FFSnNpRDtVQUpVdndDOztZQVdYLElBQUksSUFYT0E7UUFZc0IseUJBWnRCQSxNQUlWdXdDO2lCQVVrQzthQU10Q0M7VUFBbUJDLGdCQUFRQzs2QkFBUkQsVUFBUUM7YUFPM0JDLGVBQWVDO01BQ1gsNEJBRFdBLFVBQ1gseUJBRVk7YUFFaEJDLGNBQWM3d0MsYUFBVyxPQUFYQSxRQUEwQjthQUV4Qzh3QyxxQkFBcUI5d0M7VUFBT3l3QyxnQkFBUUM7TUFDdEMsY0FEdUIxd0MsTUFBT3l3QztNQUU5QixrQkFGdUJ6d0MsTUFBZTB3QztNQUV0QzthQUdFSyxnQkFBZ0Ivd0MsTUFBTzB3QyxXQUFZRDtNQUNyQyxnQkFEeUJDLFdBQVlELFFBRS9CLHdCQURGRztNQUNFLGtCQUlKLDRCQU5nQjV3QyxNQUNkNHdDO01BQUosSUFFUW43QztNQUNrQiw0REFEbEJBLEtBRzZCO2FBRW5DdTdDLHFCQUFxQmh4QyxNQUFPMHdDLFdBQVlEO01BQzFDLGdCQUQ4QkMsV0FBWUQsUUFFcEMsd0JBREZHO01BQ0Usc0JBSUoscUJBTnFCNXdDLE1BQ25CNHdDLFdBS2lDO2FBRW5DSyxnQkFBZ0JqeEMsYUFDOEIsVUFEOUJBLGtCQUMwRDthQUUxRWt4QyxtQkFBbUJseEMsTUFBTWdMO01BQ1osSUFBWDRsQyxTQUFXLGdCQURNNXdDO01BRU0sNEJBRk5BLE1BRU0sV0FGQWdMLE9BQ3ZCNGxDLFVBQ3dDO2FBRzFDTywrQkFBK0JueEM7VUFLaEJsTyxXQURBaFgsV0FEQ2lnQixXQURGaFYsV0FEQy9HO01BRGdCZ2hCLFlBQ2hCaGhCO01BRGdCZ2hCLFlBRWpCamE7TUFGaUJpYSxZQUdmakY7TUFIZWlGLFlBSWhCbGxCO01BSmdCa2xCLFlBS2hCbE87O2FBUWZzL0MsK0JBQStCcHhDO01BQVcsVUFBWEEsa0RBTWxDO2FBSUdxeEMsK0JBQWtDcnhDLE1BQU1oaEIsRUFBRStHO01BQzVDLFlBRDBDL0csRUFDMUMsWUFENEMrRyxFQUM1QyxRQUFpRDthQUUvQ3VyRCwrQkFBa0N0eEM7TUFDcEMsVUFEb0NBLG9CQUNLO2FBSXZDdXhDLGdCQUFnQnZ4QztNQUFXLGtCQUFYQSxxQkFBd0M7SUFHM0MsSUFBYnd4QyxXQUFhO2FBV2JDLGVBVm1CenhDLE1BQU12ZjtNNUNoNEI5QixJNENnNEI4QndOO01BQzNCO3FCQUQyQkE7UUFDM0I7VUFDQSxRQUYyQkE7WUFJekIsV0FKbUIrUixVQURuQnd4QztZQUtBLFFBSnlCdmpEOztVQUVYLGtCQUZLK1IsVUFEbkJ3eEMsYUFDeUJ2akQ7b0JBTXhCO0lBUFksU0FlYnlqRCw2QkFBNkIxeEMsTUFBTTFkO01BQ2Q7OytCNUMvNEIxQixPVXFNS0ssaUJrQ3lzQm1DTDtNQUNkLDRCQUNVLHFCQUZJQSxHQUVJO01BQ2pCLDJCNUNqNUIzQixPNEM0M0JLaXZELGdCQWtCNkJ2eEM7TUFJUiwyQjVDbDVCMUIsTzRDMDRCS3l4QyxlQUk2Qnp4QztNQUtSLDJCNUNuNUIxQixPNEMwNEJLeXhDLGVBSTZCenhDO01BS1IsUUFBb0I7SUFwQjVCLFNBNEJiMnhDO01BQTJCO1lBQ2hCeHlELFdBQVcsNEJBQVhBO01BQ04sYUFBRTtJQTlCTSxTQStCYnl5RDtNQUE0QjtZQUNqQnp5RCxXQUFZLDRCQUFaQTtNQUNOLGFBQUU7SUFqQ00sU0FtQ2IweUQsZ0M1Q2w2Qkw7STRDKzNCa0IsU0FvQ2JDLGlDNUNuNkJMO0k0QyszQmtCLFNBd0NiQyxrQkFBa0IveUQsRUFBRStHLEVBQUVnVixFQUFFamdCLEVBQUVnWDtNQUViLG9DQWg0QlhrNEM7TUFtNEJKLElBRklpSSxRQURBRDtNQUFXLElBSVhFLFdBQWE7TUFDakIsc0JBRElBO01BRUosVUFMSUQsU0FHQUM7TUFKVyxJQWNHLGlCQURELGlCQURDO01BREU7Y0FQaEJBO2NBT2dCOzs7Ozs7Ozs7Ozs7O2NoQy8zQmhCanlEOztjZ0NrM0JnQmpCO2NBQUUrRztjQUFFZ1Y7Y0FBRWpnQjtjQUFFZ1g7OztjQVoxQjYvQztjQUdBQztjQUlBQztjQUNBQztjQU1FRSxTQXNDSDtJQWhGYyxTQW9GYkcsMkJBQTJCQztNQUM3QjtlQUQ2QkEsNERBTVI7SUExRk4sU0ErRmJDLGVBQWU3dkQsT0FBTzRFO01BQ3hCLG9CNUMvOUJIO000Qys5Qkcsb0I1Qy85Qkg7TTRDKzlCYTtPQUFOa3JEO1FBQU0sa0JBRE85dkQsT0FBTzRFLHFCNUM5OUIzQjtNNENnK0J5Qix5QjVDaCtCekIsTzRDNDNCS21xRCxnQkFtR0VlO01BRWlCLHlCNUNqK0J4QixPNEMwNEJLYixlQXFGRWE7TUFHaUIseUI1Q2wrQnhCLE80QzA0QktiLGVBcUZFYTtNQUdpQixPQUhqQkEsR0FJRDtJQXBHWSxTQXdHYkMseUJBQXlCandEO01BQzNCLHFCQUFnRCxxQkFEckJBLEdBQzZCO01BQXpDOztpQjVDeCtCbEIsT1VxTUtLLGlCa0NreUJ5Qkw7b0JBQzhCO0lBekcxQyxTQTZHYmt3RCxvQkFBb0I3eEQ7TUFDdEIsb0I1QzcrQkg7TTRDNitCa0I7O2lCNUM3K0JsQixPbUN1Tks0eEIsY1NxeEJvQjV4QjtvQkFDd0I7SUE5Ry9CLElBb0hiOHhEO0lBcEhhLFNBcUhiQyxzQkFBb0IsZ0JBRHBCRCxlQUNnRDtJQUd2Qzs7S0FJTyx1Q2xDOTFCaEJoeEQ7S2tDKzFCZ0IsdUNsQzkxQmhCQztLa0MrMUJnQixrQ0FOaEJpeEQ7SUFNZ0IsU0FPaEJJLHVCQUF1Qi91RCxJQUFJc3VEO01BQzdCLGVBRDZCQSxPQUVyQixJQUFKbnpELEVBQUksU0FGaUI2RSxLQUd6QixNQUh5QkEsS0FHekIsT0FESTdFLENBRUg7SUFYaUIsU0FlaEI2ekQ7TUFBeUIsOEJBckJ6QkwsT0FNQUcsY0Flb0U7SUFmcEQsU0F5Q2hCRyxtQ0FDRixZQUFpQztJQTFDZixTQTRDaEJDLDZCQUE2QkMsS0FDL0IsbUJBQWtDO0lBN0NoQixTQStDaEJDLDJCQUEyQkQsS0FDN0IsV0FENkJBLE9BQ1E7SUFoRG5CLFNBa0RoQkUsNkJBQTZCRjtNQUNuQixJQUFSRyxNQUFRLDJCQURtQkg7TUFFL0IsNkJBRitCQTtNQUUvQixPQURJRyxLQUVDO0lBckRhLFNBdURoQkMseUJBQXlCSixJQUFJSztNQUMvQixZQUQrQkEsS0FBSkwsUUFDM0IsUUFBb0U7SUF4RGxELFNBMERoQk0sK0JBQW9DTjtNQVk5QixTQUFKbjBELEVBUG9CRyxFQUFFckUsRUFBRTJGLEdBQ2tCLGdDQU5SMHlELE9BTVEsTUFEdEJoMEQsRUFBRXJFLEVBQUUyRjtNQVFwQixTQUFKc0YsUUFYRixnQ0FGb0NvdEQ7TUFjOUIsU0FBSnA0QyxRQVZGLGdDQUpvQ280QztNQWU5QixTQUFKcjRELEVBUm9CMkYsR0FDdEIsZ0NBUm9DMHlELE9BT2QxeUQ7TUFTaEIsU0FBSnFSLEVBUG9CclIsR0FDdEIsZ0NBVm9DMHlELE9BU2QxeUQ7TUFPaEIseUJBSkp6QixFQUNBK0csRUFDQWdWLEVBQ0FqZ0IsRUFDQWdYLEVBQ3VCO0lBU2IsU0FBWjRoRCxnQjVDamxDTCxPNEMrb0JLOUUsYUE0V0FnRTtJQXVGWSxTQUFaZSxnQjVDbGxDTCxPNENncEJLOUUsYUEyV0ErRDtJQXdGYSxTQUFiZ0IsaUI1Q25sQ0wsTzRDa3BCSzlFLGNBeVdBOEQ7SUF5RmMsU0FBZGlCLGtCNUNwbENMLE80Q21wQks5RSxlQXdXQTZEO0lBMEZXLFNBQVhrQixlNUNybENMLE80Q29wQks5RSxZQXVXQTREO0lBMkZZLFNBQVptQixnQjVDdGxDTCxPNEM4Z0JLN0csYUE2ZUEwRjtJQTRGVyxTQUFYb0IsZTVDdmxDTCxPNENnakJLM0csWUEyY0F1RjtJQTZGWSxTQUFacUIsZ0I1Q3hsQ0wsTzRDaWpCSzNHLGFBMGNBc0Y7SUE4RlksU0FBWnNCLGdCNUN6bENMLE80QzJoQksvRyxhQWdlQXlGO0lBK0ZhLFNBQWJ1QixpQjVDMWxDTCxPNEN1aUJLL0csY0FvZEF3RjtJQWdHVyxTQUFYd0Isb0I1QzNsQ0wsTzRDd25CSy9GLFlBbVlBdUU7SUFpR2UsU0FBZnlCLHFCNUM1bENMLE80QzRuQks5RixnQkErWEFxRTtJQWtHWSxTQUFaMEIsa0I1QzdsQ0wsTzRDaW9CSzlGLGFBMFhBb0U7SUFtR2MsU0FBZDJCLG9CNUM5bENMLE80Q29vQks5RixlQXVYQW1FO0lBb0dhLFNBQWI0QixtQjVDL2xDTCxPNEMwb0JLN0YsY0FpWEFpRTtJQXFHYSxTQUFiNkIsaUI1Q2htQ0wsTzRDdW9CSy9GLGNBb1hBa0U7SUFzR2MsU0FBZDhCO001Q2ptQ0wsTzRDaXNCS3BGLGVBMFRBc0Q7SUF1R1ksU0FBWitCLGdCNUNsbUNMLE80QzRzQktuRixhQStTQW9EO0lBd0djLFNBQWRnQyxrQjVDbm1DTCxPNEMyc0JLckYsZUFnVEFxRDtJQXlHZ0IsU0FBaEJpQyxvQjVDcG1DTCxPNENzcUJLMUYsaUJBcVZBeUQ7SUEwR2MsU0FBZGtDLGtCNUNybUNMLE80Q2lxQks1RixlQTBWQTBEO0lBMkdnQixTQUFoQm1DO001Q3RtQ0wsTzRDK3BCSzlGLGlCQTRWQTJEO0lBNEdtQixTQUFuQm9DO001Q3ZtQ0wsTzRDNHFCSzVGLG9CQStVQXdEO0lBOEdZLFNBQVpxQyxnQjVDem1DTCxPNENndEJLeEYsYUEyU0FtRDtJQStHYSxTQUFic0MsaUI1QzFtQ0wsTzRDeXRCS3hGLGNBa1NBa0Q7SUFnSGUsU0FBZnVDO001QzNtQ0wsTzRDb3VCS3hGLGdCQXVSQWlEO0lBa0hVLFNBQVZ3QyxjNUM3bUNMLE80QzZ1Qkt2RixXQThRQStDO0lBbUhZLFNBQVp5QyxnQjVDOW1DTCxPNEMydUJLekYsYUFnUkFnRDtJQXFIYSxTQUFiMEMsaUI1Q2huQ0wsTzRDOHhCS2hGLGNBNk5Bc0M7SUFzSGEsU0FBYjJDLGlCNUNqbkNMLE80QzIvQkszQztJQXdIaUIsU0FBakI0QztNNUNubkNMLE80Q3V4QktwRixrQkFvT0F3QztJQXlIaUIsU0FBakI2QyxxQjVDcG5DTCxPNEMyL0JLN0M7SUEySGUsU0FBZjhDO001Q3RuQ0wsTzRDcTBCSzNFLGdCQXNMQTZCO0lBNEhvQixTQUFwQitDO001Q3ZuQ0wsTzRDNjBCSzNFLHFCQThLQTRCO0lBNkhlLFNBQWZnRCxtQjVDeG5DTCxPNENxMUJLM0UsZ0JBc0tBMkI7SUE4SGtCLFNBQWxCaUQ7TTVDem5DTCxPNEN3MUJLM0UsbUJBbUtBMEI7SUFnSWdCLFNBQWhCa0Qsb0I1QzNuQ0wsTzRDMHZCS2hHLGlCQWlRQThDO0lBaUlnQixTQUFoQm1ELG9CNUM1bkNMLE80QzIvQktuRDtJQWtJaUIsU0FBakJvRDtNNUM3bkNMLE80Qyt2QktoRyxrQkE0UEE0QztJQW9Jb0IsU0FBcEJxRDtNNUMvbkNMLE80Q2t3QktoRyxxQkF5UEEyQztJQXFJb0IsU0FBcEJzRCx3QjVDaG9DTCxPNEMyL0JLdEQ7SUF3SUYsU0FERXVEO001Q2xvQ0wsTzRDODRCS3pFLDZCQTZHQWtCO0lBMklGLFNBREV3RDtNNUNyb0NMLE80QzYxQktqRiwrQkE4SkF5QjtJQTZJRixTQURFeUQ7TTVDdm9DTCxPNEMwMkJLakYsK0JBaUpBd0I7SUFnSkYsU0FERTBEO001QzFvQ0wsTzRDbzNCS2pGLCtCQXVJQXVCO0lBa0pGLFNBREUyRDtNNUM1b0NMLE80Q3UzQktqRiwrQkFvSUFzQjtJQXFKRixTQURFNEQ7TTVDL29DTCxPNENva0JLM0ksK0JBdWJBK0U7SUF1SkYsU0FERTZEO001Q2pwQ0wsTzRDNGpCSzdJLCtCQStiQWdGO0lBeUpGLFNBREU4RDtNNUNucENMLE80Q21qQktuSixrQkF3Y0FxRjtJQTJKRixTQURFK0QscUI1Q3JwQ0wsTzRDMi9CSy9EO0lBNkpGLFNBREVnRSxvQjVDdnBDTCxPNENvakJLcEosaUJBdWNBb0Y7SUErSkYsU0FERWlFLG9CNUN6cENMLE80QzIvQktqRTtJQWlLRixTQURFa0UsZTVDM3BDTCxPNEN1akJLbkosWUFvY0FpRjtJQWlLRixTQU1NbUUsY0FBZ0I1MkMsSUFBdUI2MkMsS0FBSzFFO1VBQTVCMkU7O2lCQUFTLFFBQVRBLGdCQUFTNzJDLGFBQVQ4MkMsT0F0ZHBCMUg7UUFzZHNEOzs7Z0JBR2pEMkg7WUFDTCxXQUoyQ0gsS0FBSzFFO1lBS2hELFdBTG9CNEUsT0FBNEI1RTtZQUtoRCxhQUxvQjRFLDRCQUdmQzs7VUFERSxrQkFGb0NILEtBQUsxRTtRQUMxQztJQVBSLFNBZUUrRSxjQUFjL0UsSUFBSW56RDtNQUNwQiw4QkFEb0JBLEdBQ3BCO2VBR0lpSTtRQUNGLGdCQUxja3JELElBS00sTUFMRm56RCxFQUVoQmdTLFFBQ0FDLFdBREFEO1FBR0Y7a0JBRkVDO1FBRUYsUUFDMkI7O1dBSHpCQSxhQUZBMU87VUFRSSwwQkFUWXZELEVBR2hCaVM7VUFNSTtZQUVGLFNBQ0EsaUJBWlVraEQ7OzRCQWNWLFNBQVUsZUFkQUEsWUFpQkw7O1FBRVgsU0FqQkluaEQsWUFEQXpPO1FBa0JKLFlBQXFCLGNBQVE7SUFsQzdCLFNBb0NFNDBELGdCQUFrQm4zQyxJQUF1QjYyQyxLQUFLMUU7TTVDaHNDbkQsRzRDZ3NDdUJueUM7T0FBTyxRQUFQQSxZQUFPQzs7V0FBUHZYLDBCQUFtQixRQUFFO01BQWQsVUFFakIsSUFBTC9GLFdBQUssa0JBRmlDazBELEtBQUsxRSxJQUUzQ3h2RDtNQURHLGtCQURZK0YsS0FBNEJ5cEQ7SUFwQ2hELFNBd0NFaUYsZ0JBQWlCbHRELEdBQUlDLE1BQU1nb0Q7TTVDcHNDaEMsbUI0Q3FzQ1csSUFBTHh2RCxXQUFLLGtCQURXdUgsR0FBVWlvRCxJQUMxQnh2RDtNQUNRLElBQUx5SDtNQUFLLGtCQUZZRCxNQUFNZ29ELElBRXZCL25EO0lBMUNOLFNBOENFaXRELFlBQVloMUQsT0FBT2kxRDtNQUNYLHFCQUNBLHdCQUROenpEO01BRUosV0FIY3hCLE9BRVY4dkQsSUFGaUJtRjtNQUlyQixlQUZJbkY7TUFETSxJQUlONXZELElBSkFzQjtNQUlNLFlBQU50QixJQUVDLE1BTkRzQixNQUlBdEIsYUFDWSxTQUxac0IsSUFNMkI7SUFyRC9CLFNBa0VFMHpELHNCQUFzQnBGLElBQUluMEQ7TUFBYSxVQUFiQTtPQUFhLE9BQWJBO2dCQUNHLG9CQURQbTBEO2dCQUVPLG9CQUZQQTtnQkFJTyxzQkFKUEE7Z0JBS08sd0JBTFBBO2dCQU1PLHdCQU5QQTtnQkFRTyxxQkFSUEE7aUJBU08scUJBVFBBOztPQUFpQixPQUFibjBEOztjQUdUcTBCLE9BSFNyMEIsY0FHaEJnNEIsTUFIZ0JoNEI7aUJBN2hCMUJteEQsZUE2aEJzQmdELElBR1puOEIsTUFBTzNEO2dCQUlZOztjQUdsQnp3QixFQVZlNUQ7VUFVRyxjQVZQbTBEO1VBVU8scUJBVlBBLElBVVh2d0QsR0FBNEQ7SUE1RXpFLFNBa0ZNNDFELGFBQVdyRixJQUFJL3BEO001Qzl1Q3hCO000Qzh1QzhCLFVBQU5BO09BMEJTOztPQTFCSCxPQUFOQTs7Y0FTSXZKLEVBVEp1SixPQVNDMEcsRUFURDFHO1VBVW5CLGFBVmUrcEQsSUFTS3JqRDtVQUNwQiw2QkFWZXFqRCxJQVNRdHpEOzttQkFUSnVKOztZQWFuQixJQURvQ0M7WUFDcEMsYUFiZThwRDtZQWNjO3FCQWRkQSxrQkFjYyxZQWR6QnFGLGFBWWdDbnZEO2NBR0FDO1VBQ3BDLGFBaEJlNnBEO1VBaUJLO29DQUFtQixZQWpCbkNxRixhQWVnQ2x2RDtXQUVoQjs7aUNBakJMNnBELElBaUJWcGxCLE9BQVEwcUI7O21CQWpCTXJ2RDs7OztrQkFDK0MwRCxJQUQvQzFELE9BQ3VDNGxDLGFBQWxCeEQ7Ozs2QkFrQmpCeHJDLEVBbkJKb0osT0FtQkNtaUM7OzttQkFuQkRuaUM7Ozs7a0JBSzZDZ0ksSUFMN0NoSSxPQUtxQ3VpRCxlQUFsQjNlOzs7OzZCQWdCakJwcUMsRUFyQkZ3RyxPQXFCRDJqQzs7O21CQXJCQzNqQzs7OztrQkFDK0MwRCxJQUQvQzFELE9BQ3VDNGxDLGFBQWxCeEQ7Ozs2QkFrQmpCeHJDLEVBbkJKb0osT0FtQkNtaUM7OzttQkFuQkRuaUM7Ozs7OztrQkFLNkNnSSxJQUw3Q2hJLE9BS3FDdWlELGVBQWxCM2U7Ozs7MkJBZ0JqQnBxQyxFQXJCRndHLE9BcUJEMmpDOzs7Y0FFSnNNLElBdkJLandDLE9BdUJSNmpDLElBdkJRN2pDO1VBdUJTLGFBdkJiK3BELElBdUJKbG1CO1VBQWlCLGtCQUFkb00sSUF2QkM4Wjs7Y0F3Qkx1RixJQXhCU3R2RCxPQXdCUyxhQXhCYitwRCxJQXdCTHVGLEtBQWtCLHNCQXhCYnZGOztjQXlCSzc4QyxJQXpCRGxOLE9BeUJGdXZELElBekJFdnZEO1VBeUJTLGFBekJiK3BELElBeUJFd0Y7VUFBVyxtQkFBUnJpRDtNcEN2dkJoQjtlb0NpdUJKLGFBSGU2OEMsSUFDeUIzbkIsWUE1bkJ4Q3lqQixpQkEybkJla0UsSUFDMkNua0IsS0FBUWxpQzs7U0FNbEUsYUFQZXFtRCxJQUt1Qm5tQjtnQkFob0J0Q2lpQixpQkEybkJla0UsSUFLeUN4SCxPQUdoQixTQUh3QnY2QztlQWVwQyxhQXBCYitoRCxJQW1CSzVuQixLQUNRLHVCQXBCYjRuQixJQW1CUW56RDtnQkFHSyxhQXRCYm16RCxJQXFCR3BtQixLQUNVLHFCQXRCYm9tQixJQXFCTXZ3RCxHQUtTO0lBNUdoQyxTQWtITWcyRCxhQUFXekYsSUFBSS9wRDtNNUM5d0N4QjtNNEM4d0M4QixVQUFOQTtPQTZCUzs7T0E3QkgsT0FBTkE7O2NBWUl2SixFQVpKdUosT0FZQzBHLEVBWkQxRztVQWFuQixhQWJlK3BELElBWUtyakQ7VUFDcEIsNkJBYmVxakQsSUFZUXR6RDs7bUJBWkp1Sjs7WUFnQm5CLElBRG9DQztZQUNwQyxhQWhCZThwRDtZQWlCYztxQkFqQmRBLGtCQWlCYyxZQWpCekJ5RixhQWVnQ3Z2RDtjQUdBQztVQUNwQyxhQW5CZTZwRDtVQW9CSztvQ0FBbUIsWUFwQm5DeUYsYUFrQmdDdHZEO1dBRWhCOztpQ0FwQkw2cEQsSUFvQlZwbEIsT0FBUTBxQjs7bUJBcEJNcnZEOzs7O2tCQUMrQzBELElBRC9DMUQsT0FDdUM0bEMsYUFBbEJ4RDs7OzZCQXFCakJ4ckMsRUF0QkpvSixPQXNCQ21pQzs7O21CQXRCRG5pQzs7OztrQkFLNkNnSSxJQUw3Q2hJLE9BS3FDdWlELGVBQWxCM2U7Ozs7NkJBbUJqQnBxQyxFQXhCRndHLE9Bd0JEMmpDOzs7bUJBeEJDM2pDOzs7O2tCQUMrQzBELElBRC9DMUQsT0FDdUM0bEMsYUFBbEJ4RDs7OzZCQXFCakJ4ckMsRUF0QkpvSixPQXNCQ21pQzs7O21CQXRCRG5pQzs7Ozs7O2tCQUs2Q2dJLElBTDdDaEksT0FLcUN1aUQsZUFBbEIzZTs7OzsyQkFtQmpCcHFDLEVBeEJGd0csT0F3QkQyakM7OzttQkF4QkMzakM7Ozs7a0JBU3NDa3dDLElBVHRDbHdDLE9BUzhCeWlELGVBQWxCNWU7Y0FDL0IsYUFWZWttQixJQVNnQmxtQjtxQkFwcUIvQmdpQixpQkEycEJla0UsSUFTa0N0SCxPQUVULFdBRmlCdlM7Y0FpQjNDRCxJQTFCS2p3QztVQTBCUyxhQTFCYitwRDtVQTBCbUQsdUJBMUJuREEsSUEwQm1ELFdBQXBEOVo7O2NBQ0pxZixJQTNCU3R2RCxPQTJCUyxhQTNCYitwRCxJQTJCTHVGLEtBQWtCLHNCQTNCYnZGOztjQTRCSzc4QyxJQTVCRGxOLE9BNEJGdXZELElBNUJFdnZEO1VBNEJTLGFBNUJiK3BELElBNEJFd0Y7VUFBVyxtQkFBUnJpRDtNcEMxeEJoQjtlb0Npd0JKLGFBSGU2OEMsSUFDeUIzbkIsWUE1cEJ4Q3lqQixpQkEycEJla0UsSUFDMkNua0IsS0FBUWxpQzs7U0FNbEUsYUFQZXFtRCxJQUt1Qm5tQjtnQkFocUJ0Q2lpQixpQkEycEJla0UsSUFLeUN4SCxPQUdoQixTQUh3QnY2QztlQWtCcEMsYUF2QmIraEQsSUFzQks1bkIsS0FDUSx1QkF2QmI0bkIsSUFzQlFuekQ7Z0JBR0ssYUF6QmJtekQsSUF3QkdwbUIsS0FDVSxxQkF6QmJvbUIsSUF3Qk12d0QsR0FLUztJQS9JaEMsU0F1SkVpMkQsV0FBUzNzQyxFQUFFaW5DO1VBQWFqOEI7YXhDd0xwQmtVO3dCd0N0TENoaUMsS0FBTyxhQUZEK3BELElBRU4vcEQsS0FBTyxrQkFGSDhpQixFQUFFaW5DLElBRTBCOztlQUZiajhCO0lBdkoxQixTQTRKRTRoQyxZQUFVNXNDLEVBQUVpbkM7TTVDeHpDakIsSTRDd3pDOEJqOEIsb0J4Q2tjckJxVixhd0NsY01yZ0IsRUFBRWluQyxJQUFhajhCO0lBNUozQixTQStKRTZoQyxXQUFTNUY7VUFBY2o4QjtheEMrYm5CcVYsNEJKMXZEVCxlNEMyekM0QnJWO0lBL0p6QixTQWtLRThoQyxVQUFRN0Y7TUFBTSxvQjVDOXpDbkI7TTRDOHpDbUIsc0I1Qzl6Q25CLE80Q216Q0swRixnQkFXUTFGLFVBQXlCO0lBbEtuQyxTQW1LRThGLFNBQU8vaEMsS0FBTSw0QkFwVWJ1OEIsZUFvVU92OEIsSUFBK0I7SUFuS3hDLFNBb0tFZ2lDLFVBQVFoaUMsS0FBTSw0QkFwVWR3OEIsZUFvVVF4OEIsSUFBK0I7SUFwS3pDLFNBc0tFaWlDLFNBQVNqdEM7VUFBV2dMO2F4Q3lLaEJrVTt3QndDdktDaGlDO2lCQUFPOzBCQUZIOGlCLFdBRVVpbkMsS0FBTyxvQkFBUEEsSUFBZC9wRCxJQUF1QyxFQUFDOztlQUZ6Qjh0QjtJQXRLdEIsU0EyS0VraUMsUUFBUWxpQyxLQUFNLHlCQUFjdjdCLEdBQUssT0FBTEEsQ0FBTSxFQUExQnU3QixJQUErQjtJQTNLekMsU0FzUEVtaUMsUUF6RVNudEM7TUFDSCxJQURjZ0wsYUFDZCxvQkFDRSx3QkFETjExQjtNQUNNLFNBQ053ekIsSUFBRTVyQjtRQUNKLGFBRkUrcEQsSUFDRS9wRDtRQUVGLGtCQUxPOGlCLEVBS1AsdUJBSkExcUIsRUFDQTJ4RCxLQUc4QjtNQUh4QixtQkFDTm4rQixNQUhrQmtDO0lBN0t0QixTQXNMRW9pQyxVQUFRcGlDLEtBQU0sZUEzekNkMHpCLEtBMnpDUTF6QixJQUFxQjtJQXRML0IsU0F3TEVxaUMsVUFBVXJ0QztNQUNKLElBRGVnTCxhQUNmLG9CQUNFLHdCQUROMTFCO01BQ00sU0FDTnd6QixJQUFFNXJCO1FBQ0osYUFGRStwRCxJQUNFL3BEO1FBRUYsa0JBTFE4aUIsRUFLUix1QkFKQTFxQixFQUNBMnhELEtBRzhCO01BSHhCLG1CQUNObitCLE1BSG1Ca0M7SUF4THZCLFNBaU1Fc2lDLFNBQVN0aUMsS0FBTSxpQkF0MENmMHpCLEtBczBDUzF6QixJQUFzQjtJQWpNakMsU0FxTUV1aUM7TUFDRixlQXZXRWhHLGlCQXVXRixzQkF0V0VDLGdCQXVXNkI7SUFFeEIsUUFKTCtGO0lBSUssU0FTTEMsK0JBQXNDNzRDLE1BQ2pDaGhCLEVBQVMrRyxFQUFXZ1YsRUFBVWpnQjtNQUNyQywrQkFGd0NrbEIsTUFDakNoaEIsRUFBUytHO01BQ2hCLFlBRDJCZ1Y7TUFDM0IsWUFEcUNqZ0I7TUFDckMsUUFFd0I7SUFiakIsU0FnQkxnK0QsK0JBQXNDOTRDO01BQ3hDLFVBRHdDQSx3Q0FFRztJQUszQyxTQURFKzRDO001QzMzQ0wsTzRDODJDS0YsK0JBblhBakc7SUFzWUYsU0FERW9HO001Q2g0Q0wsTzRDcTNDS0YsK0JBMVhBbEc7SUFzWUYsU0FVRXFHLFVBQVF0NEQ7TUFDQSxJQURXMDFCLGFBQ1gsd0JBREExMUI7TUFDQSxTQUNOMHFCLEVBQUU5aUIsS0FBTSxhQURSK3BELElBQ0UvcEQsS0FBTSxzQkFEUitwRCxNQUNvRDtNQUQ5QyxtQkFDTmpuQyxJQUZpQmdMO0lBVnJCLFNBK0JFNmlDLCtCQUErQmw1QztVQUlaOHRDLGFBRERDLGFBREFDLGFBRERDO2VBS2ZrTCxVQUFVbjZELEVBQUV1TDtRNUN0NkNuQiw0QjRDczZDZ0QsSUFBTHBMLFdBQUssa0JBQS9CSCxFQUEwQkc7UUFBZ0IsT0FBeENvTDtNQUNVLDJCNUN2NkM3QixPNENzNkNPNHVELFVBTGVsTDtNQU9RLDJCNUN4NkM5QixPNENzNkNPa0wsVUFKZ0JuTDtNQU1PO01BQ0EsMkI1Q3o2QzlCLE80Q3M2Q09tTCxVQUhnQnBMO01BS087TUFFQywyQjVDMTZDL0IsTzRDczZDT29MLFVBRmlCckw7TUFNTztJQXpDNUIsU0EyQ0VzTCwrQkFBK0IvaUM7TUFDdEIsSUFBUGdqQyxLQUFPLCtCQURzQmhqQztNQUN0QixTQUNQaWpDLGNBQWNuNkQsR0FBSSxrQkFEbEJrNkQsc0JBQ2NsNkQsR0FBc0M7TUFEN0MsU0FFUG82RCxlQUFlcDZELEdBQUksa0JBRm5CazZELHNCQUVlbDZELEdBQXVDO01BRi9DLFNBR1BxNkQsZUFBZXI2RCxHQUFJLGtCQUhuQms2RCxzQkFHZWw2RCxHQUF1QztNQUgvQyxTQUlQczZELGdCQUFnQnQ2RCxHQUFJLGtCQUpwQms2RCxzQkFJZ0JsNkQsR0FBd0M7TUFKakQsVUFDUG02RCxjQUNBQyxlQUNBQyxlQUNBQyxnQkFDNEQ7SUFHaEUsU0FERUM7TTVDcDdDTCxPNENnNkNLUiwrQkFyYUF0RztJQTRiRixTQURFK0c7TTVDdDdDTCxPNEM0NkNLUCwrQkFqYkF4RztJQTRiRjs7O09BbnlCRTVEO09BaWNBOEU7T0F2a0JBNUc7T0F3a0JBNkc7T0F2Y0FuRjtPQWtjQThFO09BamNBN0U7T0FrY0E4RTtPQWhjQTdFO09BaWNBOEU7T0FoY0E3RTtPQWljQThFO09BeGRBdEY7T0FnZUE4RjtPQXBlQWhHO09BbWVBK0Y7T0ExZEE1RjtPQTRkQThGO09BemRBN0Y7T0EwZEE4RjtPQXBkQTVGO09BcWRBNkY7T0F4ZEE5RjtPQXlkQStGO09BclpBbEY7T0F3WkFxRjtPQXZaQXBGO09Bc1pBbUY7T0FqYUFyRjtPQWdhQW9GO09BN2FBckY7T0FkQUY7T0E4YkEwRjtPQXhiQXpGO09BMmJBNEY7T0F0Y0E5RjtPQW9jQTRGO09BdGNBN0Y7T0F1Y0E4RjtPQXhVQXpFO09Ba1ZBZ0Y7T0FsVEF6RTtPQW1UQTBFO09BMVZBbkY7T0E0VkFvRjtPQXZWQW5GO09Bd1ZBb0Y7T0EzVEE5RTtPQVlBSTtPQWlUQTJFO09BelNBMUU7T0EwU0EyRTtPQS9SQXpFO09BaVNBMkU7T0FwU0E1RTtPQW1TQTJFO09BOVhBOUY7T0FpWUFnRztPQTlYQS9GO09BK1hBZ0c7T0E3WEEvRjtPQThYQWdHO09BN2FBdkc7T0F5WkF3RjtPQWhaQXZGO09BaVpBd0Y7T0E3WEFyRjtPQWdZQXVGO09BbFlBeEY7T0FtWUF5RjtPQTFZQTFGO09BdVlBd0Y7T0F6V0FsRjtPQTZYQWdHO09BNVhBL0Y7T0E2WEFnRzs7T0FybUJBL0k7T0E4akJBK0c7T0FsakJBOUc7T0FtakJBK0c7T0FuaUJBeEc7T0FvbUJBbUo7T0F4bUJBdko7T0FnbUJBbUo7T0EvbEJBbEo7T0FtbUJBb0o7T0FsbUJBbko7T0FnbUJBa0o7T0EvbEJBako7T0FtbUJBbUo7T0EzUUFuRjtPQW9QQXlFO09BOVFBOUU7T0FzUkFpRjtPQW5SQWhGO09BcVJBaUY7T0EvU0FwRjtPQXdTQWlGO09BM1JBaEY7T0E2UkFpRjtPQW5rQkF4STtPQTJrQkEySTtPQW5sQkE1STtPQXFsQkE2STtPQTFLQWxFO09Bb0JBSztPQUNBQztPQWhCQUw7T0FXQUc7T0FNQUc7T0FlQUU7T0E5Q0FYO09BWEFGO09BbUZBYztPQUdBQztPQUdBRTtPQUdBQztPQUtBRTtPQUdBRTtPQTJHSXNEO09BU0pNO09BcUJBQztPQUlBQztPQTBIQVk7T0FDQUM7T0FDQUM7T0FrQkFJO09BV0FFO09BdEJBSjtPQVpBTDtPQVJBRjtPQWVBTTtPQVZBTDtPQTBGQU87T0E5REFFO09BdURBTztPQU9BVDtPQXZCQU87T0FLQUM7T0FsQkFIO09BT0FDO09BcjBCQXpMO09BdWlCQTJHO09BdGlCQTFHO09BdWlCQTJHO09Bd1VBaUY7T0FvQkFRO09BUkFOO09BVUFPO0lBQ0Y7UUNoeENJQzthQUtBQyxVQUFVQztNQUNaO1FBQ1UsSUFBSi8zRCxFQUFJLFdBRkUrM0Q7UUFFRixRQUFKLzNEO1FBQUk7Z0JBRkUrM0Q7UUFFRixVQUFKLzNELEVBSWEsUUFOUCszRDtlQUVOLzNEOzs7O1VBT0osUUFkQTYzRCxVQWNBLDJCQWRBQTttQkFrQkM7YUFHREcsVUFBVUQsSUFDWixPQURZQSxZQUdQLFVBSE9BLEdBR0s7YUFRZkUsa0JBQWtCRjtNQUNaLElBQUovM0QsRUFBSSxVQURZKzNELElBQ1osR0FEWUEsTUFFRixrQkFDbEIsT0FGSS8zRCxDQUVIO2FBR0NrNEQsYUFBYUgsSUFDUixVQURRQSxJQUNSLE9BRFFBLEtBRU47YUFLUEksbUJBQW1CSixJQUFLLGFBQUxBLFNBQXlCO2FBRTVDSyxjQUFjTDtNQUNoQixTQURnQkE7TUFDaEI7Ozt5QkFDc0I7UUFDTSxJQUFmOTRDO1FBQWUsT0FBZkEsTUFFOEI7YUFHekNvNUMsV0FBV04sSUFDYixPQURhQSx5QkFHUTthQUtuQk8sWUFBWVAsSUFBSyxhQUFMQSxNQUFvQzthQUVoRFEsd0JBQXdCUixJQUFLLGtCQUFvQzthQXlTbkVTLGFBdlNRVDtNQUNSLGlCQURRQSxNQUVFLGFBRE5VO01BRUosUUFGSUE7TUFFSixRQUhRVjtNQUdSLE9BRElwMkMsR0FHRDthQUtEKzJDLFVBQVV0a0MsTUFBTTJqQyxJQUNsQix3QkFEa0JBLElBQ2xCLE9BRFkzakMsS0FFUDthQUdIdWtDLFlBQVl2a0MsTUFBTTJqQyxJQUFLLGlCQUFYM2pDLGNBQU0yakMsR0FBNkI7YUFFL0NhLFdBQVd4a0MsTUFBTTJqQyxHQUFHLzNEO01BQ3RCLFNBRG1CKzNELE1BQUcvM0QsR0FDdEIsbUJBRGFvMEIsTUFBTTJqQyxHQUVDO1FBR2xCYzthQUVBQyxTQUFPQyxNQUFNdHpEO01BUUc7O2NBbkdoQm95RDs7Ozs7Y0EyRmFweUQ7Y0FRRyxTQVZoQm96RDtjQUVPRSxNQVVWO2FBR0dDLGNBQVk1N0Q7TUFDZCxzQ0FEY0E7TUFDZCxTQUVJcUk7UUFDRixHQUZFOUUsT0FEQTVILEtBR2dCO1FBQ1YsSUFBSmlILEVBQUksZ0JBTEk1QyxFQUNWckU7UUFJTTtlQUFKaUgsQ0FFSDtNQU5ILGtCQUVJeUYsS0FLbUI7O0lBR0wsU0FBaEJ3ekQsc0I3QzFSUCxPNkNrUU9IO0lBd0JnQixJQXFEZG40RDtJQXJEYyxTQThDaEJ1NEQsa0JBQWtCNTNEO01BQUssc0JBQUxBLElBQUssaUJBQXFDO0lBOUM1QyxTQWtEaEI2M0Qsa0JBQWtCNzNELElBQU0saUJBQWlCO0lBbER6QixTQW9EaEI4M0QsUUFBUUMsY0FBY04sTUFBTXozRDtNQUU5QjtlQUlJbUU7UUFDRixHQUpFMU0sT0FDQW1YLFFBRzhCLElBQUpsUSxFQUFJLGVBTDlCaUMsSUFDQWxKLE1BSThCLGNBQUppSDtRQUM1QixHQUhFczVELE9BR1c7UUFDSixlQVRtQmg0RCxHQUUxQlcsTUFEQXRCO1FBUU8sYUFMUHVQO2tCQUNBb3BELFdBS2lCLFdBVlhELGNBQW9CLzNEO2tCQUcxQnZJLFNBU0UsZUFWRmtKLE9BWUM7TUFaTCxnQkFGd0I4MkQsTUFNcEJ0ekQsS0FTYTtJQXNCakIsSUFJRTh6RCxNQUpGLFFBdkNFSiw0Qm5DaExGMTVEO0ltQ3VOQSxTQU1FKzVELGFBQWFyNEQsUUFHYjhkO01BRkYsd0JBRUVBO1FBQ1MsSUFBTDNkLEdBQUssV0FKSUgsUUFHYjhkO2VBOUNBbTZDLFFBTkFGLHFCQW9EQWo2QyxNQUNJM2Q7TUFGRyxPQUpQaTRELEtBTytDO0lBR3JDLFNBR1ZFLGdCN0NwWVAsTzZDeVhPRCxhbkMxS0ZyNEQ7SW1DbUxnQixTQUdkdTRELG9CN0NyWVAsTzZDeVhPRixhbkN6S0ZwNEQ7SW1Da0xnQixTQUtkdTRELGVBQWFyNEQsSTdDdllwQixPNkM4VU84M0QsUUFGQUQscUJBMkRhNzNELE9BQzBCO0lBTnpCLFNBU2RzNEQsV0FBUzdCO01BQ1gsU0FEV0E7TUFDWDtPQUlpQzs7UUFKakMsa0JBRUUsSUFEYXoyRCxXQUNiLDZCQURhQTtRQUVhLElBQVB1NEQ7UUFBTyw2QkFBUEEsTUFDYztJQWRuQixJQWlDWkM7SUFqQ1ksU0FnQ2RDLGFBRUdWLGNBQWMvM0Q7TUFDbEI7UUFBSSxjQURjQSxHQURmdzREOzs7O1VBS0MsSUFERS9CLEdBQ0YsUUFKQXNCLGlCQUFjLzNEO1VBSWQsZ0JBSmNBLEdBR1p5MkQsSUFKSCtCO1VBS0MsT0FERS9CO1FBM0JQLFdBOEJLO0lBSWlCLFNBQXBCaUM7TTdDOWFQLE82Q2thT0QsYUF0RkFaO0lBa0dvQjthQWN0QmMsVUFBVTc4RCxHQUFJLHNCQUFKQSxFQUEwQjtJQWRkLFNBZ0J0Qjg4RCxpQkFBaUJsNkQ7TUFDVCwwQ0FEU0EsR0FDdUM7SUFqQmxDLFNBb0J0Qm02RCxpQkFBaUJDO01BRWpCLDBDQUZpQkEsU0FLTjtJQXpCVyxTQW9DdEJDO01BQ0YsZ0RBQXdEO0lBckNoQyxTQXdDdEJDO01BQ0YsZ0RBQXFEO0lBekM3QixTQWdEdEJDLG1CQUFtQnY2RCxFQUFFdzZEO003QzlkMUIsTzZDNGJLUCxVQStCRix5QkFHcUJqNkQsRUFBRXc2RCxJQUNnQjtJQWpEZixTQWtGdEJDLGdCQUFnQjFDLEdBQUcvM0Q7TUFDWixJQUFMdzZELEdBQUssa0JBRFN6QztNQUNULE9BQUx5QyxPQURpQng2RCxFQUVOLHdCQUZHKzNELElBR2xCLG1CQUhxQi8zRCxFQUNqQnc2RCxHQUVtQjtJQXJGQyxTQTRFbEJFLFdBV1UzQyxHQVBkdnBEO01BSEYsVUFHRUE7UUFRTyxJQUFMZ3NELEdBQUssa0JBRE96QztRQUNQLGNBQUx5QztpQkFFTSx3QkFITXpDO3dCQUNaeUM7b0JBR00sd0JBSk16QyxJQUlOLGdCQUpNQTttQkFLVCxzQkFKSHlDO2dCQVJGaHNEO09BM0JGO1NBQVEsZ0JBa0NRdXBELElBakNULFNBaUNTQTtTQWpDVDtXQUF1QixTQUQxQi8zRDtXQUMwQjs7OztXckM0Q3hCLGFxQ3pDRix3QkE4QlkrM0Q7V0E3QlA7O01Bc0JGLHVCQU9TQSxHQVBkdnBELElBQXlCO0lBaEZILFNBaUd0Qm1zRCxXQUFXNUMsSUFBd0IsdUJBQW5CLGFBQUxBLE1BQTRCO0lBakdqQixTQXFHdEI2QyxXQUFXN0M7TUFDUCxJQUdKMzZELEVBSEksYUFETzI2RDtNQUNQLDRCQUdKMzZEOztpQkFBZSxtQ0FBZkE7O2dCQUF3RDtJQXpHbEMsU0FzSHRCeTlEO01BQTZCOzs7aUJBQ3RCO2lCQUNBO2lCQUNBO2lCQUNBO2lCQUNBOztpQkFDTTs7TUFDUiw2QkFBWTtJQTdISyxTQW1JdEJDLGtCQUFrQjFnQixLQUFLMmQ7TUFDekIsT0FEb0IzZDttQkFDaEJ6NEIsSUFNZ0IsY0FBTyxhQVBGbzJDO21CQUNyQnAyQyxJQUlnQixjQUFPLGFBTEZvMkM7bUJBQ3JCcDJDLElBR2dCLGNBQU8sYUFKRm8yQzttQkFDckJwMkMsSUFLZ0IsY0FBTyxhQU5GbzJDO29CQUNyQnAyQyxJQUUrQixhQUhWbzJDO01BRzJCLElBS2hENzRELEVBTGdELHNCQUZoRHlpQjtNQVFRLFNBRFJ6aUIsWUFDUSxnQkFSUnlpQjtPQVFxQyxhQVJyQ0EsTUFPQXppQjtNQUM0QixPQVI1QnlpQixHQVE2RDtJQTVJekMsU0FvSnRCbzVDLFlBQVloRCxJQUF3Qyw0QkFBbkIsYUFBckJBLElBQXdDO0lBcEo5QixTQXVMbEJpRCx3QkFBd0I1bUMsTUFBTTJqQztNN0NybUJ2QyxJNkNxbUJpQzN3QjtNQUM5QjtpQkFEOEJBLFFBQ1osT0FEWUE7UUFFdEIsSUFHTnBuQyxFQUhNLFVBRjRCKzNEO1FBR2pDLEdBSGlDQSxNQUdaLE9BSE0zd0I7UUFJOUIsU0FDRXBuQzs7WUFJWSx3QkFUZ0JvbkMsUUFBTTJ3QixJQUFOM3dCOztrQkFLNUJwbkM7V0FDWSx1QkFOZ0JvbkMsUUFBTTJ3QixHQUtsQy8zRCxHQUw0Qm9uQztRQVd2QixPQVh1QkEsUUFXbEI7SUFsTVksU0FvUXRCNnpCLDBCQS9Ed0I3bUMsTUFBTTJqQztNQUNoQyxTQUQwQjNqQyxNQUNSO01BQ1Ysd0JBRndCMmpDLElBRXhCLFNBQUovM0Q7TUFBSSxzQkFNSSwwQ0FOUkE7TUFBSSxJQUdGb25DLFFBQVEsV0FMWWhULE1BQU0yakMsR0FFNUIvM0Q7TUFHVSwrQkFBUm9uQyxRQUwwQjJ3QixHQVFvQztJQTdNNUMsU0FrT3RCbUQsZ0JBQWdCQyxNQUFNQyxPQUFPalIsUUFBTTROO01BR3JDLFNBSCtCNU4sUUFHYjtNQUNWLElBQUozN0MsSUFBSSxrQkFKNkJ1cEQ7TUFLbEMsY0FMcUJxRCxPQUlwQjVzRDtRQUVVLHVCQU5pQjI3QyxRQUFNNE4sR0FJakN2cEQsS0FuQmdCNGxCO1FBQ2xCO21CQURrQkEsTUFDQSxPQURBQTtVQUVWLElBR05wMEIsRUFITSxVQWEyQiszRDtVQVpoQyxHQVlnQ0EsTUFaWCxPQUhOM2pDO1VBS1QsY0FVYWduQyxPQVZwQnA3RDtZQUNZLHVCQU5JbzBCLE1BZWlCMmpDLEdBVmpDLzNELEdBTGdCbzBCO29CQUtoQnAwQjtZQUlZLHdCQVRJbzBCLE1BZWlCMmpDLElBZmpCM2pDO1VBV1gsT0FYV0E7TUF3QlIsMENBTFI1bEIsSUFKYzJzRCxPQVN5RDtJQTNPbkQsU0E4T3RCRztNQUFrQix5REFFUjtJQUdRLFNBQWxCQztNN0NqcUJMLE82Q2dwQktMLDJCQVlBSTtJQUtrQixTQUVsQkU7TUFBaUIseURBRVA7SUFHTyxTQUFqQkM7TTdDeHFCTCxPNkNncEJLUCwwQkFtQkFNO0lBS2lCLFNBRWpCRTtNQUFnQjs7Ozs7TXJDMUpaLG1CcUM0Sk07SUFHYSxTQUF2QkM7TTdDL3FCTCxPNkNncEJLVCxnQ0EwQkFRO0lBS3VCLFNBS3ZCRSxVQUFVeG5DLE1BQU0yakM7TUFDVix3QkFEVUEsSUFDVixTQUFKLzNEO01BQUk7O2dCQUVDLGtCQUhHbzBCLE1BQU0yakMsR0FDZC8zRDs7aUJBR0ssa0JBSkdvMEIsTUFBTTJqQyxHQUNkLzNEO01BSUcsT0FMS28wQixLQUtBO0lBVmEsU0FhdkJ5bkMsK0JBQW1Dem5DLE1BQU0yakM7TUFDL0IsSUFBUjN3QixRQUFRLFVBRHlCaFQsTUFBTTJqQztNQUMvQixpQ0FBUjN3QixRQUR1QzJ3QixHQUVUO0lBZlQsU0EwQ3ZCK0Qsb0JBQW9CMWhCLEtBQUt6SixRQUFNb25CO01BQ2pDLE9BRHNCM2Q7ZUFFSix1QkFGU3pKLFFBQU1vbkI7ZUFHZixzQ0FIU3BuQixRQUFNb25COztTQUpyQixzQkFJZXBuQixRQUFNb25CLElBbkIzQixvQkFtQjJCQTtTQW5CM0IsVUFDSi8zRDtXQUNZLElBQVJvMEIsTUFBUSxXQUhNZ1QsUUFvQmEyd0IsR0FsQi9CLzNEO1dBQ1ksU0FBUm8wQixNQUNjLE9BRGRBO1dBQVEsSUFFUjVsQixJQUFJLFVBZXVCdXBEO1dBZDVCLEdBYzRCQSxNQWRQLE9BSHBCM2pDO1dBQVE7V0FJWixTQUZJNWxCOztjQUlvQixpQ0FOcEI0bEIsTUFpQjJCMmpDLEdBZjNCdnBELEtBZTJCdXBEO3dCQWYzQnZwRDs7Ozs7MEJBS3FCLGtDQVByQjRsQixNQWlCMkIyakMsR0FmM0J2cEQsS0FlMkJ1cEQ7V3JDek0zQjtvQnFDNkxnQyxnQ0FMaEMzakMsTUFpQjJCMmpDLEdBZjNCdnBELEtBZTJCdXBEO29CQVR4Qix3QkFSSDNqQyxNQWlCMkIyakM7U0FSMUIsaUNBWmEzd0IsUUFvQmEyd0I7ZUFLZixzQkFMU3BuQixRQUFNb25CO2VBTWYsaUNBTlNwbkIsUUFBTW9uQjtnQkFPZiw0QkFQU3BuQixRQUFNb25CLElBT2M7SUFqRHRCLFNBdUR2QmdFLHFCQUFxQjNuQyxNQUFNMmpDO01BQzdCLFNBRHVCM2pDLE1BQ0wsT0FES0E7TUFFZixJQUdOcDBCLEVBSE0sVUFGcUIrM0Q7TUFHMUIsR0FIMEJBLE1BR0wsT0FIRDNqQztNQUVmLGFBR05wMEI7TUFERjtlQUp1Qm8wQjtlQU1HLG1DQU5IQSxNQUFNMmpDLEdBSzNCLzNELEdBTDJCKzNELEdBT2pCO0lBOURhLFNBa0V2QmlFLG1CQUFtQjVuQyxNQUFNMmpDO01BQzNCLFNBRHFCM2pDLE1BQ0gsT0FER0E7TUFFYixJQUFKcDBCLEVBQUksVUFGbUIrM0Q7TUFHeEIsR0FId0JBLE1BR0gsT0FISDNqQztnQkFFakJwMEIsZUFLRyxPQVBjbzBCO01BTWdCLGlEQU5oQkEsTUFBTTJqQyxHQUV2Qi8zRCxHQUZ1QiszRCxHQU9mO0lBekVhLFNBb0h2QmtFLFdBQVd0ckIsUUFBTXVyQixVQUFVbkU7TUFuQ2pCO3VCQW1DQ3BuQixRQUFnQm9uQjtPQW5DakIsZ0NBQVIzakMsTUFtQ3lCMmpDO2VBQ3pCM3dCLFFBQ2MsVUFEZEEsUUFEZTgwQjtNQW5DUCxJQXNDUmw4RCxFQUFJLFVBSHFCKzNEO01BSTFCLEdBSjBCQSxNQUlMLFVBSHBCM3dCLFFBRGU4MEI7TUFLbkIsVUFGSWw4RDtRQUlVOzRCQU5Wb25DLFFBRHlCMndCLEdBR3pCLzNEO1NBS2MsZ0JBRFptcUQsUUFQYStSO1NBU2dCO1VBRjdCL1I7O1dBQ0FnUyxjQUM2QixxQkFEN0JBLFlBUnVCcEU7OztRQVUzQiw2QkFESXNELFFBVHVCdEQsSUFRdkJvRTtNQUlKLDZCQVhFLzBCLFFBRHlCMndCLElBQVZtRSxVQVlxQjtJQWhJZixTQW1JdkJFLDhCQUE4QmhvQyxNQUFNMmpDLEdBQUd4dkQsTUFBTTVNO01BQy9DLFNBQUl3TyxVQUFVbks7UUFDWixhQURZQTtRQUNaLDJCQURZQSxFQUdWLGFBSFVBLHFCQUlKO01BSlY7aUNBRCtDckU7T0FDL0MsV0FEZ0N5NEI7T0FDaEMsS0FLSXp6QjtPQUxKOztZQU9BNUg7UUFDRTtVQUFRLGdCQVQ0QmcvRCxJQVVsQixlQUFVLGdCQVZpQnA4RCxJQVEvQzVDO1VBRUssYUFEQ2lILFlBQ3FDLFdBVkZ1STtVQVVVLFNBSC9DNitCLFdBSWlCLFdBWG9CNytCO1VBWTlCLHdCQUxQNitCLFdBUGtDMndCLEdBU2hDLzNEO1VBQUksU0FEVmpIOzs7TUFNQSxPQVBJcXVDLFVBT0U7SUFqSm1CLFNBb0p2QmkxQixlQUFlam9DLE1BQU04bkMsVUFBVW5FO01BQ2pDLGVBRGlCM2pDLFVBQ2pCLGFBQWdCLGFBRGlCMmpDO01BQ08sUUFBTTtNQUE5QztPQUNZLGtCQUZLM2pDLE1BQWdCMmpDO09BRXJCLFdBQVIzd0I7T0FBUSxhQUNJLGFBSGlCMndCO01BR08sUUFBTTtNQUY5QyxJQUdNLFlBSjJCQTtNQUkzQixTQUNKLzNEOzs7O1lBNkJZO2dDQWhDVm9uQyxRQUY2QjJ3QixHQUsvQi8zRDthQTZCWSxXQUFSMndDO2FBQVEsYUFDSSxhQW5DZW9uQjtZQW1DUyxRQUFNO1lBQWdCO3FCQUQxRHBuQixRQWxDMkJvbkIsR0E3Vy9CdUM7Ozs7a0JBa1hBdDZEO1VBQ1k7OEJBSlZvbkMsUUFGNkIyd0IsR0FLL0IvM0Q7V0FDWSxXQUFScTdEO1dBQVEsYUFDSSxhQVBldEQ7VUFPUyxRQUFNO1VBRGxDO1dBRVJ1RTtZQUFRLDhCQUZSakIsUUFOMkJ0RCxHQTdXL0J1QztVQXNYZ0IsU0FEWmdDLGFBQ1ksYUFUZXZFO1lBVVgsb0JBVldBLElBVVg7Ozs7O2dCQUFkd0UsaUJBRkZELFFBSU8scUJBSlBBLFFBUjJCdkU7WUFhYixTQUhad0UsYUFHWSxhQWJheEU7Y0FjVCxJQUNkdnBELElBRGMsVUFkU3VwRDtjQWNULFVBQ2R2cEQ7Z0JBQ1ksdUJBTmQrdEQsUUFWeUJ4RSxHQWV2QnZwRDtnQkFFZ0IsU0FEWmd1RCxhQUNZLGFBakJPekU7a0JBa0JmLHNCQWxCZUE7O29CQXFCSDtxQ0FMaEJ5RSxRQWhCU047cUJBZ0JUTzs7O3VCQUtJTixjQUNpQixxQkFEakJBLFlBckJlcEU7Ozs7b0NBZ0JuQjBFO2tCQUVJLElBRkpDOzs7Z0JBQVEsSUFGWkMsUUFFSUQ7O21CQUZKQyxRQUpGSjtjQWVjLFNBWFpJLGFBV1ksYUF6Qlc1RTtnQkEwQm5CLElBQ0p0cEQsSUFESSxVQTFCbUJzcEQ7MEJBMkJ2QnRwRCxtQkFJSyxPQWpCTGt1RDtnQkFZSTtpQkFFUSxtQkFkWkEsUUFkdUI1RSxHQTJCdkJ0cEQ7aUJBQ1ksV0FBUm11RDtpQkFBUSxhQUNJLGFBN0JPN0U7Z0JBNkJpQixRQUFNO2dCQUFnQixzQ0FEMUQ2RSxRQTVCbUI3RTtjQXlCbUIsT0FYMUM0RTtZQUR3QyxPQUgxQ0o7VUFEd0MsT0FEMUNEO2tCQUhKdDhEO01yQ3hUSTtRcUN5VlE7NEJBcENWb25DLFFBRjZCMndCLEdBSy9CLzNEO1NBaUNZLFdBQVJtcUQ7U0FBUSxhQUNJLGFBdkNlNE47UUF1Q1MsUUFBTTtRQUFnQjtpQkFEMUQ1TixRQXRDMkI0TixHQTdXL0J1QztNQXNaSyx1QkFBZ0I7SUE3TEUsU0FnTXZCdUMscUJBQXFCem9DLE1BQU04bkMsVUFBVW5FO01BQ3ZDLGVBRHVCM2pDLFVBQ3ZCLGFBQWdCLGFBRHVCMmpDO01BQ0MsUUFBTTtNQUE5QztPQUNZLGdDQUZXM2pDLE1BQWdCMmpDO09BRTNCLFdBQVIzd0I7T0FBUSxhQUNJLGFBSHVCMndCO01BR0MsUUFBTTtNQUY5QyxJQUdRLFlBSitCQSxJQUkvQixTQUFKLzNEO01BQUk7O1VBR007OEJBTFZvbkMsUUFGbUMyd0IsR0FJbkMvM0Q7V0FNYyxnQkFIWjJ3QyxRQVB1QnVyQjtXQWFMLHFDQUhsQkMsWUFWaUNwRTtXQWFmLFdBSGxCb0UsY0FHQVc7V0FBa0IsUUFObEJuc0IsVUFTQW9zQjtVQUhrQiwwQkFLbEI1UyxRQWxCaUM0Tjs7O2lDQXFCckMsMEJBbkJFM3dCLFFBRm1DMndCO01Bc0JoQyxtQkFBWTtJQXROTSxTQXlOdkJpRixnQkFBZ0I1b0MsTUFBTThuQyxVQUFVbkU7TUFDbEMsZUFEa0IzakMsVUFDbEIsYUFBZ0IsYUFEa0IyakM7TUFDTSxRQUFNO01BQTlDO09BQ1ksa0JBRk0zakMsTUFBZ0IyakM7T0FFdEIsV0FBUjN3QjtPQUFRLGFBQ0ksYUFIa0Iyd0I7TUFHTSxRQUFNO01BRjlDLElBSUUvM0QsRUFESSxVQUo0QiszRDtNQUk1QixTQUNKLzNEOztVQWlDWTs4QkFwQ1ZvbkMsUUFGOEIyd0IsR0FLaEMvM0Q7V0FpQ1ksV0FBUjJ3QztXQUFRLGFBQ0ksYUF2Q2dCb25CO1VBdUNRLFFBQU07VUFBWSw0QkFEdERwbkIsUUF0Q2tCdXJCLFVBQVVuRTs7Z0JBS2hDLzNEO1NBQ1k7NkJBSlZvbkMsUUFGOEIyd0IsR0FLaEMvM0Q7VUFDWSxXQUFSbXFEO1VBQVEsYUFDSSxhQVBnQjROO1NBT1EsUUFBTTtTQURsQyxJQUdWdnBELElBREksVUFSMEJ1cEQ7bUJBUzlCdnBEO1VBMEJBLDRCQTdCRTI3QyxRQU5rQitSLFVBQVVuRTtTQU1wQjtVQUlFLG1CQUpWNU4sUUFONEI0TixHQVM5QnZwRDtVQUNZLFdBQVI2c0Q7VUFBUSxhQUNJLGFBWGN0RDtTQVdVLFFBQU07U0FMcEM7VUFNRSw2QkFGUnNELFFBVjBCdEQ7VUFZbEIsV0FBUnVFO1VBQVEsYUFDSSxhQWJjdkU7U0FhVSxRQUFNO1NBUHBDLElBUVEsY0FkWUEsSUFjWixTQUNkdHBEO1NBRGM7O1lBRUYsdUJBSlo2dEQsUUFaMEJ2RSxHQWUxQnRwRDtZQUVnQixTQURaOHRELGFBQ1ksYUFqQlV4RTtjQWtCbEIsb0JBbEJrQkE7O2dCQXFCTjtpQ0FMaEJ3RSxRQWhCWUw7aUJBZ0JaTzs7O21CQUtJTixjQUNpQixxQkFEakJBLFlBckJrQnBFOzs7O2dDQWdCdEIwRTtjQUVJLElBRkpEOzs7WUFBUSxJQUFSRTs7Ozs7Z0RBSkpKO1NBTk0sSUFRTkssaUJBV0ssYUFUREQ7U0FVUSxTQVpaQyxhQVlZLGFBMUJjNUU7V0EyQnRCLElBQ0pycEQsSUFESSxVQTNCc0JxcEQ7cUJBNEIxQnJwRCxtQkFJSyxPQWxCTGl1RDtXQWFJO1lBRVEsbUJBZlpBLFFBZDBCNUUsR0E0QjFCcnBEO1lBQ1ksV0FBUmt1RDtZQUFRLGFBQ0ksYUE5QlU3RTtXQThCYyxRQUFNO1dBQWdCLHNDQUQxRDZFLFFBN0JzQjdFO1NBMEJnQixPQVoxQzRFO01BK0JELG1CQUFZO0lBdFFNLFNBK1F2Qk0sWUFBWUMsSUFDRDlvQyxNQURXMmpDO003Qzk3QjNCLEk2Qys3QmdCM3dCO01BQ1g7aUJBRFdBLFFBQ08sT0FEUEE7UUFFSCxJQUFKcG5DLEVBQUksVUFIYyszRDtRQUluQixHQUptQkEsTUFJRSxPQUhiM3dCO1FBSVQsR0FMVTgxQjtVQU1LLElBQVIxdUQsSUFORzB1RDtVQU1LLEdBSGJsOUQsTUFHS3dPLElBQWtCLGlCQUxoQjQ0QixRQURXMndCO1VBTUwsSUFDRSxtQkFOUjN3QixRQURXMndCLEdBR2xCLzNELEdBRk9vbkM7O1FBRUgsSUFNSixLQU5BcG5DO1FBTUE7Ozs7UXJDdmJBLFlxQ3diOEIsT0FUdkJvbkM7UUFFSCxJQVFRLG1CQVZMQSxRQURXMndCLEdBR2xCLzNELEdBRk9vbkM7aUJBV0g7SUEzUmUsU0ErUnZCKzFCLFVBQVUvb0MsTUFBTTJqQztNQUlXLGtCQUpqQjNqQyxNQUFNMmpDLEdBSVcsa0JBSlhBLElBSTBDO0lBblNuQyxTQWdVdkJxRiwwQkFDRWxuRDtNQUFKLGFBQUlBLDBDQVVpQjtJQTNVSSxTQTBWdkJtbkQsZ0JBQWdCakQsUUFBUWhtQyxNQUFNMmpDO01BQ2hDLFNBRDBCM2pDLE1BQ1Isd0JBREFnbUM7TUFFVixJQUFKcDZELEVBQUksVUFGd0IrM0Q7TUFHN0IsT0FINkJBLE1BN2pCOUIsbUNBNmpCZ0JxQyxVQUVkcDZELENBRUg7SUFHNEIsU0FBM0JzOUQ7TTdDaGhDTCxPNkN5Z0NLRDtJQVE2QixTQUE3QkU7TTdDamhDTCxPNkN5Z0NLRjtJQVE2QixTQUU3Qkcsb0JBQW9CcHBDLE1BQU0yakM7TUFDdEIsZ0NBRGdCM2pDLE1BQU0yakM7TUFDdEIsU0FuRGtCMEY7Ozs7OztjQWlFdEI7OztrQkFDVSxnQkFoQmdCMUYsSUFnQmhCLEtBQUovM0Q7a0JBQUk7Ozs7a0JyQ25oQk4sZ0JxQ21oQkVBLEVBR0csaUJBSEhBLEVBR3FCO2VBQ2xCO2VBQ0E7ZUF4Q0osK0JBSHdCeUs7ZUFFeEIsb0NBRnFCRDs7c0JBQ3hCZ0U7eUJBTUosWUFOSUE7O3dCQUtBLG1DQU53QmhFLEdBQUdDO3FCQWx3QjNCbXVELFdBd3hCa0J4a0MsY0FBTTJqQzs7Ozs7Ozs7a0JBbERKMEY7V0F1RHRCOzs7ZUFDVSxnQkFOZ0IxRixJQU1oQixTQUVOLzNEO2VBRk0sMEJBR0QsaUJBRExBLElBQ3VCO1lBRWxCO1lBQ0E7WUE1REg7c0JBRmdCeTlELDJCQUFHRzs7Y0FBR0M7Ozs7bUJBQzFCNzlELDJCQVFKLFlBUklBOztxQkFNQSxtQ0FQb0J5OUQsR0FBR0csS0FBR0M7a0JBdHVCMUJqRixXQXd4QmtCeGtDLGNBQU0yakM7O2lCQWxESjBGO01yQ2pkbEI7O1FxQ3FjaUIsVUFZQ0E7Ozs7Ozs7Ozs7Ozs7ZUF0dUJwQjdFLFdBd3hCa0J4a0MsTUFBTTJqQztNQXdCMUIsd0JBMUVzQjBGLEdBMEVKO0lBMUJXLFNBOEI3QkssZUFFaUIxcEMsTUFGSTJqQztNQUV2QixTQVlJZ0csVUFBVTNwQztRQUNOLElBRUpwMEIsRUFGSSx5QkFETW8wQixNQWRTMmpDO1FBZWYsY0FFSi8zRCxFQURRLFlBRkVvMEIsTUFkUzJqQyxJQWlCZCxzQkFBTC8zRCxFQUE4QjtNQWQxQixJQUVKQSxFQUZJLGtCQUhlKzNEO01BR2YsVUFFSi8zRDtRQURrQjs2QkFGSG8wQixNQUZJMmpDO1NBUWYsNkJBRE0zd0IsUUFQUzJ3QjtRQVFmLGNBR0p2cEQ7aUJBRFUsOEJBQXFCLFlBSHJCNDRCLFFBUFMyd0I7aUJBWVQscUJBTEEzd0IsUUFQUzJ3QixHQVduQnZwRDtNQU5LLDZCQUFMeE8sRUFjWTtJQWpEZSxTQXFEN0JnK0QsaUJBRWlCNXBDLE1BRk0yakM7TUFFekIsU0FLSWtHLG9CQUFVN3BDO1E3QzdrQ2pCLEk2QzZrQ2lCZ1Q7UUFDWjtVQUFNLElBR0pwbkMsRUFISSwyQkFETW9uQyxRQVBXMndCO1VBUWpCLFVBR0ovM0QsRUFGUSxtQkFGRW9uQyxRQVBXMndCO29CQVdyQi8zRDtZQUR1QjtpQ0FIYm9uQyxRQVBXMndCO2FBY2pCLGlDQURXcG5CLFFBYk1vbkI7WUFjakI7Y0FFZ0IscUJBSExwbkIsUUFiTW9uQjtjQWdCRDs7dUJBUXBCbUc7OztjQVRxQjttQ0FGTnZ0QixRQWJNb25CO2VBb0JqQixtQ0FEU3NELFFBbkJRdEQ7Y0FvQmpCO2dCQUNnQixxQkFGUHNELFFBbkJRdEQ7Z0JBcUJEOzt5QkFHcEJtRzs7Y0FUcUIsSUFPTixtQkFIRjdDLFFBbkJRdEQsT0FPWDN3Qjs7WUFHYSxJQU9SLDRCQUpBdUosUUFiTW9uQixJQU9YM3dCOztVQUNOLElBR1csbUJBSkxBLFFBUFcyd0IsR0FXckIvM0QsR0FKVW9uQzttQkFJcUM7TUFUbkQsU0FzQkk4MkIsb0JBQVk5cEM7UTdDOWxDbkIsSTZDOGxDbUJnVDtRQUNkO1VBQU0scUNBRFFBLFFBeEJTMndCO1VBeUJqQjtZQUNlLHdCQUZQM3dCLFFBeEJTMndCLElBd0JUM3dCO1VBR1A7O21CQXBCTDYyQixzQkFpQlk3MkI7d0NBakJaNjJCLGVBaUJZNzJCLFVBR1E7TUF6QnhCLFNBS0kyMkIsVUFBVTNwQyxPN0M3a0NqQix1QjZDNmtDTzZwQyxjQUFVN3BDO01BSk4sSUFFSnAwQixFQUZJLGtCQUhpQiszRDtNQUdqQixjQUVKLzNEO2VBRGtCLHNCQUZIbzBCLE1BRk0yakM7ZUFLaEIsc0JBQUwvM0QsRUF3Qlk7SUFsRmUsU0FvRzdCbStELHVCQUF1QjFoRSxTQUFTMmhFLFdBQVdocUMsTUFBTTJqQztNQUNuRCxTQUFRc0csV0FBV3RsRSxFQUFFbWtFO1E3Q3RuQ3hCLEk2Q3NuQ3NCLzlEO1FBQ2pCO1VBQVEsZ0JBRnlDNDRELElBRXpDLFNBRFM1NEQ7VUFDVDtZQUNRLGFBSGlDNDREO1lBR2pDO2FBQ2Isd0JBSm9CdDdELFNBRW5CdUQsR0FFRCxVQUZDQSxNQURlazlEOzs7OztVQUtqQjtZQUFRLFdqQ3RrQ1JoL0QsUWlDZ2tDK0M2NUQsR0FFN0MvM0QsR0FJTSxRQUxPYjtzQkFNTztNQU4xQixHQURrQ2kvRDtRQVdoQyxJQURLcCtELEVBVjJCbytEO1FBV2hDLFdBWDJDaHFDLE1BVXRDcDBCO1FBQ0wsYUFYaUQrM0Q7UUFZMUM7VUFDSSxJQUFMeUMsR0FBSyxVQWJzQ3pDO1VBYXRDLE9BSE4vM0QsTUFHQ3c2RCxHQUVDLHdCQWYwQ3pDLElBZ0IxQyxtQkFORi8zRCxFQUdDdzZEO1FBSkU7d0JBVG1DcG1DLFNBZ0JiO0lBcEhELFNBd0g3QmtxQyxnQkFBZ0J2RyxHQUloQng2RDtNN0M3b0NMLEc2QzZvQ0tBO1dBSGFILEVBR2JHOzs0QkFBSyxNQUFMQSxNQUhhSCxFQUdiRztNQUZRLElBQUp4RSxFQUFJLFdBRlFnL0Q7TUFHTiwwQ0FETmgvRCxFQURTcUU7SUF6SGdCLFNBZ0k3Qm1oRSxZQUFZeEcsR0FBR243RDtNQUNqQixPQURpQkE7ZUFFQyxPQUZKbTdELGFBR0ksa0JBSEpBLFlBSUssT0FKTEEsTUFJNEI7SUFwSVgsU0F3STdCeUcsaUJBQWlCcnFDO01BQVUsR0FBVkEsU0FFSCxJQUFUQyxNQUZZRCxXQUVILE9BQVRDLE1BREcsT2pDcm1DTmwyQixPaUNzbUNpQjtJQTFJVSxTQTZJN0J1Z0UsMEJBQTBCQztNQUM1QixTQUQ0QkEsT0FDSztNQUNyQjtvQ0FGZ0JBO09BR2hCLG9CQUROL2lFO09BRVUsY0FGVkEsTUFDTSxzQkFETkE7TUFFVSxVQURWdWhFLElBQ0F4dUIsUUFDUTtJQWxKaUIsU0E0SnpCaXdCLDhCQUdKcjFDLEVBQUVnTDtNN0NockNQLEk2Q2dyQ091RDtNQUFPO2lCQUFQQTtRQXFDa0Msa0JBckNwQ3ZPOztRQUFTLE9BQVB1TztpQkFLa0MsVUFMbENBO2lCQU1rQyxVQU5sQ0E7aUJBT2tDLFVBUGxDQTtpQkFRa0MsVUFSbENBO2lCQVNrQyxVQVRsQ0E7aUJBVWtDLFVBVmxDQTtpQkFXa0MsVUFYbENBO2lCQVlrQyxVQVpsQ0E7aUJBYWtDLFVBYmxDQTtpQkFja0MsV0FkbENBO2tCQWlCa0MsV0FqQmxDQTtrQkFrQmtDLFdBbEJsQ0E7a0JBbUJrQyxXQW5CbENBO2tCQWdDa0MsV0FoQ2xDQTs7V0FrQzJCLElBREw1K0IsS0FqQ3RCNCtCLFNBaUNlaDhCLE1BakNmZzhCLFNBa0MyQixlQUFXLEtBRHZCaDhCO1dBQ1k7O29CQU03QitpRSxzQ0F4Q0F0MUMsT0FpQ3dCcndCOztvQkFPeEIybEUsK0JBeENBdDFDLE9BaUN3QnJ3QjtrQkFsQlksV0FmbEM0K0I7a0JBZ0JrQyxXQWhCbENBO2tCQTBCa0MsV0ExQmxDQTs7OzthQTRCc0I7Y0FEb0IzK0IsT0EzQjFDMitCOztjQTJCZ0NrTztjQUNWLGtCQURVQSxPQUFVN3NDO2NBM0IxQzIrQjs7V0E4QnNCO1lBRG9CMStCLE9BN0IxQzArQjs7WUE2QmdDME87WUFDVixrQkFEVUEsT0FBVXB0QztZQTdCMUMwK0I7OztXQUVGLElBRE82SyxTQURMN0s7V0FFRixnQkFBSWduQzthQUNGLFNBQUlDLE1BQU1DO2VBQWUsa0JBSDNCejFDLEtBRUl1MUMsT0FDUUUsY0FBOEM7YUFBeEQsMkJBQUlELE1BRkNwOEIsU0FHNkI7a0JBa0JBLFdBdEJsQzdLO2tCQXVCa0MsV0F2QmxDQTtrQkF3QmtDLFdBeEJsQ0E7O2VBbUNrQnorQixPQW5DbEJ5K0IsU0FtQ2E5NkIsSUFuQ2I4NkI7V0F5RVcsVUF0Q0U5NkI7WUFzQ0YsT0F0Q0VBO3lCQW5DYjg2QixNQW1Da0J6K0I7eUJBbkNsQnkrQixNQW1Da0J6K0I7O2VBd0NwQixnQkFBSXlsRTtpQkFDRixTQUFJQyxNQUFNQzttQkFBZSxrQkE1RTNCejFDLEtBMkVJdTFDLE9BQ1FFLGNBQThDO2lCQUF4RCwyQkFBSUQsTUF6Q2MxbEUsT0EwQ1c7MEJBN0U3QnkrQixNQW1Da0J6K0I7O1lBc0NQLE9BdENFMkQ7eUJBbkNiODZCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjt5QkFuQ2xCeStCLE1BbUNrQnorQjs7ZUFzRGUsSUFBVjJDLFFBdERWZ0I7ZUFzRG9COzt3QkFqRG5DNmhFO29DQXhDQXQxQyxFQXlGeUJ2dEIsUUF0REwzQzs7d0JBS3BCd2xFLCtCQXhDQXQxQyxFQXlGeUJ2dEIsUUF0REwzQzswQkFuQ2xCeStCLE1BbUNrQnorQjswQkFuQ2xCeStCLE1BbUNrQnorQjtrQkFmZ0IsV0FwQmxDeStCLCtCQXFDdUM7SUFwTVosU0F1TTdCK21DLG9DQUdBdDFDLEVBQUV6dEIsTUFBTXk0QjtNN0MzdENiLEk2QzJ0Q092NEI7TUFBYTtpQkFBYkE7U0FxQjZCOztrQkFuRTNCNGlFLGdDQThDSnIxQyxFQUFRZ0w7dUNBOUNKcXFDLHlCQThDSnIxQyxFQUFRZ0w7O1FBQU8sT0FBYnY0QjtpQkFTNkIsWUFUN0JBO2lCQVU2QixZQVY3QkE7aUJBVzZCLFlBWDdCQTtpQkFZNkIsWUFaN0JBO2lCQWE2QixZQWI3QkE7aUJBYzZCLFlBZDdCQTtpQkFlNkIsWUFmN0JBO2lCQWdCNkIsWUFoQjdCQTtpQkFvQjZCLFlBcEI3QkE7O1dBdUJPO1lBRGtCOUMsS0F0QnpCOEM7WUFzQm9CMUIsSUF0QnBCMEI7WUFzQmVuQyxJQXRCZm1DO1lBdUJPLFNBQU0sS0FERW5DLEtBQUtTO1lBRU0sc0JBRHhCWCxHQUR1QlQ7WUF0QnpCOEM7O2tCQWlCNkIsYUFqQjdCQTtrQkFrQjZCLGFBbEI3QkE7a0JBbUI2QixhQW5CN0JBOztXQUVGLElBRFUybUMsU0FEUjNtQztXQUVGLGdCQUFJOGlFO2FBQ0YsU0FBSUMsTUFBTUM7ZUFBZSxrQkFIM0J6MUMsS0FFSXUxQyxPQUNRRSxjQUE4QzthQUF4RCxpQ0FBSUQsTUFGSXA4QixTQURGcE8sSUFJc0M7O1dBRTlDLElBRGtCcU8sV0FMaEI1bUM7V0FNRixnQkFBSThpRTthQUNGLFNBQUlDLE1BQU1DO2VBQWUsa0JBUDNCejFDLEtBTUl1MUMsT0FDUUUsY0FBOEM7YUFBeEQsaUNBQUlELE1BRlluOEIsV0FMVnJPLElBUXNDLEVBZ0JRO0lBbE96QixTQTRKekIwcUMsb0JBR0oxMUMsRUFBRWdMO003Q2hyQ1AsdUI2QzZxQ1NxcUMsd0JBR0pyMUMsRUFBRWdMO0lBL0oyQixTQXVNN0I4cUMsMEJBR0E5MUMsRUFBRXp0QixNQUFNeTRCO003QzN0Q2IsdUI2Q3d0Q0tzcUMsOEJBR0F0MUMsRUFBRXp0QixNQUFNeTRCO0lBMU1xQixTQXFRekIrcUMsV0FHSnRILEdBQUd6akMsSUFBSWdyQztNN0N6eENaLEk2Q3l4Q1F6bkM7TUFBZTtpQkFBZkE7UUF3Skg7O1FBeEprQixPQUFmQTs7V0FFSCxJQURLNStCLEtBREY0K0I7V0FFSyxZQUZSa2dDO1dBRUEsSUFDSS8zRCxFQUFJLFdBSFIrM0Q7V0FJUyxVQURMLzNELEVBQ0ssV0FKVCszRCxHQUNLOStELEtBREVxbUU7O1dBTVAsSUFEVXBtRSxPQUxQMitCO1dBTUssaUJBTlJrZ0M7V0FNQSxJQUNJdnBELElBQUksV0FQUnVwRDtXQVFTLFVBREx2cEQsSUFDSyxXQVJUdXBELEdBS1U3K0QsT0FMSG9tRTs7b0JBQUp6bkM7Ozs7ZUFXWTtnQkFEMEJ6K0I7Z0JBQVpnRDtnQkFDZCxnQ0FEY0E7Z0JBQ2Q7OzswQkFDTmc0QixZQUFRMmpDO21CQUFLLHNCQURsQm1GLEtBQ0s5b0MsTUFBUTJqQyxHQUFvQztnQkFEdEMsYUFBTnA4RCxJQURnQ3ZDO2VBQzFCO3dCQVhmMitELEdBYUl5SCxTQWJHRixlQVlIQyxPQXB4QkovRzs7Ozs7a0JBdXhCMERuL0Q7O2tCQUFYKzlCO2tCQUMzQ3NvQzs0QkFBS3RyQyxZQUFRMmpDLElBQUssd0JBQWIzakMsTUFBUTJqQyxHQUFvQztpQkFDbkM7MEJBakJsQkE7MEJBaUJrQixXQUY2QjNnQyxNQUFXLzlCOzBCQWZuRGltRTs7OzBCQWdCSEk7MEJBeHhCSmxIOztnQkEyeEIwRGwvRDs7Z0JBQVhnbUM7Z0JBQzNDcWdDOzBCQUFLdnJDLFlBQVEyakMsSUFBSyx3QkFBYjNqQyxNQUFRMmpDLEdBQW9DO2VBQ25DO3dCQXJCbEJBO3dCQXFCa0IsV0FGNkJ6NEIsTUFBV2htQzt3QkFuQm5EZ21FOzs7d0JBb0JISzt3QkE1eEJKbkg7OztZQSt4QmFyL0QsT0F2QlYwK0I7WUF3QkMrbkMsY0FBS3hyQyxZQUFRMmpDLElBQUsscUJBQWIzakMsTUFBUTJqQyxHQUE4QjtrQkFxSS9DMEgsZUE3SkExSCxHQXVCYTUrRCxPQXZCTm1tRSxlQXdCSE0sS0FoeUJKcEg7OztZQW15QmtCai9ELE9BM0JmcytCO1lBMkJVcDlCLElBM0JWbzlCO1lBNEJDZ29DLGdCQUFLenJDLFlBQVEyakMsSUFBSyx3QkFBYjNqQyxNQUFRMmpDLEdBQThCO2tCQWlJL0MwSCxlQTdKQTFILEdBMkJrQngrRCxPQTNCWCtsRSxRQTJCTTdrRSxNQUNUb2xFLE9BcHlCSnJIOztXQXV5QlE7WUFEZWgvRCxPQTlCcEJxK0I7WUE4QmNsOUIsS0E5QmRrOUI7WUE4QlNuOUIsTUE5QlRtOUI7WUE4QkVoOUIsTUE5QkZnOUI7WUErQkssZ0NBQTJCLGNBRDlCaDlCO1lBQ0c7c0JBQ0N1NUIsWUFBUTJqQztlQUFLLDJCQXp2QlozZCxLQXl2QkRobUIsTUFBUTJqQyxHQUFtQztXQUNQO29CQWpDN0NBO29CQThCdUJ2K0Q7b0JBOUJoQjhsRTtvQkE4Qks1a0U7b0JBQUtDO29CQUVibWxFOzZCQXp2QlcvSDtzQkFBOEMsMEJBQTNCLGtCQUF4QjNkLEtBQUsyZDs7V0E0dkJQO1lBRGlCdCtELE9BbEN0Qm8rQjtZQWtDZ0IvOEIsT0FsQ2hCKzhCO1lBa0NXajlCLE1BbENYaTlCO1lBa0NJNzhCLFFBbENKNjhCO1lBbUNLLGtDQUEyQixjQUQ1Qjc4QjtZQUNDO3NCQUNDbzVCLFlBQVEyakM7ZUFBSywyQkF4dUJWZ0ksT0F3dUJIM3JDLE1BQVEyakMsR0FBbUM7V0FDUDtvQkFyQzdDQTtvQkFrQ3lCdCtEO29CQWxDbEI2bEU7b0JBa0NPMWtFO29CQUFLRTtvQkFFZmtsRTs2QkF4dUJhakk7c0JBQWdELDBCQUEzQixrQkFBMUJnSSxPQUFLaEk7O1dBMnVCVDtZQURxQnArRCxPQXRDMUJrK0I7WUFzQ29CNThCLE9BdENwQjQ4QjtZQXNDZTk4QixNQXRDZjg4QjtZQXNDUTE4QixRQXRDUjA4QjtZQXVDSyxrQ0FBMkIsY0FEeEIxOEI7WUFDSDtzQkFDQ2k1QixZQUFRMmpDO2VBQUssMkJBN3VCTmtJLE9BNnVCUDdyQyxNQUFRMmpDLEdBQW1DO1dBQ1A7b0JBekM3Q0E7b0JBc0M2QnArRDtvQkF0Q3RCMmxFO29CQXNDV3ZrRTtvQkFBS0U7b0JBRW5CaWxFOzZCQTd1QmlCbkk7c0JBQW9ELDBCQUEzQixrQkFBOUJrSSxPQUFLbEk7O1dBZ3ZCYjtZQURpQmwrRCxPQTFDdEJnK0I7WUEwQ2dCejhCLE9BMUNoQnk4QjtZQTBDVzM4QixNQTFDWDI4QjtZQTBDSXY4QixRQTFDSnU4QjtZQTJDSyxrQ0FBMkIsY0FENUJ2OEI7WUFDQztzQkFDQzg0QixZQUFRMmpDO2VBQUssMkJBL3VCVm9JLE9BK3VCSC9yQyxNQUFRMmpDLEdBQW1DO1dBQ1A7b0JBN0M3Q0E7b0JBMEN5QmwrRDtvQkExQ2xCeWxFO29CQTBDT3BrRTtvQkFBS0U7b0JBRWZnbEU7NkJBL3VCYXJJO3NCQUFnRCw0QkFBM0Isa0JBQTFCb0ksT0FBS3BJOztrQkFtc0JkbGdDOzs7a0JBOEMwQzk5QixRQTlDMUM4OUIsU0E4Q29Db0wsT0E5Q3BDcEwsU0E4QytCcjhCLE1BOUMvQnE4QjtxQkE2Skg0bkM7dUJBN0pBMUg7dUJBOEM2Q2grRDt1QkE5Q3RDdWxFO3VCQThDMkI5akU7dUJBQUt5bkM7dUJBL2J2Qys1Qjt1QkF0VUFqQzs7O2tCQTB3QjRDL2dFLFFBbkR6QzY5QixTQW1EbUN1TCxPQW5EbkN2TCxTQW1EOEJuOEIsTUFuRDlCbThCO3FCQTZKSDRuQzt1QkE3SkExSCxHQW1ENEMvOUQsUUFuRHJDc2xFLFFBbUQwQjVqRSxNQUFLMG5DLE9BemdCdENpNUIsZUFqUUF0Qjs7a0JBd3dCa0JqaEUsUUFqRGYrOUIsU0FpRFN0OEIsT0FqRFRzOEIsU0FpREl4OEIsTUFqREp3OEI7cUJBNkpING5DO3VCQTdKQTFILEdBaURrQmorRCxRQWpEWHdsRSxRQWlEQWprRSxNQUFLRSxPQXZpQlowZ0UsV0FqT0FsQjs7O1lBNHdCVzlnRSxRQXJEUjQ5QjtZQXFERy83QixNQXJESCs3QjtZQXNEQ3dvQztpQ0FBU3RJO2VBdk9QO29DQXVPT0E7Z0JBdk9QO3lCQUtKLzNEOzsrQkFDQSxVQUNFLHlCQUZGQTtlQUdKLHFCQVBJNmIsRUFzT1drOEMsR0FBaUI7a0JBdUc5QjBILGVBN0pBMUgsR0FxRFc5OUQsUUFyREpxbEUsUUFxRER4akUsUUFDRnVrRSxPQTV6Qkp6Rjs7V0E2MEJBLElBRE0zK0QsUUF0RUg0N0I7V0F1RUEsZ0JBdkVIa2dDLFNBQUdsZ0MsTUFzRUc1N0I7V0FFRDs7ZUFFZ0JDLFFBMUVsQjI3QixTQTBFYWpCLE1BMUViaUI7V0EyRUgsc0I3Q3AyQ0wsTzZDMGZTNmlDLFdBK3hCSjNDLFVBMEVnQm5oQztlQTFFYmlCLE1BMEVrQjM3Qjs7O2VBR0ZDLFFBN0VoQjA3QixTQTZFV2o4QixJQTdFWGk4QjtXQThFSCxXQTlFQWtnQyxHQTZFY244RDtlQTdFWGk4QixNQTZFZ0IxN0I7OztlQUlTRSxRQWpGekJ3N0IsU0FpRmtCaDhCLE1BakZsQmc4QixTQWlGUzFELFFBakZUMEQ7V0FrRkssaUJBQWlCLGlCQURiMUQsU0FqRlo0akM7V0FtRlEsSUFBSjM2RCxFQUFJLGFBbkZSMjZEO1dBbUZRO2FBRUYsZ0NBRkYzNkQsRUFGaUJ2QixPQUdqQjZqQzs7OzthQUVrQixlQUZsQkEsTUFFa0IsVUFBUGhzQjtXQUVKLFVBSlBnc0IsTUFJTyxXQXhGWHE0QixHQWlGNEIxN0QsUUFqRnJCaWpFOztlQXlGdUIvaUUsUUF6RjNCczdCLFNBeUZvQjk3QixRQXpGcEI4N0IsU0F5Rld0RCxVQXpGWHNEO1dBMEZLLGlCQUFpQixpQkFEWHRELFdBekZkd2pDO1dBMkZRLElBQUo3dEQsSUFBSSxhQTNGUjZ0RDtXQTJGUTthQUdjOzBDQUhsQjd0RDtjQUdrQjtjQUNDLDRCQUpuQkE7Y0FJbUI7Y0FjbkIsa0JBZFl3MkIsTUFjSyxVQUFXLEtBcEJUM2tDO2NBbUJuQixpQkFkWXVrQyxNQWNJLFVBbkJHdmtDO2NBR2Rta0M7Y0FBTEo7OzttQ0FvQko7YUFGc0I7OzZCQUFQa1k7Y0FsQk45WDtjQUFMSjtXQXFCRTtzQkFyQkZBLE1BREE1MUI7bUJBc0JFLFdBakhONnRELEdBaUhvQixXQXJCWDczQixNQUhxQjNqQyxTQXpGdkIraUU7a0JBeURQO2tCQUVBOztXQTRFNEI7WUFESTlpRSxRQXRJN0JxN0I7WUFzSWEvL0IsZUF0SWIrL0I7WUF1SXlCLDhCQURaLy9CO1dBQ2hCLHNCN0NoNkNMLE82QzBmUzRpRSxXQSt4QkozQztXQXVJNEIsSUF2SXpCbGdDLE1Bc0k2QnI3Qjs7O29CQXRJN0JxN0I7O2lCQXlJMENsN0IsUUF6STFDazdCLHlCQXlJK0IySjthQUNsQyxXQTFJQXUyQjthQTBJbUIsV0ExSW5CQTthQTJJYyxzQkFGb0J2MkIsTUFBVzdrQyxTQXpJMUNrN0I7O2VBNEkwQ2g3QixRQTVJMUNnN0IseUJBNEkrQm1LO1dBQ2xDLFdBN0lBKzFCO1dBNkltQixXQTdJbkJBO1dBOEljLHNCQUZvQi8xQixPQUFXbmxDLFNBNUkxQ2c3Qjs7O1dBK0RILElBRE82SyxTQTlESjdLO1dBK0RILEdBL0RPeW5DO2FBaUVLO2NBRElQLGFBaEVUTztjQWdFQ1QsT0FoRURTO2NBaUVLLGFBREpULE9BaEVSOUc7YUFrRWEsVUFETHg2RCxFQUNLLFdBbEVidzZELEdBOERPcjFCLFNBRVNxOEI7V0FJWjs7b0JBcEVEbG5DOzthQW9IWTtjQURpRDc2QjtjQUFac2pFO2NBQTFCdHNDLFdBbkh2QjZEO2NBb0hZLGtDQURxQ3lvQztjQUNyQzs7Y0FDSDthQUNaLHVCQUgwQnRzQyxjQUN0QnVzQyxPQUNBbjVCLFFBckhKMndCO2FBb0hlLElBR1AsaUJBdkhSQSxJQXVIUSxlQUhDemdDLE1BRHVEdDZCO2FBTXZELFVBRkx3akUsSUFFSyxXQXpIVHpJLEdBd0hJMEksV0F4SEduQjtXQTJISztZQUR3QnhpRSxRQTFIakMrNkI7WUEwSHVCcDdCLFNBMUh2Qm83QjtZQTJIUztXQUNaLHVCQUYwQnA3QixXQUN0QjIzQixNQTNISjJqQztXQTJIWSxJQUVSdnlDLElBQUksYUE3SFJ1eUM7V0E4SFMsVUFETHZ5QyxJQUNLLFdBOUhUdXlDLEdBMEhvQ2o3RCxRQTFIN0J3aUU7O1dBZ0lLO1lBRGV4MUIsUUEvSHhCalM7WUErSGVqN0IsUUEvSGZpN0I7WUFnSVMsa0JBaElaa2dDLEdBK0hrQm43RDtXQUVMLFVBRFR1d0IsTUFDUyxXQWpJYjRxQyxHQStIMkJqdUIsUUEvSHBCdzFCOztXQW1JUCxZQW5JR3puQyxTQW1JSyxzQkFuSVJrZ0M7V0FvSVMsVUFETHRwRCxJQUNLLFdBcElUc3BELEdBa0llaHVCLFFBbElSdTFCOztXQWlKcUI7WUFEUm9CLFFBaEpqQjdvQztZQWdKWTk2QixJQWhKWjg2QjtZQWlKeUIsdUNBRGI5NkIsSUFBSzJqRTtZQUNRO1lBQ2hCLG1CQWxKWjNJLEdBaUpxQnYxQixPQWpKZDg4QjtXQWtKSyxZQUNZLElBQWJxQixvQkFBYSxPQUFiQTtXQUNGO2tCQXZGVCxtREEyRkc7SUFoYTBCLFNBcWE3QmxCLGVBTUExSCxHQUFHempDLElBQUlnckMsUUFBUTdrRSxJQUFJRSxLQUFLaWxFLEtBQUt6WDtNQUFTLFVBQXZCMXREO2tCQUFJRTtVQXdCbkIsR0F4Qm1CQSxLQXdCbkI7VUF0QlEsV0FGZ0JpbEUsS2pDdjRDdEIxaEUsZ0JpQ3U0Q0Y2NUQ7VUFHUSxJQUFKeDZELEVBQUksV0FIcUI0cUQsTUFBN0I0UDtVQUlTLFVBREx4NkQsRUFDSyxXQUpUdzZELEdBQUd6akMsSUFBSWdyQztRQU1QLElBRDBCcHlELEVBTFB2UztRQU1YLFdBTmdCaWxFLEtqQ3Y0Q3RCMWhFLFFpQzQ0Q3dCZ1AsRUFMMUI2cUQ7UUFNQSxJQUNJenFELElBQUksV0FQcUI2NkMsTUFBN0I0UDtRQVFTLFVBREx6cUQsSUFDSyxXQVJUeXFELEdBQUd6akMsSUFBSWdyQzs7UUFBK0IsU0FBdkI3a0U7OztzQkFBSUU7Y0FvQm5CLEdBcEJtQkEsS0FvQm5CO2NBVlEsV0FWZ0JpbEUsVWpDdjRDdEIxaEUsUWlDdTRDRjY1RDtjQVdRLElBQUo5Z0IsSUFBSSxXQVhxQmtSLE1BQTdCNFA7Y0FZUyxVQURMOWdCLElBQ0ssV0FaVDhnQixHQUFHempDLElBQUlnckM7Z0JBYXlDMzJCLElBYjdCaHVDO1lBY1gsV0FkZ0JpbEUsVUFhd0JqM0IsSUFiaERvdkI7WUFlUSxJQUFKM2dCLElBQUksV0FmcUIrUSxNQUE3QjRQO1lBZ0JTLFVBREwzZ0IsSUFDSyxXQWhCVDJnQixHQUFHempDLElBQUlnckM7VUFrQlA7UUFJQSwrQ0FFMEM7SUFuY2IsU0EwYzdCc0IsT0FBTzdJLEdBQUc4STtVQUFpQmxsRSxhQUFMMjRCO2VBQ2hCd3NDLE1BQ0Y3akUsRUFBRTQ4QztZQUFGcEQsTUFBRXNxQjtRQUFRO2FBQVJBO1lBQ2lCO2FBQVpyL0QsRUFETHEvRDthQUNFeGpFLEVBREZ3akU7YUFDaUIsZUFEbkJ0cUIsSUFDSWw1QzthQURKazVDO2FBQUVzcUIsT0FDS3IvRDs7VUFDRixPQUZMKzBDLElBRU07ZUFFUm50QixFQUFFZzJDLFFBQVFyaUU7UUFDWixZQVBPODZEO1FBT1A7VUFDZSx1QkFSUkEsR0FBZXpqQyxJQU1sQmdyQztjQUdBMEI7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBQ2lCdHRELElBRGpCc3REOztjQUVBO2dCQUFZO2tCQURLdHRELElBQ0UscUJBQWtCLGlCQVhkL1g7O1VyQzM4QnZCLDBCcUNvOUJBcWxFOzswQkFJYSxJQUFSbm5CLGFBQVEsYUFQTDU4QyxFQU9INDhDO1FBQ00sSUFBUG1uQjtRQUFPLGtCQWRMSCxHQUFIOUksR0FjQ2lKLElBQWdCO2FBNVRwQmhDLG9CQW9URjExQyxFQU5vQmdMO0lBMWNPLFNBK2Q3QjJzQyxPQUFPbEosR0FBR3pqQyxLQUFNLGNBQVR5akMsR0F2V1B1RyxnQkF1V1VocUMsSUFBb0M7SUEvZGpCLFNBaWU3QjRzQyxRQUFROWpFLEVBQUV5akUsR0FBR3ZzQyxLQUFjLDRCQUFuQmwzQixHQUFFeWpFLEdBQUd2c0MsSUFBNkM7SUFqZTdCLFNBa2U3QjZzQyxPQUFPL2pFLEVBQUVrM0I7TUFBYyw0QkFBaEJsM0IsR0ExV1BraEUsZ0JBMFdTaHFDLElBQTBEO0lBbGV0QyxTQW9lN0I4c0MsTUFBTTlzQyxLQUFNLGNBOW5DVmlsQyxNQWt4QkYrRSxnQkE0V01ocUMsSUFBK0M7SUFwZXhCLFNBeWU3QitzQyxjQUdFdEosR0FBR3VKLE9BQU9ya0U7TUFDSixpQmpDejhDTmlCLFFpQ3c4Q0E2NUQ7TUFFUSxJQUFOcDhELElBQU0sYUFGUm84RDtNQUVRO1FBRUosaUNBRkZwOEQsSUFGQzJsRSxRQUdEaHRDOzs7O1FBRWtCLGVBRmxCQSxJQUVrQixVQUFQNWdCO01BQ2Ysa0JBTll6VyxFQUdScTNCLElBR0U7SUFsZnVCLFNBcWY3Qml0QyxjQUdFbmtFLEVBQUVra0UsT0FBT3JrRTtNQUFtQixtQ0FBNUJHLEdBQUVra0UsT0FBT3JrRSxFQUFvRDtJQXhmbEMsU0EyZjdCdWtFLG1CQUFtQnBrRSxFQUFFazNCO01BQ3ZCLGNBQXdELzJCLEdBQUssT0FBTEEsQ0FBTTtNQUFoRDs2QkFBUSxpQkFEREgsWUFBRWszQixTQUN3QztJQTVmaEMsU0ErZjdCbXRDLFVBQVVya0U7TUFDWixjQUFxQ0csR0FBSyxPQUFMQSxDQUFNO01BQXBDLHVDQUFRLE9BREhILHNCQUNnQztJQWhnQmIsU0FvZ0I3QnNrRSxRQUFRcGdFLEdBQUd1L0QsR0FBR3ZzQyxLQUFjLGdDQUFwQmh6QixJQUFHdS9ELEdBQUd2c0MsSUFBb0Q7SUFwZ0JyQyxTQXFnQjdCcXRDLE9BQU9yZ0UsR0FBR2d6QjtNQUFhLGdDQUFoQmh6QixJQTdZUGc5RCxnQkE2WVVocUMsSUFBZ0U7SUFyZ0I3Qzs7OztRQTFwQjNCaWxDO1FBYUFFO1FBQ0FDO1FBTUFFO1FBUEFIO1FBQ0FDO1FBdEhBVjtRQVdBQztRQTZHQVU7UUExTEF6QjtRQU9BQztRQUVBQztRQWlLQW1COztPQXluQ0YwSDtPQUdBRTtPQUVBQztPQTFCQVI7T0F1QkFNO09BUUFHO09BWUFFO09BTUFDO09BSUFDO09BTUFFO09BREFEO0lBcGdCNkI7YUM1L0I3QkUsU0FBUzdoRSxLQUFLZ0IsR0FDaEIsaUNBRFdoQixLQUFLZ0IsRUFDc0I7YUFFcEM4Z0UsbUJBQW1COWhFLEtBQ2pCMGhCO01BQ1UsSUFBVnhPLEtBQVUsYUFEVndPO01BRUosaUNBSHFCMWhCLEtBRWpCa1QsS0FDMEI7MkJBTjVCMnVELFNBR0FDOztvQkNBSzU2RCxHQUNVLElBQWI2NkQsSUFBYSxVQUNqQixzQkFESUEsSUFDSTtRQVlOQyx3QkFVQUMsc0JBT0FDO2lDQWVvQjdrRTtNQUN0QiwwQ0FEc0JBLFdBQ3RCOztZQUNBckU7UUFDRTtVQUFnQyx5QkFIWnFFLEVBRXRCckU7VUFDa0MsaUJBRjlCbUo7VUFFOEIsU0FEbENuSjs7O01BSUEsVUFMSW1KO01BQUosSUFPSWdnRSxpQkFQQWhnRTtNQVNKLE9BRklnZ0UsR0FFSzthQUsyQkMsV0FBUzVrRSxFQUFLQyxHQUFJLDJCQUFURCxFQUFLQyxFQUFlO3lDQUE3QjJrRTthQUlBQyxXQUFTN2tFLEVBQUtDLEdBQUksMkJBQVRELEVBQUtDLEVBQWU7SUFnQ3hDO3VDQWhDVzRrRTtLQUdEQzs7S0FnQmpDQyxvQkFyREFMO0tBK0RBTTtLQUd1QjthQUluQkUsU0FBUy9qRSxHQUNmLFdBRGVBLEVBRWYsVUFGZUEsNkJBRU87SUFORyxTQVF2QmdrRSxVQUFVQztNQUNaOztXQURZQTtPQUdFLHdCQURWaGlFLHFCQVZGNmhFO01BWUYsaUJBRElJLGdCQURBamlFO01BREosV0FJc0IsU0FIbEJBO01BR0osaUJBRklpaUU7TUFGSixJQUlBLEtBSElqaUUsWUFHSjs7WUFDQTVIO1FBQXdCO1VBQXlCO2lCQUFqREE7V0FBaUQsc0JBTnJDNHBFLFdBTVo1cEU7VUFBd0IsaUJBSHBCNnBFO1VBRzZDLFNBQWpEN3BFOzs7TUFDQSxVQXhGRWlwRSxvQkFvRkVZLHVDQVcwQjtJQXRCTCxTQXdCdkJDLFNBQU9DLE1BQU1DO01BQ2YsYUFEU0Qsb0JBQ1QsS0FBSUUsV0FEV0Q7TUFDZjtRQUVpQixJQUFYRSxTQUFXLGVBSEZGLFNBeEJiUDtRQTRCQSxPQUpPTSxXQUdIRyxXQUZGRDtRQUdGLFdBRElDO1FBQVc7OztNQWxCakIsV0FxQkU7SUE5QnVCO2FBNEN2QkcsV0FBV0M7TUFDYixJQUFJNWMsTUFEUzRjO01BRWIsU0FGYUEsTUFDVDVjO01BQ0osT0FESUEsS0FFQztJQS9Db0IsU0FpRHZCNmMsaUJBQWlCRCxNQUFNdGpFO01BQ3pCO1FBQ0UsOEJBRnVCQSxLQUFOc2pFOzs7O1VBSUwsSUFBUkUsTUFBUSxXQUpLRjtVQUtRLCtCQUxGdGpFLEtBSW5Cd2pFLE1BSmFGO1VBTVMsOEJBRnRCRSxRQUphRjtVQU1TLE9BRnRCRTtRQVJOLFdBV087SUF4RGtCLFNBMER2QkMsa0JBQWtCSCxNQUFNSTtNQUNoQiw0Qi9DcExiLE8rQzBLS0gsaUJBU2tCRCxhQUFNSSxNQUNjO0lBM0RmLFNBNkR2QkMsV0FBV0wsTUFBTUUsTUFBTUk7TUFDekI7TUFDRywyQkFGZ0JKLE1BQU5GO2dCQTVCYixTQTRCYUEsTUFBTUU7Z0JBM0JuQixpQkEyQmFGLFNBQU1FOztnQkFBTUk7O2dCQUFaTixpQkFBTUUsTUFBTUksU0FBWk4sWUFLaUQ7SUFsRXJDLFNBb0V2Qk8sV0FBV1AsTUFBTUU7TUFDbkI7UUFBSSxlQURlQSxNQUFORjs7OztTQUVLLHdCQUZMQSxTQUFNRTttQkFFb0I7SUF0RWQsU0F3RXZCTSxVQUFRQyxLQUNWLGFBRFVBLE1BQ3FCLFVBRHJCQSxJQUNzQztJQXpFdkIsU0EyRXZCQyxPQUFPVixNQUFNVyxLQUFLQyxXQUFXQztNQUNwQjt3QkFESUY7T0FFRSx1QkFGR0M7T0FHRix3QkFIYUM7T0FJVjs7eUIvQ3hNeEIsTytDMEtLWixpQkEwQk9ELGFBRUxlO09BR2tCOzt5Qi9Dek16QixPK0MwS0tkLGlCQTBCT0QsYUFHTGdCO01BRWtCOzs7VUFMYmhCLG9DQUlMaUIsZUFIQUg7T0FES2Q7TUFDRSxJQUlXLGtCQUxiQTtNQUthLGNBT2JtQixJQUFJbHBCLEtBQUttcEI7UUFDVCxXQURBRCxJQVhMTCxRQVk0QixtQkFEdkJLLElBQUlscEIsS0FBS21wQixZQUNnRDtNQUZoRTs7TUFNRjtpQkFDT0csSUFBSXJCO1VBQ0ssaUNBRFRxQixJQUFJckIsTUFIUG1CO1VBSVksU0FIWkM7VUFHWTtZQUdELDZCQUpKcEIsTUFsQkZGOzs7OztVQXFCRCxpQ0FIR0U7VUFHSCxRQUVXO1FBcEJmYztRQUVBRTtNQW9CSjtpQkFDT0ssSUFBSXJCO1VBQ0ssaUNBRFRxQixJQUFJckIsTUFYUG1CO1VBYWEsaUNBRk5uQixRQVZQb0I7VUFZYSxRQUE4QjtRQTFCM0NQO1FBRUFFO01BcUJKLFdBVklJO01BVUosV0FUSUM7TUFMRixJQWNGLFlBekJTdEI7TUFpQ047OztpQkFDT3VCLElBQWtCQztVQUF2QixJQUFPTCxJQUFGSSxPQUNDLFdBRENKLElBOUJSRixnQkE4QndCTyxNQUFsQkQsSUFBa0JDLEdBQ2dDOzs7TUFGekQsUUFJSTtJQWhIa0IsU0FrSHZCQyxNQUFNekI7TUFFTjtnQkFGTUE7T0FFTjs7Ozs7O01BRXVCLGNBSmpCQTtNQU1MOzs7aUJBQ09qbUUsRUFBRTJEO1VBQWdCLDZCQUFoQkEsRUFQSnNpRTtVQU9vQiwwQkFBaEJ0aUUsT0FBRjNELEVBQTRDO1FBTlYybkU7UUFBd0JmO01BS2pFLFdBTEVVO01BS0YsV0FMV0M7TUFDWixTQUZNdEI7TUFZTDs7O2lCQUNPdUIsSUFBa0JDO1VBQXZCLElBQU9MLElBQUZJLE9BQ0MsV0FEQ0osSUFaNENQLFlBWTVCWSxNQUFsQkQsSUFBa0JDLEdBQzRCOztRQWJoQ0c7TUFXckIsUUFJb0I7SUFsSUUsU0FvSXZCQyxTQUFTNUI7TUFDWCxJQUFJNWMsTUFETzRjLFNBQ1gsV0FBSTVjLGNBQUosT0FBSUEsS0FFQztJQXZJb0IsU0F5SXZCeWUsYUFBYTdCLE1BQU10akU7TUFDckI7UUFBSSw2QkFEaUJBLEtBQU5zakU7Ozs7VUFHRCxJQUFSNWMsTUFBUSxTQUhDNGM7VUFJVix3QkFKZ0J0akU7V0FJYyw4QkFKZEEsS0FHZjBtRCxNQUhTNGM7VUFLYixPQUZJNWM7UUFQTixXQVNPO0lBOUlrQixTQWdKdkIwZSxTQUFTckIsS0FDUixrQkFEUUEsY0FDNEI7SUFqSmQsU0FtSnZCc0Isc0JBQXNCL0IsTUFBTWdDLE1BQU1DO01BQ3hCO3dCQURrQkQ7T0FDbEIsT0FBUkU7T0FBUSxNQUR3QkQ7T0FHMUIsbUJBRE5FLFNBQWdDQztPQUMxQixLQURORDtPQUNNOztZQUNWcm1FO1FBQ0U7VUFBVzs7NkJBTFdra0UsTUFLWSxpQkFKaENrQyxRQUdKcG1FO1VBQ0UsaUJBRkVrRCxJQUNKbEQ7VUFDYSxTQURiQTs7O01BSFksSUFNWixLQUxvQ3NtRSxjQUtwQzs7O1FBQ0U7VUFBa0I7Z0JBRHBCMXNFLElBTEl5c0U7V0FNZ0Isa0JBUkluQyxNQVFlLGlCQVJIaUMsS0FPcEN2c0U7VUFDRSxpQkFMRXNKO1VBS2dCLFNBRHBCdEo7OztNQUdBLE9BUElzSixHQU9EO0lBN0pzQixTQStKdkJxakUsYUFBYXJDLE1BQU10akU7TUFDckI7UUFBSSw2QkFEaUJBLEtBQU5zakU7Ozs4QkFDaUM7bUJBQVk7SUFoS25DLFNBa0t2QnNDLGNBQWN0QyxNQUFNSTtNQUNaLDRCL0M1UmIsTytDd1JLaUMsYUFHY3JDLGFBQU1JLE1BQ2M7SUFuS1gsU0FxS3ZCbUMsZ0JBQWdCdkMsTUFBTXBtRSxHQUN4QixjQUR3QkEsRUFBTm9tRSxVQUNsQixRQUEyQztJQXRLbEIsU0FtTHZCd0MsYUFBYUM7TUFDZixTQURlQSxlQUNtQjtNQUV2QjtzQ0FISUE7T0FJSCxnQkFEUkM7TUFFSjtpQkFDT2h0RSxFQUFFNnJFO1VBQ0wsSUFBSUosS0FERHpyRTtVQUV1QiwrQkFGckI2ckUsSUFDREosSUFISm5CO1VBSzBCLDhCQUZ0Qm1CLE1BSEpuQjtVQUswQixRQUF3QztRQVR2RHlDO01BS2YsT0FESXpDLEtBT0M7SUE5TG9CLFNBZ012QjJDLFdBQVczQztNQUNiLHFCQTFKRUYsb0JBeUpXRTtNQUVTLGVBRlRBO01BR1c7ZUFIWEE7cUJBR1csaUJBSFhBLHVDQUdrRDtJQW5NdEMsU0FxTXZCNEMsU0FBU0MsSUFBSVosS0FBS3JCLFdBQVdDLGtCQUErQnQ1QztVQUFMN0ssYUFBVm9tRDtNQUMvQyxPQURXRCxJQUFJWixLQUFLckIsV0FBV0M7TUFDL0IsSUFDSTd2RCxLQUYwRHVXLElBR2hELFdBSGlDdTdDLFFBQXBDRCxJQUE4Q25tRCxLQUdmLFdBSEtvbUQsUUFBcENEO01BSVgsTUFKV0E7TUFDWDtPQUdBO09BTUssY0FWMEJoQztPQVE1Qjs7O29CQUNPa0MsSUFBMkIsa0JBVDFCRixJQVMwQixpQkFUMUJBLElBU0RFLElBQStEOztPQUZsQyxjQVB4QmQ7TUFNWjs7bUJBSkNqeEQ7O2lCQUtNLHFCL0NyVWIsTytDd1JLcXhELGFBc0NTUTs7SUFyTWMsU0FpTnZCRyxXQUFXQyxVQUFVQztNQUNYLHVCQURDRCxXQUVFLG9CQUZRQyxXQUNuQmxEO01BRUosV0FGSUE7TUFHSCxxQkFGR21ELFlBRm1CRCxXQUVuQkMsV0FFcUQ7SUFyTmhDLFNBeU52QkMsaUJBQWlCSCxVQUFVQyxXQUFXRztNQUM1Qix1QkFET0osV0FFSixvQkFGY0MsV0FDekJsRDtNQUVKLFdBRklBO01BRUosZ0JBSDZCa0Q7TUFHN0IsZ0JBRElDO01BQ0osUUFFK0I7SUE5Tk4sU0FnT3ZCRyxZQUFZQztNQUNkLFNBQUlDLGFBQWlCLG9DQURQRCxJQUM2QztNQUEzRCxVQUFJQyxvQkFDdUM7SUFsT2xCLFNBc092QkMsY0FBY3pEO01BRU4sSUFBTnh4RCxJQUFNLG1CQUZNd3hEO01BSWhCLFNBSmdCQTtNQUtSLHNCQUhKeHhELElBR2dCO0lBM09LLFNBNk92QmsxRCxrQkFBa0JDLE1BQU0zRDtNQUMxQixHQURvQjJELE1BQ2EsT0FEYkE7TUFHUixJQUFObjFELElBQU0sbUJBSGN3eEQ7TUFLeEIsU0FMd0JBO01BTWhCLHNCQUhKeHhELElBSUg7SUFwUHNCLFNBc1BuQm8xRCxPQUFPcDFEO00vQy9XaEI7OztjK0NrWFEzUyxhQUFIakM7VUFBUSxXQUFSQSxFQUhXNFU7c0JBR1IzUzs7UUFESztJQXhQZSxTQTJQdkJnb0UsaUJBQWlCcjFELElBQUl3eEQ7TUFDdkIsVUFEdUJBLFNBQ3ZCLFdBQUk4RDtNQUFKLFlBRUUsT0FIaUJ0MUQsSUFDZnMxRCxXQUVjO0lBOVBPLFNBZ1F2QkMscUJBQXFCSixNQUFNbjFELElBQUl3eEQ7TUFDakMsR0FEdUIyRCxNQUNVLE9BREpuMUQ7TUFDYSxJQUNwQ3MxRCxNQUYyQjlEO01BQ1MsU0FDcEM4RCxNQUNnQixPQUhPdDFELElBRXZCczFEO01BQ2dDLE9BSFR0MUQsR0FLMUI7SUFyUXNCLFNBdVF2QncxRCwrQkFBbUNMLE1BQU0zRDtNQUMzQyxHQURxQzJELE1BQ0osT0FESUE7TUFFekIsSUFBTm4xRCxJQUFNLGNBRitCd3hEO01BR3pDLGlCQURJeHhELElBRnFDd3hEO01BR3pDLE9BREl4eEQsR0FHSDtJQTVRc0IsU0F1U3ZCeTFELFdBRUt4NkQ7TUFGTSxHQUVOQSxNQUFVLE9BQVZBLFNBREksNkJBQ2lCO0lBelNILFNBOFN2Qnk2RCxXQUFXN29FLEVBQUU4b0UsS0FBSzltRDtNQUNwQix1QkFBSXJlLEtBQUo7WUFEYTNEO1lBR2IzRjtRQUNFO21CQUZFMkk7VUFFZSwyQkFKSjhsRSxLQUdmenVFO1VBQ0UsU0FERkE7YUFIYTJGLE1BR2IzRjs7TUFGQSxTQUNJMkk7TUFsQmtCLEdBZ0JGZ2YsUUFkSCx3QkFlYnJlO01BaEJPLDZCQXNCUjtJQXJUc0IsU0EwVXZCb2xFLGNBQWNDLEtBbkJJRjtNQW9CZCxJQXBCbUJHLFNBb0JuQixXQURVRDtNQUNWLEdBcEJtQkM7UUFzQnZCLFFBdEJrQkgsd0JBQUZ6dUUsTUFBTzJuQjs7UUFDekI7a0JBRGtCM25CO1lBRVIseUJBRlV5dUUsS0FBRnp1RSxVQUdFNnVFLFNBSEtsbkQ7WUFJdkI7Y0F2QlUsR0FzQlFrbkQ7bUNBRGhCNXlCO2tCQUdNLElBTGU2eUIsU0FLZixXQUZVRDtrQkFFVixHQUxlQztvQkFRakIsUUFSVTl1RSxnQkFBTzJuQjtrQkFNVjtnQkFuQkYsR0FnQk9rbkQ7a0JBZEgsU0FjR0E7O2tCQWRILElBWEM3bUUsS0F3QmRpMEM7a0JBeEJrQixHQXlCRjR5QjtvQkF2QkgsY0FGQzdtRSxTQWFoQndtRSxXQVNnQnh1RSxVQUFFeXVFLEtBdEJGem1FO2tCQUNQO2dCQVNBO2NBTkE7VUFtQkcsT0FEVzJmO01Bd0J2QixrQkF4QmtCOG1ELDZCQW1CSkUsS0FLOEI7SUEvVXJCLFNBa1l2QkksVUFBVXpFO01BQ0osaUJBRElBO01BR3NCOzs7U0FGOUIza0U7OztnQkFFOEIsaUJBSHRCMmtFLDBDQUNSM2tFO1lBQ0F3TixJQUVVLFdBSkZtM0Q7TXZDcUJOLGtCdUNuQkZuM0QsSUFEQXhOO01BS0osaUJBTlkya0UsU0FFUm4zRDtNQUlKLE9BSklBLEdBS0g7SUF6WXdCLFNBNmR2QjY3RCxZQUFZMUUsTUFBTVQ7TUFDcEIsUUFEb0JBLG1CQUNwQjs7V0F4RG9CN3BFLE9Bd0RoQjRIO1VBRUY7Z0JBMURrQjVIO1dBMEROLHVCQUhNNnBFO1dBdERwQjs7Y0FBYzt1QkFETTdwRTtjQUNRLHdCQXNEUjZwRSx1QkF0RGdCO1dBQzlCO29CQW1ESm9GOzs7Y0FsRHdCOztlQXVEUUMsTUE3SWxCLFNBQUoxcUUsRy9DNWNmLGdCK0M0YzRCc1UsS0FBUSxPQUFyQnRVLENBQXNCLEdBQXRCQTs7O2NBdUZVOztlQXNEWTBxRSxNQTVJbEIsU0FBTnZwRSxHL0M3Y2IsZ0IrQzZjNEJtVCxLQUFPLE9BQVBBLFFBQWZuVCxFQUE0QyxHQUE1Q0E7OztjQXVGWTs7ZUFBa0I7ZUFxRE51cEU7Z0JBMUlsQyxTQURVei9ELEVBQUU5SixHL0M5Y2YsZ0IrQytjWW1ULEtBQ1AsT0FET0EsUUFEQ3JKLE9BQUU5SixFQUVtRDtrQkFGckQ4SixFQUFFMEQ7OztjQXVGVTs7ZUFvRFkrN0Q7Z0JBeElsQixTQUFMdnBFO21CL0NqZGQsZ0IrQ2lkNEJtVCxLQUFPLGtCQUFQQSxXQUFkblQsR0FBY21ULElBQXFCO2tCQUFuQ3pGOzs7Y0FxRlc7O2VBbURZNjdEO2dCQXZJbEIsU0FBTnZwRSxHL0NsZGIsZ0IrQ2tkNEJtVCxJQUFJdFUsR0FBSyxRQUF4Qm1CLEtBQW1CbkIsRUFBSyxRQUF3QjtrQkFBaEQycUU7OztjQXFGWTs7ZUFBa0I7ZUFrRE5EO2dCQXRJaEIsU0FBTmhyRSxFQUFFTSxHL0NuZGpCLGdCK0NtZDhCc1UsS0FBUSxrQkFBdkI1VSxFQUFFTSxFQUF3QjtrQkFBMUJOLEVBQUVxUTs7O2NBcUZROztlQUFrQjtlQWlETjI2RDtnQkFySWhCLFNBQVJockUsRUFBRXlCO21CL0NwZGYsZ0IrQ29kOEJtVCxLQUFPLGtCQUF4QjVVLEVBQWlCNFUsUUFBZm5ULEdBQWdEO2tCQUFsRCszQyxJQUFFMHhCOzs7Y0FzRkE7O2VBQW1CO2VBQWtCO2VBK0NmRjtnQkFuSWxDLFNBRFVockUsRUFBRXVMLEVBQUU5SjttQi9DcmRqQixnQitDc2RZbVQ7cUJBQ1Asa0JBRlE1VSxFQUNENFUsUUFER3JKLE9BQUU5SixHQUVxRDtrQkFGekRnNEMsSUFBRXZoQyxJQUFFaXpEOzs7Y0F1RlE7O2VBQWtCO2VBNkNOSDtnQkFqSWhCLFNBQVBockUsRUFBRXlCO21CL0N4ZGhCLGdCK0N3ZDhCbVQ7cUJBQVMsa0JBQXpCNVUsRUFBeUIsV0FBVDRVLFdBQWRuVCxHQUFjbVQsS0FBeUI7a0JBQXpDK2tDLElBQUV5eEI7OztjQXNGRDs7ZUFBa0I7ZUFBa0I7ZUEyQ2RKO2dCQWhJUixTQUFSaHJFLEVBQUVNLEVBQUVDO21CL0N6ZHpCLGdCK0N5ZHNDcVUsS0FBUSxrQkFBekI1VSxFQUFFTSxFQUFFQyxFQUEwQjtrQkFBOUJ1NUMsSUFBRUUsSUFBRXo1Qzs7O2NBd0ZWOztlQUFrQjtlQUFrQjtlQXdDZHlxRTtnQkEvSFIsU0FBVmhyRSxFQUFFTSxFQUFFbUI7bUIvQzFkdkIsZ0IrQzBkc0NtVCxLQUFPLGtCQUExQjVVLEVBQUVNLEVBQWlCc1UsUUFBZm5ULEdBQWtEO2tCQUF0RDQ0QyxJQUFFRixJQUFFa3hCOzs7Y0EwRlI7O2VBQWtCO2VBQWtCO2VBQW1CO2VBcUNqQ0w7Z0JBMUhsQyxTQURnQmhyRSxFQUFFTSxFQUFFaUwsRUFBRTlKO21CL0M5ZHpCLGdCK0MrZFltVDtxQkFDUCxrQkFGYzVVLEVBQUVNLEVBQ1RzVSxRQURXckosT0FBRTlKLEdBRStDO2tCQUZyRDg0QyxJQUFFK3dCLElBQUU5aUQsSUFBRStpRDs7O2NBeUZWOztlQUFrQjtlQUFrQjtlQWtDZFA7Z0JBOUhULFNBQVJockUsRUFBRU0sRUFBRW1CO21CL0MzZHhCLGdCK0MyZHFDbVQ7cUJBQVcsa0JBQTVCNVUsRUFBRU0sRUFBMEIsV0FBWHNVLFdBQWJuVCxHQUFhbVQsS0FBMkI7a0JBQTVDNGxDLElBQUVneEIsSUFBRUM7OztjQStGVDs7ZUFBa0I7ZUFBa0I7ZUErQmRUO2dCQTdIVixTQUFSaHJFLEVBQUV5QixFQUFFbkI7bUIvQzVkdkIsZ0IrQzRkb0NzVSxLQUFPLGtCQUF4QjVVLEVBQWlCNFUsUUFBZm5ULEdBQUVuQixFQUFnRDtrQkFBcERvckUsSUFBRUMsSUFBRUM7OztjQWlHUjs7ZUFBa0I7ZUFBbUI7ZUFBa0I7ZUE0QmpDWjtnQkF2SGxDLFNBRGdCaHJFLEVBQUV1TCxFQUFFOUosRUFBRW5CO21CL0NqZXpCLGdCK0NrZVlzVTtxQkFDUCxrQkFGYzVVLEVBQ1A0VSxRQURTckosT0FBRTlKLEdBQUVuQixFQUUrQztrQkFGckR1ckUsSUFBRUMsSUFBRUMsS0FBRUM7OztjQStGVjs7ZUFBa0I7ZUFBa0I7ZUF5QmRoQjtnQkE1SFQsU0FBUmhyRSxFQUFFeUIsRUFBRW5CO21CL0M3ZHhCLGdCK0M2ZHFDc1U7cUJBQVMsa0JBQTFCNVUsRUFBMEIsV0FBVDRVLFdBQWZuVCxHQUFlbVQsS0FBYnRVLEVBQXdDO2tCQUE1QzJyRSxJQUFFQyxLQUFFQzs7O2NBc0dUOztlQUFrQjtlQXNCSW5CO2dCQXJIWCxTQUFOdnBFLEVBQUVuQjttQi9DcGV0QixnQitDb2VtQ3NVO3FCQUFPLGtCQUFQQSxXQUFmblQsR0FBZW1ULElBQWJ0VSxFQUErQztrQkFBakQ4ckUsS0FBRUM7OztjQWlHUDs7ZUFBa0I7ZUFvQklyQjtnQkFuSGxDLFNBRGV2cEUsRUFBRW1kO21CL0NyZXBCLGdCK0NzZVloSztxQkFBTyxrQkFBUEEsV0FETW5ULEdBQ05tVCxZQURRZ0ssR0FDaUQ7a0JBRG5EMHRELEtBQUUxdEQ7OztjQWtHTDs7ZUFBa0I7ZUFBa0I7ZUFrQmRvc0Q7Z0JBakhsQyxTQURldnBFLEVBQUU4SixFQUFFcVQ7bUIvQ3ZldEIsZ0IrQ3dlWWhLO3FCQUFPLGtCQUFQQSxXQURNblQsR0FDTm1ULFlBRFFySixPQUFFcVQsR0FFZ0Q7a0JBRnBEMnRELEtBQUVDLElBQUVyZ0Q7OztjQW1HUDs7ZUFBa0I7ZUFlSTYrQztnQkE5R2xDLFNBRGdCdnBFLEVBQUVtZDttQi9DMWVyQixnQitDMmVZaEs7cUJBQWlDLG9CQUFqQ0EsV0FEU2dLLEdBQ1RoSztxQkFBaUMsa0JBQWpDQSxXQURPblQsR0FDUG1ULFNBQWlEO2tCQUQxQzYzRCxLQUFFei9DOzs7Y0FrR047O2VBQWtCO2VBQXlCLFlBVXpDbzVDO2VBR29CNEU7Z0JBNUdsQyxTQURhcHNELEVBQUV0ZSxFQUFFeUM7bUIvQzVlcEIsZ0IrQzZlWTZSO3FCQUFPLHlDQUREdFUsRUFBRnNlLEtBQUV0ZSxFQUFFeUMsRUFDdUM7a0JBRDNDMnBFLElBQUVDLElBQUU1cEU7OztjQWtHTDs7ZUFBa0I7ZUFBd0IsY0FReENxakU7ZUFHb0I0RTtnQkExR2xDLFNBRFdwc0QsRUFBRW5kLEVBQUVzQjttQi9DOWVsQixnQitDK2VZNlI7cUJBQ1AsU0FET0EsUUFESW5UO3FCQUVYLDhDQUZTbWQsVUFBSTdiLEVBR2U7a0JBSG5CNnBFLElBQUVDLEtBQUV0N0Q7OztjQWtHSDs7ZUFBa0I7ZUFBa0I7ZUFDN0IsY0FLTDYwRDtlQUdvQjRFO2dCQXRHbEMsU0FEV3BzRCxFQUFFclQsRUFBRTlKLEVBQUVzQjttQi9DbGZwQixnQitDbWZZNlI7cUJBQ1AsU0FET0EsUUFESXJKLE9BQUU5SjtxQkFFYiw4Q0FGU21kLFVBQU03YixFQUtlO2tCQUxyQitwRSxJQUFFQyxJQUFFQyxLQUFFeDdEOzs7Y0FpR0w7O2VBQWtCO2VBQXlCLGNBR3pDNDBEO2VBR29CNEU7Z0JBaEdsQyxTQURZcHNELEVBQUVuZCxFQUFFc0I7bUIvQ3hmbkIsZ0IrQ3lmWTZSO3FCQUNHLG9CQURIQSxXQURLblQsR0FDTG1UO3FCQUNHLDhDQUZBZ0ssVUFBSTdiLEVBRXlDO2tCQUY3Q2txRSxJQUFFQyxLQUFFejdEOztlQWlHa0J1NUQsTUFMaENEO1VBTUEsV0FKWTNFLE1BR1JFLE1BQTRCMEU7VUFDaEM7O1FBMURZLFNBNERWO0lBbmVxQixTQTBldkJtQztNQUNGLFVBOWVFN0gsZUF5Q0FXLGdCQUNBQyxrQkFxY3VEO0lBNWVoQzs7OztPQTRDdkJDO09BNkZBOEI7T0FVQUU7T0FZQU07T0FHQUM7T0FqSEFyQztPQVNBRTtPQVVBSTtPQVBBRjtPQWdhQXFFO09BbFpBaEU7T0F1Q0FlO09BbURBYztPQWxMQXREO09BZ01BdUQ7T0FhQUc7T0FLQUM7T0FZQUk7T0FRQUk7T0FPQUU7O09BTUFHO09BT0FDO09BY0FHO09BS0FFO09BT0FDO09BbUVBSTtPQTdaQTFGO09BNmpCQXFJO0lBMWV1Qjs7Ozs7Ozs7O0tDL0ZOO2VBQWpCQztLQUFpQjthQUtqQkc7TUFBa0IsWUFMbEJILGVBS2tCLHNCQUFxQztJQUx0QyxTQU9qQkksTUFBTXpxRTtNQUNSLHdCQU5Fc3FFLGNBQ0FDO1FBTWdCLElBQVpHLFVBQVksc0JBTmhCSDtRQU9BLEtBUkFELFlBT0lJLFlBTkpIO1FBT0EsWUFESUc7TUFJTixlQVhFSixVQUNBQyxVQUlNdnFFO01BTVI7Y0FDVztJQWRRLFNBZ0JqQjJxRTtNQUNNLElBQUp2dEUsRUFBSSxXQWZOa3RFLFlBQ0FDO01BY00sWUFqQk5GO01BaUJNLE9BQUpqdEUsQ0FBcUU7SUFqQnRELFNBcUJqQnd0RSxXQUFXQztNQUNHLElBQVpDLFVBQVk7TUFDaEI7aUJBQWUxdEUsR0FBSyxvQ0FEaEIwdEUsVUFDVzF0RSxRQUFvQztRQUZ0Q3l0RTtNQUViLFNBQ0lFLGlCQUFpQjczRDtRQUNuQjtVQUFJLHNDQUhGNDNELFVBRWlCNTNEOzs7Z0NBRUosVUFGSUE7VUFERCxXQUdLO01BSHpCLFNBSUk4M0QsaUJBQWlCaHJFO1FBQ1gsSUFBSjVDLEVBQUksU0FEVzRDO1FBQ1g7VUFDSixzQ0FQRjhxRSxVQU1FMXRFOzs7O1dBRStCLDRDQUYvQkE7VUFISixXQUs4RDtNQVBoRSxTQXNJSTZ0RSxRQVdtQi84QztRaERsTTFCO1FnRHdMSztVQUFNLGlCQVVlQTtVQVZmOzs7OztnQkFDUSxLQVNPQTtnQkFKZixtQkFJZUE7Z0JBSmY7d0NBQ1EsS0FHT0EsTUFIK0IsUUFHL0JBO2tCQUZULEtBRVNBOztnQkFEZDs7O2dCQVBPLEtBUU9BO2dCQUNyQjtrQkFBTSxtQkFEZUE7a0JBQ2Y7O29DQUNRLEtBRk9BLE1BRVA7b0NBQ0EsS0FIT0E7b0JBSVQsS0FKU0E7O2tCQUtkO1lBWkssS0FPU0E7O1VBTmQsZ0JBQW9CO01BM0k3QixTQTJHSWc5QyxPQUFRaDlDO1FBQ0osaUJBRElBO1FBQ0o7Ozs7OztzQkFDUSxLQUZKQSxNQUVJO3NCQUNBLEtBSEpBLE1BR0k7c0JBQ0EsS0FKSkEsTUFJSTs7OzthQUVWLEtBTk1BO2FBT00sbUJBUE5BO2FBT007OztpQkFFUixLQVRFQTtpQkFVVSxtQkFWVkE7aUJBVVU7OztxQkFFUixLQVpGQTtxQkFZRTs7Ozs7Ozs7OztpQkFJRzthQUVKO1VBRUMsS0FwQkZBO1VBb0JFO1FBQ0wsZUFBb0I7TUFoSTdCLFNBaUZJaTlDLGtCQUFtQmo5QztRQUNyQjtVQUFNLGlCQURlQTtVQUNmOzt1Q0FFRixLQUhpQkEsTUFHcUI7VUFDUyxrQ0FBZixpQkFBaUI7TUFyRnZELFNBNEVJazlDLGNBQWVsOUM7UUFDWCxpQkFEV0E7UUFDWDs7O1V4Q2taRjtZd0NoWkEsS0FIYUEsTUFHeUIscUNBSHpCQTtRQUlWLHlCQUpVQSxLQUljO01BaEZqQyxTQTRESW05QyxPQWMwQmp1RTtRQWI1QjtVQUFNLGlCQWFzQkE7VUFidEI7Ozs7O2N4Q2thRixhd0M1WkEsS0FPd0JBLEdBUGMsK0JBT2RBOzs7Z0JBVHhCLEtBU3dCQTtnQkFUYztnQkFLMUM7a0JBQU0sbUJBSXNCQTtrQkFKdEI7Ozs7aURBRUYsS0FFd0JBLEdBRmM7Ozs7d0JBRXRDLEtBQXdCQSxHQUFjLCtCQUFkQTtrQkFDdUIsa0NBQWY7NkJBWmhDLEtBV3dCQSxHQVhjO1VBS0ssZ0NBQWYsaUJBQWlCO01BcEVuRCxTQStDSWt1RSxPQUFRcDlDO1FBQ1Y7VUFBTSxpQkFESUE7VUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1l4QythRixhd0MzYUEsS0FMTUEsTUFLZ0M7VUFDOUIsMkJBQWtCLGdCQUFnQjtNQXJEaEQsU0FzRElxOUMsV0FJTW51RTtRQUhGLGlCQUdFQTtRQUhGOzs7WUFFRixLQUNJQSxHQUFjLGdCQUFpQixVQUFXLDBCQUExQ0E7UUFDaUI7UUFBaUI7c0JBRGxDQSxFQUNxRDtNQTNEL0QsU0F5Q0ltMUIsTUFBT3JFO1FBQ1Q7VUFBTSxpQkFER0E7VUFDSDs7Ozs7Ozs7Ozs7OztZeENxYkYsYXdDbGJBLEtBSktBLE1BSWlDO1VBQzlCLDJCQUFrQixnQkFBZ0I7TUE5Q2hELFNBU1FzOUMscUJBeUZFdDlDO1FBeEZSO1VBQU0saUJBd0ZFQTtVQXhGRjs7Ozs7Ozs7Ozs7Ozs7cUJBeUJGLEtBK0RJQTtxQkE5RGM7cUJBbUR0Qjt1QkFBTSxtQkFXRUE7dUJBWEY7O3lDQUNTLEtBVVBBLG1CQVZPOzsyQkFFWCxLQVFJQTsyQkFSSjs2QkFFTSxJQURGMWYsSUFDRSxPQU1GMGY7OzttREFMa0I7OzsyQkFFSixNQUpkMWY7O3lCQUtJLEtBRUowZjt5QkFGMEM7O3VCQUMzQzs7cUJBeEVILEtBeUVJQTtxQkF6RUo7dUJBMEVFLG1CQURFQTt1QkFDRixhQU9DO3VCQVBEOzt5QkFFRixLQUhJQTt5QkFHSjsyQkFDVSxnQkFKTkE7OztpREFLZ0I7MkJBR2pCOzZCQWhGQ2x1Qjs7eUJBK0VJLEtBUEprdUIsVUF4RUFsdUI7Ozs2Q0FFa0I7O3FCQUVWLG1CQW9FUmt1Qjs7dUJBbkVXLEtBbUVYQSxNQW5FVyxhQUxYbHVCO3FCQU1HOztxQkFNRyxLQTRETmt1QjtxQkE1RE07OzhCQTJGWnU5Qyx3QkEvQk12OUM7bURBK0JOdTlDLGlCQS9CTXY5Qzs0QkE3RE0sS0E2RE5BLE1BN0RNLGtCQTZETkE7Ozs7Ozs0QkF0RkosS0FzRklBOzs7Ozs7Ozs7OztxQkE1RUosS0E0RUlBLE1BM0VjLGdCQUFpQiwwQkEyRS9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WXhDNlhKO3FCd0N4YlEsS0EyREpBLE1BM0Q2Qjs7ZUF6QmpDLEtBb0ZJQSxNQW5GYyxnQkFBaUIseUJBbUYvQkE7O2VBL0VKLEtBK0VJQSxNQTlFYyxnQkFBaUIsMEJBOEUvQkE7VUExREQsU0FBSTtNQXhDYixTQWlJSXU5QyxzQkFBZXY5QztRQUNYLGlCQURXQTs7VUFHYixLQUhhQTtVQUd5QixRQUh6QkE7VUFHeUI7aURBM0hwQ3M5Qyx1QkF3SFd0OUM7d0NBeEhYczlDLGdCQXdIV3Q5QztRQUlMLCtCQUFzQjtNQXJJcEMsU0FTUXc5QyxXQXlGRXg5QyxNaERuSmIsdUJnRDBEV3M5QyxlQXlGRXQ5QztNQWxHVixnQkF3Skk3c0I7UUFBUyxxQkFBaUI4ckIsT0FBVSxrQkFBcEM5ckIsTUFBb0QsRUFBQztJQS9LdEMscUJBcUJqQnVwRTtJQXJCaUI7SUNVRjtNakRwQ3BCLElpRHNFU3BwQix5QmpEdEVUO2VpRHdFU2p1QyxPQUFTNkssSUFBcUNzakM7UUFDaEQsR0FEV3RqQztTQUFTLFFBQVRBLGNBQVNDOzthQUFUc2pDLE9BQVM7WUFQQXBrRDtRQUNwQjtVQUNLLE1BSzJDbWtELGdCQVA1Qm5rRDtZQUdmLFFBSGVBO2FBT1Rva0Q7V0FFZTs4QkFKeEJIO1lBSXdCLGtCQUp4QkEscUJqQjNDSi8wQixpQmlCMkNJKzBCO1lBSUV2QyxLQUFzQjs7ZUFBdEJBO1VBQzhDLDJCQVY5QjFoRCxLQVNoQjBoRCxLQVRnQjFoRCxHQVVrRDtlQUVwRWd0QixNQUFNdlI7UUFDUjtnQkFEUUEsZ0JBQ1IsS0FDSXJZLFlBREo7O2NBRUE1SDtVQUNFOzZCQUpNaWdCLEtBR1JqZ0I7WUFDRSxTQURGQTs7O2dCQUVJO2VBRUYyMkIsTUFBTTFXO1FBQ1IsSUFBSXJZLElBRElxWTtRQUNSLE9BQUlyWSxRQURJcVk7aUJBR04sTUFITUE7a0NBTUksZUFOSkEsVUFPTDtlQUVENnJDLEtBQUt4d0M7UUFBSSxTQUFKQSxRQUFJLEtBQUpBLFFBQW9CLFlBQXBCQTtRQUFvQixVQUFwQkEsdUJBQXVDO2VBRTVDMnZDLFVBQVVockMsRUFBRTJ5RCxNQUNkLE9BRGNBLFFBQUYzeUQsd0JBQ3VCO2VBRWpDNHlELE1BQU01eUQ7UUFDUixTQUFRK3BDO1VqRG5HZjtVaURtRzJCOztrQ0FHTDlwRCxnQkFBSCtHO2NBQWtCLG1CQUFsQkE7b0JBR005RyxrQkFBSHNWO2dCQUNLLGVBRExBLElBQ0ssVUFERnRWO2NBRlosT0FMRThmOzBCQUlPL2Y7O1lBRFQsU0FLNkI7UUFQbkMsTUFEUStmLEtBQ1IsS0FTSTlDLHFCQVRKOztjQVVBbmQ7VUFDRTtZQUFTLG1CQUFVLGlCQUZqQm1kLEVBQ0puZDtZQUNFLGlCQUZFbWQsRUFDSm5kO1lBQ1csU0FEWEE7OztnQkFFSTtlQXNCRjQyQixPQUFPM1c7UUFDVCxVQURTQSxLQUNULE1BQUlxcEMsaUJBQUosTUFDSUM7UUFFSixNQUpTdHBDO1FBQ1Q7U0FHQSxLQURJdXBDO1NBQ0osV0FGSUQsb0JBRkt0cEM7UUFLcUQ7VUFDaEQsSUFBUndwQyxNQUFRLGVBSFZEO1VBR1UsT0FBUkM7VUFBUTs7O2NBRVk7b0JBRUh2cEQsY0FBTjB2QixjQUFOZ2pEO2dCQUNILGNBRGUxeUU7Z0JBRUo7Z0NBWlYrZixFQVVFMnlEO2lCQUc4QixRQUg5QkEsS0FBTWhqRCxLQUd3QixpQkFQbkM2NUIsTUFNTUk7Z0JBQ0osaUJBUEZKLE1BTU1JO2dCQUNKO2NBSk8sUUFJdUM7V0FQeEMsS0FKVk47V0FJVTs7Z0JBUVp2cEQ7WUFDRTs0QkFBYyxpQkFkZHNwRCxNQWFGdHBEO2NBQ0UsU0FERkE7OztVQVJZOzs7UUF4Q00sV0FtRGpCO2VBRUQycUIsSUFBSTFLLEVBQUVnOEIsSUFBSXNHO1FBQ0Q7OEJBREx0aUMsS0FBRWc4QjtTQUVBLFlBRkZoOEIsRUFDRjJ5RDtTQUVZLDBCQUhSMzJCLElBQUlzRztTQUl1QixVQUgvQnF3QixLQUVBRyxVQUMrQixpQkFKN0I5eUQsS0FFRmpnQjtRQUdKLGlCQUxNaWdCLEtBRUZqZ0IsWUFFQWtyRDtRQUNKLE9BTE1qckM7UUFDSyxTQURMQTtRQUtOLFlBRTJDLE9BUHJDQSxPQU82QztlQUVqRDRMLE9BQU81TCxFQUFFZzhCO1FBQ0EsSUFBUDIyQixLQUFPLGdCQURGM3lELEtBQUVnOEI7UUFDQSxTQUNIKzJCO1VqRG5LZjtVaURtSytCOztrQkFFZkMsY0FBT3ZtRSxnQkFBSHpGO2lCQUhUMnJFLFNBR0tLO2dCQUNTLDBCQURMaHNFLEVBSkZnMUM7Z0JBS087eUJBQ0QsT0FOUmg4QixhQU1RLE9BRkR2VDt5QkFHYyxVQUhyQnVtRSxHQUFJaHNFLEVBR2lCLGNBSGR5RjswQkFPTixPQVhEdVQseUJBSU92VDtrQkFVRnU4QyxrQkFBRnh6QztjQUF1QixVQVYxQnc5RCxHQVVHeDlELElBQXVCLGNBQXJCd3pDO1lBWEQsU0FXeUM7UUFDOUM7cUJBZkNocEMsRUFDTDJ5RDtTQWVVLG1CQUFjLGlCQWhCbkIzeUQsS0FlTGpnQjtRQUNKLGlCQWhCU2lnQixLQWVMamdCO1FBQ0osUUFBc0M7ZUEwQnBDNnRCLEtBQUs1TixFQUFFZzhCO1FBQ0U7OEJBREpoOEIsS0FBRWc4QjtTQUdrQixlQUhwQmg4QixFQXBCWTJ5RDtTQXVCRCx5QkFIWDN5RDs7OztnQkFqQkFnekQsWUFBTy95RSxjQUFIK0c7ZUFIUTJyRSxTQUdaSztjQUNTLDBCQURMaHNFLEVBaUJGZzFDO2NBaEJPOztpQkFFSSw0QkFIVGgxQztpQkFHUyxZQUtBLElBQUxrVyxhQUFLLE9BQUxBO2lCQUxLLFVBSE5qZDs7OztZQWVWLDJCQURTNlM7O1VBZlQsZ0JBcUJ5QztlQXNCM0NvYixTQUFTbE8sRUFBRWc4QjtRQUNGOzhCQURBaDhCLEtBQUVnOEI7U0FHa0IsZUFIcEJoOEIsRUFwQlkyeUQ7U0F1QkQseUJBSFgzeUQ7Ozs7Z0JBakJKZ3pELFlBQU8veUUsY0FBSCtHO2VBSFkyckUsU0FHaEJLO2NBQ1MsMEJBRExoc0UsRUFpQkVnMUM7Y0FoQkc7O2lCQUVJLElBS1Y5K0IsRUFMVSxnQkFIVGxXO2lCQUdTLEdBS1ZrVyxFQUFlLE9BQWZBO2lCQUxVLFVBSE5qZDs7OztZQWVWLDJCQURTNlM7O1VBZlQsU0FxQjZDO2VBRS9DMjRDLFNBQVN6ckMsRUFBRWc4QjtRQUNGLElBQVAyMkIsS0FBTyxnQkFEQTN5RCxLQUFFZzhCO1FBQ0YsU0FDSDBQO1VqRDNPZjtVaUQyT2dDOztrQkFFbEJzbkIsY0FBTy95RSxnQkFBSCtHO2lCQUhQMnJFLFNBR0dLO2dCQUNTLDBCQURMaHNFLEVBSkVnMUM7Z0JBS0c7O21CQUNXLDRCQUZoQmgxQzttQkFFZ0I7cUJBR1AsSUFBTGtXLGFBQVEsVUFBUkEsRUFBUSxlQUxUamQ7bUJBRWEsWUFGYkE7Ozs7Y0FZViwrQkFEU3liOztZQVpGLFNBYVk7UUFDQSxtQkFqQlpzRSxFQUNQMnlEO1FBZ0JXLHVDQWpCSjN5RCxxQkFpQjZCO2VBR3RDMnJDLFFBQVEzckMsRUFBRWc4QixJQUFJc0c7UUFDTCxJQUFQcXdCLEtBQU8sZ0JBREQzeUQsS0FBRWc4QjtRQUNELFNBQ0hpM0I7VWpEL1BmO1VpRCtQZ0M7O2tCQUVoQkQsY0FBT3ZtRSxnQkFBSHpGO2lCQUhUMnJFLFNBR0tLO2dCQUNTLDBCQURMaHNFLEVBSkRnMUM7Z0JBS00sc0JBREZ2dkM7Z0JBRUMsdUJBRkp6RixFQUpEZzFDLElBQUlzRztjQVNNLCtCQUFUNW1DOztZQU5BLGdCQU00QjtRQUVqQyxnQkFYRXNFLEVBQ04yeUQsTUFXSSxtQkFaRTN5RCxLQVdOamdCO1FBQ0k7VUFFTix3QkFGRW1HOzs7O1lBSWMsSUFBWjRzRSxVQUFZLGdCQWhCTjkyQixJQUFJc0c7WUFpQmQsaUJBakJRdGlDLEtBV05qZ0IsZUFWQTR5RSxLQWVFRyxVQUpGNXNFO1lBS0YsT0FqQlE4WjtZQWdCUSxTQWhCUkE7WUFpQlIsWUFFMkMsT0FuQm5DQTtVQWxCZSxXQXFDNEI7ZUFFbkQyTCxJQUFJM0wsRUFBRWc4QjtRQUNHOzhCQURMaDhCLEtBQUVnOEI7U0FXYyxlQVhoQmg4QixFQUNGMnlEO1NBVVUseUJBWFIzeUQ7O1FBRWtCOztnQkFHakJnekQsWUFBTy95RSxjQUFIK0c7ZUFBSmdzRSxPQUpITDtjQUtZLDBCQURMM3JFLEVBTEhnMUM7Y0FNUSxvQkFERi83QztjQUVDO1lBR1UsMkJBQVQ2Uzs7VUFOWixTQU9tQztlQUVyQ3RFLE9BQUt2SyxFQUFFK2I7UUFDVCxRQURTQSxLQUNULEtBUUk1Qyx1QkFSSjs7Y0FTQXJkOztVQUNFO1lBQVUsNkJBRlJxZCxJQUNKcmQ7WUFUb0I7O2dCQUlGO2lCQURIRTtpQkFBSCtHO2lCQUNNLHNCQUROQTtpQkFDbUIsd0JBRG5CQTs7O3NCQUdTa1csYUFBUm9ULFdBQWEsV0FQbkJyc0IsRUFPTXFzQixFQUFRcFQ7Z0JBRkgsVUFESGpkOzt1QkFNZkY7Ozs7UUFyQndCLFFBdUJwQjtlQUVGd08sS0FBS3RLLEVBQUUrYixFQUFFM0U7UUFDWCxRQURTMkUsS0FDVCxVQURXM0UsTUFDWCxLQVVJK0IsdUJBVko7O2NBWUFyZDs7VUFDRTs7a0JBRkVnVTthQUVnQixxQkFIaEJxSixJQUVKcmQ7YUFaa0I2RjthQUFFc0Q7WUFDbEI7aUJBRGdCdEQ7Z0JBS1c7aUJBRGQzRixLQUpHMkY7aUJBSU5vQixFQUpNcEI7aUJBS1csc0JBRGpCb0I7aUJBQzhCLHdCQUQ5QkE7OztzQkFHV2tXLGFBQVJvVCxXQVBLbG5CLE9BT1EsV0FSckJuRixFQVFRcXNCLEVBQVFwVCxFQVBIaFU7O2dCekNrT2xCLGtCeUNsT2tCRTtnQkFLUyxJQUxYeEQsRUFJSDNGLEtBSktpSjs7Y0FXaEI2SyxZQVhnQjdLO3VCQVlwQm5KOzs7O1FBR0EsT0FKSWdVLFNBSUM7ZUFFSG0yQyxtQkFBbUJqbUQsRUFBRStiO1FBQ3ZCLFNBQVErcEM7VWpEaFVmO1VpRGdVMkI7O2NBSVI7ZUFESTlwRDtlQUFIK0c7ZUFBSmdzRTtlQUNHLHNCQURDaHNFO2VBQ1ksd0JBRFpBOztnQkFLRyxJQURLa1csYUFBUm9ULFdBQ0csbUJBVEtyc0IsRUFRUnFzQixFQUFRcFQ7Z0JBQ0w7a0JBSUYsSUFER2cyRDtrQkFDSCxnQkFURGxzRSxFQUlBc3BCLEVBSUk0aUQ7a0JBRVMsVUFWakJGLEdBQUloc0UsRUFVYSxVQVZWL0c7Z0JBS0EsWUFMQUE7O2NBQ0osWUFESUE7O1lBRFYsU0FXbUM7UUFiekMsTUFEdUIrZixLQUN2QixLQWVJOUMscUJBZko7O2NBZ0JBbmQ7VUFDRTtZQUFTLG1CQUFVLGlCQUZqQm1kLEVBQ0puZDtZQUNFLGlCQUZFbWQsRUFDSm5kO1lBQ1csU0FEWEE7OztnQkFFSTtlQUVGOFMsT0FBT21OLEdBQUksT0FBSkEsSUFBVTtlQUVicXFDOzs7O1lBRWdCOzs7O3FCQUFUM3VDOztVQURGO2VBR1Q0dUMsTUFBTXRxQztRQUNSO2NBRFFBO1NBQ1I7U0FDRTs7cUJBQXFCNkMsRUFBRWpkLEdBQVcsV0FBYmlkLEVBQWEsZ0JBQVhqZCxHQUE4QjtTQUMzQyxxQkFGUjJrRDtTQUVRLEtBSEp2cUM7UUFJUjttQkFDT3BhO1lBQ007K0JBRE5BO2FBRVcsc0JBSmQ0a0QsTUFHS3RrRDtZQUNKLGlCQUpEc2tELE1BR0t0a0Q7WUFDSixRQUEwQjs7UUFIL0IsVUFKUThaLHFCQUNKdXFDLElBRUFDLE1BU3dCO2VBRXRCMm9COzs7O2dCQUVPbHpFLGdCQUFIK0c7WUFBYyxtQkFBZEE7Y0FDTixnREFEUy9HO1lBRVMsK0JBQVR5Yjs7VUFIRjtlQUtUMDNELFlBQVlwekQ7UUFDZDs7Y0FEY0E7U0FDZDtTQUVFOztxQkFBcUI2QyxFQUFFamQsR0FBVyxXQUFiaWQsRUFBYSxzQkFBWGpkLEdBQW9DO1NBQ2pELHFCQUZSMmtEO1NBRVEsS0FKRXZxQztRQUtkO21CQUNPcGE7WUFDTSxJQUFKTSxFQUFJLHNCQUROTjtZQUNNLFVBTlR3dEMsVUFNS2x0QztZQUFJLFNBRUssaUJBTGRza0QsTUFHS3RrRDtZQUVKLGlCQUxEc2tELE1BR0t0a0Q7WUFFSixRQUEwQjs7UUFKL0IsVUFKSWt0QyxRQURVcHpCLGdCQUVWdXFDLElBRUFDLE1BVXdCO2VBRTFCbjdDLE9BQU8yVjtRQUdULElBQUkwbEMsU0FISzFsQztRQUdULFNBRVFoUCxJQUFJalcsRUFBRTRxRDtjQUFGeGtELE1BQUV5a0Q7VUFBVTtlQUFWQTtjQU1JO2VBREZuK0MsS0FMRm0rQztlQUtENWpELEVBTEM0akQ7ZUFNSSxzQkFETDVqRDtlQUNrQix3QkFEbEJBOztvQkFHWTJvQixnQkFBVnFzQjtnQkFDb0I7MkJBRHBCQSxJQUFVcnNCO3VDakQzWWhDLE9pRG1ZZTNaLElBQUk3UCxJQUtJc0c7Y0FDRSxJQU5KbStDLE9BS0VuK0M7O1lBSFYsR0FGTXRHLFFBRlJ1a0Qsb0JBS087WUFDUztxQ0FOaEJBLFNBRVF2a0Q7YUFJUSxJQUpSQTs7YUFBRXlrRDtxQkFVTDtRQVpUOzhCakRqWVAsT2lEbVllNTBDLG9CQVlHO2VBRVQ4MEMsWUFBWWpvQztRQUFnQixnQkFBaEJBO1FBQWdCLG9CakRqWnJDO1FpRGlacUMsc0JqRGpackMsT2NtQ1NoVyxvQm1DOFdzQztlQUV0Q2srQyxjQUFjbG9DO1FBQWdCLGdCQUFoQkE7UUFBZ0Isb0JqRG5adkM7UWlEbVp1QyxzQmpEblp2QyxPY21DU2hXLG9CbUNnWHdDO2VBRXhDcWlCLFFBQVFsSyxJQUFJamxCO1FBQ2Q7O21CQUFTLHFDQURDaWxCLElBQ0tzTCxFQUFFdm9CLEVBQWtCO2lCQURyQmhJLEVBQ3VCO2VBRW5DNnJELFlBQVk1bUMsSUFBSWpsQjtRQUNsQjs7bUJBQVMseUNBREtpbEIsSUFDQ3NMLEVBQUV2b0IsRUFBc0I7aUJBRHJCaEksRUFDdUI7ZUFFdkNvdkIsT0FBT3B2QixHQUNDLElBQU5pbEIsSUFBTSxhQUNWLFlBRElBLElBREtqbEIsR0FFVCxPQURJaWxCLEdBRUQ7O2NBdFZEeks7Y0FLQWdYO2NBT0FtRjtjQVNBbTFCO2NBMkRBbmhDO2NBU0FrQjtjQTBDQWdDO2NBeUJBTTtjQUtBdTlCO2NBb0JBRTtjQXFCQWhnQztjQWFBbmQ7Y0FnQ0EwN0M7Y0FsQkEzN0M7Y0F1Q0FzRTtjQU1BeTNDO2NBb0NBajdDO2NBbUJBeTdDO2NBRUFDO2NBRUE3N0I7Y0FHQTA4QjtjQUdBejhCO2NBelRBeWpEO2NBNFFBUTtJQTFVVyxTQTZZYkMsZ0JBQXdCLDJCQUFlO0lBN1kxQixTQStZYkMsVUFBUzExRCxHQUFtQyx5QkFBbkNBLElBQXVEO0lBL1luRCxTQWdaYjIxRCxlQUFjMzFELEdBQW1DLHlCQUFuQ0EsSUFBNEQ7SUFoWjdELFNBaVpiNDFELFVBQVM1MUQsRUFBYzBTLEdBQWUseUJBQTdCMVMsSUFBYzBTLEVBQThDO0lBalp4RCxTQWtaYm1qRCxZQUFXNzFELEdBQXNCLHlCQUF0QkEsSUFBMEM7SUFsWnhDLFNBbVpiODFELFlBQVc5MUQsR0FBc0IseUJBQXRCQSxJQUEwQztJQW5aeEMsU0FxWmIrMUQsV0FBVWgvRCxHQUFlRixJQUMzQix5QkFEWUUsS0FBZUYsT0FDQTtJQXRaWixTQXdaYm0vRCxXQUFVaDJELEdBQW1DLHlCQUFuQ0EsRUFBc0Q7SUF4Wm5ELFNBeVpiaTJELGNBQWVqMkQsR0FBbUMsMEJBQW5DQSxFQUEyRDtJQXpaN0QsU0EwWmJrMkQsU0FBVWwyRCxFQUFjVixHQUFlLDBCQUE3QlUsRUFBY1YsRUFBNkM7SUExWnhELFNBMlpiNjJELFdBQVluMkQsR0FBc0IsMEJBQXRCQSxFQUF5QztJQTNaeEMsU0E0WmJvMkQsV0FBWXAyRCxHQUFzQiwwQkFBdEJBLEVBQXlDO0lBNVp4QyxTQTZaYnEyRCxVQUFXdC9ELEdBQWNGLElBQXNCLDBCQUFwQ0UsR0FBY0YsR0FBNEM7SUE3WnhEO2VBbWFUOEYsT0FBTytWLEVBQUVwVDtRQUNILElBQUpsVyxFQUFJLFlBQ1IsU0FESUEsRUFET2tXLEdBR1gsVUFGSWxXLEVBREtzcEIsR0FHVCxPQUZJdHBCLENBR0g7VUFDQzJMO2VBQ0FoRSxNQUFNM0gsRUFBRXNwQjtRQUdKLG9CQUhFdHBCO1FBR0YsVUFHRixJQURHb3lCLGFBQ0EsdUJBTkc5SSxFQUtIOEk7UUFERyxRQUUwRDtlQUdsRTg2QyxhQUFhbHRFLEVBQUVzcEIsRUFBRXBUO1FBQ25CLFdBRGVsVyxHQUVmLFVBRmVBLEVBQUVzcEIsR0FFakIsZ0JBRmV0cEIsRUFBSWtXLEVBR1A7OztnQkFsQlYzQztnQkFLQTVIO2dCQUNBaEU7Z0JBakJKaWxFO2dCQVRBTjtnQkFtQ0lZO2dCQS9CSlI7SUFuWmE7TWpEcENwQixJaURpZWEva0U7ZUFDQWdFLEtBQU1zekMsS0FBWTFoRCxHQUFJLHVCQUFKQSxFQUFZOzsrQkFEOUJvSyxNQUNBZ0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQWhkVmlnRTtPQUNBUTs7ZUFpZE03NEQsT0FBT3V4QyxJQUFLLDRCQUFMQSxHQUE0QjtlQUNuQzM4QixPQUFPcHZCO1FBQ0MsSUFBTmlsQixJQUFNLFdBQ1YsdUJBRElBLElBREtqbEIsR0FFVCxPQURJaWxCLEdBRUQ7O2NBSkR6Szs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBQ0E0VTtjQW5kTnlqRDtjQUNBUTtJQWlCaUIsU0E0Y2JlLGdCQUE2QiwyQkFBZTtJQTVjL0IsU0E4Y2JDLFNBQVV4MkQsR0FBeUMseUJBQXpDQSxJQUE2RDtJQTljMUQsU0ErY2J5MkQsY0FBZXoyRCxHQUNULHlCQURTQSxJQUNnQjtJQWhkbEIsU0FpZGIwMkQsU0FBVTEyRCxFQUFtQjBTLEdBQy9CLHlCQURZMVMsSUFBbUIwUyxFQUNBO0lBbGRoQixTQW1kYmlrRCxXQUFZMzJELEdBQTJCLHlCQUEzQkEsSUFBK0M7SUFuZDlDLFNBb2RiNDJELFdBQVk1MkQsR0FBMkIseUJBQTNCQSxJQUErQztJQXBkOUMsU0FzZGI2MkQsU0FBVTcyRCxHQUF5Qyx5QkFBekNBLElBQTZEO0lBdGQxRCxTQXVkYjgyRCxjQUFlOTJELEdBQ1QseUJBRFNBLElBQ2dCO0lBeGRsQixTQXlkYisyRCxTQUFVLzJELEVBQW1CMFMsR0FDL0IseUJBRFkxUyxJQUFtQjBTLEVBQ0E7SUExZGhCLFNBMmRic2tELFdBQVloM0QsR0FBMkIseUJBQTNCQSxJQUErQztJQTNkOUMsU0E0ZGJpM0QsV0FBWWozRCxHQUEyQix5QkFBM0JBLElBQStDO0lBNWQ5QyxTQStkYmszRCxVQUFXbmdFLEdBQWlCRixJQUM5Qix5QkFEYUUsS0FBaUJGLE9BQ0g7SUFoZVosU0FpZWJzZ0UsVUFBV3BnRSxHQUFpQkYsSUFDOUIseUJBRGFFLEtBQWlCRixPQUNIO0lBbGVaLFNBbWVidWdFLFdBQVlyZ0UsR0FBbUJGLElBQ2pDLHlCQURjRSxLQUFtQkYsT0FDTjtJQXBlWixTQXNlYndnRSxXQUFVcjNELEdBQXdDLHlCQUF4Q0EsRUFBMkQ7SUF0ZXhELFNBdWViczNELGdCQUFldDNELEdBQ1QsMEJBRFNBLEVBQ2U7SUF4ZWpCLFNBeWVidTNELFdBQVV2M0QsRUFBbUJWLEdBQy9CLDBCQURZVSxFQUFtQlYsRUFDRDtJQTFlZixTQTJlYms0RCxhQUFZeDNELEdBQTJCLDBCQUEzQkEsRUFBOEM7SUEzZTdDLFNBNGVieTNELGFBQVl6M0QsR0FBMkIsMEJBQTNCQSxFQUE4QztJQTVlN0MsU0E2ZWIwM0QsWUFBVzNnRSxHQUFnQkYsSUFBd0IsMEJBQXhDRSxHQUFnQkYsR0FBOEM7SUE3ZTVEO2VBcWZUOEYsYUFBZTJDO1FBQ1QsSUFES2t1QyxZQUFIRixZQUNGO1FBQ1IsV0FESWxrRCxFQURha1c7UUFHakIsU0FGSWxXLEVBRE1ra0Q7UUFHSyxTQUZYbGtELEVBRFNva0Q7UUFHRSxPQUZYcGtEO2VBSUYyTCxLQUFLc3pDO1FBQ1c7U0FERm1GO1NBQUhGO1NBQ0ssc0JBRFhqRixLQUFTbUY7UUFDaEIsd0JBRE9uRixLQUFNaUY7ZUFFWHY4QyxNQUFNM0g7UUFDRixJQURRb2tELFlBQUhGLFlBQ0wsZUFERWxrRCxHQUNVLGlCQURWQTs7Y0FHU3V1RSxnQkFBVkM7VUFDbUIsR0FBbkIsaUJBSkl0cUIsR0FHSnNxQixTQUNtQixpQkFKWnBxQixHQUdHbXFCLE1BRVI7VUFBd0I7UUFIVDtlQUt0QjU2RCxRQUFRM1Q7UUFDSixtQkFESUEsR0FDUSxpQkFEUkE7O2NBR09va0QsY0FBVkYsNEJBQVVFO1FBRE8sUUFDZTtlQUNyQzhvQixhQUFhbHRFLFFBQVVrVztZQUFKa3VDLFlBQUhGO1FBQ2xCLGFBRGVsa0Q7UUFFZixTQUZlQSxFQUFHa2tEO1FBRUgsU0FGQWxrRCxFQUFNb2tEO1FBRU4sa0JBRkFwa0QsRUFBVWtXO2VBSXZCbkMsVUFBVS9UO1FBQUksb0JBQUpBLEdBQUksWUEvQ2xCNnRFLFdBK0NjN3RFLE9BQWdDOztrQkF0QjFDdVQsT0FLQTVILEtBRUFoRSxNQXRCSnNtRSxXQTZCSXQ2RCxRQUlBdTVELGFBSUFuNUQ7SUEzZ0JTO01qRHBDcEIsSWlENmpCZXBNO2VBQ0FnRSxLQUFNc3pDLEtBQVkxaEQsR0FBSSx3QkFBSkEsRUFBYTtVQU4vQjhMLHNCQUtBMUIsTUFDQWdFO2VBTEFtTSxPQUFNbW5DLEtBQVkxaEQsR0FBSSx3QkFBSkEsRUFBYTs7K0JBRC9COEwsUUFDQXlPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F2aUJaOHpEO09BQ0FROztlQTZpQk03NEQsT0FBT3V4QyxJQUFLLDRCQUFMQSxHQUE0QjtlQUNuQzM4QixPQUFPcHZCO1FBQ0MsSUFBTmlsQixJQUFNLFdBQ1YsdUJBRElBLElBREtqbEIsR0FFVCxPQURJaWxCLEdBRUQ7O2NBSkR6Szs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBQ0E0VTtjQS9pQk55akQ7Y0FDQVE7SUFpQmlCLFNBd2lCYnFDLFNBQU8vdkUsR0FBZ0IseUJBQWhCQSxFQUErQjtJQXhpQnpCLFNBeWlCYmd3RSxTQUFRcGxELEdBQXFCLHlCQUFyQkEsRUFBb0M7SUF6aUIvQixTQTJpQmJxbEQsVUFBUy8zRCxFQUFjbFksR0FBNkIseUJBQTNDa1ksRUFBY2xZLEVBQWlEO0lBM2lCM0QsU0E0aUJia3dFLGVBQWNoNEQsRUFBY2xZLEdBQ3RCLHlCQURRa1ksRUFBY2xZLEVBQ0c7SUE3aUJsQixTQThpQmJtd0UsVUFBU2o0RCxFQUFjbFksRUFBUTRxQixHQUNqQyx5QkFEVzFTLEVBQWNsWSxFQUFRNHFCLEVBQ0Y7SUEvaUJoQixTQWdqQmJ3bEQsWUFBV2w0RCxFQUFjbFksR0FBZ0IseUJBQTlCa1ksRUFBY2xZLEVBQW9DO0lBaGpCaEQsU0FpakJicXdFLFlBQVduNEQsRUFBY2xZLEdBQWdCLHlCQUE5QmtZLEVBQWNsWSxFQUFvQztJQWpqQmhELFNBbWpCYnN3RSxXQUFVcmhFLEdBQWU3RixHQUFTMkYsR0FBZXlHLEdBQVNoVjtNQUM1RCx5QkFEWXlPLEdBQWU3RixHQUFTMkYsR0FBZXlHLEdBQVNoVixFQUMvQjtJQXBqQmQsU0FzakJiK3ZFLFdBQVVyNEQsR0FBbUMseUJBQW5DQSxFQUFzRDtJQXRqQm5ELFNBdWpCYnM0RCxnQkFBZXQ0RCxHQUFtQywwQkFBbkNBLEVBQTJEO0lBdmpCN0QsU0F3akJidTRELFdBQVV2NEQsRUFBY1YsR0FBZSwwQkFBN0JVLEVBQWNWLEVBQTZDO0lBeGpCeEQsU0F5akJiazVELGFBQVl4NEQsR0FBc0IsMEJBQXRCQSxFQUF5QztJQXpqQnhDLFNBMGpCYnk0RCxhQUFZejRELEdBQXNCLDBCQUF0QkEsRUFBeUM7SUExakJ4QyxTQTJqQmIwNEQsWUFBVzNoRSxHQUFjRixJQUFzQiwwQkFBcENFLEdBQWNGLEdBQTRDO0lBM2pCeEQ7ZUFpa0JUOEYsT0FBTytWLEVBQUVwVDtRQUNILElBQUpsVyxFQUFJLFNBRENzcEI7UUFFVCxXQURJdHBCLEVBRE9rVztRQUNILElBQ1IsS0FGU29ULHFCQUVUOztjQUNBdndCO1VBQ0U7c0JBSEVpSCxFQUVKakgsRUFDYyxpQkFKTHV3QixFQUdUdndCO1lBQ0UsU0FERkE7OztRQUdBLE9BTElpSCxDQUtIO2VBQ0MyTCxLQUFLc3pDLEtBQUszMUI7UUFDWixpQkFEWUEscUJBQ1o7O2NBQ0F2d0I7VUFDRTtxQkFGRWlnQixLQUVlLHNCQUhQc1EsRUFFWnZ3QjtZQUNPLHdCQUhBa21EO1lBR0wsU0FERmxtRDs7O1FBR0EsT0FKSWlnQixJQUlGO2VBQ0FyUixNQUtzQjNILEVBQUZzcEI7UUFKdEIsUUFJc0JBLGFBSFgsZUFHYXRwQjtRQUhiLEdBRFBXLFFBQ0FjLE1BQ2dCO1FBRnBCLElBSUUsSUFKRWQsWUFJc0I1SDtRQUN0QjtrQkFEc0JBO1lBR2Qsb0JBSFlpSCxFQUFFakg7WUFHZDtjQUdGLGdCQUFXLHNCQU5DdXdCLEVBQUl2d0I7Y0FNYix3QkFEQXcyRSxLQUVFLFFBUFd4MkU7Y0FRWDtZQUpDO1VBSEUsU0FTTztlQUV2QjRhLFFBQVEzVDtRQUNBLElBQU5XLElBQU0sU0FEQVg7UUFDQSxTQUFOVyxJQUNZO1FBRE4sVUFHRixVQUpFWDtRQUlGO1VBR0YsZ0JBU1EsaUJBZlZXLElBS0s2dUUsSUFVSyxJQWZWN3VFLFlBTWlCNUg7VUFDYjtvQkFEYUE7Y0FHTCxzQkFWTmlILEVBT1dqSDtjQUdMO2dCQUdGLElBREd3MkU7Z0JBQ0gsaUJBTktsdkUsRUFBRXRILFlBS0p3MkU7Z0JBQ0gsUUFOT3gyRTs7Y0FJRDtZQUhFLFVBREhzSDtRQUZQLFFBWVE7ZUFDbEI2c0UsYUFBYWx0RSxFQUFFc3BCLEVBQUVwVDtRQUNuQixhQURlbFc7UUFDZixTQURpQnNwQixxQkFDakI7O2NBQ0F2d0I7VUFDRTtzQkFIYWlILEVBRWZqSCxFQUNjLGlCQUhHdXdCLEVBRWpCdndCO1lBQ0UsU0FERkE7OztRQUdBLGtCQUxlaUgsRUFBSWtXLEVBS1A7ZUFDVm5DLFVBQVUvVDtRQUdILGlCQUhHQSxXQUNJakg7UUFDZDttQkFEY0E7VUFDZDs7O1lBQVUscUJBRkFpSCxFQUNJakg7WUFDSixhQURJb0c7WUFDSjtVQURaLFlBRXNCOztrQkF6RHBCb1UsT0FPQTVILEtBTUFoRSxNQXhCSnNuRSxXQXlDSXQ3RCxRQWtCQXU1RCxhQU1BbjVEO0lBdm5CUztNakRwQ3BCLElpRHFxQmFwTTtlQUNBZ0UsS0FBTXN6QyxLQUFZMWhELEdBQUksdUJBQUpBLEVBQVk7OytCQUQ5Qm9LLE1BQ0FnRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BcHBCVmlnRTtPQUNBUTs7ZUFxcEJNNzRELE9BQU91eEMsSUFBSyw0QkFBTEEsR0FBNEI7ZUFDbkMzOEIsT0FBT3B2QjtRQUNDLElBQU5pbEIsSUFBTSxXQUNWLHVCQURJQSxJQURLamxCLEdBRVQsT0FESWlsQixHQUVEOztjQUpEeks7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQUNBNFU7Y0F2cEJOeWpEO2NBQ0FRO0lBaUJpQjs7OztRQTZZYkM7UUFFQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFFQUM7UUFHQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7Ozs7UUErQ0FFO1FBRUFDO1FBQ0FDO1FBRUFDO1FBRUFDO1FBQ0FDO1FBRUFDO1FBQ0FDO1FBRUFDO1FBRUFDO1FBQ0FDO1FBR0FDO1FBRUFDO1FBRUFDO1FBR0FDO1FBQ0FDO1FBRUFDO1FBRUFDO1FBQ0FDO1FBQ0FDOzs7O1FBMkRBRztRQUdBRTtRQUNBQztRQUVBQztRQUVBQztRQUNBQztRQUVBQztRQUdBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQzs7Ozs7VWpEL2xCUDs7SWlEb0NvQjthM0NBZkcsaUJBQWlCQyxXQUFXejNFLGlCQUFpQjhIO01BVTVDLHFCQVY0Q0EsY0FXMUMsT0FYeUI5SDtNQVl6Qiw4QkFaMEM4SCxjQUM5QnJCO01BQ2Y7Z0JBRGVBO1VBRVAsY0FIU2d4RSxXQUE0QjN2RSxLQUM5QnJCLElBRWdCLFFBRmhCQTtVQUdWLE1BSFVBLFVBSUowTixJQUpJMU47VUFLZjtvQkFEVzBOO2NBRUgsY0FQU3NqRSxXQUE0QjN2RSxLQUtsQ3FNO2VBRW9CLGFBUGNyTSxLQUtsQ3FNLGFBQUVjLElBQUZkO2NBR04sUUFITUE7O1lBQ0csYUFOK0JyTSxPQUtoQ21OO1FBSEMsYUFGK0JuTixVQVlUO2FBTXBDNHZFLGdCQUFnQkQsV0FBV3ozRSxpQkFBaUI4SDtNQWMzQyxxQkFkMkNBLGNBZXpDLE9BZndCOUg7TUFnQnhCLDhCQWhCeUM4SCxjQUN6QnJCO01BQ25CO2dCQURtQkE7VUFFWCxjQUhRZ3hFLFdBQTRCM3ZFLEtBQ3pCckIsSUFFWSxRQUZaQTtjQUlaME4sSUFKWTFOO1VBS25CO29CQURPME47Y0FFQyxjQVBRc2pFLFdBQTRCM3ZFLEtBS3JDcU07b0JBSVkrN0QsSUFKWi83RDtnQkFLUDswQkFEbUIrN0Q7b0JBRVgsY0FYUXVILFdBQTRCM3ZFLEtBU3pCb29FO3NCQUVZLFFBRlpBO29CQUdkLGFBWnVDcG9FLE9BU3pCb29FO2tCQUNMLGFBVjhCcG9FO2NBUXZDLFFBSEVxTTs7WUFDTyxPQU5hblU7UUFFYixhQUY4QjhILFVBZ0JKO2FBMEJ0QzJ2RSxXQUFXdHlFLEVBQUVyRSxHQUFJLDhCQUFOcUUsRUFBRXJFLE1BQWU7YUFDNUI2MkUsWUFBWWx4RTtNQUFJO2tDQUFKQTtPQUFJLHFCQUF1QixnQkFBM0JBO2lCQUF1QzthQUNuRG14RSxZQUFZbnhFO01BQ2QscUJBRGNBO01BQ2Q7O29DQURjQTtzQkFFNkIscUJBQWhCLE1BRmJBO1FBRXFDOztxQ0FGckNBO3VCQUc2QixxQkFBaEIsTUFIYkE7Ozs7O01BR3NDLFdBQUM7YUFDbkRveEUsYUFBYS92RSxLQUFLZ3dFO01BQ3BCO2tDQURvQkEsU0FDcEIsc0JBRGVod0U7T0FDZjs7VUFFb0M7WUFEcEM7Y0FGZUE7a0VBQUtnd0U7Ozs7TUFHdUI7YUFFekNDLGdCQUFpQno3QixPQUFPNko7TUFDMUI7bUNBRG1CN0o7T0FDbkIsNEJBRDBCNko7TUFDMUIsR0FBSTZ4QixTQUFpQ0M7UUFFM0IsSUFBSnh1RSxFQUFJLE1BSGdCMDhDLFNBQ1c4eEIsUUFBakNEO1FBR0MseUJBREN2dUUsRUFIYTZ5QztvQkFLVixNQUxpQjZKLFdBQ1c4eEIsUUFBakNEOztNQVFGLFFBQUk7O01BR0Y7Ozs7O0lBQ00sU0E2SlJFLE1BclF1Qi95RTtNQUMzQiw0QkFEMkJBLEdBRW5CLFdBREo4QjtNQUVKLFNBRElOO01BREosSUFFQSxLQUZJTSxVQUVKOztZQUNBbkc7UUFDRTtVQUFHLDBCQUxzQnFFLEVBSTNCckU7V0FFTyxXQUpINkYsRUFGWXhHOztXQU9ULFNBTEh3RyxFQUtzQixnQkFQQ3hCLEVBSTNCckU7VUFHK0IsU0FIL0JBOzs7TUFLQSxTQVBJNkY7TUFPSixnQkFQSUE7SUFzR1EsU0E4SlJ3eEUsY0E3SmNodkQsSUFBSzNoQixNQUFPQyxPQUFRQyxPQUFPazZDO01BQzNDLEdBRG9DbDZDO09BSVE7VUFKUkE7UUFJVyxnQkFKWEEsT0FBUkQsZ0JBTXFCLGFBQVEsTUFGbEJ6Qzs7OztTQUpYeUM7T0FHZ0IsUUFIaEJBLGVBR2dCLGVBQU8sTUFBWisyQzs7O01BQXJDO1NBSG1CaDNDO09BRXVCLFFBRnZCQSxjQUV1QixlQUFPLE1BQVppM0M7OztNQUNyQyxTQURBO01BREYsK0JBQWtCLE1BMkpoQnk1QixTQTVKYy91RCxJQUEyQnk0QixhQU1zQjtJQUNwRCxTQUFYdzJCO01OaElQLE9Nb0NLWixpQkE0REVDLFdBSEF6M0U7SUFvQ1UsU0FBVnE0RTtNTmpJUCxPTXNES1gsZ0JBMENFRCxXQUhBejNFO0lBb0NVOzs7T0FyQ1ZEO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0F1M0U7T0FDQUU7T0FDQUM7T0FJQUM7T0FLQUU7O09BMEtBRztPQUNBQztPQXRKQUM7T0FDQUM7SUFBVSxTQVFWQyxhQUFXbnpFLEVBQUVyRTtNQUFZLHNCQUFkcUUsRUFBRXJFLEdBQVksWUFBSmlIO01BQUk7Ozt1QkFBSkE7aUJBQTJDO0lBUnRELFNBU1Z3d0UsY0FBWTl4RTtNQUNkO2tDQURjQTtPQUNkLHFCQUF3QixnQkFEVkE7Ozs7OEJBRWEsZ0JBRmJBOzs7OytCQUdhLGdCQUhiQTs7Ozs7aUJBRzBCO0lBWjVCLFNBYVYreEUsY0FBWS94RTtNQUNkLHVCQURjQTtNQUNkOztvQ0FEY0E7c0JBRTZCLHFCQUFoQixNQUZiQTtRQUVxQzs7c0NBRnJDQTt3QkFHNkIscUJBQWhCLE1BSGJBO1VBR3NDOzt3Q0FIdENBOzBCQUk2QixxQkFBaEIsTUFKYkE7WUFJc0M7O3lDQUp0Q0E7MkJBSzZCLHFCQUFoQixNQUxiQTs7Ozs7Ozs7O01BS3VDLFdBQUM7SUFsQjFDLFNBbUJWZ3lFLGVBQWEzd0UsS0FBS2d3RTtNQUNyQiwrQkFEcUJBLFNBQ3JCLHNCQURnQmh3RTtNQUNoQjtPQUNTOzs7V0FGT0E7K0RBQUtnd0U7O1FBSU8sdUJBSlBBO2FBSUksa0JBQXhCLGtCQUZJM3lFOzs7TUFQSixXQVN1RDtJQXZCM0MsU0F5QlZ1ekUsa0JBQWlCcDhCLE9BQU82SjtNQUMxQjttQ0FEbUI3SjtPQUNuQiw0QkFEMEI2SjtNQUMxQixHQUFJNnhCLFNBQWlDQztRQUUzQjtpQkFIZ0I5eEIsU0FDVzh4QixRQUFqQ0Q7U0FHNEIsdUJBSmIxN0I7UUFJVSx5QkFBeEIsa0JBREM3eUM7b0JBRUcsTUFMaUIwOEMsV0FDVzh4QixRQUFqQ0Q7O01BUUYsUUFBSTtJQWxDTTtNQXNDUixtQ0FERlc7Ozs7O2FBRUFDLFFBQU16ekU7TUFDUiw0QkFEUUEsR0FFQSxXQURKOEI7TUFFSixTQURJTjtNQUNKLFNBaUJJa3lFLE9BQU9weUU7UUFBSTtjQUFKQTtjQUFJcVI7VUFBbUI7cUJBbEI5Qm5SO1lBa0I4QixTQUFuQm1SO2VBQUpyUixNQUFJcVI7O1FBbkJmLFFBbUI4RDtNQWpCOUQsU0FDUWdoRSxlQUFLaDRFO1FONUtsQixJTTRLa0JvRztRQUNYO2FBRFdBLFFBSFRELEVBSVksZ0JBSFpOO1VBSUksSUFHSm9CLEVBSEksZ0JBTkE1QyxFQUlLK0I7VUFFTCxVQUdKYTtZQUZROzs7cUJBR1JneEUsdUJBTlM3eEU7MENBTVQ2eEUsZ0JBTlM3eEU7b0JBS1RhO1lBRFE7OztxQkFFUmd4RSx1QkFOUzd4RTswQ0FNVDZ4RSxnQkFOUzd4RTtVQUtELFNBUFJQLEVBT0FvQjtVQUhJLElBR0ksSUFMQ2I7bUJBSytCO01BTjVDLFNBT0k2eEUsZ0JBQVF0eUUsRUFBRTNGO1lBQUZtVCxNQUFFL007UUFDWjthQURZQSxRQVRWRCxHQVdBLFNBVkFOLE1BVUEsY0FGUXNOO1VBS0YsMEJBZkY5TyxFQVVNK0I7VUFLSjtZQUNJLFlBTkYrTTtZQU1rQixTQWQxQnROO1lBYzBCLFNBTmhCTztZQU1nQjttREFadEI0eEU7OztZQWFNLFFBUEE1eEUsWUFPQSxJQVBGK00sb0JBQUUvTTtVQVFBLE9BUkYrTTtVQVFFO2lEQWRONmtFLGlCQU1NNXhFO3dDQU5ONHhFLFVBTU01eEUsTUFTVDtNQWhCTCxTQUNRazVDLEtBQUt0L0MsR041S2xCLHVCTTRLYWc0RSxTQUFLaDRFO01Ba0JiO3NCQXBCSTZGLEVBcUJhO2FBZ0NmcXlFLG1CQUFtQmgwRTtNQUNRLEtBQTFCLFdBRGtCQSxXQUNRLFdBRFJBO09BR2Isa0JBSGFBLE1BSVosc0JBSllBO01BRVYsc0RBRlVBLEdBTWxCO2FBSURpMEUsZ0JBQWM5dkQsSUFBSzNoQixNQUFPQyxPQUFRQyxPQUFPazZDO01BQzNDLEdBRG9DbDZDO09BU0E7VUFUQUE7UUFTRztvQkFUSEEsT0FBUkQ7O1dBV2EsZUFBUSxtQkFIVnpDOzs7OztTQVJYeUM7T0FPZ0IsUUFQaEJBLGVBT2dCLGVBQU8sbUJBQVorMkM7Ozs7U0FQbEJoM0M7T0FNdUIsUUFOdkJBLGNBTXVCLGVBQU8sbUJBQVppM0M7OztNQUQzQjswQkFBbUIsTUF0RTdCbTZCLFFBaUV5Q2gzQjtPQXBCbkMsV0FBUixzQkFEWXo4Qzs7TUFFWjtpQkFDTzRDO1VOdk5aO1VNd05TLFNBREdBOzs7Ozs7Ozs7Ozs7O1VFeVRILGlCRnRUSSxTQUxKcEIsTUFLSSxTQUxKQSxFQUVHb0IsSUFLQyxTQVBKcEIsRUFFR29CLEVBS29CO1FBUmY1QztNQTBCQSx1QkF4QlosU0FESXdCO01BdUJGLHlEQUhjd2lCLFlBYWY7YUFPQyt2RCxlQUFlL3pFO01BTGpCLG9DQUtpQkE7TUFMakI7UUFJa0MsMEJBQ2pCQTtRQUxEOzs7O1FBSWtCLElFb1I5QixtQ0ZwUnVDLGdCQUMxQkE7Ozs7UUFFTyxlQUZQQSxJQUVaLHNCQUZZQTtRQUVYLGdCQUZXQTtNQUdaLGtCQUhZQSxFQUdMO2FBQ1ZnMEUsVUFBUWgwRTtNQUNVOzRCQURWQTtPQUNVOztPQUNWLG9CQTFIUm16RSxhQUhBajRFLG1CQTRIVSs0RTtNQUNGLGNBRExDLE1BQ0RDLElBQ087YUFDVEMsV0FBU3AwRTtNQUNVLHlCQURWQSxHQUNVOzhCQTdIbkJtekUsYUFIQWo0RSxtQkFnSVcrNEUsS0FDb0M7Ozs7T0FsSS9DaDVFO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0ErM0U7T0FDQUM7T0FJQUM7T0FNQUM7T0FNQUM7T0FZQUM7T0FFQUM7T0FpRUFLO09BNEJBTTtPQUpBSjtJQXNCVyxTQUFYSztNTnZSUCxPTW9DS2hDLGlCQXFHRWMsYUFtSUE3M0U7SUFZVSxTQUFWZzVFO01OeFJQLE9Nc0RLL0IsZ0JBbUZFWSxhQW1JQTczRTtJQVlVOzs7T0FiVkQ7T0FDQUM7T0FDQUM7T0FDQUM7T0FySUEyM0U7T0FDQUM7T0FJQUM7T0FNQUM7T0FNQUM7O09BMkhBUjtPQUNBQztPQUNBcUI7T0FDQUM7S0FBVTs7OztLQS9NZEM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FDQUM7S0FHQUM7S0FDQUM7YUEyTUVDLFNBQU9uQyxRQUFRbHlCO01BQ2pCLElBQUlsL0MsRUFBSixzQkFEU294RTtNQUVHLFNBRFJweEUsT0FDUSxhQUZIb3hFLFFBQ0xweEU7T0FHVyxjQUpOb3hFLFFBSU0sT0EzTmZ3QixVQXVOaUIxekI7TUFHWixjQUhJa3lCLFFBQVFseUIsU0FJZ0I7YUFFL0JzMEIsWUFBWTN5RSxLQUFLZ3dFO01BQ25CLElBQUlyeEUsRUFBSixzQkFEY3FCLFFBQ2Qsc0JBRG1CZ3dFO01BQ25CLFlBQUlyeEUsRUFDa0QsTUFGeENxQixPQUNWckIsR0FDVSxxQ0FBMkQ7YUFFdkVpMEUsY0FBYzV5RTtNQUNoQiw4QkFEZ0JBLGNBTUdvUTtNQUNqQjtRQUFZLFFBREtBLFNBQ0wsYUFQRXBRLEtBTUdvUTtVQUVULDBCQVJNcFEsS0FNR29RO1lBRVcsUUFGWEEsWUFMRnBYO1lBQ2Y7Y0FBWSxRQURHQSxPQUNILGFBRkVnSCxLQUNDaEg7Z0JBRVAsMEJBSE1nSCxLQUNDaEg7a0JBRWEsUUFGYkE7Z0JBR1YsNkJBSlNnSCxRQU1Hb1E7Y0FKa0I7VUFPOUIsUUFIWUE7O1FBQ2tCLFNBSUY7YUFFakN5aUUsVUFBVTd5RTtNQUNKLElBQUpiLEVBQUksY0FESWE7TUFDSixhQUFKYixVQUNrQixNQUZWYSxLQUVVLHNCQUZWQSxRQUNSYixRQUM0RDthQUU5RDJ6RSxlQUFlOXlFO01BQ1QsSUFBSmIsRUFBSSxjQURTYTtNQUNULGFBQUpiO2VBQ1U7ZUFDVCxNQUhZYSxPQUdaLHNCQUhZQSxRQUNiYixNQUUyQzthQUU3QzR6RSxpQkFBaUIveUU7TUFDWCxJQUFKYixFQUFJLGNBRFdhO01BQ1gsYUFBSmIsRUFEZWEsS0FFSyxNQUZMQSxPQUVLLHNCQUZMQSxRQUNmYixNQUM4RDtRQUtoRTZ6RSwyQk4xVUw7YU00VUtDLGVBQWVDLFNBQVMzK0IsT0FBT0M7TUFDakM7eUJBSEV3K0I7T0FHRjtxQkFIRUEsdUIwQi9TQXRtRCxpQjFCK1NBc21EO09BR1E7TUFDTSxnQkFGQ0UsU0FFRCx5QkFGVTMrQixPQUN0QjQrQixJQUQ2QjMrQixRQUU0QjtRQUczRDQrQix5QkEvUEZmO2FBaVFFZ0Isa0JBQWtCaDJFLEdBQUksMkJBQUpBLEVBQUksUUFBMEI7YUFDaERpMkUseUJBQXVCLE9BSHZCRix3QkFHNkM7YUFFN0NHLFVBQVlsMUQsSUFBbUNrMkIsT0FBT0M7TUFDeEQsR0FEY24yQjtPQUFXLFFBQVhBLGdCQUFXQzs7V0FBWDQwRCxTQUxaRTtNQU1GLFNBQVFJLFNBQVMzMkU7UU52VnBCLElNdVZvQm8wQztRQUNmO1VBQVcsSUFBUGp4QyxLQUFPLGVBRkNrekUsU0FBbUMzK0IsT0FBT0M7VUFFM0M7WUFFNEQsdUJBQTNELGNBRlJ4MEM7Z0JBSUN5STs7O2NBQ0gsV0FOYXdvQyxVQU1XLE1BRHJCeG9DO2NBQ2tDLGNBTnhCd29DOztrQkFLVnhvQyxHQUN3RDtNQU4vRCxrQkFPYTthQUVYaXJFLGVBQWlCcjFELGNBQ21DazJCLE9BQU9DO01BQzdELEdBRm1CbjJCLElBQU8sUUFBUEEsWUFBT0MsYUFBUHhlO01BRW5CLFFBRmlELGtCQUFSOHpFLE1BQVFELGVBQVJDO01BRXpDO09BRDhCLGtCQUFYVixTQUFXVzs7V0FBWFgsU0FoQmpCRTtNQWlCRixTQUFRSSxTQUFTMzJFO1FObFdwQixJTWtXb0JvMEM7UUFDZjtVQUFXLElBQVBqeEMsS0FBTyxlQUZNa3pFLFNBQW1DMytCLE9BQU9DO1VBRWhEO1lBR1IsWUFIQ3gwQyxLQUdELDRCQU5jRixRQUFzQjh6RSxNQUduQzV6RTs7Z0JBSUN5STs7O2NBQ0gsV0FOYXdvQyxVQU1XLE1BRHJCeG9DO2NBQ2tDLGNBTnhCd29DOztrQkFLVnhvQyxHQUN3RDtNQU4vRCxrQkFPYTs7OztPQS9SYm9wRTtPQUNBQztPQUNBQztPQXVORVc7T0FyTkZUO09BQ0FDO09BQ0FDO09BeU5FUTtPQXhORlA7T0F5T0VTO09BU0FFO09BTEFEO09Bdk9GTjtPQUNBQztPQWZBYjtPQTZRRTJCO09BVUFHO09BWkFKO09BREFEO09BalFGaEI7T0FDQUM7T0FDQUM7O2FDNURFdUIsTUFBSXQyRSxFQUFFQyxHQUFXLFlBQWJELE9BQUVDLEtBQUZELE9BQUVDLEtBQTRDO2FBRWxEczJFLE1BQUl2MkUsRUFBRUMsR0FBVyxZQUFiRCxPQUFFQyxLQUFGRCxPQUFFQyxLQUE0QzthQUVsRHUyRSxJQUFJeDJFLEdBQWMsY0FBZEEsWUFBa0M7YUFFdEN5MkUsS0FBS3oyRSxHQUF5QixZQUF6QkEsWUFBK0I7YUFFcEMwMkUsSUFBSTEyRSxFQUFFQztNQUF1QixZQUF6QkQsT0FBRUMsT0FBRkQsT0FBRUMsS0FBRkQsT0FBRUMsT0FBRkQsT0FBRUMsS0FDeUM7YUFFL0MwMkUsSUFBSTMyRSxFQUFFQztNQUNLLEdBQWtCLFNBRHZCQSxTQUNLLFNBRExBO1FBRUUsTUFGRkEsWUFHRSxFQUhGQSxPQUVGa0UsSUFGRWxFO1FBSW9CLGFBSnRCRCxPQUVBbUUsSUFGQW5FLFFBR0EyWSxHQUhBM1ksT0FFQW1FLElBRkFuRSxRQUdBMlk7TUFJSSxRQVBGMVksWUFRRSxJQVJGQSxPQU9GNm1CLE1BUEU3bUI7TUFTb0IsYUFGdEI2bUIsTUFQQTltQixlQVFBNlksS0FEQWlPLE1BUEE5bUIsZUFRQTZZLElBRTZCO2FBRWpDKzlELElBQUk1MkUsR0FBSSxXQTFCUnpFLE1BMEJJeUUsRUFBYTthQUVqQjYyRSxNQUFNNzJFLEdBQWdCLE9BQWhCQSx5QkFBZ0M7YUFFdEM4MkUsS0FBSzkyRTtNQUVXLGVBRlhBLE1BRWtDLFdBRmxDQTtNQUVrQyxHQUFyQ21FLFFBQ1ksT0FEVzNJO01BRXRCLEdBRnNCQSxRQUVOLE9BRmpCMkk7TUFHQyxHQUhzQjNJLEtBQXZCMkksR0FJTSxJQUFKcWEsRUFKcUJoakIsSUFBdkIySSxFQUlnQixPQUpoQkEsSUFJd0MsZUFBdENxYTtNQUpZLElBTVp1NEQsSUFORjV5RSxJQUF1QjNJO01BTVAsT0FOT0EsSUFNaUIsZUFBdEN1N0UsVUFBc0M7YUFFMUNqekQsSUFBSTlqQixHQUFVLGtCQUFWQSxVQUFtQjthQUV2QmczRSxNQUFNNzFFLEVBQUUyQixHQUFnQixZQUFMLFNBQVhBLEtBQUYzQixFQUE4QixTQUE1QjJCLEtBQUYzQixFQUEwQzthQUVoRDgxRSxLQUFLajNFO01QakVWLEdPaUVVQSx5QkFDMEI7TUFFYixlQUhiQSxNQUdvQyxXQUhwQ0E7TUFHb0MsR0FBZHhFLEtBQXZCMkk7T0FHUTtVQUhlM0ksSUFBdkIySTtRQUNBZzlCLEVBR0EsVUFKQWg5QixLQUlvRCxzQkFBRixlQUQ5Q3FhOztPQUdJO1lBTlJyYSxJQUF1QjNJO1FBQ3ZCMmxDLEVBTUEsVUFQdUIzbEMsS0FPMkIsaUJBRDlDdTdFLE1BQzRDLGVBRDVDQTtNQUdSLFNBWksvMkUsS0FhMkIsWUFUNUJtaEMsUUFKQ25oQyxPQUlEbWhDO01BRGMsSUFDZCsxQyxVQUpDbDNFLEtBSURtaEM7TUFVZ0Isa0JBWE8zbEMsSUFDdkIybEMsTUFXSDthQUVEZzJDLElBQUluM0U7TUFDTSxJQUFSaUwsRUFBUSxTQUROakwsTUFDcUIsWUFBdkJpTCxJQUFnQyxTQUQ5QmpMLE1BQ0ZpTCxJQUFvRCxTQURsRGpMLE1BQ3dEO2FBRTVEbzNFLElBQUlwM0U7TUFBb0Msb0JBQXBDQSxXQUF1QixxQkFBUixLQUFmQSxTQUErQzthQUVuRHEzRSxJQUFJcjNFLEVBQUVDLEdBQVEsZUFBUkEsRUFBZSxJQUFqQkQsSUFBeUI7Ozs7T0FuRTdCMUU7T0FDQUM7T0FDQUM7T0FNQWc3RTtPQUVBQztPQU5BSDtPQUVBQztPQU1BRztPQWVBRTtPQVpBRDtPQThCQU07T0FoQkFKO09BRUFDO09BVUFoekQ7T0FFQWt6RDtPQW1CQUc7T0FHQUM7T0FFQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPTTlEQS9vRTtPQUlBck07OztPQUZBdU07T0FNQXhNO09BSUF5TTtPQVFBSztPQWVBTTs7T0FQQXJOO09BRUlnTjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SXFDckNNLElBQVZ1b0UsUUFBVTthQUVWQyxxQkFBcUI3M0UsR0FDdkIsT0FIRTQzRSxRQUdjLFdBRE81M0UsTUFDSztJQUhoQixTQWtCUjgzRSxTQUFRMUQ7TUFDUDtRQUNhLHFCQUZOQSxNQUdSLEtBREkyRDtRQU9KLCtCQUxJcCtEO1FBS0osT0FMSUE7TUFPRyxVeEM4R1RsWCxTd0MxR0c7SUFqQ08sU0F1Q1J1MUUsV0FBWUMsS0FBS3QrRCxFQUFHdStEO01BQ3RCOztpQkFDRSxzQ0FGWUQsS0FBS3QrRCxLQUFHdStELFdBRWtCLEVBQUM7SUF6Qy9CLFNBK0NSQyxlQUFnQkYsS0FBS3QrRDtNQUN2Qjs7aUJBQ0UsR0FGcUJBLEtBRUo7aUJBQ2pCLCtCQUhnQnMrRCxLQUFLdCtEO2lCQUlyQixVQUpxQkE7aUJBSXJCO3lCQUNnQixFQUFDO0lBcERULGNBa0JSbStELFNBcUJBRSxXQVFBRztJQS9DUSxTQTREUkMsT0FBTUg7VUFBc0JGLGlCQUFmTTthQTFEZlI7O2lCQTRERSxHQUZhUSxPQUVFO2lCQUNmO2lCQUNBLHNDQUpNSixLQUFzQkYsUUFJVjtJQWhFVixnQkE0RFJLO0lBNURRLFNBdUVWRSwrQkFBb0NKO01BQ3RDOztpQkFDRSxzQ0FGb0NBLFdBRVUsRUFBQztJQXpFckM7O1NBQVZOLHdCQXVFQVU7SUF2RVU7O0tDeUNWQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBQztLQUNBNzdCO2FBRUE4N0I7O2VBQ1c7ZUFDQTtlQUNJO2VBQ0U7ZUFDRDtlQUNFO2VBQ1Q7ZUFDQTtlQUNGO2VBQ007Z0JBQ0E7Z0JBQ0E7Z0JBQ0wsU0FBQztRQUtUQyxXQUNBQzthQVlFQyxLQUFLbDJFO01BQ0MsdUJBRERBLEdBRUMsaUJBREozQixLQUNJLEtBREpBLFVBQ0k7O1lBQ1IzRjtRQUFvQjtVQUFTLDZCQUh0QnNILEVBR1B0SDtVQUFvQixpQkFEaEJtZCxFQUNKbmQ7VUFBNkIsU0FBN0JBOzs7TUFDQSxPQUZJbWQsQ0FFSDthQU9Dc2dFLGNBQWMxUztNQUNrQixnQ0FBeUIsS0FEM0NBO01BQ2hCLG1DQUFvQixhQURKQSxXQUNzRDtvQkFacEV5UyxLQVdBQzthQXFCQUMsU0FBTzVqQyxLQUFLNmpDLFFBQ2Qsc0JBRFM3akMsS0FBSzZqQyxXQUNrQjthQUM5QkMsTUFBSTdTLEtBQU0sbUNBQU5BLFFBQTJCO2FBQy9COFMsTUFBSTlTO01BQU07NEJuRDNJakIsbUNtRDJJV0EsZUFBMkI7YUFPL0IrUyxnQkFBYy9TO01BQXlCLHVDQUF6QkEsS0FBbUM7YUFLakRnVCxTQUFTamtDLEtBQUs2akMsT0FBTzMxRTtNQUNmLElBQUpWLEVBQUksU0FER3d5QyxLQUFLNmpDLFFBRWhCLGlCQURJcjJFLEdBRG1CVSxHQUV2QixPQURJVixDQUVIO2FBS0MwMkUsVUFBT2xrQyxLQUFLNmpDLE9BQU9NO01BQ3JCLHNCQURTbmtDLEtBQUs2akMsVUFBT00sS0FDYzthQWFqQ0MsZ0JBQWNuVDtNQUNrQix1QkFEbEJBO01BQ2hCLG1DQUFvQixhQURKQSxXQUMyQjthQUd6Q29ULE1BQWdCNzJFLEVBQTBCM0I7TUFDdEMsaUNBRFkyQjtNQUNaLGFBRWUsY0FISEEsS0FBMEIzQixJQUU3QixjQUZHMkIsS0FBMEIzQixHQUc0QjthQUd0RXk0RSxTQUFrQnRrQyxLQUFNNmpDLE9BQWtCL3REO01BQ25DO29CQURXa3FCLEtBQU02akMsT0FBa0IvdEQ7T0FDbkMsSUFEaUIrdEQ7T0FPMUIsS0FQNEMvdEQ7T0FPNUM7OztRQUFzQzs7WUFObEN5dUQsR0FNSnIrRSxJQUxJMkgsUUFLMEQsaUJBUGxCaW9CLEtBTzVDNXZCO1VBQXNDLFNBQXRDQTs7O01BQ0EsT0FQSXErRSxFQU9GO2FBS0FDLFVBQU94a0MsS0FBSzZqQyxPQUFPWSxLQUFLQztNQUMxQixzQkFEUzFrQyxLQUFLNmpDLFVBQU9ZLEtBQUtDLE1BQ2dCO2FBZXhDQyxnQkFBYzFUO01BQytCLHVCQUQvQkEsS0FDa0IsbUJBRGxCQTtNQUNoQjsyQ0FBb0IsYUFESkEsaUJBQ3lDO2FBT3ZEMlQsV0FBV3AzRSxFQUFFM0IsR0FBSSxxQkFBTjJCLEtBQUUzQixHQUErQjthQUM1Q2c1RSxZQUFZcjNFLEVBQUUzQixHQUFJLHFCQUFOMkIsS0FBRTNCLEdBQWdDO2FBRzlDaTVFLFdBQWtCOWtDLEtBQU02akMsT0FBa0IvdEQ7TUFDNUM7WUFENENBO09BQzVDLFdBQUkydUQsT0FDNEMsaUJBRkozdUQ7T0FHbkMsYUFIV2txQixLQUFNNmpDLE9BQ3RCWSxLQUNBQztPQUNLLElBSGlCYjtPQVMxQixLQVJJWTtPQVFKOzs7UUFDRTtVQUFVLElBQU5NLElBQU0saUJBVmdDanZELEtBUzVDNXZCO1VBQ1ksR0FBTjYrRSxtQkFSRkw7V0FVQTtVQUZRLElBRXFELEtBVjdEQSxhQVU2RDs7Z0JBQy9EeG5FO1lBQ0U7O2dCQVhBcW5FLEdBTUpyK0UsSUFMSTJILFFBU0ZxUCxJQVRFclAsUUFVa0MsaUJBSmhDazNFLElBR0o3bkU7Y0FDRSxTQURGQTs7O1VBSFUsU0FEWmhYOzs7TUFRQSxPQWRJcStFLEVBY0Y7YUFLQVMsVUFBT2hsQyxLQUFLNmpDLE9BQU9ZLEtBQUtDLEtBQUtPO01BQy9CLHNCQURTamxDLEtBQUs2akMsVUFBT1ksS0FBS0MsS0FBS08sTUFDaUI7YUFpQjlDQyxnQkFBY2pVO01BQzRDO2tDQUQ1Q0E7T0FDK0IsbUJBRC9CQTtPQUNrQixtQkFEbEJBO01BQ2hCOzs2Q0FBb0IsYUFESkE7b0JBQ3NEO2FBT3BFa1UsYUFBYTMzRSxFQUFFM0IsRUFBRW1kLEdBQUkscUJBQVJ4YixLQUFFM0IsRUFBRW1kLEdBQWtDO2FBQ25EbzhELGNBQWM1M0UsRUFBRTNCLEVBQUVtZCxHQUFJLHFCQUFSeGIsS0FBRTNCLEVBQUVtZCxHQUFtQzthQUNyRHE4RCxhQUFhNzNFLEVBQUUzQixHQUFJLHFCQUFOMkIsS0FBRTNCLEdBQStCO2FBQzlDeTVFLGNBQWM5M0UsRUFBRTNCLEdBQUkscUJBQU4yQixLQUFFM0IsR0FBZ0M7YUFHaEQwNUUsV0FBa0J2bEMsS0FBTTZqQyxPQUFrQi90RDtNQUM1QztZQUQ0Q0E7T0FDNUMsV0FBSTJ1RCxPQUM0QyxpQkFGSjN1RDtPQUc1QztjQURJNHVEOztVQUNvRCxpQkFBUixpQkFISjV1RDtPQUluQyxhQUpXa3FCLEtBQU02akMsT0FDdEJZLEtBQ0FDLEtBQ0FPO09BQ0ssSUFKaUJwQjtPQVUxQixLQVRJWTtPQVNKOzs7UUFDRTtVQUFVLElBQU5NLElBQU0saUJBWGdDanZELEtBVTVDNXZCO1VBQ1ksR0FBTjYrRSxtQkFURkw7V0FXQTtVQUZRLElBRStDLEtBWHZEQSxhQVd1RDs7Z0JBQ3pEeG5FO1lBQ0U7Y0FBVSxJQUFOc29FLElBQU0saUJBSlJULElBR0o3bkU7Y0FDWSxHQUFOc29FLG1CQVpKUDtlQWNFO2NBRlEsSUFFK0MsS0FkekRBLGFBY3lEOztvQkFDekR4dUQ7Z0JBQ0U7O29CQWZGOHREO29CQU1KcitFLElBTEkySDtvQkFTRnFQLElBVEVyUDtvQkFhQTRvQixJQWJBNW9CO29CQWM4QyxpQkFKMUMyM0UsSUFHSi91RDtrQkFDRSxTQURGQTs7O2NBSFUsU0FEWnZaOzs7VUFIVSxTQURaaFg7OztNQWFBLE9BbkJJcStFLEVBbUJGO2FBV0ZrQixtQkFBbUJqNEU7TUFDbEIsOEJBRGtCQTs7ZUFFaEIsMkNBQXlDO2FBQzVDazRFLG1CQUFtQmw0RTtNQUNsQiw4QkFEa0JBOztlQUVoQiwyQ0FBeUM7YUFDNUNtNEUsbUJBQW1CbjRFO01BQ2xCLDhCQURrQkE7O2VBRWhCLDJDQUF5QzthQUM1Q280RSxtQkFBbUJwNEU7TUFDbEIsOEJBRGtCQTs7ZUFFaEIsMkNBQXlDO2FBSzVDcTRFLFVBQVVyNEUsR0FBSSx1QkFBSkEsTUFBa0I7YUFDNUJzNEUsVUFBVXQ0RSxFQUFFaTNFLE1BQU8sdUJBQVRqM0UsS0FBRWkzRSxNQUF5QjthQUNyQ3NCLFVBQVV2NEUsRUFBRWkzRSxLQUFLQyxNQUFPLHVCQUFkbDNFLEtBQUVpM0UsS0FBS0MsTUFBOEI7YUFDL0NzQixVQUFVeDRFLEVBQUVpM0UsS0FBS0MsS0FBS087TUFBTyx1QkFBbkJ6M0UsS0FBRWkzRSxLQUFLQyxLQUFLTyxNQUFtQzs7OztPQWhSekR0QztPQUNBQztPQVNBUztPQUNBQztPQVRBVDtPQUNBQztPQUNBQztPQUNBQztPQUdBRztPQUZBRjtPQUNBQztPQUVBRTtPQUdBMzdCO09BRUE4N0I7T0FrQkFDO09BQ0FDOztVQTRDRUcsK0JBVUFJLGdCQVJBRixNQUNBQyxNQVlBRTtVQVFBQyxnQ0FjQUUsZ0JBSUFDLE1BTUFDOztRQWFBRTs7UUFnQkFHO1FBUUFDO1FBQ0FDO1FBR0FDOztRQXNCQUU7O1FBa0JBRTtRQVFBQztRQUNBQztRQUNBQztRQUNBQztRQUdBQztPQWtDRkU7T0FHQUM7T0FHQUM7T0FHQUM7O09BT0FDO09BQ0FDO09BQ0FDO09BQ0FDOztVbkQzVUw7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VW1EQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VDQ0NDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUJDQ0NDO0lEREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQ0NDQyxLRERELEdDQ0NDO0lEREQ7Ozs7Ozs7ZUNDQ0g7SURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttRENDWUksS0FBTyxNQUFNQSxHQUF2QixJRERGOzs7OztpQkNDQ0g7SURERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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L0twRTtNQytLb0Usa0NBQThCO0lBQS9GOzs7O09BektFeEI7T0FJQUM7T0FNQUk7T0FFQUM7T0FRQUc7T0FHQUc7T0FHQUU7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FDQUM7T0FHQUM7T0FDQUk7T0FFQUM7T0FlQU87T0FnREFKO09BQ0FnQjtPQUNBUjtPQUNBUztPQUVBQztPQXFCQVE7T0FJQUM7T0FrQ0FHO0lBSUY7VUQvS0g7Ozs7Ozs7SUNBQTs7OztJQ2tCUzs7O1VEbEJUIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG52YXIgY2FtbF9pbnQ2NF9vZmZzZXQgPSBNYXRoLnBvdygyLCAtMjQpO1xuXG4vL1Byb3ZpZGVzOiBNbEludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mZnNldCwgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZVxuZnVuY3Rpb24gTWxJbnQ2NCAobG8sbWksaGkpIHtcbiAgdGhpcy5sbyA9IGxvICYgMHhmZmZmZmY7XG4gIHRoaXMubWkgPSBtaSAmIDB4ZmZmZmZmO1xuICB0aGlzLmhpID0gaGkgJiAweGZmZmY7XG59XG5NbEludDY0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX2pcIlxuTWxJbnQ2NC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG8sdGhpcy5taSx0aGlzLmhpKTtcbn1cblxuTWxJbnQ2NC5wcm90b3R5cGUudWNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICBpZiAodGhpcy5oaSA+IHguaGkpIHJldHVybiAxO1xuICBpZiAodGhpcy5oaSA8IHguaGkpIHJldHVybiAtMTtcbiAgaWYgKHRoaXMubWkgPiB4Lm1pKSByZXR1cm4gMTtcbiAgaWYgKHRoaXMubWkgPCB4Lm1pKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLmxvID4geC5sbykgcmV0dXJuIDE7XG4gIGlmICh0aGlzLmxvIDwgeC5sbykgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgaGkgPSB0aGlzLmhpIDw8IDE2O1xuICB2YXIgeGhpID0geC5oaSA8PCAxNjtcbiAgaWYgKGhpID4geGhpKSByZXR1cm4gMTtcbiAgaWYgKGhpIDwgeGhpKSByZXR1cm4gLTE7XG4gIGlmICh0aGlzLm1pID4geC5taSkgcmV0dXJuIDE7XG4gIGlmICh0aGlzLm1pIDwgeC5taSkgcmV0dXJuIC0xO1xuICBpZiAodGhpcy5sbyA+IHgubG8pIHJldHVybiAxO1xuICBpZiAodGhpcy5sbyA8IHgubG8pIHJldHVybiAtMTtcbiAgcmV0dXJuIDA7XG59XG5NbEludDY0LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsbyA9IC0gdGhpcy5sbztcbiAgdmFyIG1pID0gLSB0aGlzLm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gLSB0aGlzLmhpICsgKG1pID4+IDI0KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KGxvLCBtaSwgaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIGxvID0gdGhpcy5sbyArIHgubG87XG4gIHZhciBtaSA9IHRoaXMubWkgKyB4Lm1pICsgKGxvID4+IDI0KTtcbiAgdmFyIGhpID0gdGhpcy5oaSArIHguaGkgKyAobWkgPj4gMjQpO1xuICByZXR1cm4gbmV3IE1sSW50NjQobG8sIG1pLCBoaSk7XG59XG5NbEludDY0LnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbG8gPSB0aGlzLmxvIC0geC5sbztcbiAgdmFyIG1pID0gdGhpcy5taSAtIHgubWkgKyAobG8gPj4gMjQpO1xuICB2YXIgaGkgPSB0aGlzLmhpIC0geC5oaSArIChtaSA+PiAyNCk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBsbyA9IHRoaXMubG8gKiB4LmxvO1xuICB2YXIgbWkgPSAoKGxvICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLm1pICogeC5sbyArIHRoaXMubG8gKiB4Lm1pO1xuICB2YXIgaGkgPSAoKG1pICogY2FtbF9pbnQ2NF9vZmZzZXQpIHwgMCkgKyB0aGlzLmhpICogeC5sbyArIHRoaXMubWkgKiB4Lm1pICsgdGhpcy5sbyAqIHguaGk7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLmxvfHRoaXMubWl8dGhpcy5oaSkgPT0gMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKHRoaXMuaGkgPDwgMTYpIDwgMDtcbn1cbk1sSW50NjQucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh0aGlzLmxvICYgeC5sbywgdGhpcy5taSAmIHgubWksIHRoaXMuaGkgJiB4LmhpKTtcbn1cbk1sSW50NjQucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG98eC5sbywgdGhpcy5taXx4Lm1pLCB0aGlzLmhpfHguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIG5ldyBNbEludDY0KHRoaXMubG9eeC5sbywgdGhpcy5taV54Lm1pLCB0aGlzLmhpXnguaGkpO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfbGVmdCA9IGZ1bmN0aW9uIChzKSB7XG4gIHMgPSBzICYgNjM7XG4gIGlmIChzID09IDApIHJldHVybiB0aGlzO1xuICBpZiAocyA8IDI0KSB7XG4gICAgcmV0dXJuIG5ldyBNbEludDY0ICh0aGlzLmxvIDw8IHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCBzKSB8ICh0aGlzLmxvID4+ICgyNCAtIHMpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmhpIDw8IHMpIHwgKHRoaXMubWkgPj4gKDI0IC0gcykpKTtcbiAgfVxuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG8gPDwgKHMgLSAyNCksXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5taSA8PCAocyAtIDI0KSkgfCAodGhpcy5sbyA+PiAoNDggLSBzKSkpO1xuICByZXR1cm4gbmV3IE1sSW50NjQoMCwgMCwgdGhpcy5sbyA8PCAocyAtIDQ4KSlcbn1cbk1sSW50NjQucHJvdG90eXBlLnNoaWZ0X3JpZ2h0X3Vuc2lnbmVkID0gZnVuY3Rpb24gKHMpIHtcbiAgcyA9IHMgJiA2MztcbiAgaWYgKHMgPT0gMCkgcmV0dXJuIHRoaXM7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAodGhpcy5oaSA8PCAoMjQgLSBzKSksXG4gICAgICAodGhpcy5oaSA+PiBzKSk7XG4gIGlmIChzIDwgNDgpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLm1pID4+IChzIC0gMjQpKSB8ICh0aGlzLmhpIDw8ICg0OCAtIHMpKSxcbiAgICAgICh0aGlzLmhpID4+IChzIC0gMjQpKSxcbiAgICAgIDApO1xuICByZXR1cm4gbmV3IE1sSW50NjQgKHRoaXMuaGkgPj4gKHMgLSA0OCksIDAsIDApO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUuc2hpZnRfcmlnaHQgPSBmdW5jdGlvbiAocykge1xuICBzID0gcyAmIDYzO1xuICBpZiAocyA9PSAwKSByZXR1cm4gdGhpcztcbiAgdmFyIGggPSAodGhpcy5oaSA8PCAxNikgPj4gMTY7XG4gIGlmIChzIDwgMjQpXG4gICAgcmV0dXJuIG5ldyBNbEludDY0IChcbiAgICAgICh0aGlzLmxvID4+IHMpIHwgKHRoaXMubWkgPDwgKDI0IC0gcykpLFxuICAgICAgKHRoaXMubWkgPj4gcykgfCAoaCA8PCAoMjQgLSBzKSksXG4gICAgICAoKHRoaXMuaGkgPDwgMTYpID4+IHMpID4+PiAxNik7XG4gIHZhciBzaWduID0gKHRoaXMuaGkgPDwgMTYpID4+IDMxO1xuICBpZiAocyA8IDQ4KVxuICAgIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgICAodGhpcy5taSA+PiAocyAtIDI0KSkgfCAodGhpcy5oaSA8PCAoNDggLSBzKSksXG4gICAgICAodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAyNCkgPj4gMTYsXG4gICAgICBzaWduICYgMHhmZmZmKTtcbiAgcmV0dXJuIG5ldyBNbEludDY0ICgodGhpcy5oaSA8PCAxNikgPj4gKHMgLSAzMiksIHNpZ24sIHNpZ24pO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubHNsMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oaSA9ICh0aGlzLmhpIDw8IDEpIHwgKHRoaXMubWkgPj4gMjMpO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pIDw8IDEpIHwgKHRoaXMubG8gPj4gMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSkgJiAweGZmZmZmZjtcbn1cbk1sSW50NjQucHJvdG90eXBlLmxzcjEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEpIHwgKHRoaXMubWkgPDwgMjMpKSAmIDB4ZmZmZmZmO1xuICB0aGlzLm1pID0gKCh0aGlzLm1pID4+PiAxKSB8ICh0aGlzLmhpIDw8IDIzKSkgJiAweGZmZmZmZjtcbiAgdGhpcy5oaSA9IHRoaXMuaGkgPj4+IDE7XG59XG5NbEludDY0LnByb3RvdHlwZS51ZGl2bW9kID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciBtb2R1bHVzID0gdGhpcy5jb3B5KCk7XG4gIHZhciBkaXZpc29yID0geC5jb3B5KCk7XG4gIHZhciBxdW90aWVudCA9IG5ldyBNbEludDY0KDAsMCwwKTtcbiAgd2hpbGUgKG1vZHVsdXMudWNvbXBhcmUoZGl2aXNvcikgPiAwKSB7XG4gICAgb2Zmc2V0Kys7XG4gICAgZGl2aXNvci5sc2wxKCk7XG4gIH1cbiAgd2hpbGUgKG9mZnNldCA+PSAwKSB7XG4gICAgb2Zmc2V0IC0tO1xuICAgIHF1b3RpZW50LmxzbDEoKTtcbiAgICBpZiAobW9kdWx1cy51Y29tcGFyZShkaXZpc29yKSA+PSAwKSB7XG4gICAgICBxdW90aWVudC5sbyArKztcbiAgICAgIG1vZHVsdXMgPSBtb2R1bHVzLnN1YihkaXZpc29yKTtcbiAgICB9XG4gICAgZGl2aXNvci5sc3IxKCk7XG4gIH1cbiAgcmV0dXJuIHsgcXVvdGllbnQgOiBxdW90aWVudCwgbW9kdWx1cyA6IG1vZHVsdXMgfTtcbn1cbk1sSW50NjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh5KVxue1xuICB2YXIgeCA9IHRoaXM7XG4gIGlmICh5LmlzWmVybygpKSBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpO1xuICB2YXIgc2lnbiA9IHguaGkgXiB5LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHEgPSB4LnVkaXZtb2QoeSkucXVvdGllbnQ7XG4gIGlmIChzaWduICYgMHg4MDAwKSBxID0gcS5uZWcoKTtcbiAgcmV0dXJuIHE7XG59XG5NbEludDY0LnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiAoeSlcbntcbiAgdmFyIHggPSB0aGlzO1xuICBpZiAoeS5pc1plcm8oKSkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgdmFyIHNpZ24gPSB4LmhpO1xuICBpZiAoeC5oaSAmIDB4ODAwMCkgeCA9IHgubmVnKCk7XG4gIGlmICh5LmhpICYgMHg4MDAwKSB5ID0geS5uZWcoKTtcbiAgdmFyIHIgPSB4LnVkaXZtb2QoeSkubW9kdWx1cztcbiAgaWYgKHNpZ24gJiAweDgwMDApIHIgPSByLm5lZygpO1xuICByZXR1cm4gcjtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sbyB8ICh0aGlzLm1pIDw8IDI0KTtcbn1cbk1sSW50NjQucHJvdG90eXBlLnRvRmxvYXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoKHRoaXMuaGkgPDwgMTYpICogTWF0aC5wb3coMiwgMzIpICsgdGhpcy5taSAqIE1hdGgucG93KDIsIDI0KSkgKyB0aGlzLmxvO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFt0aGlzLmhpID4+IDgsXG4gICAgICAgICAgdGhpcy5oaSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSA+PiAxNixcbiAgICAgICAgICAodGhpcy5taSA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5taSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyA+PiAxNixcbiAgICAgICAgICAodGhpcy5sbyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgdGhpcy5sbyAmIDB4ZmZdO1xufVxuTWxJbnQ2NC5wcm90b3R5cGUubG8zMiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubG8gfCAoKHRoaXMubWkgJiAweGZmKSA8PCAyNCk7XG59XG5NbEludDY0LnByb3RvdHlwZS5oaTMyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKCh0aGlzLm1pID4+PiA4KSAmIDB4ZmZmZikgfCAodGhpcy5oaSA8PCAxNik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdWx0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3VsdCh4LHkpIHsgcmV0dXJuIHgudWNvbXBhcmUoeSkgPCAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfY29tcGFyZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jb21wYXJlKHgseSwgdG90YWwpIHsgcmV0dXJuIHguY29tcGFyZSh5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbmVnIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X25lZyAoeCkgeyByZXR1cm4geC5uZWcoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYWRkIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FkZCAoeCwgeSkgeyByZXR1cm4geC5hZGQoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3N1YiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9zdWIgKHgsIHkpIHsgcmV0dXJuIHguc3ViKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tdWwgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0XG5mdW5jdGlvbiBjYW1sX2ludDY0X211bCh4LHkpIHsgcmV0dXJuIHgubXVsKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc196ZXJvIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2lzX3plcm8oeCkgeyByZXR1cm4gK3guaXNaZXJvKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSh4KSB7IHJldHVybiAreC5pc05lZygpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYW5kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2FuZCAoeCwgeSkgeyByZXR1cm4geC5hbmQoeSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vciAoeCwgeSkgeyByZXR1cm4geC5vcih5KTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3hvciBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF94b3IgKHgsIHkpIHsgcmV0dXJuIHgueG9yKHkpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9zaGlmdF9sZWZ0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X2xlZnQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfbGVmdChzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfc2hpZnRfcmlnaHRfdW5zaWduZWQgKHgsIHMpIHsgcmV0dXJuIHguc2hpZnRfcmlnaHRfdW5zaWduZWQocykgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X3NoaWZ0X3JpZ2h0ICh4LCBzKSB7IHJldHVybiB4LnNoaWZ0X3JpZ2h0KHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9kaXYgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZGl2ICh4LCB5KSB7IHJldHVybiB4LmRpdih5KSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbW9kIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ludDY0X21vZCAoeCwgeSkgeyByZXR1cm4geC5tb2QoeSkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X29mX2ludDMyIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2ludDMyICh4KSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCh4ICYgMHhmZmZmZmYsICh4ID4+IDI0KSAmIDB4ZmZmZmZmLCAoeCA+PiAzMSkgJiAweGZmZmYpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9faW50MzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9faW50MzIgKHgpIHsgcmV0dXJuIHgudG9JbnQoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdG9fZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfdG9fZmxvYXQgKHgpIHsgcmV0dXJuIHgudG9GbG9hdCAoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2Zmc2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX2Zsb2F0ICh4KSB7XG4gIGlmICh4IDwgMCkgeCA9IE1hdGguY2VpbCh4KTtcbiAgcmV0dXJuIG5ldyBNbEludDY0KFxuICAgIHggJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCkgJiAweGZmZmZmZixcbiAgICBNYXRoLmZsb29yKHggKiBjYW1sX2ludDY0X29mZnNldCAqIGNhbWxfaW50NjRfb2Zmc2V0KSAmIDB4ZmZmZik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfZm9ybWF0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3BhcnNlX2Zvcm1hdCwgY2FtbF9maW5pc2hfZm9ybWF0dGluZ1xuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9pc19uZWdhdGl2ZSwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfaW50MzIsIGNhbWxfaW50NjRfdG9faW50MzJcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfaXNfemVybywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2ludDY0X2Zvcm1hdCAoZm10LCB4KSB7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGYuc2lnbmVkY29udiAmJiBjYW1sX2ludDY0X2lzX25lZ2F0aXZlKHgpKSB7XG4gICAgZi5zaWduID0gLTE7IHggPSBjYW1sX2ludDY0X25lZyh4KTtcbiAgfVxuICB2YXIgYnVmZmVyID0gXCJcIjtcbiAgdmFyIHdiYXNlID0gY2FtbF9pbnQ2NF9vZl9pbnQzMihmLmJhc2UpO1xuICB2YXIgY3Z0YmwgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgZG8ge1xuICAgIHZhciBwID0geC51ZGl2bW9kKHdiYXNlKTtcbiAgICB4ID0gcC5xdW90aWVudDtcbiAgICBidWZmZXIgPSBjdnRibC5jaGFyQXQoY2FtbF9pbnQ2NF90b19pbnQzMihwLm1vZHVsdXMpKSArIGJ1ZmZlcjtcbiAgfSB3aGlsZSAoISBjYW1sX2ludDY0X2lzX3plcm8oeCkpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKG4gPiAwKSBidWZmZXIgPSBjYW1sX3N0cl9yZXBlYXQgKG4sICcwJykgKyBidWZmZXI7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgYnVmZmVyKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9mYWlsd2l0aCwgY2FtbF9wYXJzZV9kaWdpdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9pbnQzMiwgY2FtbF9pbnQ2NF91bHRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfYWRkLCBjYW1sX2ludDY0X211bCwgY2FtbF9pbnQ2NF9uZWdcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCxjYW1sX3N0cmluZ191bnNhZmVfZ2V0LCBNbEludDY0XG5mdW5jdGlvbiBjYW1sX2ludDY0X29mX3N0cmluZyhzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBiYXNlNjQgPSBjYW1sX2ludDY0X29mX2ludDMyKGJhc2UpO1xuICB2YXIgdGhyZXNob2xkID1cbiAgICAgIG5ldyBNbEludDY0KDB4ZmZmZmZmLCAweGZmZmZmZmYsIDB4ZmZmZikudWRpdm1vZChiYXNlNjQpLnF1b3RpZW50O1xuICB2YXIgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gIHZhciBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgaWYgKGQgPCAwIHx8IGQgPj0gYmFzZSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIHZhciByZXMgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIGMgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpO1xuICAgIGlmIChjID09IDk1KSBjb250aW51ZTtcbiAgICBkID0gY2FtbF9wYXJzZV9kaWdpdChjKTtcbiAgICBpZiAoZCA8IDAgfHwgZCA+PSBiYXNlKSBicmVhaztcbiAgICAvKiBEZXRlY3Qgb3ZlcmZsb3cgaW4gbXVsdGlwbGljYXRpb24gYmFzZSAqIHJlcyAqL1xuICAgIGlmIChjYW1sX2ludDY0X3VsdCh0aHJlc2hvbGQsIHJlcykpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICAgIGQgPSBjYW1sX2ludDY0X29mX2ludDMyKGQpO1xuICAgIHJlcyA9IGNhbWxfaW50NjRfYWRkKGNhbWxfaW50NjRfbXVsKGJhc2U2NCwgcmVzKSwgZCk7XG4gICAgLyogRGV0ZWN0IG92ZXJmbG93IGluIGFkZGl0aW9uIChiYXNlICogcmVzKSArIGQgKi9cbiAgICBpZiAoY2FtbF9pbnQ2NF91bHQocmVzLCBkKSkgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIH1cbiAgaWYgKGkgIT0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKSBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKGJhc2UgPT0gMTAgJiYgY2FtbF9pbnQ2NF91bHQobmV3IE1sSW50NjQoMCwgMCwgMHg4MDAwKSwgcmVzKSlcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgaWYgKHNpZ24gPCAwKSByZXMgPSBjYW1sX2ludDY0X25lZyhyZXMpO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9jcmVhdGVfbG9fbWlfaGkobG8sIG1pLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChsbywgbWksIGhpKVxufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGkgY29uc3Rcbi8vUmVxdWlyZXM6IE1sSW50NjRcbmZ1bmN0aW9uIGNhbWxfaW50NjRfY3JlYXRlX2xvX2hpKGxvLCBoaSl7XG4gIHJldHVybiBuZXcgTWxJbnQ2NCAoXG4gICAgbG8gJiAweGZmZmZmZixcbiAgICAoKGxvID4+PiAyNCkgJiAweGZmKSB8ICgoaGkgJiAweGZmZmYpIDw8IDgpLFxuICAgIChoaSA+Pj4gMTYpICYgMHhmZmZmKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfbG8zMiBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9sbzMyKHYpeyByZXR1cm4gdi5sbzMyKCkgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2hpMzIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfaGkzMih2KXsgcmV0dXJuIHYuaGkzMigpIH1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9vZl9ieXRlcyBjb25zdFxuLy9SZXF1aXJlczogTWxJbnQ2NFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKSB7XG4gIHJldHVybiBuZXcgTWxJbnQ2NChhWzddIDw8IDAgfCAoYVs2XSA8PCA4KSB8IChhWzVdIDw8IDE2KSxcbiAgICAgICAgICAgICAgICAgICAgIGFbNF0gPDwgMCB8IChhWzNdIDw8IDgpIHwgKGFbMl0gPDwgMTYpLFxuICAgICAgICAgICAgICAgICAgICAgYVsxXSA8PCAwIHwgKGFbMF0gPDwgOCkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF90b19ieXRlcyBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF90b19ieXRlcyh4KSB7IHJldHVybiB4LnRvQXJyYXkoKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfaGFzaCBjb25zdFxuZnVuY3Rpb24gY2FtbF9pbnQ2NF9oYXNoKHYpe1xuICByZXR1cm4gKHYubG8zMigpKSBeICh2LmhpMzIoKSlcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxMC0yMDE0IErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIEFuIE9DYW1sIHN0cmluZyBpcyBhbiBvYmplY3Qgd2l0aCB0aHJlZSBmaWVsZHM6XG4vLyAtIHRhZyAndCdcbi8vIC0gbGVuZ3RoICdsJ1xuLy8gLSBjb250ZW50cyAnYydcbi8vXG4vLyBUaGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBjYW4gYmUgZWl0aGVyIGEgSmF2YVNjcmlwdCBhcnJheSBvclxuLy8gYSBKYXZhU2NyaXB0IHN0cmluZy4gVGhlIGxlbmd0aCBvZiB0aGlzIHN0cmluZyBjYW4gYmUgbGVzcyB0aGFuIHRoZVxuLy8gbGVuZ3RoIG9mIHRoZSBPQ2FtbCBzdHJpbmcuIEluIHRoaXMgY2FzZSwgcmVtYWluaW5nIGJ5dGVzIGFyZVxuLy8gYXNzdW1lZCB0byBiZSB6ZXJvZXMuIEFycmF5cyBhcmUgbXV0YWJsZSBidXQgY29uc3VtZXMgbW9yZSBtZW1vcnlcbi8vIHRoYW4gc3RyaW5ncy4gQSBjb21tb24gcGF0dGVybiBpcyB0byBzdGFydCBmcm9tIGFuIGVtcHR5IHN0cmluZyBhbmRcbi8vIHByb2dyZXNzaXZlbHkgZmlsbCBpdCBmcm9tIHRoZSBzdGFydC4gUGFydGlhbCBzdHJpbmdzIG1ha2VzIGl0XG4vLyBwb3NzaWJsZSB0byBpbXBsZW1lbnQgdGhpcyBlZmZpY2llbnRseS5cbi8vXG4vLyBXaGVuIGNvbnZlcnRpbmcgdG8gYW5kIGZyb20gVVRGLTE2LCB3ZSBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlXG4vLyBzdHJpbmcgaXMgY29tcG9zZWQgb25seSBvZiBBU0NJSSBjaGFyYWN0ZXJzIChpbiB3aGljaCBjYXNlLCBub1xuLy8gY29udmVyc2lvbiBuZWVkcyB0byBiZSBwZXJmb3JtZWQpIG9yIG5vdC5cbi8vXG4vLyBUaGUgc3RyaW5nIHRhZyBjYW4gdGh1cyB0YWtlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuLy8gICBmdWxsIHN0cmluZyAgICAgQllURSB8IFVOS05PV046ICAgICAgMFxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IEFTQ0lJOiAgICAgICAgOVxuLy8gICAgICAgICAgICAgICAgICAgQllURSB8IE5PVF9BU0NJSTogICAgOFxuLy8gICBzdHJpbmcgcHJlZml4ICAgUEFSVElBTDogICAgICAgICAgICAgMlxuLy8gICBhcnJheSAgICAgICAgICAgQVJSQVk6ICAgICAgICAgICAgICAgNFxuLy9cbi8vIE9uZSBjYW4gdXNlIGJpdCBtYXNraW5nIHRvIGRpc2NyaW1pbmF0ZSB0aGVzZSBkaWZmZXJlbnQgY2FzZXM6XG4vLyAgIGtub3duX2VuY29kaW5nKHgpID0geCY4XG4vLyAgIGlzX2FzY2lpKHgpID0gICAgICAgeCYxXG4vLyAgIGtpbmQoeCkgPSAgICAgICAgICAgeCY2XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyX3JlcGVhdFxuZnVuY3Rpb24gY2FtbF9zdHJfcmVwZWF0KG4sIHMpIHtcbiAgaWYobiA9PSAwKSByZXR1cm4gXCJcIjtcbiAgaWYgKHMucmVwZWF0KSB7cmV0dXJuIHMucmVwZWF0KG4pO30gLy8gRUNNQXNjcmlwdCA2IGFuZCBGaXJlZm94IDI0K1xuICB2YXIgciA9IFwiXCIsIGwgPSAwO1xuICBmb3IoOzspIHtcbiAgICBpZiAobiAmIDEpIHIgKz0gcztcbiAgICBuID4+PSAxO1xuICAgIGlmIChuID09IDApIHJldHVybiByO1xuICAgIHMgKz0gcztcbiAgICBsKys7XG4gICAgaWYgKGwgPT0gOSkge1xuICAgICAgcy5zbGljZSgwLDEpOyAvLyBmbGF0dGVuIHRoZSBzdHJpbmdcbiAgICAgIC8vIHRoZW4sIHRoZSBmbGF0dGVuaW5nIG9mIHRoZSB3aG9sZSBzdHJpbmcgd2lsbCBiZSBmYXN0ZXIsXG4gICAgICAvLyBhcyBpdCB3aWxsIGJlIGNvbXBvc2VkIG9mIGxhcmdlciBwaWVjZXNcbiAgICB9XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzXG4vL1dlYWtkZWZcbi8vIFByZSBFQ01BU2NyaXB0IDUsIFthcHBseV0gd291bGQgbm90IHN1cHBvcnQgYXJyYXktbGlrZSBvYmplY3QuXG4vLyBJbiBzdWNoIHNldHVwLCBUeXBlZF9hcnJheSB3b3VsZCBiZSBpbXBsZW1lbnRlZCBhcyBwb2x5ZmlsbCwgYW5kIFtmLmFwcGx5XSB3b3VsZFxuLy8gZmFpbCBoZXJlLiBNYXJrIHRoZSBwcmltaXRpdmUgYXMgV2Vha2RlZiwgc28gdGhhdCBwZW9wbGUgY2FuIG92ZXJyaWRlIGl0IGVhc2lseS5cbmZ1bmN0aW9uIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcyAoYSwgaSwgbGVuKSB7XG4gIHZhciBmID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgaWYgKGkgPT0gMCAmJiBsZW4gPD0gNDA5NiAmJiBsZW4gPT0gYS5sZW5ndGgpIHJldHVybiBmLmFwcGx5IChudWxsLCBhKTtcbiAgdmFyIHMgPSBcIlwiO1xuICBmb3IgKDsgMCA8IGxlbjsgaSArPSAxMDI0LGxlbi09MTAyNClcbiAgICBzICs9IGYuYXBwbHkgKG51bGwsIGEuc2xpY2UoaSxpICsgTWF0aC5taW4obGVuLCAxMDI0KSkpO1xuICByZXR1cm4gcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF91dGY4X29mX3V0ZjE2XG5mdW5jdGlvbiBjYW1sX3V0Zjhfb2ZfdXRmMTYocykge1xuICBmb3IgKHZhciBiID0gXCJcIiwgdCA9IGIsIGMsIGQsIGkgPSAwLCBsID0gcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjID0gcy5jaGFyQ29kZUF0KGopKSA8IDB4ODA7IGorKyk7XG4gICAgICBpZiAoaiAtIGkgPiA1MTIpIHsgdC5zdWJzdHIoMCwgMSk7IGIgKz0gdDsgdCA9IFwiXCI7IGIgKz0gcy5zbGljZShpLCBqKSB9XG4gICAgICBlbHNlIHQgKz0gcy5zbGljZShpLCBqKTtcbiAgICAgIGlmIChqID09IGwpIGJyZWFrO1xuICAgICAgaSA9IGo7XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGMwIHwgKGMgPj4gNikpO1xuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9IGVsc2UgaWYgKGMgPCAweGQ4MDAgfHwgYyA+PSAweGRmZmYpIHtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGUwIHwgKGMgPj4gMTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gNikgJiAweDNmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKGMgJiAweDNmKSk7XG4gICAgfSBlbHNlIGlmIChjID49IDB4ZGJmZiB8fCBpICsgMSA9PSBsIHx8XG4gICAgICAgICAgICAgICAoZCA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGQgPiAweGRmZmYpIHtcbiAgICAgIC8vIFVubWF0Y2hlZCBzdXJyb2dhdGUgcGFpciwgcmVwbGFjZWQgYnkgXFx1ZmZmZCAocmVwbGFjZW1lbnQgY2hhcmFjdGVyKVxuICAgICAgdCArPSBcIlxceGVmXFx4YmZcXHhiZFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBpKys7XG4gICAgICBjID0gKGMgPDwgMTApICsgZCAtIDB4MzVmZGMwMDtcbiAgICAgIHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgKGMgPj4gMTgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKGMgPj4gMTIpICYgMHgzZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoYyA+PiA2KSAmIDB4M2YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoYyAmIDB4M2YpKTtcbiAgICB9XG4gICAgaWYgKHQubGVuZ3RoID4gMTAyNCkge3Quc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiO31cbiAgfVxuICByZXR1cm4gYit0O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3V0ZjE2X29mX3V0ZjhcbmZ1bmN0aW9uIGNhbWxfdXRmMTZfb2ZfdXRmOChzKSB7XG4gIGZvciAodmFyIGIgPSBcIlwiLCB0ID0gXCJcIiwgYywgYzEsIGMyLCB2LCBpID0gMCwgbCA9IHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYzEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMxIDwgMHg4MCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyAoaiA8IGwpICYmIChjMSA9IHMuY2hhckNvZGVBdChqKSkgPCAweDgwOyBqKyspO1xuICAgICAgaWYgKGogLSBpID4gNTEyKSB7IHQuc3Vic3RyKDAsIDEpOyBiICs9IHQ7IHQgPSBcIlwiOyBiICs9IHMuc2xpY2UoaSwgaikgfVxuICAgICAgZWxzZSB0ICs9IHMuc2xpY2UoaSwgaik7XG4gICAgICBpZiAoaiA9PSBsKSBicmVhaztcbiAgICAgIGkgPSBqO1xuICAgIH1cbiAgICB2ID0gMTtcbiAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgYyA9IGMyICsgKGMxIDw8IDYpO1xuICAgICAgaWYgKGMxIDwgMHhlMCkge1xuICAgICAgICB2ID0gYyAtIDB4MzA4MDtcbiAgICAgICAgaWYgKHYgPCAweDgwKSB2ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSAyO1xuICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSkge1xuICAgICAgICAgIGMgPSBjMiArIChjIDw8IDYpO1xuICAgICAgICAgIGlmIChjMSA8IDB4ZjApIHtcbiAgICAgICAgICAgIHYgPSBjIC0gMHhlMjA4MDtcbiAgICAgICAgICAgIGlmICgodiA8IDB4ODAwKSB8fCAoKHYgPj0gMHhkN2ZmKSAmJiAodiA8IDB4ZTAwMCkpKSB2ID0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdiA9IDM7XG4gICAgICAgICAgICBpZiAoKCsraSA8IGwpICYmICgoKGMyID0gcy5jaGFyQ29kZUF0KGkpKSAmIC02NCkgPT0gMTI4KSAmJlxuICAgICAgICAgICAgICAgIChjMSA8IDB4ZjUpKSB7XG4gICAgICAgICAgICAgIHYgPSBjMiAtIDB4M2M4MjA4MCArIChjIDw8IDYpO1xuICAgICAgICAgICAgICBpZiAodiA8IDB4MTAwMDAgfHwgdiA+IDB4MTBmZmZmKSB2ID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHYgPCA0KSB7IC8vIEludmFsaWQgc2VxdWVuY2VcbiAgICAgIGkgLT0gdjtcbiAgICAgIHQgKz0gXCJcXHVmZmZkXCI7XG4gICAgfSBlbHNlIGlmICh2ID4gMHhmZmZmKVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDdjMCArICh2ID4+IDEwKSwgMHhkYzAwICsgKHYgJiAweDNGRikpXG4gICAgZWxzZVxuICAgICAgdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHYpO1xuICAgIGlmICh0Lmxlbmd0aCA+IDEwMjQpIHt0LnN1YnN0cigwLCAxKTsgYiArPSB0OyB0ID0gXCJcIjt9XG4gIH1cbiAgcmV0dXJuIGIrdDtcbn1cblxuLy9Qcm92aWRlczoganNvb19pc19hc2NpaVxuZnVuY3Rpb24ganNvb19pc19hc2NpaSAocykge1xuICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGdldHMgYmV0dGVyIGF0IGFyb3VuZCB0aGlzIHBvaW50IGZvciBhbGwgYnJvd3NlcnNcbiAgaWYgKHMubGVuZ3RoIDwgMjQpIHtcbiAgICAvLyBTcGlkZXJtb25rZXkgZ2V0cyBtdWNoIHNsb3dlciB3aGVuIHMubGVuZ3RoID49IDI0IChvbiA2NCBiaXQgYXJjaHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSBpZiAocy5jaGFyQ29kZUF0KGkpID4gMTI3KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhL1teXFx4MDAtXFx4N2ZdLy50ZXN0KHMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgbXV0YWJsZVxuZnVuY3Rpb24gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSB7XG4gIHN3aXRjaCAocy50ICYgNikge1xuICBkZWZhdWx0OiAvKiBQQVJUSUFMICovXG4gICAgaWYgKGkgPj0gcy5jLmxlbmd0aCkgcmV0dXJuIDA7XG4gIGNhc2UgMDogLyogQllURVMgKi9cbiAgICByZXR1cm4gcy5jLmNoYXJDb2RlQXQoaSk7XG4gIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICByZXR1cm4gcy5jW2ldXG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSwgYykge1xuICAvLyBUaGUgT0NhbWwgY29tcGlsZXIgdXNlcyBDaGFyLnVuc2FmZV9jaHIgb24gaW50ZWdlcnMgbGFyZ2VyIHRoYW4gMjU1IVxuICBjICY9IDB4ZmY7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykge1xuICAgIGlmIChpID09IHMuYy5sZW5ndGgpIHtcbiAgICAgIHMuYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgIGlmIChpICsgMSA9PSBzLmwpIHMudCA9IDA7IC8qQllURVMgfCBVTktPV04qL1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheSAocyk7XG4gIH1cbiAgcy5jW2ldID0gYztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yICgpIHtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9ieXRlc19ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yLCBjYW1sX3N0cmluZ191bnNhZmVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldCAocywgaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDE2KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSAxKSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDEpO1xuICByZXR1cm4gKGIyIDw8IDggfCBiMSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQxNihzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gMSkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAxKTtcbiAgcmV0dXJuIChiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19nZXQzMlxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9zdHJpbmdfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSAtIDMpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpLFxuICAgICAgYjIgPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkgKyAyKSxcbiAgICAgIGI0ID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldCAocywgaSArIDMpO1xuICByZXR1cm4gKGI0IDw8IDI0IHwgYjMgPDwgMTYgfCBiMiA8PCA4IHwgYjEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQsIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ2V0MzIocyxpKSB7XG4gIGlmIChpID4+PiAwID49IHMubCAtIDMpIGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IoKTtcbiAgdmFyIGIxID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpKSxcbiAgICAgIGIyID0gY2FtbF9ieXRlc191bnNhZmVfZ2V0IChzLCBpICsgMSksXG4gICAgICBiMyA9IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCAocywgaSArIDIpLFxuICAgICAgYjQgPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyAzKTtcbiAgcmV0dXJuIChiNCA8PCAyNCB8IGIzIDw8IDE2IHwgYjIgPDwgOCB8IGIxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQsIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dldDY0KHMsaSkge1xuICBpZiAoaSA+Pj4gMCA+PSBjYW1sX21sX3N0cmluZ19sZW5ndGgocykgLSA3KSBjYW1sX3N0cmluZ19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IChzLCBpICsgaik7XG4gIH1cbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfYnl0ZXMoYSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfdW5zYWZlX2dldCwgY2FtbF9ieXRlc19ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQ2NChzLGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IG5ldyBBcnJheSg4KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKyl7XG4gICAgYVs3IC0gal0gPSBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkgKyBqKTtcbiAgfVxuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9ieXRlcyhhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19nZXRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9ieXRlc19nZXQgKHMsIGkpIHtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQgKHMsIGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfc2V0IChzLCBpLCBjKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldCwgY2FtbF9zdHJpbmdfYm91bmRfZXJyb3Jcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldCAocywgaSwgYykge1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwpIGNhbWxfc3RyaW5nX2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQxNlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDE2KHMsaSxpMTYpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAxKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMiA9IDB4RkYgJiBpMTYgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkxNjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDE2XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N0cmluZ19zZXQxNlwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfc2V0MTZcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3NldDE2KHMsaSxpMTYpe1xuICByZXR1cm4gY2FtbF9ieXRlc19zZXQxNihzLGksaTE2KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19ib3VuZF9lcnJvciwgY2FtbF9ieXRlc191bnNhZmVfc2V0XG5mdW5jdGlvbiBjYW1sX2J5dGVzX3NldDMyKHMsaSxpMzIpe1xuICBpZiAoaSA+Pj4gMCA+PSBzLmwgLSAzKSBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiNCA9IDB4RkYgJiBpMzIgPj4gMjQsXG4gICAgICBiMyA9IDB4RkYgJiBpMzIgPj4gMTYsXG4gICAgICBiMiA9IDB4RkYgJiBpMzIgPj4gOCxcbiAgICAgIGIxID0gMHhGRiAmIGkzMjtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMCwgYjEpO1xuICBjYW1sX2J5dGVzX3Vuc2FmZV9zZXQgKHMsIGkgKyAxLCBiMik7XG4gIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDIsIGIzKTtcbiAgY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpICsgMywgYjQpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQzMlxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0MzJcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDMyXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQzMihzLGksaTMyKXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0MzIocyxpLGkzMik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfYm91bmRfZXJyb3IsIGNhbWxfYnl0ZXNfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19zZXQ2NChzLGksaTY0KXtcbiAgaWYgKGkgPj4+IDAgPj0gcy5sIC0gNykgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICB2YXIgYSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoaTY0KTtcbiAgZm9yKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgIGNhbWxfYnl0ZXNfdW5zYWZlX3NldCAocywgaSArIDcgLSBqLCBhW2pdKTtcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19zZXQ2NFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9zdHJpbmdfc2V0NjRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX3NldDY0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3NldDY0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19zZXQ2NChzLGksaTY0KXtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfc2V0NjQocyxpLGk2NCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2JvdW5kX2Vycm9yLCBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfc2V0IChzLCBpLCBjKSB7XG4gIGlmIChpID4+PiAwID49IHMubCkgY2FtbF9ieXRlc19ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gY2FtbF9ieXRlc191bnNhZmVfc2V0IChzLCBpLCBjKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nIChzKSB7XG4gIHZhciB0YWcgPSA5IC8qIEJZVEVTIHwgQVNDSUkgKi87XG4gIGlmICghanNvb19pc19hc2NpaShzKSlcbiAgICB0YWcgPSA4IC8qIEJZVEVTIHwgTk9UX0FTQ0lJICovLCBzID0gY2FtbF91dGY4X29mX3V0ZjE2KHMpO1xuICByZXR1cm4gbmV3IE1sQnl0ZXModGFnLCBzLCBzLmxlbmd0aCk7XG59XG5cblxuLy9Qcm92aWRlczogTWxCeXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcywganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBNbEJ5dGVzICh0YWcsIGNvbnRlbnRzLCBsZW5ndGgpIHtcbiAgdGhpcy50PXRhZzsgdGhpcy5jPWNvbnRlbnRzOyB0aGlzLmw9bGVuZ3RoO1xufVxuTWxCeXRlcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICBzd2l0Y2ggKHRoaXMudCkge1xuICBjYXNlIDk6IC8qQllURVMgfCBBU0NJSSovXG4gICAgcmV0dXJuIHRoaXMuYztcbiAgZGVmYXVsdDpcbiAgICBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHRoaXMpO1xuICBjYXNlIDA6IC8qQllURVMgfCBVTktPV04qL1xuICAgIGlmIChqc29vX2lzX2FzY2lpKHRoaXMuYykpIHtcbiAgICAgIHRoaXMudCA9IDk7IC8qQllURVMgfCBBU0NJSSovXG4gICAgICByZXR1cm4gdGhpcy5jO1xuICAgIH1cbiAgICB0aGlzLnQgPSA4OyAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgY2FzZSA4OiAvKkJZVEVTIHwgTk9UX0FTQ0lJKi9cbiAgICByZXR1cm4gdGhpcy5jO1xuICB9XG59O1xuTWxCeXRlcy5wcm90b3R5cGUudG9VdGYxNiA9IGZ1bmN0aW9uICgpe1xuICB2YXIgciA9IHRoaXMudG9TdHJpbmcoKTtcbiAgaWYodGhpcy50ID09IDkpIHJldHVybiByXG4gIHJldHVybiBjYW1sX3V0ZjE2X29mX3V0Zjgocik7XG59XG5NbEJ5dGVzLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICgpe1xuICB2YXIgY29udGVudCA9IHRoaXMudCA9PSA0ID8gdGhpcy5jLnNsaWNlKCkgOiB0aGlzLmM7XG4gIHJldHVybiBuZXcgTWxCeXRlcyh0aGlzLnQsY29udGVudCx0aGlzLmwpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfc3ViYXJyYXlfdG9fanNieXRlc1xuZnVuY3Rpb24gY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyAocykge1xuICAvKiBBc3N1bWVzIG5vdCBCWVRFUyAqL1xuICBpZiAocy50ID09IDIgLyogUEFSVElBTCAqLylcbiAgICBzLmMgKz0gY2FtbF9zdHJfcmVwZWF0KHMubCAtIHMuYy5sZW5ndGgsICdcXDAnKVxuICBlbHNlXG4gICAgcy5jID0gY2FtbF9zdWJhcnJheV90b19qc2J5dGVzIChzLmMsIDAsIHMuYy5sZW5ndGgpO1xuICBzLnQgPSAwOyAvKkJZVEVTIHwgVU5LT1dOKi9cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXkgKHMpIHtcbiAgLyogQXNzdW1lcyBub3QgQVJSQVkgKi9cbiAgaWYoam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkge1xuICAgIHZhciBhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkocy5sKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheShzLmwpO1xuICB9XG4gIHZhciBiID0gcy5jLCBsID0gYi5sZW5ndGgsIGkgPSAwO1xuICBmb3IgKDsgaSA8IGw7IGkrKykgYVtpXSA9IGIuY2hhckNvZGVBdChpKTtcbiAgZm9yIChsID0gcy5sOyBpIDwgbDsgaSsrKSBhW2ldID0gMDtcbiAgcy5jID0gYTtcbiAgcy50ID0gNDsgLyogQVJSQVkgKi9cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfb2ZfYnl0ZXMgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5XG5mdW5jdGlvbiBjYW1sX2FycmF5X29mX2J5dGVzIChzKSB7XG4gIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICByZXR1cm4gcy5jO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X29mX3N0cmluZyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9zdHJpbmdfdW5zYWZlX2dldFxuZnVuY3Rpb24gY2FtbF9hcnJheV9vZl9zdHJpbmcgKHMpIHtcbiAgdmFyIGwgPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciBhID0gbmV3IEFycmF5KGwpO1xuICB2YXIgaSA9IDA7XG4gIGZvciAoOyBpIDwgbDsgaSsrKSBhW2ldID0gY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLGkpO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX3N0cmluZyhsZW4pIHtcbiAgaWYobGVuIDwgMCkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiU3RyaW5nLmNyZWF0ZVwiKTtcbiAgcmV0dXJuIG5ldyBNbEJ5dGVzKGxlbj8yOjksXCJcIixsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NyZWF0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2NyZWF0ZV9zdHJpbmcobGVuKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0cmluZy5jcmVhdGVcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY3JlYXRlX2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzLGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9jcmVhdGVfYnl0ZXMobGVuKSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCeXRlcy5jcmVhdGVcIik7XG4gIHJldHVybiBuZXcgTWxCeXRlcyhsZW4/Mjo5LFwiXCIsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfc3ViYXJyYXlfdG9fanNieXRlcywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYXJyYXkgKGEpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKGEsMCxhLmxlbmd0aCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2FycmF5IChhKSB7XG4gIHJldHVybiBuZXcgTWxCeXRlcyg0LGEsYS5sZW5ndGgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2NvbXBhcmUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuZnVuY3Rpb24gY2FtbF9ieXRlc19jb21wYXJlKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPCBzMi5jKT8tMTooczEuYyA+IHMyLmMpPzE6MDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2VxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZXF1YWwoczEsIHMyKSB7XG4gIGlmKHMxID09PSBzMikgcmV0dXJuIDE7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA9PSBzMi5jKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19ub3RlcXVhbChzMSwgczIpIHsgcmV0dXJuIDEtY2FtbF9zdHJpbmdfZXF1YWwoczEsIHMyKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX25vdGVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG5mdW5jdGlvbiBjYW1sX2J5dGVzX25vdGVxdWFsKHMxLCBzMikgeyByZXR1cm4gMS1jYW1sX3N0cmluZ19lcXVhbChzMSwgczIpOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfbGVzc2VxdWFsIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLCBzMikge1xuICAoczEudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczEpO1xuICAoczIudCAmIDYpICYmIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMoczIpO1xuICByZXR1cm4gKHMxLmMgPD0gczIuYyk/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2xlc3N0aGFuIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczEsIHMyKSB7XG4gIChzMS50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMSk7XG4gIChzMi50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzMik7XG4gIHJldHVybiAoczEuYyA8IHMyLmMpPzE6MDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfZ3JlYXRlcmVxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMixzMSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2J5dGVzX2dyZWF0ZXJlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbmZ1bmN0aW9uIGNhbWxfYnl0ZXNfZ3JlYXRlcmVxdWFsKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9ieXRlc19sZXNzZXF1YWwoczIsczEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfbGVzc3RoYW5cbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2dyZWF0ZXJ0aGFuKHMxLCBzMikge1xuICByZXR1cm4gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19ncmVhdGVydGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuZnVuY3Rpb24gY2FtbF9ieXRlc19ncmVhdGVydGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc3RoYW4oczIsIHMxKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9maWxsX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cl9yZXBlYXQsIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheVxuZnVuY3Rpb24gY2FtbF9maWxsX2J5dGVzKHMsIGksIGwsIGMpIHtcbiAgaWYgKGwgPiAwKSB7XG4gICAgaWYgKGkgPT0gMCAmJiAobCA+PSBzLmwgfHwgKHMudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbCA+PSBzLmMubGVuZ3RoKSkpIHtcbiAgICAgIGlmIChjID09IDApIHtcbiAgICAgICAgcy5jID0gXCJcIjtcbiAgICAgICAgcy50ID0gMjsgLyogUEFSVElBTCAqL1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcy5jID0gY2FtbF9zdHJfcmVwZWF0IChsLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgcy50ID0gKGwgPT0gcy5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLnQgIT0gNCAvKiBBUlJBWSAqLykgY2FtbF9jb252ZXJ0X2J5dGVzX3RvX2FycmF5KHMpO1xuICAgICAgZm9yIChsICs9IGk7IGkgPCBsOyBpKyspIHMuY1tpXSA9IGM7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbGxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2ZpbGxfYnl0ZXNcbnZhciBjYW1sX2ZpbGxfc3RyaW5nID0gY2FtbF9maWxsX2J5dGVzXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdWJhcnJheV90b19qc2J5dGVzLCBjYW1sX2NvbnZlcnRfYnl0ZXNfdG9fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmxpdF9ieXRlcyhzMSwgaTEsIHMyLCBpMiwgbGVuKSB7XG4gIGlmIChsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIGlmICgoaTIgPT0gMCkgJiZcbiAgICAgIChsZW4gPj0gczIubCB8fCAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgbGVuID49IHMyLmMubGVuZ3RoKSkpIHtcbiAgICBzMi5jID0gKHMxLnQgPT0gNCAvKiBBUlJBWSAqLyk/XG4gICAgICBjYW1sX3N1YmFycmF5X3RvX2pzYnl0ZXMoczEuYywgaTEsIGxlbik6XG4gICAgICAoaTEgPT0gMCAmJiBzMS5jLmxlbmd0aCA9PSBsZW4pP3MxLmM6czEuYy5zdWJzdHIoaTEsIGxlbik7XG4gICAgczIudCA9IChzMi5jLmxlbmd0aCA9PSBzMi5sKT8wIC8qIEJZVEVTIHwgVU5LT1dOICovIDoyOyAvKiBQQVJUSUFMICovXG4gIH0gZWxzZSBpZiAoczIudCA9PSAyIC8qIFBBUlRJQUwgKi8gJiYgaTIgPT0gczIuYy5sZW5ndGgpIHtcbiAgICBzMi5jICs9IChzMS50ID09IDQgLyogQVJSQVkgKi8pP1xuICAgICAgY2FtbF9zdWJhcnJheV90b19qc2J5dGVzKHMxLmMsIGkxLCBsZW4pOlxuICAgICAgKGkxID09IDAgJiYgczEuYy5sZW5ndGggPT0gbGVuKT9zMS5jOnMxLmMuc3Vic3RyKGkxLCBsZW4pO1xuICAgIHMyLnQgPSAoczIuYy5sZW5ndGggPT0gczIubCk/MCAvKiBCWVRFUyB8IFVOS09XTiAqLyA6MjsgLyogUEFSVElBTCAqL1xuICB9IGVsc2Uge1xuICAgIGlmIChzMi50ICE9IDQgLyogQVJSQVkgKi8pIGNhbWxfY29udmVydF9ieXRlc190b19hcnJheShzMik7XG4gICAgdmFyIGMxID0gczEuYywgYzIgPSBzMi5jO1xuICAgIGlmIChzMS50ID09IDQgLyogQVJSQVkgKi8pIHtcbiAgICAgIGlmIChpMiA8PSBpMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSBjMiBbaTIgKyBpXSA9IGMxIFtpMSArIGldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbCA9IE1hdGgubWluIChsZW4sIGMxLmxlbmd0aCAtIGkxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSBjMiBbaTIgKyBpXSA9IGMxLmNoYXJDb2RlQXQoaTEgKyBpKTtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGMyIFtpMiArIGldID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmxpdF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmxpdF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfYmxpdF9zdHJpbmcoYSxiLGMsZCxlKSB7XG4gICAgY2FtbF9ibGl0X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGEpLGIsYyxkLGUpO1xuICAgIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoIGNvbnN0XG5mdW5jdGlvbiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKSB7IHJldHVybiBzLmwgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIHMuY2hhckNvZGVBdChpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfdW5zYWZlX3NldFxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ191bnNhZmVfc2V0IChzLCBpLCBjKSB7XG4gICAgY2FtbF9mYWlsd2l0aChcImNhbWxfc3RyaW5nX3Vuc2FmZV9zZXRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21sX3N0cmluZ19sZW5ndGgocykge1xuICByZXR1cm4gcy5sZW5ndGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfY29tcGFyZSBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19jb21wYXJlKHMxLCBzMikge1xuICByZXR1cm4gKHMxIDwgczIpPy0xOihzMSA+IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2VxdWFsKHMxLCBzMikge1xuICBpZihzMSA9PT0gczIpIHJldHVybiAxO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfbGVzc2VxdWFsIGNvbnN0XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8PSBzMik/MTowO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhbiBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19sZXNzdGhhbihzMSwgczIpIHtcbiAgcmV0dXJuIChzMSA8IHMyKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2J5dGVzKHMpIHtcbiAgICAocy50ICYgNikgJiYgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhzKTtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocy5jKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYnl0ZXNfb2ZfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMgY29uc3Rcbi8vSWY6IGpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh4KSB7IHJldHVybiB4IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZyBjb25zdFxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHgpIHsgcmV0dXJuIHggfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGYxNl9vZl91dGY4XG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpIHtcbiAgaWYoanNvb19pc19hc2NpaShzKSlcbiAgICByZXR1cm4gcztcbiAgcmV0dXJuIGNhbWxfdXRmMTZfb2ZfdXRmOChzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyBjb25zdFxuLy9SZXF1aXJlczoganNvb19pc19hc2NpaSwgY2FtbF91dGY4X29mX3V0ZjE2LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG4vL0lmOiBqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nIChzKSB7XG4gIGlmIChqc29vX2lzX2FzY2lpKHMpKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpXG4gIGVsc2UgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF91dGY4X29mX3V0ZjE2KHMpKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzIGNvbnN0XG4vL1JlcXVpcmVzOiBNbEJ5dGVzXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX2pzYnl0ZXMocykgeyByZXR1cm4gbmV3IE1sQnl0ZXMoMCxzLHMubGVuZ3RoKTsgfVxuXG5cbi8vIFRoZSBzZWN0aW9uIGJlbG93IHNob3VsZCBiZSB1c2VkIHdoZW4gdXNlLWpzLXN0cmluZz1mYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQgKHMsIGkpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX2dldChzLGkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ191bnNhZmVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX3Vuc2FmZV9zZXRcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX3Vuc2FmZV9zZXQgKHMsIGksIGMpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfdW5zYWZlX3NldChzLGksYyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aChzKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19jb21wYXJlXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2NvbXBhcmVcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2NvbXBhcmUoczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2NvbXBhcmUoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2VxdWFsXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2VxdWFsXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19lcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfZXF1YWwoczEsczIpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX2xlc3NlcXVhbFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzZXF1YWxcbi8vSWY6ICFqcy1zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3RyaW5nX2xlc3NlcXVhbChzMSwgczIpIHtcbiAgcmV0dXJuIGNhbWxfYnl0ZXNfbGVzc2VxdWFsKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19sZXNzdGhhblxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19sZXNzdGhhblxuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfbGVzc3RoYW4oczEsIHMyKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX2xlc3N0aGFuKHMxLHMyKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9JZjogIWpzLXN0cmluZ1xuZnVuY3Rpb24gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMocykgeyByZXR1cm4gcyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2J5dGVzX29mX3N0cmluZyhzKSB7IHJldHVybiBzIH1cblxuLy9Qcm92aWRlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcyBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIHsgcmV0dXJuIGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhzKTsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHMpIHtcbiAgaWYgKChzLnQgJiA2KSAhPSAwIC8qIEJZVEVTICovKSBjYW1sX2NvbnZlcnRfc3RyaW5nX3RvX2J5dGVzKHMpO1xuICByZXR1cm4gcy5jIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcgbXV0YWJsZSAoY29uc3QpXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKXtcbiAgcmV0dXJuIHMudG9VdGYxNigpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX3V0ZjE2X2pzc3RyaW5nXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAocykge1xuICByZXR1cm4gY2FtbF9ieXRlc19vZl91dGYxNl9qc3N0cmluZyhzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogTWxCeXRlc1xuZnVuY3Rpb24gY2FtbF9pc19tbF9ieXRlcyhzKSB7XG4gIHJldHVybiAocyBpbnN0YW5jZW9mIE1sQnl0ZXMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX21sX3N0cmluZ1xuLy9SZXF1aXJlczoganNvb19pc19hc2NpaVxuLy9JZjoganMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgIS9bXlxceDAwLVxceGZmXS8udGVzdChzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfbWxfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzXG4vL0lmOiAhanMtc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2lzX21sX3N0cmluZyhzKSB7XG4gIHJldHVybiBjYW1sX2lzX21sX2J5dGVzKHMpO1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBkZXByZWNhdGVkXG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYnl0ZV9zdHJpbmcocykgeyByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhzKSB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9uZXdfc3RyaW5nIChzKSB7IHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKHMpIH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX3N0cmluZyBtdXRhYmxlIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdG9fanNfc3RyaW5nIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfdG9fanNfc3RyaW5nKHMpIHtcbiAgcmV0dXJuIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fc3RyaW5nIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc190b19zdHJpbmcgKHMpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKHMpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9SYWlzZSBleGNlcHRpb25cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JhaXNlX2NvbnN0YW50ICh0YWcpIHsgdGhyb3cgdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmV0dXJuX2V4bl9jb25zdGFudCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQgKHRhZykgeyByZXR1cm4gdGFnOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfcmFpc2Vfd2l0aF9hcmcgKHRhZywgYXJnKSB7IHRocm93IFswLCB0YWcsIGFyZ107IH1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZyAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX2FyZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9yYWlzZV93aXRoX3N0cmluZyAodGFnLCBtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX2FyZyAodGFnLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKG1zZykpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZhaWx3aXRoIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9zdHJpbmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfZmFpbHdpdGggKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuRmFpbHVyZSwgbXNnKTtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9pbnZhbGlkX2FyZ3VtZW50IChtc2cpIHtcbiAgY2FtbF9yYWlzZV93aXRoX3N0cmluZyhjYW1sX2dsb2JhbF9kYXRhLkludmFsaWRfYXJndW1lbnQsIG1zZyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfY29uc3RhbnQsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuRW5kX29mX2ZpbGUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2NvbnN0YW50LCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlICgpIHtcbiAgY2FtbF9yYWlzZV9jb25zdGFudChjYW1sX2dsb2JhbF9kYXRhLkRpdmlzaW9uX2J5X3plcm8pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3JhaXNlX25vdF9mb3VuZFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9jb25zdGFudCwgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfZm91bmQgKCkge1xuICBjYW1sX3JhaXNlX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuTm90X2ZvdW5kKTsgfVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9hcnJheV9ib3VuZF9lcnJvciAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9jYWxsX2dlbiAoY29uc3QsIHNoYWxsb3cpXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfY2FsbF9nZW4oZiwgYXJncykge1xuICBpZihmLmZ1bilcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLmZ1biwgYXJncyk7XG4gIC8vRklYTUUsIGNhbiBoYXBwZW4gd2l0aCB0b28gbWFueSBhcmd1bWVudHNcbiAgaWYodHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGY7XG4gIHZhciBuID0gZi5sZW5ndGggfCAwO1xuICBpZihuID09PSAwKSByZXR1cm4gZi5hcHBseShudWxsLGFyZ3MpO1xuICB2YXIgYXJnc0xlbiA9IGFyZ3MubGVuZ3RoIHwgMDtcbiAgdmFyIGQgPSBuIC0gYXJnc0xlbiB8IDA7XG4gIGlmIChkID09IDApXG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gIGVsc2UgaWYgKGQgPCAwKSB7XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZi5hcHBseShudWxsLGFyZ3Muc2xpY2UoMCxuKSksYXJncy5zbGljZShuKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpe1xuICAgICAgdmFyIGV4dHJhX2FyZ3MgPSAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKT8xOmFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB2YXIgbmFyZ3MgPSBuZXcgQXJyYXkoYXJncy5sZW5ndGgrZXh0cmFfYXJncyk7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKyApIG5hcmdzW2ldID0gYXJnc1tpXTtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSBuYXJnc1thcmdzLmxlbmd0aCtpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIG5hcmdzKVxuICAgIH1cbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hbWVkX3ZhbHVlc1xudmFyIGNhbWxfbmFtZWRfdmFsdWVzID0ge307XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUgKGNvbnN0LGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWUobm0sdikge1xuICBjYW1sX25hbWVkX3ZhbHVlc1tjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5tKV0gPSB2O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uYW1lZF92YWx1ZVxuLy9SZXF1aXJlczogY2FtbF9uYW1lZF92YWx1ZXNcbmZ1bmN0aW9uIGNhbWxfbmFtZWRfdmFsdWUobm0pIHtcbiAgcmV0dXJuIGNhbWxfbmFtZWRfdmFsdWVzW25tXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dsb2JhbF9kYXRhXG52YXIgY2FtbF9nbG9iYWxfZGF0YSA9IFswXTtcblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9nbG9iYWwgKGNvbnN0LCBzaGFsbG93LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfcmVnaXN0ZXJfZ2xvYmFsIChuLCB2LCBuYW1lX29wdCkge1xuICBpZihuYW1lX29wdCAmJiBqb29fZ2xvYmFsX29iamVjdC50b3BsZXZlbFJlbG9jKVxuICAgIG4gPSBqb29fZ2xvYmFsX29iamVjdC50b3BsZXZlbFJlbG9jKG5hbWVfb3B0KTtcbiAgY2FtbF9nbG9iYWxfZGF0YVtuICsgMV0gPSB2O1xuICBpZihuYW1lX29wdCkgY2FtbF9nbG9iYWxfZGF0YVtuYW1lX29wdF0gPSB2O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9nbG9iYWxfZGF0YSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2dldF9nbG9iYWxfZGF0YSAoKSB7IHJldHVybiBjYW1sX2dsb2JhbF9kYXRhOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfaXNfcHJpbnRhYmxlIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfaXNfcHJpbnRhYmxlKGMpIHsgcmV0dXJuICsoYyA+IDMxICYmIGMgPCAxMjcpOyB9XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEZvcm1hdFxuXG4vL1Byb3ZpZGVzOiBjYW1sX3BhcnNlX2Zvcm1hdFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2Zvcm1hdCAoZm10KSB7XG4gIGZtdCA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KTtcbiAgdmFyIGxlbiA9IGZtdC5sZW5ndGg7XG4gIGlmIChsZW4gPiAzMSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZm9ybWF0X2ludDogZm9ybWF0IHRvbyBsb25nXCIpO1xuICB2YXIgZiA9XG4gICAgICB7IGp1c3RpZnk6JysnLCBzaWduc3R5bGU6Jy0nLCBmaWxsZXI6JyAnLCBhbHRlcm5hdGU6ZmFsc2UsXG4gICAgICAgIGJhc2U6MCwgc2lnbmVkY29udjpmYWxzZSwgd2lkdGg6MCwgdXBwZXJjYXNlOmZhbHNlLFxuICAgICAgICBzaWduOjEsIHByZWM6LTEsIGNvbnY6J2YnIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgYyA9IGZtdC5jaGFyQXQoaSk7XG4gICAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnLSc6XG4gICAgICBmLmp1c3RpZnkgPSAnLSc7IGJyZWFrO1xuICAgIGNhc2UgJysnOiBjYXNlICcgJzpcbiAgICAgIGYuc2lnbnN0eWxlID0gYzsgYnJlYWs7XG4gICAgY2FzZSAnMCc6XG4gICAgICBmLmZpbGxlciA9ICcwJzsgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBmLmFsdGVybmF0ZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOiBjYXNlICc1JzpcbiAgICBjYXNlICc2JzogY2FzZSAnNyc6IGNhc2UgJzgnOiBjYXNlICc5JzpcbiAgICAgIGYud2lkdGggPSAwO1xuICAgICAgd2hpbGUgKGM9Zm10LmNoYXJDb2RlQXQoaSkgLSA0OCwgYyA+PSAwICYmIGMgPD0gOSkge1xuICAgICAgICBmLndpZHRoID0gZi53aWR0aCAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBicmVhaztcbiAgICBjYXNlICcuJzpcbiAgICAgIGYucHJlYyA9IDA7XG4gICAgICBpKys7XG4gICAgICB3aGlsZSAoYz1mbXQuY2hhckNvZGVBdChpKSAtIDQ4LCBjID49IDAgJiYgYyA8PSA5KSB7XG4gICAgICAgIGYucHJlYyA9IGYucHJlYyAqIDEwICsgYzsgaSsrXG4gICAgICB9XG4gICAgICBpLS07XG4gICAgY2FzZSAnZCc6IGNhc2UgJ2knOlxuICAgICAgZi5zaWduZWRjb252ID0gdHJ1ZTsgLyogZmFsbHRocm91Z2ggKi9cbiAgICBjYXNlICd1JzpcbiAgICAgIGYuYmFzZSA9IDEwOyBicmVhaztcbiAgICBjYXNlICd4JzpcbiAgICAgIGYuYmFzZSA9IDE2OyBicmVhaztcbiAgICBjYXNlICdYJzpcbiAgICAgIGYuYmFzZSA9IDE2OyBmLnVwcGVyY2FzZSA9IHRydWU7IGJyZWFrO1xuICAgIGNhc2UgJ28nOlxuICAgICAgZi5iYXNlID0gODsgYnJlYWs7XG4gICAgY2FzZSAnZSc6IGNhc2UgJ2YnOiBjYXNlICdnJzpcbiAgICAgIGYuc2lnbmVkY29udiA9IHRydWU7IGYuY29udiA9IGM7IGJyZWFrO1xuICAgIGNhc2UgJ0UnOiBjYXNlICdGJzogY2FzZSAnRyc6XG4gICAgICBmLnNpZ25lZGNvbnYgPSB0cnVlOyBmLnVwcGVyY2FzZSA9IHRydWU7XG4gICAgICBmLmNvbnYgPSBjLnRvTG93ZXJDYXNlICgpOyBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZmluaXNoX2Zvcm1hdHRpbmdcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcmF3YnVmZmVyKSB7XG4gIGlmIChmLnVwcGVyY2FzZSkgcmF3YnVmZmVyID0gcmF3YnVmZmVyLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBsZW4gPSByYXdidWZmZXIubGVuZ3RoO1xuICAvKiBBZGp1c3QgbGVuIHRvIHJlZmxlY3QgYWRkaXRpb25hbCBjaGFycyAoc2lnbiwgZXRjKSAqL1xuICBpZiAoZi5zaWduZWRjb252ICYmIChmLnNpZ24gPCAwIHx8IGYuc2lnbnN0eWxlICE9ICctJykpIGxlbisrO1xuICBpZiAoZi5hbHRlcm5hdGUpIHtcbiAgICBpZiAoZi5iYXNlID09IDgpIGxlbiArPSAxO1xuICAgIGlmIChmLmJhc2UgPT0gMTYpIGxlbiArPSAyO1xuICB9XG4gIC8qIERvIHRoZSBmb3JtYXR0aW5nICovXG4gIHZhciBidWZmZXIgPSBcIlwiO1xuICBpZiAoZi5qdXN0aWZ5ID09ICcrJyAmJiBmLmZpbGxlciA9PSAnICcpXG4gICAgZm9yICh2YXIgaSA9IGxlbjsgaSA8IGYud2lkdGg7IGkrKykgYnVmZmVyICs9ICcgJztcbiAgaWYgKGYuc2lnbmVkY29udikge1xuICAgIGlmIChmLnNpZ24gPCAwKSBidWZmZXIgKz0gJy0nO1xuICAgIGVsc2UgaWYgKGYuc2lnbnN0eWxlICE9ICctJykgYnVmZmVyICs9IGYuc2lnbnN0eWxlO1xuICB9XG4gIGlmIChmLmFsdGVybmF0ZSAmJiBmLmJhc2UgPT0gOCkgYnVmZmVyICs9ICcwJztcbiAgaWYgKGYuYWx0ZXJuYXRlICYmIGYuYmFzZSA9PSAxNikgYnVmZmVyICs9IFwiMHhcIjtcbiAgaWYgKGYuanVzdGlmeSA9PSAnKycgJiYgZi5maWxsZXIgPT0gJzAnKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnMCc7XG4gIGJ1ZmZlciArPSByYXdidWZmZXI7XG4gIGlmIChmLmp1c3RpZnkgPT0gJy0nKVxuICAgIGZvciAodmFyIGkgPSBsZW47IGkgPCBmLndpZHRoOyBpKyspIGJ1ZmZlciArPSAnICc7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGJ1ZmZlcik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczoganNvb19mbG9vcl9sb2cyXG52YXIgbG9nMl9vayA9IE1hdGgubG9nMiAmJiBNYXRoLmxvZzIoMS4xMjM1NTgyMDkyODg5NDc0RSszMDcpID09IDEwMjBcbmZ1bmN0aW9uIGpzb29fZmxvb3JfbG9nMih4KSB7XG4gIGlmKGxvZzJfb2spIHJldHVybiBNYXRoLmZsb29yKE1hdGgubG9nMih4KSlcbiAgdmFyIGkgPSAwO1xuICBpZiAoeCA9PSAwKSByZXR1cm4gLUluZmluaXR5O1xuICBpZih4Pj0xKSB7d2hpbGUgKHg+PTIpIHt4Lz0yOyBpKyt9IH1cbiAgZWxzZSB7d2hpbGUgKHggPCAxKSB7eCo9MjsgaS0tfSB9O1xuICByZXR1cm4gaTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBqc29vX2Zsb29yX2xvZzIsIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpXG5mdW5jdGlvbiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHgpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSlcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgxLCAwLCAweDdmZjApO1xuICAgIGlmICh4ID4gMClcbiAgICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19taV9oaSgwLCAwLCAweDdmZjApXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKDAsIDAsIDB4ZmZmMClcbiAgfVxuICB2YXIgc2lnbiA9ICh4PT0wICYmIDEveCA9PSAtSW5maW5pdHkpPzB4ODAwMDooeD49MCk/MDoweDgwMDA7XG4gIGlmIChzaWduKSB4ID0gLXg7XG4gIC8vIEludDY0LmJpdHNfb2ZfZmxvYXQgMS4xMjM1NTgyMDkyODg5NDc0RSszMDcgPSAweDdmYjAwMDAwMDAwMDAwMDBMXG4gIC8vIHVzaW5nIE1hdGguTE9HMkUqTWF0aC5sb2coeCkgaW4gcGxhY2Ugb2YgTWF0aC5sb2cyIHJlc3VsdCBpbiBwcmVjaXNpb24gbG9zdFxuICB2YXIgZXhwID0ganNvb19mbG9vcl9sb2cyKHgpICsgMTAyMztcbiAgaWYgKGV4cCA8PSAwKSB7XG4gICAgZXhwID0gMDtcbiAgICB4IC89IE1hdGgucG93KDIsLTEwMjYpO1xuICB9IGVsc2Uge1xuICAgIHggLz0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gICAgaWYgKHggPCAxNikge1xuICAgICAgeCAqPSAyOyBleHAgLT0xOyB9XG4gICAgaWYgKGV4cCA9PSAwKSB7XG4gICAgICB4IC89IDI7IH1cbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsMjQpO1xuICB2YXIgcjMgPSB4fDA7XG4gIHggPSAoeCAtIHIzKSAqIGs7XG4gIHZhciByMiA9IHh8MDtcbiAgeCA9ICh4IC0gcjIpICogaztcbiAgdmFyIHIxID0geHwwO1xuICByMyA9IChyMyAmMHhmKSB8IHNpZ24gfCBleHAgPDwgNDtcbiAgcmV0dXJuIGNhbWxfaW50NjRfY3JlYXRlX2xvX21pX2hpKHIxLCByMiwgcjMpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGpzb29fZmxvb3JfbG9nMlxuZnVuY3Rpb24gY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0ICh4KSB7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoMSk7XG4gIGZsb2F0MzJhWzBdID0geDtcbiAgdmFyIGludDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5JbnQzMkFycmF5KGZsb2F0MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBpbnQzMmFbMF0gfCAwO1xufVxuXG4vL0ZQIGxpdGVyYWxzIGNhbiBiZSB3cml0dGVuIHVzaW5nIHRoZSBoZXhhZGVjaW1hbFxuLy9ub3RhdGlvbiAweDxtYW50aXNzYSBpbiBoZXg+cDxleHBvbmVudD4gZnJvbSBJU08gQzk5LlxuLy9odHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtaGV4ZmxvYXQvYmxvYi9tYXN0ZXIvaGV4ZmxvYXQuanNcbi8vUHJvdmlkZXM6IGNhbWxfaGV4c3RyaW5nX29mX2Zsb2F0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZywgY2FtbF9zdHJfcmVwZWF0XG5mdW5jdGlvbiBjYW1sX2hleHN0cmluZ19vZl9mbG9hdCAoeCwgcHJlYywgc3R5bGUpIHtcbiAgaWYgKCFpc0Zpbml0ZSh4KSkge1xuICAgIGlmIChpc05hTih4KSkgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKFwibmFuXCIpO1xuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoKHggPiAwKT9cImluZmluaXR5XCI6XCItaW5maW5pdHlcIik7XG4gIH1cbiAgdmFyIHNpZ24gPSAoeD09MCAmJiAxL3ggPT0gLUluZmluaXR5KT8xOih4Pj0wKT8wOjE7XG4gIGlmKHNpZ24pIHggPSAteDtcbiAgdmFyIGV4cCA9IDA7XG4gIGlmICh4ID09IDApIHsgfVxuICBlbHNlIGlmICh4IDwgMSkge1xuICAgIHdoaWxlICh4IDwgMSAmJiBleHAgPiAtMTAyMikgIHsgeCAqPSAyOyBleHAtLSB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHggPj0gMikgeyB4IC89IDI7IGV4cCsrIH1cbiAgfVxuICB2YXIgZXhwX3NpZ24gPSBleHAgPCAwID8gJycgOiAnKyc7XG4gIHZhciBzaWduX3N0ciA9ICcnO1xuICBpZiAoc2lnbikgc2lnbl9zdHIgPSAnLSdcbiAgZWxzZSB7XG4gICAgc3dpdGNoKHN0eWxlKXtcbiAgICBjYXNlIDQzIC8qICcrJyAqLzogc2lnbl9zdHIgPSAnKyc7IGJyZWFrO1xuICAgIGNhc2UgMzIgLyogJyAnICovOiBzaWduX3N0ciA9ICcgJzsgYnJlYWs7XG4gICAgZGVmYXVsdDogYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChwcmVjID49IDAgJiYgcHJlYyA8IDEzKSB7XG4gICAgLyogSWYgYSBwcmVjaXNpb24gaXMgZ2l2ZW4sIGFuZCBpcyBzbWFsbCwgcm91bmQgbWFudGlzc2EgYWNjb3JkaW5nbHkgKi9cbiAgICB2YXIgY3N0ID0gTWF0aC5wb3coMixwcmVjICogNCk7XG4gICAgeCA9IE1hdGgucm91bmQoeCAqIGNzdCkgLyBjc3Q7XG4gIH1cbiAgdmFyIHhfc3RyID0geC50b1N0cmluZygxNik7XG4gIGlmKHByZWMgPj0gMCl7XG4gICAgdmFyIGlkeCA9IHhfc3RyLmluZGV4T2YoJy4nKTtcbiAgICBpZihpZHg8MCkge1xuICAgICAgeF9zdHIgKz0gJy4nICsgY2FtbF9zdHJfcmVwZWF0KHByZWMsICcwJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHNpemUgPSBpZHgrMStwcmVjO1xuICAgICAgaWYoeF9zdHIubGVuZ3RoIDwgc2l6ZSlcbiAgICAgICAgeF9zdHIgKz0gY2FtbF9zdHJfcmVwZWF0KHNpemUgLSB4X3N0ci5sZW5ndGgsICcwJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHhfc3RyID0geF9zdHIuc3Vic3RyKDAsc2l6ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyAoc2lnbl9zdHIgKyAnMHgnICsgeF9zdHIgKyAncCcgKyBleHBfc2lnbiArIGV4cC50b1N0cmluZygxMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgbG8gPSB4LmxvO1xuICB2YXIgbWkgPSB4Lm1pO1xuICB2YXIgaGkgPSB4LmhpO1xuICB2YXIgZXhwID0gKGhpICYgMHg3ZmZmKSA+PiA0O1xuICBpZiAoZXhwID09IDIwNDcpIHtcbiAgICBpZiAoKGxvfG1pfChoaSYweGYpKSA9PSAwKVxuICAgICAgcmV0dXJuIChoaSAmIDB4ODAwMCk/KC1JbmZpbml0eSk6SW5maW5pdHk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIE5hTjtcbiAgfVxuICB2YXIgayA9IE1hdGgucG93KDIsLTI0KTtcbiAgdmFyIHJlcyA9IChsbyprK21pKSprKyhoaSYweGYpO1xuICBpZiAoZXhwID4gMCkge1xuICAgIHJlcyArPSAxNjtcbiAgICByZXMgKj0gTWF0aC5wb3coMixleHAtMTAyNyk7XG4gIH0gZWxzZVxuICAgIHJlcyAqPSBNYXRoLnBvdygyLC0xMDI2KTtcbiAgaWYgKGhpICYgMHg4MDAwKSByZXMgPSAtIHJlcztcbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2ludDY0X2FkZCwgY2FtbF9pbnQ2NF9zdWIsY2FtbF9pbnQ2NF9vZl9pbnQzMlxuZnVuY3Rpb24gY2FtbF9uZXh0YWZ0ZXJfZmxvYXQgKHgseSkge1xuICBpZihpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuIE5hTjtcbiAgaWYoeD09eSkgcmV0dXJuIHk7XG4gIGlmKHg9PTApe1xuICAgIGlmKHkgPCAwKVxuICAgICAgcmV0dXJuIC1NYXRoLnBvdygyLCAtMTA3NClcbiAgICBlbHNlXG4gICAgICByZXR1cm4gTWF0aC5wb3coMiwgLTEwNzQpXG4gIH1cbiAgdmFyIGJpdHMgPSBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQoeCk7XG4gIHZhciBvbmUgPSBjYW1sX2ludDY0X29mX2ludDMyKDEpO1xuICBpZiAoKHg8eSkgPT0gKHg+MCkpXG4gICAgYml0cyA9IGNhbWxfaW50NjRfYWRkKGJpdHMsIG9uZSlcbiAgZWxzZVxuICAgIGJpdHMgPSBjYW1sX2ludDY0X3N1YihiaXRzLCBvbmUpXG4gIHJldHVybiBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoYml0cyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfdHJ1bmNfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfdHJ1bmNfZmxvYXQoeCl7XG4gIHJldHVybiBNYXRoLnRydW5jKHgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW50MzJfZmxvYXRfb2ZfYml0cyAoeCkge1xuICB2YXIgaW50MzJhID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkludDMyQXJyYXkoMSk7XG4gIGludDMyYVswXSA9IHg7XG4gIHZhciBmbG9hdDMyYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5GbG9hdDMyQXJyYXkoaW50MzJhLmJ1ZmZlcik7XG4gIHJldHVybiBmbG9hdDMyYVswXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jbGFzc2lmeV9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jbGFzc2lmeV9mbG9hdCAoeCkge1xuICBpZiAoaXNGaW5pdGUgKHgpKSB7XG4gICAgaWYgKE1hdGguYWJzKHgpID49IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSByZXR1cm4gMDtcbiAgICBpZiAoeCAhPSAwKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuICByZXR1cm4gaXNOYU4oeCk/NDozO1xufVxuLy9Qcm92aWRlczogY2FtbF9tb2RmX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX21vZGZfZmxvYXQgKHgpIHtcbiAgaWYgKGlzRmluaXRlICh4KSkge1xuICAgIHZhciBuZWcgPSAoMS94KSA8IDA7XG4gICAgeCA9IE1hdGguYWJzKHgpO1xuICAgIHZhciBpID0gTWF0aC5mbG9vciAoeCk7XG4gICAgdmFyIGYgPSB4IC0gaTtcbiAgICBpZiAobmVnKSB7IGkgPSAtaTsgZiA9IC1mOyB9XG4gICAgcmV0dXJuIFswLCBmLCBpXTtcbiAgfVxuICBpZiAoaXNOYU4gKHgpKSByZXR1cm4gWzAsIE5hTiwgTmFOXTtcbiAgcmV0dXJuIFswLCAxL3gsIHhdO1xufVxuLy9Qcm92aWRlczogY2FtbF9sZGV4cF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9sZGV4cF9mbG9hdCAoeCxleHApIHtcbiAgZXhwIHw9IDA7XG4gIGlmIChleHAgPiAxMDIzKSB7XG4gICAgZXhwIC09IDEwMjM7XG4gICAgeCAqPSBNYXRoLnBvdygyLCAxMDIzKTtcbiAgICBpZiAoZXhwID4gMTAyMykgeyAgLy8gaW4gY2FzZSB4IGlzIHN1Ym5vcm1hbFxuICAgICAgZXhwIC09IDEwMjM7XG4gICAgICB4ICo9IE1hdGgucG93KDIsIDEwMjMpO1xuICAgIH1cbiAgfVxuICBpZiAoZXhwIDwgLTEwMjMpIHtcbiAgICBleHAgKz0gMTAyMztcbiAgICB4ICo9IE1hdGgucG93KDIsIC0xMDIzKTtcbiAgfVxuICB4ICo9IE1hdGgucG93KDIsIGV4cCk7XG4gIHJldHVybiB4O1xufVxuLy9Qcm92aWRlczogY2FtbF9mcmV4cF9mbG9hdCBjb25zdFxuLy9SZXF1aXJlczoganNvb19mbG9vcl9sb2cyXG5mdW5jdGlvbiBjYW1sX2ZyZXhwX2Zsb2F0ICh4KSB7XG4gIGlmICgoeCA9PSAwKSB8fCAhaXNGaW5pdGUoeCkpIHJldHVybiBbMCwgeCwgMF07XG4gIHZhciBuZWcgPSB4IDwgMDtcbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgdmFyIGV4cCA9IE1hdGgubWF4KC0xMDIzLCBqc29vX2Zsb29yX2xvZzIoeCkgKyAxKTtcbiAgeCAqPSBNYXRoLnBvdygyLC1leHApO1xuICB3aGlsZSAoeCA8IDAuNSkge1xuICAgIHggKj0gMjtcbiAgICBleHAtLTtcbiAgfVxuICB3aGlsZSAoeCA+PSAxKSB7XG4gICAgeCAqPSAwLjU7XG4gICAgZXhwKys7XG4gIH1cbiAgaWYgKG5lZykgeCA9IC0geDtcbiAgcmV0dXJuIFswLCB4LCBleHBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zsb2F0X2NvbXBhcmUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmxvYXRfY29tcGFyZSAoeCwgeSkge1xuICBpZiAoeCA9PT0geSkgcmV0dXJuIDA7XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xO1xuICBpZiAoeCA+IHkpIHJldHVybiAxO1xuICBpZiAoeCA9PT0geCkgcmV0dXJuIDE7XG4gIGlmICh5ID09PSB5KSByZXR1cm4gLTE7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvcHlzaWduX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvcHlzaWduX2Zsb2F0ICh4LCB5KSB7XG4gIGlmICh5ID09IDApIHkgPSAxIC8geTtcbiAgeCA9IE1hdGguYWJzKHgpO1xuICByZXR1cm4gKHkgPCAwKT8oLXgpOng7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2lnbmJpdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zaWduYml0X2Zsb2F0KHgpIHtcbiAgaWYgKHggPT0gMCkgeCA9IDEgLyB4O1xuICByZXR1cm4gKHggPCAwKT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhwbTFfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZXhwbTFfZmxvYXQgKHgpIHtcbiAgdmFyIHkgPSBNYXRoLmV4cCh4KSwgeiA9IHkgLSAxO1xuICByZXR1cm4gKE1hdGguYWJzKHgpPjE/ejooej09MD94Ongqei9NYXRoLmxvZyh5KSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xvZzFwX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2xvZzFwX2Zsb2F0ICh4KSB7XG4gIHZhciB5ID0gMSArIHgsIHogPSB5IC0gMTtcbiAgcmV0dXJuICh6PT0wP3g6eCpNYXRoLmxvZyh5KS96KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oeXBvdF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9oeXBvdF9mbG9hdCAoeCwgeSkge1xuICB2YXIgeCA9IE1hdGguYWJzKHgpLCB5ID0gTWF0aC5hYnMoeSk7XG4gIHZhciBhID0gTWF0aC5tYXgoeCwgeSksIGIgPSBNYXRoLm1pbih4LHkpIC8gKGE/YToxKTtcbiAgcmV0dXJuIChhICogTWF0aC5zcXJ0KDEgKyBiKmIpKTtcbn1cblxuLy8gRklYOiB0aGVzZSBmaXZlIGZ1bmN0aW9ucyBvbmx5IGdpdmUgYXBwcm94aW1hdGUgcmVzdWx0cy5cbi8vUHJvdmlkZXM6IGNhbWxfbG9nMTBfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfbG9nMTBfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGguTE9HMTBFICogTWF0aC5sb2coeCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29zaF9mbG9hdCBjb25zdFxuZnVuY3Rpb24gY2FtbF9jb3NoX2Zsb2F0ICh4KSB7IHJldHVybiAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpIC8gMjsgfVxuLy9Qcm92aWRlczogY2FtbF9zaW5oX2Zsb2F0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX3NpbmhfZmxvYXQgKHgpIHsgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3RhbmhfZmxvYXQgY29uc3RcbmZ1bmN0aW9uIGNhbWxfdGFuaF9mbG9hdCAoeCkge1xuICB2YXIgeSA9IE1hdGguZXhwKHgpLCB6ID0gTWF0aC5leHAoLXgpO1xuICByZXR1cm4gKHkgLSB6KSAvICh5ICsgeik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcm91bmRfZmxvYXRcbmZ1bmN0aW9uIGNhbWxfcm91bmRfZmxvYXQgKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9mb3JtYXRfZmxvYXQgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nXG5mdW5jdGlvbiBjYW1sX2Zvcm1hdF9mbG9hdCAoZm10LCB4KSB7XG4gIGZ1bmN0aW9uIHRvRml4ZWQoeCxkcCkge1xuICAgIGlmIChNYXRoLmFicyh4KSA8IDEuMCkge1xuICAgICAgcmV0dXJuIHgudG9GaXhlZChkcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlID0gcGFyc2VJbnQoeC50b1N0cmluZygpLnNwbGl0KCcrJylbMV0pO1xuICAgICAgaWYgKGUgPiAyMCkge1xuICAgICAgICBlIC09IDIwO1xuICAgICAgICB4IC89IE1hdGgucG93KDEwLGUpO1xuICAgICAgICB4ICs9IChuZXcgQXJyYXkoZSsxKSkuam9pbignMCcpO1xuICAgICAgICBpZihkcCA+IDApIHtcbiAgICAgICAgICB4ID0geCArICcuJyArIChuZXcgQXJyYXkoZHArMSkpLmpvaW4oJzAnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICAgIGVsc2UgcmV0dXJuIHgudG9GaXhlZChkcClcbiAgICB9XG4gIH1cbiAgdmFyIHMsIGYgPSBjYW1sX3BhcnNlX2Zvcm1hdChmbXQpO1xuICB2YXIgcHJlYyA9IChmLnByZWMgPCAwKT82OmYucHJlYztcbiAgaWYgKHggPCAwIHx8ICh4ID09IDAgJiYgMS94ID09IC1JbmZpbml0eSkpIHsgZi5zaWduID0gLTE7IHggPSAteDsgfVxuICBpZiAoaXNOYU4oeCkpIHsgcyA9IFwibmFuXCI7IGYuZmlsbGVyID0gJyAnOyB9XG4gIGVsc2UgaWYgKCFpc0Zpbml0ZSh4KSkgeyBzID0gXCJpbmZcIjsgZi5maWxsZXIgPSAnICc7IH1cbiAgZWxzZVxuICAgIHN3aXRjaCAoZi5jb252KSB7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgcyA9IHgudG9FeHBvbmVudGlhbChwcmVjKTtcbiAgICAgIC8vIGV4cG9uZW50IHNob3VsZCBiZSBhdCBsZWFzdCB0d28gZGlnaXRzXG4gICAgICB2YXIgaSA9IHMubGVuZ3RoO1xuICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgIHMgPSBzLnNsaWNlICgwLCBpIC0gMSkgKyAnMCcgKyBzLnNsaWNlIChpIC0gMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmJzpcbiAgICAgIHMgPSB0b0ZpeGVkKHgsIHByZWMpOyBicmVhaztcbiAgICBjYXNlICdnJzpcbiAgICAgIHByZWMgPSBwcmVjP3ByZWM6MTtcbiAgICAgIHMgPSB4LnRvRXhwb25lbnRpYWwocHJlYyAtIDEpO1xuICAgICAgdmFyIGogPSBzLmluZGV4T2YoJ2UnKTtcbiAgICAgIHZhciBleHAgPSArcy5zbGljZShqICsgMSk7XG4gICAgICBpZiAoZXhwIDwgLTQgfHwgeCA+PSAxZTIxIHx8IHgudG9GaXhlZCgwKS5sZW5ndGggPiBwcmVjKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB6ZXJvZXNcbiAgICAgICAgdmFyIGkgPSBqIC0gMTsgd2hpbGUgKHMuY2hhckF0KGkpID09ICcwJykgaS0tO1xuICAgICAgICBpZiAocy5jaGFyQXQoaSkgPT0gJy4nKSBpLS07XG4gICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKSArIHMuc2xpY2Uoaik7XG4gICAgICAgIGkgPSBzLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuY2hhckF0KGkgLSAzKSA9PSAnZScpXG4gICAgICAgICAgcyA9IHMuc2xpY2UgKDAsIGkgLSAxKSArICcwJyArIHMuc2xpY2UgKGkgLSAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcCA9IHByZWM7XG4gICAgICAgIGlmIChleHAgPCAwKSB7IHAgLT0gZXhwICsgMTsgcyA9IHgudG9GaXhlZChwKTsgfVxuICAgICAgICBlbHNlIHdoaWxlIChzID0geC50b0ZpeGVkKHApLCBzLmxlbmd0aCA+IHByZWMgKyAxKSBwLS07XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHplcm9lc1xuICAgICAgICAgIHZhciBpID0gcy5sZW5ndGggLSAxOyB3aGlsZSAocy5jaGFyQXQoaSkgPT0gJzAnKSBpLS07XG4gICAgICAgICAgaWYgKHMuY2hhckF0KGkpID09ICcuJykgaS0tO1xuICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gY2FtbF9maW5pc2hfZm9ybWF0dGluZyhmLCBzKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdF9vZl9zdHJpbmcgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9zdHJpbmcocykge1xuICB2YXIgcmVzO1xuICBzID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhzKVxuICByZXMgPSArcztcbiAgaWYgKChzLmxlbmd0aCA+IDApICYmIChyZXMgPT09IHJlcykpIHJldHVybiByZXM7XG4gIHMgPSBzLnJlcGxhY2UoL18vZyxcIlwiKTtcbiAgcmVzID0gK3M7XG4gIGlmICgoKHMubGVuZ3RoID4gMCkgJiYgKHJlcyA9PT0gcmVzKSkgfHwgL15bKy1dP25hbiQvaS50ZXN0KHMpKSByZXR1cm4gcmVzO1xuICB2YXIgbSA9IC9eICooWystXT8pMHgoWzAtOWEtZl0rKVxcLj8oWzAtOWEtZl0qKXAoWystXT9bMC05XSspL2kuZXhlYyhzKTtcbiAgLy8gICAgICAgICAgMSAgICAgICAgMiAgICAgICAgICAgICAzICAgICAgICAgICA0XG4gIGlmKG0pe1xuICAgIHZhciBtMyA9IG1bM10ucmVwbGFjZSgvMCskLywnJyk7XG4gICAgdmFyIG1hbnRpc3NhID0gcGFyc2VJbnQobVsxXSArIG1bMl0gKyBtMywgMTYpO1xuICAgIHZhciBleHBvbmVudCA9IChtWzRdfDApIC0gNCptMy5sZW5ndGg7XG4gICAgcmVzID0gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZigvXlxcKz9pbmYoaW5pdHkpPyQvaS50ZXN0KHMpKSByZXR1cm4gSW5maW5pdHk7XG4gIGlmKC9eLWluZihpbml0eSk/JC9pLnRlc3QocykpIHJldHVybiAtSW5maW5pdHk7XG4gIGNhbWxfZmFpbHdpdGgoXCJmbG9hdF9vZl9zdHJpbmdcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIER1bW15IGZpbGVzeXN0ZW1cblxuLy9Qcm92aWRlczogY2FtbF9jdXJyZW50X2RpclxuaWYoam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAmJiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZClcbiAgdmFyIGNhbWxfY3VycmVudF9kaXIgPSBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLmN3ZCgpLnJlcGxhY2UoL1xcXFwvZywnLycpO1xuZWxzZVxuICB2YXIgY2FtbF9jdXJyZW50X2RpciA9ICBcIi9zdGF0aWNcIjtcbmlmKGNhbWxfY3VycmVudF9kaXIuc2xpY2UoLTEpICE9PSBcIi9cIikgY2FtbF9jdXJyZW50X2RpciArPSBcIi9cIlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3Jvb3Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbnZhciBjYW1sX3Jvb3QgPSBjYW1sX2N1cnJlbnRfZGlyLm1hdGNoKC9bXlxcL10qXFwvLylbMF07XG5cblxuLy9Qcm92aWRlczogTWxGaWxlXG5mdW5jdGlvbiBNbEZpbGUoKXsgIH1cblxuLy9Qcm92aWRlczogY2FtbF9tYWtlX3BhdGhcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX21ha2VfcGF0aCAobmFtZSkge1xuICBuYW1lPWNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICBpZihuYW1lLmNoYXJDb2RlQXQoMCkgIT0gNDcpXG4gICAgbmFtZSA9IGNhbWxfY3VycmVudF9kaXIgKyBuYW1lO1xuICB2YXIgY29tcCA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICB2YXIgbmNvbXAgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpPGNvbXAubGVuZ3RoOyBpKyspe1xuICAgIHN3aXRjaChjb21wW2ldKXtcbiAgICBjYXNlIFwiLi5cIjogaWYobmNvbXAubGVuZ3RoPjEpIG5jb21wLnBvcCgpOyBicmVhaztcbiAgICBjYXNlIFwiLlwiOiBicmVhaztcbiAgICBjYXNlIFwiXCI6IGlmKG5jb21wLmxlbmd0aCA9PSAwKSBuY29tcC5wdXNoKFwiXCIpOyBicmVhaztcbiAgICBkZWZhdWx0OiBuY29tcC5wdXNoKGNvbXBbaV0pO2JyZWFrXG4gICAgfVxuICB9XG4gIG5jb21wLm9yaWcgPSBuYW1lO1xuICByZXR1cm4gbmNvbXA7XG59XG5cbi8vUHJvdmlkZXM6anNvb19tb3VudF9wb2ludFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBNbE5vZGVEZXZpY2UsIGNhbWxfcm9vdCwgZnNfbm9kZV9zdXBwb3J0ZWRcbnZhciBqc29vX21vdW50X3BvaW50ID0gW11cbmlmIChmc19ub2RlX3N1cHBvcnRlZCgpKSB7XG4gIGpzb29fbW91bnRfcG9pbnQucHVzaCh7cGF0aDpjYW1sX3Jvb3QsZGV2aWNlOm5ldyBNbE5vZGVEZXZpY2UoY2FtbF9yb290KX0pO1xufSBlbHNlIHtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOmNhbWxfcm9vdCxkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QpfSk7XG59XG5qc29vX21vdW50X3BvaW50LnB1c2goe3BhdGg6Y2FtbF9yb290K1wic3RhdGljL1wiLCBkZXZpY2U6bmV3IE1sRmFrZURldmljZShjYW1sX3Jvb3QrXCJzdGF0aWMvXCIpfSk7XG5cbi8vUHJvdmlkZXM6Y2FtbF9saXN0X21vdW50X3BvaW50XG4vL1JlcXVpcmVzOiBqc29vX21vdW50X3BvaW50LCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xpc3RfbW91bnRfcG9pbnQoKXtcbiAgdmFyIHByZXYgPSAwXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKXtcbiAgICB2YXIgb2xkID0gcHJldjtcbiAgICBwcmV2ID0gWzAsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoanNvb19tb3VudF9wb2ludFtpXS5wYXRoKSwgb2xkXVxuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vL1Byb3ZpZGVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9tYWtlX3BhdGgsIGpzb29fbW91bnRfcG9pbnRcbmZ1bmN0aW9uIHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIik7XG4gIHZhciBuYW1lX3NsYXNoID0gbmFtZSArIFwiL1wiO1xuICB2YXIgcmVzO1xuICBmb3IodmFyIGkgPSAwOyBpIDwganNvb19tb3VudF9wb2ludC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtID0ganNvb19tb3VudF9wb2ludFtpXTtcbiAgICBpZihuYW1lX3NsYXNoLnNlYXJjaChtLnBhdGgpID09IDBcbiAgICAgICAmJiAoIXJlcyB8fCByZXMucGF0aC5sZW5ndGggPCBtLnBhdGgubGVuZ3RoKSlcbiAgICAgIHJlcyA9IHtwYXRoOm0ucGF0aCxkZXZpY2U6bS5kZXZpY2UscmVzdDpuYW1lLnN1YnN0cmluZyhtLnBhdGgubGVuZ3RoLG5hbWUubGVuZ3RoKX07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tb3VudF9hdXRvbG9hZFxuLy9SZXF1aXJlczogTWxGYWtlRGV2aWNlLCBjYW1sX21ha2VfcGF0aCwganNvb19tb3VudF9wb2ludFxuZnVuY3Rpb24gY2FtbF9tb3VudF9hdXRvbG9hZChuYW1lLGYpe1xuICB2YXIgcGF0aCA9IGNhbWxfbWFrZV9wYXRoKG5hbWUpO1xuICB2YXIgbmFtZSA9IHBhdGguam9pbihcIi9cIikgKyBcIi9cIjtcbiAganNvb19tb3VudF9wb2ludC5wdXNoKHtwYXRoOm5hbWUsZGV2aWNlOm5ldyBNbEZha2VEZXZpY2UobmFtZSxmKX0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VubW91bnRcbi8vUmVxdWlyZXM6IGpzb29fbW91bnRfcG9pbnQsIGNhbWxfbWFrZV9wYXRoXG5mdW5jdGlvbiBjYW1sX3VubW91bnQobmFtZSl7XG4gIHZhciBwYXRoID0gY2FtbF9tYWtlX3BhdGgobmFtZSk7XG4gIHZhciBuYW1lID0gcGF0aC5qb2luKFwiL1wiKSArIFwiL1wiO1xuICB2YXIgaWR4ID0gLTE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBqc29vX21vdW50X3BvaW50Lmxlbmd0aDsgaSsrKVxuICAgIGlmKGpzb29fbW91bnRfcG9pbnRbaV0ucGF0aCA9PSBuYW1lKSBpZHggPSBpO1xuICBpZihpZHggPiAtMSkganNvb19tb3VudF9wb2ludC5zcGxpY2UoaWR4LDEpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRjd2Rcbi8vUmVxdWlyZXM6IGNhbWxfY3VycmVudF9kaXIsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGN3ZCgpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoY2FtbF9jdXJyZW50X2Rpcik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NoZGlyXG4vL1JlcXVpcmVzOiBjYW1sX2N1cnJlbnRfZGlyLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX2NoZGlyKGRpcikge1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKGRpcik7XG4gIGlmKHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpKSB7XG4gICAgaWYocm9vdC5yZXN0KSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoICsgcm9vdC5yZXN0ICsgXCIvXCI7XG4gICAgZWxzZSBjYW1sX2N1cnJlbnRfZGlyID0gcm9vdC5wYXRoO1xuICAgIHJldHVybiAwO1xuICB9XG4gIGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKGRpcik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yXG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZShuYW1lKXtcbiAgbmFtZSA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcobmFtZSk7XG4gIGNhbWxfcmFpc2Vfc3lzX2Vycm9yIChuYW1lICsgXCI6IE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmFpc2Vfbm90X2FfZGlyXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvclxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9yYWlzZV9ub3RfYV9kaXIobmFtZSl7XG4gIG5hbWUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpO1xuICBjYW1sX3JhaXNlX3N5c19lcnJvciAobmFtZSArIFwiOiBOb3QgYSBkaXJlY3RvcnlcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2ZpbGVfZXhpc3RzXG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfZmlsZV9leGlzdHMgKG5hbWUpIHtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgcmV0dXJuIHJvb3QuZGV2aWNlLmV4aXN0cyhyb290LnJlc3QpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9ub3RfYV9kaXIsIHJlc29sdmVfZnNfZGV2aWNlXG5mdW5jdGlvbiBjYW1sX3N5c19yZWFkX2RpcmVjdG9yeShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIGEgPSByb290LmRldmljZS5yZWFkZGlyKHJvb3QucmVzdCk7XG4gIHZhciBsID0gbmV3IEFycmF5KGEubGVuZ3RoICsgMSk7XG4gIGxbMF0gPSAwO1xuICBmb3IodmFyIGk9MDtpPGEubGVuZ3RoO2krKylcbiAgICBsW2krMV0gPSBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKGFbaV0pO1xuICByZXR1cm4gbDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfcmVtb3ZlXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbW92ZShuYW1lKXtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgdmFyIG9rID0gcm9vdC5kZXZpY2UudW5saW5rKHJvb3QucmVzdCk7XG4gIGlmKG9rID09IDApIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfaXNfZGlyZWN0b3J5XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuZnVuY3Rpb24gY2FtbF9zeXNfaXNfZGlyZWN0b3J5KG5hbWUpe1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICB2YXIgYSA9IHJvb3QuZGV2aWNlLmlzX2Rpcihyb290LnJlc3QpO1xuICByZXR1cm4gYT8xOjA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JlbmFtZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2VcbmZ1bmN0aW9uIGNhbWxfc3lzX3JlbmFtZShvLG4pe1xuICB2YXIgb19yb290ID0gcmVzb2x2ZV9mc19kZXZpY2Uobyk7XG4gIHZhciBuX3Jvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuKTtcbiAgaWYob19yb290LmRldmljZSAhPSBuX3Jvb3QuZGV2aWNlKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IGNhbm5vdCBtb3ZlIGZpbGUgYmV0d2VlbiB0d28gZmlsZXN5c3RlbVwiKTtcbiAgaWYoIW9fcm9vdC5kZXZpY2UucmVuYW1lKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJjYW1sX3N5c19yZW5hbWU6IG5vIGltcGxlbWVudGVkXCIpO1xuICBvX3Jvb3QuZGV2aWNlLnJlbmFtZShvX3Jvb3QucmVzdCwgbl9yb290LnJlc3QpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbWFwX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfYmFfbWFwX2ZpbGUodmZkLCBraW5kLCBsYXlvdXQsIHNoYXJlZCwgZGltcywgcG9zKSB7XG4gIC8vIHZhciBkYXRhID0gY2FtbF9nbG9iYWxfZGF0YS5mZHNbdmZkXTtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfYmFfbWFwX2ZpbGUgbm90IGltcGxlbWVudGVkXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX21hcF9maWxlXG5mdW5jdGlvbiBjYW1sX2JhX21hcF9maWxlX2J5dGVjb2RlKGFyZ3YsYXJnbil7XG4gIHJldHVybiBjYW1sX2JhX21hcF9maWxlKGFyZ3ZbMF0sYXJndlsxXSxhcmd2WzJdLGFyZ3ZbM10sYXJndls0XSxhcmd2WzVdKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZV9leHRlcm5cbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGVfZXh0ZXJuKG5hbWUsY29udGVudCl7XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUpXG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9jcmVhdGVfZmlsZShuYW1lLGNvbnRlbnQpO1xuICBlbHNlIHtcbiAgICBpZigham9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXApIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfZnNfdG1wID0gW107XG4gICAgam9vX2dsb2JhbF9vYmplY3QuY2FtbF9mc190bXAucHVzaCh7bmFtZTpuYW1lLGNvbnRlbnQ6Y29udGVudH0pO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZzX2luaXRcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2ZpbGVcbmZ1bmN0aW9uIGNhbWxfZnNfaW5pdCAoKXtcbiAgdmFyIHRtcD1qb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcFxuICBpZih0bXApe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0bXAubGVuZ3RoOyBpKyspe1xuICAgICAgY2FtbF9jcmVhdGVfZmlsZSh0bXBbaV0ubmFtZSx0bXBbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG4gIGpvb19nbG9iYWxfb2JqZWN0LmNhbWxfY3JlYXRlX2ZpbGUgPSBjYW1sX2NyZWF0ZV9maWxlO1xuICBqb29fZ2xvYmFsX29iamVjdC5jYW1sX2ZzX3RtcCA9IFtdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jcmVhdGVfZmlsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgcmVzb2x2ZV9mc19kZXZpY2UsIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY3JlYXRlX2ZpbGUobmFtZSxjb250ZW50KSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIGNvbnRlbnQgPSAodHlwZW9mIGNvbnRlbnQgPT0gXCJzdHJpbmdcIik/Y2FtbF9zdHJpbmdfb2ZfanNieXRlcyhjb250ZW50KTpjb250ZW50O1xuICB2YXIgcm9vdCA9IHJlc29sdmVfZnNfZGV2aWNlKG5hbWUpO1xuICBpZighIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKSBjYW1sX2ZhaWx3aXRoKFwiY2Fubm90IHJlZ2lzdGVyIGZpbGVcIik7XG4gIHJvb3QuZGV2aWNlLnJlZ2lzdGVyKHJvb3QucmVzdCxjb250ZW50KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcmVhZF9maWxlX2NvbnRlbnRcbi8vUmVxdWlyZXM6IHJlc29sdmVfZnNfZGV2aWNlLCBjYW1sX3JhaXNlX25vX3N1Y2hfZmlsZSwgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3JlYWRfZmlsZV9jb250ZW50IChuYW1lKSB7XG4gIHZhciBuYW1lID0gKHR5cGVvZiBuYW1lID09IFwic3RyaW5nXCIpP2NhbWxfc3RyaW5nX29mX2pzYnl0ZXMobmFtZSk6bmFtZTtcbiAgdmFyIHJvb3QgPSByZXNvbHZlX2ZzX2RldmljZShuYW1lKTtcbiAgaWYocm9vdC5kZXZpY2UuZXhpc3RzKHJvb3QucmVzdCkpIHtcbiAgICB2YXIgZmlsZSA9IHJvb3QuZGV2aWNlLm9wZW4ocm9vdC5yZXN0LHtyZG9ubHk6MX0pO1xuICAgIHZhciBsZW4gID0gZmlsZS5sZW5ndGgoKTtcbiAgICB2YXIgYnVmICA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gICAgZmlsZS5yZWFkKDAsYnVmLDAsbGVuKTtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKVxuICB9XG4gIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlKG5hbWUpO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBTeXNcblxuLy9Qcm92aWRlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV93aXRoX3N0cmluZywgY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9yYWlzZV9zeXNfZXJyb3IgKG1zZykge1xuICBjYW1sX3JhaXNlX3dpdGhfc3RyaW5nKGNhbWxfZ2xvYmFsX2RhdGEuU3lzX2Vycm9yLCBtc2cpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19leGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4aXQgKGNvZGUpIHtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYoZy5xdWl0KSBnLnF1aXQoY29kZSk7XG4gIC8vbm9kZWpzXG4gIGlmKGcucHJvY2VzcyAmJiBnLnByb2Nlc3MuZXhpdClcbiAgICBnLnByb2Nlc3MuZXhpdChjb2RlKTtcbiAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiRnVuY3Rpb24gJ2V4aXQnIG5vdCBpbXBsZW1lbnRlZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zZXRfc3RhdGljX2VudlxuZnVuY3Rpb24gY2FtbF9zZXRfc3RhdGljX2VudihrLHYpe1xuICBpZigham9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52KVxuICAgIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudiA9IHt9XG4gIGpvb19nbG9iYWxfb2JqZWN0Lmpzb29fc3RhdGljX2VudltrXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9zeXNfZ2V0ZW52IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfbm90X2ZvdW5kXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9qc3N0cmluZ19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfc3lzX2dldGVudiAobmFtZSkge1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgbiA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKG5hbWUpO1xuICAvL25vZGVqcyBlbnZcbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5lbnZcbiAgICAgJiYgZy5wcm9jZXNzLmVudltuXSAhPSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGcucHJvY2Vzcy5lbnZbbl0pO1xuICBpZihqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZcbiAgICAgJiYgam9vX2dsb2JhbF9vYmplY3QuanNvb19zdGF0aWNfZW52W25dKVxuICAgIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhqb29fZ2xvYmFsX29iamVjdC5qc29vX3N0YXRpY19lbnZbbl0pXG4gIGNhbWxfcmFpc2Vfbm90X2ZvdW5kICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c191bnNhZmVfZ2V0ZW52XG4vL1JlcXVpcmVzOiBjYW1sX3N5c19nZXRlbnZcbmZ1bmN0aW9uIGNhbWxfc3lzX3Vuc2FmZV9nZXRlbnYobmFtZSl7XG4gIHJldHVybiBjYW1sX3N5c19nZXRlbnYgKG5hbWUpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FyZ3Zcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG52YXIgY2FtbF9hcmd2ID0gKChmdW5jdGlvbiAoKSB7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIHZhciBtYWluID0gXCJhLm91dFwiO1xuICB2YXIgYXJncyA9IFtdXG5cbiAgaWYoZy5wcm9jZXNzXG4gICAgICYmIGcucHJvY2Vzcy5hcmd2XG4gICAgICYmIGcucHJvY2Vzcy5hcmd2Lmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgYXJndiA9IGcucHJvY2Vzcy5hcmd2XG4gICAgLy9ub2RlanNcbiAgICBtYWluID0gYXJndlsxXTtcbiAgICBhcmdzID0gYXJndi5zbGljZSgyKTtcbiAgfVxuXG4gIHZhciBwID0gY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcobWFpbik7XG4gIHZhciBhcmdzMiA9IFswLCBwXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgYXJnczIucHVzaChjYW1sX3N0cmluZ19vZl9qc3N0cmluZyhhcmdzW2ldKSk7XG4gIHJldHVybiBhcmdzMjtcbn0pKCkpXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXhlY3V0YWJsZV9uYW1lXG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbnZhciBjYW1sX2V4ZWN1dGFibGVfbmFtZSA9IGNhbWxfYXJndlsxXVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfYXJndiAoYSkge1xuICByZXR1cm4gWzAsIGNhbWxfYXJndlsxXSwgY2FtbF9hcmd2XTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfYXJndlxuLy9SZXF1aXJlczogY2FtbF9hcmd2XG5mdW5jdGlvbiBjYW1sX3N5c19hcmd2IChhKSB7XG4gIHJldHVybiBjYW1sX2FyZ3Y7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX21vZGlmeV9hcmd2XG4vL1JlcXVpcmVzOiBjYW1sX2FyZ3ZcbmZ1bmN0aW9uIGNhbWxfc3lzX21vZGlmeV9hcmd2KGFyZyl7XG4gIGNhbWxfYXJndiA9IGFyZztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9leGVjdXRhYmxlX25hbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX2V4ZWN1dGFibGVfbmFtZShhKXtcbiAgcmV0dXJuIGNhbWxfZXhlY3V0YWJsZV9uYW1lXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3N5c3RlbV9jb21tYW5kXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfc3lzdGVtX2NvbW1hbmQoY21kKXtcbiAgdmFyIGNtZCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGNtZCk7XG4gIGlmICh0eXBlb2YgcmVxdWlyZSAhPSBcInVuZGVmaW5lZFwiXG4gICAgICAmJiByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbiAgICAgICYmIHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5leGVjU3luYykge1xuICAgIHRyeSB7cmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKGNtZCx7c3RkaW86ICdpbmhlcml0J30pOyByZXR1cm4gMH1cbiAgICBjYXRjaCAoZSkge3JldHVybiAxfVxuICB9XG4gIGVsc2UgcmV0dXJuIDEyNztcbn1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfdGltZSBtdXRhYmxlXG52YXIgY2FtbF9pbml0aWFsX3RpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpICogMC4wMDE7XG5mdW5jdGlvbiBjYW1sX3N5c190aW1lICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHJldHVybiBub3cgKiAwLjAwMSAtIGNhbWxfaW5pdGlhbF90aW1lO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c190aW1lX2luY2x1ZGVfY2hpbGRyZW5cbi8vUmVxdWlyZXM6IGNhbWxfc3lzX3RpbWVcbmZ1bmN0aW9uIGNhbWxfc3lzX3RpbWVfaW5jbHVkZV9jaGlsZHJlbihiKSB7XG4gIHJldHVybiBjYW1sX3N5c190aW1lKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX3JhbmRvbV9zZWVkIG11dGFibGVcbi8vVGhlIGZ1bmN0aW9uIG5lZWRzIHRvIHJldHVybiBhbiBhcnJheSBzaW5jZSBPQ2FtbCA0LjAuLi5cbmZ1bmN0aW9uIGNhbWxfc3lzX3JhbmRvbV9zZWVkICgpIHtcbiAgdmFyIG5vdyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gIHZhciB4ID0gbm93XjB4ZmZmZmZmZmYqTWF0aC5yYW5kb20oKTtcbiAgcmV0dXJuIFswLHhdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9iaWdfZW5kaWFuICgpIHsgcmV0dXJuIDA7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfd29yZF9zaXplIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF93b3JkX3NpemUgKCkgeyByZXR1cm4gMzI7IH1cblxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3RfaW50X3NpemUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfc3lzX2NvbnN0X2ludF9zaXplICgpIHsgcmV0dXJuIDMyOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X21heF93b3NpemUgY29uc3Rcbi8vIG1heF9pbnQgLyA0IHNvIHRoYXQgdGhlIGZvbGxvd2luZyBkb2VzIG5vdCBvdmVyZmxvd1xuLy9sZXQgbWF4X3N0cmluZ19sZW5ndGggPSB3b3JkX3NpemUgLyA4ICogbWF4X2FycmF5X2xlbmd0aCAtIDE7O1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbWF4X3dvc2l6ZSAoKSB7IHJldHVybiAoMHg3RkZGRkZGRi80KSB8IDA7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jb25zdF9vc3R5cGVfdW5peCBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3VuaXggKCkgeyByZXR1cm4gMTsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX3dpbjMyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX3N5c19jb25zdF9vc3R5cGVfd2luMzIgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiBjb25zdFxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3Rfb3N0eXBlX2N5Z3dpbiAoKSB7IHJldHVybiAwOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X2JhY2tlbmRfdHlwZSBjb25zdFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfYmFja2VuZF90eXBlICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwianNfb2Zfb2NhbWxcIildO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19nZXRfY29uZmlnIGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX3N5c19nZXRfY29uZmlnICgpIHtcbiAgcmV0dXJuIFswLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiVW5peFwiKSwgMzIsIDBdO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19pc2F0dHlcbmZ1bmN0aW9uIGNhbWxfc3lzX2lzYXR0eShfY2hhbikge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3ZhcmlhbnRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV92YXJpYW50KF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3BhcmFtZXRlcnNcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfcnVudGltZV9wYXJhbWV0ZXJzKF91bml0KSB7XG4gIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2luc3RhbGxfc2lnbmFsX2hhbmRsZXIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfaW5zdGFsbF9zaWduYWxfaGFuZGxlcigpe3JldHVybiAwfVxuXG4vL1Byb3ZpZGVzOiB1bml4X2luZXRfYWRkcl9vZl9zdHJpbmdcbmZ1bmN0aW9uIHVuaXhfaW5ldF9hZGRyX29mX3N0cmluZyAoKSB7cmV0dXJuIDA7fVxuXG5cblxuLy9Qcm92aWRlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG52YXIgY2FtbF9ydW50aW1lX3dhcm5pbmdzID0gMDtcblxuLy9Qcm92aWRlczogY2FtbF9tbF9lbmFibGVfcnVudGltZV93YXJuaW5nc1xuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX2VuYWJsZV9ydW50aW1lX3dhcm5pbmdzIChib29sKSB7XG4gIGNhbWxfcnVudGltZV93YXJuaW5ncyA9IGJvb2w7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZFxuLy9SZXF1aXJlczogY2FtbF9ydW50aW1lX3dhcm5pbmdzXG5mdW5jdGlvbiBjYW1sX21sX3J1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCAoX3VuaXQpIHtcbiAgcmV0dXJuIGNhbWxfcnVudGltZV93YXJuaW5ncztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX3NwYWNldGltZV9lbmFibGVkIGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfc3BhY2V0aW1lX2VuYWJsZWQoX3VuaXQpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX2NvbnN0X25ha2VkX3BvaW50ZXJzX2NoZWNrZWQgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9zeXNfY29uc3RfbmFrZWRfcG9pbnRlcnNfY2hlY2tlZChfdW5pdCkge1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgY29uc3QgKGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9yZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUoX2NoYW5uZWwpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX3NwYWNldGltZV9vbmx5X3dvcmtzX2Zvcl9uYXRpdmVfY29kZSgpIHtcbiAgY2FtbF9mYWlsd2l0aChcIlNwYWNldGltZSBwcm9maWxpbmcgb25seSB3b3JrcyBmb3IgbmF0aXZlIGNvZGVcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTQgSsOpcsO0bWUgVm91aWxsb24sIEh1Z28gSGV1emFyZFxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBNbEZha2VEZXZpY2Vcbi8vUmVxdWlyZXM6IE1sRmFrZUZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9yYWlzZV9ub19zdWNoX2ZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX29mX2FycmF5LCBjYW1sX2J5dGVzX29mX3N0cmluZywgY2FtbF9ieXRlc19vZl9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gTWxGYWtlRGV2aWNlIChyb290LCBmKSB7XG4gIHRoaXMuY29udGVudD17fTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5sb29rdXBGdW4gPSBmO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighdGhpcy5jb250ZW50W25hbWVdICYmIHRoaXMubG9va3VwRnVuKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMubG9va3VwRnVuKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXModGhpcy5yb290KSwgY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhuYW1lKSk7XG4gICAgaWYocmVzICE9PSAwKSB0aGlzLmNvbnRlbnRbbmFtZV09bmV3IE1sRmFrZUZpbGUoY2FtbF9ieXRlc19vZl9zdHJpbmcocmVzWzFdKSk7XG4gIH1cbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICAvLyBUaGUgcm9vdCBvZiB0aGUgZGV2aWNlIGV4aXN0c1xuICBpZihuYW1lID09IFwiXCIpIHJldHVybiAxO1xuICAvLyBDaGVjayBpZiBhIGRpcmVjdG9yeSBleGlzdHNcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSArIFwiL1wiKTtcbiAgdmFyIHIgPSBuZXcgUmVnRXhwKFwiXlwiICsgbmFtZV9zbGFzaCk7XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICBpZiAobi5tYXRjaChyKSkgcmV0dXJuIDFcbiAgfVxuICAvLyBDaGVjayBpZiBhIGZpbGUgZXhpc3RzXG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdPzE6MDtcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgc2VlbiA9IHt9XG4gIHZhciBhID0gW107XG4gIGZvcih2YXIgbiBpbiB0aGlzLmNvbnRlbnQpIHtcbiAgICB2YXIgbSA9IG4ubWF0Y2gocik7XG4gICAgaWYobSAmJiAhc2VlblttWzFdXSkge3NlZW5bbVsxXV0gPSB0cnVlOyBhLnB1c2gobVsxXSl9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5NbEZha2VEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIG5hbWVfc2xhc2ggPSAobmFtZSA9PSBcIlwiKT9cIlwiOihuYW1lICsgXCIvXCIpO1xuICB2YXIgciA9IG5ldyBSZWdFeHAoXCJeXCIgKyBuYW1lX3NsYXNoICsgXCIoW14vXSopXCIpO1xuICB2YXIgYSA9IFtdO1xuICBmb3IodmFyIG4gaW4gdGhpcy5jb250ZW50KSB7XG4gICAgdmFyIG0gPSBuLm1hdGNoKHIpO1xuICAgIGlmKG0pIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn1cbk1sRmFrZURldmljZS5wcm90b3R5cGUudW5saW5rID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgb2sgPSB0aGlzLmNvbnRlbnRbbmFtZV0/dHJ1ZTpmYWxzZTtcbiAgZGVsZXRlIHRoaXMuY29udGVudFtuYW1lXTtcbiAgcmV0dXJuIG9rO1xufVxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24obmFtZSwgZikge1xuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IodGhpcy5ubShuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHRoaXMubG9va3VwKG5hbWUpO1xuICBpZiAodGhpcy5jb250ZW50W25hbWVdKSB7XG4gICAgaWYgKHRoaXMuaXNfZGlyKG5hbWUpKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBpcyBhIGRpcmVjdG9yeVwiKTtcbiAgICBpZiAoZi5jcmVhdGUgJiYgZi5leGNsKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICAgIHZhciBmaWxlID0gdGhpcy5jb250ZW50W25hbWVdO1xuICAgIGlmKGYudHJ1bmNhdGUpIGZpbGUudHJ1bmNhdGUoKTtcbiAgICByZXR1cm4gZmlsZTtcbiAgfSBlbHNlIGlmIChmLmNyZWF0ZSkge1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKTtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50W25hbWVdO1xuICB9IGVsc2Uge1xuICAgIGNhbWxfcmFpc2Vfbm9fc3VjaF9maWxlICh0aGlzLm5tKG5hbWUpKTtcbiAgfVxufVxuXG5NbEZha2VEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyPSBmdW5jdGlvbiAobmFtZSxjb250ZW50KXtcbiAgaWYodGhpcy5jb250ZW50W25hbWVdKSBjYW1sX3JhaXNlX3N5c19lcnJvcih0aGlzLm5tKG5hbWUpICsgXCIgOiBmaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuICBpZihjYW1sX2lzX21sX2J5dGVzKGNvbnRlbnQpKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNvbnRlbnQpO1xuICBpZihjYW1sX2lzX21sX3N0cmluZyhjb250ZW50KSlcbiAgICB0aGlzLmNvbnRlbnRbbmFtZV0gPSBuZXcgTWxGYWtlRmlsZShjYW1sX2J5dGVzX29mX3N0cmluZyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudCBpbnN0YW5jZW9mIEFycmF5KVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfYXJyYXkoY29udGVudCkpO1xuICBlbHNlIGlmKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKVxuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGNhbWxfYnl0ZXNfb2ZfanNieXRlcyhjb250ZW50KSk7XG4gIGVsc2UgaWYoY29udGVudC50b1N0cmluZykge1xuICAgIHZhciBieXRlcyA9IGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKGNhbWxfc3RyaW5nX29mX2pzc3RyaW5nKGNvbnRlbnQudG9TdHJpbmcoKSkpO1xuICAgIHRoaXMuY29udGVudFtuYW1lXSA9IG5ldyBNbEZha2VGaWxlKGJ5dGVzKTtcbiAgfVxuICBlbHNlIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKHRoaXMubm0obmFtZSkgKyBcIiA6IHJlZ2lzdGVyaW5nIGZpbGUgd2l0aCBpbnZhbGlkIGNvbnRlbnQgdHlwZVwiKTtcbn1cblxuTWxGYWtlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sRmFrZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGVcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2JsaXRfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2J5dGVzX2dldFxuZnVuY3Rpb24gTWxGYWtlRmlsZShjb250ZW50KXtcbiAgdGhpcy5kYXRhID0gY29udGVudDtcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlID0gbmV3IE1sRmlsZSAoKTtcbk1sRmFrZUZpbGUucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24obGVuKXtcbiAgdmFyIG9sZCA9IHRoaXMuZGF0YTtcbiAgdGhpcy5kYXRhID0gY2FtbF9jcmVhdGVfYnl0ZXMobGVufDApO1xuICBjYW1sX2JsaXRfYnl0ZXMob2xkLCAwLCB0aGlzLmRhdGEsIDAsIGxlbik7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYW1sX21sX2J5dGVzX2xlbmd0aCh0aGlzLmRhdGEpO1xufVxuTWxGYWtlRmlsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGlmKG9mZnNldCArIGxlbiA+PSBjbGVuKSB7XG4gICAgdmFyIG5ld19zdHIgPSBjYW1sX2NyZWF0ZV9ieXRlcyhvZmZzZXQgKyBsZW4pO1xuICAgIHZhciBvbGRfZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB0aGlzLmRhdGEgPSBuZXdfc3RyO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhvbGRfZGF0YSwgMCwgdGhpcy5kYXRhLCAwLCBjbGVuKTtcbiAgfVxuICBjYW1sX2JsaXRfc3RyaW5nKGJ1ZiwgcG9zLCB0aGlzLmRhdGEsIG9mZnNldCwgbGVuKTtcbiAgcmV0dXJuIDBcbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihvZmZzZXQsYnVmLHBvcyxsZW4pe1xuICB2YXIgY2xlbiA9IHRoaXMubGVuZ3RoKCk7XG4gIGNhbWxfYmxpdF9ieXRlcyh0aGlzLmRhdGEsIG9mZnNldCwgYnVmLCBwb3MsIGxlbik7XG4gIHJldHVybiAwXG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5yZWFkX29uZSA9IGZ1bmN0aW9uKG9mZnNldCl7XG4gIHJldHVybiBjYW1sX2J5dGVzX2dldCh0aGlzLmRhdGEsIG9mZnNldCk7XG59XG5NbEZha2VGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCl7XG5cbn1cbk1sRmFrZUZpbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWxGYWtlRmlsZVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogZnNfbm9kZV9zdXBwb3J0ZWRcbmZ1bmN0aW9uIGZzX25vZGVfc3VwcG9ydGVkICgpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygam9vX2dsb2JhbF9vYmplY3QucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5wcm9jZXNzLnZlcnNpb25zICE9PSAndW5kZWZpbmVkJ1xuICAgICAgJiYgdHlwZW9mIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICYmIGpvb19nbG9iYWxfb2JqZWN0LnByb2Nlc3MucGxhdGZvcm0gIT09IFwiYnJvd3NlclwiKVxufVxuXG5cbi8vUHJvdmlkZXM6IE1sTm9kZURldmljZVxuLy9SZXF1aXJlczogTWxOb2RlRmlsZSwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZURldmljZShyb290KSB7XG4gIHRoaXMuZnMgPSByZXF1aXJlKCdmcycpO1xuICB0aGlzLnJvb3QgPSByb290O1xufVxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5ubSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuICh0aGlzLnJvb3QgKyBuYW1lKTtcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmV4aXN0c1N5bmModGhpcy5ubShuYW1lKSk/MTowO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5yZWFkZGlyU3luYyh0aGlzLm5tKG5hbWUpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLmlzX2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdGhpcy5mcy5zdGF0U3luYyh0aGlzLm5tKG5hbWUpKS5pc0RpcmVjdG9yeSgpPzE6MDtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5NbE5vZGVEZXZpY2UucHJvdG90eXBlLnVubGluayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IHRoaXMuZnMuZXhpc3RzU3luYyh0aGlzLm5tKG5hbWUpKT8xOjA7XG4gICAgdGhpcy5mcy51bmxpbmtTeW5jKHRoaXMubm0obmFtZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJcbn1cbk1sTm9kZURldmljZS5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKG5hbWUsIGYpIHtcbiAgdmFyIGNvbnN0cyA9IHJlcXVpcmUoJ2NvbnN0YW50cycpO1xuICB2YXIgcmVzID0gMDtcbiAgZm9yKHZhciBrZXkgaW4gZil7XG4gICAgc3dpdGNoKGtleSl7XG4gICAgY2FzZSBcInJkb25seVwiICA6IHJlcyB8PSBjb25zdHMuT19SRE9OTFk7IGJyZWFrO1xuICAgIGNhc2UgXCJ3cm9ubHlcIiAgOiByZXMgfD0gY29uc3RzLk9fV1JPTkxZOyBicmVhaztcbiAgICBjYXNlIFwiYXBwZW5kXCIgIDpcbiAgICAgIHJlcyB8PSBjb25zdHMuT19XUk9OTFkgfCBjb25zdHMuT19BUFBFTkQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY3JlYXRlXCIgICA6IHJlcyB8PSBjb25zdHMuT19DUkVBVDsgICAgYnJlYWs7XG4gICAgY2FzZSBcInRydW5jYXRlXCIgOiByZXMgfD0gY29uc3RzLk9fVFJVTkM7ICAgIGJyZWFrO1xuICAgIGNhc2UgXCJleGNsXCIgICAgIDogcmVzIHw9IGNvbnN0cy5PX0VYQ0w7ICAgICBicmVhaztcbiAgICBjYXNlIFwiYmluYXJ5XCIgICA6IHJlcyB8PSBjb25zdHMuT19CSU5BUlk7ICAgYnJlYWs7XG4gICAgY2FzZSBcInRleHRcIiAgICAgOiByZXMgfD0gY29uc3RzLk9fVEVYVDsgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJub25ibG9ja1wiIDogcmVzIHw9IGNvbnN0cy5PX05PTkJMT0NLOyBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgZmQgPSB0aGlzLmZzLm9wZW5TeW5jKHRoaXMubm0obmFtZSksIHJlcyk7XG4gICAgcmV0dXJuIG5ldyBNbE5vZGVGaWxlKGZkKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG59XG5cbk1sTm9kZURldmljZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obyxuKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZW5hbWVTeW5jKHRoaXMubm0obyksIHRoaXMubm0obikpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRGV2aWNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1sTm9kZURldmljZVxuXG4vL1Byb3ZpZGVzOiBNbE5vZGVGaWxlXG4vL1JlcXVpcmVzOiBNbEZpbGUsIGNhbWxfYXJyYXlfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzLCBjYW1sX2J5dGVzX3NldCwgY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIE1sTm9kZUZpbGUoZmQpe1xuICB0aGlzLmZzID0gcmVxdWlyZSgnZnMnKTtcbiAgdGhpcy5mZCA9IGZkO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUgPSBuZXcgTWxGaWxlICgpO1xuXG5NbE5vZGVGaWxlLnByb3RvdHlwZS50cnVuY2F0ZSA9IGZ1bmN0aW9uKGxlbil7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5mdHJ1bmNhdGVTeW5jKHRoaXMuZmQsbGVufDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiB0aGlzLmZzLmZzdGF0U3luYyh0aGlzLmZkKS5zaXplO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cbk1sTm9kZUZpbGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9zdHJpbmcoYnVmKTtcbiAgaWYoISAoYSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LlVpbnQ4QXJyYXkpKVxuICAgIGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhKTtcbiAgdmFyIGJ1ZmZlciA9IGpvb19nbG9iYWxfb2JqZWN0LkJ1ZmZlci5mcm9tKGEpO1xuICB0cnkge1xuICAgIHRoaXMuZnMud3JpdGVTeW5jKHRoaXMuZmQsIGJ1ZmZlciwgYnVmX29mZnNldCwgbGVuLCBvZmZzZXQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5NbE5vZGVGaWxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24ob2Zmc2V0LGJ1ZixidWZfb2Zmc2V0LGxlbil7XG4gIHZhciBhID0gY2FtbF9hcnJheV9vZl9ieXRlcyhidWYpO1xuICBpZighIChhIGluc3RhbmNlb2Ygam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheSkpXG4gICAgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KGEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIGJ1Zl9vZmZzZXQsIGxlbiwgb2Zmc2V0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuICB9XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgY2FtbF9ieXRlc19zZXQoYnVmLGJ1Zl9vZmZzZXQgKyBpLGJ1ZmZlcltidWZfb2Zmc2V0K2ldKTtcbiAgfVxuICByZXR1cm4gMFxufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUucmVhZF9vbmUgPSBmdW5jdGlvbihvZmZzZXQpe1xuICB2YXIgYSA9IG5ldyBqb29fZ2xvYmFsX29iamVjdC5VaW50OEFycmF5KDEpO1xuICB2YXIgYnVmZmVyID0gam9vX2dsb2JhbF9vYmplY3QuQnVmZmVyLmZyb20oYSk7XG4gIHRyeSB7XG4gICAgdGhpcy5mcy5yZWFkU3luYyh0aGlzLmZkLCBidWZmZXIsIDAsIDEsIG9mZnNldCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKGVyci50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyWzBdO1xufVxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICB0cnkge1xuICAgIHRoaXMuZnMuY2xvc2VTeW5jKHRoaXMuZmQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihlcnIudG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuTWxOb2RlRmlsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNbE5vZGVGaWxlO1xuIiwiLy9Qcm92aWRlczogaW5pdGlhbGl6ZV9uYXRcbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogc2VyaWFsaXplX25hdCwgZGVzZXJpYWxpemVfbmF0LCBjYW1sX2hhc2hfbmF0XG5mdW5jdGlvbiBpbml0aWFsaXplX25hdCgpIHtcbiAgY2FtbF9jdXN0b21fb3BzW1wiX25hdFwiXSA9XG4gICAgeyBkZXNlcmlhbGl6ZSA6IGRlc2VyaWFsaXplX25hdCxcbiAgICAgIHNlcmlhbGl6ZSA6IHNlcmlhbGl6ZV9uYXQsXG4gICAgICBoYXNoIDogY2FtbF9oYXNoX25hdFxuICAgIH1cbn1cblxuLy9Qcm92aWRlczogTWxOYXRcbmZ1bmN0aW9uIE1sTmF0KHgpe1xuICB0aGlzLmRhdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuSW50MzJBcnJheSh4KTtcbiAgLy8gbGVuZ3RoX25hdCBpc24ndCBleHRlcm5hbCwgc28gd2UgaGF2ZSB0byBtYWtlIHRoZSBPYmouc2l6ZVxuICAvLyB3b3JrIG91dCByaWdodC4gVGhlICsyIHRvIGFycmF5IGxlbmd0aCBzZWVtcyB0byB3b3JrLlxuICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggKyAyXG59XG5cbk1sTmF0LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IFwiX25hdFwiO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbmF0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludCwgbnVtX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNhbWxfaGFzaF9uYXQoeCkge1xuICB2YXIgbGVuID0gbnVtX2RpZ2l0c19uYXQoeCwgMCwgeC5kYXRhLmxlbmd0aCk7XG4gIHZhciBoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB4LmRhdGFbaV0pO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG5cbi8vUHJvdmlkZXM6IG5hdF9vZl9hcnJheVxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIG5hdF9vZl9hcnJheShsKXtcbiAgcmV0dXJuIG5ldyBNbE5hdChsKTtcbn1cblxuLy9Qcm92aWRlczogY3JlYXRlX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGNyZWF0ZV9uYXQoc2l6ZSkge1xuICB2YXIgYXJyID0gbmV3IE1sTmF0KHNpemUpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgYXJyLmRhdGFbaV0gPSAtMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vL1Byb3ZpZGVzOiBzZXRfdG9femVyb19uYXRcbmZ1bmN0aW9uIHNldF90b196ZXJvX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hdC5kYXRhW29mcytpXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGJsaXRfbmF0XG5mdW5jdGlvbiBibGl0X25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyLCBsZW4pIHtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmF0MS5kYXRhW29mczEraV0gPSBuYXQyLmRhdGFbb2ZzMitpXTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdFxuZnVuY3Rpb24gc2V0X2RpZ2l0X25hdChuYXQsIG9mcywgZGlnaXQpIHtcbiAgbmF0LmRhdGFbb2ZzXSA9IGRpZ2l0O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbnRoX2RpZ2l0X25hdFxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdChuYXQsIG9mcykge1xuICByZXR1cm4gbmF0LmRhdGFbb2ZzXTtcbn1cblxuLy9Qcm92aWRlczogc2V0X2RpZ2l0X25hdF9uYXRpdmVcbmZ1bmN0aW9uIHNldF9kaWdpdF9uYXRfbmF0aXZlKG5hdCwgb2ZzLCBkaWdpdCkge1xuICBuYXQuZGF0YVtvZnNdID0gZGlnaXQ7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBudGhfZGlnaXRfbmF0X25hdGl2ZVxuZnVuY3Rpb24gbnRoX2RpZ2l0X25hdF9uYXRpdmUobmF0LCBvZnMpIHtcbiAgcmV0dXJuIG5hdC5kYXRhW29mc107XG59XG5cbi8vUHJvdmlkZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBudW1fZGlnaXRzX25hdChuYXQsIG9mcywgbGVuKSB7XG4gIGZvcih2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYobmF0LmRhdGFbb2ZzK2ldICE9IDApIHJldHVybiBpKzE7XG4gIH1cbiAgcmV0dXJuIDE7IC8vIDAgY291bnRzIGFzIDEgZGlnaXRcbn1cblxuLy9Qcm92aWRlczogbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0XG5mdW5jdGlvbiBudW1fbGVhZGluZ196ZXJvX2JpdHNfaW5fZGlnaXQobmF0LCBvZnMpIHtcbiAgdmFyIGEgPSBuYXQuZGF0YVtvZnNdO1xuICB2YXIgYiA9IDA7XG4gIGlmKGEgJiAweEZGRkYwMDAwKSB7IGIgKz0xNjsgYSA+Pj49MTY7IH1cbiAgaWYoYSAmIDB4RkYwMCkgICAgIHsgYiArPSA4OyBhID4+Pj0gODsgfVxuICBpZihhICYgMHhGMCkgICAgICAgeyBiICs9IDQ7IGEgPj4+PSA0OyB9XG4gIGlmKGEgJiAxMikgICAgICAgICB7IGIgKz0gMjsgYSA+Pj49IDI7IH1cbiAgaWYoYSAmIDIpICAgICAgICAgIHsgYiArPSAxOyBhID4+Pj0gMTsgfVxuICBpZihhICYgMSkgICAgICAgICAgeyBiICs9IDE7IH1cbiAgcmV0dXJuIDMyIC0gYjtcbn1cblxuLy9Qcm92aWRlczogaXNfZGlnaXRfaW50XG5mdW5jdGlvbiBpc19kaWdpdF9pbnQobmF0LCBvZnMpIHtcbiAgaWYgKG5hdC5kYXRhW29mc10gPj0gMCkgcmV0dXJuIDFcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X3plcm9cbmZ1bmN0aW9uIGlzX2RpZ2l0X3plcm8obmF0LCBvZnMpIHtcbiAgaWYobmF0LmRhdGFbb2ZzXSA9PSAwKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGlzX2RpZ2l0X29kZFxuZnVuY3Rpb24gaXNfZGlnaXRfb2RkKG5hdCwgb2ZzKSB7XG4gIGlmKG5hdC5kYXRhW29mc10gJiAxKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGluY3JfbmF0XG5mdW5jdGlvbiBpbmNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0LmRhdGFbb2ZzK2ldID4+PiAwKSArIGNhcnJ5O1xuICAgIG5hdC5kYXRhW29mcytpXSA9ICh4IHwgMCk7XG4gICAgaWYoeCA9PSAoeCA+Pj4gMCkpIHtcbiAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXJyeTtcbn1cblxuLy8gbGVuMSA+PSBsZW4yXG4vL1Byb3ZpZGVzOiBhZGRfbmF0XG4vL1JlcXVpcmVzOiBpbmNyX25hdFxuZnVuY3Rpb24gYWRkX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBjYXJyeV9pbikge1xuICB2YXIgY2FycnkgPSBjYXJyeV9pbjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4ID0gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSArIChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKyBjYXJyeTtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHhcbiAgICBpZih4ID09ICh4ID4+PiAwKSkge1xuICAgICAgY2FycnkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYXJyeSA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmNyX25hdChuYXQxLCBvZnMxK2xlbjIsIGxlbjEtbGVuMiwgY2FycnkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wbGVtZW50X25hdFxuZnVuY3Rpb24gY29tcGxlbWVudF9uYXQobmF0LCBvZnMsIGxlbikge1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYXQuZGF0YVtvZnMraV0gPSAoLTEgPj4+IDApIC0gKG5hdC5kYXRhW29mcytpXSA+Pj4gMCk7XG4gIH1cbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vUHJvdmlkZXM6IGRlY3JfbmF0XG5mdW5jdGlvbiBkZWNyX25hdChuYXQsIG9mcywgbGVuLCBjYXJyeV9pbikge1xuICB2YXIgYm9ycm93ID0gKGNhcnJ5X2luID09IDEpID8gMCA6IDE7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB4ID0gKG5hdC5kYXRhW29mcytpXSA+Pj4wKSAtIGJvcnJvdztcbiAgICBuYXQuZGF0YVtvZnMraV0gPSB4O1xuICAgIGlmICh4ID49IDApIHtcbiAgICAgIGJvcnJvdyA9IDA7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChib3Jyb3cgPT0gMSkgPyAwIDogMTtcbn1cblxuLy8gb2NhbWwgZmxpcHMgY2FycnlfaW5cbi8vIGxlbjEgPj0gbGVuMlxuLy9Qcm92aWRlczogc3ViX25hdFxuLy9SZXF1aXJlczogZGVjcl9uYXRcbmZ1bmN0aW9uIHN1Yl9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbGVuMiwgY2FycnlfaW4pIHtcbiAgdmFyIGJvcnJvdyA9IChjYXJyeV9pbiA9PSAxKSA/IDAgOiAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMjsgaSsrKSB7XG4gICAgdmFyIHggPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApIC0gKG5hdDIuZGF0YVtvZnMyK2ldID4+PiAwKSAtIGJvcnJvdztcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHg7XG4gICAgaWYgKHggPj0gMCkge1xuICAgICAgYm9ycm93ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9ycm93ID0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY3JfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCAoYm9ycm93PT0xKT8wOjEpO1xufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzW29mczNdXG4vLyBsZW4xID49IGxlbjJcbi8vUHJvdmlkZXM6IG11bHRfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBhZGRfbmF0LCBuYXRfb2ZfYXJyYXlcbmZ1bmN0aW9uIG11bHRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDMsIG9mczMpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGEgPSAobmF0My5kYXRhW29mczNdID4+PiAwKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjI7IGkrKykge1xuICAgIHZhciB4MSA9IChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgKyAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApICogKGEgJiAweDAwMDBGRkZGKSArIGNhcnJ5O1xuICAgIHZhciB4MiA9IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkgKiAoYSA+Pj4gMTYpO1xuICAgIGNhcnJ5ID0gTWF0aC5mbG9vcih4Mi82NTUzNik7XG4gICAgdmFyIHgzID0geDEgKyAoeDIgJSA2NTUzNikgKiA2NTUzNjtcbiAgICBuYXQxLmRhdGFbb2ZzMStpXSA9IHgzO1xuICAgIGNhcnJ5ICs9IE1hdGguZmxvb3IoeDMvNDI5NDk2NzI5Nik7XG4gIH1cblxuICBpZihsZW4yIDwgbGVuMSAmJiBjYXJyeSkge1xuICAgIHJldHVybiBhZGRfbmF0KG5hdDEsIG9mczErbGVuMiwgbGVuMS1sZW4yLCBuYXRfb2ZfYXJyYXkoW2NhcnJ5XSksIDAsIDEsIDApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXJyeTtcbiAgfVxufVxuXG4vLyBuYXQxICs9IG5hdDIgKiBuYXQzXG4vLyBsZW4xID49IGxlbjIgKyBsZW4zLlxuLy9Qcm92aWRlczogbXVsdF9uYXRcbi8vUmVxdWlyZXM6IG11bHRfZGlnaXRfbmF0XG5mdW5jdGlvbiBtdWx0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yLCBuYXQzLCBvZnMzLCBsZW4zKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW4zOyBpKyspIHtcbiAgICBjYXJyeSArPSBtdWx0X2RpZ2l0X25hdChuYXQxLCBvZnMxK2ksIGxlbjEtaSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0Mywgb2ZzMytpKTtcbiAgfVxuICByZXR1cm4gY2Fycnk7XG59XG5cbi8vIG5hdDEgPSAyICogbmF0MSArIG5hdDIgKiBuYXQyXG4vLyBsZW4xID49IDIgKiBsZW4yXG4vL1Byb3ZpZGVzOiBzcXVhcmVfbmF0XG4vL1JlcXVpcmVzOiBtdWx0X25hdCwgYWRkX25hdFxuZnVuY3Rpb24gc3F1YXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIGNhcnJ5ICs9IGFkZF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0MSwgb2ZzMSwgbGVuMSwgMCk7XG4gIGNhcnJ5ICs9IG11bHRfbmF0KG5hdDEsIG9mczEsIGxlbjEsIG5hdDIsIG9mczIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpO1xuICByZXR1cm4gY2Fycnk7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9sZWZ0X25hdFxuZnVuY3Rpb24gc2hpZnRfbGVmdF9uYXQobmF0MSwgb2ZzMSwgbGVuMSwgbmF0Miwgb2ZzMiwgbmJpdHMpIHtcbiAgaWYobmJpdHMgPT0gMCkge1xuICAgIG5hdDIuZGF0YVtvZnMyXSA9IDA7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgdmFyIHdyYXAgPSAwO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuMTsgaSsrKSB7XG4gICAgdmFyIGEgPSAobmF0MS5kYXRhW29mczEraV0gPj4+IDApO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPDwgbmJpdHMpIHwgd3JhcDtcbiAgICB3cmFwID0gYSA+Pj4gKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vLyBBc3N1bWluZyBjID4gYSwgcmV0dXJucyBbcXVvdGllbnQsIHJlbWFpbmRlcl0gb2YgKGE8PDMyICsgYikvY1xuLy9Qcm92aWRlczogZGl2X2hlbHBlclxuZnVuY3Rpb24gZGl2X2hlbHBlcihhLCBiLCBjKSB7XG4gIHZhciB4ID0gYSAqIDY1NTM2ICsgKGI+Pj4xNik7XG4gIHZhciB5ID0gTWF0aC5mbG9vcih4L2MpICogNjU1MzY7XG4gIHZhciB6ID0gKHggJSBjKSAqIDY1NTM2O1xuICB2YXIgdyA9IHogKyAoYiAmIDB4MDAwMEZGRkYpO1xuICByZXR1cm4gW3kgKyBNYXRoLmZsb29yKHcvYyksIHcgJSBjXTtcbn1cblxuLy8gbmF0MVtvZnMxK2xlbl0gPCBuYXQyW29mczJdXG4vL1Byb3ZpZGVzOiBkaXZfZGlnaXRfbmF0XG4vL1JlcXVpcmVzOiBkaXZfaGVscGVyXG5mdW5jdGlvbiBkaXZfZGlnaXRfbmF0KG5hdHEsIG9mc3EsIG5hdHIsIG9mc3IsIG5hdDEsIG9mczEsIGxlbiwgbmF0Miwgb2ZzMikge1xuICB2YXIgcmVtID0gKG5hdDEuZGF0YVtvZnMxK2xlbi0xXSA+Pj4wKTtcbiAgLy8gbmF0cVtvZnNxK2xlbi0xXSBpcyBndWFyYW50ZWVkIHRvIGJlIHplcm8gKGR1ZSB0byB0aGUgTVNEIHJlcXVpcmVtZW50KSxcbiAgLy8gYW5kIHNob3VsZCBub3QgYmUgd3JpdHRlbiB0by5cbiAgZm9yKHZhciBpID0gbGVuLTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHggPSBkaXZfaGVscGVyKHJlbSwgKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDIuZGF0YVtvZnMyXSA+Pj4gMCkpO1xuICAgIG5hdHEuZGF0YVtvZnNxK2ldID0geFswXTtcbiAgICByZW0gPSB4WzFdO1xuICB9XG4gIG5hdHIuZGF0YVtvZnNyXSA9IHJlbTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vIG5hdDFbbmF0MjpdIDo9IG5hdDEgLyBuYXQyXG4vLyBuYXQxWzpuYXQyXSA6PSBuYXQxICUgbmF0MlxuLy8gbGVuMSA+IGxlbjIsIG5hdDJbb2ZzMitsZW4yLTFdID4gbmF0MVtvZnMxK2xlbjEtMV1cbi8vUHJvdmlkZXM6IGRpdl9uYXRcbi8vUmVxdWlyZXM6IGRpdl9kaWdpdF9uYXQsIGRpdl9oZWxwZXIsIG51bV9sZWFkaW5nX3plcm9fYml0c19pbl9kaWdpdCwgc2hpZnRfbGVmdF9uYXQsIHNoaWZ0X3JpZ2h0X25hdCwgY3JlYXRlX25hdCwgc2V0X3RvX3plcm9fbmF0LCBtdWx0X2RpZ2l0X25hdCwgc3ViX25hdCwgY29tcGFyZV9uYXQsIG5hdF9vZl9hcnJheVxuZnVuY3Rpb24gZGl2X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIGlmKGxlbjIgPT0gMSkge1xuICAgIGRpdl9kaWdpdF9uYXQobmF0MSwgb2ZzMSsxLCBuYXQxLCBvZnMxLCBuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBzID0gbnVtX2xlYWRpbmdfemVyb19iaXRzX2luX2RpZ2l0KG5hdDIsIG9mczIrbGVuMi0xKTtcbiAgc2hpZnRfbGVmdF9uYXQobmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFswXSksIDAsIHMpO1xuICBzaGlmdF9sZWZ0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7XG5cbiAgdmFyIGQgPSAobmF0Mi5kYXRhW29mczIrbGVuMi0xXSA+Pj4gMCkgKyAxO1xuICB2YXIgYSA9IGNyZWF0ZV9uYXQobGVuMisxKTtcbiAgZm9yICh2YXIgaSA9IGxlbjEgLSAxOyBpID49IGxlbjI7IGktLSkge1xuICAgIC8vIERlY2VudCBsb3dlciBib3VuZCBvbiBxdW9cbiAgICB2YXIgcXVvID0gZCA9PSA0Mjk0OTY3Mjk2ID8gKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA6IGRpdl9oZWxwZXIoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSwgKG5hdDEuZGF0YVtvZnMxK2ktMV0gPj4+MCksIGQpWzBdO1xuICAgIHNldF90b196ZXJvX25hdChhLCAwLCBsZW4yKzEpO1xuICAgIG11bHRfZGlnaXRfbmF0KGEsIDAsIGxlbjIrMSwgbmF0Miwgb2ZzMiwgbGVuMiwgbmF0X29mX2FycmF5KFtxdW9dKSwgMCk7XG4gICAgc3ViX25hdChuYXQxLCBvZnMxK2ktbGVuMiwgbGVuMisxLCBhLCAwLCBsZW4yKzEsIDEpO1xuXG4gICAgd2hpbGUgKG5hdDEuZGF0YVtvZnMxK2ldICE9IDAgfHwgY29tcGFyZV9uYXQobmF0MSwgb2ZzMStpLWxlbjIsIGxlbjIsIG5hdDIsIG9mczIsIGxlbjIpID49IDApIHtcbiAgICAgIHF1byA9IHF1byArIDE7XG4gICAgICBzdWJfbmF0KG5hdDEsIG9mczEraS1sZW4yLCBsZW4yKzEsIG5hdDIsIG9mczIsIGxlbjIsIDEpO1xuICAgIH1cblxuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gcXVvO1xuICB9XG5cbiAgc2hpZnRfcmlnaHRfbmF0KG5hdDEsIG9mczEsIGxlbjIsIG5hdF9vZl9hcnJheShbMF0pLCAwLCBzKTsgLy8gc2hpZnQgcmVtYWluZGVyXG4gIHNoaWZ0X3JpZ2h0X25hdChuYXQyLCBvZnMyLCBsZW4yLCBuYXRfb2ZfYXJyYXkoWzBdKSwgMCwgcyk7IC8vIHJlc3RvcmVcbiAgcmV0dXJuIDA7XG59XG5cblxuLy8gMCA8PSBzaGlmdCA8IDMyXG4vL1Byb3ZpZGVzOiBzaGlmdF9yaWdodF9uYXRcbmZ1bmN0aW9uIHNoaWZ0X3JpZ2h0X25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBuYml0cykge1xuICBpZihuYml0cyA9PSAwKSB7XG4gICAgbmF0Mi5kYXRhW29mczJdID0gMDtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgd3JhcCA9IDA7XG4gIGZvcih2YXIgaSA9IGxlbjEtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgYSA9IG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwO1xuICAgIG5hdDEuZGF0YVtvZnMxK2ldID0gKGEgPj4+IG5iaXRzKSB8IHdyYXA7XG4gICAgd3JhcCA9IGEgPDwgKDMyIC0gbmJpdHMpO1xuICB9XG4gIG5hdDIuZGF0YVtvZnMyXSA9IHdyYXA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjb21wYXJlX2RpZ2l0c19uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfZGlnaXRzX25hdChuYXQxLCBvZnMxLCBuYXQyLCBvZnMyKSB7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA+IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIDE7XG4gIGlmKG5hdDEuZGF0YVtvZnMxXSA8IG5hdDIuZGF0YVtvZnMyXSkgcmV0dXJuIC0xO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRcbi8vUmVxdWlyZXM6IG51bV9kaWdpdHNfbmF0XG5mdW5jdGlvbiBjb21wYXJlX25hdChuYXQxLCBvZnMxLCBsZW4xLCBuYXQyLCBvZnMyLCBsZW4yKSB7XG4gIHZhciBhID0gbnVtX2RpZ2l0c19uYXQobmF0MSwgb2ZzMSwgbGVuMSk7XG4gIHZhciBiID0gbnVtX2RpZ2l0c19uYXQobmF0Miwgb2ZzMiwgbGVuMik7XG4gIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgaWYoYSA8IGIpIHJldHVybiAtMTtcbiAgZm9yKHZhciBpID0gbGVuMSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKChuYXQxLmRhdGFbb2ZzMStpXSA+Pj4gMCkgPiAobmF0Mi5kYXRhW29mczIraV0gPj4+IDApKSByZXR1cm4gMTtcbiAgICBpZiAoKG5hdDEuZGF0YVtvZnMxK2ldID4+PiAwKSA8IChuYXQyLmRhdGFbb2ZzMitpXSA+Pj4gMCkpIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY29tcGFyZV9uYXRfcmVhbFxuLy9SZXF1aXJlczogY29tcGFyZV9uYXRcbmZ1bmN0aW9uIGNvbXBhcmVfbmF0X3JlYWwobmF0MSxuYXQyKXtcbiAgcmV0dXJuIGNvbXBhcmVfbmF0KG5hdDEsMCxuYXQxLmRhdGEubGVuZ3RoLG5hdDIsMCxuYXQyLmRhdGEubGVuZ3RoKTtcbn1cblxuLy9Qcm92aWRlczogbGFuZF9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxhbmRfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdICY9IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGxvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGxvcl9kaWdpdF9uYXQobmF0MSwgb2ZzMSwgbmF0Miwgb2ZzMikge1xuICBuYXQxLmRhdGFbb2ZzMV0gfD0gbmF0Mi5kYXRhW29mczJdO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogbHhvcl9kaWdpdF9uYXRcbmZ1bmN0aW9uIGx4b3JfZGlnaXRfbmF0KG5hdDEsIG9mczEsIG5hdDIsIG9mczIpIHtcbiAgbmF0MS5kYXRhW29mczFdIF49IG5hdDIuZGF0YVtvZnMyXTtcbiAgcmV0dXJuIDA7XG59XG5cblxuLy9Qcm92aWRlczogc2VyaWFsaXplX25hdFxuZnVuY3Rpb24gc2VyaWFsaXplX25hdCh3cml0ZXIsIG5hdCwgc3ope1xuICB2YXIgbGVuID0gbmF0LmRhdGEubGVuZ3RoO1xuICB3cml0ZXIud3JpdGUoMzIsIGxlbik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgd3JpdGVyLndyaXRlKDMyLCBuYXQuZGF0YVtpXSk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICBzelsxXSA9IGxlbiAqIDg7XG59XG5cbi8vUHJvdmlkZXM6IGRlc2VyaWFsaXplX25hdFxuLy9SZXF1aXJlczogTWxOYXRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplX25hdChyZWFkZXIsIHN6KXtcbiAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIHZhciBuYXQgPSBuZXcgTWxOYXQobGVuKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBuYXQuZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIH1cbiAgc3pbMF0gPSBsZW4gKiA0O1xuICByZXR1cm4gbmF0O1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZVxudmFyIGNhbWxfZ3Jfc3RhdGU7XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX25hbWVkX3ZhbHVlLCBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2dldCgpIHtcbiAgaWYoY2FtbF9ncl9zdGF0ZSkge1xuICAgIHJldHVybiBjYW1sX2dyX3N0YXRlO1xuICB9XG4gIHRocm93IFswLGNhbWxfbmFtZWRfdmFsdWUoXCJHcmFwaGljcy5HcmFwaGljX2ZhaWx1cmVcIiksIGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJOb3QgaW5pdGlhbGl6ZWRcIildXG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3N0YXRlX3NldFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZSxjYW1sX2dyX3N0YXRlX2luaXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCkge1xuICBjYW1sX2dyX3N0YXRlPWN0eDtcbiAgY2FtbF9ncl9zdGF0ZV9pbml0KClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfc2V0XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9vcGVuX2dyYXBoKGluZm8pe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgaW5mbyA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKGluZm8pO1xuICBmdW5jdGlvbiBnZXQobmFtZSl7XG4gICAgdmFyIHJlcyA9IGluZm8ubWF0Y2goXCIoXnwsKSAqXCIrbmFtZStcIiAqPSAqKFthLXpBLVowLTlfXSspICooLHwkKVwiKTtcbiAgICBpZihyZXMpIHJldHVybiByZXNbMl07XG4gIH1cbiAgdmFyIHNwZWNzID0gW107XG4gIGlmKCEoaW5mbz09XCJcIikpIHNwZWNzLnB1c2goaW5mbyk7XG4gIHZhciB0YXJnZXQgPSBnZXQoXCJ0YXJnZXRcIik7XG4gIGlmKCF0YXJnZXQpIHRhcmdldD1cIlwiO1xuICB2YXIgc3RhdHVzID0gZ2V0KFwic3RhdHVzXCIpO1xuICBpZighc3RhdHVzKSBzcGVjcy5wdXNoKFwic3RhdHVzPTFcIilcblxuICB2YXIgdyA9IGdldChcIndpZHRoXCIpO1xuICB3ID0gdz9wYXJzZUludCh3KToyMDA7XG4gIHNwZWNzLnB1c2goXCJ3aWR0aD1cIit3KTtcblxuICB2YXIgaCA9IGdldChcImhlaWdodFwiKTtcbiAgaCA9IGg/cGFyc2VJbnQoaCk6MjAwO1xuICBzcGVjcy5wdXNoKFwiaGVpZ2h0PVwiK2gpO1xuXG4gIHZhciB3aW4gPSBnLm9wZW4oXCJhYm91dDpibGFua1wiLHRhcmdldCxzcGVjcy5qb2luKFwiLFwiKSk7XG4gIGlmKCF3aW4pIHtjYW1sX2ZhaWx3aXRoKFwiR3JhcGhpY3Mub3Blbl9ncmFwaDogY2Fubm90IG9wZW4gdGhlIHdpbmRvd1wiKX1cbiAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgdmFyIGNhbnZhcyA9IGRvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSB3O1xuICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgdmFyIGN0eCA9IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlKGNhbnZhcyx3LGgpO1xuICBjdHguc2V0X3RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgZG9jLnRpdGxlID0gdGl0bGU7XG4gIH07XG4gIGNhbWxfZ3Jfc3RhdGVfc2V0KGN0eCk7XG4gIHZhciBib2R5ID0gZG9jLmJvZHk7XG4gIGJvZHkuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zdGF0ZV9pbml0XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3NldF9jb2xvcixjYW1sX2dyX21vdmV0byxjYW1sX2dyX3Jlc2l6ZV93aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgsY2FtbF9ncl9zZXRfdGV4dF9zaXplLGNhbWxfZ3Jfc2V0X2ZvbnRcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc2V0X3dpbmRvd190aXRsZVxuZnVuY3Rpb24gY2FtbF9ncl9zdGF0ZV9pbml0KCl7XG4gIGNhbWxfZ3JfbW92ZXRvKGNhbWxfZ3Jfc3RhdGUueCxjYW1sX2dyX3N0YXRlLnkpO1xuICBjYW1sX2dyX3Jlc2l6ZV93aW5kb3coY2FtbF9ncl9zdGF0ZS53aWR0aCxjYW1sX2dyX3N0YXRlLmhlaWdodCk7XG4gIGNhbWxfZ3Jfc2V0X2xpbmVfd2lkdGgoY2FtbF9ncl9zdGF0ZS5saW5lX3dpZHRoKTtcbiAgY2FtbF9ncl9zZXRfdGV4dF9zaXplKGNhbWxfZ3Jfc3RhdGUudGV4dF9zaXplKTtcbiAgY2FtbF9ncl9zZXRfZm9udChjYW1sX2dyX3N0YXRlLmZvbnQpO1xuICBjYW1sX2dyX3NldF9jb2xvcihjYW1sX2dyX3N0YXRlLmNvbG9yKTtcbiAgY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKGNhbWxfZ3Jfc3RhdGUudGl0bGUpO1xuICAvL2NhbWxfZ3JfcmVzaXplX3dpbmRvdyBtaWdodCByZXNldCBzb21lIGNhbnZhcycgcHJvcGVydGllc1xuICBjYW1sX2dyX3N0YXRlLmNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc3RhdGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzXG5mdW5jdGlvbiBjYW1sX2dyX3N0YXRlX2NyZWF0ZShjYW52YXMsdyxoKXtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgY2FudmFzIDogY2FudmFzLFxuICAgIHggOiAwLFxuICAgIHkgOiAwLFxuICAgIHdpZHRoIDogdyxcbiAgICBoZWlnaHQgOiBoLFxuICAgIGxpbmVfd2lkdGggOiAxLFxuICAgIGZvbnQgOiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiZml4ZWRcIiksXG4gICAgdGV4dF9zaXplIDogMjYsXG4gICAgY29sb3IgOiAweDAwMDAwMCxcbiAgICB0aXRsZSA6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIilcbiAgfTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kb2Nfb2Zfc3RhdGVcbmZ1bmN0aW9uIGNhbWxfZ3JfZG9jX29mX3N0YXRlKHN0YXRlKSB7XG4gIGlmKHN0YXRlLmNhbnZhcy5vd25lckRvY3VtZW50KVxuICAgIHJldHVybiBzdGF0ZS5jYW52YXMub3duZXJEb2N1bWVudDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9jbG9zZV9ncmFwaFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY2xvc2VfZ3JhcGgoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNhbnZhcy53aWR0aCA9IDA7XG4gIHMuY2FudmFzLmhlaWdodCA9IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF93aW5kb3dfdGl0bGVcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9zZXRfd2luZG93X3RpdGxlKG5hbWUpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMudGl0bGUgPSBuYW1lO1xuICB2YXIganNuYW1lID0gY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcobmFtZSk7XG4gIGlmKHMuc2V0X3RpdGxlKSBzLnNldF90aXRsZShqc25hbWUpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9yZXNpemVfd2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9yZXNpemVfd2luZG93KHcsaCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKVxuICBzLndpZHRoID0gdztcbiAgcy5oZWlnaHQgPSBoO1xuICBzLmNhbnZhcy53aWR0aCA9IHc7XG4gIHMuY2FudmFzLmhlaWdodCA9IGg7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2NsZWFyX2dyYXBoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jbGVhcl9ncmFwaCgpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY2FudmFzLndpZHRoID0gcy53aWR0aDtcbiAgcy5jYW52YXMuaGVpZ2h0ID0gcy5oZWlnaHQ7XG4gIC8vICBzLmNvbnRleHQuc3Ryb2tlUmVjdCAoMC4sIDAuLCBzLndpZHRoLCBzLmhlaWdodCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV94KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMud2lkdGg7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NpemVfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3Jfc2l6ZV95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMuaGVpZ2h0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X2NvbG9yXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfY29sb3IoY29sb3Ipe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGZ1bmN0aW9uIGNvbnZlcnQobnVtYmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnICsgbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IDIpIHN0ciA9ICcwJyArIHN0cjtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHZhclxuICByID0gKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gIGcgPSAoY29sb3IgPj4gOCkgICYgMHhmZixcbiAgYiA9IChjb2xvciA+PiAwKSAgJiAweGZmO1xuICBzLmNvbG9yPWNvbG9yO1xuICB2YXIgY19zdHIgPSAnIycgKyBjb252ZXJ0KHIpICsgY29udmVydChnKSArIGNvbnZlcnQoYik7XG4gIHMuY29udGV4dC5maWxsU3R5bGUgPSAgIGNfc3RyO1xuICBzLmNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjX3N0cjtcbiAgcmV0dXJuIDA7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3Bsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3Bsb3QoeCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW09cy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSgxLDEpO1xuICB2YXIgZCA9IGltLmRhdGE7XG4gIHZhciBjb2xvciA9IHMuY29sb3I7XG4gIGRbMF0gPSAoY29sb3IgPj4gMTYpICYgMHhmZjsgLy9yXG4gIGRbMV0gPSAoY29sb3IgPj4gOCkgICYgMHhmZiwgLy9nXG4gIGRbMl0gPSAoY29sb3IgPj4gMCkgICYgMHhmZjsgLy9iXG4gIGRbM10gPSAweEZGOyAvL2FcbiAgcy54PXg7XG4gIHMueT15O1xuICBzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltLHgscy5oZWlnaHQgLSB5KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcG9pbnRfY29sb3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX3BvaW50X2NvbG9yKHgseSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGltPXMuY29udGV4dC5nZXRJbWFnZURhdGEoeCxzLmhlaWdodCAtIHksMSwxKTtcbiAgdmFyIGQgPSBpbS5kYXRhO1xuICByZXR1cm4gKGRbMF0gPDwgMTYpICsgKGRbMV0gPDwgOCkgKyBkWzJdO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9tb3ZldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX21vdmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMueD14O1xuICBzLnk9eTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY3VycmVudF94XG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9jdXJyZW50X3goKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICByZXR1cm4gcy54XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2N1cnJlbnRfeVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfY3VycmVudF95KCl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcmV0dXJuIHMueVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9saW5ldG9cbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2xpbmV0byh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcy5jb250ZXh0Lm1vdmVUbyhzLngscy5oZWlnaHQgLSBzLnkpO1xuICBzLmNvbnRleHQubGluZVRvKHgscy5oZWlnaHQgLSB5KTtcbiAgcy5jb250ZXh0LnN0cm9rZSgpO1xuICBzLng9eDtcbiAgcy55PXk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2RyYXdfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuc3Ryb2tlUmVjdCh4LHMuaGVpZ2h0IC0geSx3LC1oKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfYXJjX2F1eFxuZnVuY3Rpb24gY2FtbF9ncl9hcmNfYXV4KGN0eCxjeCxjeSxyeSxyeCxhMSxhMil7XG4gIHdoaWxlKGExPmEyKSBhMis9MzYwO1xuICBhMSAvPSAxODA7XG4gIGEyIC89IDE4MDtcbiAgdmFyIHJvdCA9IDAseFBvcyx5UG9zLHhQb3NfcHJldix5UG9zX3ByZXY7XG4gIHZhciBzcGFjZSA9IDI7XG4gIHZhciBudW0gPSAoKChhMiAtIGExKSAqIE1hdGguUEkgKiAoKHJ4K3J5KS8yKSkgLyBzcGFjZSkgfCAwO1xuICB2YXIgZGVsdGEgPSAoYTIgLSBhMSkgKiBNYXRoLlBJIC8gbnVtO1xuICB2YXIgaSA9IGExICogTWF0aC5QSTtcbiAgZm9yICh2YXIgaj0wO2o8PW51bTtqKyspe1xuICAgIHhQb3MgPSBjeCAtIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguc2luKHJvdCAqIE1hdGguUEkpICsgKHJ5ICogTWF0aC5jb3MoaSkpICogTWF0aC5jb3Mocm90ICogTWF0aC5QSSk7XG4gICAgeFBvcyA9IHhQb3MudG9GaXhlZCgyKTtcbiAgICB5UG9zID0gY3kgKyAocnkgKiBNYXRoLmNvcyhpKSkgKiBNYXRoLnNpbihyb3QgKiBNYXRoLlBJKSArIChyeCAqIE1hdGguc2luKGkpKSAqIE1hdGguY29zKHJvdCAqIE1hdGguUEkpO1xuICAgIHlQb3MgPSB5UG9zLnRvRml4ZWQoMik7XG4gICAgaWYgKGo9PTApIHtcbiAgICAgIGN0eC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgfSBlbHNlIGlmICh4UG9zX3ByZXYhPXhQb3MgfHwgeVBvc19wcmV2IT15UG9zKXtcbiAgICAgIGN0eC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgfVxuICAgIHhQb3NfcHJldj14UG9zO1xuICAgIHlQb3NfcHJldj15UG9zO1xuICAgIGktPSBkZWx0YTsvL2Njd1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuc3Ryb2tlKCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3NldF9saW5lX3dpZHRoXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9zZXRfbGluZV93aWR0aCh3KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmxpbmVfd2lkdGggPSB3O1xuICBzLmNvbnRleHQubGluZVdpZHRoID0gd1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3JlY3Rcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcmVjdCh4LHksdyxoKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuZmlsbFJlY3QoeCxzLmhlaWdodCAtIHksdywtaCk7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9maWxsX3BvbHlcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2ZpbGxfcG9seShhcil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICBzLmNvbnRleHQubW92ZVRvKGFyWzFdWzFdLHMuaGVpZ2h0IC0gYXJbMV1bMl0pO1xuICBmb3IodmFyIGkgPSAyOyBpIDwgYXIubGVuZ3RoOyBpKyspXG4gICAgcy5jb250ZXh0LmxpbmVUbyhhcltpXVsxXSxzLmhlaWdodCAtIGFyW2ldWzJdKTtcbiAgcy5jb250ZXh0LmxpbmVUbyhhclsxXVsxXSxzLmhlaWdodCAtIGFyWzFdWzJdKTtcbiAgcy5jb250ZXh0LmZpbGwoKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZmlsbF9hcmNcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0LCBjYW1sX2dyX2FyY19hdXhcbmZ1bmN0aW9uIGNhbWxfZ3JfZmlsbF9hcmMoeCx5LHJ4LHJ5LGExLGEyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICBzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIGNhbWxfZ3JfYXJjX2F1eChzLmNvbnRleHQseCxzLmhlaWdodCAtIHkscngscnksYTEsYTIpO1xuICBzLmNvbnRleHQuZmlsbCgpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9kcmF3X3N0clxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19zdHIoc3RyKXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgbSA9IHMuY29udGV4dC5tZWFzdXJlVGV4dChzdHIpO1xuICB2YXIgZHggPSBtLndpZHRoO1xuICBzLmNvbnRleHQuZmlsbFRleHQoc3RyLHMueCxzLmhlaWdodCAtIHMueSk7XG4gIHMueCArPSBkeCB8IDA7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfY2hhclxuLy9SZXF1aXJlczogY2FtbF9ncl9kcmF3X3N0clxuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X2NoYXIoYyl7XG4gIGNhbWxfZ3JfZHJhd19zdHIoU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2RyYXdfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2dyX2RyYXdfc3RyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9ncl9kcmF3X3N0cmluZyhzdHIpe1xuICBjYW1sX2dyX2RyYXdfc3RyKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHN0cikpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zZXRfZm9udFxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF9mb250KGYpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHMuZm9udCA9IGY7XG4gIHMuY29udGV4dC5mb250ID0gcy50ZXh0X3NpemUgKyBcInB4IFwiICsgY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocy5mb250KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2V0X3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3NldF90ZXh0X3NpemUoc2l6ZSl7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgcy50ZXh0X3NpemUgPSBzaXplO1xuICBzLmNvbnRleHQuZm9udCA9IHMudGV4dF9zaXplICsgXCJweCBcIiArIGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMuZm9udCk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2dyX3RleHRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2dyX3RleHRfc2l6ZSh0eHQpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHZhciB3ID0gcy5jb250ZXh0Lm1lYXN1cmVUZXh0KGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHR4dCkpLndpZHRoO1xuICByZXR1cm4gWzAsdyxzLnRleHRfc2l6ZV07XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9ncl9tYWtlX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9tYWtlX2ltYWdlKGFycil7XG4gIHZhciBzID0gY2FtbF9ncl9zdGF0ZV9nZXQoKTtcbiAgdmFyIGggPSBhcnIubGVuZ3RoIC0gMSA7XG4gIHZhciB3ID0gYXJyWzFdLmxlbmd0aCAtIDE7XG4gIHZhciBpbSA9IHMuY29udGV4dC5jcmVhdGVJbWFnZURhdGEodyxoKTtcbiAgZm9yKHZhciBpPTA7aTxoO2krKyl7XG4gICAgZm9yKHZhciBqPTA7ajx3O2orKyl7XG4gICAgICB2YXIgYyA9IGFycltpKzFdW2orMV07XG4gICAgICB2YXIgbyA9IGkqKHcqNCkgKyAoaiAqIDQpO1xuICAgICAgaWYoYyA9PSAtMSkge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IDA7XG4gICAgICAgIGltLmRhdGFbbyArIDFdID0gMDtcbiAgICAgICAgaW0uZGF0YVtvICsgMl0gPSAwO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbS5kYXRhW28gKyAwXSA9IGMgPj4gMTYgJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAxXSA9IGMgPj4gIDggJiAweGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAyXSA9IGMgPj4gIDAgJiAwWGZmO1xuICAgICAgICBpbS5kYXRhW28gKyAzXSA9IDB4ZmY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbVxufVxuLy9Qcm92aWRlczogY2FtbF9ncl9kdW1wX2ltYWdlXG4vL1JlcXVpcmVzOiBjYW1sX2dyX3N0YXRlX2dldFxuZnVuY3Rpb24gY2FtbF9ncl9kdW1wX2ltYWdlKGltKXtcbiAgdmFyIGRhdGEgPSBbMF1cbiAgZm9yKHZhciBpPTA7IGk8aW0uaGVpZ2h0O2krKyl7XG4gICAgZGF0YVtpKzFdID0gWzBdXG4gICAgZm9yKHZhciBqPTA7IGo8aW0ud2lkdGg7aisrKXtcbiAgICAgIHZhciBvID0gaSooaW0ud2lkdGgqNCkgKyAoaiAqIDQpLFxuICAgICAgICAgIHIgPSBpbS5kYXRhW28rMF0sXG4gICAgICAgICAgZyA9IGltLmRhdGFbbysxXSxcbiAgICAgICAgICBiID0gaW0uZGF0YVtvKzJdO1xuICAgICAgZGF0YVtpKzFdW2orMV0gPSAociA8PCAxNikgKyAoZyA8PCA4KSArIGJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfZHJhd19pbWFnZVxuLy9SZXF1aXJlczogY2FtbF9ncl9zdGF0ZV9nZXRcbmZ1bmN0aW9uIGNhbWxfZ3JfZHJhd19pbWFnZShpbSx4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIGlmKCFpbS5pbWFnZSkge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IHMud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHMuaGVpZ2h0O1xuICAgIGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikucHV0SW1hZ2VEYXRhKGltLDAsMCk7XG4gICAgdmFyIGltYWdlID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkltYWdlKCk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSx4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSk7XG4gICAgICBpbS5pbWFnZSA9IGltYWdlO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBjYW52YXMudG9EYXRhVVJMKFwiaW1hZ2UvcG5nXCIpO1xuICB9IGVsc2Uge1xuICAgIHMuY29udGV4dC5kcmF3SW1hZ2UoaW0uaW1hZ2UseCxzLmhlaWdodCAtIGltLmhlaWdodCAtIHkpO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9jcmVhdGVfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2NyZWF0ZV9pbWFnZSh4LHkpe1xuICB2YXIgcyA9IGNhbWxfZ3Jfc3RhdGVfZ2V0KCk7XG4gIHJldHVybiBzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKHgseSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2JsaXRfaW1hZ2Vcbi8vUmVxdWlyZXM6IGNhbWxfZ3Jfc3RhdGVfZ2V0XG5mdW5jdGlvbiBjYW1sX2dyX2JsaXRfaW1hZ2UoaW0seCx5KXtcbiAgdmFyIHMgPSBjYW1sX2dyX3N0YXRlX2dldCgpO1xuICB2YXIgaW0yID0gcy5jb250ZXh0LmdldEltYWdlRGF0YSh4LHMuaGVpZ2h0IC0gaW0uaGVpZ2h0IC0geSxpbS53aWR0aCxpbS5oZWlnaHQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGltMi5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgaW0uZGF0YVtpXSA9IGltMi5kYXRhW2ldO1xuICAgIGltLmRhdGFbaSsxXSA9IGltMi5kYXRhW2krMV07XG4gICAgaW0uZGF0YVtpKzJdID0gaW0yLmRhdGFbaSsyXTtcbiAgICBpbS5kYXRhW2krM10gPSBpbTIuZGF0YVtpKzNdO1xuICB9XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF9ncl9zaWdpb19oYW5kbGVyXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX2hhbmRsZXIoKXtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfc2lnaW9fc2lnbmFsXG5mdW5jdGlvbiBjYW1sX2dyX3NpZ2lvX3NpZ25hbCgpe3JldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9ncl93YWl0X2V2ZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dhaXRfZXZlbnQoX2V2bCl7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dhaXRfZXZlbnQgbm90IEltcGxlbWVudGVkOiB1c2UgR3JhcGhpY3NfanMgaW5zdGVhZFwiKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ncl9zeW5jaHJvbml6ZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9zeW5jaHJvbml6ZSAoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3N5bmNocm9uaXplIG5vdCBJbXBsZW1lbnRlZFwiKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfcmVtZW1iZXJfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9yZW1lbWJlcl9tb2RlICgpIHtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfZ3JfcmVtZW1iZXJfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2dyX2Rpc3BsYXlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9ncl9kaXNwbGF5X21vZGUoKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Rpc3BsYXlfbW9kZSBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfd2luZG93X2lkXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX3dpbmRvd19pZChhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX3dpbmRvd19pZCBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3dcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfZ3Jfb3Blbl9zdWJ3aW5kb3coYSxiLGMsZCkge1xuICBjYW1sX2ZhaWx3aXRoKFwiY2FtbF9ncl9vcGVuX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ3JfY2xvc2Vfc3Vid2luZG93XG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG5mdW5jdGlvbiBjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyhhKSB7XG4gIGNhbWxfZmFpbHdpdGgoXCJjYW1sX2dyX2Nsb3NlX3N1YndpbmRvdyBub3QgSW1wbGVtZW50ZWRcIik7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tYXJzaGFsX2NvbnN0YW50c1xudmFyIGNhbWxfbWFyc2hhbF9jb25zdGFudHMgPSB7XG4gIFBSRUZJWF9TTUFMTF9CTE9DSzogICAgICAgICAweDgwLFxuICBQUkVGSVhfU01BTExfSU5UOiAgICAgICAgICAgMHg0MCxcbiAgUFJFRklYX1NNQUxMX1NUUklORzogICAgICAgIDB4MjAsXG4gIENPREVfSU5UODogICAgICAgICAgICAgICAgICAweDAwLFxuICBDT0RFX0lOVDE2OiAgICAgICAgICAgICAgICAgMHgwMSxcbiAgQ09ERV9JTlQzMjogICAgICAgICAgICAgICAgIDB4MDIsXG4gIENPREVfSU5UNjQ6ICAgICAgICAgICAgICAgICAweDAzLFxuICBDT0RFX1NIQVJFRDg6ICAgICAgICAgICAgICAgMHgwNCxcbiAgQ09ERV9TSEFSRUQxNjogICAgICAgICAgICAgIDB4MDUsXG4gIENPREVfU0hBUkVEMzI6ICAgICAgICAgICAgICAweDA2LFxuICBDT0RFX0JMT0NLMzI6ICAgICAgICAgICAgICAgMHgwOCxcbiAgQ09ERV9CTE9DSzY0OiAgICAgICAgICAgICAgIDB4MTMsXG4gIENPREVfU1RSSU5HODogICAgICAgICAgICAgICAweDA5LFxuICBDT0RFX1NUUklORzMyOiAgICAgICAgICAgICAgMHgwQSxcbiAgQ09ERV9ET1VCTEVfQklHOiAgICAgICAgICAgIDB4MEIsXG4gIENPREVfRE9VQkxFX0xJVFRMRTogICAgICAgICAweDBDLFxuICBDT0RFX0RPVUJMRV9BUlJBWThfQklHOiAgICAgMHgwRCxcbiAgQ09ERV9ET1VCTEVfQVJSQVk4X0xJVFRMRTogIDB4MEUsXG4gIENPREVfRE9VQkxFX0FSUkFZMzJfQklHOiAgICAweDBGLFxuICBDT0RFX0RPVUJMRV9BUlJBWTMyX0xJVFRMRTogMHgwNyxcbiAgQ09ERV9DT0RFUE9JTlRFUjogICAgICAgICAgIDB4MTAsXG4gIENPREVfSU5GSVhQT0lOVEVSOiAgICAgICAgICAweDExLFxuICBDT0RFX0NVU1RPTTogICAgICAgICAgICAgICAgMHgxMixcbiAgQ09ERV9DVVNUT01fTEVOOiAgICAgICAgICAgIDB4MTgsXG4gIENPREVfQ1VTVE9NX0ZJWEVEOiAgICAgICAgICAweDE5XG59XG5cblxuLy9Qcm92aWRlczogTWxTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIE1sU3RyaW5nUmVhZGVyIChzLCBpKSB7IHRoaXMucyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7IHRoaXMuaSA9IGk7IH1cbk1sU3RyaW5nUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgcmVhZDh1OmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKTsgfSxcbiAgcmVhZDhzOmZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucy5jaGFyQ29kZUF0KHRoaXMuaSsrKSA8PCAyNCA+PiAyNDsgfSxcbiAgcmVhZDE2dTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSArIDEpXG4gIH0sXG4gIHJlYWQxNnM6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyAyO1xuICAgIHJldHVybiAocy5jaGFyQ29kZUF0KGkpIDw8IDI0ID4+IDE2KSB8IHMuY2hhckNvZGVBdChpICsgMSk7XG4gIH0sXG4gIHJlYWQzMnU6ZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gdGhpcy5zLCBpID0gdGhpcy5pO1xuICAgIHRoaXMuaSA9IGkgKyA0O1xuICAgIHJldHVybiAoKHMuY2hhckNvZGVBdChpKSA8PCAyNCkgfCAocy5jaGFyQ29kZUF0KGkrMSkgPDwgMTYpIHxcbiAgICAgICAgICAgIChzLmNoYXJDb2RlQXQoaSsyKSA8PCA4KSB8IHMuY2hhckNvZGVBdChpKzMpKSA+Pj4gMDtcbiAgfSxcbiAgcmVhZDMyczpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuIChzLmNoYXJDb2RlQXQoaSkgPDwgMjQpIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDE2KSB8XG4gICAgICAocy5jaGFyQ29kZUF0KGkrMikgPDwgOCkgfCBzLmNoYXJDb2RlQXQoaSszKTtcbiAgfSxcbiAgcmVhZHN0cjpmdW5jdGlvbiAobGVuKSB7XG4gICAgdmFyIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIGxlbjtcbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyh0aGlzLnMuc3Vic3RyaW5nKGksIGkgKyBsZW4pKTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBCaWdTdHJpbmdSZWFkZXJcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5LCBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBCaWdTdHJpbmdSZWFkZXIgKGJzLCBpKSB7IHRoaXMucyA9IGJzOyB0aGlzLmkgPSBpOyB9XG5CaWdTdHJpbmdSZWFkZXIucHJvdG90eXBlID0ge1xuICByZWFkOHU6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspOyB9LFxuICByZWFkOHM6ZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FtbF9iYV9nZXRfMSh0aGlzLnMsdGhpcy5pKyspIDw8IDI0ID4+IDI0OyB9LFxuICByZWFkMTZ1OmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgMjtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSA8PCA4KSB8IGNhbWxfYmFfZ2V0XzEocyxpICsgMSlcbiAgfSxcbiAgcmVhZDE2czpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDI7XG4gICAgcmV0dXJuIChjYW1sX2JhX2dldF8xKHMsaSkgPDwgMjQgPj4gMTYpIHwgY2FtbF9iYV9nZXRfMShzLGkgKyAxKTtcbiAgfSxcbiAgcmVhZDMydTpmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHMgPSB0aGlzLnMsIGkgPSB0aGlzLmk7XG4gICAgdGhpcy5pID0gaSArIDQ7XG4gICAgcmV0dXJuICgoY2FtbF9iYV9nZXRfMShzLGkpICAgPDwgMjQpIHwgKGNhbWxfYmFfZ2V0XzEocyxpKzEpIDw8IDE2KSB8XG4gICAgICAgICAgICAoY2FtbF9iYV9nZXRfMShzLGkrMikgPDwgOCkgIHwgY2FtbF9iYV9nZXRfMShzLGkrMykgICAgICAgICApID4+PiAwO1xuICB9LFxuICByZWFkMzJzOmZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcyA9IHRoaXMucywgaSA9IHRoaXMuaTtcbiAgICB0aGlzLmkgPSBpICsgNDtcbiAgICByZXR1cm4gKGNhbWxfYmFfZ2V0XzEocyxpKSAgIDw8IDI0KSB8IChjYW1sX2JhX2dldF8xKHMsaSsxKSA8PCAxNikgfFxuICAgICAgKGNhbWxfYmFfZ2V0XzEocyxpKzIpIDw8IDgpICB8IGNhbWxfYmFfZ2V0XzEocyxpKzMpO1xuICB9LFxuICByZWFkc3RyOmZ1bmN0aW9uIChsZW4pIHtcbiAgICB2YXIgaSA9IHRoaXMuaTtcbiAgICB2YXIgYXJyID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspe1xuICAgICAgYXJyW2pdID0gY2FtbF9iYV9nZXRfMSh0aGlzLnMsIGkraik7XG4gICAgfVxuICAgIHRoaXMuaSA9IGkgKyBsZW47XG4gICAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIH1cbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0cywgY2FtbF9pbnQ2NF9vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9mbG9hdF9vZl9ieXRlcyAoYSkge1xuICByZXR1cm4gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzIChjYW1sX2ludDY0X29mX2J5dGVzIChhKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcgbXV0YWJsZVxuLy9SZXF1aXJlczogTWxTdHJpbmdSZWFkZXIsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXJcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9zdHJpbmcocyxvZnMpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBNbFN0cmluZ1JlYWRlciAocywgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyBtdXRhYmxlXG4vL1JlcXVpcmVzOiBNbFN0cmluZ1JlYWRlciwgY2FtbF9pbnB1dF92YWx1ZV9mcm9tX3JlYWRlciwgY2FtbF9zdHJpbmdfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcyhzLG9mcykge1xuICB2YXIgcmVhZGVyID0gbmV3IE1sU3RyaW5nUmVhZGVyIChjYW1sX3N0cmluZ19vZl9ieXRlcyhzKSwgdHlwZW9mIG9mcz09XCJudW1iZXJcIj9vZnM6b2ZzWzBdKTtcbiAgcmV0dXJuIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9yZWFkZXIocmVhZGVyLCBvZnMpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfdW5tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgc2l6ZVswXSA9IDg7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzICh0KTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9pbnQ2NF9tYXJzaGFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2ludDY0X21hcnNoYWwod3JpdGVyLCB2LCBzaXplcykge1xuICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMgKHYpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykgd3JpdGVyLndyaXRlICg4LCBiW2ldKTtcbiAgc2l6ZXNbMF0gPSA4OyBzaXplc1sxXSA9IDg7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50MzJfdW5tYXJzaGFsXG5mdW5jdGlvbiBjYW1sX2ludDMyX3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzaXplWzBdID0gNDtcbiAgcmV0dXJuIHJlYWRlci5yZWFkMzJzICgpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWxcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbChyZWFkZXIsIHNpemUpe1xuICBzd2l0Y2ggKHJlYWRlci5yZWFkOHUgKCkpIHtcbiAgY2FzZSAxOlxuICAgIHNpemVbMF0gPSA0O1xuICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgY2FzZSAyOlxuICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogbmF0aXZlIGludGVnZXIgdmFsdWUgdG9vIGxhcmdlXCIpO1xuICBkZWZhdWx0OiBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGlsbC1mb3JtZWQgbmF0aXZlIGludGVnZXJcIik7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3VubWFyc2hhbCwgY2FtbF9pbnQ2NF9tYXJzaGFsLCBjYW1sX2ludDY0X2NvbXBhcmUsIGNhbWxfaW50NjRfaGFzaFxuLy9SZXF1aXJlczogY2FtbF9pbnQzMl91bm1hcnNoYWwsIGNhbWxfbmF0aXZlaW50X3VubWFyc2hhbFxuLy9SZXF1aXJlczogY2FtbF9iYV9zZXJpYWxpemUsIGNhbWxfYmFfZGVzZXJpYWxpemUsIGNhbWxfYmFfY29tcGFyZSwgY2FtbF9iYV9oYXNoXG52YXIgY2FtbF9jdXN0b21fb3BzID1cbiAgICB7XCJfalwiOiB7XG4gICAgICBkZXNlcmlhbGl6ZSA6IGNhbWxfaW50NjRfdW5tYXJzaGFsLFxuICAgICAgc2VyaWFsaXplICA6IGNhbWxfaW50NjRfbWFyc2hhbCxcbiAgICAgIGZpeGVkX2xlbmd0aCA6IDgsXG4gICAgICBjb21wYXJlIDogY2FtbF9pbnQ2NF9jb21wYXJlLFxuICAgICAgaGFzaCA6IGNhbWxfaW50NjRfaGFzaFxuICAgIH0sXG4gICAgIFwiX2lcIjoge1xuICAgICAgIGRlc2VyaWFsaXplIDogY2FtbF9pbnQzMl91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfblwiOiB7XG4gICAgICAgZGVzZXJpYWxpemUgOiBjYW1sX25hdGl2ZWludF91bm1hcnNoYWwsXG4gICAgICAgZml4ZWRfbGVuZ3RoIDogNCxcbiAgICAgfSxcbiAgICAgXCJfYmlnYXJyYXlcIjp7XG4gICAgICAgZGVzZXJpYWxpemUgOiAoZnVuY3Rpb24gKHJlYWRlciwgc3opIHtyZXR1cm4gY2FtbF9iYV9kZXNlcmlhbGl6ZSAocmVhZGVyLHN6LFwiX2JpZ2FycmF5XCIpfSksXG4gICAgICAgc2VyaWFsaXplIDogY2FtbF9iYV9zZXJpYWxpemUsXG4gICAgICAgY29tcGFyZSA6IGNhbWxfYmFfY29tcGFyZSxcbiAgICAgICBoYXNoOiBjYW1sX2JhX2hhc2gsXG4gICAgIH0sXG4gICAgIFwiX2JpZ2FycjAyXCI6e1xuICAgICAgIGRlc2VyaWFsaXplIDogKGZ1bmN0aW9uIChyZWFkZXIsIHN6KSB7cmV0dXJuIGNhbWxfYmFfZGVzZXJpYWxpemUgKHJlYWRlcixzeixcIl9iaWdhcnIwMlwiKX0pLFxuICAgICAgIHNlcmlhbGl6ZSA6IGNhbWxfYmFfc2VyaWFsaXplLFxuICAgICAgIGNvbXBhcmUgOiBjYW1sX2JhX2NvbXBhcmUsXG4gICAgICAgaGFzaDogY2FtbF9iYV9oYXNoLFxuICAgICB9XG4gICAgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfZmxvYXRfb2ZfYnl0ZXMsIGNhbWxfY3VzdG9tX29wc1xuXG5mdW5jdGlvbiBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fcmVhZGVyKHJlYWRlciwgb2ZzKSB7XG4gIHZhciBfbWFnaWMgPSByZWFkZXIucmVhZDMydSAoKVxuICB2YXIgX2Jsb2NrX2xlbiA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgbnVtX29iamVjdHMgPSByZWFkZXIucmVhZDMydSAoKTtcbiAgdmFyIF9zaXplXzMyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gIHZhciBfc2l6ZV82NCA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGludGVybl9vYmpfdGFibGUgPSAobnVtX29iamVjdHMgPiAwKT9bXTpudWxsO1xuICB2YXIgb2JqX2NvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBpbnRlcm5fcmVjICgpIHtcbiAgICB2YXIgY29kZSA9IHJlYWRlci5yZWFkOHUgKCk7XG4gICAgaWYgKGNvZGUgPj0gMHg0MCAvKmNzdC5QUkVGSVhfU01BTExfSU5UKi8pIHtcbiAgICAgIGlmIChjb2RlID49IDB4ODAgLypjc3QuUFJFRklYX1NNQUxMX0JMT0NLKi8pIHtcbiAgICAgICAgdmFyIHRhZyA9IGNvZGUgJiAweEY7XG4gICAgICAgIHZhciBzaXplID0gKGNvZGUgPj4gNCkgJiAweDc7XG4gICAgICAgIHZhciB2ID0gW3RhZ107XG4gICAgICAgIGlmIChzaXplID09IDApIHJldHVybiB2O1xuICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgIHN0YWNrLnB1c2godiwgc2l6ZSk7XG4gICAgICAgIHJldHVybiB2O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAoY29kZSAmIDB4M0YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29kZSA+PSAweDIwLypjc3QuUFJFRklYX1NNQUxMX1NUUklORyAqLykge1xuICAgICAgICB2YXIgbGVuID0gY29kZSAmIDB4MUY7XG4gICAgICAgIHZhciB2ID0gcmVhZGVyLnJlYWRzdHIgKGxlbik7XG4gICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2goY29kZSkge1xuICAgICAgICBjYXNlIDB4MDA6IC8vY3N0LkNPREVfSU5UODpcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQ4cyAoKTtcbiAgICAgICAgY2FzZSAweDAxOiAvL2NzdC5DT0RFX0lOVDE2OlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDE2cyAoKTtcbiAgICAgICAgY2FzZSAweDAyOiAvL2NzdC5DT0RFX0lOVDMyOlxuICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZDMycyAoKTtcbiAgICAgICAgY2FzZSAweDAzOiAvL2NzdC5DT0RFX0lOVDY0OlxuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJpbnB1dF92YWx1ZTogaW50ZWdlciB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwNDogLy9jc3QuQ09ERV9TSEFSRUQ4OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHJldHVybiBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyIC0gb2Zmc2V0XTtcbiAgICAgICAgY2FzZSAweDA1OiAvL2NzdC5DT0RFX1NIQVJFRDE2OlxuICAgICAgICAgIHZhciBvZmZzZXQgPSByZWFkZXIucmVhZDE2dSAoKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlciAtIG9mZnNldF07XG4gICAgICAgIGNhc2UgMHgwNjogLy9jc3QuQ09ERV9TSEFSRUQzMjpcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgcmV0dXJuIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIgLSBvZmZzZXRdO1xuICAgICAgICBjYXNlIDB4MDg6IC8vY3N0LkNPREVfQkxPQ0szMjpcbiAgICAgICAgICB2YXIgaGVhZGVyID0gcmVhZGVyLnJlYWQzMnUgKCk7XG4gICAgICAgICAgdmFyIHRhZyA9IGhlYWRlciAmIDB4RkY7XG4gICAgICAgICAgdmFyIHNpemUgPSBoZWFkZXIgPj4gMTA7XG4gICAgICAgICAgdmFyIHYgPSBbdGFnXTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSAwKSByZXR1cm4gdjtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDEzOiAvL2NzdC5DT0RFX0JMT0NLNjQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogZGF0YSBibG9jayB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgwOTogLy9jc3QuQ09ERV9TVFJJTkc4OlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSByZWFkZXIucmVhZHN0ciAobGVuKTtcbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwQTogLy9jc3QuQ09ERV9TVFJJTkczMjpcbiAgICAgICAgICB2YXIgbGVuID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgICB2YXIgdiA9IHJlYWRlci5yZWFkc3RyIChsZW4pO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBDOiAvL2NzdC5DT0RFX0RPVUJMRV9MSVRUTEU6XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCA4O2krKykgdFs3IC0gaV0gPSByZWFkZXIucmVhZDh1ICgpO1xuICAgICAgICAgIHZhciB2ID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEI6IC8vY3N0LkNPREVfRE9VQkxFX0JJRzpcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IDg7aSsrKSB0W2ldID0gcmVhZGVyLnJlYWQ4dSAoKTtcbiAgICAgICAgICB2YXIgdiA9IGNhbWxfZmxvYXRfb2ZfYnl0ZXMgKHQpO1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY2FzZSAweDBFOiAvL2NzdC5DT0RFX0RPVUJMRV9BUlJBWThfTElUVExFOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgICAgICAgIGlmIChpbnRlcm5fb2JqX3RhYmxlKSBpbnRlcm5fb2JqX3RhYmxlW29ial9jb3VudGVyKytdID0gdjtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEQ6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZOF9CSUc6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICB2YXIgdiA9IG5ldyBBcnJheShsZW4rMSk7XG4gICAgICAgICAgdlswXSA9IDI1NDtcbiAgICAgICAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxO2kgPD0gbGVuO2krKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgICAgICAgdiBbaV0gPSBjYW1sX2Zsb2F0X29mX2J5dGVzICh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNhc2UgMHgwNzogLy9jc3QuQ09ERV9ET1VCTEVfQVJSQVkzMl9MSVRUTEU6XG4gICAgICAgICAgdmFyIGxlbiA9IHJlYWRlci5yZWFkMzJ1KCk7XG4gICAgICAgICAgdmFyIHYgPSBuZXcgQXJyYXkobGVuKzEpO1xuICAgICAgICAgIHZbMF0gPSAyNTQ7XG4gICAgICAgICAgaWYgKGludGVybl9vYmpfdGFibGUpIGludGVybl9vYmpfdGFibGVbb2JqX2NvdW50ZXIrK10gPSB2O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFs3IC0gal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICAgICAgICB2W2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MEY6IC8vY3N0LkNPREVfRE9VQkxFX0FSUkFZMzJfQklHOlxuICAgICAgICAgIHZhciBsZW4gPSByZWFkZXIucmVhZDMydSgpO1xuICAgICAgICAgIHZhciB2ID0gbmV3IEFycmF5KGxlbisxKTtcbiAgICAgICAgICB2WzBdID0gMjU0O1xuICAgICAgICAgIHZhciB0ID0gbmV3IEFycmF5KDgpOztcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTtpIDw9IGxlbjtpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwO2ogPCA4O2orKykgdFtqXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICAgICAgICAgIHYgW2ldID0gY2FtbF9mbG9hdF9vZl9ieXRlcyAodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICBjYXNlIDB4MTA6IC8vY3N0LkNPREVfQ09ERVBPSU5URVI6XG4gICAgICAgIGNhc2UgMHgxMTogLy9jc3QuQ09ERV9JTkZJWFBPSU5URVI6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogY29kZSBwb2ludGVyXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTI6IC8vY3N0LkNPREVfQ1VTVE9NOlxuICAgICAgICBjYXNlIDB4MTg6IC8vY3N0LkNPREVfQ1VTVE9NX0xFTjpcbiAgICAgICAgY2FzZSAweDE5OiAvL2NzdC5DT0RFX0NVU1RPTV9GSVhFRDpcbiAgICAgICAgICB2YXIgYywgcyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKChjID0gcmVhZGVyLnJlYWQ4dSAoKSkgIT0gMCkgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjKTtcbiAgICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW3NdO1xuICAgICAgICAgIHZhciBleHBlY3RlZF9zaXplO1xuICAgICAgICAgIGlmKCFvcHMpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHVua25vd24gY3VzdG9tIGJsb2NrIGlkZW50aWZpZXJcIik7XG4gICAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgIGNhc2UgMHgxMjogLy8gY3N0LkNPREVfQ1VTVE9NIChkZXByZWNhdGVkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAweDE5OiAvLyBjc3QuQ09ERV9DVVNUT01fRklYRURcbiAgICAgICAgICAgIGlmKCFvcHMuZml4ZWRfbGVuZ3RoKVxuICAgICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGV4cGVjdGVkIGEgZml4ZWQtc2l6ZSBjdXN0b20gYmxvY2tcIik7XG4gICAgICAgICAgICBleHBlY3RlZF9zaXplID0gb3BzLmZpeGVkX2xlbmd0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMHgxODogLy8gY3N0LkNPREVfQ1VTVE9NX0xFTlxuICAgICAgICAgICAgZXhwZWN0ZWRfc2l6ZSA9IHJlYWRlci5yZWFkMzJ1ICgpO1xuICAgICAgICAgICAgLy8gU2tpcCBzaXplNjRcbiAgICAgICAgICAgIHJlYWRlci5yZWFkMzJzKCk7IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9sZF9wb3MgPSByZWFkZXIuaTtcbiAgICAgICAgICB2YXIgc2l6ZSA9IFswXTtcbiAgICAgICAgICB2YXIgdiA9IG9wcy5kZXNlcmlhbGl6ZShyZWFkZXIsIHNpemUpO1xuICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGlmKGV4cGVjdGVkX3NpemUgIT0gc2l6ZVswXSlcbiAgICAgICAgICAgICAgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBpbmNvcnJlY3QgbGVuZ3RoIG9mIHNlcmlhbGl6ZWQgY3VzdG9tIGJsb2NrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZXJuX29ial90YWJsZSkgaW50ZXJuX29ial90YWJsZVtvYmpfY291bnRlcisrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FtbF9mYWlsd2l0aCAoXCJpbnB1dF92YWx1ZTogaWxsLWZvcm1lZCBtZXNzYWdlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciByZXMgPSBpbnRlcm5fcmVjICgpO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBzaXplID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZCA9IHYubGVuZ3RoO1xuICAgIGlmIChkIDwgc2l6ZSkgc3RhY2sucHVzaCh2LCBzaXplKTtcbiAgICB2W2RdID0gaW50ZXJuX3JlYyAoKTtcbiAgfVxuICBpZiAodHlwZW9mIG9mcyE9XCJudW1iZXJcIikgb2ZzWzBdID0gcmVhZGVyLmk7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9ieXRlc191bnNhZmVfZ2V0XG5mdW5jdGlvbiBjYW1sX21hcnNoYWxfZGF0YV9zaXplIChzLCBvZnMpIHtcbiAgZnVuY3Rpb24gZ2V0MzIocyxpKSB7XG4gICAgcmV0dXJuIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSkgPDwgMjQpIHxcbiAgICAgIChjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDEpIDw8IDE2KSB8XG4gICAgICAoY2FtbF9ieXRlc191bnNhZmVfZ2V0KHMsIGkgKyAyKSA8PCA4KSB8XG4gICAgICBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQocywgaSArIDMpO1xuICB9XG4gIGlmIChnZXQzMihzLCBvZnMpICE9ICgweDg0OTVBNkJFfDApKVxuICAgIGNhbWxfZmFpbHdpdGgoXCJNYXJzaGFsLmRhdGFfc2l6ZTogYmFkIG9iamVjdFwiKTtcbiAgcmV0dXJuIChnZXQzMihzLCBvZnMgKyA0KSk7XG59XG5cbi8vUHJvdmlkZXM6IE1sT2JqZWN0VGFibGVcbnZhciBNbE9iamVjdFRhYmxlO1xuaWYgKHR5cGVvZiBqb29fZ2xvYmFsX29iamVjdC5XZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLyogcG9seWZpbGwgKHVzaW5nIGxpbmVhciBzZWFyY2gpICovXG4gICAgZnVuY3Rpb24gTmFpdmVMb29rdXAob2JqcykgeyB0aGlzLm9ianMgPSBvYmpzOyB9XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm9ianNbaV0gPT09IHYpIHJldHVybiBpO1xuICAgICAgfVxuICAgIH07XG4gICAgTmFpdmVMb29rdXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gRG8gbm90aGluZyBoZXJlLiBbTWxPYmplY3RUYWJsZS5zdG9yZV0gd2lsbCBwdXNoIHRvIFt0aGlzLm9ianNdIGRpcmVjdGx5LlxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICAgIHRoaXMub2JqcyA9IFtdOyB0aGlzLmxvb2t1cCA9IG5ldyBOYWl2ZUxvb2t1cCh0aGlzLm9ianMpO1xuICAgIH07XG4gIH0oKTtcbn1cbmVsc2Uge1xuICBNbE9iamVjdFRhYmxlID0gZnVuY3Rpb24gTWxPYmplY3RUYWJsZSgpIHtcbiAgICB0aGlzLm9ianMgPSBbXTsgdGhpcy5sb29rdXAgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuV2Vha01hcCgpO1xuICB9O1xufVxuXG5NbE9iamVjdFRhYmxlLnByb3RvdHlwZS5zdG9yZSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5sb29rdXAuc2V0KHYsIHRoaXMub2Jqcy5sZW5ndGgpO1xuICB0aGlzLm9ianMucHVzaCh2KTtcbn1cblxuTWxPYmplY3RUYWJsZS5wcm90b3R5cGUucmVjYWxsID0gZnVuY3Rpb24odikge1xuICB2YXIgaSA9IHRoaXMubG9va3VwLmdldCh2KTtcbiAgcmV0dXJuIChpID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWQgOiB0aGlzLm9ianMubGVuZ3RoIC0gaTsgICAvKiBpbmRleCBpcyByZWxhdGl2ZSAqL1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA+PSA0LjA4XG52YXIgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUgPSBmYWxzZVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZVxuLy9WZXJzaW9uOiA8IDQuMDhcbnZhciBjYW1sX2xlZ2FjeV9jdXN0b21fY29kZSA9IHRydWVcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2J5dGVzLCBjYW1sX2ZhaWx3aXRoXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfYnl0ZXMsIGNhbWxfbWxfYnl0ZXNfbGVuZ3RoLCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfaXNfbWxfc3RyaW5nLCBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IE1sT2JqZWN0VGFibGUsIGNhbWxfbGlzdF90b19qc19hcnJheSwgY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUsIGNhbWxfY3VzdG9tX29wc1xuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbnZhciBjYW1sX291dHB1dF92YWwgPSBmdW5jdGlvbiAoKXtcbiAgZnVuY3Rpb24gV3JpdGVyICgpIHsgdGhpcy5jaHVuayA9IFtdOyB9XG4gIFdyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgY2h1bmtfaWR4OjIwLCBibG9ja19sZW46MCwgb2JqX2NvdW50ZXI6MCwgc2l6ZV8zMjowLCBzaXplXzY0OjAsXG4gICAgd3JpdGU6ZnVuY3Rpb24gKHNpemUsIHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9hdDpmdW5jdGlvbiAocG9zLCBzaXplLCB2YWx1ZSkge1xuICAgICAgdmFyIHBvcyA9IHBvcztcbiAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gODtpID49IDA7aSAtPSA4KVxuICAgICAgICB0aGlzLmNodW5rW3BvcysrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9jb2RlOmZ1bmN0aW9uIChzaXplLCBjb2RlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9IGNvZGU7XG4gICAgICBmb3IgKHZhciBpID0gc2l6ZSAtIDg7aSA+PSAwO2kgLT0gOClcbiAgICAgICAgdGhpcy5jaHVua1t0aGlzLmNodW5rX2lkeCsrXSA9ICh2YWx1ZSA+PiBpKSAmIDB4RkY7XG4gICAgfSxcbiAgICB3cml0ZV9zaGFyZWQ6ZnVuY3Rpb24gKG9mZnNldCkge1xuICAgICAgaWYgKG9mZnNldCA8ICgxIDw8IDgpKSB0aGlzLndyaXRlX2NvZGUoOCwgMHgwNCAvKmNzdC5DT0RFX1NIQVJFRDgqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgaWYgKG9mZnNldCA8ICgxIDw8IDE2KSkgdGhpcy53cml0ZV9jb2RlKDE2LCAweDA1IC8qY3N0LkNPREVfU0hBUkVEMTYqLywgb2Zmc2V0KTtcbiAgICAgIGVsc2UgdGhpcy53cml0ZV9jb2RlKDMyLCAweDA2IC8qY3N0LkNPREVfU0hBUkVEMzIqLywgb2Zmc2V0KTtcbiAgICB9LFxuICAgIHBvczpmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNodW5rX2lkeCB9LFxuICAgIGZpbmFsaXplOmZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuYmxvY2tfbGVuID0gdGhpcy5jaHVua19pZHggLSAyMDtcbiAgICAgIHRoaXMuY2h1bmtfaWR4ID0gMDtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCAweDg0OTVBNkJFKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLmJsb2NrX2xlbik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5vYmpfY291bnRlcik7XG4gICAgICB0aGlzLndyaXRlICgzMiwgdGhpcy5zaXplXzMyKTtcbiAgICAgIHRoaXMud3JpdGUgKDMyLCB0aGlzLnNpemVfNjQpO1xuICAgICAgcmV0dXJuIHRoaXMuY2h1bms7XG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAodiwgZmxhZ3MpIHtcbiAgICBmbGFncyA9IGNhbWxfbGlzdF90b19qc19hcnJheShmbGFncyk7XG5cbiAgICB2YXIgbm9fc2hhcmluZyA9IChmbGFncy5pbmRleE9mKDAgLypNYXJzaGFsLk5vX3NoYXJpbmcqLykgIT09IC0xKSxcbiAgICAgICAgY2xvc3VyZXMgPSAgKGZsYWdzLmluZGV4T2YoMSAvKk1hcnNoYWwuQ2xvc3VyZXMqLykgIT09IC0xKTtcbiAgICAgICAgLyogTWFyc2hhbC5Db21wYXRfMzIgaXMgcmVkdW5kYW50IHNpbmNlIGludGVnZXJzIGFyZSAzMi1iaXQgYW55d2F5ICovXG5cbiAgICBpZiAoY2xvc3VyZXMpXG4gICAgICBqb29fZ2xvYmFsX29iamVjdC5jb25zb2xlLndhcm4oXCJpbiBjYW1sX291dHB1dF92YWw6IGZsYWcgTWFyc2hhbC5DbG9zdXJlcyBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcblxuICAgIHZhciB3cml0ZXIgPSBuZXcgV3JpdGVyICgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBpbnRlcm5fb2JqX3RhYmxlID0gbm9fc2hhcmluZyA/IG51bGwgOiBuZXcgTWxPYmplY3RUYWJsZSgpO1xuXG4gICAgZnVuY3Rpb24gbWVtbyh2KSB7XG4gICAgICBpZiAobm9fc2hhcmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGV4aXN0aW5nX29mZnNldCA9IGludGVybl9vYmpfdGFibGUucmVjYWxsKHYpO1xuICAgICAgaWYgKGV4aXN0aW5nX29mZnNldCkgeyB3cml0ZXIud3JpdGVfc2hhcmVkKGV4aXN0aW5nX29mZnNldCk7IHJldHVybiB0cnVlOyB9XG4gICAgICBlbHNlIHsgaW50ZXJuX29ial90YWJsZS5zdG9yZSh2KTsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZXJuX3JlYyAodikge1xuICAgICAgaWYgKHYuY2FtbF9jdXN0b20pIHtcbiAgICAgICAgaWYgKG1lbW8odikpIHJldHVybjtcbiAgICAgICAgdmFyIG5hbWUgPSB2LmNhbWxfY3VzdG9tO1xuICAgICAgICB2YXIgb3BzID0gY2FtbF9jdXN0b21fb3BzW25hbWVdO1xuICAgICAgICB2YXIgc3pfMzJfNjQgPSBbMCwwXTtcbiAgICAgICAgaWYoIW9wcy5zZXJpYWxpemUpXG4gICAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQ3VzdG9tKVwiKTtcbiAgICAgICAgaWYoY2FtbF9sZWdhY3lfY3VzdG9tX2NvZGUpIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTIgLypjc3QuQ09ERV9DVVNUT00qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICB9IGVsc2UgaWYob3BzLmZpeGVkX2xlbmd0aCA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgxOCAvKmNzdC5DT0RFX0NVU1RPTV9MRU4qLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgaGVhZGVyX3BvcyA9IHdyaXRlci5wb3MgKCk7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3BzLnNlcmlhbGl6ZSh3cml0ZXIsIHYsIHN6XzMyXzY0KTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcywgMzIsIHN6XzMyXzY0WzBdKTtcbiAgICAgICAgICB3cml0ZXIud3JpdGVfYXQoaGVhZGVyX3BvcyArIDQsIDMyLCAwKTsgLy8gemVyb1xuICAgICAgICAgIHdyaXRlci53cml0ZV9hdChoZWFkZXJfcG9zICsgOCwgMzIsIHN6XzMyXzY0WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIDB4MTkgLypjc3QuQ09ERV9DVVNUT01fRklYRUQqLyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBuYW1lLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgIHdyaXRlci53cml0ZSg4LCAwKTtcbiAgICAgICAgICB2YXIgb2xkX3BvcyA9IHdyaXRlci5wb3MoKTtcbiAgICAgICAgICBvcHMuc2VyaWFsaXplKHdyaXRlciwgdiwgc3pfMzJfNjQpO1xuICAgICAgICAgIGlmIChvcHMuZml4ZWRfbGVuZ3RoICE9IHdyaXRlci5wb3MoKSAtIG9sZF9wb3MpXG4gICAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBpbmNvcnJlY3QgZml4ZWQgc2l6ZXMgc3BlY2lmaWVkIGJ5IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLnNpemVfMzIgKz0gMiArICgoc3pfMzJfNjRbMF0gKyAzKSA+PiAyKTtcbiAgICAgICAgd3JpdGVyLnNpemVfNjQgKz0gMiArICgoc3pfMzJfNjRbMV0gKyA3KSA+PiAzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSAmJiB2WzBdID09PSAodlswXXwwKSkge1xuICAgICAgICBpZiAodlswXSA9PSAyNTEpIHtcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwib3V0cHV0X3ZhbHVlOiBhYnN0cmFjdCB2YWx1ZSAoQWJzdHJhY3QpXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2Lmxlbmd0aCA+IDEgJiYgbWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICBpZiAodlswXSA8IDE2ICYmIHYubGVuZ3RoIC0gMSA8IDgpXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDgwIC8qY3N0LlBSRUZJWF9TTUFMTF9CTE9DSyovICsgdlswXSArICgodi5sZW5ndGggLSAxKTw8NCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDggLypjc3QuQ09ERV9CTE9DSzMyKi8sICgodi5sZW5ndGgtMSkgPDwgMTApIHwgdlswXSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IHYubGVuZ3RoO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSB2Lmxlbmd0aDtcbiAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkgc3RhY2sucHVzaCAodiwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfYnl0ZXModikpIHtcbiAgICAgICAgaWYoIShjYW1sX2lzX21sX2J5dGVzKGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMoXCJcIikpKSkge1xuICAgICAgICAgIGNhbWxfZmFpbHdpdGgoXCJvdXRwdXRfdmFsdWU6IFtCeXRlcy50XSBjYW5ub3Qgc2FmZWx5IGJlIG1hcnNoYWxlZCB3aXRoIFstLWVuYWJsZSB1c2UtanMtc3RyaW5nXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVtbyh2KSkgcmV0dXJuO1xuICAgICAgICB2YXIgbGVuID0gY2FtbF9tbF9ieXRlc19sZW5ndGgodik7XG4gICAgICAgIGlmIChsZW4gPCAweDIwKVxuICAgICAgICAgIHdyaXRlci53cml0ZSAoOCwgMHgyMCAvKmNzdC5QUkVGSVhfU01BTExfU1RSSU5HKi8gKyBsZW4pO1xuICAgICAgICBlbHNlIGlmIChsZW4gPCAweDEwMClcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoOCwgMHgwOS8qY3N0LkNPREVfU1RSSU5HOCovLCBsZW4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUgKDMyLCAweDBBIC8qY3N0LkNPREVfU1RSSU5HMzIqLywgbGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGxlbjtpKyspXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCBjYW1sX2J5dGVzX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcodikpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aCh2KTtcbiAgICAgICAgaWYgKGxlbiA8IDB4MjApXG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDIwIC8qY3N0LlBSRUZJWF9TTUFMTF9TVFJJTkcqLyArIGxlbik7XG4gICAgICAgIGVsc2UgaWYgKGxlbiA8IDB4MTAwKVxuICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlICg4LCAweDA5Lypjc3QuQ09ERV9TVFJJTkc4Ki8sIGxlbik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSAoMzIsIDB4MEEgLypjc3QuQ09ERV9TVFJJTkczMiovLCBsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgbGVuO2krKylcbiAgICAgICAgICB3cml0ZXIud3JpdGUgKDgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQodixpKSk7XG4gICAgICAgIHdyaXRlci5zaXplXzMyICs9IDEgKyAoKChsZW4gKyA0KSAvIDQpfDApO1xuICAgICAgICB3cml0ZXIuc2l6ZV82NCArPSAxICsgKCgobGVuICsgOCkgLyA4KXwwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICE9ICh2fDApKXtcbiAgICAgICAgICB2YXIgdHlwZV9vZl92ID0gdHlwZW9mIHY7XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBJZiBhIGZsb2F0IGhhcHBlbnMgdG8gYmUgYW4gaW50ZWdlciBpdCBpcyBzZXJpYWxpemVkIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAvLyAoSnNfb2Zfb2NhbWwgY2Fubm90IHRlbGwgd2hldGhlciB0aGUgdHlwZSBvZiBhbiBpbnRlZ2VyIG51bWJlciBpc1xuICAgICAgICAgIC8vIGZsb2F0IG9yIGludGVnZXIuKSBUaGlzIGNhbiByZXN1bHQgaW4gdW5leHBlY3RlZCBjcmFzaGVzIHdoZW5cbiAgICAgICAgICAvLyB1bm1hcnNoYWxsaW5nIHVzaW5nIHRoZSBzdGFuZGFyZCBydW50aW1lLiBJdCBzZWVtcyBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBzeXN0ZW1hdGljYWxseSBmYWlsIG9uIG1hcnNoYWxsaW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gICAgICAgICAgaWYodHlwZV9vZl92ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIm91dHB1dF92YWx1ZTogYWJzdHJhY3QgdmFsdWUgKFwiK3R5cGVfb2ZfditcIilcIik7XG4gICAgICAgICAgLy8gICAgICAgICAgdmFyIHQgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCh2KSk7XG4gICAgICAgICAgLy8gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAweDBCIC8qY3N0LkNPREVfRE9VQkxFX0JJRyovKTtcbiAgICAgICAgICAvLyAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpPDg7IGkrKyl7d3JpdGVyLndyaXRlKDgsdFtpXSl9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA+PSAwICYmIHYgPCAweDQwKSB7XG4gICAgICAgICAgd3JpdGVyLndyaXRlICg4LCAwWDQwIC8qY3N0LlBSRUZJWF9TTUFMTF9JTlQqLyArIHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ID49IC0oMSA8PCA3KSAmJiB2IDwgKDEgPDwgNykpXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVfY29kZSg4LCAweDAwIC8qY3N0LkNPREVfSU5UOCovLCB2KTtcbiAgICAgICAgICBlbHNlIGlmICh2ID49IC0oMSA8PCAxNSkgJiYgdiA8ICgxIDw8IDE1KSlcbiAgICAgICAgICAgIHdyaXRlci53cml0ZV9jb2RlKDE2LCAweDAxIC8qY3N0LkNPREVfSU5UMTYqLywgdik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLndyaXRlX2NvZGUoMzIsIDB4MDIgLypjc3QuQ09ERV9JTlQzMiovLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBleHRlcm5fcmVjICh2KTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGkgPSBzdGFjay5wb3AgKCk7XG4gICAgICB2YXIgdiA9IHN0YWNrLnBvcCAoKTtcbiAgICAgIGlmIChpICsgMSA8IHYubGVuZ3RoKSBzdGFjay5wdXNoICh2LCBpICsgMSk7XG4gICAgICBleHRlcm5fcmVjICh2W2ldKTtcbiAgICB9XG4gICAgaWYgKGludGVybl9vYmpfdGFibGUpIHdyaXRlci5vYmpfY291bnRlciA9IGludGVybl9vYmpfdGFibGUub2Jqcy5sZW5ndGg7XG4gICAgd3JpdGVyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHdyaXRlci5jaHVuaztcbiAgfVxufSAoKTtcblxuLy9Qcm92aWRlczogY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9zdHJpbmdfb2ZfYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX3N0cmluZyAodiwgZmxhZ3MpIHtcbiAgcmV0dXJuIGNhbWxfc3RyaW5nX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J5dGVzIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfb3V0cHV0X3ZhbCwgY2FtbF9ieXRlc19vZl9hcnJheVxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWVfdG9fYnl0ZXMgKHYsIGZsYWdzKSB7XG4gIHJldHVybiBjYW1sX2J5dGVzX29mX2FycmF5IChjYW1sX291dHB1dF92YWwgKHYsIGZsYWdzKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclxuLy9SZXF1aXJlczogY2FtbF9vdXRwdXRfdmFsLCBjYW1sX2ZhaWx3aXRoLCBjYW1sX2JsaXRfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlciAocywgb2ZzLCBsZW4sIHYsIGZsYWdzKSB7XG4gIHZhciB0ID0gY2FtbF9vdXRwdXRfdmFsICh2LCBmbGFncyk7XG4gIGlmICh0Lmxlbmd0aCA+IGxlbikgY2FtbF9mYWlsd2l0aCAoXCJNYXJzaGFsLnRvX2J1ZmZlcjogYnVmZmVyIG92ZXJmbG93XCIpO1xuICBjYW1sX2JsaXRfYnl0ZXModCwgMCwgcywgb2ZzLCB0Lmxlbmd0aCk7XG4gIHJldHVybiAwO1xufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBJb1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3N5c19jbG9zZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YVxuZnVuY3Rpb24gY2FtbF9zeXNfY2xvc2UoZmQpIHtcbiAgZGVsZXRlIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3RkX291dHB1dFxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfanNieXRlcywgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX3N0ZF9vdXRwdXQoY2hhbmlkLHMpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIHN0ciA9IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMocyk7XG4gIHZhciBzbGVuID0gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHN0cik7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLm9mZnNldCwgc3RyLCAwLCBzbGVuKTtcbiAgY2hhbi5vZmZzZXQgKz0gc2xlbjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc3lzX29wZW5cbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX2dsb2JhbF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2NyZWF0ZV9ieXRlcyxNbEZha2VGaWxlXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnIsIGpzX3ByaW50X3N0ZG91dFxuLy9SZXF1aXJlczogY2FtbF9zdGRfb3V0cHV0XG4vL1JlcXVpcmVzOiByZXNvbHZlX2ZzX2RldmljZVxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9zeXNfb3Blbl9pbnRlcm5hbChpZHgsb3V0cHV0LGZpbGUsZmxhZ3MpIHtcbiAgaWYoY2FtbF9nbG9iYWxfZGF0YS5mZHMgPT09IHVuZGVmaW5lZCkgY2FtbF9nbG9iYWxfZGF0YS5mZHMgPSBuZXcgQXJyYXkoKTtcbiAgZmxhZ3M9ZmxhZ3M/ZmxhZ3M6e307XG4gIHZhciBpbmZvID0ge307XG4gIGluZm8uZmlsZSA9IGZpbGU7XG4gIGluZm8ub2Zmc2V0ID0gZmxhZ3MuYXBwZW5kP2ZpbGUubGVuZ3RoKCk6MDtcbiAgaW5mby5mbGFncyA9IGZsYWdzO1xuICBpbmZvLm91dHB1dCA9IG91dHB1dDtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbaWR4XSA9IGluZm87XG4gIGlmKCFjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4IHx8IGlkeCA+IGNhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHgpXG4gICAgY2FtbF9nbG9iYWxfZGF0YS5mZF9sYXN0X2lkeCA9IGlkeDtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIGNhbWxfc3lzX29wZW4gKG5hbWUsIGZsYWdzLCBfcGVybXMpIHtcbiAgdmFyIGYgPSB7fTtcbiAgd2hpbGUoZmxhZ3Mpe1xuICAgIHN3aXRjaChmbGFnc1sxXSl7XG4gICAgY2FzZSAwOiBmLnJkb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAxOiBmLndyb25seSA9IDE7YnJlYWs7XG4gICAgY2FzZSAyOiBmLmFwcGVuZCA9IDE7YnJlYWs7XG4gICAgY2FzZSAzOiBmLmNyZWF0ZSA9IDE7YnJlYWs7XG4gICAgY2FzZSA0OiBmLnRydW5jYXRlID0gMTticmVhaztcbiAgICBjYXNlIDU6IGYuZXhjbCA9IDE7IGJyZWFrO1xuICAgIGNhc2UgNjogZi5iaW5hcnkgPSAxO2JyZWFrO1xuICAgIGNhc2UgNzogZi50ZXh0ID0gMTticmVhaztcbiAgICBjYXNlIDg6IGYubm9uYmxvY2sgPSAxO2JyZWFrO1xuICAgIH1cbiAgICBmbGFncz1mbGFnc1syXTtcbiAgfVxuICBpZihmLnJkb25seSAmJiBmLndyb25seSlcbiAgICBjYW1sX3JhaXNlX3N5c19lcnJvcihjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG5hbWUpICsgXCIgOiBmbGFncyBPcGVuX3Jkb25seSBhbmQgT3Blbl93cm9ubHkgYXJlIG5vdCBjb21wYXRpYmxlXCIpO1xuICBpZihmLnRleHQgJiYgZi5iaW5hcnkpXG4gICAgY2FtbF9yYWlzZV9zeXNfZXJyb3IoY2FtbF9qc2J5dGVzX29mX3N0cmluZyhuYW1lKSArIFwiIDogZmxhZ3MgT3Blbl90ZXh0IGFuZCBPcGVuX2JpbmFyeSBhcmUgbm90IGNvbXBhdGlibGVcIik7XG4gIHZhciByb290ID0gcmVzb2x2ZV9mc19kZXZpY2UobmFtZSk7XG4gIHZhciBmaWxlID0gcm9vdC5kZXZpY2Uub3Blbihyb290LnJlc3QsZik7XG4gIHZhciBpZHggPSBjYW1sX2dsb2JhbF9kYXRhLmZkX2xhc3RfaWR4P2NhbWxfZ2xvYmFsX2RhdGEuZmRfbGFzdF9pZHg6MDtcbiAgcmV0dXJuIGNhbWxfc3lzX29wZW5faW50ZXJuYWwgKGlkeCsxLGNhbWxfc3RkX291dHB1dCxmaWxlLGYpO1xufVxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgwLGNhbWxfc3RkX291dHB1dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRpblxuY2FtbF9zeXNfb3Blbl9pbnRlcm5hbCgxLGpzX3ByaW50X3N0ZG91dCwgbmV3IE1sRmFrZUZpbGUoY2FtbF9jcmVhdGVfYnl0ZXMoMCkpKTsgLy9zdGRvdXRcbmNhbWxfc3lzX29wZW5faW50ZXJuYWwoMixqc19wcmludF9zdGRlcnIsIG5ldyBNbEZha2VGaWxlKGNhbWxfY3JlYXRlX2J5dGVzKDApKSk7IC8vc3RkZXJyXG5cblxuLy8gb2NhbWwgQ2hhbm5lbHNcblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX25hbWUoKSB7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbHNcbnZhciBjYW1sX21sX2NoYW5uZWxzID0gbmV3IEFycmF5KCk7XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3Rcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3QgKCkge1xuICB2YXIgbCA9IDA7XG4gIGZvcih2YXIgYyA9IDA7IGMgPCBjYW1sX21sX2NoYW5uZWxzLmxlbmd0aDsgYysrKXtcbiAgICBpZihjYW1sX21sX2NoYW5uZWxzW2NdICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3BlbmVkICYmIGNhbWxfbWxfY2hhbm5lbHNbY10ub3V0KVxuICAgICAgbD1bMCxjYW1sX21sX2NoYW5uZWxzW2NdLmZkLGxdO1xuICB9XG4gIHJldHVybiBsO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dFxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVscywgY2FtbF9nbG9iYWxfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX291dCAoZmQpIHtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tmZF07XG4gIGlmKGRhdGEuZmxhZ3MucmRvbmx5KSBjYW1sX3JhaXNlX3N5c19lcnJvcihcImZkIFwiKyBmZCArIFwiIGlzIHJlYWRvbmx5XCIpO1xuICB2YXIgY2hhbm5lbCA9IHtcbiAgICBmaWxlOmRhdGEuZmlsZSxcbiAgICBvZmZzZXQ6ZGF0YS5vZmZzZXQsXG4gICAgZmQ6ZmQsXG4gICAgb3BlbmVkOnRydWUsXG4gICAgb3V0OnRydWUsXG4gICAgYnVmZmVyOlwiXCJcbiAgfTtcbiAgY2FtbF9tbF9jaGFubmVsc1tjaGFubmVsLmZkXT1jaGFubmVsO1xuICByZXR1cm4gY2hhbm5lbC5mZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW5cbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsY2FtbF9zeXNfb3BlbixjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9vcGVuX2Rlc2NyaXB0b3JfaW4gKGZkKSAge1xuICB2YXIgZGF0YSA9IGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2ZkXTtcbiAgaWYoZGF0YS5mbGFncy53cm9ubHkpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiZmQgXCIrIGZkICsgXCIgaXMgd3JpdGVvbmx5XCIpO1xuXG4gIHZhciBjaGFubmVsID0ge1xuICAgIGZpbGU6ZGF0YS5maWxlLFxuICAgIG9mZnNldDpkYXRhLm9mZnNldCxcbiAgICBmZDpmZCxcbiAgICBvcGVuZWQ6dHJ1ZSxcbiAgICBvdXQ6IGZhbHNlLFxuICAgIHJlZmlsbDpudWxsXG4gIH07XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbm5lbC5mZF09Y2hhbm5lbDtcbiAgcmV0dXJuIGNoYW5uZWwuZmQ7XG59XG5cblxuLy9Qcm92aWRlczogY2FtbF9jaGFubmVsX2Rlc2NyaXB0b3Jcbi8vUmVxdWlyZXM6IGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfY2hhbm5lbF9kZXNjcmlwdG9yKGNoYW5pZCl7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICByZXR1cm4gY2hhbi5mZDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NldF9iaW5hcnlfbW9kZVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZXRfYmluYXJ5X21vZGUoY2hhbmlkLG1vZGUpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGRhdGEgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXTtcbiAgZGF0YS5mbGFncy50ZXh0ID0gIW1vZGVcbiAgZGF0YS5mbGFncy5iaW5hcnkgPSBtb2RlXG4gIHJldHVybiAwO1xufVxuXG4vL0lucHV0IGZyb20gaW5fY2hhbm5lbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2Nsb3NlX2NoYW5uZWxcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsIGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfc3lzX2Nsb3NlXG5mdW5jdGlvbiBjYW1sX21sX2Nsb3NlX2NoYW5uZWwgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICBjaGFuLm9wZW5lZCA9IGZhbHNlO1xuICBjaGFuLmZpbGUuY2xvc2UoKTtcbiAgY2FtbF9zeXNfY2xvc2UoY2hhbi5mZClcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2NoYW5uZWxfc2l6ZShjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHJldHVybiBjaGFuLmZpbGUubGVuZ3RoKCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfY2hhbm5lbF9zaXplXzY0KGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgcmV0dXJuIGNhbWxfaW50NjRfb2ZfZmxvYXQoY2hhbi5maWxlLmxlbmd0aCAoKSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX291dHB1dChjaGFuaWQsZikge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgY2FtbF9nbG9iYWxfZGF0YS5mZHNbY2hhbi5mZF0ub3V0cHV0ID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2V0X2NoYW5uZWxfcmVmaWxsXG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX21sX3NldF9jaGFubmVsX3JlZmlsbChjaGFuaWQsZikge1xuICBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ucmVmaWxsID0gZjtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfbWxfcmVmaWxsX2lucHV0IChjaGFuKSB7XG4gIHZhciBzdHIgPSBjaGFuLnJlZmlsbCgpO1xuICB2YXIgc3RyX2xlbiA9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIpO1xuICBpZiAoc3RyX2xlbiA9PSAwKSBjaGFuLnJlZmlsbCA9IG51bGw7XG4gIGNoYW4uZmlsZS53cml0ZShjaGFuLmZpbGUubGVuZ3RoKCksIHN0ciwgMCwgc3RyX2xlbik7XG4gIHJldHVybiBzdHJfbGVuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX21heV9yZWZpbGxfaW5wdXQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsID09IG51bGwpIHJldHVybjtcbiAgaWYgKGNoYW4uZmlsZS5sZW5ndGgoKSAhPSBjaGFuLm9mZnNldCkgcmV0dXJuO1xuICBjYW1sX21sX3JlZmlsbF9pbnB1dCAoY2hhbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfcmVmaWxsX2lucHV0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX2lucHV0IChjaGFuaWQsIHMsIGksIGwpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBsMiA9IGNoYW4uZmlsZS5sZW5ndGgoKSAtIGNoYW4ub2Zmc2V0O1xuICBpZiAobDIgPT0gMCAmJiBjaGFuLnJlZmlsbCAhPSBudWxsKSBsMiA9IGNhbWxfbWxfcmVmaWxsX2lucHV0KGNoYW4pO1xuICBpZiAobDIgPCBsKSBsID0gbDI7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LCBzLCBpLCBsKTtcbiAgY2hhbi5vZmZzZXQgKz0gbDtcbiAgcmV0dXJuIGw7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW5wdXRfdmFsdWVcbi8vUmVxdWlyZXM6IGNhbWxfbWFyc2hhbF9kYXRhX3NpemUsIGNhbWxfaW5wdXRfdmFsdWVfZnJvbV9ieXRlcywgY2FtbF9jcmVhdGVfYnl0ZXMsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfaW5wdXRfdmFsdWUgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcblxuICB2YXIgYnVmID0gY2FtbF9jcmVhdGVfYnl0ZXMoOCk7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLDgpO1xuXG4gIC8vIEhlYWRlciBpcyAyMCBieXRlc1xuICB2YXIgbGVuID0gY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZSAoYnVmLCAwKSArIDIwO1xuXG4gIHZhciBidWYgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICBjaGFuLmZpbGUucmVhZChjaGFuLm9mZnNldCxidWYsMCxsZW4pO1xuXG4gIHZhciBvZmZzZXQgPSBbMF07XG4gIHZhciByZXMgPSBjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXMoYnVmLCBvZmZzZXQpO1xuICBjaGFuLm9mZnNldCA9IGNoYW4ub2Zmc2V0ICsgb2Zmc2V0WzBdO1xuICByZXR1cm4gcmVzO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX2lucHV0X2NoYXJcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9jaGFyIChjaGFuaWQpIHtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICBpZiAoY2hhbi5vZmZzZXQgPj0gY2hhbi5maWxlLmxlbmd0aCgpKVxuICAgIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIHJlcyA9IGNoYW4uZmlsZS5yZWFkX29uZShjaGFuLm9mZnNldCk7XG4gIGNoYW4ub2Zmc2V0Kys7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfaW5wdXRfaW50XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX2VuZF9vZl9maWxlXG4vL1JlcXVpcmVzOiBjYW1sX21sX3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9pbnQgKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgdmFyIGZpbGUgPSBjaGFuLmZpbGU7XG4gIHdoaWxlICgoY2hhbi5vZmZzZXQgKyAzKSA+PSBmaWxlLmxlbmd0aCgpKSB7XG4gICAgdmFyIGwgPSBjYW1sX21sX3JlZmlsbF9pbnB1dChjaGFuKTtcbiAgICBpZiAobCA9PSAwKSBjYW1sX3JhaXNlX2VuZF9vZl9maWxlKCk7XG4gIH1cbiAgdmFyIG8gPSBjaGFuLm9mZnNldDtcbiAgdmFyIHIgPShmaWxlLnJlYWRfb25lKG8gICkgPDwgMjQpXG4gICAgICB8ICAoZmlsZS5yZWFkX29uZShvKzEpIDw8IDE2KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobysyKSA8PCA4KVxuICAgICAgfCAgKGZpbGUucmVhZF9vbmUobyszKSk7XG4gIGNoYW4ub2Zmc2V0Kz00O1xuICByZXR1cm4gcjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9zZWVrX2luXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3N5c19lcnJvciwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9zZWVrX2luKGNoYW5pZCxwb3Mpe1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYgKGNoYW4ucmVmaWxsICE9IG51bGwpIGNhbWxfcmFpc2Vfc3lzX2Vycm9yKFwiSWxsZWdhbCBzZWVrXCIpO1xuICBjaGFuLm9mZnNldCA9IHBvcztcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfc2Vla19pbl82NFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF90b19mbG9hdCwgY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfc2Vla19pbl82NChjaGFuaWQscG9zKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGlmIChjaGFuLnJlZmlsbCAhPSBudWxsKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIklsbGVnYWwgc2Vla1wiKTtcbiAgY2hhbi5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19pblxuLy9SZXF1aXJlczogY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9wb3NfaW4oY2hhbmlkKSB7cmV0dXJuIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXR9XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfcG9zX2luXzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X29mX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzXG5mdW5jdGlvbiBjYW1sX21sX3Bvc19pbl82NChjaGFuaWQpIHtyZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdChjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF0ub2Zmc2V0KX1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmVcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3Jcbi8vUmVxdWlyZXM6IGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dCwgY2FtbF9tbF9jaGFubmVsc1xuZnVuY3Rpb24gY2FtbF9tbF9pbnB1dF9zY2FuX2xpbmUoY2hhbmlkKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIGNhbWxfbWxfbWF5X3JlZmlsbF9pbnB1dChjaGFuaWQpO1xuICB2YXIgcCA9IGNoYW4ub2Zmc2V0O1xuICB2YXIgbGVuID0gY2hhbi5maWxlLmxlbmd0aCgpO1xuICBpZihwID49IGxlbikgeyByZXR1cm4gMDt9XG4gIHdoaWxlKHRydWUpIHtcbiAgICBpZihwID49IGxlbikgcmV0dXJuIC0gKHAgLSBjaGFuLm9mZnNldCk7XG4gICAgaWYoY2hhbi5maWxlLnJlYWRfb25lKHApID09IDEwKSByZXR1cm4gcCAtIGNoYW4ub2Zmc2V0ICsgMTtcbiAgICBwKys7XG4gIH1cbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9mbHVzaFxuLy9SZXF1aXJlczogY2FtbF9yYWlzZV9zeXNfZXJyb3IsIGNhbWxfZ2xvYmFsX2RhdGEsIGNhbWxfbWxfY2hhbm5lbHNcbmZ1bmN0aW9uIGNhbWxfbWxfZmx1c2ggKGNoYW5pZCkge1xuICB2YXIgY2hhbiA9IGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXTtcbiAgaWYoISBjaGFuLm9wZW5lZCkgY2FtbF9yYWlzZV9zeXNfZXJyb3IoXCJDYW5ub3QgZmx1c2ggYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgaWYoIWNoYW4uYnVmZmVyIHx8IGNoYW4uYnVmZmVyID09IFwiXCIpIHJldHVybiAwO1xuICBpZihjaGFuLmZkXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdXG4gICAgICYmIGNhbWxfZ2xvYmFsX2RhdGEuZmRzW2NoYW4uZmRdLm91dHB1dCkge1xuICAgIHZhciBvdXRwdXQgPSBjYW1sX2dsb2JhbF9kYXRhLmZkc1tjaGFuLmZkXS5vdXRwdXQ7XG4gICAgc3dpdGNoKG91dHB1dC5sZW5ndGgpe1xuICAgIGNhc2UgMjogb3V0cHV0KGNoYW5pZCxjaGFuLmJ1ZmZlcik7YnJlYWs7XG4gICAgZGVmYXVsdDogb3V0cHV0KGNoYW4uYnVmZmVyKVxuICAgIH07XG4gIH1cbiAgY2hhbi5idWZmZXIgPSBcIlwiO1xuICByZXR1cm4gMDtcbn1cblxuLy9vdXRwdXQgdG8gb3V0X2NoYW5uZWxcblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfbWxfZmx1c2gsY2FtbF9tbF9ieXRlc19sZW5ndGhcbi8vUmVxdWlyZXM6IGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX2JsaXRfYnl0ZXMsIGNhbWxfcmFpc2Vfc3lzX2Vycm9yLCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9tbF9vdXRwdXRfYnl0ZXMoY2hhbmlkLGJ1ZmZlcixvZmZzZXQsbGVuKSB7XG4gIHZhciBjaGFuID0gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdO1xuICBpZighIGNoYW4ub3BlbmVkKSBjYW1sX3JhaXNlX3N5c19lcnJvcihcIkNhbm5vdCBvdXRwdXQgdG8gYSBjbG9zZWQgY2hhbm5lbFwiKTtcbiAgdmFyIGJ5dGVzO1xuICBpZihvZmZzZXQgPT0gMCAmJiBjYW1sX21sX2J5dGVzX2xlbmd0aChidWZmZXIpID09IGxlbilcbiAgICBieXRlcyA9IGJ1ZmZlcjtcbiAgZWxzZSB7XG4gICAgYnl0ZXMgPSBjYW1sX2NyZWF0ZV9ieXRlcyhsZW4pO1xuICAgIGNhbWxfYmxpdF9ieXRlcyhidWZmZXIsb2Zmc2V0LGJ5dGVzLDAsbGVuKTtcbiAgfVxuICB2YXIgc3RyaW5nID0gY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnl0ZXMpO1xuICB2YXIganNzdHJpbmcgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHN0cmluZyk7XG4gIHZhciBpZCA9IGpzc3RyaW5nLmxhc3RJbmRleE9mKFwiXFxuXCIpO1xuICBpZihpZCA8IDApXG4gICAgY2hhbi5idWZmZXIrPWpzc3RyaW5nO1xuICBlbHNlIHtcbiAgICBjaGFuLmJ1ZmZlcis9anNzdHJpbmcuc3Vic3RyKDAsaWQrMSk7XG4gICAgY2FtbF9tbF9mbHVzaCAoY2hhbmlkKTtcbiAgICBjaGFuLmJ1ZmZlciArPSBqc3N0cmluZy5zdWJzdHIoaWQrMSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0XG4vL1JlcXVpcmVzOiBjYW1sX21sX291dHB1dF9ieXRlcywgY2FtbF9ieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxidWZmZXIsb2Zmc2V0LGxlbil7XG4gIHJldHVybiBjYW1sX21sX291dHB1dF9ieXRlcyhjaGFuaWQsY2FtbF9ieXRlc19vZl9zdHJpbmcoYnVmZmVyKSxvZmZzZXQsbGVuKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9tbF9vdXRwdXRfY2hhclxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbWxfb3V0cHV0X2NoYXIgKGNoYW5pZCxjKSB7XG4gIHZhciBzID0gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCwxKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb3V0cHV0X3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmcsIGNhbWxfbWxfb3V0cHV0LGNhbWxfbWxfc3RyaW5nX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9vdXRwdXRfdmFsdWUgKGNoYW5pZCx2LGZsYWdzKSB7XG4gIHZhciBzID0gY2FtbF9vdXRwdXRfdmFsdWVfdG9fc3RyaW5nKHYsIGZsYWdzKTtcbiAgY2FtbF9tbF9vdXRwdXQoY2hhbmlkLHMsMCxjYW1sX21sX3N0cmluZ19sZW5ndGgocykpO1xuICByZXR1cm4gMDtcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XG4vL1JlcXVpcmVzOiBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBwb3M7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3NlZWtfb3V0XzY0XG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X3RvX2Zsb2F0LCBjYW1sX21sX2NoYW5uZWxzLCBjYW1sX21sX2ZsdXNoXG5mdW5jdGlvbiBjYW1sX21sX3NlZWtfb3V0XzY0KGNoYW5pZCxwb3Mpe1xuICBjYW1sX21sX2ZsdXNoKGNoYW5pZCk7XG4gIGNhbWxfbWxfY2hhbm5lbHNbY2hhbmlkXS5vZmZzZXQgPSBjYW1sX2ludDY0X3RvX2Zsb2F0KHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRcbi8vUmVxdWlyZXM6IGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21sX3Bvc19vdXRfNjRcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfZmxvYXQsIGNhbWxfbWxfY2hhbm5lbHMsIGNhbWxfbWxfZmx1c2hcbmZ1bmN0aW9uIGNhbWxfbWxfcG9zX291dF82NChjaGFuaWQpIHtcbiAgY2FtbF9tbF9mbHVzaChjaGFuaWQpO1xuICByZXR1cm4gY2FtbF9pbnQ2NF9vZl9mbG9hdCAoY2FtbF9tbF9jaGFubmVsc1tjaGFuaWRdLm9mZnNldCk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWxfb3V0cHV0X2ludFxuLy9SZXF1aXJlczogY2FtbF9tbF9vdXRwdXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2FycmF5XG5mdW5jdGlvbiBjYW1sX21sX291dHB1dF9pbnQgKGNoYW5pZCxpKSB7XG4gIHZhciBhcnIgPSBbKGk+PjI0KSAmIDB4RkYsKGk+PjE2KSAmIDB4RkYsKGk+PjgpICYgMHhGRixpICYgMHhGRiBdO1xuICB2YXIgcyA9IGNhbWxfc3RyaW5nX29mX2FycmF5KGFycik7XG4gIGNhbWxfbWxfb3V0cHV0KGNoYW5pZCxzLDAsNCk7XG4gIHJldHVybiAwXG59XG4iLCJcblxuLy9Qcm92aWRlczogY2FtbF9nY19taW5vclxuZnVuY3Rpb24gY2FtbF9nY19taW5vcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfbWFqb3IoKXsgcmV0dXJuIDB9XG4vL1Byb3ZpZGVzOiBjYW1sX2djX2Z1bGxfbWFqb3JcbmZ1bmN0aW9uIGNhbWxfZ2NfZnVsbF9tYWpvcigpeyByZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfY29tcGFjdGlvblxuZnVuY3Rpb24gY2FtbF9nY19jb21wYWN0aW9uKCl7IHJldHVybiAwfVxuLy9Qcm92aWRlczogY2FtbF9nY19jb3VudGVyc1xuZnVuY3Rpb24gY2FtbF9nY19jb3VudGVycygpIHsgcmV0dXJuIFsyNTQsMCwwLDBdIH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfcXVpY2tfc3RhdFxuZnVuY3Rpb24gY2FtbF9nY19xdWlja19zdGF0KCl7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuLy9Qcm92aWRlczogY2FtbF9nY19zdGF0XG5mdW5jdGlvbiBjYW1sX2djX3N0YXQoKSB7XG4gIHJldHVybiBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2djX3NldFxuZnVuY3Rpb24gY2FtbF9nY19zZXQoX2NvbnRyb2wpIHtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZ2NfZ2V0XG5mdW5jdGlvbiBjYW1sX2djX2dldCgpe1xuICByZXR1cm4gWzAsMCwwLDAsMCwwLDAsMCwwXVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc2V0XG5mdW5jdGlvbiBjYW1sX21lbXByb2Zfc2V0KF9jb250cm9sKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2ZpbmFsX3JlZ2lzdGVyIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlZ2lzdGVyICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgY29uc3RcbmZ1bmN0aW9uIGNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWUgKCkgeyByZXR1cm4gMDsgfVxuLy9Qcm92aWRlczogY2FtbF9maW5hbF9yZWxlYXNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2ZpbmFsX3JlbGVhc2UgKCkgeyByZXR1cm4gMDsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RhcnRcbmZ1bmN0aW9uIGNhbWxfbWVtcHJvZl9zdGFydChyYXRlLHN0YWNrX3NpemUsdHJhY2tlcil7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21lbXByb2Zfc3RvcFxuZnVuY3Rpb24gY2FtbF9tZW1wcm9mX3N0b3AodW5pdCkge1xuICByZXR1cm4gMDtcbn1cbiIsIi8vIEpzX29mX29jYW1sIHJ1bnRpbWUgc3VwcG9ydFxuLy8gaHR0cDovL3d3dy5vY3NpZ2VuLm9yZy9qc19vZl9vY2FtbC9cbi8vIENvcHlyaWdodCAoQykgMjAxNCBKw6lyw7RtZSBWb3VpbGxvbiwgSHVnbyBIZXV6YXJkLCBBbmR5IFJheVxuLy8gTGFib3JhdG9pcmUgUFBTIC0gQ05SUyBVbml2ZXJzaXTDqSBQYXJpcyBEaWRlcm90XG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuLy9cbi8vIEJpZ2FycmF5LlxuLy9cbi8vIC0gYWxsIGJpZ2FycmF5IHR5cGVzIGluY2x1ZGluZyBJbnQ2NCBhbmQgQ29tcGxleC5cbi8vIC0gZm9ydHJhbiArIGMgbGF5b3V0c1xuLy8gLSBzdWIvc2xpY2UvcmVzaGFwZVxuLy8gLSByZXRhaW4gZmFzdCBwYXRoIGZvciAxZCBhcnJheSBhY2Nlc3NcblxuLy9Qcm92aWRlczogY2FtbF9iYV9pbml0IGNvbnN0XG5mdW5jdGlvbiBjYW1sX2JhX2luaXQoKSB7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X3NpemUoZGltcykge1xuICB2YXIgbl9kaW1zID0gZGltcy5sZW5ndGg7XG4gIHZhciBzaXplID0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuX2RpbXM7IGkrKykge1xuICAgIGlmIChkaW1zW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmNyZWF0ZTogbmVnYXRpdmUgZGltZW5zaW9uXCIpO1xuICAgIHNpemUgPSBzaXplICogZGltc1tpXTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKXtcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDc6IGNhc2UgMTA6IGNhc2UgMTE6IHJldHVybiAyO1xuICBkZWZhdWx0OiByZXR1cm4gMTtcbiAgfVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGVfYnVmZmVyKGtpbmQsIHNpemUpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICB2YXIgdmlldztcbiAgc3dpdGNoKGtpbmQpe1xuICBjYXNlIDA6ICB2aWV3ID0gZy5GbG9hdDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDE6ICB2aWV3ID0gZy5GbG9hdDY0QXJyYXk7IGJyZWFrO1xuICBjYXNlIDI6ICB2aWV3ID0gZy5JbnQ4QXJyYXk7IGJyZWFrO1xuICBjYXNlIDM6ICB2aWV3ID0gZy5VaW50OEFycmF5OyBicmVhaztcbiAgY2FzZSA0OiAgdmlldyA9IGcuSW50MTZBcnJheTsgYnJlYWs7XG4gIGNhc2UgNTogIHZpZXcgPSBnLlVpbnQxNkFycmF5OyBicmVhaztcbiAgY2FzZSA2OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgNzogIHZpZXcgPSBnLkludDMyQXJyYXk7IGJyZWFrO1xuICBjYXNlIDg6ICB2aWV3ID0gZy5JbnQzMkFycmF5OyBicmVhaztcbiAgY2FzZSA5OiAgdmlldyA9IGcuSW50MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTA6IHZpZXcgPSBnLkZsb2F0MzJBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTE6IHZpZXcgPSBnLkZsb2F0NjRBcnJheTsgYnJlYWs7XG4gIGNhc2UgMTI6IHZpZXcgPSBnLlVpbnQ4QXJyYXk7IGJyZWFrO1xuICB9XG4gIGlmICghdmlldykgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuY3JlYXRlOiB1bnN1cHBvcnRlZCBraW5kXCIpO1xuICB2YXIgZGF0YSA9IG5ldyB2aWV3KHNpemUgKiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGtpbmQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3VzdG9tX25hbWVcbi8vVmVyc2lvbjogPCA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycmF5XCJcblxuLy9Qcm92aWRlczogY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9WZXJzaW9uOiA+PSA0LjExXG52YXIgY2FtbF9iYV9jdXN0b21fbmFtZSA9IFwiX2JpZ2FycjAyXCJcblxuLy9Qcm92aWRlczogTWxfQmlnYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jdXN0b21fbmFtZVxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9jcmVhdGVfbG9faGksIGNhbWxfaW50NjRfaGkzMiwgY2FtbF9pbnQ2NF9sbzMyXG5mdW5jdGlvbiBNbF9CaWdhcnJheSAoa2luZCwgbGF5b3V0LCBkaW1zLCBidWZmZXIpIHtcblxuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgPSBidWZmZXI7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5jYW1sX2N1c3RvbSA9IGNhbWxfYmFfY3VzdG9tX25hbWU7XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciBvZnMgPSAwO1xuICBpZih0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSBhcmcgPSBbYXJnXTtcbiAgaWYgKCEgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSkgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiYmlnYXJyYXkuanM6IGludmFsaWQgb2Zmc2V0XCIpO1xuICBpZiAodGhpcy5kaW1zLmxlbmd0aCAhPSBhcmcubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LmdldC9zZXQ6IGJhZCBudW1iZXIgb2YgZGltZW5zaW9uc1wiKTtcbiAgaWYodGhpcy5sYXlvdXQgPT0gMCAvKiBjX2xheW91dCAqLykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJnW2ldIDwgMCB8fCBhcmdbaV0gPj0gdGhpcy5kaW1zW2ldKVxuICAgICAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gICAgICBvZnMgPSAob2ZzICogdGhpcy5kaW1zW2ldKSArIGFyZ1tpXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZGltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFyZ1tpXSA8IDEgfHwgYXJnW2ldID4gdGhpcy5kaW1zW2ldKXtcbiAgICAgICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICAgICAgfVxuICAgICAgb2ZzID0gKG9mcyAqIHRoaXMuZGltc1tpXSkgKyAoYXJnW2ldIC0gMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvZnM7XG59XG5cbk1sX0JpZ2FycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2ZzKSB7XG4gIHN3aXRjaCh0aGlzLmtpbmQpe1xuICBjYXNlIDc6XG4gICAgLy8gSW50NjRcbiAgICB2YXIgbCA9IHRoaXMuZGF0YVtvZnMgKiAyICsgMF07XG4gICAgdmFyIGggPSB0aGlzLmRhdGFbb2ZzICogMiArIDFdO1xuICAgIHJldHVybiBjYW1sX2ludDY0X2NyZWF0ZV9sb19oaShsLGgpO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdmFyIHIgPSB0aGlzLmRhdGFbb2ZzICogMiArIDBdO1xuICAgIHZhciBpID0gdGhpcy5kYXRhW29mcyAqIDIgKyAxXTtcbiAgICByZXR1cm4gWzI1NCwgciwgaV07XG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtvZnNdXG4gIH1cbn1cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChvZnMsdikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IGNhbWxfaW50NjRfbG8zMih2KTtcbiAgICB0aGlzLmRhdGFbb2ZzICogMiArIDFdID0gY2FtbF9pbnQ2NF9oaTMyKHYpO1xuICAgIGJyZWFrO1xuICBjYXNlIDEwOiBjYXNlIDExOlxuICAgIC8vIENvbXBsZXgzMiwgQ29tcGxleDY0XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAwXSA9IHZbMV07XG4gICAgdGhpcy5kYXRhW29mcyAqIDIgKyAxXSA9IHZbMl07XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhW29mc10gPSB2O1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAwXG59XG5cblxuTWxfQmlnYXJyYXkucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodikge1xuICBzd2l0Y2godGhpcy5raW5kKXtcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgdmFyIGEgPSBjYW1sX2ludDY0X2xvMzIodik7XG4gICAgdmFyIGIgPSBjYW1sX2ludDY0X2hpMzIodik7XG4gICAgaWYoYSA9PSBiKXtcbiAgICAgIHRoaXMuZGF0YS5maWxsKGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDA7IGk8dGhpcy5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gKGklMiA9PSAwKSA/IGEgOiBiO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMDogY2FzZSAxMTpcbiAgICAvLyBDb21wbGV4MzIsIENvbXBsZXg2NFxuICAgIHZhciBpbSA9IHZbMV07XG4gICAgdmFyIHJlID0gdlsyXTtcbiAgICBpZihpbSA9PSByZSl7XG4gICAgICB0aGlzLmRhdGEuZmlsbChpbSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMDsgaTx0aGlzLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmRhdGFbaV0gPSAoaSUyID09IDApID8gaW0gOiByZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgdGhpcy5kYXRhLmZpbGwodik7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuXG5NbF9CaWdhcnJheS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChiLCB0b3RhbCkge1xuICBpZiAodGhpcy5sYXlvdXQgIT0gYi5sYXlvdXQgfHwgdGhpcy5raW5kICE9IGIua2luZCkge1xuICAgIHZhciBrMSA9IHRoaXMua2luZCB8ICh0aGlzLmxheW91dCA8PCA4KTtcbiAgICB2YXIgazIgPSAgICBiLmtpbmQgfCAoYi5sYXlvdXQgPDwgOCk7XG4gICAgcmV0dXJuIGsyIC0gazE7XG4gIH1cbiAgaWYgKHRoaXMuZGltcy5sZW5ndGggIT0gYi5kaW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBiLmRpbXMubGVuZ3RoIC0gdGhpcy5kaW1zLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGltcy5sZW5ndGg7IGkrKylcbiAgICBpZiAodGhpcy5kaW1zW2ldICE9IGIuZGltc1tpXSlcbiAgICAgIHJldHVybiAodGhpcy5kaW1zW2ldIDwgYi5kaW1zW2ldKSA/IC0xIDogMTtcbiAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gIGNhc2UgMTA6XG4gIGNhc2UgMTE6XG4gICAgLy8gRmxvYXRzXG4gICAgdmFyIHgsIHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHggPSB0aGlzLmRhdGFbaV07XG4gICAgICB5ID0gYi5kYXRhW2ldO1xuICAgICAgaWYgKHggPCB5KVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoeCA+IHkpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHggIT0geSkge1xuICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICBpZiAoeCA9PSB4KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKHkgPT0geSkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA3OlxuICAgIC8vIEludDY0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKz0yKSB7XG4gICAgICAvLyBDaGVjayBoaWdoZXN0IGJpdHMgZmlyc3RcbiAgICAgIGlmICh0aGlzLmRhdGFbaSsxXSA8IGIuZGF0YVtpKzFdKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2krMV0gPiBiLmRhdGFbaSsxXSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAoKHRoaXMuZGF0YVtpXSA+Pj4gMCkgPCAoYi5kYXRhW2ldID4+PiAwKSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCh0aGlzLmRhdGFbaV0gPj4+IDApID4gKGIuZGF0YVtpXSA+Pj4gMCkpXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAyOlxuICBjYXNlIDM6XG4gIGNhc2UgNDpcbiAgY2FzZSA1OlxuICBjYXNlIDY6XG4gIGNhc2UgODpcbiAgY2FzZSA5OlxuICBjYXNlIDEyOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldIDwgYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAodGhpcy5kYXRhW2ldID4gYi5kYXRhW2ldKVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IE1sX0JpZ2FycmF5X2NfMV8xXG4vL1JlcXVpcmVzOiBNbF9CaWdhcnJheSwgY2FtbF9hcnJheV9ib3VuZF9lcnJvciwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGJ1ZmZlcikge1xuICB0aGlzLmtpbmQgICA9IGtpbmQgO1xuICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgdGhpcy5kaW1zICAgPSBkaW1zO1xuICB0aGlzLmRhdGEgICA9IGJ1ZmZlcjtcbn1cblxuTWxfQmlnYXJyYXlfY18xXzEucHJvdG90eXBlID0gbmV3IE1sX0JpZ2FycmF5KClcbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIGlmKHR5cGVvZiBhcmcgIT09IFwibnVtYmVyXCIpe1xuICAgIGlmKChhcmcgaW5zdGFuY2VvZiBBcnJheSkgJiYgYXJnLmxlbmd0aCA9PSAxKVxuICAgICAgYXJnID0gYXJnWzBdO1xuICAgIGVsc2UgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiTWxfQmlnYXJyYXlfY18xXzEub2Zmc2V0XCIpO1xuICB9XG4gIGlmIChhcmcgPCAwIHx8IGFyZyA+PSB0aGlzLmRpbXNbMF0pXG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJnO1xufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mcykge1xuICByZXR1cm4gdGhpcy5kYXRhW29mc107XG59XG5cbk1sX0JpZ2FycmF5X2NfMV8xLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAob2ZzLHYpIHtcbiAgdGhpcy5kYXRhW29mc10gPSB2O1xuICByZXR1cm4gMFxufVxuXG5NbF9CaWdhcnJheV9jXzFfMS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuZGF0YS5maWxsKHYpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NvbXBhcmVcbmZ1bmN0aW9uIGNhbWxfYmFfY29tcGFyZShhLGIsdG90YWwpe1xuICByZXR1cm4gYS5jb21wYXJlKGIsdG90YWwpXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuLy9SZXF1aXJlczogTWxfQmlnYXJyYXksIE1sX0JpZ2FycmF5X2NfMV8xLCBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpe1xuICB2YXIgc2l6ZV9wZXJfZWxlbWVudCA9IGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnQoa2luZCk7XG4gIGlmKGNhbWxfYmFfZ2V0X3NpemUoZGltcykgKiBzaXplX3Blcl9lbGVtZW50ICE9IGRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwibGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggZGltc1wiKTtcbiAgfVxuICBpZihsYXlvdXQgPT0gMCAmJiAvLyBjX2xheW91dFxuICAgICBkaW1zLmxlbmd0aCA9PSAxICYmIC8vIEFycmF5MVxuICAgICBzaXplX3Blcl9lbGVtZW50ID09IDEpIC8vIDEtdG8tMSBtYXBwaW5nXG4gICAgcmV0dXJuIG5ldyBNbF9CaWdhcnJheV9jXzFfMShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICByZXR1cm4gbmV3IE1sX0JpZ2FycmF5KGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG5cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NyZWF0ZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplLCBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX2J1ZmZlclxuZnVuY3Rpb24gY2FtbF9iYV9jcmVhdGUoa2luZCwgbGF5b3V0LCBkaW1zX21sKSB7XG4gIHZhciBkaW1zID0gY2FtbF9qc19mcm9tX2FycmF5KGRpbXNfbWwpO1xuICB2YXIgZGF0YSA9IGNhbWxfYmFfY3JlYXRlX2J1ZmZlcihraW5kLCBjYW1sX2JhX2dldF9zaXplKGRpbXMpKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2NoYW5nZV9sYXlvdXRcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9jaGFuZ2VfbGF5b3V0KGJhLCBsYXlvdXQpIHtcbiAgaWYoYmEubGF5b3V0ID09IGxheW91dCkgcmV0dXJuIGJhO1xuICB2YXIgbmV3X2RpbXMgPSBbXVxuICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKykgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2JhLmRpbXMubGVuZ3RoIC0gaSAtIDFdO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGxheW91dCwgbmV3X2RpbXMsIGJhLmRhdGEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2tpbmRcbmZ1bmN0aW9uIGNhbWxfYmFfa2luZChiYSkge1xuICByZXR1cm4gYmEua2luZDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9sYXlvdXRcbmZ1bmN0aW9uIGNhbWxfYmFfbGF5b3V0KGJhKSB7XG4gIHJldHVybiBiYS5sYXlvdXQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfbnVtX2RpbXNcbmZ1bmN0aW9uIGNhbWxfYmFfbnVtX2RpbXMoYmEpIHtcbiAgcmV0dXJuIGJhLmRpbXMubGVuZ3RoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX2JhX2RpbShiYSwgaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSBiYS5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5kaW1cIik7XG4gIHJldHVybiBiYS5kaW1zW2ldO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8xXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMShiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8yXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMihiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2RpbV8zXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2RpbVxuZnVuY3Rpb24gY2FtbF9iYV9kaW1fMyhiYSkge1xuICByZXR1cm4gY2FtbF9iYV9kaW0oYmEsIDIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF9nZW5lcmljXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfYmFfZ2V0X2dlbmVyaWMoYmEsIGkpIHtcbiAgdmFyIG9mcyA9IGJhLm9mZnNldChjYW1sX2pzX2Zyb21fYXJyYXkoaSkpO1xuICByZXR1cm4gYmEuZ2V0KG9mcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0MTYoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMpO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzICsgMSk7XG4gIHJldHVybiAoYjEgfCAoYjIgPDwgOCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X2dldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X2dldDMyKGJhLCBpMCkge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB2YXIgYjEgPSBiYS5nZXQob2ZzKzApO1xuICB2YXIgYjIgPSBiYS5nZXQob2ZzKzEpO1xuICB2YXIgYjMgPSBiYS5nZXQob2ZzKzIpO1xuICB2YXIgYjQgPSBiYS5nZXQob2ZzKzMpO1xuICByZXR1cm4gKCAoYjEgPDwgMCkgIHxcbiAgICAgICAgICAgKGIyIDw8IDgpICB8XG4gICAgICAgICAgIChiMyA8PCAxNikgfFxuICAgICAgICAgICAoYjQgPDwgMjQpICk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfZ2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfZ2V0NjQoYmEsIGkwKSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBiMSA9IGJhLmdldChvZnMrMCk7XG4gIHZhciBiMiA9IGJhLmdldChvZnMrMSk7XG4gIHZhciBiMyA9IGJhLmdldChvZnMrMik7XG4gIHZhciBiNCA9IGJhLmdldChvZnMrMyk7XG4gIHZhciBiNSA9IGJhLmdldChvZnMrNCk7XG4gIHZhciBiNiA9IGJhLmdldChvZnMrNSk7XG4gIHZhciBiNyA9IGJhLmdldChvZnMrNik7XG4gIHZhciBiOCA9IGJhLmdldChvZnMrNyk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFtiOCxiNyxiNixiNSxiNCxiMyxiMixiMV0pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8xKGJhLCBpMCkge1xuICByZXR1cm4gYmEuZ2V0KGJhLm9mZnNldChpMCkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8yXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8yKGJhLCBpMCwgaTEpIHtcbiAgcmV0dXJuIGJhLmdldChiYS5vZmZzZXQoW2kwLGkxXSkpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2dldF8zXG5mdW5jdGlvbiBjYW1sX2JhX2dldF8zKGJhLCBpMCwgaTEsIGkyKSB7XG4gIHJldHVybiBiYS5nZXQoYmEub2Zmc2V0KFtpMCxpMSxpMl0pKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zZXRfZ2VuZXJpY1xuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5XG5mdW5jdGlvbiBjYW1sX2JhX3NldF9nZW5lcmljKGJhLCBpLCB2KSB7XG4gIGJhLnNldChiYS5vZmZzZXQoY2FtbF9qc19mcm9tX2FycmF5KGkpKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0MTZcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0MTYoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyAxID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIGJhLnNldChvZnMrMCwgIHYgICAgICAgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMSwgKHYgPj4+IDgpICYgMHhmZik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3VpbnQ4X3NldDMyXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2JhX3VpbnQ4X3NldDMyKGJhLCBpMCwgdikge1xuICB2YXIgb2ZzID0gYmEub2Zmc2V0KGkwKTtcbiAgaWYob2ZzICsgMyA+PSBiYS5kYXRhLmxlbmd0aCkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICBiYS5zZXQob2ZzKzAsICB2ICAgICAgICAgJiAweGZmKTtcbiAgYmEuc2V0KG9mcysxLCAodiA+Pj4gOCkgICYgMHhmZik7XG4gIGJhLnNldChvZnMrMiwgKHYgPj4+IDE2KSAmIDB4ZmYpO1xuICBiYS5zZXQob2ZzKzMsICh2ID4+PiAyNCkgJiAweGZmKTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfdWludDhfc2V0NjRcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3IsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfYmFfdWludDhfc2V0NjQoYmEsIGkwLCB2KSB7XG4gIHZhciBvZnMgPSBiYS5vZmZzZXQoaTApO1xuICBpZihvZnMgKyA3ID49IGJhLmRhdGEubGVuZ3RoKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciB2ID0gY2FtbF9pbnQ2NF90b19ieXRlcyh2KTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IDg7IGkrKykgYmEuc2V0KG9mcytpLCB2WzctaV0pXG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3NldF8xXG5mdW5jdGlvbiBjYW1sX2JhX3NldF8xKGJhLCBpMCwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KGkwKSwgdik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzJcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzIoYmEsIGkwLCBpMSwgdikge1xuICBiYS5zZXQoYmEub2Zmc2V0KFtpMCxpMV0pLCB2KTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2V0XzNcbmZ1bmN0aW9uIGNhbWxfYmFfc2V0XzMoYmEsIGkwLCBpMSwgaTIsIHYpIHtcbiAgYmEuc2V0KGJhLm9mZnNldChbaTAsaTEsaTJdKSwgdik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2ZpbGxcbmZ1bmN0aW9uIGNhbWxfYmFfZmlsbChiYSwgdikge1xuICBiYS5maWxsKHYpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfYmxpdChzcmMsIGRzdCkge1xuICBpZiAoZHN0LmRpbXMubGVuZ3RoICE9IHNyYy5kaW1zLmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5ibGl0OiBkaW1lbnNpb24gbWlzbWF0Y2hcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZHN0LmRpbXMubGVuZ3RoOyBpKyspXG4gICAgaWYgKGRzdC5kaW1zW2ldICE9IHNyYy5kaW1zW2ldKVxuICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuYmxpdDogZGltZW5zaW9uIG1pc21hdGNoXCIpO1xuICBkc3QuZGF0YS5zZXQoc3JjLmRhdGEpO1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zdWJcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2JhX2dldF9zaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50XG5mdW5jdGlvbiBjYW1sX2JhX3N1YihiYSwgb2ZzLCBsZW4pIHtcbiAgdmFyIGNoYW5nZWRfZGltO1xuICB2YXIgbXVsID0gMTtcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAoYmEuZGltcy5sZW5ndGggLSAxKTsgaSsrKVxuICAgICAgbXVsID0gbXVsICogYmEuZGltc1tpXTtcbiAgICBjaGFuZ2VkX2RpbSA9IGJhLmRpbXMubGVuZ3RoIC0gMTtcbiAgICBvZnMgPSBvZnMgLSAxO1xuICB9XG4gIGlmIChvZnMgPCAwIHx8IGxlbiA8IDAgfHwgKG9mcyArIGxlbikgPiBiYS5kaW1zW2NoYW5nZWRfZGltXSl7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkuc3ViOiBiYWQgc3ViLWFycmF5XCIpO1xuICB9XG4gIHZhciBuZXdfZGltcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspXG4gICAgbmV3X2RpbXNbaV0gPSBiYS5kaW1zW2ldO1xuICBuZXdfZGltc1tjaGFuZ2VkX2RpbV0gPSBsZW47XG4gIG11bCAqPSBjYW1sX2JhX2dldF9zaXplX3Blcl9lbGVtZW50KGJhLmtpbmQpO1xuICB2YXIgbmV3X2RhdGEgPSBiYS5kYXRhLnN1YmFycmF5KG9mcyAqIG11bCwgKG9mcyArIGxlbikgKiBtdWwpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbXMsIG5ld19kYXRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9zbGljZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9iYV9nZXRfc2l6ZVxuLy9SZXF1aXJlczogY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudFxuZnVuY3Rpb24gY2FtbF9iYV9zbGljZShiYSwgdmluZCkge1xuICB2aW5kID0gY2FtbF9qc19mcm9tX2FycmF5KHZpbmQpO1xuICB2YXIgbnVtX2luZHMgPSB2aW5kLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gW107XG4gIHZhciBzdWJfZGltcyA9IFtdO1xuICB2YXIgb2ZzO1xuXG4gIGlmIChudW1faW5kcyA+IGJhLmRpbXMubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnNsaWNlOiB0b28gbWFueSBpbmRpY2VzXCIpO1xuXG4gIC8vIENvbXB1dGUgb2Zmc2V0IGFuZCBjaGVjayBib3VuZHNcbiAgaWYgKGJhLmxheW91dCA9PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1faW5kczsgaSsrKVxuICAgICAgaW5kZXhbaV0gPSB2aW5kW2ldO1xuICAgIGZvciAoOyBpIDwgYmEuZGltcy5sZW5ndGg7IGkrKylcbiAgICAgIGluZGV4W2ldID0gMDtcbiAgICBzdWJfZGltcyA9IGJhLmRpbXMuc2xpY2UobnVtX2luZHMpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2luZHM7IGkrKylcbiAgICAgIGluZGV4W2JhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMgKyBpXSA9IHZpbmRbaV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aCAtIG51bV9pbmRzOyBpKyspXG4gICAgICBpbmRleFtpXSA9IDE7XG4gICAgc3ViX2RpbXMgPSBiYS5kaW1zLnNsaWNlKDAsIGJhLmRpbXMubGVuZ3RoIC0gbnVtX2luZHMpO1xuICB9XG4gIG9mcyA9IGJhLm9mZnNldChpbmRleCk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShzdWJfZGltcyk7XG4gIHZhciBzaXplX3Blcl9lbGVtZW50ID0gY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChiYS5raW5kKTtcbiAgdmFyIG5ld19kYXRhID0gYmEuZGF0YS5zdWJhcnJheShvZnMgKiBzaXplX3Blcl9lbGVtZW50LCAob2ZzICsgc2l6ZSkgKiBzaXplX3Blcl9lbGVtZW50KTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShiYS5raW5kLCBiYS5sYXlvdXQsIHN1Yl9kaW1zLCBuZXdfZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfcmVzaGFwZVxuLy9SZXF1aXJlczogY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSwgY2FtbF9iYV9nZXRfc2l6ZVxuZnVuY3Rpb24gY2FtbF9iYV9yZXNoYXBlKGJhLCB2aW5kKSB7XG4gIHZpbmQgPSBjYW1sX2pzX2Zyb21fYXJyYXkodmluZCk7XG4gIHZhciBuZXdfZGltID0gW107XG4gIHZhciBudW1fZGltcyA9IHZpbmQubGVuZ3RoO1xuXG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNil7XG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiQmlnYXJyYXkucmVzaGFwZTogYmFkIG51bWJlciBvZiBkaW1lbnNpb25zXCIpO1xuICB9XG4gIHZhciBudW1fZWx0cyA9IDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtX2RpbXM7IGkrKykge1xuICAgIG5ld19kaW1baV0gPSB2aW5kW2ldO1xuICAgIGlmIChuZXdfZGltW2ldIDwgMClcbiAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIkJpZ2FycmF5LnJlc2hhcGU6IG5lZ2F0aXZlIGRpbWVuc2lvblwiKTtcbiAgICBudW1fZWx0cyA9IG51bV9lbHRzICogbmV3X2RpbVtpXTtcbiAgfVxuXG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShiYS5kaW1zKTtcbiAgLy8gQ2hlY2sgdGhhdCBzaXplcyBhZ3JlZVxuICBpZiAobnVtX2VsdHMgIT0gc2l6ZSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJCaWdhcnJheS5yZXNoYXBlOiBzaXplIG1pc21hdGNoXCIpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGJhLmtpbmQsIGJhLmxheW91dCwgbmV3X2RpbSwgYmEuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQsIGNhbWxfaW50NjRfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50MzJfYml0c19vZl9mbG9hdFxuZnVuY3Rpb24gY2FtbF9iYV9zZXJpYWxpemUod3JpdGVyLCBiYSwgc3opIHtcbiAgd3JpdGVyLndyaXRlKDMyLCBiYS5kaW1zLmxlbmd0aCk7XG4gIHdyaXRlci53cml0ZSgzMiwgKGJhLmtpbmQgfCAoYmEubGF5b3V0IDw8IDgpKSk7XG4gIGlmKGJhLmNhbWxfY3VzdG9tID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmKGJhLmRpbXNbaV0gPCAweGZmZmYpXG4gICAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGltc1tpXSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKDE2LCAweGZmZmYpO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIDApO1xuICAgICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRpbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgZWxzZVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kaW1zLmxlbmd0aDsgaSsrKSB3cml0ZXIud3JpdGUoMzIsYmEuZGltc1tpXSlcbiAgc3dpdGNoKGJhLmtpbmQpe1xuICBjYXNlIDI6ICAvL0ludDhBcnJheVxuICBjYXNlIDM6ICAvL1VpbnQ4QXJyYXlcbiAgY2FzZSAxMjogLy9VaW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDgsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA0OiAgLy8gSW50MTZBcnJheVxuICBjYXNlIDU6ICAvLyBVaW50MTZBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgIHdyaXRlci53cml0ZSgxNiwgYmEuZGF0YVtpXSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGJhLmRhdGFbaV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgd3JpdGVyLndyaXRlKDgsMCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgd3JpdGVyLndyaXRlKDMyLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBiYS5kYXRhLmxlbmd0aCAvIDI7IGkrKyl7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoYmEuZ2V0KGkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChiYS5nZXQoaSkpKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGJhLmRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXQoYmEuZ2V0KGkpKTtcbiAgICAgIHdyaXRlci53cml0ZSgzMiwgYik7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDEwOiAvLyBGbG9hdDMyQXJyYXkgKGNvbXBsZXgzMilcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGogPSBiYS5nZXQoaSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzFdKSk7XG4gICAgICB3cml0ZXIud3JpdGUoMzIsIGNhbWxfaW50MzJfYml0c19vZl9mbG9hdChqWzJdKSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDExOiAvLyBGbG9hdDY0QXJyYXkgKGNvbXBsZXg2NClcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYmEuZGF0YS5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgdmFyIGNvbXBsZXggPSBiYS5nZXQoaSk7XG4gICAgICB2YXIgYiA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0KGNvbXBsZXhbMV0pKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB3cml0ZXIud3JpdGUgKDgsIGJbal0pO1xuICAgICAgdmFyIGIgPSBjYW1sX2ludDY0X3RvX2J5dGVzKGNhbWxfaW50NjRfYml0c19vZl9mbG9hdChjb21wbGV4WzJdKSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykgd3JpdGVyLndyaXRlICg4LCBiW2pdKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cbiAgc3pbMF0gPSAoNCArIGJhLmRpbXMubGVuZ3RoKSAqIDQ7XG4gIHN6WzFdID0gKDQgKyBiYS5kaW1zLmxlbmd0aCkgKiA4O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2Rlc2VyaWFsaXplXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUsIGNhbWxfZmFpbHdpdGhcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemVcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfb2ZfYnl0ZXMsIGNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1xuLy9SZXF1aXJlczogY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV9idWZmZXJcbmZ1bmN0aW9uIGNhbWxfYmFfZGVzZXJpYWxpemUocmVhZGVyLCBzeiwgbmFtZSl7XG4gIHZhciBudW1fZGltcyA9IHJlYWRlci5yZWFkMzJzKCk7XG4gIGlmIChudW1fZGltcyA8IDAgfHwgbnVtX2RpbXMgPiAxNilcbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IHdyb25nIG51bWJlciBvZiBiaWdhcnJheSBkaW1lbnNpb25zXCIpO1xuICB2YXIgdGFnID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgdmFyIGtpbmQgPSB0YWcgJiAweGZmXG4gIHZhciBsYXlvdXQgPSAodGFnID4+IDgpICYgMTtcbiAgdmFyIGRpbXMgPSBbXVxuICBpZihuYW1lID09IFwiX2JpZ2FycjAyXCIpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSB7XG4gICAgICB2YXIgc2l6ZV9kaW0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgICAgaWYoc2l6ZV9kaW0gPT0gMHhmZmZmKXtcbiAgICAgICAgdmFyIHNpemVfZGltX2hpID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgdmFyIHNpemVfZGltX2xvID0gcmVhZGVyLnJlYWQzMnUoKTtcbiAgICAgICAgaWYoc2l6ZV9kaW1faGkgIT0gMClcbiAgICAgICAgICBjYW1sX2ZhaWx3aXRoKFwiaW5wdXRfdmFsdWU6IGJpZ2FycmF5IGRpbWVuc2lvbiBvdmVyZmxvdyBpbiAzMmJpdFwiKTtcbiAgICAgICAgc2l6ZV9kaW0gPSBzaXplX2RpbV9sbztcbiAgICAgIH1cbiAgICAgIGRpbXMucHVzaChzaXplX2RpbSk7XG4gICAgfVxuICBlbHNlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZGltczsgaSsrKSBkaW1zLnB1c2gocmVhZGVyLnJlYWQzMnUoKSk7XG4gIHZhciBzaXplID0gY2FtbF9iYV9nZXRfc2l6ZShkaW1zKTtcbiAgdmFyIGRhdGEgPSBjYW1sX2JhX2NyZWF0ZV9idWZmZXIoa2luZCwgc2l6ZSk7XG4gIHZhciBiYSA9IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZShraW5kLCBsYXlvdXQsIGRpbXMsIGRhdGEpO1xuICBzd2l0Y2goa2luZCl7XG4gIGNhc2UgMjogIC8vSW50OEFycmF5XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQ4cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2cygpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgIGRhdGFbaV0gPSByZWFkZXIucmVhZDE2dSgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSA2OiAgLy8gSW50MzJBcnJheSAoaW50MzIpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBkYXRhW2ldID0gcmVhZGVyLnJlYWQzMnMoKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgODogIC8vIEludDMyQXJyYXkgKGludClcbiAgY2FzZSA5OiAgLy8gSW50MzJBcnJheSAobmF0aXZlaW50KVxuICAgIHZhciBzaXh0eSA9IHJlYWRlci5yZWFkOHUoKTtcbiAgICBpZihzaXh0eSkgY2FtbF9mYWlsd2l0aChcImlucHV0X3ZhbHVlOiBjYW5ub3QgcmVhZCBiaWdhcnJheSB3aXRoIDY0LWJpdCBPQ2FtbCBpbnRzXCIpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZGF0YVtpXSA9IHJlYWRlci5yZWFkMzJzKCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICBjYXNlIDc6IC8vIChpbnQ2NClcbiAgICB2YXIgdCA9IG5ldyBBcnJheSg4KTs7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKyl7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgODtqKyspIHRbal0gPSByZWFkZXIucmVhZDh1KCk7XG4gICAgICB2YXIgaW50NjQgPSBjYW1sX2ludDY0X29mX2J5dGVzKHQpO1xuICAgICAgYmEuc2V0KGksaW50NjQpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxOiAgLy8gRmxvYXQ2NEFycmF5XG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHMoY2FtbF9pbnQ2NF9vZl9ieXRlcyh0KSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMDogIC8vIEZsb2F0MzJBcnJheVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIGYgPSBjYW1sX2ludDMyX2Zsb2F0X29mX2JpdHMocmVhZGVyLnJlYWQzMnMoKSk7XG4gICAgICBiYS5zZXQoaSxmKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzKHJlYWRlci5yZWFkMzJzKCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgdmFyIHQgPSBuZXcgQXJyYXkoOCk7O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspe1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIHJlID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7aiA8IDg7aisrKSB0W2pdID0gcmVhZGVyLnJlYWQ4dSgpO1xuICAgICAgdmFyIGltID0gY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzKGNhbWxfaW50NjRfb2ZfYnl0ZXModCkpO1xuICAgICAgYmEuc2V0KGksWzI1NCxyZSxpbV0pO1xuICAgIH1cbiAgICBicmVha1xuICB9XG4gIHN6WzBdID0gKDQgKyBudW1fZGltcykgKiA0O1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YSk7XG59XG5cbi8vRGVwcmVjYXRlZFxuLy9Qcm92aWRlczogY2FtbF9iYV9jcmVhdGVfZnJvbVxuLy9SZXF1aXJlczogY2FtbF9iYV9jcmVhdGVfdW5zYWZlLCBjYW1sX2ludmFsaWRfYXJndW1lbnQsIGNhbWxfYmFfZ2V0X3NpemVfcGVyX2VsZW1lbnRcbmZ1bmN0aW9uIGNhbWxfYmFfY3JlYXRlX2Zyb20oZGF0YTEsIGRhdGEyLCBqc3R5cCwga2luZCwgbGF5b3V0LCBkaW1zKXtcbiAgaWYoZGF0YTIgfHwgY2FtbF9iYV9nZXRfc2l6ZV9wZXJfZWxlbWVudChraW5kKSA9PSAyKXtcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjYW1sX2JhX2NyZWF0ZV9mcm9tOiB1c2UgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVwiKTtcbiAgfVxuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIGxheW91dCwgZGltcywgZGF0YTEpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX2hhc2ggY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfYmFfZ2V0X3NpemUsIGNhbWxfaGFzaF9taXhfaW50LCBjYW1sX2hhc2hfbWl4X2Zsb2F0XG5mdW5jdGlvbiBjYW1sX2JhX2hhc2goYmEpe1xuICB2YXIgbnVtX2VsdHMgPSBjYW1sX2JhX2dldF9zaXplKGJhLmRpbXMpO1xuICB2YXIgaCA9IDA7XG4gIHN3aXRjaChiYS5raW5kKXtcbiAgY2FzZSAyOiAgLy9JbnQ4QXJyYXlcbiAgY2FzZSAzOiAgLy9VaW50OEFycmF5XG4gIGNhc2UgMTI6IC8vVWludDhBcnJheVxuICAgIGlmKG51bV9lbHRzID4gMjU2KSBudW1fZWx0cyA9IDI1NjtcbiAgICB2YXIgdyA9IDAsIGkgPTA7XG4gICAgZm9yKGkgPSAwOyBpICsgNCA8PSBiYS5kYXRhLmxlbmd0aDsgaSs9NCl7XG4gICAgICB3ID0gYmEuZGF0YVtpKzBdIHwgKGJhLmRhdGFbaSsxXSA8PCA4KSB8IChiYS5kYXRhW2krMl0gPDwgMTYpIHwgKGJhLmRhdGFbaSszXSA8PCAyNCk7XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCx3KTtcbiAgICB9XG4gICAgdyA9IDA7XG4gICAgc3dpdGNoIChudW1fZWx0cyAmIDMpIHtcbiAgICBjYXNlIDM6IHcgID0gYmEuZGF0YVtpKzJdIDw8IDE2OyAgICAvKiBmYWxsdGhyb3VnaCAqL1xuICAgIGNhc2UgMjogdyB8PSBiYS5kYXRhW2krMV0gPDwgODsgICAgIC8qIGZhbGx0aHJvdWdoICovXG4gICAgY2FzZSAxOiB3IHw9IGJhLmRhdGFbaSswXTtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgNDogIC8vIEludDE2QXJyYXlcbiAgY2FzZSA1OiAgLy8gVWludDE2QXJyYXlcbiAgICBpZihudW1fZWx0cyA+IDEyOCkgbnVtX2VsdHMgPSAxMjg7XG4gICAgdmFyIHcgPSAwLCBpID0wO1xuICAgIGZvcihpID0gMDsgaSArIDIgPD0gYmEuZGF0YS5sZW5ndGg7IGkrPTIpe1xuICAgICAgdyA9IGJhLmRhdGFbaSswXSB8IChiYS5kYXRhW2krMV0gPDwgMTYpO1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsdyk7XG4gICAgfVxuICAgIGlmICgobnVtX2VsdHMgJiAxKSAhPSAwKVxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICBjYXNlIDY6ICAvLyBJbnQzMkFycmF5IChpbnQzMilcbiAgICBpZiAobnVtX2VsdHMgPiA2NCkgbnVtX2VsdHMgPSA2NDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSA4OiAgLy8gSW50MzJBcnJheSAoaW50KVxuICBjYXNlIDk6ICAvLyBJbnQzMkFycmF5IChuYXRpdmVpbnQpXG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgYmEuZGF0YVtpXSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNzogIC8vIEludDMyQXJyYXkgKGludDY0KVxuICAgIGlmIChudW1fZWx0cyA+IDMyKSBudW1fZWx0cyA9IDMyO1xuICAgIG51bV9lbHRzICo9IDJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBiYS5kYXRhW2ldKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gIGNhc2UgMTA6IC8vIEZsb2F0MzJBcnJheSAoY29tcGxleDMyKVxuICAgIG51bV9lbHRzICo9MjsgLyogZmFsbHRocm91Z2ggKi9cbiAgY2FzZSAwOiAgLy8gRmxvYXQzMkFycmF5XG4gICAgaWYgKG51bV9lbHRzID4gNjQpIG51bV9lbHRzID0gNjQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1fZWx0czsgaSsrKSBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLCBiYS5kYXRhW2ldKTtcbiAgICBicmVhaztcbiAgY2FzZSAxMTogLy8gRmxvYXQ2NEFycmF5IChjb21wbGV4NjQpXG4gICAgbnVtX2VsdHMgKj0yOyAvKiBmYWxsdGhyb3VnaCAqL1xuICBjYXNlIDE6ICAvLyBGbG9hdDY0QXJyYXlcbiAgICBpZiAobnVtX2VsdHMgPiAzMikgbnVtX2VsdHMgPSAzMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bV9lbHRzOyBpKyspIGggPSBjYW1sX2hhc2hfbWl4X2Zsb2F0KGgsIGJhLmRhdGFbaV0pO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBoO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JhX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYmFfdG9fdHlwZWRfYXJyYXkoYmEpe1xuICByZXR1cm4gYmEuZGF0YTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5IG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF9iYV9raW5kX29mX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgdmFyIGtpbmQ7XG4gIGlmICh0YSBpbnN0YW5jZW9mIGcuRmxvYXQzMkFycmF5KSBraW5kID0gMDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkZsb2F0NjRBcnJheSkga2luZCA9IDE7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQ4QXJyYXkpIGtpbmQgPSAyO1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDhBcnJheSkga2luZCA9IDM7XG4gIGVsc2UgaWYgKHRhIGluc3RhbmNlb2YgZy5JbnQxNkFycmF5KSBraW5kID0gNDtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLlVpbnQxNkFycmF5KSBraW5kID0gNTtcbiAgZWxzZSBpZiAodGEgaW5zdGFuY2VvZiBnLkludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGlmICh0YSBpbnN0YW5jZW9mIGcuVWludDMyQXJyYXkpIGtpbmQgPSA2O1xuICBlbHNlIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmFfa2luZF9vZl90eXBlZF9hcnJheTogdW5zdXBwb3J0ZWQga2luZFwiKTtcbiAgcmV0dXJuIGtpbmQ7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmFfZnJvbV90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gY2FtbF9iYV9mcm9tX3R5cGVkX2FycmF5KHRhKXtcbiAgdmFyIGtpbmQgPSBjYW1sX2JhX2tpbmRfb2ZfdHlwZWRfYXJyYXkodGEpO1xuICByZXR1cm4gY2FtbF9iYV9jcmVhdGVfdW5zYWZlKGtpbmQsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBsaWJyYXJ5XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vLy8vLy8vLy8vLy8gSnNsaWJcblxuLy9Qcm92aWRlczogY2FtbF9qc19wdXJlX2V4cHIgY29uc3RcbmZ1bmN0aW9uIGNhbWxfanNfcHVyZV9leHByIChmKSB7IHJldHVybiBmKCk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19zZXQgKG11dGFibGUsIGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfc2V0KG8sZix2KSB7IG9bZl09djtyZXR1cm4gMH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZ2V0IG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZ2V0KG8sZikgeyByZXR1cm4gb1tmXTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19kZWxldGUgKG11dGFibGUsIGNvbnN0KVxuZnVuY3Rpb24gY2FtbF9qc19kZWxldGUobyxmKSB7IGRlbGV0ZSBvW2ZdOyByZXR1cm4gMH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19pbnN0YW5jZW9mIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2luc3RhbmNlb2YobyxjKSB7IHJldHVybiBvIGluc3RhbmNlb2YgYzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3R5cGVvZiAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3R5cGVvZihvKSB7IHJldHVybiB0eXBlb2YgbzsgfVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29uX2llIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2pzX29uX2llICgpIHtcbiAgdmFyIHVhID1cbiAgICAgIGpvb19nbG9iYWxfb2JqZWN0Lm5hdmlnYXRvcj9qb29fZ2xvYmFsX29iamVjdC5uYXZpZ2F0b3IudXNlckFnZW50OlwiXCI7XG4gIHJldHVybiB1YS5pbmRleE9mKFwiTVNJRVwiKSAhPSAtMSAmJiB1YS5pbmRleE9mKFwiT3BlcmFcIikgIT0gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9qc19odG1sX2VzY2FwZSBjb25zdCAoY29uc3QpXG52YXIgY2FtbF9qc19yZWdleHBzID0geyBhbXA6LyYvZywgbHQ6LzwvZywgcXVvdDovXFxcIi9nLCBhbGw6L1smPFxcXCJdLyB9O1xuZnVuY3Rpb24gY2FtbF9qc19odG1sX2VzY2FwZSAocykge1xuICBpZiAoIWNhbWxfanNfcmVnZXhwcy5hbGwudGVzdChzKSkgcmV0dXJuIHM7XG4gIHJldHVybiBzLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLmFtcCwgXCImYW1wO1wiKVxuICAgIC5yZXBsYWNlKGNhbWxfanNfcmVnZXhwcy5sdCwgXCImbHQ7XCIpXG4gICAgLnJlcGxhY2UoY2FtbF9qc19yZWdleHBzLnF1b3QsIFwiJnF1b3Q7XCIpO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2h0bWxfZW50aXRpZXNcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfanNfaHRtbF9lbnRpdGllcyhzKSB7XG4gIHZhciBlbnRpdHkgPSAvXiYjP1swLTlhLXpBLVpdKzskL1xuICBpZihzLm1hdGNoKGVudGl0eSkpXG4gIHtcbiAgICB2YXIgc3RyLCB0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgIHRlbXAuaW5uZXJIVE1MPSBzO1xuICAgIHN0cj0gdGVtcC50ZXh0Q29udGVudCB8fCB0ZW1wLmlubmVyVGV4dDtcbiAgICB0ZW1wPW51bGw7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBlbHNlIHtcbiAgICBjYW1sX2ZhaWx3aXRoKFwiSW52YWxpZCBlbnRpdHkgXCIgKyBzKTtcbiAgfVxufVxuXG4vLy8vLy8vLy8vLyBEZWJ1Z2dpbmcgY29uc29sZVxuLy9Qcm92aWRlczogY2FtbF9qc19nZXRfY29uc29sZSBjb25zdFxuZnVuY3Rpb24gY2FtbF9qc19nZXRfY29uc29sZSAoKSB7XG4gIHZhciBjID0gam9vX2dsb2JhbF9vYmplY3QuY29uc29sZT9qb29fZ2xvYmFsX29iamVjdC5jb25zb2xlOnt9O1xuICB2YXIgbSA9IFtcImxvZ1wiLCBcImRlYnVnXCIsIFwiaW5mb1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcImFzc2VydFwiLCBcImRpclwiLCBcImRpcnhtbFwiLFxuICAgICAgICAgICBcInRyYWNlXCIsIFwiZ3JvdXBcIiwgXCJncm91cENvbGxhcHNlZFwiLCBcImdyb3VwRW5kXCIsIFwidGltZVwiLCBcInRpbWVFbmRcIl07XG4gIGZ1bmN0aW9uIGYgKCkge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSBpZiAoIWNbbVtpXV0pIGNbbVtpXV09ZjtcbiAgcmV0dXJuIGM7XG59XG5cbi8vUHJvdmlkZXM6Y2FtbF90cmFtcG9saW5lXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmUocmVzKSB7XG4gIHZhciBjID0gMTtcbiAgd2hpbGUocmVzICYmIHJlcy5qb29fdHJhbXApe1xuICAgIHJlcyA9IHJlcy5qb29fdHJhbXAuYXBwbHkobnVsbCwgcmVzLmpvb19hcmdzKTtcbiAgICBjKys7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy9Qcm92aWRlczpjYW1sX3RyYW1wb2xpbmVfcmV0dXJuXG5mdW5jdGlvbiBjYW1sX3RyYW1wb2xpbmVfcmV0dXJuKGYsYXJncykge1xuICByZXR1cm4ge2pvb190cmFtcDpmLGpvb19hcmdzOmFyZ3N9O1xufVxuXG4vL1Byb3ZpZGVzOiBqc19wcmludF9zdGRvdXQgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF91dGYxNl9vZl91dGY4XG5mdW5jdGlvbiBqc19wcmludF9zdGRvdXQocykge1xuICB2YXIgcyA9IGNhbWxfdXRmMTZfb2ZfdXRmOChzKTtcbiAgdmFyIGcgPSBqb29fZ2xvYmFsX29iamVjdDtcbiAgaWYgKGcucHJvY2VzcyAmJiBnLnByb2Nlc3Muc3Rkb3V0ICYmIGcucHJvY2Vzcy5zdGRvdXQud3JpdGUpIHtcbiAgICBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKHMpXG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IG91dHB1dCB0aGUgbGFzdCBcXG4gaWYgcHJlc2VudFxuICAgIC8vIGFzIGNvbnNvbGUgbG9nZ2luZyBkaXNwbGF5IGEgbmV3bGluZSBhdCB0aGUgZW5kXG4gICAgaWYocy5jaGFyQ29kZUF0KHMubGVuZ3RoIC0gMSkgPT0gMTApXG4gICAgICBzID0gcy5zdWJzdHIoMCxzLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgdiA9IGcuY29uc29sZTtcbiAgICB2ICAmJiB2LmxvZyAmJiB2LmxvZyhzKTtcbiAgfVxufVxuLy9Qcm92aWRlczoganNfcHJpbnRfc3RkZXJyIChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfdXRmMTZfb2ZfdXRmOFxuZnVuY3Rpb24ganNfcHJpbnRfc3RkZXJyKHMpIHtcbiAgdmFyIHMgPSBjYW1sX3V0ZjE2X29mX3V0Zjgocyk7XG4gIHZhciBnID0gam9vX2dsb2JhbF9vYmplY3Q7XG4gIGlmIChnLnByb2Nlc3MgJiYgZy5wcm9jZXNzLnN0ZG91dCAmJiBnLnByb2Nlc3Muc3Rkb3V0LndyaXRlKSB7XG4gICAgZy5wcm9jZXNzLnN0ZGVyci53cml0ZShzKVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBvdXRwdXQgdGhlIGxhc3QgXFxuIGlmIHByZXNlbnRcbiAgICAvLyBhcyBjb25zb2xlIGxvZ2dpbmcgZGlzcGxheSBhIG5ld2xpbmUgYXQgdGhlIGVuZFxuICAgIGlmKHMuY2hhckNvZGVBdChzLmxlbmd0aCAtIDEpID09IDEwKVxuICAgICAgcyA9IHMuc3Vic3RyKDAscy5sZW5ndGggLSAxICk7XG4gICAgdmFyIHYgPSBnLmNvbnNvbGU7XG4gICAgdiAmJiB2LmVycm9yICYmIHYuZXJyb3Iocyk7XG4gIH1cbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2lzX2pzXG5mdW5jdGlvbiBjYW1sX2lzX2pzKCkge1xuICByZXR1cm4gMTtcbn1cblxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfd3JhcF9leGNlcHRpb24gY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9nbG9iYWxfZGF0YSxjYW1sX3N0cmluZ19vZl9qc3N0cmluZyxjYW1sX25hbWVkX3ZhbHVlXG4vL1JlcXVpcmVzOiBjYW1sX3JldHVybl9leG5fY29uc3RhbnRcbmZ1bmN0aW9uIGNhbWxfd3JhcF9leGNlcHRpb24oZSkge1xuICBpZihlIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiBlO1xuICAvL1N0YWNrX292ZXJmbG93OiBjaHJvbWUsIHNhZmFyaVxuICBpZihqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUgaW5zdGFuY2VvZiBqb29fZ2xvYmFsX29iamVjdC5SYW5nZUVycm9yXG4gICAgICYmIGUubWVzc2FnZVxuICAgICAmJiBlLm1lc3NhZ2UubWF0Y2goL21heGltdW0gY2FsbCBzdGFjay9pKSlcbiAgICByZXR1cm4gY2FtbF9yZXR1cm5fZXhuX2NvbnN0YW50KGNhbWxfZ2xvYmFsX2RhdGEuU3RhY2tfb3ZlcmZsb3cpO1xuICAvL1N0YWNrX292ZXJmbG93OiBmaXJlZm94XG4gIGlmKGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkludGVybmFsRXJyb3JcbiAgICAgJiYgZS5tZXNzYWdlXG4gICAgICYmIGUubWVzc2FnZS5tYXRjaCgvdG9vIG11Y2ggcmVjdXJzaW9uL2kpKVxuICAgIHJldHVybiBjYW1sX3JldHVybl9leG5fY29uc3RhbnQoY2FtbF9nbG9iYWxfZGF0YS5TdGFja19vdmVyZmxvdyk7XG4gIC8vV3JhcCBFcnJvciBpbiBKcy5FcnJvciBleGNlcHRpb25cbiAgaWYoZSBpbnN0YW5jZW9mIGpvb19nbG9iYWxfb2JqZWN0LkVycm9yICYmIGNhbWxfbmFtZWRfdmFsdWUoXCJqc0Vycm9yXCIpKVxuICAgIHJldHVybiBbMCxjYW1sX25hbWVkX3ZhbHVlKFwianNFcnJvclwiKSxlXTtcbiAgLy9mYWxsYmFjazogd3JhcHBlZCBpbiBGYWlsdXJlXG4gIHJldHVybiBbMCxjYW1sX2dsb2JhbF9kYXRhLkZhaWx1cmUsY2FtbF9zdHJpbmdfb2ZfanNzdHJpbmcgKFN0cmluZyhlKSldO1xufVxuXG4vLyBFeHBlcmltZW50YWxcbi8vUHJvdmlkZXM6IGNhbWxfZXhuX3dpdGhfanNfYmFja3RyYWNlXG4vL1JlcXVpcmVzOiBjYW1sX2dsb2JhbF9kYXRhXG5mdW5jdGlvbiBjYW1sX2V4bl93aXRoX2pzX2JhY2t0cmFjZShleG4sIGZvcmNlKSB7XG4gIC8vbmV2ZXIgcmVyYWlzZSBmb3IgY29uc3RhbnQgZXhuXG4gIGlmKCFleG4uanNfZXJyb3IgfHwgZm9yY2UgfHwgZXhuWzBdID09IDI0OCkgZXhuLmpzX2Vycm9yID0gbmV3IGpvb19nbG9iYWxfb2JqZWN0LkVycm9yKFwiSnMgZXhjZXB0aW9uIGNvbnRhaW5pbmcgYmFja3RyYWNlXCIpO1xuICByZXR1cm4gZXhuO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Vycm9yX29mX2V4Y2VwdGlvblxuZnVuY3Rpb24gY2FtbF9qc19lcnJvcl9vZl9leGNlcHRpb24oZXhuKSB7XG4gIGlmKGV4bi5qc19lcnJvcikgeyByZXR1cm4gZXhuLmpzX2Vycm9yOyB9XG4gIHJldHVybiBudWxsO1xufVxuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RpdmUgQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyogIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAqL1xuLyogIGVuIEF1dG9tYXRpcXVlLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCAgICAqL1xuLyogIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB3aXRoICAgICAqL1xuLyogIHRoZSBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiBmaWxlIC4uL0xJQ0VOU0UuICAgICAqL1xuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiAkSWQ6IHBhcnNpbmcuYyA4OTgzIDIwMDgtMDgtMDYgMDk6Mzg6MjVaIHhsZXJveSAkICovXG5cbi8qIFRoZSBQREEgYXV0b21hdG9uIGZvciBwYXJzZXJzIGdlbmVyYXRlZCBieSBjYW1seWFjYyAqL1xuXG4vKiBUaGUgcHVzaGRvd24gYXV0b21hdGEgKi9cblxuLy9Qcm92aWRlczogY2FtbF9wYXJzZV9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfbGV4X2FycmF5XG5mdW5jdGlvbiBjYW1sX3BhcnNlX2VuZ2luZSh0YWJsZXMsIGVudiwgY21kLCBhcmcpXG57XG4gIHZhciBFUlJDT0RFID0gMjU2O1xuXG4gIC8vdmFyIFNUQVJUID0gMDtcbiAgLy92YXIgVE9LRU5fUkVBRCA9IDE7XG4gIC8vdmFyIFNUQUNLU19HUk9XTl8xID0gMjtcbiAgLy92YXIgU1RBQ0tTX0dST1dOXzIgPSAzO1xuICAvL3ZhciBTRU1BTlRJQ19BQ1RJT05fQ09NUFVURUQgPSA0O1xuICAvL3ZhciBFUlJPUl9ERVRFQ1RFRCA9IDU7XG4gIHZhciBsb29wID0gNjtcbiAgdmFyIHRlc3RzaGlmdCA9IDc7XG4gIHZhciBzaGlmdCA9IDg7XG4gIHZhciBzaGlmdF9yZWNvdmVyID0gOTtcbiAgdmFyIHJlZHVjZSA9IDEwO1xuXG4gIHZhciBSRUFEX1RPS0VOID0gMDtcbiAgdmFyIFJBSVNFX1BBUlNFX0VSUk9SID0gMTtcbiAgdmFyIEdST1dfU1RBQ0tTXzEgPSAyO1xuICB2YXIgR1JPV19TVEFDS1NfMiA9IDM7XG4gIHZhciBDT01QVVRFX1NFTUFOVElDX0FDVElPTiA9IDQ7XG4gIHZhciBDQUxMX0VSUk9SX0ZVTkNUSU9OID0gNTtcblxuICB2YXIgZW52X3Nfc3RhY2sgPSAxO1xuICB2YXIgZW52X3Zfc3RhY2sgPSAyO1xuICB2YXIgZW52X3N5bWJfc3RhcnRfc3RhY2sgPSAzO1xuICB2YXIgZW52X3N5bWJfZW5kX3N0YWNrID0gNDtcbiAgdmFyIGVudl9zdGFja3NpemUgPSA1O1xuICB2YXIgZW52X3N0YWNrYmFzZSA9IDY7XG4gIHZhciBlbnZfY3Vycl9jaGFyID0gNztcbiAgdmFyIGVudl9sdmFsID0gODtcbiAgdmFyIGVudl9zeW1iX3N0YXJ0ID0gOTtcbiAgdmFyIGVudl9zeW1iX2VuZCA9IDEwO1xuICB2YXIgZW52X2FzcCA9IDExO1xuICB2YXIgZW52X3J1bGVfbGVuID0gMTI7XG4gIHZhciBlbnZfcnVsZV9udW1iZXIgPSAxMztcbiAgdmFyIGVudl9zcCA9IDE0O1xuICB2YXIgZW52X3N0YXRlID0gMTU7XG4gIHZhciBlbnZfZXJyZmxhZyA9IDE2O1xuXG4gIC8vIHZhciBfdGJsX2FjdGlvbnMgPSAxO1xuICB2YXIgdGJsX3RyYW5zbF9jb25zdCA9IDI7XG4gIHZhciB0YmxfdHJhbnNsX2Jsb2NrID0gMztcbiAgdmFyIHRibF9saHMgPSA0O1xuICB2YXIgdGJsX2xlbiA9IDU7XG4gIHZhciB0YmxfZGVmcmVkID0gNjtcbiAgdmFyIHRibF9kZ290byA9IDc7XG4gIHZhciB0Ymxfc2luZGV4ID0gODtcbiAgdmFyIHRibF9yaW5kZXggPSA5O1xuICB2YXIgdGJsX2dpbmRleCA9IDEwO1xuICB2YXIgdGJsX3RhYmxlc2l6ZSA9IDExO1xuICB2YXIgdGJsX3RhYmxlID0gMTI7XG4gIHZhciB0YmxfY2hlY2sgPSAxMztcbiAgLy8gdmFyIF90YmxfZXJyb3JfZnVuY3Rpb24gPSAxNDtcbiAgLy8gdmFyIF90YmxfbmFtZXNfY29uc3QgPSAxNTtcbiAgLy8gdmFyIF90YmxfbmFtZXNfYmxvY2sgPSAxNjtcblxuICBpZiAoIXRhYmxlcy5kZ290bykge1xuICAgIHRhYmxlcy5kZWZyZWQgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZWZyZWRdKTtcbiAgICB0YWJsZXMuc2luZGV4ID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0Ymxfc2luZGV4XSk7XG4gICAgdGFibGVzLmNoZWNrICA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2NoZWNrXSk7XG4gICAgdGFibGVzLnJpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX3JpbmRleF0pO1xuICAgIHRhYmxlcy50YWJsZSAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF90YWJsZV0pO1xuICAgIHRhYmxlcy5sZW4gICAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9sZW5dKTtcbiAgICB0YWJsZXMubGhzICAgID0gY2FtbF9sZXhfYXJyYXkgKHRhYmxlc1t0YmxfbGhzXSk7XG4gICAgdGFibGVzLmdpbmRleCA9IGNhbWxfbGV4X2FycmF5ICh0YWJsZXNbdGJsX2dpbmRleF0pO1xuICAgIHRhYmxlcy5kZ290byAgPSBjYW1sX2xleF9hcnJheSAodGFibGVzW3RibF9kZ290b10pO1xuICB9XG5cbiAgdmFyIHJlcyA9IDAsIG4sIG4xLCBuMiwgc3RhdGUxO1xuXG4gIC8vIFJFU1RPUkVcbiAgdmFyIHNwID0gZW52W2Vudl9zcF07XG4gIHZhciBzdGF0ZSA9IGVudltlbnZfc3RhdGVdO1xuICB2YXIgZXJyZmxhZyA9IGVudltlbnZfZXJyZmxhZ107XG5cbiAgZXhpdDpmb3IgKDs7KSB7XG4gICAgc3dpdGNoKGNtZCkge1xuICAgIGNhc2UgMDovL1NUQVJUOlxuICAgICAgc3RhdGUgPSAwO1xuICAgICAgZXJyZmxhZyA9IDA7XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNjovL2xvb3A6XG4gICAgICBuID0gdGFibGVzLmRlZnJlZFtzdGF0ZV07XG4gICAgICBpZiAobiAhPSAwKSB7IGNtZCA9IHJlZHVjZTsgYnJlYWs7IH1cbiAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPj0gMCkgeyBjbWQgPSB0ZXN0c2hpZnQ7IGJyZWFrOyB9XG4gICAgICByZXMgPSBSRUFEX1RPS0VOO1xuICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBsZXhlciBhbmQgdXBkYXRlcyAqL1xuICAgICAgLyogc3ltYl9zdGFydCBhbmQgc3ltYl9lbmQgKi9cbiAgICBjYXNlIDE6Ly9UT0tFTl9SRUFEOlxuICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2Jsb2NrXVthcmdbMF0gKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IGFyZ1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudltlbnZfY3Vycl9jaGFyXSA9IHRhYmxlc1t0YmxfdHJhbnNsX2NvbnN0XVthcmcgKyAxXTtcbiAgICAgICAgZW52W2Vudl9sdmFsXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgNzovL3Rlc3RzaGlmdDpcbiAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZV07XG4gICAgICBuMiA9IG4xICsgZW52W2Vudl9jdXJyX2NoYXJdO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IGVudltlbnZfY3Vycl9jaGFyXSkge1xuICAgICAgICBjbWQgPSBzaGlmdDsgYnJlYWs7XG4gICAgICB9XG4gICAgICBuMSA9IHRhYmxlcy5yaW5kZXhbc3RhdGVdO1xuICAgICAgbjIgPSBuMSArIGVudltlbnZfY3Vycl9jaGFyXTtcbiAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgdGFibGVzLmNoZWNrW24yXSA9PSBlbnZbZW52X2N1cnJfY2hhcl0pIHtcbiAgICAgICAgbiA9IHRhYmxlcy50YWJsZVtuMl07XG4gICAgICAgIGNtZCA9IHJlZHVjZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXJyZmxhZyA8PSAwKSB7XG4gICAgICAgIHJlcyA9IENBTExfRVJST1JfRlVOQ1RJT047XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIGNhbGxzIHRoZSBlcnJvciBmdW5jdGlvbiAqL1xuICAgIGNhc2UgNTovL0VSUk9SX0RFVEVDVEVEOlxuICAgICAgaWYgKGVycmZsYWcgPCAzKSB7XG4gICAgICAgIGVycmZsYWcgPSAzO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdO1xuICAgICAgICAgIG4xID0gdGFibGVzLnNpbmRleFtzdGF0ZTFdO1xuICAgICAgICAgIG4yID0gbjEgKyBFUlJDT0RFO1xuICAgICAgICAgIGlmIChuMSAhPSAwICYmIG4yID49IDAgJiYgbjIgPD0gdGFibGVzW3RibF90YWJsZXNpemVdICYmXG4gICAgICAgICAgICAgIHRhYmxlcy5jaGVja1tuMl0gPT0gRVJSQ09ERSkge1xuICAgICAgICAgICAgY21kID0gc2hpZnRfcmVjb3ZlcjsgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzcCA8PSBlbnZbZW52X3N0YWNrYmFzZV0pIHJldHVybiBSQUlTRV9QQVJTRV9FUlJPUjtcbiAgICAgICAgICAgIC8qIFRoZSBNTCBjb2RlIHJhaXNlcyBQYXJzZV9lcnJvciAqL1xuICAgICAgICAgICAgc3AtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbnZbZW52X2N1cnJfY2hhcl0gPT0gMCkgcmV0dXJuIFJBSVNFX1BBUlNFX0VSUk9SO1xuICAgICAgICAvKiBUaGUgTUwgY29kZSByYWlzZXMgUGFyc2VfZXJyb3IgKi9cbiAgICAgICAgZW52W2Vudl9jdXJyX2NoYXJdID0gLTE7XG4gICAgICAgIGNtZCA9IGxvb3A7IGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA4Oi8vc2hpZnQ6XG4gICAgICBlbnZbZW52X2N1cnJfY2hhcl0gPSAtMTtcbiAgICAgIGlmIChlcnJmbGFnID4gMCkgZXJyZmxhZy0tO1xuICAgICAgLy8gRmFsbCB0aHJvdWdoXG4gICAgY2FzZSA5Oi8vc2hpZnRfcmVjb3ZlcjpcbiAgICAgIHN0YXRlID0gdGFibGVzLnRhYmxlW24yXTtcbiAgICAgIHNwKys7XG4gICAgICBpZiAoc3AgPj0gZW52W2Vudl9zdGFja3NpemVdKSB7XG4gICAgICAgIHJlcyA9IEdST1dfU1RBQ0tTXzE7XG4gICAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICB9XG4gICAgICAvLyBGYWxsIHRocm91Z2hcbiAgICAgIC8qIFRoZSBNTCBjb2RlIHJlc2l6ZXMgdGhlIHN0YWNrcyAqL1xuICAgIGNhc2UgMjovL1NUQUNLU19HUk9XTl8xOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X2x2YWxdO1xuICAgICAgZW52W2Vudl9zeW1iX3N0YXJ0X3N0YWNrXVtzcCArIDFdID0gZW52W2Vudl9zeW1iX3N0YXJ0XTtcbiAgICAgIGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW3NwICsgMV0gPSBlbnZbZW52X3N5bWJfZW5kXTtcbiAgICAgIGNtZCA9IGxvb3A7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTA6Ly9yZWR1Y2U6XG4gICAgICB2YXIgbSA9IHRhYmxlcy5sZW5bbl07XG4gICAgICBlbnZbZW52X2FzcF0gPSBzcDtcbiAgICAgIGVudltlbnZfcnVsZV9udW1iZXJdID0gbjtcbiAgICAgIGVudltlbnZfcnVsZV9sZW5dID0gbTtcbiAgICAgIHNwID0gc3AgLSBtICsgMTtcbiAgICAgIG0gPSB0YWJsZXMubGhzW25dO1xuICAgICAgc3RhdGUxID0gZW52W2Vudl9zX3N0YWNrXVtzcF07XG4gICAgICBuMSA9IHRhYmxlcy5naW5kZXhbbV07XG4gICAgICBuMiA9IG4xICsgc3RhdGUxO1xuICAgICAgaWYgKG4xICE9IDAgJiYgbjIgPj0gMCAmJiBuMiA8PSB0YWJsZXNbdGJsX3RhYmxlc2l6ZV0gJiZcbiAgICAgICAgICB0YWJsZXMuY2hlY2tbbjJdID09IHN0YXRlMSlcbiAgICAgICAgc3RhdGUgPSB0YWJsZXMudGFibGVbbjJdO1xuICAgICAgZWxzZVxuICAgICAgICBzdGF0ZSA9IHRhYmxlcy5kZ290b1ttXTtcbiAgICAgIGlmIChzcCA+PSBlbnZbZW52X3N0YWNrc2l6ZV0pIHtcbiAgICAgICAgcmVzID0gR1JPV19TVEFDS1NfMjtcbiAgICAgICAgYnJlYWsgZXhpdDtcbiAgICAgIH1cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuICAgICAgLyogVGhlIE1MIGNvZGUgcmVzaXplcyB0aGUgc3RhY2tzICovXG4gICAgY2FzZSAzOi8vU1RBQ0tTX0dST1dOXzI6XG4gICAgICByZXMgPSBDT01QVVRFX1NFTUFOVElDX0FDVElPTjtcbiAgICAgIGJyZWFrIGV4aXQ7XG4gICAgICAvKiBUaGUgTUwgY29kZSBjYWxscyB0aGUgc2VtYW50aWMgYWN0aW9uICovXG4gICAgY2FzZSA0Oi8vU0VNQU5USUNfQUNUSU9OX0NPTVBVVEVEOlxuICAgICAgZW52W2Vudl9zX3N0YWNrXVtzcCArIDFdID0gc3RhdGU7XG4gICAgICBlbnZbZW52X3Zfc3RhY2tdW3NwICsgMV0gPSBhcmc7XG4gICAgICB2YXIgYXNwID0gZW52W2Vudl9hc3BdO1xuICAgICAgZW52W2Vudl9zeW1iX2VuZF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgaWYgKHNwID4gYXNwKSB7XG4gICAgICAgIC8qIFRoaXMgaXMgYW4gZXBzaWxvbiBwcm9kdWN0aW9uLiBUYWtlIHN5bWJfc3RhcnQgZXF1YWwgdG8gc3ltYl9lbmQuICovXG4gICAgICAgIGVudltlbnZfc3ltYl9zdGFydF9zdGFja11bc3AgKyAxXSA9IGVudltlbnZfc3ltYl9lbmRfc3RhY2tdW2FzcCArIDFdO1xuICAgICAgfVxuICAgICAgY21kID0gbG9vcDsgYnJlYWs7XG4gICAgICAvKiBTaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gUkFJU0VfUEFSU0VfRVJST1I7XG4gICAgfVxuICB9XG4gIC8vIFNBVkVcbiAgZW52W2Vudl9zcF0gPSBzcDtcbiAgZW52W2Vudl9zdGF0ZV0gPSBzdGF0ZTtcbiAgZW52W2Vudl9lcnJmbGFnXSA9IGVycmZsYWc7XG4gIHJldHVybiByZXM7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfc2V0X3BhcnNlcl90cmFjZSBjb25zdFxuLy9EdW1teSBmdW5jdGlvbiFcbmZ1bmN0aW9uIGNhbWxfc2V0X3BhcnNlcl90cmFjZSgpIHsgcmV0dXJuIDA7IH1cbiIsIi8vIEpzX29mX29jYW1sIGxpYnJhcnlcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBKc2xpYjogY29kZSBzcGVjaWZpYyB0byBKc19vZl9vY2FtbFxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2Zyb21fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYm9vbCh4KSB7IHJldHVybiAhIXg7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYm9vbCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Jvb2woeCkgeyByZXR1cm4gK3g7IH1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZnJvbV9mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fZmxvYXQoeCkgeyByZXR1cm4geDsgfVxuLy9Qcm92aWRlczogY2FtbF9qc190b19mbG9hdCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2pzX3RvX2Zsb2F0KHgpIHsgcmV0dXJuIHg7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19mcm9tX2FycmF5IG11dGFibGUgKHNoYWxsb3cpXG5mdW5jdGlvbiBjYW1sX2pzX2Zyb21fYXJyYXkoYSkge1xuICByZXR1cm4gYS5zbGljZSgxKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfdG9fYXJyYXkgbXV0YWJsZSAoc2hhbGxvdylcbmZ1bmN0aW9uIGNhbWxfanNfdG9fYXJyYXkoYSkge1xuICB2YXIgbGVuID0gYS5sZW5ndGg7XG4gIHZhciBiID0gbmV3IEFycmF5KGxlbisxKTtcbiAgYlswXSA9IDA7XG4gIGZvcih2YXIgaT0wO2k8bGVuO2krKykgYltpKzFdID0gYVtpXTtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGlzdF9vZl9qc19hcnJheSBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xpc3Rfb2ZfanNfYXJyYXkoYSl7XG4gIHZhciBsID0gMDtcbiAgZm9yKHZhciBpPWEubGVuZ3RoIC0gMTsgaT49MDsgaS0tKXtcbiAgICB2YXIgZSA9IGFbaV07XG4gICAgbCA9IFswLGUsbF07XG4gIH1cbiAgcmV0dXJuIGxcbn1cblxuLy9Qcm92aWRlczogY2FtbF9saXN0X3RvX2pzX2FycmF5IGNvbnN0IChjb25zdClcbmZ1bmN0aW9uIGNhbWxfbGlzdF90b19qc19hcnJheShsKXtcbiAgdmFyIGEgPSBbXTtcbiAgZm9yKDsgbCAhPT0gMDsgbCA9IGxbMl0pIHtcbiAgICBhLnB1c2gobFsxXSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfdmFyIG11dGFibGUgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc192YXIoeCkge1xuICB2YXIgeCA9IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHgpO1xuICAvL0NoZWNrcyB0aGF0IHggaGFzIHRoZSBmb3JtIGlkZW50Wy5pZGVudF0qXG4gIGlmKCF4Lm1hdGNoKC9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qKFxcLlthLXpBLVpfJF1bYS16QS1aXyQwLTldKikqJC8pKXtcbiAgICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX3ZhcjogXFxcIlwiICsgeCArIFwiXFxcIiBpcyBub3QgYSB2YWxpZCBKYXZhU2NyaXB0IHZhcmlhYmxlLiBjb250aW51aW5nIC4uXCIpO1xuICAgIC8vam9vX2dsb2JhbF9vYmplY3QuY29uc29sZS5lcnJvcihcIkpzLlVuc2FmZS5ldmFsX3N0cmluZ1wiKVxuICB9XG4gIHJldHVybiBldmFsKHgpO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc19jYWxsIChjb25zdCwgbXV0YWJsZSwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNfZnJvbV9hcnJheVxuZnVuY3Rpb24gY2FtbF9qc19jYWxsKGYsIG8sIGFyZ3MpIHsgcmV0dXJuIGYuYXBwbHkobywgY2FtbF9qc19mcm9tX2FycmF5KGFyZ3MpKTsgfVxuLy9Qcm92aWRlczogY2FtbF9qc19mdW5fY2FsbCAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfZnVuX2NhbGwoZiwgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMTogcmV0dXJuIGYoKTtcbiAgY2FzZSAyOiByZXR1cm4gZiAoYVsxXSk7XG4gIGNhc2UgMzogcmV0dXJuIGYgKGFbMV0sYVsyXSk7XG4gIGNhc2UgNDogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSk7XG4gIGNhc2UgNjogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSk7XG4gIGNhc2UgNzogcmV0dXJuIGYgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gZiAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdLGFbNl0sYVs3XSk7XG4gIH1cbiAgcmV0dXJuIGYuYXBwbHkobnVsbCwgY2FtbF9qc19mcm9tX2FycmF5KGEpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfbWV0aF9jYWxsIChtdXRhYmxlLCBjb25zdCwgc2hhbGxvdylcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbWV0aF9jYWxsKG8sIGYsIGFyZ3MpIHtcbiAgcmV0dXJuIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcoZildLmFwcGx5KG8sIGNhbWxfanNfZnJvbV9hcnJheShhcmdzKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX25ldyAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfanNfbmV3KGMsIGEpIHtcbiAgc3dpdGNoIChhLmxlbmd0aCkge1xuICBjYXNlIDE6IHJldHVybiBuZXcgYztcbiAgY2FzZSAyOiByZXR1cm4gbmV3IGMgKGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdKTtcbiAgY2FzZSA0OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdKTtcbiAgY2FzZSA1OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVsxXSxhWzJdLGFbM10sYVs0XSxhWzVdKTtcbiAgY2FzZSA3OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdKTtcbiAgY2FzZSA4OiByZXR1cm4gbmV3IGMgKGFbMV0sYVsyXSxhWzNdLGFbNF0sYVs1XSxhWzZdLGFbN10pO1xuICB9XG4gIGZ1bmN0aW9uIEYoKSB7IHJldHVybiBjLmFwcGx5KHRoaXMsIGNhbWxfanNfZnJvbV9hcnJheShhKSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9vanNfbmV3X2FyciAoY29uc3QsIHNoYWxsb3cpXG4vL1JlcXVpcmVzOiBjYW1sX2pzX2Zyb21fYXJyYXlcbmZ1bmN0aW9uIGNhbWxfb2pzX25ld19hcnIoYywgYSkge1xuICBzd2l0Y2ggKGEubGVuZ3RoKSB7XG4gIGNhc2UgMDogcmV0dXJuIG5ldyBjO1xuICBjYXNlIDE6IHJldHVybiBuZXcgYyAoYVswXSk7XG4gIGNhc2UgMjogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0pO1xuICBjYXNlIDM6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0pO1xuICBjYXNlIDQ6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSk7XG4gIGNhc2UgNTogcmV0dXJuIG5ldyBjIChhWzBdLGFbMV0sYVsyXSxhWzNdLGFbNF0pO1xuICBjYXNlIDY6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0pO1xuICBjYXNlIDc6IHJldHVybiBuZXcgYyAoYVswXSxhWzFdLGFbMl0sYVszXSxhWzRdLGFbNV0sYVs2XSk7XG4gIH1cbiAgZnVuY3Rpb24gRigpIHsgcmV0dXJuIGMuYXBwbHkodGhpcywgYSk7IH1cbiAgRi5wcm90b3R5cGUgPSBjLnByb3RvdHlwZTtcbiAgcmV0dXJuIG5ldyBGO1xufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX2NhbGxiYWNrIGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobGVuID4gMCl7XG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLCBbdW5kZWZpbmVkXSk7XG4gICAgfVxuICB9XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHNcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsIFthcmdzXSk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QgY29uc3Rcbi8vUmVxdWlyZXM6IGNhbWxfY2FsbF9nZW5cbmZ1bmN0aW9uIGNhbWxfanNfd3JhcF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYobiA9PSBhcml0eSAmJiBmLmxlbmd0aCA9PSBhcml0eSkgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGgsIGFyaXR5KVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFjayhmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobGVuICsgMSk7XG4gICAgYXJnc1swXSA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpKzFdID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBjYW1sX2NhbGxfZ2VuKGYsYXJncyk7XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfd3JhcF9tZXRoX2NhbGxiYWNrX2FyZ3VtZW50cyBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19hcmd1bWVudHMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICByZXR1cm4gY2FtbF9jYWxsX2dlbihmLFt0aGlzLGFyZ3NdKTtcbiAgfVxufVxuLy9Qcm92aWRlczogY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfc3RyaWN0IGNvbnN0XG4vL1JlcXVpcmVzOiBjYW1sX2NhbGxfZ2VuXG5mdW5jdGlvbiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja19zdHJpY3QoYXJpdHksIGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcml0eSArIDEpO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcmd1bWVudHMubGVuZ3RoLCBhcml0eSlcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGNhbWxfY2FsbF9nZW4oZiwgYXJncyk7XG4gIH07XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2pzX3dyYXBfbWV0aF9jYWxsYmFja191bnNhZmUgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jYWxsX2dlblxuZnVuY3Rpb24gY2FtbF9qc193cmFwX21ldGhfY2FsbGJhY2tfdW5zYWZlKGYpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShsZW4gKyAxKTtcbiAgICBhcmdzWzBdID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBhcmdzW2krMV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncyk7IH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXF1YWxzIG11dGFibGUgKGNvbnN0LCBjb25zdClcbmZ1bmN0aW9uIGNhbWxfanNfZXF1YWxzICh4LCB5KSB7IHJldHVybiArKHggPT0geSk7IH1cblxuLy9Qcm92aWRlczogY2FtbF9qc19ldmFsX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19ldmFsX3N0cmluZyAocykge3JldHVybiBldmFsKGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nKHMpKTt9XG5cbi8vUHJvdmlkZXM6IGNhbWxfanNfZXhwciAoY29uc3QpXG4vL1JlcXVpcmVzOiBqc19wcmludF9zdGRlcnJcbi8vUmVxdWlyZXM6IGNhbWxfanNzdHJpbmdfb2Zfc3RyaW5nXG5mdW5jdGlvbiBjYW1sX2pzX2V4cHIocykge1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX2pzX2V4cHI6IGZhbGxiYWNrIHRvIHJ1bnRpbWUgZXZhbHVhdGlvblxcblwiKTtcbiAgcmV0dXJuIGV2YWwoY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocykpO31cblxuLy9Qcm92aWRlczogY2FtbF9wdXJlX2pzX2V4cHIgY29uc3QgKGNvbnN0KVxuLy9SZXF1aXJlczoganNfcHJpbnRfc3RkZXJyXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9wdXJlX2pzX2V4cHIgKHMpe1xuICBqc19wcmludF9zdGRlcnIoXCJjYW1sX3B1cmVfanNfZXhwcjogZmFsbGJhY2sgdG8gcnVudGltZSBldmFsdWF0aW9uXFxuXCIpO1xuICByZXR1cm4gZXZhbChjYW1sX2pzc3RyaW5nX29mX3N0cmluZyhzKSk7fVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX29iamVjdCAob2JqZWN0X2xpdGVyYWwpXG4vL1JlcXVpcmVzOiBjYW1sX2pzc3RyaW5nX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9qc19vYmplY3QgKGEpIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAgPSBhW2ldO1xuICAgIG9bY2FtbF9qc3N0cmluZ19vZl9zdHJpbmcocFsxXSldID0gcFsyXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX2pzX2V4cG9ydF92YXJcbmZ1bmN0aW9uIGNhbWxfanNfZXhwb3J0X3ZhciAoKXtcbiAgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKVxuICAgIHJldHVybiBtb2R1bGUuZXhwb3J0c1xuICBlbHNlXG4gICAgcmV0dXJuIGpvb19nbG9iYWxfb2JqZWN0O1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX2ZhaWx3aXRoXG4vL1dlYWtkZWZcbmZ1bmN0aW9uIGNhbWxfeG1saHR0cHJlcXVlc3RfY3JlYXRlKHVuaXQpe1xuICB2YXIgZyA9IGpvb19nbG9iYWxfb2JqZWN0O1xuICBpZih0eXBlb2YgZy5YTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuWE1MSHR0cFJlcXVlc3QgfSBjYXRjaCAoZSkgeyB9O1xuICB9XG4gIGlmKHR5cGVvZiBnLmFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBnLmFjdGl2ZVhPYmplY3QoXCJNc3htbDIuWE1MSFRUUFwiKSB9IGNhdGNoKGUpeyB9O1xuICAgIHRyeSB7IHJldHVybiBuZXcgZy5hY3RpdmVYT2JqZWN0KFwiTXN4bWwzLlhNTEhUVFBcIikgfSBjYXRjaChlKXsgfTtcbiAgICB0cnkgeyByZXR1cm4gbmV3IGcuYWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIH0gY2F0Y2goZSl7IH07XG4gIH1cbiAgY2FtbF9mYWlsd2l0aChcIkNhbm5vdCBjcmVhdGUgYSBYTUxIdHRwUmVxdWVzdFwiKTtcbn1cbiIsIi8vUHJvdmlkZXM6IHVuaXhfZ2V0dGltZW9mZGF5XG5mdW5jdGlvbiB1bml4X2dldHRpbWVvZmRheSAoKSB7XG4gIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC8gMTAwMDtcbn1cblxuLy9Qcm92aWRlczogdW5peF90aW1lXG4vL1JlcXVpcmVzOiB1bml4X2dldHRpbWVvZmRheVxuZnVuY3Rpb24gdW5peF90aW1lICgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodW5peF9nZXR0aW1lb2ZkYXkgKCkpO1xufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2dtdGltZVxuZnVuY3Rpb24gdW5peF9nbXRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpKSkuZ2V0VGltZSgpO1xuICB2YXIgZG95ID0gTWF0aC5mbG9vcigoZF9udW0gLSBqYW51YXJ5Zmlyc3QpIC8gODY0MDAwMDApO1xuICByZXR1cm4gQkxPQ0soMCwgZC5nZXRVVENTZWNvbmRzKCksIGQuZ2V0VVRDTWludXRlcygpLCBkLmdldFVUQ0hvdXJzKCksXG4gICAgICAgICAgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCxcbiAgICAgICAgICBkLmdldFVUQ0RheSgpLCBkb3ksXG4gICAgICAgICAgZmFsc2UgfCAwIC8qIGZvciBVVEMgZGF5bGlnaHQgc2F2aW5ncyB0aW1lIGlzIGZhbHNlICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X2xvY2FsdGltZVxuZnVuY3Rpb24gdW5peF9sb2NhbHRpbWUgKHQpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSAodCAqIDEwMDApO1xuICB2YXIgZF9udW0gPSBkLmdldFRpbWUoKTtcbiAgdmFyIGphbnVhcnlmaXJzdCA9IChuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpKS5nZXRUaW1lKCk7XG4gIHZhciBkb3kgPSBNYXRoLmZsb29yKChkX251bSAtIGphbnVhcnlmaXJzdCkgLyA4NjQwMDAwMCk7XG4gIHZhciBqYW4gPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuICB2YXIganVsID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCA2LCAxKTtcbiAgdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgcmV0dXJuIEJMT0NLKDAsIGQuZ2V0U2Vjb25kcygpLCBkLmdldE1pbnV0ZXMoKSwgZC5nZXRIb3VycygpLFxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLCBkLmdldE1vbnRoKCksIGQuZ2V0RnVsbFllYXIoKSAtIDE5MDAsXG4gICAgICAgICAgZC5nZXREYXkoKSwgZG95LFxuICAgICAgICAgIChkLmdldFRpbWV6b25lT2Zmc2V0KCkgPCBzdGRUaW1lem9uZU9mZnNldCkgfCAwIC8qIGRheWxpZ2h0IHNhdmluZ3MgdGltZSAgZmllbGQuICovKVxufVxuXG4vL1Byb3ZpZGVzOiB1bml4X21rdGltZVxuLy9SZXF1aXJlczogdW5peF9sb2NhbHRpbWVcbmZ1bmN0aW9uIHVuaXhfbWt0aW1lKHRtKXtcbiAgdmFyIGQgPSAobmV3IERhdGUodG1bNl0rMTkwMCx0bVs1XSx0bVs0XSx0bVszXSx0bVsyXSx0bVsxXSkpLmdldFRpbWUoKTtcbiAgdmFyIHQgPSBNYXRoLmZsb29yKGQgLyAxMDAwKTtcbiAgdmFyIHRtMiA9IHVuaXhfbG9jYWx0aW1lKHQpO1xuICByZXR1cm4gQkxPQ0soMCx0LHRtMik7XG59XG5cbi8vUHJvdmlkZXM6IHdpbl9zdGFydHVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fc3RhcnR1cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9jbGVhbnVwIGNvbnN0XG5mdW5jdGlvbiB3aW5fY2xlYW51cCgpIHt9XG5cbi8vUHJvdmlkZXM6IHdpbl9oYW5kbGVfZmQgY29uc3RcbmZ1bmN0aW9uIHdpbl9oYW5kbGVfZmQoeCkge3JldHVybiB4O31cblxuLy9Qcm92aWRlczogdW5peF9pc2F0dHkgXG4vL1JlcXVpcmVzOiBmc19ub2RlX3N1cHBvcnRlZFxuZnVuY3Rpb24gdW5peF9pc2F0dHkoZmlsZURlc2NyaXB0b3IpIHtcbiAgaWYoZnNfbm9kZV9zdXBwb3J0ZWQoKSkge1xuICAgIHZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcbiAgICByZXR1cm4gdHR5LmlzYXR0eShmaWxlRGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2Zvcm1hdF9pbnQgY29uc3QgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2VfZm9ybWF0LCBjYW1sX2ZpbmlzaF9mb3JtYXR0aW5nLCBjYW1sX3N0cl9yZXBlYXRcbi8vUmVxdWlyZXM6IGNhbWxfc3RyaW5nX29mX2pzYnl0ZXMsIGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfZm9ybWF0X2ludChmbXQsIGkpIHtcbiAgaWYgKGNhbWxfanNieXRlc19vZl9zdHJpbmcoZm10KSA9PSBcIiVkXCIpIHJldHVybiBjYW1sX3N0cmluZ19vZl9qc2J5dGVzKFwiXCIraSk7XG4gIHZhciBmID0gY2FtbF9wYXJzZV9mb3JtYXQoZm10KTtcbiAgaWYgKGkgPCAwKSB7IGlmIChmLnNpZ25lZGNvbnYpIHsgZi5zaWduID0gLTE7IGkgPSAtaTsgfSBlbHNlIGkgPj4+PSAwOyB9XG4gIHZhciBzID0gaS50b1N0cmluZyhmLmJhc2UpO1xuICBpZiAoZi5wcmVjID49IDApIHtcbiAgICBmLmZpbGxlciA9ICcgJztcbiAgICB2YXIgbiA9IGYucHJlYyAtIHMubGVuZ3RoO1xuICAgIGlmIChuID4gMCkgcyA9IGNhbWxfc3RyX3JlcGVhdCAobiwgJzAnKSArIHM7XG4gIH1cbiAgcmV0dXJuIGNhbWxfZmluaXNoX2Zvcm1hdHRpbmcoZiwgcyk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZVxuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfdW5zYWZlX2dldCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX3BhcnNlX3NpZ25fYW5kX2Jhc2UgKHMpIHtcbiAgdmFyIGkgPSAwLCBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyksIGJhc2UgPSAxMCwgc2lnbiA9IDE7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgc3dpdGNoIChjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsaSkpIHtcbiAgICBjYXNlIDQ1OiBpKys7IHNpZ24gPSAtMTsgYnJlYWs7XG4gICAgY2FzZSA0MzogaSsrOyBzaWduID0gMTsgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpICsgMSA8IGxlbiAmJiBjYW1sX3N0cmluZ191bnNhZmVfZ2V0KHMsIGkpID09IDQ4KVxuICAgIHN3aXRjaCAoY2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpICsgMSkpIHtcbiAgICBjYXNlIDEyMDogY2FzZSA4ODogYmFzZSA9IDE2OyBpICs9IDI7IGJyZWFrO1xuICAgIGNhc2UgMTExOiBjYXNlIDc5OiBiYXNlID0gIDg7IGkgKz0gMjsgYnJlYWs7XG4gICAgY2FzZSAgOTg6IGNhc2UgNjY6IGJhc2UgPSAgMjsgaSArPSAyOyBicmVhaztcbiAgICBjYXNlIDExNzogY2FzZSA4NTogaSArPSAyOyBicmVhaztcbiAgICB9XG4gIHJldHVybiBbaSwgc2lnbiwgYmFzZV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfcGFyc2VfZGlnaXRcbmZ1bmN0aW9uIGNhbWxfcGFyc2VfZGlnaXQoYykge1xuICBpZiAoYyA+PSA0OCAmJiBjIDw9IDU3KSAgcmV0dXJuIGMgLSA0ODtcbiAgaWYgKGMgPj0gNjUgJiYgYyA8PSA5MCkgIHJldHVybiBjIC0gNTU7XG4gIGlmIChjID49IDk3ICYmIGMgPD0gMTIyKSByZXR1cm4gYyAtIDg3O1xuICByZXR1cm4gLTE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfaW50X29mX3N0cmluZyAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX21sX3N0cmluZ19sZW5ndGgsIGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfcGFyc2Vfc2lnbl9hbmRfYmFzZSwgY2FtbF9wYXJzZV9kaWdpdCwgY2FtbF9mYWlsd2l0aFxuZnVuY3Rpb24gY2FtbF9pbnRfb2Zfc3RyaW5nIChzKSB7XG4gIHZhciByID0gY2FtbF9wYXJzZV9zaWduX2FuZF9iYXNlIChzKTtcbiAgdmFyIGkgPSByWzBdLCBzaWduID0gclsxXSwgYmFzZSA9IHJbMl07XG4gIHZhciBsZW4gPSBjYW1sX21sX3N0cmluZ19sZW5ndGgocyk7XG4gIHZhciB0aHJlc2hvbGQgPSAtMSA+Pj4gMDtcbiAgdmFyIGMgPSAoaSA8IGxlbik/Y2FtbF9zdHJpbmdfdW5zYWZlX2dldChzLCBpKTowO1xuICB2YXIgZCA9IGNhbWxfcGFyc2VfZGlnaXQoYyk7XG4gIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB2YXIgcmVzID0gZDtcbiAgZm9yIChpKys7aTxsZW47aSsrKSB7XG4gICAgYyA9IGNhbWxfc3RyaW5nX3Vuc2FmZV9nZXQocywgaSk7XG4gICAgaWYgKGMgPT0gOTUpIGNvbnRpbnVlO1xuICAgIGQgPSBjYW1sX3BhcnNlX2RpZ2l0KGMpO1xuICAgIGlmIChkIDwgMCB8fCBkID49IGJhc2UpIGJyZWFrO1xuICAgIHJlcyA9IGJhc2UgKiByZXMgKyBkO1xuICAgIGlmIChyZXMgPiB0aHJlc2hvbGQpIGNhbWxfZmFpbHdpdGgoXCJpbnRfb2Zfc3RyaW5nXCIpO1xuICB9XG4gIGlmIChpICE9IGxlbikgY2FtbF9mYWlsd2l0aChcImludF9vZl9zdHJpbmdcIik7XG4gIC8vIEZvciBiYXNlIGRpZmZlcmVudCBmcm9tIDEwLCB3ZSBleHBlY3QgYW4gdW5zaWduZWQgcmVwcmVzZW50YXRpb24sXG4gIC8vIGhlbmNlIGFueSB2YWx1ZSBvZiAncmVzJyAobGVzcyB0aGFuICd0aHJlc2hvbGQnKSBpcyBhY2NlcHRhYmxlLlxuICAvLyBCdXQgd2UgaGF2ZSB0byBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayB0byBhIHNpZ25lZCBpbnRlZ2VyLlxuICByZXMgPSBzaWduICogcmVzO1xuICBpZiAoKGJhc2UgPT0gMTApICYmICgocmVzIHwgMCkgIT0gcmVzKSlcbiAgICAvKiBTaWduZWQgcmVwcmVzZW50YXRpb24gZXhwZWN0ZWQsIGFsbG93IC0yXihuYml0cy0xKSB0byAyXihuYml0cy0xKSAtIDEgKi9cbiAgICBjYW1sX2ZhaWx3aXRoKFwiaW50X29mX3N0cmluZ1wiKTtcbiAgcmV0dXJuIHJlcyB8IDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbXVsIGNvbnN0XG5mdW5jdGlvbiBjYW1sX211bChhLGIpe1xuICByZXR1cm4gTWF0aC5pbXVsKGEsYik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZGl2XG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX2Rpdih4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuICh4L3kpfDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3JhaXNlX3plcm9fZGl2aWRlXG5mdW5jdGlvbiBjYW1sX21vZCh4LHkpIHtcbiAgaWYgKHkgPT0gMCkgY2FtbF9yYWlzZV96ZXJvX2RpdmlkZSAoKTtcbiAgcmV0dXJuIHgleTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9ic3dhcDE2XG5mdW5jdGlvbiBjYW1sX2Jzd2FwMTYoeCkge1xuICByZXR1cm4gKCgoKHggJiAweDAwRkYpIDw8IDgpIHxcbiAgICAgICAgICAgKCh4ICYgMHhGRjAwKSA+PiA4KSkpO1xufVxuLy9Qcm92aWRlczogY2FtbF9pbnQzMl9ic3dhcFxuZnVuY3Rpb24gY2FtbF9pbnQzMl9ic3dhcCh4KSB7XG4gIHJldHVybiAoKCh4ICYgMHgwMDAwMDBGRikgPDwgMjQpIHxcbiAgICAgICAgICAoKHggJiAweDAwMDBGRjAwKSA8PCA4KSB8XG4gICAgICAgICAgKCh4ICYgMHgwMEZGMDAwMCkgPj4+IDgpIHxcbiAgICAgICAgICAoKHggJiAweEZGMDAwMDAwKSA+Pj4gMjQpKTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfaW50NjRfYnN3YXBcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfaW50NjRfYnN3YXAoeCkge1xuICB2YXIgeSA9IGNhbWxfaW50NjRfdG9fYnl0ZXMoeCk7XG4gIHJldHVybiBjYW1sX2ludDY0X29mX2J5dGVzKFt5WzddLCB5WzZdLCB5WzVdLCB5WzRdLCB5WzNdLCB5WzJdLCB5WzFdLCB5WzBdXSk7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vLy8vLy8vLy8vLy8vIEhhc2h0YmxcblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX3VuaXZfcGFyYW0gbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW50NjRfdG9fYnl0ZXMsIGNhbWxfaW50NjRfYml0c19vZl9mbG9hdCwgY2FtbF9jdXN0b21fb3BzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aCwgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX3VuaXZfcGFyYW0gKGNvdW50LCBsaW1pdCwgb2JqKSB7XG4gIHZhciBoYXNoX2FjY3UgPSAwO1xuICBmdW5jdGlvbiBoYXNoX2F1eCAob2JqKSB7XG4gICAgbGltaXQgLS07XG4gICAgaWYgKGNvdW50IDwgMCB8fCBsaW1pdCA8IDApIHJldHVybjtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkgJiYgb2JqWzBdID09PSAob2JqWzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKG9ialswXSkge1xuICAgICAgY2FzZSAyNDg6XG4gICAgICAgIC8vIE9iamVjdFxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqWzJdKSB8IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTA6XG4gICAgICAgIC8vIEZvcndhcmRcbiAgICAgICAgbGltaXQrKzsgaGFzaF9hdXgob2JqKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudCAtLTtcbiAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgb2JqWzBdKSB8IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSBvYmoubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgaGFzaF9hdXggKG9ialtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKG9iaikpIHtcbiAgICAgIGNvdW50IC0tO1xuICAgICAgc3dpdGNoIChvYmoudCAmIDYpIHtcbiAgICAgIGRlZmF1bHQ6IC8qIFBBUlRJQUwgKi9cbiAgICAgICAgY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlcyhvYmopO1xuICAgICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLmMsIGwgPSBjYW1sX21sX2J5dGVzX2xlbmd0aChvYmopLCBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBiLmNoYXJDb2RlQXQoaSkpIHwgMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgICAgIGZvciAodmFyIGEgPSBvYmouYywgbCA9IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKG9iaiksIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGFbaV0pIHwgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKG9iaikpIHtcbiAgICAgICAgdmFyIGpzYnl0ZXMgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKG9iaik7XG4gICAgICAgIGZvciAodmFyIGIgPSBqc2J5dGVzLCBsID0ganNieXRlcy5sZW5ndGgsIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgIGhhc2hfYWNjdSA9IChoYXNoX2FjY3UgKiAxOSArIGIuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmb3IgKHZhciBiID0gb2JqLCBsID0gb2JqLmxlbmd0aCwgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDE5ICsgYi5jaGFyQ29kZUF0KGkpKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09IChvYmp8MCkpIHtcbiAgICAgIC8vIEludGVnZXJcbiAgICAgIGNvdW50IC0tO1xuICAgICAgaGFzaF9hY2N1ID0gKGhhc2hfYWNjdSAqIDY1NTk5ICsgb2JqKSB8IDA7XG4gICAgfSBlbHNlIGlmIChvYmogPT09ICtvYmopIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBjb3VudC0tO1xuICAgICAgdmFyIHAgPSBjYW1sX2ludDY0X3RvX2J5dGVzIChjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKG9iaikpO1xuICAgICAgZm9yICh2YXIgaSA9IDc7IGkgPj0gMDsgaS0tKSBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogMTkgKyBwW2ldKSB8IDA7XG4gICAgfSBlbHNlIGlmKG9iaiAmJiBvYmouY2FtbF9jdXN0b20pIHtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1tvYmouY2FtbF9jdXN0b21dLmhhc2gpIHtcbiAgICAgICAgdmFyIGggPSBjYW1sX2N1c3RvbV9vcHNbb2JqLmNhbWxfY3VzdG9tXS5oYXNoKG9iaikgfCAwO1xuICAgICAgICBoYXNoX2FjY3UgPSAoaGFzaF9hY2N1ICogNjU1OTkgKyBoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc2hfYXV4IChvYmopO1xuICByZXR1cm4gaGFzaF9hY2N1ICYgMHgzRkZGRkZGRjtcbn1cblxuLy9mdW5jdGlvbiBST1RMMzIoeCxuKSB7IHJldHVybiAoKHggPDwgbikgfCAoeCA+Pj4gKDMyLW4pKSk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfaW50XG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9pbnQoaCxkKSB7XG4gIGQgPSBjYW1sX211bChkLCAweGNjOWUyZDUxfDApO1xuICBkID0gKChkIDw8IDE1KSB8IChkID4+PiAoMzItMTUpKSk7IC8vIFJPVEwzMihkLCAxNSk7XG4gIGQgPSBjYW1sX211bChkLCAweDFiODczNTkzKTtcbiAgaCBePSBkO1xuICBoID0gKChoIDw8IDEzKSB8IChoID4+PiAoMzItMTMpKSk7ICAgLy9ST1RMMzIoaCwgMTMpO1xuICByZXR1cm4gKCgoaCArIChoIDw8IDIpKXwwKSArICgweGU2NTQ2YjY0fDApKXwwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ZpbmFsXG4vL1JlcXVpcmVzOiBjYW1sX211bFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9maW5hbChoKSB7XG4gIGggXj0gaCA+Pj4gMTY7XG4gIGggPSBjYW1sX211bCAoaCwgMHg4NWViY2E2YnwwKTtcbiAgaCBePSBoID4+PiAxMztcbiAgaCA9IGNhbWxfbXVsIChoLCAweGMyYjJhZTM1fDApO1xuICBoIF49IGggPj4+IDE2O1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9mbG9hdFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0LCBjYW1sX2hhc2hfbWl4X2ludDY0XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2Zsb2F0IChoLCB2MCkge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9pbnQ2NChoLCBjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXQgKHYwKSk7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX2hhc2hfbWl4X2ludDY0XG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuLy9SZXF1aXJlczogY2FtbF9pbnQ2NF9sbzMyLCBjYW1sX2ludDY0X2hpMzJcbmZ1bmN0aW9uIGNhbWxfaGFzaF9taXhfaW50NjQgKGgsIHYpIHtcbiAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIGNhbWxfaW50NjRfbG8zMih2KSk7XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCBjYW1sX2ludDY0X2hpMzIodikpO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2ludFxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIHMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoLCBpLCB3O1xuICBmb3IgKGkgPSAwOyBpICsgNCA8PSBsZW47IGkgKz0gNCkge1xuICAgIHcgPSBzLmNoYXJDb2RlQXQoaSlcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzEpIDw8IDgpXG4gICAgICB8IChzLmNoYXJDb2RlQXQoaSsyKSA8PCAxNilcbiAgICAgIHwgKHMuY2hhckNvZGVBdChpKzMpIDw8IDI0KTtcbiAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdyk7XG4gIH1cbiAgdyA9IDA7XG4gIHN3aXRjaCAobGVuICYgMykge1xuICBjYXNlIDM6IHcgID0gcy5jaGFyQ29kZUF0KGkrMikgPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzLmNoYXJDb2RlQXQoaSsxKSA8PCA4O1xuICBjYXNlIDE6XG4gICAgdyB8PSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc19hcnJcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfaW50XG5mdW5jdGlvbiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FycihoLCBzKSB7XG4gIHZhciBsZW4gPSBzLmxlbmd0aCwgaSwgdztcbiAgZm9yIChpID0gMDsgaSArIDQgPD0gbGVuOyBpICs9IDQpIHtcbiAgICB3ID0gc1tpXVxuICAgICAgfCAoc1tpKzFdIDw8IDgpXG4gICAgICB8IChzW2krMl0gPDwgMTYpXG4gICAgICB8IChzW2krM10gPDwgMjQpO1xuICAgIGggPSBjYW1sX2hhc2hfbWl4X2ludChoLCB3KTtcbiAgfVxuICB3ID0gMDtcbiAgc3dpdGNoIChsZW4gJiAzKSB7XG4gIGNhc2UgMzogdyAgPSBzW2krMl0gPDwgMTY7XG4gIGNhc2UgMjogdyB8PSBzW2krMV0gPDwgODtcbiAgY2FzZSAxOiB3IHw9IHNbaV07XG4gICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHcpO1xuICBkZWZhdWx0OlxuICB9XG4gIGggXj0gbGVuO1xuICByZXR1cm4gaDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9jb252ZXJ0X3N0cmluZ190b19ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9qc2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9ieXRlcyhoLCB2KSB7XG4gIHN3aXRjaCAodi50ICYgNikge1xuICBkZWZhdWx0OlxuICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMgKHYpO1xuICBjYXNlIDA6IC8qIEJZVEVTICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfanNieXRlcyhoLCB2LmMpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6IC8qIEFSUkFZICovXG4gICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsIHYuYyk7XG4gIH1cbiAgcmV0dXJuIGhcbn1cblxuLy9Qcm92aWRlczogY2FtbF9oYXNoX21peF9zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlcywgY2FtbF9qc2J5dGVzX29mX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9zdHJpbmcoaCwgdikge1xuICByZXR1cm4gY2FtbF9oYXNoX21peF9qc2J5dGVzKGgsIGNhbWxfanNieXRlc19vZl9zdHJpbmcodikpO1xufVxuXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaCBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX3N0cmluZywgY2FtbF9pc19tbF9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9oYXNoX21peF9pbnQsIGNhbWxfaGFzaF9taXhfZmluYWxcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfZmxvYXQsIGNhbWxfaGFzaF9taXhfc3RyaW5nLCBjYW1sX2hhc2hfbWl4X2J5dGVzLCBjYW1sX2N1c3RvbV9vcHNcbi8vUmVxdWlyZXM6IGNhbWxfaGFzaF9taXhfanNieXRlc1xuZnVuY3Rpb24gY2FtbF9oYXNoIChjb3VudCwgbGltaXQsIHNlZWQsIG9iaikge1xuICB2YXIgcXVldWUsIHJkLCB3ciwgc3osIG51bSwgaCwgdiwgaSwgbGVuO1xuICBzeiA9IGxpbWl0O1xuICBpZiAoc3ogPCAwIHx8IHN6ID4gMjU2KSBzeiA9IDI1NjtcbiAgbnVtID0gY291bnQ7XG4gIGggPSBzZWVkO1xuICBxdWV1ZSA9IFtvYmpdOyByZCA9IDA7IHdyID0gMTtcbiAgd2hpbGUgKHJkIDwgd3IgJiYgbnVtID4gMCkge1xuICAgIHYgPSBxdWV1ZVtyZCsrXTtcbiAgICBpZiAodiAmJiB2LmNhbWxfY3VzdG9tKXtcbiAgICAgIGlmKGNhbWxfY3VzdG9tX29wc1t2LmNhbWxfY3VzdG9tXSAmJiBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCkge1xuICAgICAgICB2YXIgaGggPSBjYW1sX2N1c3RvbV9vcHNbdi5jYW1sX2N1c3RvbV0uaGFzaCh2KTtcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50IChoLCBoaCk7XG4gICAgICAgIG51bSAtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIEFycmF5ICYmIHZbMF0gPT09ICh2WzBdfDApKSB7XG4gICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgIGNhc2UgMjQ4OlxuICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHZbMl0pO1xuICAgICAgICBudW0tLTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MDpcbiAgICAgICAgLy8gRm9yd2FyZFxuICAgICAgICBxdWV1ZVstLXJkXSA9IHZbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIHRhZyA9ICgodi5sZW5ndGggLSAxKSA8PCAxMCkgfCB2WzBdO1xuICAgICAgICBoID0gY2FtbF9oYXNoX21peF9pbnQoaCwgdGFnKTtcbiAgICAgICAgZm9yIChpID0gMSwgbGVuID0gdi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmICh3ciA+PSBzeikgYnJlYWs7XG4gICAgICAgICAgcXVldWVbd3IrK10gPSB2W2ldO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2FtbF9pc19tbF9ieXRlcyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmIChjYW1sX2lzX21sX3N0cmluZyh2KSkge1xuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfc3RyaW5nKGgsdilcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGggPSBjYW1sX2hhc2hfbWl4X2pzYnl0ZXMoaCx2KVxuICAgICAgbnVtLS07XG4gICAgfSBlbHNlIGlmICh2ID09PSAodnwwKSkge1xuICAgICAgLy8gSW50ZWdlclxuICAgICAgaCA9IGNhbWxfaGFzaF9taXhfaW50KGgsIHYrdisxKTtcbiAgICAgIG51bS0tO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gK3YpIHtcbiAgICAgIC8vIEZsb2F0XG4gICAgICBoID0gY2FtbF9oYXNoX21peF9mbG9hdChoLHYpO1xuICAgICAgbnVtLS07XG4gICAgfVxuICB9XG4gIGggPSBjYW1sX2hhc2hfbWl4X2ZpbmFsKGgpO1xuICByZXR1cm4gaCAmIDB4M0ZGRkZGRkY7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX3RhZ1xuLy9SZXF1aXJlczogY2FtbF9pc19tbF9zdHJpbmcsIGNhbWxfaXNfbWxfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWxfdGFnKGEpe1xuICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHJldHVybiAxMDAwOyAvLyBpbnRfdGFnICh3ZSB1c2UgaXQgZm9yIGFsbCBudW1iZXJzKVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKGEpKSByZXR1cm4gMjUyOyAvLyBzdHJpbmdfdGFnXG4gIGVsc2UgaWYgKGNhbWxfaXNfbWxfc3RyaW5nKGEpKSByZXR1cm4gMTI1MjsgLy8gb2NhbWwgc3RyaW5nIChpZiBkaWZmZXJlbnQgZnJvbSBieXRlcylcbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIEFycmF5ICYmIGFbMF0gPT09IChhWzBdPj4+MCkgJiYgYVswXSA8PSAyNTUpIHtcbiAgICAvLyBMb29rIGxpa2UgYW4gb2NhbWwgYmxvY2tcbiAgICB2YXIgdGFnID0gYVswXSB8IDA7XG4gICAgLy8gaWdub3JlIGRvdWJsZV9hcnJheV90YWcgYmVjYXVzZSB3ZSBjYW5ub3QgYWNjdXJhdGVseSBzZXRcbiAgICAvLyB0aGlzIHRhZyB3aGVuIHdlIGNyZWF0ZSBhbiBhcnJheSBvZiBmbG9hdC5cbiAgICByZXR1cm4gKHRhZyA9PSAyNTQpPzA6dGFnXG4gIH1cbiAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIDEyNTIwOyAvLyBqYXZhc2NyaXB0IHN0cmluZywgbGlrZSBzdHJpbmdfdGFnICgyNTIpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHJldHVybiAxMjUyMDsgLy8gamF2YXNjcmlwdCBzdHJpbmcsIGxpa2Ugc3RyaW5nX3RhZyAoMjUyKVxuICBlbHNlIGlmIChhIGluc3RhbmNlb2YgTnVtYmVyKSByZXR1cm4gMTAwMDsgLy8gaW50X3RhZyAod2UgdXNlIGl0IGZvciBhbGwgbnVtYmVycylcbiAgZWxzZSBpZiAoYSAmJiBhLmNhbWxfY3VzdG9tKSByZXR1cm4gMTI1NTsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKGEgJiYgYS5jb21wYXJlKSByZXR1cm4gMTI1NjsgLy8gbGlrZSBjdXN0b21fdGFnICgyNTUpXG4gIGVsc2UgaWYgKHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIDEyNDc7IC8vIGxpa2UgY2xvc3VyZV90YWcgKDI0NylcbiAgZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzeW1ib2xcIikgcmV0dXJuIDEyNTE7XG4gIHJldHVybiAxMDAxOyAvL291dF9vZl9oZWFwX3RhZ1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY3VzdG9tX29wc1xuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGEpe1xuICByZXR1cm4gY2FtbF9jdXN0b21fb3BzW2EuY2FtbF9jdXN0b21dICYmIGNhbWxfY3VzdG9tX29wc1thLmNhbWxfY3VzdG9tXS5jb21wYXJlO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbVxuZnVuY3Rpb24gY2FtbF9jb21wYXJlX3ZhbF9udW1iZXJfY3VzdG9tKG51bSwgY3VzdG9tLCBzd2FwLCB0b3RhbCkge1xuICB2YXIgY29tcCA9IGNhbWxfY29tcGFyZV92YWxfZ2V0X2N1c3RvbShjdXN0b20pO1xuICBpZihjb21wKSB7XG4gICAgdmFyIHggPSAoc3dhcCA+IDApP2NvbXAoY3VzdG9tLG51bSx0b3RhbCk6Y29tcChudW0sY3VzdG9tLHRvdGFsKTtcbiAgICBpZih0b3RhbCAmJiB4ICE9IHgpIHJldHVybiBzd2FwOyAvLyB0b3RhbCAmJiBuYW5cbiAgICBpZigreCAhPSAreCkgcmV0dXJuICt4OyAvLyBuYW5cbiAgICBpZigoeCB8IDApICE9IDApIHJldHVybiAoeCB8IDApOyAvLyAhbmFuXG4gIH1cbiAgcmV0dXJuIHN3YXBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9jb21wYXJlX3ZhbCAoY29uc3QsIGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfaW50X2NvbXBhcmUsIGNhbWxfc3RyaW5nX2NvbXBhcmUsIGNhbWxfYnl0ZXNfY29tcGFyZVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20sIGNhbWxfY29tcGFyZV92YWxfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b21cbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfY29tcGFyZV92YWwgKGEsIGIsIHRvdGFsKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICBmb3IoOzspIHtcbiAgICBpZiAoISh0b3RhbCAmJiBhID09PSBiKSkge1xuICAgICAgdmFyIHRhZ19hID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYSk7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYSA9PSAyNTApIHsgYSA9IGFbMV07IGNvbnRpbnVlIH1cblxuICAgICAgdmFyIHRhZ19iID0gY2FtbF9jb21wYXJlX3ZhbF90YWcoYik7XG4gICAgICAvLyBmb3J3YXJkX3RhZyA/XG4gICAgICBpZih0YWdfYiA9PSAyNTApIHsgYiA9IGJbMV07IGNvbnRpbnVlIH1cblxuICAgICAgLy8gdGFncyBhcmUgZGlmZmVyZW50XG4gICAgICBpZih0YWdfYSAhPT0gdGFnX2IpIHtcbiAgICAgICAgaWYodGFnX2EgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19iID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYSwgYiwgLTEsIHRvdGFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYodGFnX2IgPT0gMTAwMCkge1xuICAgICAgICAgIGlmKHRhZ19hID09IDEyNTUpIHsgLy9pbW1lZGlhdGUgY2FuIGNvbXBhcmUgYWdhaW5zdCBjdXN0b21cbiAgICAgICAgICAgIHJldHVybiBjYW1sX2NvbXBhcmVfdmFsX251bWJlcl9jdXN0b20oYiwgYSwgMSwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGFnX2EgPCB0YWdfYik/LTE6MTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCh0YWdfYSl7XG4gICAgICAgIC8vIDI0NjogTGF6eV90YWcgaGFuZGxlZCBiZWxsb3dcbiAgICAgIGNhc2UgMjQ3OiAvLyBDbG9zdXJlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIDI0ODogLy8gT2JqZWN0XG4gICAgICAgIHZhciB4ID0gY2FtbF9pbnRfY29tcGFyZShhWzJdLCBiWzJdKTtcbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNDk6IC8vIEluZml4XG4gICAgICAgIC8vIENhbm5vdCBoYXBwZW5cbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY29tcGFyZTogZnVuY3Rpb25hbCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMjUwOiAvLyBGb3J3YXJkIHRhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuLCBoYW5kbGVkIGFib3ZlXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRm9yd2FyZF90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjUxOiAvL0Fic3RyYWN0XG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MjogLy8gT0NhbWwgYnl0ZXNcbiAgICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgICB2YXIgeCA9IGNhbWxfYnl0ZXNfY29tcGFyZShhLCBiKTtcbiAgICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1MzogLy8gRG91YmxlX3RhZ1xuICAgICAgICAvLyBDYW5ub3QgaGFwcGVuXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImVxdWFsOiBnb3QgRG91YmxlX3RhZywgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheV90YWdcbiAgICAgICAgLy8gQ2Fubm90IGhhcHBlbiwgaGFuZGxlZCBhYm92ZVxuICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJlcXVhbDogZ290IERvdWJsZV9hcnJheV90YWcsIHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAyNTU6IC8vIEN1c3RvbV90YWdcbiAgICAgICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiZXF1YWw6IGdvdCBDdXN0b21fdGFnLCBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNDc6IC8vIEZ1bmN0aW9uXG4gICAgICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNvbXBhcmU6IGZ1bmN0aW9uYWwgdmFsdWVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU1OiAvLyBDdXN0b21cbiAgICAgICAgdmFyIGNvbXAgPSBjYW1sX2NvbXBhcmVfdmFsX2dldF9jdXN0b20oYSk7XG4gICAgICAgIGlmKGNvbXAgIT0gY2FtbF9jb21wYXJlX3ZhbF9nZXRfY3VzdG9tKGIpKXtcbiAgICAgICAgICByZXR1cm4gKGEuY2FtbF9jdXN0b208Yi5jYW1sX2N1c3RvbSk/LTE6MTtcbiAgICAgICAgfVxuICAgICAgICBpZighY29tcClcbiAgICAgICAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJjb21wYXJlOiBhYnN0cmFjdCB2YWx1ZVwiKTtcbiAgICAgICAgdmFyIHggPSBjb21wKGEsYix0b3RhbCk7XG4gICAgICAgIGlmKHggIT0geCl7IC8vIFByb3RlY3QgYWdhaW5zdCBpbnZhbGlkIFVOT1JERVJFRFxuICAgICAgICAgIHJldHVybiB0b3RhbD8tMTp4O1xuICAgICAgICB9XG4gICAgICAgIGlmKHggIT09ICh4fDApKXsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggIT0gMCkgcmV0dXJuICh4IHwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjU2OiAvLyBjb21wYXJlIGZ1bmN0aW9uXG4gICAgICAgIHZhciB4ID0gYS5jb21wYXJlKGIsdG90YWwpO1xuICAgICAgICBpZih4ICE9IHgpIHsgLy8gUHJvdGVjdCBhZ2FpbnN0IGludmFsaWQgVU5PUkRFUkVEXG4gICAgICAgICAgcmV0dXJuIHRvdGFsPy0xOng7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeCAhPT0gKHh8MCkpeyAvLyBQcm90ZWN0IGFnYWluc3QgaW52YWxpZCByZXR1cm4gdmFsdWVcbiAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCAhPSAwKSByZXR1cm4gKHggfCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDA6IC8vIE51bWJlclxuICAgICAgICBhID0gK2E7XG4gICAgICAgIGIgPSArYjtcbiAgICAgICAgaWYgKGEgPCBiKSByZXR1cm4gLTE7XG4gICAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhICE9IGIpIHtcbiAgICAgICAgICBpZiAoIXRvdGFsKSByZXR1cm4gTmFOO1xuICAgICAgICAgIGlmIChhID09IGEpIHJldHVybiAxO1xuICAgICAgICAgIGlmIChiID09IGIpIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwMTogLy8gVGhlIHJlc3RcbiAgICAgICAgLy8gSGVyZSB3ZSBjYW4gYmUgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgLy8gMS4gSmF2YVNjcmlwdCBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMi4gSmF2YVNjcmlwdCBvYmplY3QgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy8gMy4gSmF2YVNjcmlwdCBvYmplY3QgdGhhbiBjYW5ub3QgYmUgY29lcmNlZCB0byBwcmltaXRpdmUgdHlwZXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKDMpIHdpbGwgcmFpc2UgYSBbVHlwZUVycm9yXVxuICAgICAgICAvLyAoMikgd2lsbCBjb2VyY2UgdG8gcHJpbWl0aXZlIHR5cGVzIHVzaW5nIFt2YWx1ZU9mXSBvciBbdG9TdHJpbmddXG4gICAgICAgIC8vICgyKSBhbmQgKDMpLCBhZnRlciBldmVudHVhbCBjb2VyY2lvblxuICAgICAgICAvLyAtIGlmIGEgYW5kIGIgYXJlIHN0cmluZ3MsIGFwcGx5IGxleGljb2dyYXBoaWMgY29tcGFyaXNvblxuICAgICAgICAvLyAtIGlmIGEgb3IgYiBhcmUgbm90IHN0cmluZ3MsIGNvbnZlcnQgYSBhbmQgYiB0byBudW1iZXJcbiAgICAgICAgLy8gICBhbmQgYXBwbHkgc3RhbmRhcmQgY29tcGFyaXNvblxuICAgICAgICAvL1xuICAgICAgICAvLyBFeGNlcHRpb246IGAhPWAgd2lsbCBub3QgY29lcmNlL2NvbnZlcnQgaWYgYm90aCBhIGFuZCBiIGFyZSBvYmplY3RzXG4gICAgICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYSA+IGIpIHJldHVybiAxO1xuICAgICAgICBpZiAoYSAhPSBiKSB7XG4gICAgICAgICAgaWYgKCF0b3RhbCkgcmV0dXJuIE5hTjtcbiAgICAgICAgICBpZiAoYSA9PSBhKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYiA9PSBiKSByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTE6IC8vIEphdmFTY3JpcHQgU3ltYm9sLCBubyBvcmRlcmluZy5cbiAgICAgICAgaWYoYSAhPT0gYikge1xuICAgICAgICAgIGlmICghdG90YWwpIHJldHVybiBOYU47XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyNTI6IC8vIG9jYW1sIHN0cmluZ3NcbiAgICAgICAgdmFyIGEgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKGEpO1xuICAgICAgICB2YXIgYiA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcoYik7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI1MjA6IC8vIGphdmFzY3JpcHQgc3RyaW5nc1xuICAgICAgICB2YXIgYSA9IGEudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGIgPSBiLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmKGEgIT09IGIpIHtcbiAgICAgICAgICBpZihhIDwgYikgcmV0dXJuIC0xO1xuICAgICAgICAgIGlmKGEgPiBiKSByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ2OiAvLyBMYXp5X3RhZ1xuICAgICAgY2FzZSAyNTQ6IC8vIERvdWJsZV9hcnJheVxuICAgICAgZGVmYXVsdDogLy8gQmxvY2sgd2l0aCBvdGhlciB0YWdcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gKGEubGVuZ3RoIDwgYi5sZW5ndGgpPy0xOjE7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDEpIHN0YWNrLnB1c2goYSwgYiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2subGVuZ3RoID09IDApIHJldHVybiAwO1xuICAgIHZhciBpID0gc3RhY2sucG9wKCk7XG4gICAgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGEgPSBzdGFjay5wb3AoKTtcbiAgICBpZiAoaSArIDEgPCBhLmxlbmd0aCkgc3RhY2sucHVzaChhLCBiLCBpICsgMSk7XG4gICAgYSA9IGFbaV07XG4gICAgYiA9IGJbaV07XG4gIH1cbn1cbi8vUHJvdmlkZXM6IGNhbWxfY29tcGFyZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9jb21wYXJlIChhLCBiKSB7IHJldHVybiBjYW1sX2NvbXBhcmVfdmFsIChhLCBiLCB0cnVlKTsgfVxuLy9Qcm92aWRlczogY2FtbF9pbnRfY29tcGFyZSBtdXRhYmxlIChjb25zdCwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX2ludF9jb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgcmV0dXJuICgtMSk7IGlmIChhID09IGIpIHJldHVybiAwOyByZXR1cm4gMTtcbn1cbi8vUHJvdmlkZXM6IGNhbWxfZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9lcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbm90ZXF1YWwgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9ub3RlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgIT0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ3JlYXRlcmVxdWFsIG11dGFibGUgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfY29tcGFyZV92YWxcbmZ1bmN0aW9uIGNhbWxfZ3JlYXRlcmVxdWFsICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+PSAwKTsgfVxuLy9Qcm92aWRlczogY2FtbF9ncmVhdGVydGhhbiBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2dyZWF0ZXJ0aGFuICh4LCB5KSB7IHJldHVybiArKGNhbWxfY29tcGFyZV92YWwoeCx5LGZhbHNlKSA+IDApOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2xlc3NlcXVhbCBtdXRhYmxlIChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2NvbXBhcmVfdmFsXG5mdW5jdGlvbiBjYW1sX2xlc3NlcXVhbCAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPD0gMCk7IH1cbi8vUHJvdmlkZXM6IGNhbWxfbGVzc3RoYW4gbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9jb21wYXJlX3ZhbFxuZnVuY3Rpb24gY2FtbF9sZXNzdGhhbiAoeCwgeSkgeyByZXR1cm4gKyhjYW1sX2NvbXBhcmVfdmFsKHgseSxmYWxzZSkgPCAwKTsgfVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDE0IErDqXLDtG1lIFZvdWlsbG9uLCBIdWdvIEhldXphcmRcbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9DYW1saW50ZXJuYWxNb2RfaW5pdF9tb2Rcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2Vfd2l0aF9hcmcsIGNhbWxfZ2xvYmFsX2RhdGFcbmZ1bmN0aW9uIGNhbWxfQ2FtbGludGVybmFsTW9kX2luaXRfbW9kKGxvYyxzaGFwZSkge1xuICBmdW5jdGlvbiB1bmRlZl9tb2R1bGUgKF94KSB7XG4gICAgY2FtbF9yYWlzZV93aXRoX2FyZyhjYW1sX2dsb2JhbF9kYXRhLlVuZGVmaW5lZF9yZWN1cnNpdmVfbW9kdWxlLCBsb2MpO1xuICB9XG4gIGZ1bmN0aW9uIGxvb3AgKHNoYXBlLHN0cnVjdCxpZHgpe1xuICAgIGlmKHR5cGVvZiBzaGFwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgIHN3aXRjaChzaGFwZSl7XG4gICAgICBjYXNlIDA6Ly9mdW5jdGlvblxuICAgICAgICBzdHJ1Y3RbaWR4XT17ZnVuOnVuZGVmX21vZHVsZX07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOi8vbGF6eVxuICAgICAgICBzdHJ1Y3RbaWR4XT1bMjQ2LCB1bmRlZl9tb2R1bGVdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6Ly9jYXNlIDI6Ly9jbGFzc1xuICAgICAgICBzdHJ1Y3RbaWR4XT1bXTtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgICAgY2FzZSAwOi8vbW9kdWxlXG4gICAgICAgIHN0cnVjdFtpZHhdID0gWzBdO1xuICAgICAgICBmb3IodmFyIGk9MTtpPHNoYXBlWzFdLmxlbmd0aDtpKyspXG4gICAgICAgICAgbG9vcChzaGFwZVsxXVtpXSxzdHJ1Y3RbaWR4XSxpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0Oi8vY2FzZSAxOi8vVmFsdWVcbiAgICAgICAgc3RydWN0W2lkeF0gPSBzaGFwZVsxXTtcbiAgICAgIH1cbiAgfVxuICB2YXIgcmVzID0gW107XG4gIGxvb3Aoc2hhcGUscmVzLDApO1xuICByZXR1cm4gcmVzWzBdXG59XG4vL1Byb3ZpZGVzOiBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kXG4vL1JlcXVpcmVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF9DYW1saW50ZXJuYWxNb2RfdXBkYXRlX21vZChzaGFwZSxyZWFsLHgpIHtcbiAgaWYodHlwZW9mIHNoYXBlID09PSBcIm51bWJlclwiKVxuICAgIHN3aXRjaChzaGFwZSl7XG4gICAgY2FzZSAwOi8vZnVuY3Rpb25cbiAgICBjYXNlIDE6Ly9sYXp5XG4gICAgY2FzZSAyOi8vY2xhc3NcbiAgICBkZWZhdWx0OlxuICAgICAgY2FtbF91cGRhdGVfZHVtbXkocmVhbCx4KTtcbiAgICB9XG4gIGVsc2VcbiAgICBzd2l0Y2goc2hhcGVbMF0pe1xuICAgIGNhc2UgMDovL21vZHVsZVxuICAgICAgZm9yKHZhciBpPTE7aTxzaGFwZVsxXS5sZW5ndGg7aSsrKVxuICAgICAgICBjYW1sX0NhbWxpbnRlcm5hbE1vZF91cGRhdGVfbW9kKHNoYXBlWzFdW2ldLHJlYWxbaV0seFtpXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vY2FzZSAxOi8vVmFsdWVcbiAgICBkZWZhdWx0OlxuICAgIH07XG4gIHJldHVybiAwXG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbi8vIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4vLyBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuXG4vL1Byb3ZpZGVzOiBjYW1sX3VwZGF0ZV9kdW1teVxuZnVuY3Rpb24gY2FtbF91cGRhdGVfZHVtbXkgKHgsIHkpIHtcbiAgaWYoIHR5cGVvZiB5PT09XCJmdW5jdGlvblwiICkgeyB4LmZ1biA9IHk7IHJldHVybiAwOyB9XG4gIGlmKCB5LmZ1biApIHsgeC5mdW4gPSB5LmZ1bjsgcmV0dXJuIDA7IH1cbiAgdmFyIGkgPSB5Lmxlbmd0aDsgd2hpbGUgKGktLSkgeFtpXSA9IHlbaV07IHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial9pc19ibG9jayBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9pc19ibG9jayAoeCkgeyByZXR1cm4gKyh4IGluc3RhbmNlb2YgQXJyYXkpOyB9XG5cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdGFnXG4vL1JlcXVpcmVzOiBjYW1sX2lzX21sX2J5dGVzLCBjYW1sX2lzX21sX3N0cmluZ1xuZnVuY3Rpb24gY2FtbF9vYmpfdGFnICh4KSB7XG4gIGlmICgoeCBpbnN0YW5jZW9mIEFycmF5KSAmJiB4WzBdID09ICh4WzBdID4+PiAwKSlcbiAgICByZXR1cm4geFswXVxuICBlbHNlIGlmIChjYW1sX2lzX21sX2J5dGVzKHgpKVxuICAgIHJldHVybiAyNTJcbiAgZWxzZSBpZiAoY2FtbF9pc19tbF9zdHJpbmcoeCkpXG4gICAgcmV0dXJuIDI1MlxuICBlbHNlIGlmICgoeCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIDI0N1xuICBlbHNlIGlmICh4ICYmIHguY2FtbF9jdXN0b20pXG4gICAgcmV0dXJuIDI1NVxuICBlbHNlXG4gICAgcmV0dXJuIDEwMDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3RhZyAobXV0YWJsZSwgY29uc3QpXG5mdW5jdGlvbiBjYW1sX29ial9zZXRfdGFnICh4LCB0YWcpIHsgeFswXSA9IHRhZzsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2Jsb2NrIGNvbnN0IChjb25zdCxjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2Jsb2NrICh0YWcsIHNpemUpIHtcbiAgdmFyIG8gPSBuZXcgQXJyYXkoc2l6ZSsxKTtcbiAgb1swXT10YWc7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IHNpemU7IGkrKykgb1tpXSA9IDA7XG4gIHJldHVybiBvO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29ial93aXRoX3RhZ1xuZnVuY3Rpb24gY2FtbF9vYmpfd2l0aF90YWcodGFnLHgpIHtcbiAgdmFyIGwgPSB4Lmxlbmd0aDtcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSB0YWc7XG4gIGZvcih2YXIgaSA9IDE7IGkgPCBsOyBpKysgKSBhW2ldID0geFtpXTtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX2R1cCBtdXRhYmxlIChjb25zdClcbmZ1bmN0aW9uIGNhbWxfb2JqX2R1cCAoeCkge1xuICB2YXIgbCA9IHgubGVuZ3RoO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyApIGFbaV0gPSB4W2ldO1xuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfdHJ1bmNhdGUgKG11dGFibGUsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX29ial90cnVuY2F0ZSAoeCwgcykge1xuICBpZiAoczw9MCB8fCBzICsgMSA+IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJPYmoudHJ1bmNhdGVcIik7XG4gIGlmICh4Lmxlbmd0aCAhPSBzICsgMSkgeC5sZW5ndGggPSBzICsgMTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX21ha2VfZm9yd2FyZFxuZnVuY3Rpb24gY2FtbF9vYmpfbWFrZV9mb3J3YXJkIChiLHYpIHtcbiAgYlswXT0yNTA7XG4gIGJbMV09djtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9sYXp5X21ha2VfZm9yd2FyZCBjb25zdCAoY29uc3QpXG5mdW5jdGlvbiBjYW1sX2xhenlfbWFrZV9mb3J3YXJkICh2KSB7IHJldHVybiBbMjUwLCB2XTsgfVxuXG4vLy8vLy8vLy8vLy8vIENhbWxpbnRlcm5hbE9PXG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9wdWJsaWNfbWV0aG9kIGNvbnN0XG52YXIgY2FtbF9tZXRob2RfY2FjaGUgPSBbXTtcbmZ1bmN0aW9uIGNhbWxfZ2V0X3B1YmxpY19tZXRob2QgKG9iaiwgdGFnLCBjYWNoZWlkKSB7XG4gIHZhciBtZXRocyA9IG9ialsxXTtcbiAgdmFyIG9mcyA9IGNhbWxfbWV0aG9kX2NhY2hlW2NhY2hlaWRdO1xuICBpZiAob2ZzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFycmF5IGlzIG5vdCBzcGFyc2VcbiAgICBmb3IgKHZhciBpID0gY2FtbF9tZXRob2RfY2FjaGUubGVuZ3RoOyBpIDwgY2FjaGVpZDsgaSsrKVxuICAgICAgY2FtbF9tZXRob2RfY2FjaGVbaV0gPSAwO1xuICB9IGVsc2UgaWYgKG1ldGhzW29mc10gPT09IHRhZykge1xuICAgIHJldHVybiBtZXRoc1tvZnMgLSAxXTtcbiAgfVxuICB2YXIgbGkgPSAzLCBoaSA9IG1ldGhzWzFdICogMiArIDEsIG1pO1xuICB3aGlsZSAobGkgPCBoaSkge1xuICAgIG1pID0gKChsaStoaSkgPj4gMSkgfCAxO1xuICAgIGlmICh0YWcgPCBtZXRoc1ttaSsxXSkgaGkgPSBtaS0yO1xuICAgIGVsc2UgbGkgPSBtaTtcbiAgfVxuICBjYW1sX21ldGhvZF9jYWNoZVtjYWNoZWlkXSA9IGxpICsgMTtcbiAgLyogcmV0dXJuIDAgaWYgdGFnIGlzIG5vdCB0aGVyZSAqL1xuICByZXR1cm4gKHRhZyA9PSBtZXRoc1tsaSsxXSA/IG1ldGhzW2xpXSA6IDApO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX29vX2xhc3RfaWRcbnZhciBjYW1sX29vX2xhc3RfaWQgPSAwO1xuXG4vL1Byb3ZpZGVzOiBjYW1sX3NldF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX3NldF9vb19pZCAoYikge1xuICBiWzJdPWNhbWxfb29fbGFzdF9pZCsrO1xuICByZXR1cm4gYjtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mcmVzaF9vb19pZFxuLy9SZXF1aXJlczogY2FtbF9vb19sYXN0X2lkXG5mdW5jdGlvbiBjYW1sX2ZyZXNoX29vX2lkKCkge1xuICByZXR1cm4gY2FtbF9vb19sYXN0X2lkKys7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfb2JqX3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfcmF3X2ZpZWxkKG8saSkgeyByZXR1cm4gb1tpKzFdIH1cblxuLy9Qcm92aWRlczogY2FtbF9vYmpfc2V0X3Jhd19maWVsZFxuZnVuY3Rpb24gY2FtbF9vYmpfc2V0X3Jhd19maWVsZChvLGksdikgeyByZXR1cm4gb1tpKzFdID0gdiB9XG4iLCIvLy8vLy8vLy8gQklHU1RSSU5HXG5cbi8vUHJvdmlkZXM6IGNhbWxfaGFzaF9taXhfYmlnc3RyaW5nXG4vL1JlcXVpcmVzOiBjYW1sX2hhc2hfbWl4X2J5dGVzX2FyclxuZnVuY3Rpb24gY2FtbF9oYXNoX21peF9iaWdzdHJpbmcoaCwgYnMpIHtcbiAgcmV0dXJuIGNhbWxfaGFzaF9taXhfYnl0ZXNfYXJyKGgsYnMuZGF0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ190b19hcnJheV9idWZmZXIgbXV0YWJsZVxuZnVuY3Rpb24gYmlnc3RyaW5nX3RvX2FycmF5X2J1ZmZlcihicykge1xuICByZXR1cm4gYnMuZGF0YS5idWZmZXJcbn1cblxuLy9Qcm92aWRlczogYmlnc3RyaW5nX3RvX3R5cGVkX2FycmF5IG11dGFibGVcbmZ1bmN0aW9uIGJpZ3N0cmluZ190b190eXBlZF9hcnJheShicykge1xuICByZXR1cm4gYnMuZGF0YVxufVxuXG4vL1Byb3ZpZGVzOiBiaWdzdHJpbmdfb2ZfYXJyYXlfYnVmZmVyIG11dGFibGVcbi8vUmVxdWlyZXM6IGNhbWxfYmFfY3JlYXRlX3Vuc2FmZVxuZnVuY3Rpb24gYmlnc3RyaW5nX29mX2FycmF5X2J1ZmZlcihhYikge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShhYik7XG4gIHJldHVybiBjYW1sX2JhX2NyZWF0ZV91bnNhZmUoMTIsIDAsIFt0YS5sZW5ndGhdLCB0YSk7XG59XG5cbi8vUHJvdmlkZXM6IGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheSBtdXRhYmxlXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2NyZWF0ZV91bnNhZmVcbmZ1bmN0aW9uIGJpZ3N0cmluZ19vZl90eXBlZF9hcnJheShiYSkge1xuICB2YXIgdGEgPSBuZXcgam9vX2dsb2JhbF9vYmplY3QuVWludDhBcnJheShiYS5idWZmZXIsIGJhLmJ5dGVPZmZzZXQsIGJhLmxlbmd0aCAqIGJhLkJZVEVTX1BFUl9FTEVNRU5UKTtcbiAgcmV0dXJuIGNhbWxfYmFfY3JlYXRlX3Vuc2FmZSgxMiwgMCwgW3RhLmxlbmd0aF0sIHRhKTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfbWVtY21wXG4vL1JlcXVpcmVzOiBjYW1sX2JhX2dldF8xXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19tZW1jbXAoczEsIHBvczEsIHMyLCBwb3MyLCBsZW4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGEgPSBjYW1sX2JhX2dldF8xKHMxLHBvczEgKyBpKTtcbiAgICB2YXIgYiA9IGNhbWxfYmFfZ2V0XzEoczIscG9zMiArIGkpO1xuICAgIGlmIChhIDwgYikgcmV0dXJuIC0xO1xuICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYShiYTEsIHBvczEsIGJhMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYoMTIgIT0gYmEyLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYToga2luZCBtaXNtYXRjaFwiKTtcbiAgaWYobGVuID09IDApIHJldHVybiAwO1xuICB2YXIgb2ZzMSA9IGJhMS5vZmZzZXQocG9zMSk7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYob2ZzMSArIGxlbiA+IGJhMS5kYXRhLmxlbmd0aCl7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zdWJhcnJheShvZnMxLG9mczErbGVuKTtcbiAgYmEyLmRhdGEuc2V0KHNsaWNlLHBvczIpO1xuICByZXR1cm4gMFxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9tbF9zdHJpbmdfbGVuZ3RoXG5mdW5jdGlvbiBjYW1sX2JpZ3N0cmluZ19ibGl0X3N0cmluZ190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzdHIxKSkge1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICBpZihvZnMyICsgbGVuID4gYmEyLmRhdGEubGVuZ3RoKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIHZhciBzbGljZSA9IGNhbWxfYXJyYXlfb2Zfc3RyaW5nKHN0cjEpLnNsaWNlKHBvczEscG9zMSArIGxlbik7XG4gIGJhMi5kYXRhLnNldChzbGljZSxvZnMyKTtcbiAgcmV0dXJuIDBcbn1cblxuLy9Qcm92aWRlczogY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYVxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50LCBjYW1sX2FycmF5X2JvdW5kX2Vycm9yLCBjYW1sX2FycmF5X29mX2J5dGVzXG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9ieXRlc190b19iYShzdHIxLCBwb3MxLCBiYTIsIHBvczIsIGxlbil7XG4gIGlmKDEyICE9IGJhMi5raW5kKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcImNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhOiBraW5kIG1pc21hdGNoXCIpO1xuICBpZihsZW4gPT0gMCkgcmV0dXJuIDA7XG4gIHZhciBvZnMyID0gYmEyLm9mZnNldChwb3MyKTtcbiAgaWYocG9zMSArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKHN0cjEpKSB7XG4gICAgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICB9XG4gIGlmKG9mczIgKyBsZW4gPiBiYTIuZGF0YS5sZW5ndGgpIHtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgdmFyIHNsaWNlID0gY2FtbF9hcnJheV9vZl9ieXRlcyhzdHIxKS5zbGljZShwb3MxLHBvczEgKyBsZW4pO1xuICBiYTIuZGF0YS5zZXQoc2xpY2Usb2ZzMik7XG4gIHJldHVybiAwXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vUmVxdWlyZXM6IGNhbWxfaW52YWxpZF9hcmd1bWVudCwgY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuLy9SZXF1aXJlczogY2FtbF9ibGl0X2J5dGVzLCBjYW1sX2J5dGVzX29mX2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX21sX2J5dGVzX2xlbmd0aFxuZnVuY3Rpb24gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlcyhiYTEsIHBvczEsIGJ5dGVzMiwgcG9zMiwgbGVuKXtcbiAgaWYoMTIgIT0gYmExLmtpbmQpXG4gICAgY2FtbF9pbnZhbGlkX2FyZ3VtZW50KFwiY2FtbF9iaWdzdHJpbmdfYmxpdF9zdHJpbmdfdG9fYmE6IGtpbmQgbWlzbWF0Y2hcIik7XG4gIGlmKGxlbiA9PSAwKSByZXR1cm4gMDtcbiAgdmFyIG9mczEgPSBiYTEub2Zmc2V0KHBvczEpO1xuICBpZihvZnMxICsgbGVuID4gYmExLmRhdGEubGVuZ3RoKXtcbiAgICBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIH1cbiAgaWYocG9zMiArIGxlbiA+IGNhbWxfbWxfYnl0ZXNfbGVuZ3RoKGJ5dGVzMikpe1xuICAgIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgfVxuICB2YXIgc2xpY2UgPSBiYTEuZGF0YS5zbGljZShvZnMxLCBvZnMxK2xlbik7XG4gIGNhbWxfYmxpdF9ieXRlcyhjYW1sX2J5dGVzX29mX2FycmF5KHNsaWNlKSwgMCwgYnl0ZXMyLCBwb3MyLCBsZW4pO1xuICByZXR1cm4gMFxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy9Qcm92aWRlczogY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyBjb25zdFxuZnVuY3Rpb24gY2FtbF9tbF9kZWJ1Z19pbmZvX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2JhY2t0cmFjZV9zdGF0dXMgY29uc3RcbmZ1bmN0aW9uIGNhbWxfYmFja3RyYWNlX3N0YXR1cyAoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfZ2V0X2V4Y2VwdGlvbl9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmVjb3JkX2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZWNvcmRfYmFja3RyYWNlICgpIHsgcmV0dXJuIDA7IH1cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlIGNvbnN0XG5mdW5jdGlvbiBjYW1sX2NvbnZlcnRfcmF3X2JhY2t0cmFjZSAoKSB7IHJldHVybiBbMF07IH1cbi8vUHJvdmlkZXM6IGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcbmZ1bmN0aW9uIGNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGgoKSB7IHJldHVybiAwOyB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90KCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFxuLy9SZXF1aXJlczogY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiBjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdCAoKSB7XG4gIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlX3Nsb3Q6IGluZGV4IG91dCBvZiBib3VuZHNcIik7XG59XG4vL1Byb3ZpZGVzOiBjYW1sX3Jlc3RvcmVfcmF3X2JhY2t0cmFjZVxuZnVuY3Rpb24gY2FtbF9yZXN0b3JlX3Jhd19iYWNrdHJhY2UoZXhuLCBidCkgeyByZXR1cm4gMCB9XG4vL1Byb3ZpZGVzOiBjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFjayBjb25zdFxuZnVuY3Rpb24gY2FtbF9nZXRfY3VycmVudF9jYWxsc3RhY2sgKCkgeyByZXR1cm4gWzBdOyB9XG5cbi8vUHJvdmlkZXM6IGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Rcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbmZ1bmN0aW9uIGNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3QoKXtcbiAgY2FtbF9mYWlsd2l0aChcImNhbWxfY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3RcIik7XG59XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICovXG4vKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICovXG4vKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgICovXG4vKiAgdGhlIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIGZpbGUgLi4vTElDRU5TRS4gICAgICovXG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qICRJZDogbGV4aW5nLmMgNjA0NSAyMDA0LTAxLTAxIDE2OjQyOjQzWiBkb2xpZ2V6ICQgKi9cblxuLyogVGhlIHRhYmxlLWRyaXZlbiBhdXRvbWF0b24gZm9yIGxleGVycyBnZW5lcmF0ZWQgYnkgY2FtbGxleC4gKi9cblxuLy9Qcm92aWRlczogY2FtbF9sZXhfYXJyYXlcbi8vUmVxdWlyZXM6IGNhbWxfanNieXRlc19vZl9zdHJpbmdcbmZ1bmN0aW9uIGNhbWxfbGV4X2FycmF5KHMpIHtcbiAgcyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocyk7XG4gIHZhciBsID0gcy5sZW5ndGggLyAyO1xuICB2YXIgYSA9IG5ldyBBcnJheShsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgYVtpXSA9IChzLmNoYXJDb2RlQXQoMiAqIGkpIHwgKHMuY2hhckNvZGVBdCgyICogaSArIDEpIDw8IDgpKSA8PCAxNiA+PiAxNjtcbiAgcmV0dXJuIGE7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbGV4X2VuZ2luZVxuLy9SZXF1aXJlczogY2FtbF9mYWlsd2l0aCwgY2FtbF9sZXhfYXJyYXksIGNhbWxfYXJyYXlfb2ZfYnl0ZXNcbmZ1bmN0aW9uIGNhbWxfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG5cbiAgaWYgKCF0YmwubGV4X2RlZmF1bHQpIHtcbiAgICB0YmwubGV4X2Jhc2UgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlXSk7XG4gICAgdGJsLmxleF9iYWNrdHJrID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfYmFja3Rya10pO1xuICAgIHRibC5sZXhfY2hlY2sgPSAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2NoZWNrXSk7XG4gICAgdGJsLmxleF90cmFucyA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNdKTtcbiAgICB0YmwubGV4X2RlZmF1bHQgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9kZWZhdWx0XSk7XG4gIH1cblxuICB2YXIgYywgc3RhdGUgPSBzdGFydF9zdGF0ZTtcblxuICB2YXIgYnVmZmVyID0gY2FtbF9hcnJheV9vZl9ieXRlcyhsZXhidWZbbGV4X2J1ZmZlcl0pO1xuXG4gIGlmIChzdGF0ZSA+PSAwKSB7XG4gICAgLyogRmlyc3QgZW50cnkgKi9cbiAgICBsZXhidWZbbGV4X2xhc3RfcG9zXSA9IGxleGJ1ZltsZXhfc3RhcnRfcG9zXSA9IGxleGJ1ZltsZXhfY3Vycl9wb3NdO1xuICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgLyogUmVlbnRyeSBhZnRlciByZWZpbGwgKi9cbiAgICBzdGF0ZSA9IC1zdGF0ZSAtIDE7XG4gIH1cbiAgZm9yKDs7KSB7XG4gICAgLyogTG9va3VwIGJhc2UgYWRkcmVzcyBvciBhY3Rpb24gbnVtYmVyIGZvciBjdXJyZW50IHN0YXRlICovXG4gICAgdmFyIGJhc2UgPSB0YmwubGV4X2Jhc2Vbc3RhdGVdO1xuICAgIGlmIChiYXNlIDwgMCkgcmV0dXJuIC1iYXNlLTE7XG4gICAgLyogU2VlIGlmIGl0J3MgYSBiYWNrdHJhY2sgcG9pbnQgKi9cbiAgICB2YXIgYmFja3RyayA9IHRibC5sZXhfYmFja3Rya1tzdGF0ZV07XG4gICAgaWYgKGJhY2t0cmsgPj0gMCkge1xuICAgICAgbGV4YnVmW2xleF9sYXN0X3Bvc10gPSBsZXhidWZbbGV4X2N1cnJfcG9zXTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9hY3Rpb25dID0gYmFja3RyaztcbiAgICB9XG4gICAgLyogU2VlIGlmIHdlIG5lZWQgYSByZWZpbGwgKi9cbiAgICBpZiAobGV4YnVmW2xleF9jdXJyX3Bvc10gPj0gbGV4YnVmW2xleF9idWZmZXJfbGVuXSl7XG4gICAgICBpZiAobGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPT0gMClcbiAgICAgICAgcmV0dXJuIC1zdGF0ZSAtIDE7XG4gICAgICBlbHNlXG4gICAgICAgIGMgPSAyNTY7XG4gICAgfWVsc2V7XG4gICAgICAvKiBSZWFkIG5leHQgaW5wdXQgY2hhciAqL1xuICAgICAgYyA9IGJ1ZmZlcltsZXhidWZbbGV4X2N1cnJfcG9zXV07XG4gICAgICBsZXhidWZbbGV4X2N1cnJfcG9zXSArKztcbiAgICB9XG4gICAgLyogRGV0ZXJtaW5lIG5leHQgc3RhdGUgKi9cbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBOZXcgbGV4ZXIgZW5naW5lLCB3aXRoIG1lbW9yeSBvZiBwb3NpdGlvbnMgICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vUHJvdmlkZXM6IGNhbWxfbmV3X2xleF9lbmdpbmVcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGgsIGNhbWxfbGV4X2FycmF5XG4vL1JlcXVpcmVzOiBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nLCBjYW1sX2FycmF5X29mX2J5dGVzXG5mdW5jdGlvbiBjYW1sX2xleF9ydW5fbWVtKHMsIGksIG1lbSwgY3Vycl9wb3MpIHtcbiAgZm9yICg7Oykge1xuICAgIHZhciBkc3QgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoZHN0ID09IDB4ZmYpIHJldHVybjtcbiAgICB2YXIgc3JjID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKHNyYyA9PSAweGZmKVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IGN1cnJfcG9zO1xuICAgIGVsc2VcbiAgICAgIG1lbSBbZHN0ICsgMV0gPSBtZW0gW3NyYyArIDFdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbWxfbGV4X3J1bl90YWcocywgaSwgbWVtKSB7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgZHN0ID0gcy5jaGFyQ29kZUF0KGkpOyBpKys7XG4gICAgaWYgKGRzdCA9PSAweGZmKSByZXR1cm4gO1xuICAgIHZhciBzcmMgPSBzLmNoYXJDb2RlQXQoaSk7IGkrKztcbiAgICBpZiAoc3JjID09IDB4ZmYpXG4gICAgICBtZW0gW2RzdCArIDFdID0gLTE7XG4gICAgZWxzZVxuICAgICAgbWVtIFtkc3QgKyAxXSA9IG1lbSBbc3JjICsgMV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FtbF9uZXdfbGV4X2VuZ2luZSh0YmwsIHN0YXJ0X3N0YXRlLCBsZXhidWYpIHtcbiAgdmFyIGxleF9idWZmZXIgPSAyO1xuICB2YXIgbGV4X2J1ZmZlcl9sZW4gPSAzO1xuICB2YXIgbGV4X3N0YXJ0X3BvcyA9IDU7XG4gIHZhciBsZXhfY3Vycl9wb3MgPSA2O1xuICB2YXIgbGV4X2xhc3RfcG9zID0gNztcbiAgdmFyIGxleF9sYXN0X2FjdGlvbiA9IDg7XG4gIHZhciBsZXhfZW9mX3JlYWNoZWQgPSA5O1xuICB2YXIgbGV4X21lbSA9IDEwO1xuICB2YXIgbGV4X2Jhc2UgPSAxO1xuICB2YXIgbGV4X2JhY2t0cmsgPSAyO1xuICB2YXIgbGV4X2RlZmF1bHQgPSAzO1xuICB2YXIgbGV4X3RyYW5zID0gNDtcbiAgdmFyIGxleF9jaGVjayA9IDU7XG4gIHZhciBsZXhfYmFzZV9jb2RlID0gNjtcbiAgdmFyIGxleF9iYWNrdHJrX2NvZGUgPSA3O1xuICB2YXIgbGV4X2RlZmF1bHRfY29kZSA9IDg7XG4gIHZhciBsZXhfdHJhbnNfY29kZSA9IDk7XG4gIHZhciBsZXhfY2hlY2tfY29kZSA9IDEwO1xuICB2YXIgbGV4X2NvZGUgPSAxMTtcblxuICBpZiAoIXRibC5sZXhfZGVmYXVsdCkge1xuICAgIHRibC5sZXhfYmFzZSA9ICAgIGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2Jhc2VdKTtcbiAgICB0YmwubGV4X2JhY2t0cmsgPSBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYWNrdHJrXSk7XG4gICAgdGJsLmxleF9jaGVjayA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tdKTtcbiAgICB0YmwubGV4X3RyYW5zID0gICBjYW1sX2xleF9hcnJheSAodGJsW2xleF90cmFuc10pO1xuICAgIHRibC5sZXhfZGVmYXVsdCA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2RlZmF1bHRdKTtcbiAgfVxuICBpZiAoIXRibC5sZXhfZGVmYXVsdF9jb2RlKSB7XG4gICAgdGJsLmxleF9iYXNlX2NvZGUgPSAgICBjYW1sX2xleF9hcnJheSAodGJsW2xleF9iYXNlX2NvZGVdKTtcbiAgICB0YmwubGV4X2JhY2t0cmtfY29kZSA9IGNhbWxfbGV4X2FycmF5ICh0YmxbbGV4X2JhY2t0cmtfY29kZV0pO1xuICAgIHRibC5sZXhfY2hlY2tfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfY2hlY2tfY29kZV0pO1xuICAgIHRibC5sZXhfdHJhbnNfY29kZSA9ICAgY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfdHJhbnNfY29kZV0pO1xuICAgIHRibC5sZXhfZGVmYXVsdF9jb2RlID0gY2FtbF9sZXhfYXJyYXkgKHRibFtsZXhfZGVmYXVsdF9jb2RlXSk7XG4gIH1cbiAgaWYgKHRibC5sZXhfY29kZSA9PSBudWxsKSB0YmwubGV4X2NvZGUgPSBjYW1sX2pzYnl0ZXNfb2Zfc3RyaW5nKHRibFtsZXhfY29kZV0pO1xuXG4gIHZhciBjLCBzdGF0ZSA9IHN0YXJ0X3N0YXRlO1xuXG4gIHZhciBidWZmZXIgPSBjYW1sX2FycmF5X29mX2J5dGVzKGxleGJ1ZltsZXhfYnVmZmVyXSk7XG5cbiAgaWYgKHN0YXRlID49IDApIHtcbiAgICAvKiBGaXJzdCBlbnRyeSAqL1xuICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9zdGFydF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgbGV4YnVmW2xleF9sYXN0X2FjdGlvbl0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICAvKiBSZWVudHJ5IGFmdGVyIHJlZmlsbCAqL1xuICAgIHN0YXRlID0gLXN0YXRlIC0gMTtcbiAgfVxuICBmb3IoOzspIHtcbiAgICAvKiBMb29rdXAgYmFzZSBhZGRyZXNzIG9yIGFjdGlvbiBudW1iZXIgZm9yIGN1cnJlbnQgc3RhdGUgKi9cbiAgICB2YXIgYmFzZSA9IHRibC5sZXhfYmFzZVtzdGF0ZV07XG4gICAgaWYgKGJhc2UgPCAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYXNlX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIHJldHVybiAtYmFzZS0xO1xuICAgIH1cbiAgICAvKiBTZWUgaWYgaXQncyBhIGJhY2t0cmFjayBwb2ludCAqL1xuICAgIHZhciBiYWNrdHJrID0gdGJsLmxleF9iYWNrdHJrW3N0YXRlXTtcbiAgICBpZiAoYmFja3RyayA+PSAwKSB7XG4gICAgICB2YXIgcGNfb2ZmID0gdGJsLmxleF9iYWNrdHJrX2NvZGVbc3RhdGVdO1xuICAgICAgY2FtbF9sZXhfcnVuX3RhZyh0YmwubGV4X2NvZGUsIHBjX29mZiwgbGV4YnVmW2xleF9tZW1dKTtcbiAgICAgIGxleGJ1ZltsZXhfbGFzdF9wb3NdID0gbGV4YnVmW2xleF9jdXJyX3Bvc107XG4gICAgICBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9IGJhY2t0cms7XG4gICAgfVxuICAgIC8qIFNlZSBpZiB3ZSBuZWVkIGEgcmVmaWxsICovXG4gICAgaWYgKGxleGJ1ZltsZXhfY3Vycl9wb3NdID49IGxleGJ1ZltsZXhfYnVmZmVyX2xlbl0pe1xuICAgICAgaWYgKGxleGJ1ZltsZXhfZW9mX3JlYWNoZWRdID09IDApXG4gICAgICAgIHJldHVybiAtc3RhdGUgLSAxO1xuICAgICAgZWxzZVxuICAgICAgICBjID0gMjU2O1xuICAgIH1lbHNle1xuICAgICAgLyogUmVhZCBuZXh0IGlucHV0IGNoYXIgKi9cbiAgICAgIGMgPSBidWZmZXJbbGV4YnVmW2xleF9jdXJyX3Bvc11dO1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gKys7XG4gICAgfVxuICAgIC8qIERldGVybWluZSBuZXh0IHN0YXRlICovXG4gICAgdmFyIHBzdGF0ZSA9IHN0YXRlIDtcbiAgICBpZiAodGJsLmxleF9jaGVja1tiYXNlICsgY10gPT0gc3RhdGUpXG4gICAgICBzdGF0ZSA9IHRibC5sZXhfdHJhbnNbYmFzZSArIGNdO1xuICAgIGVsc2VcbiAgICAgIHN0YXRlID0gdGJsLmxleF9kZWZhdWx0W3N0YXRlXTtcbiAgICAvKiBJZiBubyB0cmFuc2l0aW9uIG9uIHRoaXMgY2hhciwgcmV0dXJuIHRvIGxhc3QgYmFja3RyYWNrIHBvaW50ICovXG4gICAgaWYgKHN0YXRlIDwgMCkge1xuICAgICAgbGV4YnVmW2xleF9jdXJyX3Bvc10gPSBsZXhidWZbbGV4X2xhc3RfcG9zXTtcbiAgICAgIGlmIChsZXhidWZbbGV4X2xhc3RfYWN0aW9uXSA9PSAtMSlcbiAgICAgICAgY2FtbF9mYWlsd2l0aChcImxleGluZzogZW1wdHkgdG9rZW5cIik7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBsZXhidWZbbGV4X2xhc3RfYWN0aW9uXTtcbiAgICB9ZWxzZXtcbiAgICAgIC8qIElmIHNvbWUgdHJhbnNpdGlvbiwgZ2V0IGFuZCBwZXJmb3JtIG1lbW9yeSBtb3ZlcyAqL1xuICAgICAgdmFyIGJhc2VfY29kZSA9IHRibC5sZXhfYmFzZV9jb2RlW3BzdGF0ZV0sIHBjX29mZjtcbiAgICAgIGlmICh0YmwubGV4X2NoZWNrX2NvZGVbYmFzZV9jb2RlICsgY10gPT0gcHN0YXRlKVxuICAgICAgICBwY19vZmYgPSB0YmwubGV4X3RyYW5zX2NvZGVbYmFzZV9jb2RlICsgY107XG4gICAgICBlbHNlXG4gICAgICAgIHBjX29mZiA9IHRibC5sZXhfZGVmYXVsdF9jb2RlW3BzdGF0ZV07XG4gICAgICBpZiAocGNfb2ZmID4gMClcbiAgICAgICAgY2FtbF9sZXhfcnVuX21lbVxuICAgICAgKHRibC5sZXhfY29kZSwgcGNfb2ZmLCBsZXhidWZbbGV4X21lbV0sIGxleGJ1ZltsZXhfY3Vycl9wb3NdKTtcbiAgICAgIC8qIEVyYXNlIHRoZSBFT0YgY29uZGl0aW9uIG9ubHkgaWYgdGhlIEVPRiBwc2V1ZG8tY2hhcmFjdGVyIHdhc1xuICAgICAgICAgY29uc3VtZWQgYnkgdGhlIGF1dG9tYXRvbiAoaS5lLiB0aGVyZSB3YXMgbm8gYmFja3RyYWNrIGFib3ZlKVxuICAgICAgKi9cbiAgICAgIGlmIChjID09IDI1NikgbGV4YnVmW2xleF9lb2ZfcmVhY2hlZF0gPSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8vLy8vLy8vLy8vLyBBcnJheVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3N1YiBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X3N1YiAoYSwgaSwgbGVuKSB7XG4gIHZhciBhMiA9IG5ldyBBcnJheShsZW4rMSk7XG4gIGEyWzBdPTA7XG4gIGZvcih2YXIgaTIgPSAxLCBpMT0gaSsxOyBpMiA8PSBsZW47IGkyKyssaTErKyApe1xuICAgIGEyW2kyXT1hW2kxXTtcbiAgfVxuICByZXR1cm4gYTI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfYXJyYXlfYXBwZW5kIG11dGFibGVcbmZ1bmN0aW9uIGNhbWxfYXJyYXlfYXBwZW5kKGExLCBhMikge1xuICB2YXIgbDEgPSBhMS5sZW5ndGgsIGwyID0gYTIubGVuZ3RoO1xuICB2YXIgbCA9IGwxK2wyLTFcbiAgdmFyIGEgPSBuZXcgQXJyYXkobCk7XG4gIGFbMF0gPSAwO1xuICB2YXIgaSA9IDEsaiA9IDE7XG4gIGZvcig7aTxsMTtpKyspIGFbaV09YTFbaV07XG4gIGZvcig7aTxsO2krKyxqKyspIGFbaV09YTJbal07XG4gIHJldHVybiBhO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X2NvbmNhdCBtdXRhYmxlXG5mdW5jdGlvbiBjYW1sX2FycmF5X2NvbmNhdChsKSB7XG4gIHZhciBhID0gWzBdO1xuICB3aGlsZSAobCAhPT0gMCkge1xuICAgIHZhciBiID0gbFsxXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGIubGVuZ3RoOyBpKyspIGEucHVzaChiW2ldKTtcbiAgICBsID0gbFsyXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9ibGl0XG5mdW5jdGlvbiBjYW1sX2FycmF5X2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICBpZiAoaTIgPD0gaTEpIHtcbiAgICBmb3IgKHZhciBqID0gMTsgaiA8PSBsZW47IGorKykgYTJbaTIgKyBqXSA9IGExW2kxICsgal07XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaiA9IGxlbjsgaiA+PSAxOyBqLS0pIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9O1xuICByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2JsaXRcbmZ1bmN0aW9uIGNhbWxfZmxvYXRhcnJheV9ibGl0KGExLCBpMSwgYTIsIGkyLCBsZW4pIHtcbiAgaWYgKGkyIDw9IGkxKSB7XG4gICAgZm9yICh2YXIgaiA9IDE7IGogPD0gbGVuOyBqKyspIGEyW2kyICsgal0gPSBhMVtpMSArIGpdO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGogPSBsZW47IGogPj0gMTsgai0tKSBhMltpMiArIGpdID0gYTFbaTEgKyBqXTtcbiAgfTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vLy8vLy8vLy8vLy8gUGVydmFzaXZlXG4vL1Byb3ZpZGVzOiBjYW1sX2FycmF5X3NldCAobXV0YWJsZSwgY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9zZXQgKGFycmF5LCBpbmRleCwgbmV3dmFsKSB7XG4gIGlmICgoaW5kZXggPCAwKSB8fCAoaW5kZXggPj0gYXJyYXkubGVuZ3RoIC0gMSkpIGNhbWxfYXJyYXlfYm91bmRfZXJyb3IoKTtcbiAgYXJyYXlbaW5kZXgrMV09bmV3dmFsOyByZXR1cm4gMDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9nZXQgbXV0YWJsZSAoY29uc3QsIGNvbnN0KVxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ib3VuZF9lcnJvclxuZnVuY3Rpb24gY2FtbF9hcnJheV9nZXQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoKGluZGV4IDwgMCkgfHwgKGluZGV4ID49IGFycmF5Lmxlbmd0aCAtIDEpKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHJldHVybiBhcnJheVtpbmRleCsxXTtcbn1cblxuLy9Qcm92aWRlczogY2FtbF9hcnJheV9maWxsXG5mdW5jdGlvbiBjYW1sX2FycmF5X2ZpbGwoYXJyYXksIG9mcywgbGVuLCB2KXtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcbiAgICBhcnJheVtvZnMraSsxXSA9IHY7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfY2hlY2tfYm91bmQgKGNvbnN0LCBjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfY2hlY2tfYm91bmQgKGFycmF5LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj4+IDAgPj0gYXJyYXkubGVuZ3RoIC0gMSkgY2FtbF9hcnJheV9ib3VuZF9lcnJvcigpO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV92ZWN0IGNvbnN0IChjb25zdCwgY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX21ha2VfdmVjdCAobGVuLCBpbml0KSB7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0wO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSBiW2ldID0gaW5pdDtcbiAgcmV0dXJuIGI7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWFrZV9mbG9hdF92ZWN0IGNvbnN0IChjb25zdClcbi8vUmVxdWlyZXM6IGNhbWxfYXJyYXlfYm91bmRfZXJyb3JcbmZ1bmN0aW9uIGNhbWxfbWFrZV9mbG9hdF92ZWN0KGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuLy9Qcm92aWRlczogY2FtbF9mbG9hdGFycmF5X2NyZWF0ZSBjb25zdCAoY29uc3QpXG4vL1JlcXVpcmVzOiBjYW1sX2FycmF5X2JvdW5kX2Vycm9yXG5mdW5jdGlvbiBjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlKGxlbil7XG4gIGlmIChsZW4gPCAwKSBjYW1sX2FycmF5X2JvdW5kX2Vycm9yKCk7XG4gIHZhciBsZW4gPSBsZW4gKyAxIHwgMDtcbiAgdmFyIGIgPSBuZXcgQXJyYXkobGVuKTtcbiAgYlswXT0yNTQ7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIGJbaV0gPSAwO1xuICByZXR1cm4gYlxufVxuIiwiLy8gSnNfb2Zfb2NhbWwgcnVudGltZSBzdXBwb3J0XG4vLyBodHRwOi8vd3d3Lm9jc2lnZW4ub3JnL2pzX29mX29jYW1sL1xuLy8gQ29weXJpZ2h0IChDKSAyMDEwIErDqXLDtG1lIFZvdWlsbG9uXG4vLyBMYWJvcmF0b2lyZSBQUFMgLSBDTlJTIFVuaXZlcnNpdMOpIFBhcmlzIERpZGVyb3Rcbi8vXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuLy8gZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy9cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbi8vIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG5cbi8vIFdlYWsgQVBJLCBidXQgd2l0aG91dCB0aGUgd2VhayBzZW1hbnRpY3NcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbi8vVmVyc2lvbjogPCA0LjAzXG52YXIgY2FtbF9lcGhlX2tleV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfa2V5X29mZnNldCA9IDNcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbnZhciBjYW1sX2VwaGVfZGF0YV9vZmZzZXQgPSAyXG5cbi8vUHJvdmlkZXM6IGNhbWxfd2Vha19jcmVhdGVcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9rZXlfb2Zmc2V0LCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jcmVhdGUgKG4pIHtcbiAgaWYgKG4gPCAwKSBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5jcmVhdGVcIik7XG4gIHZhciB4ID0gWzI1MSxcImNhbWxfZXBoZV9saXN0X2hlYWRcIl07XG4gIHgubGVuZ3RoID0gY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBuO1xuICByZXR1cm4geDtcbn1cblxuLy9Qcm92aWRlczogY2FtbF93ZWFrX3NldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX3NldCh4LCBpLCB2KSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5zZXRcIik7XG4gIHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSA9IHY7XG4gIHJldHVybiAwO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldFxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXQsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldCh4LCBpKSB7XG4gIGlmKGkgPCAwIHx8IGNhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaSA+PSB4Lmxlbmd0aClcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQgKFwiV2Vhay5nZXRfa2V5XCIpO1xuICByZXR1cm4gKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpIF09PT11bmRlZmluZWQpPzA6eFtjYW1sX2VwaGVfa2V5X29mZnNldCArIGldO1xufVxuLy9Qcm92aWRlczogY2FtbF93ZWFrX2dldF9jb3B5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0LGNhbWxfZXBoZV9rZXlfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXAsIGNhbWxfaW52YWxpZF9hcmd1bWVudFxuZnVuY3Rpb24gY2FtbF93ZWFrX2dldF9jb3B5KHgsIGkpIHtcbiAgaWYoaSA8IDAgfHwgY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpID49IHgubGVuZ3RoKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudCAoXCJXZWFrLmdldF9jb3B5XCIpO1xuICB2YXIgeSA9IGNhbWxfd2Vha19nZXQoeCwgaSk7XG4gIGlmICh5ID09PSAwKSByZXR1cm4geTtcbiAgdmFyIHogPSB5WzFdO1xuICBpZiAoeiBpbnN0YW5jZW9mIEFycmF5KSByZXR1cm4gWzAsIGNhbWxfb2JqX2R1cCh6KV07XG4gIHJldHVybiB5O1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfY2hlY2sgbXV0YWJsZVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2tleV9vZmZzZXRcbmZ1bmN0aW9uIGNhbWxfd2Vha19jaGVjayh4LCBpKSB7XG4gIGlmKHhbY2FtbF9lcGhlX2tleV9vZmZzZXQgKyBpXSE9PXVuZGVmaW5lZCAmJiB4W2NhbWxfZXBoZV9rZXlfb2Zmc2V0ICsgaV0gIT09MClcbiAgICByZXR1cm4gMTtcbiAgZWxzZVxuICAgIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX3dlYWtfYmxpdFxuLy9SZXF1aXJlczogY2FtbF9hcnJheV9ibGl0XG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfa2V5X29mZnNldFxuZnVuY3Rpb24gY2FtbF93ZWFrX2JsaXQoYTEsIGkxLCBhMiwgaTIsIGxlbikge1xuICAvLyBtaW51cyBvbmUgYmVjYXVzZSBjYW1sX2FycmF5X2JsaXQgd29ya3Mgb24gb2NhbWwgYXJyYXlcbiAgY2FtbF9hcnJheV9ibGl0KGExLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkxIC0gMSxcbiAgICAgICAgICAgICAgICAgIGEyLCBjYW1sX2VwaGVfa2V5X29mZnNldCArIGkyIC0gMSxcbiAgICAgICAgICAgICAgICAgIGxlbik7XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfY3JlYXRlXG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfY3JlYXRlXG52YXIgY2FtbF9lcGhlX2NyZWF0ZSA9IGNhbWxfd2Vha19jcmVhdGVcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2JsaXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfYmxpdFxudmFyIGNhbWxfZXBoZV9ibGl0X2tleSA9IGNhbWxfd2Vha19ibGl0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5XG4vL1JlcXVpcmVzOiBjYW1sX3dlYWtfZ2V0XG52YXIgY2FtbF9lcGhlX2dldF9rZXkgPSBjYW1sX3dlYWtfZ2V0XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9nZXRfa2V5X2NvcHlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19nZXRfY29weVxudmFyIGNhbWxfZXBoZV9nZXRfa2V5X2NvcHkgPSBjYW1sX3dlYWtfZ2V0X2NvcHlcblxuLy9Qcm92aWRlczogY2FtbF9lcGhlX2NoZWNrX2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX2NoZWNrXG52YXIgY2FtbF9lcGhlX2NoZWNrX2tleSA9IGNhbWxfd2Vha19jaGVja1xuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfc2V0X2tleVxuLy9SZXF1aXJlczogY2FtbF93ZWFrX3NldFxuZnVuY3Rpb24gY2FtbF9lcGhlX3NldF9rZXkoeCwgaSwgdikge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCBbMCwgdl0pXG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9rZXlcbi8vUmVxdWlyZXM6IGNhbWxfd2Vha19zZXRcbmZ1bmN0aW9uIGNhbWxfZXBoZV91bnNldF9rZXkoeCwgaSkge1xuICByZXR1cm4gY2FtbF93ZWFrX3NldCh4LCBpLCAwKVxufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfYmxpdF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2JsaXRfZGF0YShzcmMsIGRzdCl7XG4gIGRzdFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gc3JjW2NhbWxfZXBoZV9kYXRhX29mZnNldF07XG4gIHJldHVybiAwO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFcbi8vUmVxdWlyZXM6IGNhbWxfZXBoZV9kYXRhX29mZnNldFxuLy9WZXJzaW9uOiA+PSA0LjAzXG5mdW5jdGlvbiBjYW1sX2VwaGVfZ2V0X2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCB4W2NhbWxfZXBoZV9kYXRhX29mZnNldF1dO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX2VwaGVfZ2V0X2RhdGFfY29weVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1JlcXVpcmVzOiBjYW1sX29ial9kdXBcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2dldF9kYXRhX2NvcHkoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIFswLCBjYW1sX29ial9kdXAoeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdKV07XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9zZXRfZGF0YVxuLy9SZXF1aXJlczogY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XG4vL1ZlcnNpb246ID49IDQuMDNcbmZ1bmN0aW9uIGNhbWxfZXBoZV9zZXRfZGF0YSh4LCBkYXRhKXtcbiAgeFtjYW1sX2VwaGVfZGF0YV9vZmZzZXRdID0gZGF0YTtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV91bnNldF9kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX3Vuc2V0X2RhdGEoeCwgZGF0YSl7XG4gIHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIDA7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfZXBoZV9jaGVja19kYXRhXG4vL1JlcXVpcmVzOiBjYW1sX2VwaGVfZGF0YV9vZmZzZXRcbi8vVmVyc2lvbjogPj0gNC4wM1xuZnVuY3Rpb24gY2FtbF9lcGhlX2NoZWNrX2RhdGEoeCl7XG4gIGlmKHhbY2FtbF9lcGhlX2RhdGFfb2Zmc2V0XSA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiAwO1xuICBlbHNlXG4gICAgcmV0dXJuIDE7XG59XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgSsOpcsO0bWUgVm91aWxsb25cbi8vIExhYm9yYXRvaXJlIFBQUyAtIENOUlMgVW5pdmVyc2l0w6kgUGFyaXMgRGlkZXJvdFxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9jaGFuXG4vL1JlcXVpcmVzOiBjYW1sX21kNV9zdHJpbmcsIGNhbWxfc3RyaW5nX29mX2FycmF5LGNhbWxfbWxfY2hhbm5lbHNcbi8vUmVxdWlyZXM6IGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUsIGNhbWxfY3JlYXRlX2J5dGVzLCBjYW1sX3N0cmluZ19vZl9ieXRlc1xuZnVuY3Rpb24gY2FtbF9tZDVfY2hhbihjaGFuaWQsbGVuKXtcbiAgdmFyIGNoYW4gPSBjYW1sX21sX2NoYW5uZWxzW2NoYW5pZF07XG4gIHZhciBjaGFuX2xlbiA9IGNoYW4uZmlsZS5sZW5ndGgoKTtcbiAgaWYobGVuPDApIGxlbiA9IGNoYW5fbGVuIC0gY2hhbi5vZmZzZXQ7XG4gIGlmKGNoYW4ub2Zmc2V0ICsgbGVuID4gY2hhbl9sZW4pIGNhbWxfcmFpc2VfZW5kX29mX2ZpbGUoKTtcbiAgdmFyIGJ1ZiA9IGNhbWxfY3JlYXRlX2J5dGVzKGxlbik7XG4gIGNoYW4uZmlsZS5yZWFkKGNoYW4ub2Zmc2V0LGJ1ZiwwLGxlbik7XG4gIHJldHVybiBjYW1sX21kNV9zdHJpbmcoY2FtbF9zdHJpbmdfb2ZfYnl0ZXMoYnVmKSwwLGxlbik7XG59XG5cbi8vUHJvdmlkZXM6IGNhbWxfbWQ1X3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9ieXRlc19vZl9zdHJpbmcsIGNhbWxfbWQ1X2J5dGVzXG5mdW5jdGlvbiBjYW1sX21kNV9zdHJpbmcocywgb2ZzLCBsZW4pIHtcbiAgcmV0dXJuIGNhbWxfbWQ1X2J5dGVzKGNhbWxfYnl0ZXNfb2Zfc3RyaW5nKHMpLG9mcyxsZW4pO1xufVxuXG4vL1Byb3ZpZGVzOiBjYW1sX21kNV9ieXRlc1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfb2ZfYXJyYXksIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXNcbnZhciBjYW1sX21kNV9ieXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gYWRkICh4LCB5KSB7IHJldHVybiAoeCArIHkpIHwgMDsgfVxuICBmdW5jdGlvbiB4eChxLGEsYix4LHMsdCkge1xuICAgIGEgPSBhZGQoYWRkKGEsIHEpLCBhZGQoeCwgdCkpO1xuICAgIHJldHVybiBhZGQoKGEgPDwgcykgfCAoYSA+Pj4gKDMyIC0gcykpLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBmZihhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgYykgfCAoKH5iKSAmIGQpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBnZyhhLGIsYyxkLHgscyx0KSB7XG4gICAgcmV0dXJuIHh4KChiICYgZCkgfCAoYyAmICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcbiAgfVxuICBmdW5jdGlvbiBoaChhLGIsYyxkLHgscyx0KSB7IHJldHVybiB4eChiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpOyB9XG4gIGZ1bmN0aW9uIGlpKGEsYixjLGQseCxzLHQpIHsgcmV0dXJuIHh4KGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTsgfVxuXG4gIGZ1bmN0aW9uIG1kNShidWZmZXIsIGxlbmd0aCkge1xuICAgIHZhciBpID0gbGVuZ3RoO1xuICAgIGJ1ZmZlcltpID4+IDJdIHw9IDB4ODAgPDwgKDggKiAoaSAmIDMpKTtcbiAgICBmb3IgKGkgPSAoaSAmIH4weDMpICsgODsoaSAmIDB4M0YpIDwgNjAgO2kgKz0gNClcbiAgICAgIGJ1ZmZlclsoaSA+PiAyKSAtIDFdID0gMDtcbiAgICBidWZmZXJbKGkgPj4gMikgLTFdID0gbGVuZ3RoIDw8IDM7XG4gICAgYnVmZmVyW2kgPj4gMl0gPSAobGVuZ3RoID4+IDI5KSAmIDB4MUZGRkZGRkY7XG5cbiAgICB2YXIgdyA9IFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2XTtcblxuICAgIGZvcihpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgIHZhciBhID0gd1swXSwgYiA9IHdbMV0sIGMgPSB3WzJdLCBkID0gd1szXTtcblxuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAwXSwgNywgMHhENzZBQTQ3OCk7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krIDFdLCAxMiwgMHhFOEM3Qjc1Nik7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krIDJdLCAxNywgMHgyNDIwNzBEQik7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krIDNdLCAyMiwgMHhDMUJEQ0VFRSk7XG4gICAgICBhID0gZmYoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA3LCAweEY1N0MwRkFGKTtcbiAgICAgIGQgPSBmZihkLCBhLCBiLCBjLCBidWZmZXJbaSsgNV0sIDEyLCAweDQ3ODdDNjJBKTtcbiAgICAgIGMgPSBmZihjLCBkLCBhLCBiLCBidWZmZXJbaSsgNl0sIDE3LCAweEE4MzA0NjEzKTtcbiAgICAgIGIgPSBmZihiLCBjLCBkLCBhLCBidWZmZXJbaSsgN10sIDIyLCAweEZENDY5NTAxKTtcbiAgICAgIGEgPSBmZihhLCBiLCBjLCBkLCBidWZmZXJbaSsgOF0sIDcsIDB4Njk4MDk4RDgpO1xuICAgICAgZCA9IGZmKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA5XSwgMTIsIDB4OEI0NEY3QUYpO1xuICAgICAgYyA9IGZmKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTcsIDB4RkZGRjVCQjEpO1xuICAgICAgYiA9IGZmKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzExXSwgMjIsIDB4ODk1Q0Q3QkUpO1xuICAgICAgYSA9IGZmKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKzEyXSwgNywgMHg2QjkwMTEyMik7XG4gICAgICBkID0gZmYoZCwgYSwgYiwgYywgYnVmZmVyW2krMTNdLCAxMiwgMHhGRDk4NzE5Myk7XG4gICAgICBjID0gZmYoYywgZCwgYSwgYiwgYnVmZmVyW2krMTRdLCAxNywgMHhBNjc5NDM4RSk7XG4gICAgICBiID0gZmYoYiwgYywgZCwgYSwgYnVmZmVyW2krMTVdLCAyMiwgMHg0OUI0MDgyMSk7XG5cbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsgMV0sIDUsIDB4RjYxRTI1NjIpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA2XSwgOSwgMHhDMDQwQjM0MCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krMTFdLCAxNCwgMHgyNjVFNUE1MSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krIDBdLCAyMCwgMHhFOUI2QzdBQSk7XG4gICAgICBhID0gZ2coYSwgYiwgYywgZCwgYnVmZmVyW2krIDVdLCA1LCAweEQ2MkYxMDVEKTtcbiAgICAgIGQgPSBnZyhkLCBhLCBiLCBjLCBidWZmZXJbaSsxMF0sIDksIDB4MDI0NDE0NTMpO1xuICAgICAgYyA9IGdnKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTQsIDB4RDhBMUU2ODEpO1xuICAgICAgYiA9IGdnKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyA0XSwgMjAsIDB4RTdEM0ZCQzgpO1xuICAgICAgYSA9IGdnKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA5XSwgNSwgMHgyMUUxQ0RFNik7XG4gICAgICBkID0gZ2coZCwgYSwgYiwgYywgYnVmZmVyW2krMTRdLCA5LCAweEMzMzcwN0Q2KTtcbiAgICAgIGMgPSBnZyhjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE0LCAweEY0RDUwRDg3KTtcbiAgICAgIGIgPSBnZyhiLCBjLCBkLCBhLCBidWZmZXJbaSsgOF0sIDIwLCAweDQ1NUExNEVEKTtcbiAgICAgIGEgPSBnZyhhLCBiLCBjLCBkLCBidWZmZXJbaSsxM10sIDUsIDB4QTlFM0U5MDUpO1xuICAgICAgZCA9IGdnKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAyXSwgOSwgMHhGQ0VGQTNGOCk7XG4gICAgICBjID0gZ2coYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNCwgMHg2NzZGMDJEOSk7XG4gICAgICBiID0gZ2coYiwgYywgZCwgYSwgYnVmZmVyW2krMTJdLCAyMCwgMHg4RDJBNEM4QSk7XG5cbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgNV0sIDQsIDB4RkZGQTM5NDIpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyA4XSwgMTEsIDB4ODc3MUY2ODEpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzExXSwgMTYsIDB4NkQ5RDYxMjIpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKzE0XSwgMjMsIDB4RkRFNTM4MEMpO1xuICAgICAgYSA9IGhoKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyAxXSwgNCwgMHhBNEJFRUE0NCk7XG4gICAgICBkID0gaGgoZCwgYSwgYiwgYywgYnVmZmVyW2krIDRdLCAxMSwgMHg0QkRFQ0ZBOSk7XG4gICAgICBjID0gaGgoYywgZCwgYSwgYiwgYnVmZmVyW2krIDddLCAxNiwgMHhGNkJCNEI2MCk7XG4gICAgICBiID0gaGgoYiwgYywgZCwgYSwgYnVmZmVyW2krMTBdLCAyMywgMHhCRUJGQkM3MCk7XG4gICAgICBhID0gaGgoYSwgYiwgYywgZCwgYnVmZmVyW2krMTNdLCA0LCAweDI4OUI3RUM2KTtcbiAgICAgIGQgPSBoaChkLCBhLCBiLCBjLCBidWZmZXJbaSsgMF0sIDExLCAweEVBQTEyN0ZBKTtcbiAgICAgIGMgPSBoaChjLCBkLCBhLCBiLCBidWZmZXJbaSsgM10sIDE2LCAweEQ0RUYzMDg1KTtcbiAgICAgIGIgPSBoaChiLCBjLCBkLCBhLCBidWZmZXJbaSsgNl0sIDIzLCAweDA0ODgxRDA1KTtcbiAgICAgIGEgPSBoaChhLCBiLCBjLCBkLCBidWZmZXJbaSsgOV0sIDQsIDB4RDlENEQwMzkpO1xuICAgICAgZCA9IGhoKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKzEyXSwgMTEsIDB4RTZEQjk5RTUpO1xuICAgICAgYyA9IGhoKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzE1XSwgMTYsIDB4MUZBMjdDRjgpO1xuICAgICAgYiA9IGhoKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAyXSwgMjMsIDB4QzRBQzU2NjUpO1xuXG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDBdLCA2LCAweEY0MjkyMjQ0KTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsgN10sIDEwLCAweDQzMkFGRjk3KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsxNF0sIDE1LCAweEFCOTQyM0E3KTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgNV0sIDIxLCAweEZDOTNBMDM5KTtcbiAgICAgIGEgPSBpaShhLCBiLCBjLCBkLCBidWZmZXJbaSsxMl0sIDYsIDB4NjU1QjU5QzMpO1xuICAgICAgZCA9IGlpKGQsIGEsIGIsIGMsIGJ1ZmZlcltpKyAzXSwgMTAsIDB4OEYwQ0NDOTIpO1xuICAgICAgYyA9IGlpKGMsIGQsIGEsIGIsIGJ1ZmZlcltpKzEwXSwgMTUsIDB4RkZFRkY0N0QpO1xuICAgICAgYiA9IGlpKGIsIGMsIGQsIGEsIGJ1ZmZlcltpKyAxXSwgMjEsIDB4ODU4NDVERDEpO1xuICAgICAgYSA9IGlpKGEsIGIsIGMsIGQsIGJ1ZmZlcltpKyA4XSwgNiwgMHg2RkE4N0U0Rik7XG4gICAgICBkID0gaWkoZCwgYSwgYiwgYywgYnVmZmVyW2krMTVdLCAxMCwgMHhGRTJDRTZFMCk7XG4gICAgICBjID0gaWkoYywgZCwgYSwgYiwgYnVmZmVyW2krIDZdLCAxNSwgMHhBMzAxNDMxNCk7XG4gICAgICBiID0gaWkoYiwgYywgZCwgYSwgYnVmZmVyW2krMTNdLCAyMSwgMHg0RTA4MTFBMSk7XG4gICAgICBhID0gaWkoYSwgYiwgYywgZCwgYnVmZmVyW2krIDRdLCA2LCAweEY3NTM3RTgyKTtcbiAgICAgIGQgPSBpaShkLCBhLCBiLCBjLCBidWZmZXJbaSsxMV0sIDEwLCAweEJEM0FGMjM1KTtcbiAgICAgIGMgPSBpaShjLCBkLCBhLCBiLCBidWZmZXJbaSsgMl0sIDE1LCAweDJBRDdEMkJCKTtcbiAgICAgIGIgPSBpaShiLCBjLCBkLCBhLCBidWZmZXJbaSsgOV0sIDIxLCAweEVCODZEMzkxKTtcblxuICAgICAgd1swXSA9IGFkZChhLCB3WzBdKTtcbiAgICAgIHdbMV0gPSBhZGQoYiwgd1sxXSk7XG4gICAgICB3WzJdID0gYWRkKGMsIHdbMl0pO1xuICAgICAgd1szXSA9IGFkZChkLCB3WzNdKTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IG5ldyBBcnJheSgxNik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgdFtpICogNCArIGpdID0gKHdbaV0gPj4gKDggKiBqKSkgJiAweEZGO1xuICAgIHJldHVybiB0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzLCBvZnMsIGxlbikge1xuICAgIC8vIEZJWDogbWF5YmUgd2Ugc2hvdWxkIHBlcmZvcm0gdGhlIGNvbXB1dGF0aW9uIGJ5IGNodW5rIG9mIDY0IGJ5dGVzXG4gICAgLy8gYXMgaW4gaHR0cDovL3d3dy5teWVyc2RhaWx5Lm9yZy9qb3NlcGgvamF2YXNjcmlwdC9tZDUuanNcbiAgICB2YXIgYnVmID0gW107XG4gICAgc3dpdGNoIChzLnQgJiA2KSB7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNhbWxfY29udmVydF9zdHJpbmdfdG9fYnl0ZXMocyk7XG4gICAgY2FzZSAwOiAvKiBCWVRFUyAqL1xuICAgICAgdmFyIGIgPSBzLmM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgICB2YXIgaiA9IGkgKyBvZnM7XG4gICAgICAgIGJ1ZltpPj4yXSA9XG4gICAgICAgICAgYi5jaGFyQ29kZUF0KGopIHwgKGIuY2hhckNvZGVBdChqKzEpIDw8IDgpIHxcbiAgICAgICAgICAoYi5jaGFyQ29kZUF0KGorMikgPDwgMTYpIHwgKGIuY2hhckNvZGVBdChqKzMpIDw8IDI0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIGJ1ZltpPj4yXSB8PSBiLmNoYXJDb2RlQXQoaSArIG9mcykgPDwgKDggKiAoaSAmIDMpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDogLyogQVJSQVkgKi9cbiAgICAgIHZhciBhID0gcy5jO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgICAgdmFyIGogPSBpICsgb2ZzO1xuICAgICAgICBidWZbaT4+Ml0gPSBhW2pdIHwgKGFbaisxXSA8PCA4KSB8IChhW2orMl0gPDwgMTYpIHwgKGFbaiszXSA8PCAyNCk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSBidWZbaT4+Ml0gfD0gYVtpICsgb2ZzXSA8PCAoOCAqIChpICYgMykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfYXJyYXkobWQ1KGJ1ZiwgbGVuKSk7XG4gIH1cbn0gKCk7XG4iLCIvLyBKc19vZl9vY2FtbCBydW50aW1lIHN1cHBvcnRcbi8vIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvanNfb2Zfb2NhbWwvXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgLSBIdWdvIEhldXphcmRcbi8vIENvcHlyaWdodCAoQykgMjAyMCAtIFNoYWNoYXIgSXR6aGFreVxuLy9cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4vLyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vL1xuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4vL1xuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuLy8gRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cblxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL2Jsb2IvNC4wNy9vdGhlcmxpYnMvc3RyL3N0cnN0dWJzLmNcbi8vIENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qc2NvcS9qc2NvcS9ibG9iL3Y4LjExL2NvcS1qcy9qc19zdHViL3N0ci5qc1xuXG4vL1Byb3ZpZGVzOiByZV9tYXRjaFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9qc19mcm9tX2FycmF5LCBjYW1sX2FycmF5X29mX3N0cmluZ1xuLy9SZXF1aXJlczogY2FtbF9zdHJpbmdfZ2V0XG5cbnZhciByZV9tYXRjaCA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZV93b3JkX2xldHRlcnMgPSBbXG4gICAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgICAgICAgLyogMHgwMC0weDFGOiBub25lICovXG4gICAgMHgwMCwgMHgwMCwgMHhGRiwgMHgwMywgICAgICAgLyogMHgyMC0weDNGOiBkaWdpdHMgMC05ICovXG4gICAgMHhGRSwgMHhGRiwgMHhGRiwgMHg4NywgICAgICAgLyogMHg0MC0weDVGOiBBIHRvIFosIF8gKi9cbiAgICAweEZFLCAweEZGLCAweEZGLCAweDA3LCAgICAgICAvKiAweDYwLTB4N0Y6IGEgdG8geiAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4ODAtMHg5Rjogbm9uZSAqL1xuICAgIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsICAgICAgIC8qIDB4QTAtMHhCRjogbm9uZSAqL1xuICAgIDB4RkYsIDB4RkYsIDB4N0YsIDB4RkYsICAgICAgIC8qIDB4QzAtMHhERjogTGF0aW4tMSBhY2NlbnRlZCB1cHBlcmNhc2UgKi9cbiAgICAweEZGLCAweEZGLCAweDdGLCAweEZGICAgICAgICAvKiAweEUwLTB4RkY6IExhdGluLTEgYWNjZW50ZWQgbG93ZXJjYXNlICovXG4gIF07XG5cbiAgdmFyIG9wY29kZXMgPSB7XG4gICAgQ0hBUjogMCwgQ0hBUk5PUk06IDEsIFNUUklORzogMiwgU1RSSU5HTk9STTogMywgQ0hBUkNMQVNTOiA0LFxuICAgIEJPTDogNSwgRU9MOiA2LCBXT1JEQk9VTkRBUlk6IDcsXG4gICAgQkVHR1JPVVA6IDgsIEVOREdST1VQOiA5LCBSRUZHUk9VUDogMTAsXG4gICAgQUNDRVBUOiAxMSxcbiAgICBTSU1QTEVPUFQ6IDEyLCBTSU1QTEVTVEFSOiAxMywgU0lNUExFUExVUzogMTQsXG4gICAgR09UTzogMTUsIFBVU0hCQUNLOiAxNiwgU0VUTUFSSzogMTcsXG4gICAgQ0hFQ0tQUk9HUkVTUzogMThcbiAgfTtcblxuICBmdW5jdGlvbiBpc193b3JkX2xldHRlcihjKSB7XG4gICAgcmV0dXJuIChyZV93b3JkX2xldHRlcnNbICAoYyA+PiAzKV0gPj4gKGMgJiA3KSkgJiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5fYml0c2V0KHMsaSkge1xuICAgIHJldHVybiAoY2FtbF9zdHJpbmdfZ2V0KHMsKGkgPj4gMykpID4+IChpICYgNykpICYgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlX21hdGNoX2ltcGwocmUsIHMsIHBvcywgcGFydGlhbCkge1xuXG4gICAgdmFyIHByb2cgICAgICAgICAgPSBjYW1sX2pzX2Zyb21fYXJyYXkocmVbMV0pLFxuICAgICAgICBjcG9vbCAgICAgICAgID0gY2FtbF9qc19mcm9tX2FycmF5KHJlWzJdKSxcbiAgICAgICAgbm9ybXRhYmxlICAgICA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcocmVbM10pLFxuICAgICAgICBudW1ncm91cHMgICAgID0gcmVbNF0gfCAwLFxuICAgICAgICBudW1yZWdpc3RlcnMgID0gcmVbNV0gfCAwLFxuICAgICAgICBzdGFydGNoYXJzICAgID0gcmVbNl0gfCAwO1xuXG4gICAgdmFyIHMgPSBjYW1sX2FycmF5X29mX3N0cmluZyhzKTtcblxuICAgIHZhciBwYyA9IDAsXG4gICAgICAgIHF1aXQgPSBmYWxzZSxcbiAgICAgICAgc3RhY2sgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gbmV3IEFycmF5KG51bWdyb3VwcyksXG4gICAgICAgIHJlX3JlZ2lzdGVyID0gbmV3IEFycmF5KG51bXJlZ2lzdGVycyk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKXtcbiAgICAgIGdyb3Vwc1tpXSA9IHtzdGFydDogLTEsIGVuZDotMX1cbiAgICB9XG4gICAgZ3JvdXBzWzBdLnN0YXJ0ID0gcG9zO1xuXG4gICAgdmFyIGJhY2t0cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGl0ZW0udW5kbykge1xuICAgICAgICAgIGl0ZW0udW5kby5vYmpbaXRlbS51bmRvLnByb3BdID0gaXRlbS51bmRvLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaXRlbS5wb3MpIHtcbiAgICAgICAgICBwYyA9IGl0ZW0ucG9zLnBjO1xuICAgICAgICAgIHBvcyA9IGl0ZW0ucG9zLnR4dDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHF1aXQgPSB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgcHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHsgc3RhY2sucHVzaChpdGVtKTsgfTtcblxuICAgIHZhciBhY2NlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBncm91cHNbMF0uZW5kID0gcG9zO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSgxICsgZ3JvdXBzLmxlbmd0aCoyKTtcbiAgICAgIHJlc3VsdFswXSA9IDA7IC8vIHRhZ1xuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBnID0gZ3JvdXBzW2ldO1xuICAgICAgICBpZihnLnN0YXJ0IDwgMCB8fCBnLmVuZCA8IDApIHtcbiAgICAgICAgICBnLnN0YXJ0ID0gZy5lbmQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbMippICsgMSBdID0gZy5zdGFydDtcbiAgICAgICAgcmVzdWx0WzIqaSArIDEgKyAxIF0gPSBnLmVuZDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfTtcblxuICAgIHZhciBwcmVmaXhfbWF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZihwYXJ0aWFsKSByZXR1cm4gYWNjZXB0ICgpO1xuICAgICAgZWxzZSBiYWNrdHJhY2sgKCk7XG4gICAgfVxuXG4gICAgLyogTWFpbiBERkEgaW50ZXJwcmV0ZXIgbG9vcCAqL1xuICAgIHdoaWxlICghcXVpdCkge1xuICAgICAgdmFyIG9wID0gcHJvZ1twY10gJiAweGZmLFxuICAgICAgICAgIHNhcmcgPSBwcm9nW3BjXSA+PiA4LFxuICAgICAgICAgIHVhcmcgPSBzYXJnICYgMHhmZixcbiAgICAgICAgICBjID0gc1twb3NdLFxuICAgICAgICAgIGdyb3VwO1xuXG4gICAgICBwYysrO1xuXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIG9wY29kZXMuQ0hBUjpcbiAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICBpZiAoYyA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJOT1JNOlxuICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gdWFyZykgcG9zKys7XG4gICAgICAgIGVsc2UgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNUUklORzpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChjID09PSBhcmcuY2hhckNvZGVBdChpKSlcbiAgICAgICAgICAgIGMgPSBzWysrcG9zXTtcbiAgICAgICAgICBlbHNlIHsgYmFja3RyYWNrKCk7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU1RSSU5HTk9STTpcbiAgICAgICAgZm9yICh2YXIgYXJnID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhjcG9vbFt1YXJnXSksIGkgPSAwOyBpIDwgYXJnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYocG9zID09PSBzLmxlbmd0aCkge3ByZWZpeF9tYXRjaCAoKTsgYnJlYWt9O1xuICAgICAgICAgIGlmIChub3JtdGFibGUuY2hhckNvZGVBdChjKSA9PT0gYXJnLmNoYXJDb2RlQXQoaSkpXG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgZWxzZSB7IGJhY2t0cmFjaygpOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLkNIQVJDTEFTUzpcbiAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBlbHNlIGJhY2t0cmFjaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CT0w6XG4gICAgICAgIGlmKHBvcyA+IDAgJiYgc1twb3MgLSAxXSAhPSAxMCAvKiBcXG4gKi8pIHtiYWNrdHJhY2soKX1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuRU9MOlxuICAgICAgICBpZihwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT0gMTAgLyogXFxuICovKSB7YmFja3RyYWNrKCl9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLldPUkRCT1VOREFSWTpcbiAgICAgICAgaWYocG9zID09IDApIHtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoaXNfd29yZF9sZXR0ZXIoc1swXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA9PT0gcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZihpc193b3JkX2xldHRlcihzW3BvcyAtIDFdKSkgYnJlYWs7XG4gICAgICAgICAgYmFja3RyYWNrICgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmKGlzX3dvcmRfbGV0dGVyKHNbcG9zIC0gMV0pICE9IGlzX3dvcmRfbGV0dGVyKHNbcG9zXSkpIGJyZWFrO1xuICAgICAgICAgIGJhY2t0cmFjayAoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5CRUdHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6Z3JvdXAsXG4gICAgICAgICAgICAgICAgICAgICBwcm9wOidzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXAuc3RhcnR9fSk7XG4gICAgICAgIGdyb3VwLnN0YXJ0ID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5FTkRHUk9VUDpcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbdWFyZ107XG4gICAgICAgIHB1c2goe3VuZG86IHtvYmo6IGdyb3VwLFxuICAgICAgICAgICAgICAgICAgICAgcHJvcDonZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC5lbmR9fSk7XG4gICAgICAgIGdyb3VwLmVuZCA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuUkVGR1JPVVA6XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW3VhcmddO1xuICAgICAgICBpZihncm91cC5zdGFydCA8IDAgfHwgZ3JvdXAuZW5kIDwgMCkge2JhY2t0cmFjayAoKTsgYnJlYWt9XG4gICAgICAgIGZvciAodmFyIGkgPSBncm91cC5zdGFydDsgaSA8IGdyb3VwLmVuZDsgaSsrKXtcbiAgICAgICAgICBpZihwb3MgPT09IHMubGVuZ3RoKSB7cHJlZml4X21hdGNoICgpOyBicmVha307XG4gICAgICAgICAgaWYoc1tpXSAhPSBzW3Bvc10pIHtiYWNrdHJhY2sgKCk7IGJyZWFrfVxuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRU9QVDpcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHBvcysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5TSU1QTEVTVEFSOlxuICAgICAgICB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSlcbiAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlNJTVBMRVBMVVM6XG4gICAgICAgIGlmKHBvcyA9PT0gcy5sZW5ndGgpIHtwcmVmaXhfbWF0Y2ggKCk7IGJyZWFrfTtcbiAgICAgICAgaWYgKGluX2JpdHNldChjcG9vbFt1YXJnXSwgYykpIHtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBjID0gc1srK3Bvc107XG4gICAgICAgICAgfSB3aGlsZSAoaW5fYml0c2V0KGNwb29sW3VhcmddLCBjKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBiYWNrdHJhY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuQUNDRVBUOlxuICAgICAgICByZXR1cm4gYWNjZXB0KCk7XG4gICAgICBjYXNlIG9wY29kZXMuR09UTzpcbiAgICAgICAgcGMgPSBwYyArIHNhcmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvcGNvZGVzLlBVU0hCQUNLOlxuICAgICAgICBwdXNoKHtwb3M6IHtwYzogcGMgKyBzYXJnLCB0eHQ6IHBvc319KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG9wY29kZXMuU0VUTUFSSzpcbiAgICAgICAgcHVzaCh7dW5kbzoge29iajpyZV9yZWdpc3RlcixcbiAgICAgICAgICAgICAgICAgICAgIHByb3A6IHVhcmcsXG4gICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVfcmVnaXN0ZXJbdWFyZ119fSk7XG4gICAgICAgIHJlX3JlZ2lzdGVyW3VhcmddID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugb3Bjb2Rlcy5DSEVDS1BST0dSRVNTOlxuICAgICAgICBpZiAocmVfcmVnaXN0ZXJbdWFyZ10gPT09IHBvcykgYmFja3RyYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlY29kZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gcmVfbWF0Y2hfaW1wbDtcbn0oKTtcblxuXG4vL1Byb3ZpZGVzOiByZV9zZWFyY2hfZm9yd2FyZFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zZWFyY2hfZm9yd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfZm9yd2FyZFwiKVxuICB3aGlsZSAocG9zIDw9IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSkge1xuICAgIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgICBpZiAocmVzKSByZXR1cm4gcmVzO1xuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIFswXTsgIC8qIFt8fF0gOiBpbnQgYXJyYXkgKi9cbn1cblxuLy9Qcm92aWRlczogcmVfc2VhcmNoX2JhY2t3YXJkXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3NlYXJjaF9iYWNrd2FyZChyZSwgcywgcG9zKSB7XG4gIGlmKHBvcyA8IDAgfHwgcG9zID4gY2FtbF9tbF9zdHJpbmdfbGVuZ3RoKHMpKVxuICAgIGNhbWxfaW52YWxpZF9hcmd1bWVudChcIlN0ci5zZWFyY2hfYmFja3dhcmRcIilcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHJlcyA9IHJlX21hdGNoKHJlLCBzLCBwb3MsIDApO1xuICAgIGlmIChyZXMpIHJldHVybiByZXM7XG4gICAgcG9zLS07XG4gIH1cblxuICByZXR1cm4gWzBdOyAgLyogW3x8XSA6IGludCBhcnJheSAqL1xufVxuXG5cbi8vUHJvdmlkZXM6IHJlX3N0cmluZ19tYXRjaFxuLy9SZXF1aXJlczogcmVfbWF0Y2gsIGNhbWxfbWxfc3RyaW5nX2xlbmd0aCwgY2FtbF9pbnZhbGlkX2FyZ3VtZW50XG5mdW5jdGlvbiByZV9zdHJpbmdfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIuc3RyaW5nX21hdGNoXCIpXG4gIHZhciByZXMgPSByZV9tYXRjaChyZSwgcywgcG9zLCAwKTtcbiAgaWYgKHJlcykgcmV0dXJuIHJlcztcbiAgZWxzZSByZXR1cm4gWzBdO1xufVxuXG4vL1Byb3ZpZGVzOiByZV9wYXJ0aWFsX21hdGNoXG4vL1JlcXVpcmVzOiByZV9tYXRjaCwgY2FtbF9tbF9zdHJpbmdfbGVuZ3RoLCBjYW1sX2ludmFsaWRfYXJndW1lbnRcbmZ1bmN0aW9uIHJlX3BhcnRpYWxfbWF0Y2gocmUscyxwb3Mpe1xuICBpZihwb3MgPCAwIHx8IHBvcyA+IGNhbWxfbWxfc3RyaW5nX2xlbmd0aChzKSlcbiAgICBjYW1sX2ludmFsaWRfYXJndW1lbnQoXCJTdHIucGFydGlhbF9tYXRjaFwiKVxuICB2YXIgcmVzID0gcmVfbWF0Y2gocmUsIHMsIHBvcywgMSk7XG4gIGlmIChyZXMpIHJldHVybiByZXM7XG4gIGVsc2UgcmV0dXJuIFswXTtcbn1cblxuLy9Qcm92aWRlczogcmVfcmVwbGFjZW1lbnRfdGV4dFxuLy9SZXF1aXJlczogY2FtbF9qc2J5dGVzX29mX3N0cmluZywgY2FtbF9zdHJpbmdfb2ZfanNieXRlc1xuLy9SZXF1aXJlczogY2FtbF9hcnJheV9nZXRcbi8vUmVxdWlyZXM6IGNhbWxfZmFpbHdpdGhcbi8vIGV4dGVybmFsIHJlX3JlcGxhY2VtZW50X3RleHQ6IHN0cmluZyAtPiBpbnQgYXJyYXkgLT4gc3RyaW5nIC0+IHN0cmluZ1xuZnVuY3Rpb24gcmVfcmVwbGFjZW1lbnRfdGV4dChyZXBsLGdyb3VwcyxvcmlnKSB7XG4gIHZhciByZXBsID0gY2FtbF9qc2J5dGVzX29mX3N0cmluZyhyZXBsKTtcbiAgdmFyIGxlbiA9IHJlcGwubGVuZ3RoO1xuICB2YXIgb3JpZyA9IGNhbWxfanNieXRlc19vZl9zdHJpbmcob3JpZyk7XG4gIHZhciByZXMgPSBcIlwiOyAvL3Jlc3VsdFxuICB2YXIgbiA9IDA7IC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgdmFyIGN1cjsgLy9jdXJyZW50IGNoYXJcbiAgdmFyIHN0YXJ0LCBlbmQsIGM7XG4gIHdoaWxlKG4gPCBsZW4pe1xuICAgIGN1ciA9IHJlcGwuY2hhckF0KG4rKyk7XG4gICAgaWYoY3VyICE9ICdcXFxcJyl7XG4gICAgICByZXMgKz0gY3VyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmKG4gPT0gbGVuKSBjYW1sX2ZhaWx3aXRoKFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCIpO1xuICAgICAgY3VyID0gcmVwbC5jaGFyQXQobisrKTtcbiAgICAgIHN3aXRjaChjdXIpe1xuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIHJlcyArPSBjdXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnMCc6IGNhc2UgJzEnOiBjYXNlICcyJzogY2FzZSAnMyc6IGNhc2UgJzQnOlxuICAgICAgY2FzZSAnNSc6IGNhc2UgJzYnOiBjYXNlICc3JzogY2FzZSAnOCc6IGNhc2UgJzknOlxuICAgICAgICBjID0gK2N1cjtcbiAgICAgICAgaWYgKGMqMiA+PSBncm91cHMubGVuZ3RoIC0gMSApXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIgKTtcbiAgICAgICAgc3RhcnQgPSBjYW1sX2FycmF5X2dldChncm91cHMsYyoyKTtcbiAgICAgICAgZW5kID0gY2FtbF9hcnJheV9nZXQoZ3JvdXBzLCBjKjIgKzEpO1xuICAgICAgICBpZiAoc3RhcnQgPT0gLTEpXG4gICAgICAgICAgY2FtbF9mYWlsd2l0aChcIlN0ci5yZXBsYWNlOiByZWZlcmVuY2UgdG8gdW5tYXRjaGVkIGdyb3VwXCIpO1xuICAgICAgICByZXMrPW9yaWcuc2xpY2Uoc3RhcnQsZW5kKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgKz0gKCdcXFxcJyAgKyBjdXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FtbF9zdHJpbmdfb2ZfanNieXRlcyhyZXMpOyB9XG4iLCIvL1RoZSBmb2xsb3dpbmcgYXJlIGRlZmluZWQgaW4gQ3N0cnVjdFxuLy9UaGVyZSBhcmUganVzdCBwcm92aWRlZCBoZXJlIGZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnNcblxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYmFcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fYmlnc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19iYVxuLy9Qcm92aWRlczogY2FtbF9ibGl0X2JpZ3N0cmluZ190b19zdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfYmFfdG9fYnl0ZXNcbi8vV2Vha2RlZlxudmFyIGNhbWxfYmxpdF9iaWdzdHJpbmdfdG9fc3RyaW5nID0gY2FtbF9iaWdzdHJpbmdfYmxpdF9iYV90b19ieXRlc1xuLy9Qcm92aWRlczogY2FtbF9ibGl0X3N0cmluZ190b19iaWdzdHJpbmdcbi8vUmVxdWlyZXM6IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4vL1dlYWtkZWZcbnZhciBjYW1sX2JsaXRfc3RyaW5nX3RvX2JpZ3N0cmluZyA9IGNhbWxfYmlnc3RyaW5nX2JsaXRfc3RyaW5nX3RvX2JhXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIERhbmllbCBDLiBCdWVuemxpICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE0IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGZvcm1hdF9pbnQgOiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZyA9IFwiY2FtbF9mb3JtYXRfaW50XCJcblxubGV0IGVycl9ub19wcmVkID0gXCJVKzAwMDAgaGFzIG5vIHByZWRlY2Vzc29yXCJcbmxldCBlcnJfbm9fc3VjYyA9IFwiVSsxMEZGRkYgaGFzIG5vIHN1Y2Nlc3NvclwiXG5sZXQgZXJyX25vdF9zdiBpID0gZm9ybWF0X2ludCBcIiVYXCIgaSBeIFwiIGlzIG5vdCBhbiBVbmljb2RlIHNjYWxhciB2YWx1ZVwiXG5sZXQgZXJyX25vdF9sYXRpbjEgdSA9IFwiVStcIiBeIGZvcm1hdF9pbnQgXCIlMDRYXCIgdSBeIFwiIGlzIG5vdCBhIGxhdGluMSBjaGFyYWN0ZXJcIlxuXG50eXBlIHQgPSBpbnRcblxubGV0IG1pbiA9IDB4MDAwMFxubGV0IG1heCA9IDB4MTBGRkZGXG5sZXQgbG9fYm91bmQgPSAweEQ3RkZcbmxldCBoaV9ib3VuZCA9IDB4RTAwMFxuXG5sZXQgYm9tID0gMHhGRUZGXG5sZXQgcmVwID0gMHhGRkZEXG5cbmxldCBzdWNjIHUgPVxuICBpZiB1ID0gbG9fYm91bmQgdGhlbiBoaV9ib3VuZCBlbHNlXG4gIGlmIHUgPSBtYXggdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fc3VjYyBlbHNlXG4gIHUgKyAxXG5cbmxldCBwcmVkIHUgPVxuICBpZiB1ID0gaGlfYm91bmQgdGhlbiBsb19ib3VuZCBlbHNlXG4gIGlmIHUgPSBtaW4gdGhlbiBpbnZhbGlkX2FyZyBlcnJfbm9fcHJlZCBlbHNlXG4gIHUgLSAxXG5cbmxldCBpc192YWxpZCBpID0gKG1pbiA8PSBpICYmIGkgPD0gbG9fYm91bmQpIHx8IChoaV9ib3VuZCA8PSBpICYmIGkgPD0gbWF4KVxubGV0IG9mX2ludCBpID0gaWYgaXNfdmFsaWQgaSB0aGVuIGkgZWxzZSBpbnZhbGlkX2FyZyAoZXJyX25vdF9zdiBpKVxuZXh0ZXJuYWwgdW5zYWZlX29mX2ludCA6IGludCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgdG9faW50IDogdCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5cbmxldCBpc19jaGFyIHUgPSB1IDwgMjU2XG5sZXQgb2ZfY2hhciBjID0gQ2hhci5jb2RlIGNcbmxldCB0b19jaGFyIHUgPVxuICBpZiB1ID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgKGVycl9ub3RfbGF0aW4xIHUpIGVsc2VcbiAgQ2hhci51bnNhZmVfY2hyIHVcblxubGV0IHVuc2FmZV90b19jaGFyID0gQ2hhci51bnNhZmVfY2hyXG5cbmxldCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50ID0gU3RkbGliLmNvbXBhcmVcbmxldCBoYXNoID0gdG9faW50XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbSW50NjRdOiA2NC1iaXQgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnIDogaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9uZWdcIlxuZXh0ZXJuYWwgYWRkIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hZGRcIlxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuZXh0ZXJuYWwgbXVsIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tdWxcIlxuZXh0ZXJuYWwgZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9kaXZcIlxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuZXh0ZXJuYWwgbG9nYW5kIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hbmRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X29yXCJcbmV4dGVybmFsIGxvZ3hvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfeG9yXCJcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9sc2xcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogaW50NjQgLT4gaW50ID0gXCIlaW50NjRfdG9faW50XCJcbmV4dGVybmFsIG9mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2ZfZmxvYXRcIiBcImNhbWxfaW50NjRfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0b19mbG9hdCA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X3RvX2Zsb2F0XCIgXCJjYW1sX2ludDY0X3RvX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbmV4dGVybmFsIHRvX2ludDMyIDogaW50NjQgLT4gaW50MzIgPSBcIiVpbnQ2NF90b19pbnQzMlwiXG5leHRlcm5hbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9uYXRpdmVpbnRcIlxuZXh0ZXJuYWwgdG9fbmF0aXZlaW50IDogaW50NjQgLT4gbmF0aXZlaW50ID0gXCIlaW50NjRfdG9fbmF0aXZlaW50XCJcblxubGV0IHplcm8gPSAwTFxubGV0IG9uZSA9IDFMXG5sZXQgbWludXNfb25lID0gLTFMXG5sZXQgc3VjYyBuID0gYWRkIG4gMUxcbmxldCBwcmVkIG4gPSBzdWIgbiAxTFxubGV0IGFicyBuID0gaWYgbiA+PSAwTCB0aGVuIG4gZWxzZSBuZWcgblxubGV0IG1pbl9pbnQgPSAweDgwMDAwMDAwMDAwMDAwMDBMXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZGRkZGRkZGRkxcbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMUwpXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmcgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmxldCB0b19zdHJpbmcgbiA9IGZvcm1hdCBcIiVkXCIgblxuXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjQgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cblxuXG5leHRlcm5hbCBiaXRzX29mX2Zsb2F0IDogZmxvYXQgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfYml0c19vZl9mbG9hdFwiIFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvYXRfb2ZfYml0cyA6IGludDY0IC0+IGZsb2F0XG4gID0gXCJjYW1sX2ludDY0X2Zsb2F0X29mX2JpdHNcIiBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c191bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxudHlwZSB0ID0gaW50NjRcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxubGV0IGVxdWFsICh4OiB0KSAoeTogdCkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0IHVuc2lnbmVkX2NvbXBhcmUgbiBtID1cbiAgY29tcGFyZSAoc3ViIG4gbWluX2ludCkgKHN1YiBtIG1pbl9pbnQpXG5cbigqIFVuc2lnbmVkIGRpdmlzaW9uIGZyb20gc2lnbmVkIGRpdmlzaW9uIG9mIHRoZSBzYW1lXG4gICBiaXRuZXNzLiBTZWUgV2FycmVuIEpyLiwgSGVucnkgUy4gKDIwMTMpLiBIYWNrZXIncyBEZWxpZ2h0ICgyIGVkLiksIFNlYyA5LTMuXG4qKVxubGV0IHVuc2lnbmVkX2RpdiBuIGQgPVxuICBpZiBkIDwgemVybyB0aGVuXG4gICAgaWYgdW5zaWduZWRfY29tcGFyZSBuIGQgPCAwIHRoZW4gemVybyBlbHNlIG9uZVxuICBlbHNlXG4gICAgbGV0IHEgPSBzaGlmdF9sZWZ0IChkaXYgKHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgbiAxKSBkKSAxIGluXG4gICAgbGV0IHIgPSBzdWIgbiAobXVsIHEgZCkgaW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIHIgZCA+PSAwIHRoZW4gc3VjYyBxIGVsc2UgcVxuXG5sZXQgdW5zaWduZWRfcmVtIG4gZCA9XG4gIHN1YiBuIChtdWwgKHVuc2lnbmVkX2RpdiBuIGQpIGQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBsZXhlcnMgZ2VuZXJhdGVkIGJ5IGNhbWxsZXggKilcblxudHlwZSBwb3NpdGlvbiA9IHtcbiAgcG9zX2ZuYW1lIDogc3RyaW5nO1xuICBwb3NfbG51bSA6IGludDtcbiAgcG9zX2JvbCA6IGludDtcbiAgcG9zX2NudW0gOiBpbnQ7XG59XG5cbmxldCBkdW1teV9wb3MgPSB7XG4gIHBvc19mbmFtZSA9IFwiXCI7XG4gIHBvc19sbnVtID0gMDtcbiAgcG9zX2JvbCA9IDA7XG4gIHBvc19jbnVtID0gLTE7XG59XG5cbnR5cGUgbGV4YnVmID1cbiAgeyByZWZpbGxfYnVmZiA6IGxleGJ1ZiAtPiB1bml0O1xuICAgIG11dGFibGUgbGV4X2J1ZmZlciA6IGJ5dGVzO1xuICAgIG11dGFibGUgbGV4X2J1ZmZlcl9sZW4gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfYWJzX3BvcyA6IGludDtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9wb3MgOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfbGFzdF9hY3Rpb24gOiBpbnQ7XG4gICAgbXV0YWJsZSBsZXhfZW9mX3JlYWNoZWQgOiBib29sO1xuICAgIG11dGFibGUgbGV4X21lbSA6IGludCBhcnJheTtcbiAgICBtdXRhYmxlIGxleF9zdGFydF9wIDogcG9zaXRpb247XG4gICAgbXV0YWJsZSBsZXhfY3Vycl9wIDogcG9zaXRpb247XG4gIH1cblxudHlwZSBsZXhfdGFibGVzID1cbiAgeyBsZXhfYmFzZTogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHQ6IHN0cmluZztcbiAgICBsZXhfdHJhbnM6IHN0cmluZztcbiAgICBsZXhfY2hlY2s6IHN0cmluZztcbiAgICBsZXhfYmFzZV9jb2RlIDogc3RyaW5nO1xuICAgIGxleF9iYWNrdHJrX2NvZGUgOiBzdHJpbmc7XG4gICAgbGV4X2RlZmF1bHRfY29kZSA6IHN0cmluZztcbiAgICBsZXhfdHJhbnNfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY2hlY2tfY29kZSA6IHN0cmluZztcbiAgICBsZXhfY29kZTogc3RyaW5nO31cblxuZXh0ZXJuYWwgY19lbmdpbmUgOiBsZXhfdGFibGVzIC0+IGludCAtPiBsZXhidWYgLT4gaW50ID0gXCJjYW1sX2xleF9lbmdpbmVcIlxuZXh0ZXJuYWwgY19uZXdfZW5naW5lIDogbGV4X3RhYmxlcyAtPiBpbnQgLT4gbGV4YnVmIC0+IGludFxuICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX25ld19sZXhfZW5naW5lXCJcblxubGV0IGVuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfZW5naW5lIHRibCBzdGF0ZSBidWYgaW5cbiAgaWYgcmVzdWx0ID49IDAgJiYgYnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zIHRoZW4gYmVnaW5cbiAgICBidWYubGV4X3N0YXJ0X3AgPC0gYnVmLmxleF9jdXJyX3A7XG4gICAgYnVmLmxleF9jdXJyX3AgPC0ge2J1Zi5sZXhfY3Vycl9wXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGggcG9zX2NudW0gPSBidWYubGV4X2Fic19wb3MgKyBidWYubGV4X2N1cnJfcG9zfTtcbiAgZW5kO1xuICByZXN1bHRcblxuXG5sZXQgbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmID1cbiAgbGV0IHJlc3VsdCA9IGNfbmV3X2VuZ2luZSB0Ymwgc3RhdGUgYnVmIGluXG4gIGlmIHJlc3VsdCA+PSAwICYmIGJ1Zi5sZXhfY3Vycl9wICE9IGR1bW15X3BvcyB0aGVuIGJlZ2luXG4gICAgYnVmLmxleF9zdGFydF9wIDwtIGJ1Zi5sZXhfY3Vycl9wO1xuICAgIGJ1Zi5sZXhfY3Vycl9wIDwtIHtidWYubGV4X2N1cnJfcFxuICAgICAgICAgICAgICAgICAgICAgICB3aXRoIHBvc19jbnVtID0gYnVmLmxleF9hYnNfcG9zICsgYnVmLmxleF9jdXJyX3Bvc307XG4gIGVuZDtcbiAgcmVzdWx0XG5cblxubGV0IGxleF9yZWZpbGwgcmVhZF9mdW4gYXV4X2J1ZmZlciBsZXhidWYgPVxuICBsZXQgcmVhZCA9XG4gICAgcmVhZF9mdW4gYXV4X2J1ZmZlciAoQnl0ZXMubGVuZ3RoIGF1eF9idWZmZXIpIGluXG4gIGxldCBuID1cbiAgICBpZiByZWFkID4gMFxuICAgIHRoZW4gcmVhZFxuICAgIGVsc2UgKGxleGJ1Zi5sZXhfZW9mX3JlYWNoZWQgPC0gdHJ1ZTsgMCkgaW5cbiAgKCogQ3VycmVudCBzdGF0ZSBvZiB0aGUgYnVmZmVyOlxuICAgICAgICA8LS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0+XG4gICAgICAgIHwgIGp1bmsgfCAgICAgIHZhbGlkIGRhdGEgICAgIHwgICBqdW5rICAgIHxcbiAgICAgICAgXiAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgXlxuICAgICAgICAwICAgIHN0YXJ0X3BvcyAgICAgICAgICAgICBidWZmZXJfZW5kICAgIEJ5dGVzLmxlbmd0aCBidWZmZXJcbiAgKilcbiAgaWYgbGV4YnVmLmxleF9idWZmZXJfbGVuICsgbiA+IEJ5dGVzLmxlbmd0aCBsZXhidWYubGV4X2J1ZmZlciB0aGVuIGJlZ2luXG4gICAgKCogVGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgKilcbiAgICBpZiBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBsZXhidWYubGV4X3N0YXJ0X3BvcyArIG5cbiAgICAgICA8PSBCeXRlcy5sZW5ndGggbGV4YnVmLmxleF9idWZmZXJcbiAgICB0aGVuIGJlZ2luXG4gICAgICAoKiBCdXQgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGlmIHdlIHJlY2xhaW0gdGhlIGp1bmsgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgb2YgdGhlIGJ1ZmZlciAqKVxuICAgICAgQnl0ZXMuYmxpdCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X3N0YXJ0X3Bvc1xuICAgICAgICAgICAgICAgICAgbGV4YnVmLmxleF9idWZmZXIgMFxuICAgICAgICAgICAgICAgICAgKGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBXZSBtdXN0IGdyb3cgdGhlIGJ1ZmZlci4gIERvdWJsaW5nIGl0cyBzaXplIHdpbGwgcHJvdmlkZSBlbm91Z2hcbiAgICAgICAgIHNwYWNlIHNpbmNlIG4gPD0gU3RyaW5nLmxlbmd0aCBhdXhfYnVmZmVyIDw9IFN0cmluZy5sZW5ndGggYnVmZmVyLlxuICAgICAgICAgV2F0Y2ggb3V0IGZvciBzdHJpbmcgbGVuZ3RoIG92ZXJmbG93LCB0aG91Z2guICopXG4gICAgICBsZXQgbmV3bGVuID1cbiAgICAgICAgbWluICgyICogQnl0ZXMubGVuZ3RoIGxleGJ1Zi5sZXhfYnVmZmVyKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICAgIGlmIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiAtIGxleGJ1Zi5sZXhfc3RhcnRfcG9zICsgbiA+IG5ld2xlblxuICAgICAgdGhlbiBmYWlsd2l0aCBcIkxleGluZy5sZXhfcmVmaWxsOiBjYW5ub3QgZ3JvdyBidWZmZXJcIjtcbiAgICAgIGxldCBuZXdidWYgPSBCeXRlcy5jcmVhdGUgbmV3bGVuIGluXG4gICAgICAoKiBDb3B5IHRoZSB2YWxpZCBkYXRhIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyBidWZmZXIgKilcbiAgICAgIEJ5dGVzLmJsaXQgbGV4YnVmLmxleF9idWZmZXIgbGV4YnVmLmxleF9zdGFydF9wb3NcbiAgICAgICAgICAgICAgICAgIG5ld2J1ZiAwXG4gICAgICAgICAgICAgICAgICAobGV4YnVmLmxleF9idWZmZXJfbGVuIC0gbGV4YnVmLmxleF9zdGFydF9wb3MpO1xuICAgICAgbGV4YnVmLmxleF9idWZmZXIgPC0gbmV3YnVmXG4gICAgZW5kO1xuICAgICgqIFJlYWxsb2NhdGlvbiBvciBub3QsIHdlIGhhdmUgc2hpZnRlZCB0aGUgZGF0YSBsZWZ0IGJ5XG4gICAgICAgc3RhcnRfcG9zIGNoYXJhY3RlcnM7IHVwZGF0ZSB0aGUgcG9zaXRpb25zICopXG4gICAgbGV0IHMgPSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICAgIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBsZXhidWYubGV4X2Fic19wb3MgKyBzO1xuICAgIGxleGJ1Zi5sZXhfY3Vycl9wb3MgPC0gbGV4YnVmLmxleF9jdXJyX3BvcyAtIHM7XG4gICAgbGV4YnVmLmxleF9zdGFydF9wb3MgPC0gMDtcbiAgICBsZXhidWYubGV4X2xhc3RfcG9zIDwtIGxleGJ1Zi5sZXhfbGFzdF9wb3MgLSBzO1xuICAgIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiA8LSBsZXhidWYubGV4X2J1ZmZlcl9sZW4gLSBzIDtcbiAgICBsZXQgdCA9IGxleGJ1Zi5sZXhfbWVtIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LTEgZG9cbiAgICAgIGxldCB2ID0gdC4oaSkgaW5cbiAgICAgIGlmIHYgPj0gMCB0aGVuXG4gICAgICAgIHQuKGkpIDwtIHYtc1xuICAgIGRvbmVcbiAgZW5kO1xuICAoKiBUaGVyZSBpcyBub3cgZW5vdWdoIHNwYWNlIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciAqKVxuICBCeXRlcy5ibGl0IGF1eF9idWZmZXIgMCBsZXhidWYubGV4X2J1ZmZlciBsZXhidWYubGV4X2J1ZmZlcl9sZW4gbjtcbiAgbGV4YnVmLmxleF9idWZmZXJfbGVuIDwtIGxleGJ1Zi5sZXhfYnVmZmVyX2xlbiArIG5cblxubGV0IHplcm9fcG9zID0ge1xuICBwb3NfZm5hbWUgPSBcIlwiO1xuICBwb3NfbG51bSA9IDE7XG4gIHBvc19ib2wgPSAwO1xuICBwb3NfY251bSA9IDA7XG59XG5cbmxldCBmcm9tX2Z1bmN0aW9uID8od2l0aF9wb3NpdGlvbnMgPSB0cnVlKSBmID1cbiAgeyByZWZpbGxfYnVmZiA9IGxleF9yZWZpbGwgZiAoQnl0ZXMuY3JlYXRlIDUxMik7XG4gICAgbGV4X2J1ZmZlciA9IEJ5dGVzLmNyZWF0ZSAxMDI0O1xuICAgIGxleF9idWZmZXJfbGVuID0gMDtcbiAgICBsZXhfYWJzX3BvcyA9IDA7XG4gICAgbGV4X3N0YXJ0X3BvcyA9IDA7XG4gICAgbGV4X2N1cnJfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9wb3MgPSAwO1xuICAgIGxleF9sYXN0X2FjdGlvbiA9IDA7XG4gICAgbGV4X21lbSA9IFt8fF07XG4gICAgbGV4X2VvZl9yZWFjaGVkID0gZmFsc2U7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBmcm9tX2NoYW5uZWwgP3dpdGhfcG9zaXRpb25zIGljID1cbiAgZnJvbV9mdW5jdGlvbiA/d2l0aF9wb3NpdGlvbnMgKGZ1biBidWYgbiAtPiBpbnB1dCBpYyBidWYgMCBuKVxuXG5sZXQgZnJvbV9zdHJpbmcgPyh3aXRoX3Bvc2l0aW9ucyA9IHRydWUpIHMgPVxuICB7IHJlZmlsbF9idWZmID0gKGZ1biBsZXhidWYgLT4gbGV4YnVmLmxleF9lb2ZfcmVhY2hlZCA8LSB0cnVlKTtcbiAgICBsZXhfYnVmZmVyID0gQnl0ZXMub2Zfc3RyaW5nIHM7ICgqIGhhdmUgdG8gbWFrZSBhIGNvcHkgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggdW5zYWZlLXN0cmluZyBtb2RlICopXG4gICAgbGV4X2J1ZmZlcl9sZW4gPSBTdHJpbmcubGVuZ3RoIHM7XG4gICAgbGV4X2Fic19wb3MgPSAwO1xuICAgIGxleF9zdGFydF9wb3MgPSAwO1xuICAgIGxleF9jdXJyX3BvcyA9IDA7XG4gICAgbGV4X2xhc3RfcG9zID0gMDtcbiAgICBsZXhfbGFzdF9hY3Rpb24gPSAwO1xuICAgIGxleF9tZW0gPSBbfHxdO1xuICAgIGxleF9lb2ZfcmVhY2hlZCA9IHRydWU7XG4gICAgbGV4X3N0YXJ0X3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICAgIGxleF9jdXJyX3AgPSBpZiB3aXRoX3Bvc2l0aW9ucyB0aGVuIHplcm9fcG9zIGVsc2UgZHVtbXlfcG9zO1xuICB9XG5cbmxldCBzZXRfcG9zaXRpb24gbGV4YnVmIHBvc2l0aW9uID1cbiAgbGV4YnVmLmxleF9jdXJyX3AgIDwtIHtwb3NpdGlvbiB3aXRoIHBvc19mbmFtZSA9IGxleGJ1Zi5sZXhfY3Vycl9wLnBvc19mbmFtZX07XG4gIGxleGJ1Zi5sZXhfYWJzX3BvcyA8LSBwb3NpdGlvbi5wb3NfY251bVxuXG5sZXQgc2V0X2ZpbGVuYW1lIGxleGJ1ZiBmbmFtZSA9XG4gIGxleGJ1Zi5sZXhfY3Vycl9wIDwtIHtsZXhidWYubGV4X2N1cnJfcCB3aXRoIHBvc19mbmFtZSA9IGZuYW1lfVxuXG5sZXQgd2l0aF9wb3NpdGlvbnMgbGV4YnVmID0gbGV4YnVmLmxleF9jdXJyX3AgIT0gZHVtbXlfcG9zXG5cbmxldCBsZXhlbWUgbGV4YnVmID1cbiAgbGV0IGxlbiA9IGxleGJ1Zi5sZXhfY3Vycl9wb3MgLSBsZXhidWYubGV4X3N0YXJ0X3BvcyBpblxuICBCeXRlcy5zdWJfc3RyaW5nIGxleGJ1Zi5sZXhfYnVmZmVyIGxleGJ1Zi5sZXhfc3RhcnRfcG9zIGxlblxuXG5sZXQgc3ViX2xleGVtZSBsZXhidWYgaTEgaTIgPVxuICBsZXQgbGVuID0gaTItaTEgaW5cbiAgQnl0ZXMuc3ViX3N0cmluZyBsZXhidWYubGV4X2J1ZmZlciBpMSBsZW5cblxubGV0IHN1Yl9sZXhlbWVfb3B0IGxleGJ1ZiBpMSBpMiA9XG4gIGlmIGkxID49IDAgdGhlbiBiZWdpblxuICAgIGxldCBsZW4gPSBpMi1pMSBpblxuICAgIFNvbWUgKEJ5dGVzLnN1Yl9zdHJpbmcgbGV4YnVmLmxleF9idWZmZXIgaTEgbGVuKVxuICBlbmQgZWxzZSBiZWdpblxuICAgIE5vbmVcbiAgZW5kXG5cbmxldCBzdWJfbGV4ZW1lX2NoYXIgbGV4YnVmIGkgPSBCeXRlcy5nZXQgbGV4YnVmLmxleF9idWZmZXIgaVxuXG5sZXQgc3ViX2xleGVtZV9jaGFyX29wdCBsZXhidWYgaSA9XG4gIGlmIGkgPj0gMCB0aGVuXG4gICAgU29tZSAoQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIGkpXG4gIGVsc2VcbiAgICBOb25lXG5cblxubGV0IGxleGVtZV9jaGFyIGxleGJ1ZiBpID1cbiAgQnl0ZXMuZ2V0IGxleGJ1Zi5sZXhfYnVmZmVyIChsZXhidWYubGV4X3N0YXJ0X3BvcyArIGkpXG5cbmxldCBsZXhlbWVfc3RhcnQgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wLnBvc19jbnVtXG5sZXQgbGV4ZW1lX2VuZCBsZXhidWYgPSBsZXhidWYubGV4X2N1cnJfcC5wb3NfY251bVxuXG5sZXQgbGV4ZW1lX3N0YXJ0X3AgbGV4YnVmID0gbGV4YnVmLmxleF9zdGFydF9wXG5sZXQgbGV4ZW1lX2VuZF9wIGxleGJ1ZiA9IGxleGJ1Zi5sZXhfY3Vycl9wXG5cbmxldCBuZXdfbGluZSBsZXhidWYgPVxuICBsZXQgbGNwID0gbGV4YnVmLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGV4YnVmLmxleF9jdXJyX3AgPC1cbiAgICAgIHsgbGNwIHdpdGhcbiAgICAgICAgcG9zX2xudW0gPSBsY3AucG9zX2xudW0gKyAxO1xuICAgICAgICBwb3NfYm9sID0gbGNwLnBvc19jbnVtO1xuICAgICAgfVxuXG5cblxuKCogRGlzY2FyZCBkYXRhIGxlZnQgaW4gbGV4ZXIgYnVmZmVyLiAqKVxuXG5sZXQgZmx1c2hfaW5wdXQgbGIgPVxuICBsYi5sZXhfY3Vycl9wb3MgPC0gMDtcbiAgbGIubGV4X2Fic19wb3MgPC0gMDtcbiAgbGV0IGxjcCA9IGxiLmxleF9jdXJyX3AgaW5cbiAgaWYgbGNwICE9IGR1bW15X3BvcyB0aGVuXG4gICAgbGIubGV4X2N1cnJfcCA8LSB7emVyb19wb3Mgd2l0aCBwb3NfZm5hbWUgPSBsY3AucG9zX2ZuYW1lfTtcbiAgbGIubGV4X2J1ZmZlcl9sZW4gPC0gMDtcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICBCZW5vaXQgVmF1Z29uLCBFTlNUQSAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3NcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgKCogVG9vbHMgdG8gbWFuaXB1bGF0ZSBzY2FubmluZyBzZXQgb2YgY2hhcnMgKHNlZSAlWy4uLl0pICopXG5cbnR5cGUgbXV0YWJsZV9jaGFyX3NldCA9IGJ5dGVzXG5cbigqIENyZWF0ZSBhIGZyZXNoLCBlbXB0eSwgbXV0YWJsZSBjaGFyIHNldC4gKilcbmxldCBjcmVhdGVfY2hhcl9zZXQgKCkgPSBCeXRlcy5tYWtlIDMyICdcXDAwMCdcblxuKCogQWRkIGEgY2hhciBpbiBhIG11dGFibGUgY2hhciBzZXQuICopXG5sZXQgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IGMgPVxuICBsZXQgaW5kID0gaW50X29mX2NoYXIgYyBpblxuICBsZXQgc3RyX2luZCA9IGluZCBsc3IgMyBhbmQgbWFzayA9IDEgbHNsIChpbmQgbGFuZCAwYjExMSkgaW5cbiAgQnl0ZXMuc2V0IGNoYXJfc2V0IHN0cl9pbmRcbiAgICAoY2hhcl9vZl9pbnQgKGludF9vZl9jaGFyIChCeXRlcy5nZXQgY2hhcl9zZXQgc3RyX2luZCkgbG9yIG1hc2spKVxuXG5sZXQgZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0ID1cbiAgQnl0ZXMudG9fc3RyaW5nIGNoYXJfc2V0XG5cbigqIENvbXB1dGUgdGhlIGNvbXBsZW1lbnQgb2YgYSBjaGFyIHNldC4gKilcbmxldCByZXZfY2hhcl9zZXQgY2hhcl9zZXQgPVxuICBsZXQgY2hhcl9zZXQnID0gY3JlYXRlX2NoYXJfc2V0ICgpIGluXG4gIGZvciBpID0gMCB0byAzMSBkb1xuICAgIEJ5dGVzLnNldCBjaGFyX3NldCcgaVxuICAgICAgKGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBpKSBseG9yIDB4RkYpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjaGFyX3NldCdcblxuKCogUmV0dXJuIHRydWUgaWYgYSBgYycgaXMgaW4gYGNoYXJfc2V0Jy4gKilcbmxldCBpc19pbl9jaGFyX3NldCBjaGFyX3NldCBjID1cbiAgbGV0IGluZCA9IGludF9vZl9jaGFyIGMgaW5cbiAgbGV0IHN0cl9pbmQgPSBpbmQgbHNyIDMgYW5kIG1hc2sgPSAxIGxzbCAoaW5kIGxhbmQgMGIxMTEpIGluXG4gIChpbnRfb2ZfY2hhciAoU3RyaW5nLmdldCBjaGFyX3NldCBzdHJfaW5kKSBsYW5kIG1hc2spIDw+IDBcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICgqIElnbm9yZWQgcGFyYW0gY29udmVyc2lvbiAqKVxuXG4oKiBHQURUIHVzZWQgdG8gYWJzdHJhY3QgYW4gZXhpc3RlbnRpYWwgdHlwZSBwYXJhbWV0ZXIuICopXG4oKiBTZWUgcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0LiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYiA9IFBhcmFtX2Zvcm1hdF9FQkIgOlxuICAgICgneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgcGFyYW1fZm9ybWF0X2ViYlxuXG4oKiBDb21wdXRlIGEgcGFkZGluZyBhc3NvY2lhdGVkIHRvIGEgcGFkX29wdGlvbiAoc2VlIFwiJV80MmRcIikuICopXG5sZXQgcGFkX29mX3BhZF9vcHQgcGFkX29wdCA9IG1hdGNoIHBhZF9vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcGFkZGluZ1xuICB8IFNvbWUgd2lkdGggLT4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcblxuKCogQ29tcHV0ZSBhIHByZWNpc2lvbiBhc3NvY2lhdGVkIHRvIGEgcHJlY19vcHRpb24gKHNlZSBcIiVfLjQyZlwiKS4gKilcbmxldCBwcmVjX29mX3ByZWNfb3B0IHByZWNfb3B0ID0gbWF0Y2ggcHJlY19vcHQgd2l0aFxuICB8IE5vbmUgLT4gTm9fcHJlY2lzaW9uXG4gIHwgU29tZSBuZGVjIC0+IExpdF9wcmVjaXNpb24gbmRlY1xuXG4oKiBUdXJuIGFuIGlnbm9yZWQgcGFyYW0gaW50byBpdHMgZXF1aXZhbGVudCBub3QtaWdub3JlZCBmb3JtYXQgbm9kZS4gKilcbigqIFVzZWQgZm9yIGZvcm1hdCBwcmV0dHktcHJpbnRpbmcgYW5kIFNjYW5mLiAqKVxubGV0IHBhcmFtX2Zvcm1hdF9vZl9pZ25vcmVkX2Zvcm1hdCA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPiAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+XG4gICAgICAoYSwgYiwgYywgZCwgZSwgZikgcGFyYW1fZm9ybWF0X2ViYiA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENoYXIgZm10KVxuICB8IElnbm9yZWRfY2FtbF9jaGFyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoQ2FtbF9jaGFyIGZtdClcbiAgfCBJZ25vcmVkX3N0cmluZyBwYWRfb3B0IC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgcGFkX29wdCAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKENhbWxfc3RyaW5nIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChJbnQgKGljb252LCBwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBOb19wcmVjaXNpb24sIGZtdCkpXG4gIHwgSWdub3JlZF9pbnQzMiAoaWNvbnYsIHBhZF9vcHQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQlxuICAgICAgKEludDMyIChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfbmF0aXZlaW50IChpY29udiwgcGFkX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoTmF0aXZlaW50IChpY29udiwgcGFkX29mX3BhZF9vcHQgcGFkX29wdCwgTm9fcHJlY2lzaW9uLCBmbXQpKVxuICB8IElnbm9yZWRfaW50NjQgKGljb252LCBwYWRfb3B0KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChJbnQ2NCAoaWNvbnYsIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIE5vX3ByZWNpc2lvbiwgZm10KSlcbiAgfCBJZ25vcmVkX2Zsb2F0IChwYWRfb3B0LCBwcmVjX29wdCkgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCXG4gICAgICAoRmxvYXQgKChGbG9hdF9mbGFnXywgRmxvYXRfZiksXG4gICAgICAgICAgICAgIHBhZF9vZl9wYWRfb3B0IHBhZF9vcHQsIHByZWNfb2ZfcHJlY19vcHQgcHJlY19vcHQsIGZtdCkpXG4gIHwgSWdub3JlZF9ib29sIHBhZF9vcHQgLT5cbiAgICBQYXJhbV9mb3JtYXRfRUJCIChCb29sIChwYWRfb2ZfcGFkX29wdCBwYWRfb3B0LCBmbXQpKVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHkpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIGZtdCkpXG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5KSAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkJcbiAgICAgIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCBmbXQpKVxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoUmVhZGVyIGZtdClcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQpIC0+XG4gICAgUGFyYW1fZm9ybWF0X0VCQiAoU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgZm10KSlcbiAgfCBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdCkpXG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAtPlxuICAgIFBhcmFtX2Zvcm1hdF9FQkIgKFNjYW5fbmV4dF9jaGFyIGZtdClcblxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZXMgKilcblxudHlwZSAoJ2IsICdjKSBhY2NfZm9ybWF0dGluZ19nZW4gPVxuICB8IEFjY19vcGVuX3RhZyBvZiAoJ2IsICdjKSBhY2NcbiAgfCBBY2Nfb3Blbl9ib3ggb2YgKCdiLCAnYykgYWNjXG5cbigqIFJldmVyc2VkIGxpc3Qgb2YgcHJpbnRpbmcgYXRvbXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgcHJpbnRmIGFyZ3VtZW50cy4gKilcbmFuZCAoJ2IsICdjKSBhY2MgPVxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCBvZiAoJ2IsICdjKSBhY2MgKiBmb3JtYXR0aW5nX2xpdFxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIG9mICgnYiwgJ2MpIGFjYyAqICgnYiwgJ2MpIGFjY19mb3JtYXR0aW5nX2dlblxuICAgICAgKCogU3BlY2lhbCBmbXR0aW5nIChib3gpICopXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZyAgICAgKCogTGl0ZXJhbCBzdHJpbmcgKilcbiAgfCBBY2NfY2hhcl9saXRlcmFsICAgb2YgKCdiLCAnYykgYWNjICogY2hhciAgICAgICAoKiBMaXRlcmFsIGNoYXIgKilcbiAgfCBBY2NfZGF0YV9zdHJpbmcgICAgb2YgKCdiLCAnYykgYWNjICogc3RyaW5nICAgICAoKiBHZW5lcmF0ZWQgc3RyaW5nICopXG4gIHwgQWNjX2RhdGFfY2hhciAgICAgIG9mICgnYiwgJ2MpIGFjYyAqIGNoYXIgICAgICAgKCogR2VuZXJhdGVkIGNoYXIgKilcbiAgfCBBY2NfZGVsYXkgICAgICAgICAgb2YgKCdiLCAnYykgYWNjICogKCdiIC0+ICdjKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogRGVsYXllZCBwcmludGluZyAoJWEsICV0KSAqKVxuICB8IEFjY19mbHVzaCAgICAgICAgICBvZiAoJ2IsICdjKSBhY2MgICAgICAgICAgICAgICgqIEZsdXNoICopXG4gIHwgQWNjX2ludmFsaWRfYXJnICAgIG9mICgnYiwgJ2MpIGFjYyAqIHN0cmluZ1xuICAgICAgKCogUmFpc2UgSW52YWxpZF9hcmd1bWVudCBtc2cgKilcbiAgfCBFbmRfb2ZfYWNjXG5cbigqIExpc3Qgb2YgaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuICopXG4oKiBVc2VkIHRvIGFjY3VtdWxhdGUgc2NhbmYgY2FsbGJhY2sgYXJndW1lbnRzLiAqKVxudHlwZSAoJ2EsICdiKSBoZXRlcl9saXN0ID1cbiAgfCBDb25zIDogJ2MgKiAoJ2EsICdiKSBoZXRlcl9saXN0IC0+ICgnYyAtPiAnYSwgJ2IpIGhldGVyX2xpc3RcbiAgfCBOaWwgOiAoJ2IsICdiKSBoZXRlcl9saXN0XG5cbigqIEV4aXN0ZW50aWFsIEJsYWNrIEJveGVzLiAqKVxuKCogVXNlZCB0byBhYnN0cmFjdCBzb21lIGV4aXN0ZW50aWFsIHR5cGUgcGFyYW1ldGVycy4gKilcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZyBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkZGluZyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZGRpbmdfZm10dHlfZWJiID0gUGFkZGluZ19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRkaW5nX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nLCBhIHByZWNpc2lvbiBhbmQgYW4gZm10dHkuICopXG4oKiBTZWUgdGhlIHR5cGVfcGFkcHJlYyBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIHBhZHByZWNfZm10dHlfZWJiID0gUGFkcHJlY19mbXR0eV9FQkIgOlxuICAgICAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCAneikgcHJlY2lzaW9uICogKCd6LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBwYWRwcmVjX2ZtdHR5X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYSBwYWRkaW5nIGFuZCBhbiBmbXQuICopXG4oKiBTZWUgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHBhZGRpbmdfZm10X2ViYiA9IFBhZGRpbmdfZm10X0VCQiA6XG4gICAgIChfLCAneCAtPiAnYSkgcGFkZGluZyAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcGFkZGluZ19mbXRfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhIHByZWNpc2lvbiBhbmQgYW4gZm10LiAqKVxuKCogU2VlIG1ha2VfcHJlY2lzaW9uX2ZtdF9lYmIgYW5kIHBhcnNlX2Zvcm1hdCBmdW5jdGlvbnMuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZSwgJ2YpIHByZWNpc2lvbl9mbXRfZWJiID0gUHJlY2lzaW9uX2ZtdF9FQkIgOlxuICAgICAoXywgJ3ggLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCd4LCAnYiwgJ2MsICdlLCAnZikgcHJlY2lzaW9uX2ZtdF9lYmJcblxuKCogR0FEVCB0eXBlIGFzc29jaWF0aW5nIGEgcGFkZGluZywgYSBwcmVjaXNpb24gYW5kIGFuIGZtdC4gKilcbigqIFNlZSBtYWtlX3BhZHByZWNfZm10X2ViYiBhbmQgcGFyc2VfZm9ybWF0IGZ1bmN0aW9ucy4gKilcbnR5cGUgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiID0gUGFkcHJlY19mbXRfRUJCIDpcbiAgICAgKCd4LCAneSkgcGFkZGluZyAqICgneSwgJ3AgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgKCdwLCAnYiwgJ2MsICdlLCAnZikgcGFkcHJlY19mbXRfZWJiXG5cbigqIEFic3RyYWN0IHRoZSAnYSBhbmQgJ2QgcGFyYW1ldGVycyBvZiBhbiBmbXQuICopXG4oKiBPdXRwdXQgdHlwZSBvZiB0aGUgZm9ybWF0IHBhcnNpbmcgZnVuY3Rpb24uICopXG50eXBlICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYiA9IEZtdF9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICgnYiwgJ2MsICdlLCAnZikgZm10X2ViYlxuXG4oKiBHQURUIHR5cGUgYXNzb2NpYXRpbmcgYW4gZm10dHkgYW5kIGFuIGZtdC4gKilcbigqIFNlZSB0aGUgdHlwZV9mb3JtYXRfZ2VuIGZ1bmN0aW9uLiAqKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10X2ZtdHR5X2ViYiA9IEZtdF9mbXR0eV9FQkIgOlxuICAgICAoJ2EsICdiLCAnYywgJ2QsICd5LCAneCkgZm10ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRfZm10dHlfZWJiXG5cbigqIEdBRFQgdHlwZSBhc3NvY2lhdGluZyBhbiBmbXR0eSBhbmQgYW4gZm10LiAqKVxuKCogU2VlIHRoZSB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiBmdW5jdGlvbi4gKilcbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmIgPSBGbXR0eV9mbXRfRUJCIDpcbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGZtdHR5ICpcbiAgICAgKCd4LCAnYiwgJ2MsICd5LCAnZSwgJ2YpIGZtdF9mbXR0eV9lYmIgLT5cbiAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5X2ZtdF9lYmJcblxuKCogQWJzdHJhY3QgYWxsIGZtdHR5IHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBmb3JtYXQgdHlwZXMuICopXG50eXBlIGZtdHR5X2ViYiA9IEZtdHR5X0VCQiA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSAtPiBmbXR0eV9lYmJcblxuKCogQWJzdHJhY3QgYWxsIHBhZGRpbmcgdHlwZSBwYXJhbWV0ZXJzLiAqKVxuKCogVXNlZCB0byBjb21wYXJlIHBhZGRpbmdzLiAqKVxudHlwZSBwYWRkaW5nX2ViYiA9IFBhZGRpbmdfRUJCIDogKCdhLCAnYikgcGFkZGluZyAtPiBwYWRkaW5nX2ViYlxuXG4oKiBBYnN0cmFjdCBhbGwgcHJlY2lzaW9uIHR5cGUgcGFyYW1ldGVycy4gKilcbigqIFVzZWQgdG8gY29tcGFyZSBwcmVjaXNpb25zLiAqKVxudHlwZSBwcmVjaXNpb25fZWJiID0gUHJlY2lzaW9uX0VCQiA6ICgnYSwgJ2IpIHByZWNpc2lvbiAtPiBwcmVjaXNpb25fZWJiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29uc3RhbnRzICopXG5cbigqIERlZmF1bHQgcHJlY2lzaW9uIGZvciBmbG9hdCBwcmludGluZy4gKilcbmxldCBkZWZhdWx0X2Zsb2F0X3ByZWNpc2lvbiBmY29udiA9XG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0cgfCBGbG9hdF9oIHwgRmxvYXRfSFxuICB8IEZsb2F0X0NGIC0+IC02XG4gICgqIEZvciAlaCAlSCBhbmQgJSNGIGZvcm1hdHMsIGEgbmVnYXRpdmUgcHJlY2lzaW9uIG1lYW5zIFwiYXMgbWFueSBkaWdpdHMgYXNcbiAgICAgbmVjZXNzYXJ5XCIuICBGb3IgdGhlIG90aGVyIEZQIGZvcm1hdHMsIHdlIHRha2UgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgIG9mIHRoZSBwcmVjaXNpb24sIGhlbmNlIDYgZGlnaXRzIGJ5IGRlZmF1bHQuICopXG4gIHwgRmxvYXRfRiAtPiAxMlxuICAoKiBEZWZhdWx0IHByZWNpc2lvbiBmb3IgT0NhbWwgZmxvYXQgcHJpbnRpbmcgKCVGKS4gKilcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBFeHRlcm5hbHMgKilcblxuZXh0ZXJuYWwgZm9ybWF0X2Zsb2F0OiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50OiBzdHJpbmcgLT4gaW50IC0+IHN0cmluZ1xuICA9IFwiY2FtbF9mb3JtYXRfaW50XCJcbmV4dGVybmFsIGZvcm1hdF9pbnQzMjogc3RyaW5nIC0+IGludDMyIC0+IHN0cmluZ1xuICA9IFwiY2FtbF9pbnQzMl9mb3JtYXRcIlxuZXh0ZXJuYWwgZm9ybWF0X25hdGl2ZWludDogc3RyaW5nIC0+IG5hdGl2ZWludCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfbmF0aXZlaW50X2Zvcm1hdFwiXG5leHRlcm5hbCBmb3JtYXRfaW50NjQ6IHN0cmluZyAtPiBpbnQ2NCAtPiBzdHJpbmdcbiAgPSBcImNhbWxfaW50NjRfZm9ybWF0XCJcbmV4dGVybmFsIGhleHN0cmluZ19vZl9mbG9hdDogZmxvYXQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nXG4gID0gXCJjYW1sX2hleHN0cmluZ19vZl9mbG9hdFwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAoKiBUb29scyB0byBwcmV0dHktcHJpbnQgZm9ybWF0cyAqKVxuXG4oKiBUeXBlIG9mIGV4dGVuc2libGUgY2hhcmFjdGVyIGJ1ZmZlcnMuICopXG50eXBlIGJ1ZmZlciA9IHtcbiAgbXV0YWJsZSBpbmQgOiBpbnQ7XG4gIG11dGFibGUgYnl0ZXMgOiBieXRlcztcbn1cblxuKCogQ3JlYXRlIGEgZnJlc2ggYnVmZmVyLiAqKVxubGV0IGJ1ZmZlcl9jcmVhdGUgaW5pdF9zaXplID0geyBpbmQgPSAwOyBieXRlcyA9IEJ5dGVzLmNyZWF0ZSBpbml0X3NpemUgfVxuXG4oKiBDaGVjayBzaXplIG9mIHRoZSBidWZmZXIgYW5kIGdyb3cgaXQgaWYgbmVlZGVkLiAqKVxubGV0IGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBvdmVyaGVhZCA9XG4gIGxldCBsZW4gPSBCeXRlcy5sZW5ndGggYnVmLmJ5dGVzIGluXG4gIGxldCBtaW5fbGVuID0gYnVmLmluZCArIG92ZXJoZWFkIGluXG4gIGlmIG1pbl9sZW4gPiBsZW4gdGhlbiAoXG4gICAgbGV0IG5ld19sZW4gPSBtYXggKGxlbiAqIDIpIG1pbl9sZW4gaW5cbiAgICBsZXQgbmV3X3N0ciA9IEJ5dGVzLmNyZWF0ZSBuZXdfbGVuIGluXG4gICAgQnl0ZXMuYmxpdCBidWYuYnl0ZXMgMCBuZXdfc3RyIDAgbGVuO1xuICAgIGJ1Zi5ieXRlcyA8LSBuZXdfc3RyO1xuICApXG5cbigqIEFkZCB0aGUgY2hhcmFjdGVyIGBjJyB0byB0aGUgYnVmZmVyIGBidWYnLiAqKVxubGV0IGJ1ZmZlcl9hZGRfY2hhciBidWYgYyA9XG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiAxO1xuICBCeXRlcy5zZXQgYnVmLmJ5dGVzIGJ1Zi5pbmQgYztcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgMVxuXG4oKiBBZGQgdGhlIHN0cmluZyBgcycgdG8gdGhlIGJ1ZmZlciBgYnVmJy4gKilcbmxldCBidWZmZXJfYWRkX3N0cmluZyBidWYgcyA9XG4gIGxldCBzdHJfbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGJ1ZmZlcl9jaGVja19zaXplIGJ1ZiBzdHJfbGVuO1xuICBTdHJpbmcuYmxpdCBzIDAgYnVmLmJ5dGVzIGJ1Zi5pbmQgc3RyX2xlbjtcbiAgYnVmLmluZCA8LSBidWYuaW5kICsgc3RyX2xlblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgdGhlIGJ1ZmZlci4gKilcbmxldCBidWZmZXJfY29udGVudHMgYnVmID1cbiAgQnl0ZXMuc3ViX3N0cmluZyBidWYuYnl0ZXMgMCBidWYuaW5kXG5cbigqKiopXG5cbigqIENvbnZlcnQgYW4gaW50ZWdlciBjb252ZXJzaW9uIHRvIGNoYXIuICopXG5sZXQgY2hhcl9vZl9pY29udiBpY29udiA9IG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfZCB8IEludF9wZCB8IEludF9zZCB8IEludF9DZCAtPiAnZCcgfCBJbnRfaSB8IEludF9waSB8IEludF9zaVxuICB8IEludF9DaSAtPiAnaScgfCBJbnRfeCB8IEludF9DeCAtPiAneCcgfCBJbnRfWCB8IEludF9DWCAtPiAnWCcgfCBJbnRfb1xuICB8IEludF9DbyAtPiAnbycgfCBJbnRfdSB8IEludF9DdSAtPiAndSdcblxuKCogQ29udmVydCBhIGZsb2F0IGNvbnZlcnNpb24gdG8gY2hhci4gKilcbigqIGBjRicgd2lsbCBiZSAnRicgZm9yIGRpc3BsYXlpbmcgZm9ybWF0IGFuZCAnZycgdG8gY2FsbCBsaWJjIHByaW50ZiAqKVxubGV0IGNoYXJfb2ZfZmNvbnYgPyhjRj0nRicpIGZjb252ID0gbWF0Y2ggc25kIGZjb252IHdpdGhcbiAgfCBGbG9hdF9mIC0+ICdmJyB8IEZsb2F0X2UgLT4gJ2UnXG4gIHwgRmxvYXRfRSAtPiAnRScgfCBGbG9hdF9nIC0+ICdnJ1xuICB8IEZsb2F0X0cgLT4gJ0cnIHwgRmxvYXRfRiAtPiBjRlxuICB8IEZsb2F0X2ggLT4gJ2gnIHwgRmxvYXRfSCAtPiAnSCdcbiAgfCBGbG9hdF9DRiAtPiAnRidcblxuXG4oKiBDb252ZXJ0IGEgc2Nhbm5pbmcgY291bnRlciB0byBjaGFyLiAqKVxubGV0IGNoYXJfb2ZfY291bnRlciBjb3VudGVyID0gbWF0Y2ggY291bnRlciB3aXRoXG4gIHwgTGluZV9jb3VudGVyICAtPiAnbCdcbiAgfCBDaGFyX2NvdW50ZXIgIC0+ICduJ1xuICB8IFRva2VuX2NvdW50ZXIgLT4gJ04nXG5cbigqKiopXG5cbigqIFByaW50IGEgY2hhcl9zZXQgaW4gYSBidWZmZXIgd2l0aCB0aGUgT0NhbWwgZm9ybWF0IGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0ID1cbiAgbGV0IHJlYyBwcmludF9zdGFydCBzZXQgPVxuICAgIGxldCBpc19hbG9uZSBjID1cbiAgICAgIGxldCBiZWZvcmUsIGFmdGVyID0gQ2hhci4oY2hyIChjb2RlIGMgLSAxKSwgY2hyIChjb2RlIGMgKyAxKSkgaW5cbiAgICAgIGlzX2luX2NoYXJfc2V0IHNldCBjXG4gICAgICAmJiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCBiZWZvcmUgJiYgaXNfaW5fY2hhcl9zZXQgc2V0IGFmdGVyKSBpblxuICAgIGlmIGlzX2Fsb25lICddJyB0aGVuIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nO1xuICAgIHByaW50X291dCBzZXQgMTtcbiAgICBpZiBpc19hbG9uZSAnLScgdGhlbiBidWZmZXJfYWRkX2NoYXIgYnVmICctJztcbiAgYW5kIHByaW50X291dCBzZXQgaSA9XG4gICAgaWYgaSA8IDI1NiB0aGVuXG4gICAgICBpZiBpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IGkpIHRoZW4gcHJpbnRfZmlyc3Qgc2V0IGlcbiAgICAgIGVsc2UgcHJpbnRfb3V0IHNldCAoaSArIDEpXG4gIGFuZCBwcmludF9maXJzdCBzZXQgaSA9XG4gICAgbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnXFwyNTUnIC0+IHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICB8ICddJyB8ICctJyAtPiBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgfCBfIC0+IHByaW50X3NlY29uZCBzZXQgKGkgKyAxKTtcbiAgYW5kIHByaW50X3NlY29uZCBzZXQgaSA9XG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBpKSB0aGVuXG4gICAgICBtYXRjaCBjaGFyX29mX2ludCBpIHdpdGhcbiAgICAgIHwgJ1xcMjU1JyAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAyNTQ7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIDI1NTtcbiAgICAgIHwgJ10nIHwgJy0nIHdoZW4gbm90IChpc19pbl9jaGFyX3NldCBzZXQgKGNoYXJfb2ZfaW50IChpICsgMSkpKSAtPlxuICAgICAgICBwcmludF9jaGFyIGJ1ZiAoaSAtIDEpO1xuICAgICAgICBwcmludF9vdXQgc2V0IChpICsgMSk7XG4gICAgICB8IF8gd2hlbiBub3QgKGlzX2luX2NoYXJfc2V0IHNldCAoY2hhcl9vZl9pbnQgKGkgKyAxKSkpIC0+XG4gICAgICAgIHByaW50X2NoYXIgYnVmIChpIC0gMSk7XG4gICAgICAgIHByaW50X2NoYXIgYnVmIGk7XG4gICAgICAgIHByaW50X291dCBzZXQgKGkgKyAyKTtcbiAgICAgIHwgXyAtPlxuICAgICAgICBwcmludF9pbiBzZXQgKGkgLSAxKSAoaSArIDIpO1xuICAgIGVsc2UgKFxuICAgICAgcHJpbnRfY2hhciBidWYgKGkgLSAxKTtcbiAgICAgIHByaW50X291dCBzZXQgKGkgKyAxKTtcbiAgICApXG4gIGFuZCBwcmludF9pbiBzZXQgaSBqID1cbiAgICBpZiBqID0gMjU2IHx8IG5vdCAoaXNfaW5fY2hhcl9zZXQgc2V0IChjaGFyX29mX2ludCBqKSkgdGhlbiAoXG4gICAgICBwcmludF9jaGFyIGJ1ZiBpO1xuICAgICAgcHJpbnRfY2hhciBidWYgKGludF9vZl9jaGFyICctJyk7XG4gICAgICBwcmludF9jaGFyIGJ1ZiAoaiAtIDEpO1xuICAgICAgaWYgaiA8IDI1NiB0aGVuIHByaW50X291dCBzZXQgKGogKyAxKTtcbiAgICApIGVsc2VcbiAgICAgIHByaW50X2luIHNldCBpIChqICsgMSk7XG4gIGFuZCBwcmludF9jaGFyIGJ1ZiBpID0gbWF0Y2ggY2hhcl9vZl9pbnQgaSB3aXRoXG4gICAgfCAnJScgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICAgIHwgJ0AnIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICdAJztcbiAgICB8IGMgICAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGluXG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ1snO1xuICBwcmludF9zdGFydCAoXG4gICAgaWYgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgJ1xcMDAwJ1xuICAgIHRoZW4gKCBidWZmZXJfYWRkX2NoYXIgYnVmICdeJzsgcmV2X2NoYXJfc2V0IGNoYXJfc2V0IClcbiAgICBlbHNlIGNoYXJfc2V0XG4gICk7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJ10nXG5cbigqKiopXG5cbigqIFByaW50IGEgcGFkdHkgaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wYWR0eSBidWYgcGFkdHkgPSBtYXRjaCBwYWR0eSB3aXRoXG4gIHwgTGVmdCAgLT4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLSdcbiAgfCBSaWdodCAtPiAoKVxuICB8IFplcm9zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJzAnXG5cbigqIFByaW50IHRoZSAnXycgb2YgYW4gaWdub3JlZCBmbGFnIGlmIG5lZWRlZC4gKilcbmxldCBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZyA9XG4gIGlmIGlnbl9mbGFnIHRoZW4gYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnXydcblxuKCoqKilcblxubGV0IGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0ID0gbWF0Y2ggcGFkX29wdCB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgd2lkdGggLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIHdpZHRoKVxuXG4oKioqKVxuXG4oKiBQcmludCBwYWRkaW5nIGluIGEgYnVmZmVyIHdpdGggdGhlIGZvcm1hdC1saWtlIHN5bnRheC4gKilcbmxldCBicHJpbnRfcGFkZGluZyA6IHR5cGUgYSBiIC4gYnVmZmVyIC0+IChhLCBiKSBwYWRkaW5nIC0+IHVuaXQgPVxuZnVuIGJ1ZiBwYWQgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgfCBOb19wYWRkaW5nIC0+ICgpXG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCBuKSAtPlxuICAgIGJwcmludF9wYWR0eSBidWYgcGFkdHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wYWRkaW5nIHBhZHR5IC0+XG4gICAgYnByaW50X3BhZHR5IGJ1ZiBwYWR0eTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcqJ1xuXG4oKiBQcmludCBwcmVjaXNpb24gaW4gYSBidWZmZXIgd2l0aCB0aGUgZm9ybWF0LWxpa2Ugc3ludGF4LiAqKVxubGV0IGJwcmludF9wcmVjaXNpb24gOiB0eXBlIGEgYiAuIGJ1ZmZlciAtPiAoYSwgYikgcHJlY2lzaW9uIC0+IHVuaXQgPVxuICBmdW4gYnVmIHByZWMgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uIC0+ICgpXG4gIHwgTGl0X3ByZWNpc2lvbiBuIC0+XG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnLic7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIChJbnQudG9fc3RyaW5nIG4pO1xuICB8IEFyZ19wcmVjaXNpb24gLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIuKlwiXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBvciAnIycgYXNzb2NpYXRlZCB0byBhbiBpbnQgY29udmVyc2lvbi4gKilcbmxldCBicHJpbnRfaWNvbnZfZmxhZyBidWYgaWNvbnYgPSBtYXRjaCBpY29udiB3aXRoXG4gIHwgSW50X3BkIHwgSW50X3BpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgSW50X3NkIHwgSW50X3NpIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgSW50X0N4IHwgSW50X0NYIHwgSW50X0NvIHwgSW50X0NkIHwgSW50X0NpIHwgSW50X0N1IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICcjJ1xuICB8IEludF9kIHwgSW50X2kgfCBJbnRfeCB8IEludF9YIHwgSW50X28gfCBJbnRfdSAtPiAoKVxuXG4oKiBQcmludCBhbiBjb21wbGV0ZSBpbnQgZm9ybWF0IGluIGEgYnVmZmVyIChleDogXCIlMy4qZFwiKS4gKilcbmxldCBicHJpbnRfaW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgPVxuICBidWZmZXJfYWRkX2NoYXIgYnVmICclJztcbiAgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gIGJwcmludF9pY29udl9mbGFnIGJ1ZiBpY29udjtcbiAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDtcbiAgYnByaW50X3ByZWNpc2lvbiBidWYgcHJlYztcbiAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAoY2hhcl9vZl9pY29udiBpY29udilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2ljb252X2ZsYWcgYnVmIGljb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIGM7XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpXG5cbigqKiopXG5cbigqIFByaW50IHRoZSBvcHRpb25hbCAnKycsICcgJyBhbmQvb3IgJyMnIGFzc29jaWF0ZWQgdG8gYSBmbG9hdCBjb252ZXJzaW9uLiAqKVxubGV0IGJwcmludF9mY29udl9mbGFnIGJ1ZiBmY29udiA9XG4gIGJlZ2luIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gIHwgRmxvYXRfZmxhZ19wIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJysnXG4gIHwgRmxvYXRfZmxhZ19zIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyAnXG4gIHwgRmxvYXRfZmxhZ18gLT4gKCkgZW5kO1xuICBtYXRjaCBzbmQgZmNvbnYgd2l0aFxuICB8IEZsb2F0X0NGIC0+IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyMnXG4gIHwgRmxvYXRfZiB8IEZsb2F0X2UgfCBGbG9hdF9FIHwgRmxvYXRfZyB8IEZsb2F0X0dcbiAgfCBGbG9hdF9GIHwgRmxvYXRfaCB8IEZsb2F0X0ggLT4gKClcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmbG9hdCBmb3JtYXQgaW4gYSBidWZmZXIgKGV4OiBcIiUrKi4zZlwiKS4gKilcbmxldCBicHJpbnRfZmxvYXRfZm10IGJ1ZiBpZ25fZmxhZyBmY29udiBwYWQgcHJlYyA9XG4gIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnO1xuICBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICBicHJpbnRfcGFkZGluZyBidWYgcGFkO1xuICBicHJpbnRfcHJlY2lzaW9uIGJ1ZiBwcmVjO1xuICBidWZmZXJfYWRkX2NoYXIgYnVmIChjaGFyX29mX2Zjb252IGZjb252KVxuXG4oKiBDb21wdXRlIHRoZSBsaXRlcmFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEZvcm1hdHRpbmdfbGl0LiAqKVxuKCogVXNlZCBieSBQcmludGYgYW5kIFNjYW5mIHdoZXJlIGZvcm1hdHRpbmcgaXMgbm90IGludGVycHJldGVkLiAqKVxubGV0IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmb3JtYXR0aW5nX2xpdCA9IG1hdGNoIGZvcm1hdHRpbmdfbGl0IHdpdGhcbiAgfCBDbG9zZV9ib3ggICAgICAgICAgICAtPiBcIkBdXCJcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAtPiBcIkB9XCJcbiAgfCBCcmVhayAoc3RyLCBfLCBfKSAgICAtPiBzdHJcbiAgfCBGRmx1c2ggICAgICAgICAgICAgICAtPiBcIkA/XCJcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAtPiBcIkBcXG5cIlxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgIC0+IFwiQC5cIlxuICB8IE1hZ2ljX3NpemUgKHN0ciwgXykgIC0+IHN0clxuICB8IEVzY2FwZWRfYXQgICAgICAgICAgIC0+IFwiQEBcIlxuICB8IEVzY2FwZWRfcGVyY2VudCAgICAgIC0+IFwiQCVcIlxuICB8IFNjYW5faW5kaWMgYyAtPiBcIkBcIiBeIChTdHJpbmcubWFrZSAxIGMpXG5cbigqKiopXG5cbigqIFByaW50IGEgbGl0ZXJhbCBjaGFyIGluIGEgYnVmZmVyLCBlc2NhcGUgJyUnIGJ5IFwiJSVcIi4gKilcbmxldCBicHJpbnRfY2hhcl9saXRlcmFsIGJ1ZiBjaHIgPSBtYXRjaCBjaHIgd2l0aFxuICB8ICclJyAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlJVwiXG4gIHwgXyAtPiBidWZmZXJfYWRkX2NoYXIgYnVmIGNoclxuXG4oKiBQcmludCBhIGxpdGVyYWwgc3RyaW5nIGluIGEgYnVmZmVyLCBlc2NhcGUgYWxsICclJyBieSBcIiUlXCIuICopXG5sZXQgYnByaW50X3N0cmluZ19saXRlcmFsIGJ1ZiBzdHIgPVxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgc3RyLltpXVxuICBkb25lXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwcmV0dHktcHJpbnRpbmcgKilcblxuKCogUHJpbnQgYSBjb21wbGV0ZSBmb3JtYXQgdHlwZSAoYW4gZm10dHkpIGluIGEgYnVmZmVyLiAqKVxubGV0IHJlYyBicHJpbnRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCBpIGogayBsIC5cbiAgICBidWZmZXIgLT4gKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiB1bml0ID1cbmZ1biBidWYgZm10dHkgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IENoYXJfdHkgcmVzdCAgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVjXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJXNcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlaVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEludDMyX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVsaVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJW5pXCI7IGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlTGlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IEZsb2F0X3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVmXCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQm9vbF90eSByZXN0ICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJUJcIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBBbHBoYV90eSByZXN0ICAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlYVwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuICB8IFRoZXRhX3R5IHJlc3QgICAgIC0+IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiV0XCI7ICBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgQW55X3R5IHJlc3QgICAgICAgLT4gYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJT9cIjsgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcbiAgfCBSZWFkZXJfdHkgcmVzdCAgICAtPiBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlclwiOyAgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiVfclwiO1xuICAgIGJwcmludF9mbXR0eSBidWYgcmVzdDtcblxuICB8IEZvcm1hdF9hcmdfdHkgKHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIle1wiOyBicHJpbnRfZm10dHkgYnVmIHN1Yl9mbXR0eTtcbiAgICBidWZmZXJfYWRkX3N0cmluZyBidWYgXCIlfVwiOyBicHJpbnRfZm10dHkgYnVmIHJlc3Q7XG4gIHwgRm9ybWF0X3N1YnN0X3R5IChzdWJfZm10dHksIF8sIHJlc3QpIC0+XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJShcIjsgYnByaW50X2ZtdHR5IGJ1ZiBzdWJfZm10dHk7XG4gICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiJSlcIjsgYnByaW50X2ZtdHR5IGJ1ZiByZXN0O1xuXG4gIHwgRW5kX29mX2ZtdHR5IC0+ICgpXG5cbigqKiopXG5cbmxldCByZWMgaW50X29mX2N1c3RvbV9hcml0eSA6IHR5cGUgYSBiIGMgLlxuICAoYSwgYiwgYykgY3VzdG9tX2FyaXR5IC0+IGludCA9XG4gIGZ1bmN0aW9uXG4gIHwgQ3VzdG9tX3plcm8gLT4gMFxuICB8IEN1c3RvbV9zdWNjIHggLT4gMSArIGludF9vZl9jdXN0b21fYXJpdHkgeFxuXG4oKiBQcmludCBhIGNvbXBsZXRlIGZvcm1hdCBpbiBhIGJ1ZmZlci4gKilcbmxldCBicHJpbnRfZm10IGJ1ZiBmbXQgPVxuICBsZXQgcmVjIGZtdGl0ZXIgOiB0eXBlIGEgYiBjIGQgZSBmIC5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gYm9vbCAtPiB1bml0ID1cbiAgZnVuIGZtdCBpZ25fZmxhZyAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdzJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkZGluZyBidWYgcGFkOyBidWZmZXJfYWRkX2NoYXIgYnVmICdTJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcblxuICAgIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2ludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfYWx0aW50X2ZtdCBidWYgaWduX2ZsYWcgaWNvbnYgcGFkIHByZWMgJ2wnO1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICduJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2FsdGludF9mbXQgYnVmIGlnbl9mbGFnIGljb252IHBhZCBwcmVjICdMJztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgYnByaW50X2Zsb2F0X2ZtdCBidWYgaWduX2ZsYWcgZmNvbnYgcGFkIHByZWM7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IENoYXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnYyc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdDJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnByaW50X3BhZGRpbmcgYnVmIHBhZDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnQic7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBBbHBoYSByZXN0IC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICdhJzsgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAndCc7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEN1c3RvbSAoYXJpdHksIF8sIHJlc3QpIC0+XG4gICAgICBmb3IgX2kgPSAxIHRvIGludF9vZl9jdXN0b21fYXJpdHkgYXJpdHkgZG9cbiAgICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIGRvbmU7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG4gICAgfCBSZWFkZXIgcmVzdCAtPlxuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7IGJwcmludF9pZ25vcmVkX2ZsYWcgYnVmIGlnbl9mbGFnO1xuICAgICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAncic7IGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZsdXNoIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIiUhXCI7XG4gICAgICBmbXRpdGVyIHJlc3QgaWduX2ZsYWc7XG5cbiAgICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgICBicHJpbnRfc3RyaW5nX2xpdGVyYWwgYnVmIHN0cjtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IENoYXJfbGl0ZXJhbCAoY2hyLCByZXN0KSAtPlxuICAgICAgYnByaW50X2NoYXJfbGl0ZXJhbCBidWYgY2hyO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBGb3JtYXRfYXJnIChwYWRfb3B0LCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9wYWRfb3B0IGJ1ZiBwYWRfb3B0OyBidWZmZXJfYWRkX2NoYXIgYnVmICd7JztcbiAgICAgIGJwcmludF9mbXR0eSBidWYgZm10dHk7IGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBidWZmZXJfYWRkX2NoYXIgYnVmICd9JztcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IEZvcm1hdF9zdWJzdCAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgcGFkX29wdDsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKCc7XG4gICAgICBicHJpbnRfZm10dHkgYnVmIGZtdHR5OyBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnKSc7XG4gICAgICBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIHJlc3QpIC0+XG4gICAgICBidWZmZXJfYWRkX2NoYXIgYnVmICclJzsgYnByaW50X2lnbm9yZWRfZmxhZyBidWYgaWduX2ZsYWc7XG4gICAgICBicHJpbnRfcGFkX29wdCBidWYgd2lkdGhfb3B0OyBicHJpbnRfY2hhcl9zZXQgYnVmIGNoYXJfc2V0O1xuICAgICAgZm10aXRlciByZXN0IGZhbHNlO1xuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgcmVzdCkgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgKGNoYXJfb2ZfY291bnRlciBjb3VudGVyKTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBmYWxzZTtcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJyUnOyBicHJpbnRfaWdub3JlZF9mbGFnIGJ1ZiBpZ25fZmxhZztcbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgXCIwY1wiOyBmbXRpdGVyIHJlc3QgZmFsc2U7XG5cbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgIGxldCBQYXJhbV9mb3JtYXRfRUJCIGZtdCcgPSBwYXJhbV9mb3JtYXRfb2ZfaWdub3JlZF9mb3JtYXQgaWduIHJlc3QgaW5cbiAgICAgIGZtdGl0ZXIgZm10JyB0cnVlO1xuXG4gICAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICAgIGJwcmludF9zdHJpbmdfbGl0ZXJhbCBidWYgKHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0KTtcbiAgICAgIGZtdGl0ZXIgcmVzdCBpZ25fZmxhZztcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZm10aW5nX2dlbiB3aXRoXG4gICAgICB8IE9wZW5fdGFnIChGb3JtYXQgKF8sIHN0cikpIC0+XG4gICAgICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBcIkB7XCI7IGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiBzdHJcbiAgICAgIHwgT3Blbl9ib3ggKEZvcm1hdCAoXywgc3RyKSkgLT5cbiAgICAgICAgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIFwiQFtcIjsgYnVmZmVyX2FkZF9zdHJpbmcgYnVmIHN0clxuICAgICAgZW5kO1xuICAgICAgZm10aXRlciByZXN0IGlnbl9mbGFnO1xuXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+ICgpXG5cbiAgaW4gZm10aXRlciBmbXQgZmFsc2VcblxuKCoqKilcblxuKCogQ29udmVydCBhIGZvcm1hdCB0byBzdHJpbmcuICopXG5sZXQgc3RyaW5nX29mX2ZtdCBmbXQgPVxuICBsZXQgYnVmID0gYnVmZmVyX2NyZWF0ZSAxNiBpblxuICBicHJpbnRfZm10IGJ1ZiBmbXQ7XG4gIGJ1ZmZlcl9jb250ZW50cyBidWZcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogVHlwZSBleHRyYWN0aW9uICopXG5cbnR5cGUgKF8sIF8pIGVxID0gUmVmbCA6ICgnYSwgJ2EpIGVxXG5cbigqIEludmFyaWFudDogdGhpcyBmdW5jdGlvbiBpcyB0aGUgaWRlbnRpdHkgb24gdmFsdWVzLlxuXG4gICBJbiBwYXJ0aWN1bGFyLCBpZiAodHkxLCB0eTIpIGhhdmUgZXF1YWwgdmFsdWVzLCB0aGVuXG4gICAodHJhbnMgKHN5bW0gdHkxKSB0eTIpIHJlc3BlY3RzIHRoZSAndHJhbnMnIHByZWNvbmRpdGlvbi4gKilcbmxldCByZWMgc3ltbSA6IHR5cGUgYTEgYjEgYzEgZDEgZTEgZjEgYTIgYjIgYzIgZDIgZTIgZjIgLlxuICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlfcmVsXG4tPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMixcbiAgICBhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXR0eV9yZWxcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT4gQ2hhcl90eSAoc3ltbSByZXN0KVxuICB8IEludF90eSByZXN0IC0+IEludF90eSAoc3ltbSByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT4gSW50MzJfdHkgKHN5bW0gcmVzdClcbiAgfCBJbnQ2NF90eSByZXN0IC0+IEludDY0X3R5IChzeW1tIHJlc3QpXG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgLT4gTmF0aXZlaW50X3R5IChzeW1tIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPiBGbG9hdF90eSAoc3ltbSByZXN0KVxuICB8IEJvb2xfdHkgcmVzdCAtPiBCb29sX3R5IChzeW1tIHJlc3QpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT4gU3RyaW5nX3R5IChzeW1tIHJlc3QpXG4gIHwgVGhldGFfdHkgcmVzdCAtPiBUaGV0YV90eSAoc3ltbSByZXN0KVxuICB8IEFscGhhX3R5IHJlc3QgLT4gQWxwaGFfdHkgKHN5bW0gcmVzdClcbiAgfCBBbnlfdHkgcmVzdCAtPiBBbnlfdHkgKHN5bW0gcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPiBSZWFkZXJfdHkgKHN5bW0gcmVzdClcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+IElnbm9yZWRfcmVhZGVyX3R5IChzeW1tIHJlc3QpXG4gIHwgRm9ybWF0X2FyZ190eSAodHksIHJlc3QpIC0+XG4gICAgRm9ybWF0X2FyZ190eSAodHksIHN5bW0gcmVzdClcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdF90eSAodHkyLCB0eTEsIHN5bW0gcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbmxldCByZWMgZm10dHlfcmVsX2RldCA6IHR5cGUgYTEgYiBjIGQxIGUxIGYxIGEyIGQyIGUyIGYyIC5cbiAgKGExLCBiLCBjLCBkMSwgZTEsIGYxLFxuICAgYTIsIGIsIGMsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgICgoZjEsIGYyKSBlcSAtPiAoYTEsIGEyKSBlcSlcbiAgKiAoKGExLCBhMikgZXEgLT4gKGYxLCBmMikgZXEpXG4gICogKChlMSwgZTIpIGVxIC0+IChkMSwgZDIpIGVxKVxuICAqICgoZDEsIGQyKSBlcSAtPiAoZTEsIGUyKSBlcSlcbj0gZnVuY3Rpb25cbiAgfCBFbmRfb2ZfZm10dHkgLT5cbiAgICAoZnVuIFJlZmwgLT4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gUmVmbClcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgSW50MzJfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBJbnQ2NF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEZsb2F0X3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgZWQsIGRlXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuXG4gIHwgVGhldGFfdHkgcmVzdCAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBBbHBoYV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIGVkLCBkZVxuICB8IFJlYWRlcl90eSByZXN0IC0+XG4gICAgbGV0IGZhLCBhZiwgZWQsIGRlID0gZm10dHlfcmVsX2RldCByZXN0IGluXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZmEgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZGUgUmVmbCBpbiBSZWZsKVxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QgLT5cbiAgICBsZXQgZmEsIGFmLCBlZCwgZGUgPSBmbXR0eV9yZWxfZGV0IHJlc3QgaW5cbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBmYSBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGFmIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gZWQgUmVmbCBpbiBSZWZsKSxcbiAgICAoZnVuIFJlZmwgLT4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG4gIHwgRm9ybWF0X2FyZ190eSAoX3R5LCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gUmVmbCksXG4gICAgKGZ1biBSZWZsIC0+IGxldCBSZWZsID0gYWYgUmVmbCBpbiBSZWZsKSxcbiAgICBlZCwgZGVcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCBmYSwgYWYsIGVkLCBkZSA9IGZtdHR5X3JlbF9kZXQgcmVzdCBpblxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgbGV0IGFnLCBnYSwgZGosIGpkID0gZm10dHlfcmVsX2RldCB0eSBpblxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGZhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZyBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGdhIFJlZmwgaW4gbGV0IFJlZmwgPSBhZiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGVkIFJlZmwgaW4gbGV0IFJlZmwgPSBkaiBSZWZsIGluIFJlZmwpLFxuICAgIChmdW4gUmVmbCAtPiBsZXQgUmVmbCA9IGpkIFJlZmwgaW4gbGV0IFJlZmwgPSBkZSBSZWZsIGluIFJlZmwpXG5cbigqIFByZWNvbmRpdGlvbjogd2UgYXNzdW1lIHRoYXQgdGhlIHR3byBmbXR0eV9yZWwgYXJndW1lbnRzIGhhdmUgZXF1YWxcbiAgIHZhbHVlcyAoYXQgcG9zc2libHkgZGlzdGluY3QgdHlwZXMpOyB0aGlzIGludmFyaWFudCBjb21lcyBmcm9tIHRoZSB3YXlcbiAgIGZtdHR5X3JlbCB3aXRuZXNzZXMgYXJlIHByb2R1Y2VkIGJ5IHRoZSB0eXBlLWNoZWNrZXJcblxuICAgVGhlIGNvZGUgYmVsb3cgdXNlcyAoYXNzZXJ0IGZhbHNlKSB3aGVuIHRoaXMgYXNzdW1wdGlvbiBpcyBicm9rZW4uIFRoZVxuICAgY29kZSBwYXR0ZXJuIGlzIHRoZSBmb2xsb3dpbmc6XG5cbiAgICAgfCBGb28geCwgRm9vIHkgLT5cbiAgICAgICAoKiBjYXNlIHdoZXJlIGluZGVlZCBib3RoIHZhbHVlc1xuICAgICAgICAgIHN0YXJ0IHdpdGggY29uc3RydWN0b3IgRm9vICopXG4gICAgIHwgRm9vIF8sIF9cbiAgICAgfCBfLCBGb28gXyAtPlxuICAgICAgICgqIGRpZmZlcmVudCBoZWFkIGNvbnN0cnVjdG9yczogYnJva2VuIHByZWNvbmRpdGlvbiAqKVxuICAgICAgIGFzc2VydCBmYWxzZVxuKilcbmFuZCB0cmFucyA6IHR5cGVcbiAgYTEgYjEgYzEgZDEgZTEgZjFcbiAgYTIgYjIgYzIgZDIgZTIgZjJcbiAgYTMgYjMgYzMgZDMgZTMgZjNcbi5cbiAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxLFxuICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbFxuLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIsXG4gICAgYTMsIGIzLCBjMywgZDMsIGUzLCBmMykgZm10dHlfcmVsXG4tPiAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSxcbiAgICBhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eV9yZWxcbj0gZnVuIHR5MSB0eTIgLT4gbWF0Y2ggdHkxLCB0eTIgd2l0aFxuICB8IENoYXJfdHkgcmVzdDEsIENoYXJfdHkgcmVzdDIgLT4gQ2hhcl90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgU3RyaW5nX3R5IHJlc3QxLCBTdHJpbmdfdHkgcmVzdDIgLT4gU3RyaW5nX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBCb29sX3R5IHJlc3QxLCBCb29sX3R5IHJlc3QyIC0+IEJvb2xfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEludF90eSByZXN0MSwgSW50X3R5IHJlc3QyIC0+IEludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgSW50MzJfdHkgcmVzdDEsIEludDMyX3R5IHJlc3QyIC0+IEludDMyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJbnQ2NF90eSByZXN0MSwgSW50NjRfdHkgcmVzdDIgLT4gSW50NjRfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IE5hdGl2ZWludF90eSByZXN0MSwgTmF0aXZlaW50X3R5IHJlc3QyIC0+IE5hdGl2ZWludF90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgRmxvYXRfdHkgcmVzdDEsIEZsb2F0X3R5IHJlc3QyIC0+IEZsb2F0X3R5ICh0cmFucyByZXN0MSByZXN0MilcblxuICB8IEFscGhhX3R5IHJlc3QxLCBBbHBoYV90eSByZXN0MiAtPiBBbHBoYV90eSAodHJhbnMgcmVzdDEgcmVzdDIpXG4gIHwgQWxwaGFfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBBbHBoYV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgVGhldGFfdHkgcmVzdDEsIFRoZXRhX3R5IHJlc3QyIC0+IFRoZXRhX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBUaGV0YV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIFRoZXRhX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBBbnlfdHkgcmVzdDEsIEFueV90eSByZXN0MiAtPiBBbnlfdHkgKHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEFueV90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEFueV90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgUmVhZGVyX3R5IHJlc3QxLCBSZWFkZXJfdHkgcmVzdDIgLT4gUmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBSZWFkZXJfdHkgXywgXyAtPiBhc3NlcnQgZmFsc2VcbiAgfCBfLCBSZWFkZXJfdHkgXyAtPiBhc3NlcnQgZmFsc2VcblxuICB8IElnbm9yZWRfcmVhZGVyX3R5IHJlc3QxLCBJZ25vcmVkX3JlYWRlcl90eSByZXN0MiAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5ICh0cmFucyByZXN0MSByZXN0MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIElnbm9yZWRfcmVhZGVyX3R5IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgfCBGb3JtYXRfYXJnX3R5ICh0eTEsIHJlc3QxKSwgRm9ybWF0X2FyZ190eSAodHkyLCByZXN0MikgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0cmFucyB0eTEgdHkyLCB0cmFucyByZXN0MSByZXN0MilcbiAgfCBGb3JtYXRfYXJnX3R5IF8sIF8gLT4gYXNzZXJ0IGZhbHNlXG4gIHwgXywgRm9ybWF0X2FyZ190eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTExLCB0eTEyLCByZXN0MSksXG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTIxLCB0eTIyLCByZXN0MikgLT5cbiAgICBsZXQgdHkgPSB0cmFucyAoc3ltbSB0eTEyKSB0eTIxIGluXG4gICAgbGV0IF8sIGYyLCBfLCBmNCA9IGZtdHR5X3JlbF9kZXQgdHkgaW5cbiAgICBsZXQgUmVmbCA9IGYyIFJlZmwgaW5cbiAgICBsZXQgUmVmbCA9IGY0IFJlZmwgaW5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5MTEsIHR5MjIsIHRyYW5zIHJlc3QxIHJlc3QyKVxuICB8IEZvcm1hdF9zdWJzdF90eSBfLCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEZvcm1hdF9zdWJzdF90eSBfIC0+IGFzc2VydCBmYWxzZVxuXG4gIHwgRW5kX29mX2ZtdHR5LCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG4gIHwgRW5kX29mX2ZtdHR5LCBfIC0+IGFzc2VydCBmYWxzZVxuICB8IF8sIEVuZF9vZl9mbXR0eSAtPiBhc3NlcnQgZmFsc2VcblxubGV0IHJlYyBmbXR0eV9vZl9mb3JtYXR0aW5nX2dlbiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm9ybWF0dGluZ19nZW4gLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgPVxuZnVuIGZvcm1hdHRpbmdfZ2VuIC0+IG1hdGNoIGZvcm1hdHRpbmdfZ2VuIHdpdGhcbiAgfCBPcGVuX3RhZyAoRm9ybWF0IChmbXQsIF8pKSAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgT3Blbl9ib3ggKEZvcm1hdCAoZm10LCBfKSkgLT4gZm10dHlfb2ZfZm10IGZtdFxuXG4oKiBFeHRyYWN0IHRoZSB0eXBlIHJlcHJlc2VudGF0aW9uIChhbiBmbXR0eSkgb2YgYSBmb3JtYXQuICopXG5hbmQgZm10dHlfb2ZfZm10IDogdHlwZSBhIGIgYyBkIGUgZiAuXG4gIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5ID1cbmZ1biBmbXR0eSAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgU3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgKFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpKVxuXG4gIHwgSW50IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludF90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBJbnQzMiAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCB0eV9yZXN0ID0gZm10dHlfb2ZfZm10IHJlc3QgaW5cbiAgICBsZXQgcHJlY190eSA9IGZtdHR5X29mX3ByZWNpc2lvbl9mbXR0eSBwcmVjIChJbnQzMl90eSB0eV9yZXN0KSBpblxuICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIHByZWNfdHlcbiAgfCBOYXRpdmVpbnQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgdHlfcmVzdCA9IGZtdHR5X29mX2ZtdCByZXN0IGluXG4gICAgbGV0IHByZWNfdHkgPSBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgcHJlYyAoTmF0aXZlaW50X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEludDY0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEludDY0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IHR5X3Jlc3QgPSBmbXR0eV9vZl9mbXQgcmVzdCBpblxuICAgIGxldCBwcmVjX3R5ID0gZm10dHlfb2ZfcHJlY2lzaW9uX2ZtdHR5IHByZWMgKEZsb2F0X3R5IHR5X3Jlc3QpIGluXG4gICAgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSBwYWQgcHJlY190eVxuXG4gIHwgQ2hhciByZXN0ICAgICAgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgLT4gQ2hhcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgQm9vbCAocGFkLCByZXN0KSAgICAgICAgICAgLT5cbiAgICAgIGZtdHR5X29mX3BhZGRpbmdfZm10dHkgcGFkIChCb29sX3R5IChmbXR0eV9vZl9mbXQgcmVzdCkpXG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgLT4gQWxwaGFfdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFRoZXRhIHJlc3QgICAgICAgICAgICAgICAgIC0+IFRoZXRhX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBDdXN0b20gKGFyaXR5LCBfLCByZXN0KSAgICAtPiBmbXR0eV9vZl9jdXN0b20gYXJpdHkgKGZtdHR5X29mX2ZtdCByZXN0KVxuICB8IFJlYWRlciByZXN0ICAgICAgICAgICAgICAgIC0+IFJlYWRlcl90eSAoZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGb3JtYXRfYXJnIChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0IChfLCB0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfc3Vic3RfdHkgKHR5LCB0eSwgZm10dHlfb2ZfZm10IHJlc3QpXG5cbiAgfCBGbHVzaCByZXN0ICAgICAgICAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgcmVzdFxuICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgQ2hhcl9saXRlcmFsIChfLCByZXN0KSAgICAgLT4gZm10dHlfb2ZfZm10IHJlc3RcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+IFN0cmluZ190eSAoZm10dHlfb2ZfZm10IHJlc3QpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT4gSW50X3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBTY2FuX25leHRfY2hhciByZXN0ICAgICAgICAtPiBDaGFyX3R5IChmbXR0eV9vZl9mbXQgcmVzdClcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpICAtPiBmbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCBpZ24gcmVzdFxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgIC0+IGZtdHR5X29mX2ZtdCByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKGZtdGluZ19nZW4sIHJlc3QpICAtPlxuICAgIGNvbmNhdF9mbXR0eSAoZm10dHlfb2ZfZm9ybWF0dGluZ19nZW4gZm10aW5nX2dlbikgKGZtdHR5X29mX2ZtdCByZXN0KVxuXG4gIHwgRW5kX29mX2Zvcm1hdCAgICAgICAgICAgICAgLT4gRW5kX29mX2ZtdHR5XG5cbmFuZCBmbXR0eV9vZl9jdXN0b20gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICh5LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gYXJpdHkgZm10dHkgLT4gbWF0Y2ggYXJpdHkgd2l0aFxuICB8IEN1c3RvbV96ZXJvIC0+IGZtdHR5XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT4gQW55X3R5IChmbXR0eV9vZl9jdXN0b20gYXJpdHkgZm10dHkpXG5cbigqIEV4dHJhY3QgdGhlIGZtdHR5IG9mIGFuIGlnbm9yZWQgcGFyYW1ldGVyIGZvbGxvd2VkIGJ5IHRoZSByZXN0IG9mXG4gICB0aGUgZm9ybWF0LiAqKVxuYW5kIGZtdHR5X29mX2lnbm9yZWRfZm9ybWF0IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgIChhLCBiLCBjLCBkLCB5LCB4KSBpZ25vcmVkIC0+XG4gICAgKHgsIGIsIGMsIHksIGUsIGYpIGZtdCAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG5mdW4gaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50IChfLCBfKSAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50MzIgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfaW50NjQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZmxvYXQgKF8sIF8pICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyBfICAgICAgICAgICAgLT4gZm10dHlfb2ZfZm10IGZtdFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IChfLCBmbXR0eSkgLT4gY29uY2F0X2ZtdHR5IGZtdHR5IChmbXR0eV9vZl9mbXQgZm10KVxuICB8IElnbm9yZWRfcmVhZGVyICAgICAgICAgICAgICAgICAgLT4gSWdub3JlZF9yZWFkZXJfdHkgKGZtdHR5X29mX2ZtdCBmbXQpXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiBmbXR0eV9vZl9mbXQgZm10XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwYWRkaW5nIGlzIHRha2VuIGFzIGFuIGV4dHJhIGFyZ3VtZW50IChleDogXCIlKnNcIikuICopXG5hbmQgZm10dHlfb2ZfcGFkZGluZ19mbXR0eSA6IHR5cGUgeCBhIGIgYyBkIGUgZiAuXG4gICAgKHgsIGEpIHBhZGRpbmcgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwYWQgZm10dHkgLT4gbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgICAgLT4gZm10dHlcbiAgICB8IExpdF9wYWRkaW5nIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wYWRkaW5nIF8gLT4gSW50X3R5IGZtdHR5XG5cbigqIEFkZCBhbiBJbnRfdHkgbm9kZSBpZiBwcmVjaXNpb24gaXMgdGFrZW4gYXMgYW4gZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikuKilcbmFuZCBmbXR0eV9vZl9wcmVjaXNpb25fZm10dHkgOiB0eXBlIHggYSBiIGMgZCBlIGYgLlxuICAgICh4LCBhKSBwcmVjaXNpb24gLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+ICh4LCBiLCBjLCBkLCBlLCBmKSBmbXR0eSA9XG4gIGZ1biBwcmVjIGZtdHR5IC0+IG1hdGNoIHByZWMgd2l0aFxuICAgIHwgTm9fcHJlY2lzaW9uICAgIC0+IGZtdHR5XG4gICAgfCBMaXRfcHJlY2lzaW9uIF8gLT4gZm10dHlcbiAgICB8IEFyZ19wcmVjaXNpb24gICAtPiBJbnRfdHkgZm10dHlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBGb3JtYXQgdHlwaW5nICopXG5cbigqIEV4Y2VwdGlvbiByYWlzZWQgd2hlbiBhIGZvcm1hdCBkb2VzIG5vdCBtYXRjaCBhIGdpdmVuIGZvcm1hdCB0eXBlLiAqKVxuZXhjZXB0aW9uIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIHBhZGRpbmcuICopXG4oKiBUYWtlIGFuIEludF90eSBmcm9tIHRoZSBmbXR0eSBpZiB0aGUgaW50ZWdlciBzaG91bGQgYmUga2VwdCBhcyBhcmd1bWVudC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkZGluZyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRkaW5nX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIGZtdHR5IC0+IG1hdGNoIHBhZCwgZm10dHkgd2l0aFxuICB8IE5vX3BhZGRpbmcsIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKE5vX3BhZGRpbmcsIGZtdHR5KVxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIF8gLT4gUGFkZGluZ19mbXR0eV9FQkIgKExpdF9wYWRkaW5nIChwYWR0eSx3KSxmbXR0eSlcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgSW50X3R5IHJlc3QgLT4gUGFkZGluZ19mbXR0eV9FQkIgKEFyZ19wYWRkaW5nIHBhZHR5LHJlc3QpXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbigqIENvbnZlcnQgYSAodXBhZGRpbmcsIHVwcmVjaXNpb24pIHRvIGEgKHBhZGRpbmcsIHByZWNpc2lvbikuICopXG4oKiBUYWtlIG9uZSBvciB0d28gSW50X3R5IGZyb20gdGhlIGZtdHR5IGlmIG5lZWRlZC4gKilcbigqIFJhaXNlIFR5cGVfbWlzbWF0Y2ggaW4gY2FzZSBvZiB0eXBlIG1pc21hdGNoLiAqKVxubGV0IHR5cGVfcGFkcHJlYyA6IHR5cGUgYSBiIGMgZCBlIGYgeCB5IHogLlxuICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeikgcHJlY2lzaW9uIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eSAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBwYWRwcmVjX2ZtdHR5X2ViYiA9XG5mdW4gcGFkIHByZWMgZm10dHkgLT4gbWF0Y2ggcHJlYywgdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uLCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIE5vX3ByZWNpc2lvbiwgcmVzdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAsIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIHJlc3QpIC0+XG4gICAgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgTGl0X3ByZWNpc2lvbiBwLCByZXN0KVxuICB8IEFyZ19wcmVjaXNpb24sIFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEludF90eSByZXN0KSAtPlxuICAgIFBhZHByZWNfZm10dHlfRUJCIChwYWQsIEFyZ19wcmVjaXNpb24sIHJlc3QpXG4gIHwgXywgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVHlwZSBhIGZvcm1hdCBhY2NvcmRpbmcgdG8gYW4gZm10dHkuICopXG4oKiBJZiB0eXBpbmcgc3VjY2VlZCwgZ2VuZXJhdGUgYSBjb3B5IG9mIHRoZSBmb3JtYXQgd2l0aCB0aGUgc2FtZVxuICAgIHR5cGUgcGFyYW1ldGVycyBhcyB0aGUgZm10dHkuICopXG4oKiBSYWlzZSBbRmFpbHVyZV0gd2l0aCBhbiBlcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgdHlwZSBtaXNtYXRjaC4gKilcbmxldCByZWMgdHlwZV9mb3JtYXQgOlxuICB0eXBlIGExIGIxIGMxIGQxIGUxIGYxXG4gICAgICAgYTIgYjIgYzIgZDIgZTIgZjIgIC5cbiAgICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZtdFxuICAtPiAoYTIsIGIyLCBjMiwgZDIsIGUyLCBmMikgZm10dHlcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+IG1hdGNoIHR5cGVfZm9ybWF0X2dlbiBmbXQgZm10dHkgd2l0aFxuICB8IEZtdF9mbXR0eV9FQkIgKGZtdCcsIEVuZF9vZl9mbXR0eSkgLT4gZm10J1xuICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuXG5hbmQgdHlwZV9mb3JtYXRfZ2VuIDpcbiAgdHlwZSBhMSBiMSBjMSBkMSBlMSBmMVxuICAgICAgIGEyIGIyIGMyIGQyIGUyIGYyICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5XG4gIC0+IChhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXRfZm10dHlfZWJiXG49IGZ1biBmbXQgZm10dHkgLT4gbWF0Y2ggZm10LCBmbXR0eSB3aXRoXG4gIHwgQ2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXIgZm10JywgZm10dHknKVxuICB8IENhbWxfY2hhciBmbXRfcmVzdCwgQ2hhcl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfY2hhciBmbXQnLCBmbXR0eScpXG4gIHwgU3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKFN0cmluZyAocGFkLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkZGluZ19mbXR0eV9FQkIgKF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRkaW5nIHBhZCBmbXR0eSB3aXRoXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAocGFkLCBTdHJpbmdfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKENhbWxfc3RyaW5nIChwYWQsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRkaW5nX2ZtdHR5X0VCQiAoXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCBmbXRfcmVzdCksIF8gLT4gKFxuICAgIG1hdGNoIHR5cGVfcGFkcHJlYyBwYWQgcHJlYyBmbXR0eSB3aXRoXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAocGFkLCBwcmVjLCBJbnRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBJbnQzMiAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgSW50MzJfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEludDMyIChpY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgTmF0aXZlaW50X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGZtdCcpLCBmbXR0eScpXG4gICAgfCBQYWRwcmVjX2ZtdHR5X0VCQiAoXywgXywgXykgLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG4gIHwgSW50NjQgKGljb252LCBwYWQsIHByZWMsIGZtdF9yZXN0KSwgXyAtPiAoXG4gICAgbWF0Y2ggdHlwZV9wYWRwcmVjIHBhZCBwcmVjIGZtdHR5IHdpdGhcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChwYWQsIHByZWMsIEludDY0X3R5IGZtdHR5X3Jlc3QpIC0+XG4gICAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZHByZWNfZm10dHlfRUJCIChfLCBfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZHByZWMgcGFkIHByZWMgZm10dHkgd2l0aFxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKHBhZCwgcHJlYywgRmxvYXRfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEZsb2F0IChmY29udiwgcGFkLCBwcmVjLCBmbXQnKSwgZm10dHknKVxuICAgIHwgUGFkcHJlY19mbXR0eV9FQkIgKF8sIF8sIF8pIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcbiAgKVxuICB8IEJvb2wgKHBhZCwgZm10X3Jlc3QpLCBfIC0+IChcbiAgICBtYXRjaCB0eXBlX3BhZGRpbmcgcGFkIGZtdHR5IHdpdGhcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChwYWQsIEJvb2xfdHkgZm10dHlfcmVzdCkgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICAgIEZtdF9mbXR0eV9FQkIgKEJvb2wgKHBhZCwgZm10JyksIGZtdHR5JylcbiAgICB8IFBhZGRpbmdfZm10dHlfRUJCIChfLCBfKSAtPiByYWlzZSBUeXBlX21pc21hdGNoXG4gIClcbiAgfCBGbHVzaCBmbXRfcmVzdCwgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGbHVzaCBmbXQnLCBmbXR0eScpXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoU3RyaW5nX2xpdGVyYWwgKHN0ciwgZm10JyksIGZtdHR5JylcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKENoYXJfbGl0ZXJhbCAoY2hyLCBmbXQnKSwgZm10dHknKVxuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5LCBmbXRfcmVzdCksXG4gICAgRm9ybWF0X2FyZ190eSAoc3ViX2ZtdHR5JywgZm10dHlfcmVzdCkgLT5cbiAgICBpZiBGbXR0eV9FQkIgc3ViX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWJfZm10dHknIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5JywgZm10JyksIGZtdHR5JylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSwgZm10X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViX2ZtdHR5MSwgX3N1Yl9mbXR0eTIsIGZtdHR5X3Jlc3QpIC0+XG4gICAgaWYgRm10dHlfRUJCIChlcmFzZV9yZWwgc3ViX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWJfZm10dHkxKSB0aGVuXG4gICAgICByYWlzZSBUeXBlX21pc21hdGNoO1xuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID1cbiAgICAgIHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCAoZXJhc2VfcmVsIGZtdHR5X3Jlc3QpXG4gICAgaW5cbiAgICBGbXRfZm10dHlfRUJCIChGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eTEsIGZtdCcpLCBmbXR0eScpXG4gICgqIFByaW50ZiBhbmQgRm9ybWF0IHNwZWNpZmljIGNvbnN0cnVjdG9yczogKilcbiAgfCBBbHBoYSBmbXRfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChBbHBoYSBmbXQnLCBmbXR0eScpXG4gIHwgVGhldGEgZm10X3Jlc3QsIFRoZXRhX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoVGhldGEgZm10JywgZm10dHknKVxuXG4gICgqIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnM6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXRfcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCBmbXQnKSwgZm10dHknKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nX2dlbiwgZm10X3Jlc3QpLCBmbXR0eV9yZXN0IC0+XG4gICAgdHlwZV9mb3JtYXR0aW5nX2dlbiBmb3JtYXR0aW5nX2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciBmbXRfcmVzdCwgUmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXRfcmVzdCBmbXR0eV9yZXN0IGluXG4gICAgRm10X2ZtdHR5X0VCQiAoUmVhZGVyIGZtdCcsIGZtdHR5JylcbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCBmbXRfcmVzdCksIFN0cmluZ190eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10X3Jlc3QgZm10dHlfcmVzdCBpblxuICAgIEZtdF9mbXR0eV9FQkIgKFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGZtdCcpLCBmbXR0eScpXG4gIHwgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpLCBJbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdF9yZXN0IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXRfZm10dHlfRUJCIChTY2FuX2dldF9jb3VudGVyIChjb3VudGVyLCBmbXQnKSwgZm10dHknKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCksIGZtdHR5X3Jlc3QgLT5cbiAgICB0eXBlX2lnbm9yZWRfcGFyYW0gaWduIHJlc3QgZm10dHlfcmVzdFxuXG4gIHwgRW5kX29mX2Zvcm1hdCwgZm10dHlfcmVzdCAtPiBGbXRfZm10dHlfRUJCIChFbmRfb2ZfZm9ybWF0LCBmbXR0eV9yZXN0KVxuXG4gIHwgXyAtPiByYWlzZSBUeXBlX21pc21hdGNoXG5cbmFuZCB0eXBlX2Zvcm1hdHRpbmdfZ2VuIDogdHlwZSBhMSBhMyBiMSBiMyBjMSBjMyBkMSBkMyBlMSBlMiBlMyBmMSBmMiBmMyAuXG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEpIGZvcm1hdHRpbmdfZ2VuIC0+XG4gICAgKGYxLCBiMSwgYzEsIGUxLCBlMiwgZjIpIGZtdCAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXR0eSAtPlxuICAgIChhMywgYjMsIGMzLCBkMywgZTMsIGYzKSBmbXRfZm10dHlfZWJiID1cbmZ1biBmb3JtYXR0aW5nX2dlbiBmbXQwIGZtdHR5MCAtPiBtYXRjaCBmb3JtYXR0aW5nX2dlbiB3aXRoXG4gIHwgT3Blbl90YWcgKEZvcm1hdCAoZm10MSwgc3RyKSkgLT5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MiwgZm10dHkyKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQxIGZtdHR5MCBpblxuICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQzLCBmbXR0eTMpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdDAgZm10dHkyIGluXG4gICAgRm10X2ZtdHR5X0VCQiAoRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdDIsIHN0cikpLCBmbXQzKSwgZm10dHkzKVxuICB8IE9wZW5fYm94IChGb3JtYXQgKGZtdDEsIHN0cikpIC0+XG4gICAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdDIsIGZtdHR5MikgPSB0eXBlX2Zvcm1hdF9nZW4gZm10MSBmbXR0eTAgaW5cbiAgICBsZXQgRm10X2ZtdHR5X0VCQiAoZm10MywgZm10dHkzKSA9IHR5cGVfZm9ybWF0X2dlbiBmbXQwIGZtdHR5MiBpblxuICAgIEZtdF9mbXR0eV9FQkIgKEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQyLCBzdHIpKSwgZm10MyksIGZtdHR5MylcblxuKCogVHlwZSBhbiBJZ25vcmVkX3BhcmFtIG5vZGUgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuYW5kIHR5cGVfaWdub3JlZF9wYXJhbSA6IHR5cGUgcCBxIHggeSB6IHQgdSB2IGEgYiBjIGQgZSBmIC5cbiAgICAoeCwgeSwgeiwgdCwgcSwgcCkgaWdub3JlZCAtPlxuICAgIChwLCB5LCB6LCBxLCB1LCB2KSBmbXQgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10dHkgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10X2ZtdHR5X2ViYiA9XG5mdW4gaWduIGZtdCBmbXR0eSAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9jaGFyICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc3RyaW5nIF8gICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50IF8gICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50MzIgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfbmF0aXZlaW50IF8gICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfaW50NjQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZmxvYXQgXyAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9jaGFyX3NldCBfICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBfIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgIGFzIGlnbicgLT4gdHlwZV9pZ25vcmVkX3BhcmFtX29uZSBpZ24nIGZtdCBmbXR0eVxuICB8IElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSAtPlxuICAgIHR5cGVfaWdub3JlZF9wYXJhbV9vbmUgKElnbm9yZWRfZm9ybWF0X2FyZyAocGFkX29wdCwgc3ViX2ZtdHR5KSkgZm10IGZtdHR5XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKHBhZF9vcHQsIHN1Yl9mbXR0eSkgLT5cbiAgICBsZXQgRm10dHlfZm10X0VCQiAoc3ViX2ZtdHR5JywgRm10X2ZtdHR5X0VCQiAoZm10JywgZm10dHknKSkgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5IGZtdCBmbXR0eSBpblxuICAgIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfZm9ybWF0X3N1YnN0IChwYWRfb3B0LCBzdWJfZm10dHknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXQnKSxcbiAgICAgICAgICAgICAgICAgICBmbXR0eScpXG4gIHwgSWdub3JlZF9yZWFkZXIgLT4gKFxuICAgIG1hdGNoIGZtdHR5IHdpdGhcbiAgICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdHR5X3Jlc3QgLT5cbiAgICAgIGxldCBGbXRfZm10dHlfRUJCIChmbXQnLCBmbXR0eScpID0gdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eV9yZXN0IGluXG4gICAgICBGbXRfZm10dHlfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10JyksIGZtdHR5JylcbiAgICB8IF8gLT4gcmFpc2UgVHlwZV9taXNtYXRjaFxuICApXG5cbmFuZCB0eXBlX2lnbm9yZWRfcGFyYW1fb25lIDogdHlwZSBhMSBhMiBiMSBiMiBjMSBjMiBkMSBkMiBlMSBlMiBmMSBmMiAuXG4gICAgKGEyLCBiMiwgYzIsIGQyLCBkMiwgYTIpIGlnbm9yZWQgLT5cbiAgICAoYTEsIGIxLCBjMSwgZDEsIGUxLCBmMSkgZm10IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5IC0+XG4gICAgKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdF9mbXR0eV9lYmJcbj0gZnVuIGlnbiBmbXQgZm10dHkgLT5cbiAgbGV0IEZtdF9mbXR0eV9FQkIgKGZtdCcsIGZtdHR5JykgPSB0eXBlX2Zvcm1hdF9nZW4gZm10IGZtdHR5IGluXG4gIEZtdF9mbXR0eV9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbiwgZm10JyksIGZtdHR5JylcblxuKCogVHlwaW5nIG9mIHRoZSBjb21wbGV4IGNhc2U6IFwiJV8oLi4uJSlcIi4gKilcbmFuZCB0eXBlX2lnbm9yZWRfZm9ybWF0X3N1YnN0aXR1dGlvbiA6IHR5cGUgdyB4IHkgeiBwIHMgdCB1IGEgYiBjIGQgZSBmIC5cbiAgICAodywgeCwgeSwgeiwgcywgcCkgZm10dHkgLT5cbiAgICAocCwgeCwgeSwgcywgdCwgdSkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXR0eV9mbXRfZWJiID1cbmZ1biBzdWJfZm10dHkgZm10IGZtdHR5IC0+IG1hdGNoIHN1Yl9mbXR0eSwgZm10dHkgd2l0aFxuICB8IENoYXJfdHkgc3ViX2ZtdHR5X3Jlc3QsIENoYXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQ2hhcl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0LCBTdHJpbmdfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoU3RyaW5nX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QsIEludF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEludDMyX3R5IHN1Yl9mbXR0eV9yZXN0LCBJbnQzMl90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChJbnQzMl90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0LCBOYXRpdmVpbnRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoTmF0aXZlaW50X3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJbnQ2NF90eSBzdWJfZm10dHlfcmVzdCwgSW50NjRfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSW50NjRfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IEZsb2F0X3R5IHN1Yl9mbXR0eV9yZXN0LCBGbG9hdF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGbG9hdF90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgQm9vbF90eSBzdWJfZm10dHlfcmVzdCwgQm9vbF90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChCb29sX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBBbHBoYV90eSBzdWJfZm10dHlfcmVzdCwgQWxwaGFfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoQWxwaGFfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuICB8IFRoZXRhX3R5IHN1Yl9mbXR0eV9yZXN0LCBUaGV0YV90eSBmbXR0eV9yZXN0IC0+XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChUaGV0YV90eSBzdWJfZm10dHlfcmVzdCcsIGZtdCcpXG4gIHwgUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0LCBSZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoUmVhZGVyX3R5IHN1Yl9mbXR0eV9yZXN0JywgZm10JylcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBzdWJfZm10dHlfcmVzdCwgSWdub3JlZF9yZWFkZXJfdHkgZm10dHlfcmVzdCAtPlxuICAgIGxldCBGbXR0eV9mbXRfRUJCIChzdWJfZm10dHlfcmVzdCcsIGZtdCcpID1cbiAgICAgIHR5cGVfaWdub3JlZF9mb3JtYXRfc3Vic3RpdHV0aW9uIHN1Yl9mbXR0eV9yZXN0IGZtdCBmbXR0eV9yZXN0IGluXG4gICAgRm10dHlfZm10X0VCQiAoSWdub3JlZF9yZWFkZXJfdHkgc3ViX2ZtdHR5X3Jlc3QnLCBmbXQnKVxuXG4gIHwgRm9ybWF0X2FyZ190eSAoc3ViMl9mbXR0eSwgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9hcmdfdHkgKHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgIGlmIEZtdHR5X0VCQiBzdWIyX2ZtdHR5IDw+IEZtdHR5X0VCQiBzdWIyX2ZtdHR5JyB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gc3ViX2ZtdHR5X3Jlc3QgZm10IGZtdHR5X3Jlc3QgaW5cbiAgICBGbXR0eV9mbXRfRUJCIChGb3JtYXRfYXJnX3R5IChzdWIyX2ZtdHR5Jywgc3ViX2ZtdHR5X3Jlc3QnKSwgZm10JylcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHN1YjFfZm10dHksICBzdWIyX2ZtdHR5LCAgc3ViX2ZtdHR5X3Jlc3QpLFxuICAgIEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLCBmbXR0eV9yZXN0KSAtPlxuICAgICgqIFRPRE8gZGVmaW5lIEZtdHR5X3JlbF9FQkIgdG8gcmVtb3ZlIHRob3NlIGVyYXNlX3JlbCAqKVxuICAgIGlmIEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHkpIDw+IEZtdHR5X0VCQiAoZXJhc2VfcmVsIHN1YjFfZm10dHknKVxuICAgIHRoZW4gcmFpc2UgVHlwZV9taXNtYXRjaDtcbiAgICBpZiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5KSA8PiBGbXR0eV9FQkIgKGVyYXNlX3JlbCBzdWIyX2ZtdHR5JylcbiAgICB0aGVuIHJhaXNlIFR5cGVfbWlzbWF0Y2g7XG4gICAgbGV0IHN1Yl9mbXR0eScgPSB0cmFucyAoc3ltbSBzdWIxX2ZtdHR5Jykgc3ViMl9mbXR0eScgaW5cbiAgICBsZXQgXywgZjIsIF8sIGY0ID0gZm10dHlfcmVsX2RldCBzdWJfZm10dHknIGluXG4gICAgbGV0IFJlZmwgPSBmMiBSZWZsIGluXG4gICAgbGV0IFJlZmwgPSBmNCBSZWZsIGluXG4gICAgbGV0IEZtdHR5X2ZtdF9FQkIgKHN1Yl9mbXR0eV9yZXN0JywgZm10JykgPVxuICAgICAgdHlwZV9pZ25vcmVkX2Zvcm1hdF9zdWJzdGl0dXRpb24gKGVyYXNlX3JlbCBzdWJfZm10dHlfcmVzdCkgZm10IGZtdHR5X3Jlc3RcbiAgICBpblxuICAgIEZtdHR5X2ZtdF9FQkIgKEZvcm1hdF9zdWJzdF90eSAoc3ViMV9mbXR0eScsIHN1YjJfZm10dHknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ltbSBzdWJfZm10dHlfcmVzdCcpLFxuICAgICAgICAgICAgICAgICAgIGZtdCcpXG4gIHwgRW5kX29mX2ZtdHR5LCBmbXR0eSAtPlxuICAgIEZtdHR5X2ZtdF9FQkIgKEVuZF9vZl9mbXR0eSwgdHlwZV9mb3JtYXRfZ2VuIGZtdCBmbXR0eSlcbiAgfCBfIC0+IHJhaXNlIFR5cGVfbWlzbWF0Y2hcblxuKCogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBgcmVjYXN0YCBpcyBhIGJpdCBkaXNhcHBvaW50aW5nLiBUaGVcbiAgIGludmFyaWFudCBwcm92aWRlZCBieSB0aGUgdHlwZSBhcmUgdmVyeSBzdHJvbmc6IHRoZSBpbnB1dCBmb3JtYXQnc1xuICAgdHlwZSBpcyBpbiByZWxhdGlvbiB0byB0aGUgb3V0cHV0IHR5cGUncyBhcyB3aXRuZXNzZWQgYnkgdGhlXG4gICBmbXR0eV9yZWwgYXJndW1lbnQuIE9uZSB3b3VsZCBhdCBmaXJzdCBleHBlY3QgdGhpcyBmdW5jdGlvbiB0byBiZVxuICAgdG90YWwsIGFuZCBpbXBsZW1lbnRhYmxlIGJ5IGV4aGF1c3RpdmUgcGF0dGVybiBtYXRjaGluZy4gSW5zdGVhZCxcbiAgIHdlIHJldXNlIHRoZSBoaWdobHkgcGFydGlhbCBhbmQgbXVjaCBsZXNzIHdlbGwtZGVmaW5lZCBmdW5jdGlvblxuICAgYHR5cGVfZm9ybWF0YCB0aGF0IGhhcyBsb3N0IGFsbCBrbm93bGVkZ2Ugb2YgdGhlIGNvcnJlc3BvbmRlbmNlXG4gICBiZXR3ZWVuIHRoZSBhcmd1bWVudCdzIHR5cGVzLlxuXG4gICBCZXNpZGVzIHRoZSBmYWN0IHRoYXQgdGhpcyBmdW5jdGlvbiByZXVzZXMgYSBsb3Qgb2YgdGhlXG4gICBgdHlwZV9mb3JtYXRgIGxvZ2ljIChlZy46IHNlZWluZyBJbnRfdHkgaW4gdGhlIGZtdHR5IHBhcmFtZXRlciBkb2VzXG4gICBub3QgbGV0IHlvdSBtYXRjaCBvbiBJbnQgb25seSwgYXMgeW91IG1heSBpbiBmYWN0IGhhdmUgRmxvYXRcbiAgIChBcmdfcGFkZGluZywgLi4uKSAoXCIlLipkXCIpIGJlZ2lubmluZyB3aXRoIGFuIEludF90eSksIGl0IGlzIGFsc29cbiAgIGEgcGFydGlhbCBmdW5jdGlvbiwgYmVjYXVzZSB0aGUgdHlwaW5nIGluZm9ybWF0aW9uIGluIGEgZm9ybWF0IGlzXG4gICBub3QgcXVpdGUgZW5vdWdoIHRvIHJlY29uc3RydWN0IGl0IHVuYW1iaWd1b3VzbHkuIEZvciBleGFtcGxlLCB0aGVcbiAgIGZvcm1hdCB0eXBlcyBvZiBcIiVkJV9yXCIgYW5kIFwiJV9yJWRcIiBoYXZlIHRoZSBzYW1lIGZvcm1hdDZcbiAgIHBhcmFtZXRlcnMsIGJ1dCB0aGV5IGFyZSBub3QgYXQgYWxsIGV4Y2hhbmdlYWJsZSwgYW5kIHB1dHRpbmcgb25lXG4gICBpbiBwbGFjZSBvZiB0aGUgb3RoZXIgbXVzdCByZXN1bHQgaW4gYSBkeW5hbWljIGZhaWx1cmUuXG5cbiAgIEdpdmVuIHRoYXQ6XG4gICAtIHdlJ2QgaGF2ZSB0byBkdXBsaWNhdGUgYSBsb3Qgb2Ygbm9uLXRyaXZpYWwgdHlwaW5nIGxvZ2ljIGZyb20gdHlwZV9mb3JtYXRcbiAgIC0gdGhpcyB3b3VsZG4ndCBldmVuIGVsaW1pbmF0ZSAoYWxsKSB0aGUgZHluYW1pYyBmYWlsdXJlc1xuICAgd2UgZGVjaWRlZCB0byBqdXN0IHJldXNlIHR5cGVfZm9ybWF0IGRpcmVjdGx5IGZvciBub3cuXG4qKVxubGV0IHJlY2FzdCA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAuXG4gICAgIChhMSwgYjEsIGMxLCBkMSwgZTEsIGYxKSBmbXRcbiAgLT4gKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgICBhMiwgYjIsIGMyLCBkMiwgZTIsIGYyKSBmbXR0eV9yZWxcbiAgLT4gKGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdFxuPSBmdW4gZm10IGZtdHR5IC0+XG4gIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUHJpbnRpbmcgdG9vbHMgKilcblxuKCogQWRkIHBhZGRpbmcgc3BhY2VzIGFyb3VuZCBhIHN0cmluZy4gKilcbmxldCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCBzdHIgPVxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHdpZHRoLCBwYWR0eSA9XG4gICAgYWJzIHdpZHRoLFxuICAgICgqIHdoaWxlIGxpdGVyYWwgcGFkZGluZyB3aWR0aHMgYXJlIGFsd2F5cyBub24tbmVnYXRpdmUsXG4gICAgICAgZHluYW1pY2FsbHktc2V0IHdpZHRocyAoQXJnX3BhZGRpbmcsIGVnLiAlKmQpIG1heSBiZSBuZWdhdGl2ZTtcbiAgICAgICB3ZSBpbnRlcnByZXQgdGhvc2UgYXMgc3BlY2lmeWluZyBhIHBhZGRpbmctdG8tdGhlLWxlZnQ7IHRoaXNcbiAgICAgICBtZWFucyB0aGF0ICcwJyBtYXkgZ2V0IGRyb3BwZWQgZXZlbiBpZiBpdCB3YXMgZXhwbGljaXRseSBzZXQsXG4gICAgICAgYnV0OlxuICAgICAgIC0gdGhpcyBpcyB3aGF0IHRoZSBsZWdhY3kgaW1wbGVtZW50YXRpb24gZG9lcywgYW5kXG4gICAgICAgICB3ZSBwcmVzZXJ2ZSBjb21wYXRpYmlsaXR5IGlmIHBvc3NpYmxlXG4gICAgICAgLSB3ZSBjb3VsZCBvbmx5IHNpZ25hbCB0aGlzIGlzc3VlIGJ5IGZhaWxpbmcgYXQgcnVudGltZSxcbiAgICAgICAgIHdoaWNoIGlzIG5vdCB2ZXJ5IG5pY2UuLi4gKilcbiAgICBpZiB3aWR0aCA8IDAgdGhlbiBMZWZ0IGVsc2UgcGFkdHkgaW5cbiAgaWYgd2lkdGggPD0gbGVuIHRoZW4gc3RyIGVsc2VcbiAgICBsZXQgcmVzID0gQnl0ZXMubWFrZSB3aWR0aCAoaWYgcGFkdHkgPSBaZXJvcyB0aGVuICcwJyBlbHNlICcgJykgaW5cbiAgICBiZWdpbiBtYXRjaCBwYWR0eSB3aXRoXG4gICAgfCBMZWZ0ICAtPiBTdHJpbmcuYmxpdCBzdHIgMCByZXMgMCBsZW5cbiAgICB8IFJpZ2h0IC0+IFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAwICYmIChzdHIuWzBdID0gJysnIHx8IHN0ci5bMF0gPSAnLScgfHwgc3RyLlswXSA9ICcgJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMCBzdHIuWzBdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzICh3aWR0aCAtIGxlbiArIDEpIChsZW4gLSAxKVxuICAgIHwgWmVyb3Mgd2hlbiBsZW4gPiAxICYmIHN0ci5bMF0gPSAnMCcgJiYgKHN0ci5bMV0gPSAneCcgfHwgc3RyLlsxXSA9ICdYJykgLT5cbiAgICAgIEJ5dGVzLnNldCByZXMgMSBzdHIuWzFdO1xuICAgICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzICh3aWR0aCAtIGxlbiArIDIpIChsZW4gLSAyKVxuICAgIHwgWmVyb3MgLT5cbiAgICAgIFN0cmluZy5ibGl0IHN0ciAwIHJlcyAod2lkdGggLSBsZW4pIGxlblxuICAgIGVuZDtcbiAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBBZGQgJzAnIHBhZGRpbmcgdG8gaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKilcbmxldCBmaXhfaW50X3ByZWNpc2lvbiBwcmVjIHN0ciA9XG4gIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gIG1hdGNoIHN0ci5bMF0gd2l0aFxuICB8ICgnKycgfCAnLScgfCAnICcpIGFzIGMgd2hlbiBwcmVjICsgMSA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMSkgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAwIGM7XG4gICAgU3RyaW5nLmJsaXQgc3RyIDEgcmVzIChwcmVjIC0gbGVuICsgMikgKGxlbiAtIDEpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIHdoZW4gcHJlYyArIDIgPiBsZW4gJiYgbGVuID4gMSAmJiAoc3RyLlsxXSA9ICd4JyB8fCBzdHIuWzFdID0gJ1gnKSAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIChwcmVjICsgMikgJzAnIGluXG4gICAgQnl0ZXMuc2V0IHJlcyAxIHN0ci5bMV07XG4gICAgU3RyaW5nLmJsaXQgc3RyIDIgcmVzIChwcmVjIC0gbGVuICsgNCkgKGxlbiAtIDIpO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgfCAnQScgLi4gJ0YnIHdoZW4gcHJlYyA+IGxlbiAtPlxuICAgIGxldCByZXMgPSBCeXRlcy5tYWtlIHByZWMgJzAnIGluXG4gICAgU3RyaW5nLmJsaXQgc3RyIDAgcmVzIChwcmVjIC0gbGVuKSBsZW47XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXNcbiAgfCBfIC0+XG4gICAgc3RyXG5cbigqIEVzY2FwZSBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGluZyBjb252ZW50aW9uLiAqKVxubGV0IHN0cmluZ190b19jYW1sX3N0cmluZyBzdHIgPVxuICBsZXQgc3RyID0gU3RyaW5nLmVzY2FwZWQgc3RyIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgbGV0IHJlcyA9IEJ5dGVzLm1ha2UgKGwgKyAyKSAnXFxcIicgaW5cbiAgU3RyaW5nLnVuc2FmZV9ibGl0IHN0ciAwIHJlcyAxIGw7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfaW50L2ludDMyL25hdGl2ZWludC9pbnQ2NCBmaXJzdCBhcmd1bWVudFxuICAgZnJvbSBhbiBpbnRfY29udi4gKilcbmxldCBmb3JtYXRfb2ZfaWNvbnYgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWRcIiB8IEludF9wZCAtPiBcIiUrZFwiIHwgSW50X3NkIC0+IFwiJSBkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVpXCIgfCBJbnRfcGkgLT4gXCIlK2lcIiB8IEludF9zaSAtPiBcIiUgaVwiXG4gIHwgSW50X3ggLT4gXCIleFwiIHwgSW50X0N4IC0+IFwiJSN4XCJcbiAgfCBJbnRfWCAtPiBcIiVYXCIgfCBJbnRfQ1ggLT4gXCIlI1hcIlxuICB8IEludF9vIC0+IFwiJW9cIiB8IEludF9DbyAtPiBcIiUjb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIldVwiXG5cbmxldCBmb3JtYXRfb2ZfaWNvbnZMID0gZnVuY3Rpb25cbiAgfCBJbnRfZCB8IEludF9DZCAtPiBcIiVMZFwiIHwgSW50X3BkIC0+IFwiJStMZFwiIHwgSW50X3NkIC0+IFwiJSBMZFwiXG4gIHwgSW50X2kgfCBJbnRfQ2kgLT4gXCIlTGlcIiB8IEludF9waSAtPiBcIiUrTGlcIiB8IEludF9zaSAtPiBcIiUgTGlcIlxuICB8IEludF94IC0+IFwiJUx4XCIgfCBJbnRfQ3ggLT4gXCIlI0x4XCJcbiAgfCBJbnRfWCAtPiBcIiVMWFwiIHwgSW50X0NYIC0+IFwiJSNMWFwiXG4gIHwgSW50X28gLT4gXCIlTG9cIiB8IEludF9DbyAtPiBcIiUjTG9cIlxuICB8IEludF91IHwgSW50X0N1IC0+IFwiJUx1XCJcblxubGV0IGZvcm1hdF9vZl9pY29udmwgPSBmdW5jdGlvblxuICB8IEludF9kIHwgSW50X0NkIC0+IFwiJWxkXCIgfCBJbnRfcGQgLT4gXCIlK2xkXCIgfCBJbnRfc2QgLT4gXCIlIGxkXCJcbiAgfCBJbnRfaSB8IEludF9DaSAtPiBcIiVsaVwiIHwgSW50X3BpIC0+IFwiJStsaVwiIHwgSW50X3NpIC0+IFwiJSBsaVwiXG4gIHwgSW50X3ggLT4gXCIlbHhcIiB8IEludF9DeCAtPiBcIiUjbHhcIlxuICB8IEludF9YIC0+IFwiJWxYXCIgfCBJbnRfQ1ggLT4gXCIlI2xYXCJcbiAgfCBJbnRfbyAtPiBcIiVsb1wiIHwgSW50X0NvIC0+IFwiJSNsb1wiXG4gIHwgSW50X3UgfCBJbnRfQ3UgLT4gXCIlbHVcIlxuXG5sZXQgZm9ybWF0X29mX2ljb252biA9IGZ1bmN0aW9uXG4gIHwgSW50X2QgfCBJbnRfQ2QgLT4gXCIlbmRcIiB8IEludF9wZCAtPiBcIiUrbmRcIiB8IEludF9zZCAtPiBcIiUgbmRcIlxuICB8IEludF9pIHwgSW50X0NpIC0+IFwiJW5pXCIgfCBJbnRfcGkgLT4gXCIlK25pXCIgfCBJbnRfc2kgLT4gXCIlIG5pXCJcbiAgfCBJbnRfeCAtPiBcIiVueFwiIHwgSW50X0N4IC0+IFwiJSNueFwiXG4gIHwgSW50X1ggLT4gXCIlblhcIiB8IEludF9DWCAtPiBcIiUjblhcIlxuICB8IEludF9vIC0+IFwiJW5vXCIgfCBJbnRfQ28gLT4gXCIlI25vXCJcbiAgfCBJbnRfdSB8IEludF9DdSAtPiBcIiVudVwiXG5cbigqIEdlbmVyYXRlIHRoZSBmb3JtYXRfZmxvYXQgZmlyc3QgYXJndW1lbnQgZnJvbSBhIGZsb2F0X2NvbnYuICopXG5sZXQgZm9ybWF0X29mX2Zjb252IGZjb252IHByZWMgPVxuICAgIGxldCBwcmVjID0gYWJzIHByZWMgaW5cbiAgICBsZXQgc3ltYiA9IGNoYXJfb2ZfZmNvbnYgfmNGOidnJyBmY29udiBpblxuICAgIGxldCBidWYgPSBidWZmZXJfY3JlYXRlIDE2IGluXG4gICAgYnVmZmVyX2FkZF9jaGFyIGJ1ZiAnJSc7XG4gICAgYnByaW50X2Zjb252X2ZsYWcgYnVmIGZjb252O1xuICAgIGJ1ZmZlcl9hZGRfY2hhciBidWYgJy4nO1xuICAgIGJ1ZmZlcl9hZGRfc3RyaW5nIGJ1ZiAoSW50LnRvX3N0cmluZyBwcmVjKTtcbiAgICBidWZmZXJfYWRkX2NoYXIgYnVmIHN5bWI7XG4gICAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG5sZXQgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgcyA9XG4gIG1hdGNoIGljb252IHdpdGhcbiAgfCBJbnRfQ2QgfCBJbnRfQ2kgfCBJbnRfQ3UgLT5cbiAgICBsZXQgZGlnaXRzID1cbiAgICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgIHwgJzAnLi4nOScgLT4gaW5jciBuXG4gICAgICAgIHwgXyAtPiAoKVxuICAgICAgZG9uZTtcbiAgICAgICFuXG4gICAgaW5cbiAgICBsZXQgYnVmID0gQnl0ZXMuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHMgKyAoZGlnaXRzIC0gMSkgLyAzKSBpblxuICAgIGxldCBwb3MgPSByZWYgMCBpblxuICAgIGxldCBwdXQgYyA9IEJ5dGVzLnNldCBidWYgIXBvcyBjOyBpbmNyIHBvcyBpblxuICAgIGxldCBsZWZ0ID0gcmVmICgoZGlnaXRzIC0gMSkgbW9kIDMgKyAxKSBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAnMCcuLic5JyBhcyBjIC0+XG4gICAgICAgICAgaWYgIWxlZnQgPSAwIHRoZW4gKHB1dCAnXyc7IGxlZnQgOj0gMyk7IGRlY3IgbGVmdDsgcHV0IGNcbiAgICAgIHwgYyAtPiBwdXQgY1xuICAgIGRvbmU7XG4gICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBidWZcbiAgfCBfIC0+IHNcblxuKCogQ29udmVydCBhbiBpbnRlZ2VyIHRvIGEgc3RyaW5nIGFjY29yZGluZyB0byBhIGNvbnZlcnNpb24uICopXG5sZXQgY29udmVydF9pbnQgaWNvbnYgbiA9XG4gIHRyYW5zZm9ybV9pbnRfYWx0IGljb252IChmb3JtYXRfaW50IChmb3JtYXRfb2ZfaWNvbnYgaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQzMiBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQzMiAoZm9ybWF0X29mX2ljb252bCBpY29udikgbilcbmxldCBjb252ZXJ0X25hdGl2ZWludCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9uYXRpdmVpbnQgKGZvcm1hdF9vZl9pY29udm4gaWNvbnYpIG4pXG5sZXQgY29udmVydF9pbnQ2NCBpY29udiBuID1cbiAgdHJhbnNmb3JtX2ludF9hbHQgaWNvbnYgKGZvcm1hdF9pbnQ2NCAoZm9ybWF0X29mX2ljb252TCBpY29udikgbilcblxuKCogQ29udmVydCBhIGZsb2F0IHRvIHN0cmluZy4gKilcbigqIEZpeCBzcGVjaWFsIGNhc2Ugb2YgXCJPQ2FtbCBmbG9hdCBmb3JtYXRcIi4gKilcbmxldCBjb252ZXJ0X2Zsb2F0IGZjb252IHByZWMgeCA9XG4gIGxldCBoZXggKCkgPVxuICAgIGxldCBzaWduID1cbiAgICAgIG1hdGNoIGZzdCBmY29udiB3aXRoXG4gICAgICB8IEZsb2F0X2ZsYWdfcCAtPiAnKydcbiAgICAgIHwgRmxvYXRfZmxhZ19zIC0+ICcgJ1xuICAgICAgfCBfIC0+ICctJyBpblxuICAgIGhleHN0cmluZ19vZl9mbG9hdCB4IHByZWMgc2lnbiBpblxuICBsZXQgYWRkX2RvdF9pZl9uZWVkZWQgc3RyID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzdHIgaW5cbiAgICBsZXQgcmVjIGlzX3ZhbGlkIGkgPVxuICAgICAgaWYgaSA9IGxlbiB0aGVuIGZhbHNlIGVsc2VcbiAgICAgICAgbWF0Y2ggc3RyLltpXSB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ2UnIHwgJ0UnIC0+IHRydWVcbiAgICAgICAgfCBfIC0+IGlzX3ZhbGlkIChpICsgMSkgaW5cbiAgICBpZiBpc192YWxpZCAwIHRoZW4gc3RyIGVsc2Ugc3RyIF4gXCIuXCIgaW5cbiAgbGV0IGNhbWxfc3BlY2lhbF92YWwgc3RyID0gbWF0Y2ggY2xhc3NpZnlfZmxvYXQgeCB3aXRoXG4gICAgfCBGUF9ub3JtYWwgfCBGUF9zdWJub3JtYWwgfCBGUF96ZXJvIC0+IHN0clxuICAgIHwgRlBfaW5maW5pdGUgLT4gaWYgeCA8IDAuMCB0aGVuIFwibmVnX2luZmluaXR5XCIgZWxzZSBcImluZmluaXR5XCJcbiAgICB8IEZQX25hbiAtPiBcIm5hblwiIGluXG4gIG1hdGNoIHNuZCBmY29udiB3aXRoXG4gIHwgRmxvYXRfaCAtPiBoZXggKClcbiAgfCBGbG9hdF9IIC0+IFN0cmluZy51cHBlcmNhc2VfYXNjaWkgKGhleCAoKSlcbiAgfCBGbG9hdF9DRiAtPiBjYW1sX3NwZWNpYWxfdmFsIChoZXggKCkpXG4gIHwgRmxvYXRfRiAtPlxuICAgIGxldCBzdHIgPSBmb3JtYXRfZmxvYXQgKGZvcm1hdF9vZl9mY29udiBmY29udiBwcmVjKSB4IGluXG4gICAgY2FtbF9zcGVjaWFsX3ZhbCAoYWRkX2RvdF9pZl9uZWVkZWQgc3RyKVxuICB8IEZsb2F0X2YgfCBGbG9hdF9lIHwgRmxvYXRfRSB8IEZsb2F0X2cgfCBGbG9hdF9HIC0+XG4gICAgZm9ybWF0X2Zsb2F0IChmb3JtYXRfb2ZfZmNvbnYgZmNvbnYgcHJlYykgeFxuXG4oKiBDb252ZXJ0IGEgY2hhciB0byBhIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIE9DYW1sIGxleGljYWwgY29udmVudGlvbi4gKilcbmxldCBmb3JtYXRfY2FtbF9jaGFyIGMgPVxuICBsZXQgc3RyID0gQ2hhci5lc2NhcGVkIGMgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVzID0gQnl0ZXMubWFrZSAobCArIDIpICdcXCcnIGluXG4gIFN0cmluZy51bnNhZmVfYmxpdCBzdHIgMCByZXMgMSBsO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc1xuXG4oKiBDb252ZXJ0IGEgZm9ybWF0IHR5cGUgdG8gc3RyaW5nICopXG5sZXQgc3RyaW5nX29mX2ZtdHR5IGZtdHR5ID1cbiAgbGV0IGJ1ZiA9IGJ1ZmZlcl9jcmVhdGUgMTYgaW5cbiAgYnByaW50X2ZtdHR5IGJ1ZiBmbXR0eTtcbiAgYnVmZmVyX2NvbnRlbnRzIGJ1ZlxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgKCogR2VuZXJpYyBwcmludGluZyBmdW5jdGlvbiAqKVxuXG4oKiBNYWtlIGEgZ2VuZXJpYyBwcmludGluZyBmdW5jdGlvbi4gKilcbigqIFVzZWQgdG8gZ2VuZXJhdGUgUHJpbnRmIGFuZCBGb3JtYXQgcHJpbnRpbmcgZnVuY3Rpb25zLiAqKVxuKCogUGFyYW1ldGVyczpcbiAgICAgazogYSBjb250aW51YXRpb24gZmluYWxseSBhcHBsaWVkIHRvIHRoZSBvdXRwdXQgc3RyZWFtIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gICAgIG86IHRoZSBvdXRwdXQgc3RyZWFtIChzZWUgaywgJWEgYW5kICV0KS5cbiAgICAgYWNjOiByZXYgbGlzdCBvZiBwcmludGluZyBlbnRpdGllcyAoc3RyaW5nLCBjaGFyLCBmbHVzaCwgZm9ybWF0dGluZywgLi4uKS5cbiAgICAgZm10OiB0aGUgZm9ybWF0LiAqKVxubGV0IHJlYyBtYWtlX3ByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICB8IENoYXIgcmVzdCAtPlxuICAgIGZ1biBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX2NoYXIgKGFjYywgYykgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgLT5cbiAgICBmdW4gYyAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgZm9ybWF0X2NhbWxfY2hhciBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTdHJpbmcgKHBhZCwgcmVzdCkgLT5cbiAgICBtYWtlX3BhZGRpbmcgayBhY2MgcmVzdCBwYWQgKGZ1biBzdHIgLT4gc3RyKVxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ190b19jYW1sX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50IGljb252XG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbWFrZV9pbnRfcGFkZGluZ19wcmVjaXNpb24gayBhY2MgcmVzdCBwYWQgcHJlYyBjb252ZXJ0X2ludDMyIGljb252XG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIG1ha2VfaW50X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgY29udmVydF9uYXRpdmVpbnQgaWNvbnZcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiBrIGFjYyByZXN0IHBhZCBwcmVjIGNvbnZlcnRfaW50NjQgaWNvbnZcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBtYWtlX2Zsb2F0X3BhZGRpbmdfcHJlY2lzaW9uIGsgYWNjIHJlc3QgcGFkIHByZWMgZmNvbnZcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgbWFrZV9wYWRkaW5nIGsgYWNjIHJlc3QgcGFkIHN0cmluZ19vZl9ib29sXG4gIHwgQWxwaGEgcmVzdCAtPlxuICAgIGZ1biBmIHggLT4gbWFrZV9wcmludGYgayAoQWNjX2RlbGF5IChhY2MsIGZ1biBvIC0+IGYgbyB4KSkgcmVzdFxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBmdW4gZiAtPiBtYWtlX3ByaW50ZiBrIChBY2NfZGVsYXkgKGFjYywgZikpIHJlc3RcbiAgfCBDdXN0b20gKGFyaXR5LCBmLCByZXN0KSAtPlxuICAgIG1ha2VfY3VzdG9tIGsgYWNjIHJlc3QgYXJpdHkgKGYgKCkpXG4gIHwgUmVhZGVyIF8gLT5cbiAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICopXG4gICAgKCogSW5kZWVkLCBzaW5jZSBwcmludGYgYW5kIGNvLiB0YWtlIGEgZm9ybWF0NCBhcyBhcmd1bWVudCwgdGhlICdkIGFuZCAnZVxuICAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiBmbXQgYXJlIG9idmlvdXNseSBlcXVhbHMuIFRoZSBSZWFkZXIgaXMgdGhlXG4gICAgICAgb25seSBjb25zdHJ1Y3RvciB3aGljaCB0b3VjaCAnZCBhbmQgJ2UgdHlwZSBwYXJhbWV0ZXJzIG9mIHRoZSBmb3JtYXRcbiAgICAgICB0eXBlLCBpdCBhZGRzIGFuICgtPikgdG8gdGhlICdkIHBhcmFtZXRlcnMuIENvbnNlcXVlbnRseSwgYSBmb3JtYXQ0XG4gICAgICAgY2Fubm90IGNvbnRhaW4gYSBSZWFkZXIgbm9kZSwgZXhjZXB0IGluIHRoZSBzdWItZm9ybWF0IGFzc29jaWF0ZWQgdG9cbiAgICAgICBhbiAley4uLiV9LiBJdCdzIG5vdCBhIHByb2JsZW0gYmVjYXVzZSBtYWtlX3ByaW50ZiBkbyBub3QgY2FsbFxuICAgICAgIGl0c2VsZiByZWN1cnNpdmVseSBvbiB0aGUgc3ViLWZvcm1hdCBhc3NvY2lhdGVkIHRvICV7Li4uJX0uICopXG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mbHVzaCBhY2MpIHJlc3RcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgbWFrZV9wcmludGYgayAoQWNjX3N0cmluZ19saXRlcmFsIChhY2MsIHN0cikpIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfY2hhcl9saXRlcmFsIChhY2MsIGNocikpIHJlc3RcblxuICB8IEZvcm1hdF9hcmcgKF8sIHN1Yl9mbXR0eSwgcmVzdCkgLT5cbiAgICBsZXQgdHkgPSBzdHJpbmdfb2ZfZm10dHkgc3ViX2ZtdHR5IGluXG4gICAgKGZ1biBzdHIgLT5cbiAgICAgIGlnbm9yZSBzdHI7XG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHkpKSByZXN0KVxuICB8IEZvcm1hdF9zdWJzdCAoXywgZm10dHksIHJlc3QpIC0+XG4gICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+IG1ha2VfcHJpbnRmIGsgYWNjXG4gICAgICAoY29uY2F0X2ZtdCAocmVjYXN0IGZtdCBmbXR0eSkgcmVzdClcblxuICB8IFNjYW5fY2hhcl9zZXQgKF8sIF8sIHJlc3QpIC0+XG4gICAgbGV0IG5ld19hY2MgPSBBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVbXCIpIGluXG4gICAgZnVuIF8gLT4gbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX2dldF9jb3VudGVyIChfLCByZXN0KSAtPlxuICAgICgqIFRoaXMgY2FzZSBzaG91bGQgYmUgcmVmdXNlZCBmb3IgUHJpbnRmLiAqKVxuICAgICgqIEFjY2VwdGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiAqKVxuICAgICgqIEludGVycHJldCAlbCwgJW4gYW5kICVMIGFzICV1LiAqKVxuICAgIGZ1biBuIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmb3JtYXRfaW50IFwiJXVcIiBuKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgZnVuIGMgLT5cbiAgICAgIGxldCBuZXdfYWNjID0gQWNjX2RhdGFfY2hhciAoYWNjLCBjKSBpblxuICAgICAgbWFrZV9wcmludGYgayBuZXdfYWNjIHJlc3RcbiAgfCBJZ25vcmVkX3BhcmFtIChpZ24sIHJlc3QpIC0+XG4gICAgbWFrZV9pZ25vcmVkX3BhcmFtIGsgYWNjIGlnbiByZXN0XG5cbiAgfCBGb3JtYXR0aW5nX2xpdCAoZm10aW5nX2xpdCwgcmVzdCkgLT5cbiAgICBtYWtlX3ByaW50ZiBrIChBY2NfZm9ybWF0dGluZ19saXQgKGFjYywgZm10aW5nX2xpdCkpIHJlc3RcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl90YWcgKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl90YWcga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcbiAgfCBGb3JtYXR0aW5nX2dlbiAoT3Blbl9ib3ggKEZvcm1hdCAoZm10JywgXykpLCByZXN0KSAtPlxuICAgIGxldCBrJyBrYWNjID1cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19mb3JtYXR0aW5nX2dlbiAoYWNjLCBBY2Nfb3Blbl9ib3gga2FjYykpIHJlc3QgaW5cbiAgICBtYWtlX3ByaW50ZiBrJyBFbmRfb2ZfYWNjIGZtdCdcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBrIGFjY1xuXG4oKiBEZWxheSB0aGUgZXJyb3IgKEludmFsaWRfYXJndW1lbnQgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpLiAqKVxuKCogR2VuZXJhdGUgZnVuY3Rpb25zIHRvIHRha2UgcmVtYWluaW5nIGFyZ3VtZW50cyAoYWZ0ZXIgdGhlIFwiJV9cIikuICopXG5hbmQgbWFrZV9pZ25vcmVkX3BhcmFtIDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgaWdub3JlZCAtPlxuICAgICh4LCBiLCBjLCB5LCBlLCBmKSBmbXQgLT4gYSA9XG5mdW4gayBhY2MgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfY2hhciAgICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2NhbWxfY2hhciAgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgXyAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludCAoXywgXykgICAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfbmF0aXZlaW50IChfLCBfKSAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2ludDY0IChfLCBfKSAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfYm9vbCBfICAgICAgICAgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgXyAgICAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgZm10dHkgZm10XG4gIHwgSWdub3JlZF9yZWFkZXIgICAgICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgXyAgICAgICAgIC0+IG1ha2VfaW52YWxpZF9hcmcgayBhY2MgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIgICAgICAgICAgLT4gbWFrZV9pbnZhbGlkX2FyZyBrIGFjYyBmbXRcblxuXG4oKiBTcGVjaWFsIGNhc2Ugb2YgcHJpbnRmIFwiJV8oXCIuICopXG5hbmQgbWFrZV9mcm9tX2ZtdHR5IDogdHlwZSB4IHkgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgeSwgeCkgZm10dHkgLT5cbiAgICAoeCwgYiwgYywgeSwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdHR5IGZtdCAtPiBtYXRjaCBmbXR0eSB3aXRoXG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgU3RyaW5nX3R5IHJlc3QgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50X3R5IHJlc3QgICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgTmF0aXZlaW50X3R5IHJlc3QgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgSW50NjRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQm9vbF90eSByZXN0ICAgICAgICAgICAgLT4gZnVuIF8gLT4gbWFrZV9mcm9tX2ZtdHR5IGsgYWNjIHJlc3QgZm10XG4gIHwgQWxwaGFfdHkgcmVzdCAgICAgICAgICAgLT4gZnVuIF8gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBUaGV0YV90eSByZXN0ICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBBbnlfdHkgcmVzdCAgICAgICAgICAgICAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBSZWFkZXJfdHkgXyAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSBfICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAtPiBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgcmVzdCBmbXRcbiAgfCBFbmRfb2ZfZm10dHkgICAgICAgICAgICAtPiBtYWtlX2ludmFsaWRfYXJnIGsgYWNjIGZtdFxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgbGV0IHR5ID0gdHJhbnMgKHN5bW0gdHkxKSB0eTIgaW5cbiAgICBmdW4gXyAtPiBtYWtlX2Zyb21fZm10dHkgayBhY2MgKGNvbmNhdF9mbXR0eSB0eSByZXN0KSBmbXRcblxuKCogSW5zZXJ0IGFuIEFjY19pbnZhbGlkX2FyZyBpbiB0aGUgYWNjdW11bGF0b3IgYW5kIGNvbnRpbnVlIHRvIGdlbmVyYXRlXG4gICBjbG9zdXJlcyB0byBnZXQgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuICopXG5hbmQgbWFrZV9pbnZhbGlkX2FyZyA6IHR5cGUgYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuZnVuIGsgYWNjIGZtdCAtPlxuICBtYWtlX3ByaW50ZiBrIChBY2NfaW52YWxpZF9hcmcgKGFjYywgXCJQcmludGY6IGJhZCBjb252ZXJzaW9uICVfXCIpKSBmbXRcblxuKCogRml4IHBhZGRpbmcsIHRha2UgaXQgYXMgYW4gZXh0cmEgaW50ZWdlciBhcmd1bWVudCBpZiBuZWVkZWQuICopXG5hbmQgbWFrZV9wYWRkaW5nIDogdHlwZSB4IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHogLT4gYSkgcGFkZGluZyAtPiAoeiAtPiBzdHJpbmcpIC0+IHggPVxuICBmdW4gayBhY2MgZm10IHBhZCB0cmFucyAtPiBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IG5ld19hY2MgPSBBY2NfZGF0YV9zdHJpbmcgKGFjYywgdHJhbnMgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHdpZHRoKSAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3aWR0aCAodHJhbnMgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIG5ld19hY2MgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHkgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IEFjY19kYXRhX3N0cmluZyAoYWNjLCBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgbmV3X2FjYyBmbXRcblxuKCogRml4IHBhZGRpbmcgYW5kIHByZWNpc2lvbiBmb3IgaW50LCBpbnQzMiwgbmF0aXZlaW50IG9yIGludDY0LiAqKVxuKCogVGFrZSBvbmUgb3IgdHdvIGV4dHJhIGludGVnZXIgYXJndW1lbnRzIGlmIG5lZWRlZC4gKilcbmFuZCBtYWtlX2ludF9wYWRkaW5nX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogYSBiIGMgZCBlIGYgLlxuICAgICgoYiwgYykgYWNjIC0+IGYpIC0+IChiLCBjKSBhY2MgLT5cbiAgICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IChpbnRfY29udiAtPiB6IC0+IHN0cmluZykgLT5cbiAgICBpbnRfY29udiAtPiB4ID1cbiAgZnVuIGsgYWNjIGZtdCBwYWQgcHJlYyB0cmFucyBpY29udiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gdHJhbnMgaWNvbnYgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBOb19wYWRkaW5nLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgZnVuIHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3ICh0cmFucyBpY29udiB4KSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoZml4X2ludF9wcmVjaXNpb24gcCAodHJhbnMgaWNvbnYgeCkpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKHRyYW5zIGljb252IHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB3IHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChmaXhfaW50X3ByZWNpc2lvbiBwICh0cmFucyBpY29udiB4KSkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biB3IHAgeCAtPlxuICAgICAgbGV0IHN0ciA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgKGZpeF9pbnRfcHJlY2lzaW9uIHAgKHRyYW5zIGljb252IHgpKSBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuXG4oKiBDb252ZXJ0IGEgZmxvYXQsIGZpeCBwYWRkaW5nIGFuZCBwcmVjaXNpb24gaWYgbmVlZGVkLiAqKVxuKCogVGFrZSB0aGUgZmxvYXQgYXJndW1lbnQgYW5kIG9uZSBvciB0d28gZXh0cmEgaW50ZWdlciBhcmd1bWVudHMgaWYgbmVlZGVkLiAqKVxuYW5kIG1ha2VfZmxvYXRfcGFkZGluZ19wcmVjaXNpb24gOiB0eXBlIHggeSBhIGIgYyBkIGUgZiAuXG4gICAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeSwgZmxvYXQgLT4gYSkgcHJlY2lzaW9uIC0+IGZsb2F0X2NvbnYgLT4geCA9XG4gIGZ1biBrIGFjYyBmbXQgcGFkIHByZWMgZmNvbnYgLT4gbWF0Y2ggcGFkLCBwcmVjIHdpdGhcbiAgfCBOb19wYWRkaW5nLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTm9fcGFkZGluZywgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgZnVuIHggLT5cbiAgICAgIGxldCBzdHIgPSBjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCBpblxuICAgICAgbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIHN0cikpIGZtdFxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gcCB4IC0+XG4gICAgICBsZXQgc3RyID0gY29udmVydF9mbG9hdCBmY29udiBwIHggaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBMaXRfcGFkZGluZyAocGFkdHksIHcpLCBOb19wcmVjaXNpb24gLT5cbiAgICBmdW4geCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IExpdF9wYWRkaW5nIChwYWR0eSwgdyksIExpdF9wcmVjaXNpb24gcCAtPlxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgTGl0X3BhZGRpbmcgKHBhZHR5LCB3KSwgQXJnX3ByZWNpc2lvbiAtPlxuICAgIGZ1biBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbiAgfCBBcmdfcGFkZGluZyBwYWR0eSwgTm9fcHJlY2lzaW9uIC0+XG4gICAgZnVuIHcgeCAtPlxuICAgICAgbGV0IHN0ciA9IGNvbnZlcnRfZmxvYXQgZmNvbnYgKGRlZmF1bHRfZmxvYXRfcHJlY2lzaW9uIGZjb252KSB4IGluXG4gICAgICBsZXQgc3RyJyA9IGZpeF9wYWRkaW5nIHBhZHR5IHcgc3RyIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyJykpIGZtdFxuICB8IEFyZ19wYWRkaW5nIHBhZHR5LCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBmdW4gdyB4IC0+XG4gICAgICBsZXQgc3RyID0gZml4X3BhZGRpbmcgcGFkdHkgdyAoY29udmVydF9mbG9hdCBmY29udiBwIHgpIGluXG4gICAgICBtYWtlX3ByaW50ZiBrIChBY2NfZGF0YV9zdHJpbmcgKGFjYywgc3RyKSkgZm10XG4gIHwgQXJnX3BhZGRpbmcgcGFkdHksIEFyZ19wcmVjaXNpb24gLT5cbiAgICBmdW4gdyBwIHggLT5cbiAgICAgIGxldCBzdHIgPSBmaXhfcGFkZGluZyBwYWR0eSB3IChjb252ZXJ0X2Zsb2F0IGZjb252IHAgeCkgaW5cbiAgICAgIG1ha2VfcHJpbnRmIGsgKEFjY19kYXRhX3N0cmluZyAoYWNjLCBzdHIpKSBmbXRcbmFuZCBtYWtlX2N1c3RvbSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIC5cbiAgKChiLCBjKSBhY2MgLT4gZikgLT4gKGIsIGMpIGFjYyAtPlxuICAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+XG4gIChhLCB4LCB5KSBjdXN0b21fYXJpdHkgLT4geCAtPiB5ID1cbiAgZnVuIGsgYWNjIHJlc3QgYXJpdHkgZiAtPiBtYXRjaCBhcml0eSB3aXRoXG4gIHwgQ3VzdG9tX3plcm8gLT4gbWFrZV9wcmludGYgayAoQWNjX2RhdGFfc3RyaW5nIChhY2MsIGYpKSByZXN0XG4gIHwgQ3VzdG9tX3N1Y2MgYXJpdHkgLT5cbiAgICBmdW4geCAtPlxuICAgICAgbWFrZV9jdXN0b20gayBhY2MgcmVzdCBhcml0eSAoZiB4KVxuXG5sZXQgY29uc3QgeCBfID0geFxuXG5sZXQgcmVjIG1ha2VfaXByaW50ZiA6IHR5cGUgYSBiIGMgZCBlIGYgc3RhdGUuXG4gIChzdGF0ZSAtPiBmKSAtPiBzdGF0ZSAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10IC0+IGEgPVxuICBmdW4gayBvIGZtdCAtPiBtYXRjaCBmbXQgd2l0aFxuICAgIHwgQ2hhciByZXN0IC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpXG4gICAgfCBDYW1sX2NoYXIgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU3RyaW5nIChBcmdfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdCkpXG4gICAgfCBDYW1sX3N0cmluZyAoTm9fcGFkZGluZywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IENhbWxfc3RyaW5nIChMaXRfcGFkZGluZyBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ2FtbF9zdHJpbmcgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50MzIgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IE5hdGl2ZWludCAoXywgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgICAgICBmbl9vZl9wYWRkaW5nX3ByZWNpc2lvbiBrIG8gcmVzdCBwYWQgcHJlY1xuICAgIHwgSW50NjQgKF8sIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfcGFkZGluZ19wcmVjaXNpb24gayBvIHJlc3QgcGFkIHByZWNcbiAgICB8IEZsb2F0IChfLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgICAgIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIGsgbyByZXN0IHBhZCBwcmVjXG4gICAgfCBCb29sIChOb19wYWRkaW5nLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQm9vbCAoTGl0X3BhZGRpbmcgXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IEJvb2wgKEFyZ19wYWRkaW5nIF8sIHJlc3QpIC0+XG4gICAgICAgIGNvbnN0IChjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KSlcbiAgICB8IEFscGhhIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIHJlc3QpKVxuICAgIHwgVGhldGEgcmVzdCAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgQ3VzdG9tIChhcml0eSwgXywgcmVzdCkgLT5cbiAgICAgICAgZm5fb2ZfY3VzdG9tX2FyaXR5IGsgbyByZXN0IGFyaXR5XG4gICAgfCBSZWFkZXIgXyAtPlxuICAgICAgICAoKiBUaGlzIGNhc2UgaXMgaW1wb3NzaWJsZSwgYnkgdHlwaW5nIG9mIGZvcm1hdHMuICBTZWUgdGhlXG4gICAgICAgICAgIG5vdGUgaW4gdGhlIGNvcnJlc3BvbmRpbmcgY2FzZSBmb3IgbWFrZV9wcmludGYuICopXG4gICAgICAgIGFzc2VydCBmYWxzZVxuICAgIHwgRmx1c2ggcmVzdCAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IFN0cmluZ19saXRlcmFsIChfLCByZXN0KSAtPlxuICAgICAgICBtYWtlX2lwcmludGYgayBvIHJlc3RcbiAgICB8IENoYXJfbGl0ZXJhbCAoXywgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyByZXN0XG4gICAgfCBGb3JtYXRfYXJnIChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgLT5cbiAgICAgICAgZnVuIChGb3JtYXQgKGZtdCwgXykpIC0+XG4gICAgICAgICAgbWFrZV9pcHJpbnRmIGsgb1xuICAgICAgICAgICAgKGNvbmNhdF9mbXQgKHJlY2FzdCBmbXQgZm10dHkpIHJlc3QpXG4gICAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyByZXN0KVxuICAgIHwgU2Nhbl9nZXRfY291bnRlciAoXywgcmVzdCkgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IFNjYW5fbmV4dF9jaGFyIHJlc3QgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gcmVzdClcbiAgICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pZ25vcmVkX3BhcmFtIChmdW4gXyAtPiBrIG8pIChFbmRfb2ZfYWNjKSBpZ24gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19saXQgKF8sIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiBrIG8gcmVzdFxuICAgIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIChmdW4ga29jIC0+IG1ha2VfaXByaW50ZiBrIGtvYyByZXN0KSBvIGZtdCdcbiAgICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgICAgIG1ha2VfaXByaW50ZiAoZnVuIGtvYyAtPiBtYWtlX2lwcmludGYgayBrb2MgcmVzdCkgbyBmbXQnXG4gICAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgICAgIGsgb1xuYW5kIGZuX29mX3BhZGRpbmdfcHJlY2lzaW9uIDpcbiAgdHlwZSB4IHkgeiBhIGIgYyBkIGUgZiBzdGF0ZS5cbiAgKHN0YXRlIC0+IGYpIC0+IHN0YXRlIC0+IChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgKHgsIHkpIHBhZGRpbmcgLT4gKHksIHogLT4gYSkgcHJlY2lzaW9uIC0+IHggPVxuICBmdW4gayBvIGZtdCBwYWQgcHJlYyAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICAgIHwgTm9fcGFkZGluZyAgICwgTm9fcHJlY2lzaW9uICAgIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IE5vX3BhZGRpbmcgICAsIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAobWFrZV9pcHJpbnRmIGsgbyBmbXQpXG4gICAgfCBOb19wYWRkaW5nICAgLCBBcmdfcHJlY2lzaW9uICAgLT5cbiAgICAgICAgY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpXG4gICAgfCBMaXRfcGFkZGluZyBfLCBOb19wcmVjaXNpb24gICAgLT5cbiAgICAgICAgY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KVxuICAgIHwgTGl0X3BhZGRpbmcgXywgTGl0X3ByZWNpc2lvbiBfIC0+XG4gICAgICAgIGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdClcbiAgICB8IExpdF9wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIE5vX3ByZWNpc2lvbiAgICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIExpdF9wcmVjaXNpb24gXyAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKG1ha2VfaXByaW50ZiBrIG8gZm10KSlcbiAgICB8IEFyZ19wYWRkaW5nIF8sIEFyZ19wcmVjaXNpb24gICAtPlxuICAgICAgICBjb25zdCAoY29uc3QgKGNvbnN0IChtYWtlX2lwcmludGYgayBvIGZtdCkpKVxuYW5kIGZuX29mX2N1c3RvbV9hcml0eSA6IHR5cGUgeCB5IGEgYiBjIGQgZSBmIHN0YXRlLlxuICAoc3RhdGUgLT4gZikgLT5cbiAgc3RhdGUgLT4gKGEsIGIsIGMsIGQsIGUsIGYpIGZtdCAtPiAoYSwgeCwgeSkgY3VzdG9tX2FyaXR5IC0+IHkgPVxuICBmdW4gayBvIGZtdCAtPiBmdW5jdGlvblxuICAgIHwgQ3VzdG9tX3plcm8gLT5cbiAgICAgICAgbWFrZV9pcHJpbnRmIGsgbyBmbXRcbiAgICB8IEN1c3RvbV9zdWNjIGFyaXR5IC0+XG4gICAgICAgIGNvbnN0IChmbl9vZl9jdXN0b21fYXJpdHkgayBvIGZtdCBhcml0eSlcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQ29udGludWF0aW9ucyBmb3IgbWFrZV9wcmludGYgKilcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhbiBvdXRwdXRfc3RyZWFtLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBtYWtlX3ByaW50Zi4gKilcbmxldCByZWMgb3V0cHV0X2FjYyBvIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmbXRpbmdfbGl0KSAtPlxuICAgIGxldCBzID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZ19saXQgaW5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQHtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIFwiQFtcIjsgb3V0cHV0X2FjYyBvIGFjYyc7XG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChwLCBzKVxuICB8IEFjY19kYXRhX3N0cmluZyAocCwgcykgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X3N0cmluZyBvIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBvdXRwdXRfYWNjIG8gcDsgb3V0cHV0X2NoYXIgbyBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgbyBwOyBmIG9cbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gb3V0cHV0X2FjYyBvIHA7IGZsdXNoIG9cbiAgfCBBY2NfaW52YWxpZF9hcmcgKHAsIG1zZykgLT4gb3V0cHV0X2FjYyBvIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIFVzZWQgYXMgYSBjb250aW51YXRpb24gb2YgbWFrZV9wcmludGYuICopXG5sZXQgcmVjIGJ1ZnB1dF9hY2MgYiBhY2MgPSBtYXRjaCBhY2Mgd2l0aFxuICB8IEFjY19mb3JtYXR0aW5nX2xpdCAocCwgZm10aW5nX2xpdCkgLT5cbiAgICBsZXQgcyA9IHN0cmluZ19vZl9mb3JtYXR0aW5nX2xpdCBmbXRpbmdfbGl0IGluXG4gICAgYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgcztcbiAgfCBBY2NfZm9ybWF0dGluZ19nZW4gKHAsIEFjY19vcGVuX3RhZyBhY2MnKSAtPlxuICAgIGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIFwiQHtcIjsgYnVmcHV0X2FjYyBiIGFjYyc7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl9ib3ggYWNjJykgLT5cbiAgICBidWZwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkBbXCI7IGJ1ZnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gYnVmcHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgc1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX2NoYXIgYiBjXG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IGJ1ZnB1dF9hY2MgYiBwOyBmIGJcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gYnVmcHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IGJ1ZnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYSBidWZmZXIuICopXG4oKiBEaWZmZXIgZnJvbSBidWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiAlYSBhbmQgJXQuICopXG4oKiBVc2VkIGFzIGEgY29udGludWF0aW9uIG9mIG1ha2VfcHJpbnRmLiAqKVxubGV0IHJlYyBzdHJwdXRfYWNjIGIgYWNjID0gbWF0Y2ggYWNjIHdpdGhcbiAgfCBBY2NfZm9ybWF0dGluZ19saXQgKHAsIGZtdGluZ19saXQpIC0+XG4gICAgbGV0IHMgPSBzdHJpbmdfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHM7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfZ2VuIChwLCBBY2Nfb3Blbl90YWcgYWNjJykgLT5cbiAgICBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiBcIkB7XCI7IHN0cnB1dF9hY2MgYiBhY2MnO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBiIHA7IEJ1ZmZlci5hZGRfc3RyaW5nIGIgXCJAW1wiOyBzdHJwdXRfYWNjIGIgYWNjJztcbiAgfCBBY2Nfc3RyaW5nX2xpdGVyYWwgKHAsIHMpXG4gIHwgQWNjX2RhdGFfc3RyaW5nIChwLCBzKSAgIC0+IHN0cnB1dF9hY2MgYiBwOyBCdWZmZXIuYWRkX3N0cmluZyBiIHNcbiAgfCBBY2NfY2hhcl9saXRlcmFsIChwLCBjKVxuICB8IEFjY19kYXRhX2NoYXIgKHAsIGMpICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICB8IEFjY19kZWxheSAocCwgZikgICAgICAgICAtPiBzdHJwdXRfYWNjIGIgcDsgQnVmZmVyLmFkZF9zdHJpbmcgYiAoZiAoKSlcbiAgfCBBY2NfZmx1c2ggcCAgICAgICAgICAgICAgLT4gc3RycHV0X2FjYyBiIHA7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgYiBwOyBpbnZhbGlkX2FyZyBtc2c7XG4gIHwgRW5kX29mX2FjYyAgICAgICAgICAgICAgIC0+ICgpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEVycm9yIG1hbmFnZW1lbnQgKilcblxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBwcmV0dHktcHJpbnRlZCBlcnJvciBtZXNzYWdlLiAqKVxubGV0IGZhaWx3aXRoX21lc3NhZ2UgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IGsgYWNjID0gc3RycHV0X2FjYyBidWYgYWNjOyBmYWlsd2l0aCAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdHRpbmcgdG9vbHMgKilcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhbiBvcGVuIGJsb2NrIGRlc2NyaXB0aW9uIChpbmRlbnQsIGJsb2NrX3R5cGUpICopXG5sZXQgb3Blbl9ib3hfb2Zfc3RyaW5nIHN0ciA9XG4gIGlmIHN0ciA9IFwiXCIgdGhlbiAoMCwgUHBfYm94KSBlbHNlXG4gICAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggc3RyIGluXG4gICAgbGV0IGludmFsaWRfYm94ICgpID0gZmFpbHdpdGhfbWVzc2FnZSBcImludmFsaWQgYm94IGRlc2NyaXB0aW9uICVTXCIgc3RyIGluXG4gICAgbGV0IHJlYyBwYXJzZV9zcGFjZXMgaSA9XG4gICAgICBpZiBpID0gbGVuIHRoZW4gaSBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIC0+IHBhcnNlX3NwYWNlcyAoaSArIDEpXG4gICAgICAgIHwgXyAtPiBpXG4gICAgYW5kIHBhcnNlX2x3b3JkIGkgaiA9XG4gICAgICBpZiBqID0gbGVuIHRoZW4gaiBlbHNlXG4gICAgICAgIG1hdGNoIHN0ci5bal0gd2l0aFxuICAgICAgICB8ICdhJyAuLiAneicgLT4gcGFyc2VfbHdvcmQgaSAoaiArIDEpXG4gICAgICAgIHwgXyAtPiBqXG4gICAgYW5kIHBhcnNlX2ludCBpIGogPVxuICAgICAgaWYgaiA9IGxlbiB0aGVuIGogZWxzZVxuICAgICAgICBtYXRjaCBzdHIuW2pdIHdpdGhcbiAgICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IHBhcnNlX2ludCBpIChqICsgMSlcbiAgICAgICAgfCBfIC0+IGogaW5cbiAgICBsZXQgd3N0YXJ0ID0gcGFyc2Vfc3BhY2VzIDAgaW5cbiAgICBsZXQgd2VuZCA9IHBhcnNlX2x3b3JkIHdzdGFydCB3c3RhcnQgaW5cbiAgICBsZXQgYm94X25hbWUgPSBTdHJpbmcuc3ViIHN0ciB3c3RhcnQgKHdlbmQgLSB3c3RhcnQpIGluXG4gICAgbGV0IG5zdGFydCA9IHBhcnNlX3NwYWNlcyB3ZW5kIGluXG4gICAgbGV0IG5lbmQgPSBwYXJzZV9pbnQgbnN0YXJ0IG5zdGFydCBpblxuICAgIGxldCBpbmRlbnQgPVxuICAgICAgaWYgbnN0YXJ0ID0gbmVuZCB0aGVuIDAgZWxzZVxuICAgICAgICB0cnkgaW50X29mX3N0cmluZyAoU3RyaW5nLnN1YiBzdHIgbnN0YXJ0IChuZW5kIC0gbnN0YXJ0KSlcbiAgICAgICAgd2l0aCBGYWlsdXJlIF8gLT4gaW52YWxpZF9ib3ggKCkgaW5cbiAgICBsZXQgZXhwX2VuZCA9IHBhcnNlX3NwYWNlcyBuZW5kIGluXG4gICAgaWYgZXhwX2VuZCA8PiBsZW4gdGhlbiBpbnZhbGlkX2JveCAoKTtcbiAgICBsZXQgYm94X3R5cGUgPSBtYXRjaCBib3hfbmFtZSB3aXRoXG4gICAgICB8IFwiXCIgfCBcImJcIiAtPiBQcF9ib3hcbiAgICAgIHwgXCJoXCIgICAgICAtPiBQcF9oYm94XG4gICAgICB8IFwidlwiICAgICAgLT4gUHBfdmJveFxuICAgICAgfCBcImh2XCIgICAgIC0+IFBwX2h2Ym94XG4gICAgICB8IFwiaG92XCIgICAgLT4gUHBfaG92Ym94XG4gICAgICB8IF8gICAgICAgIC0+IGludmFsaWRfYm94ICgpIGluXG4gICAgKGluZGVudCwgYm94X3R5cGUpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogUGFyc2luZyB0b29scyAqKVxuXG4oKiBDcmVhdGUgYSBwYWRkaW5nX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcgYW5kIGEgZm9ybWF0LiAqKVxuKCogQ29weSB0aGUgcGFkZGluZyB0byBkaXNqb2luIHRoZSB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnQgYW5kIHJlc3VsdC4gKilcbmxldCBtYWtlX3BhZGRpbmdfZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoXywgXywgXywgXywgXywgXykgZm10IC0+XG4gICAgICAoXywgXywgXywgXywgXykgcGFkZGluZ19mbXRfZWJiID1cbmZ1biBwYWQgZm10IC0+IG1hdGNoIHBhZCB3aXRoXG4gIHwgTm9fcGFkZGluZyAgICAgICAgIC0+IFBhZGRpbmdfZm10X0VCQiAoTm9fcGFkZGluZywgZm10KVxuICB8IExpdF9wYWRkaW5nIChzLCB3KSAtPiBQYWRkaW5nX2ZtdF9FQkIgKExpdF9wYWRkaW5nIChzLCB3KSwgZm10KVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRkaW5nX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIGZtdClcblxuKCogQ3JlYXRlIGEgcHJlY2lzaW9uX2ZtdF9lYmIgZnJvbSBhIHByZWNpc2lvbiBhbmQgYSBmb3JtYXQuICopXG4oKiBDb3B5IHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0aGUgdHlwZSBwYXJhbWV0ZXJzIG9mIGFyZ3VtZW50IGFuZCByZXN1bHQuICopXG5sZXQgbWFrZV9wcmVjaXNpb25fZm10X2ViYiA6IHR5cGUgeCB5IC5cbiAgICAoeCwgeSkgcHJlY2lzaW9uIC0+IChfLCBfLCBfLCBfLCBfLCBfKSBmbXQgLT5cbiAgICAgIChfLCBfLCBfLCBfLCBfKSBwcmVjaXNpb25fZm10X2ViYiA9XG5mdW4gcHJlYyBmbXQgLT4gbWF0Y2ggcHJlYyB3aXRoXG4gIHwgTm9fcHJlY2lzaW9uICAgIC0+IFByZWNpc2lvbl9mbXRfRUJCIChOb19wcmVjaXNpb24sIGZtdClcbiAgfCBMaXRfcHJlY2lzaW9uIHAgLT4gUHJlY2lzaW9uX2ZtdF9FQkIgKExpdF9wcmVjaXNpb24gcCwgZm10KVxuICB8IEFyZ19wcmVjaXNpb24gICAtPiBQcmVjaXNpb25fZm10X0VCQiAoQXJnX3ByZWNpc2lvbiwgZm10KVxuXG4oKiBDcmVhdGUgYSBwYWRwcmVjX2ZtdF9lYmIgZnJvbSBhIHBhZGRpbmcsIGEgcHJlY2lzaW9uIGFuZCBhIGZvcm1hdC4gKilcbigqIENvcHkgdGhlIHBhZGRpbmcgYW5kIHRoZSBwcmVjaXNpb24gdG8gZGlzam9pbiB0eXBlIHBhcmFtZXRlcnMgb2YgYXJndW1lbnRzXG4gICBhbmQgcmVzdWx0LiAqKVxubGV0IG1ha2VfcGFkcHJlY19mbXRfZWJiIDogdHlwZSB4IHkgeiB0IC5cbiAgICAoeCwgeSkgcGFkZGluZyAtPiAoeiwgdCkgcHJlY2lzaW9uIC0+XG4gICAgKF8sIF8sIF8sIF8sIF8sIF8pIGZtdCAtPlxuICAgIChfLCBfLCBfLCBfLCBfKSBwYWRwcmVjX2ZtdF9lYmIgPVxuZnVuIHBhZCBwcmVjIGZtdCAtPlxuICBsZXQgUHJlY2lzaW9uX2ZtdF9FQkIgKHByZWMsIGZtdCcpID0gbWFrZV9wcmVjaXNpb25fZm10X2ViYiBwcmVjIGZtdCBpblxuICBtYXRjaCBwYWQgd2l0aFxuICB8IE5vX3BhZGRpbmcgICAgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKE5vX3BhZGRpbmcsIHByZWMsIGZtdCcpXG4gIHwgTGl0X3BhZGRpbmcgKHMsIHcpIC0+IFBhZHByZWNfZm10X0VCQiAoTGl0X3BhZGRpbmcgKHMsIHcpLCBwcmVjLCBmbXQnKVxuICB8IEFyZ19wYWRkaW5nIHMgICAgICAtPiBQYWRwcmVjX2ZtdF9FQkIgKEFyZ19wYWRkaW5nIHMsIHByZWMsIGZtdCcpXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBwYXJzaW5nICopXG5cbigqIFBhcnNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIGZvcm1hdCBhbmQgY3JlYXRlIGEgZm10X2ViYi4gKilcbigqIFJhaXNlIFtGYWlsdXJlXSBpbiBjYXNlIG9mIGludmFsaWQgZm9ybWF0LiAqKVxubGV0IGZtdF9lYmJfb2Zfc3RyaW5nID9sZWdhY3lfYmVoYXZpb3Igc3RyID1cbiAgKCogUGFyYW1ldGVycyBuYW1pbmcgY29udmVudGlvbjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gbGl0X3N0YXJ0OiBzdGFydCBvZiB0aGUgbGl0ZXJhbCBzZXF1ZW5jZS4gICAgICAgICAgICAgICAgICAgICopXG4gICgqICAgLSBzdHJfaW5kOiBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcuICAgICAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIGVuZF9pbmQ6IGVuZCBvZiB0aGUgY3VycmVudCAoc3ViLSlmb3JtYXQuICAgICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gcGN0X2luZDogaW5kZXggb2YgdGhlICclJyBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICopXG4gICgqICAgLSB6ZXJvOiAgaXMgdGhlICcwJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIG1pbnVzOiBpcyB0aGUgJy0nIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gcGx1czogIGlzIHRoZSAnKycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBoYXNoOiAgaXMgdGhlICcjJyBmbGFnIGRlZmluZWQgaW4gdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgKilcbiAgKCogICAtIHNwYWNlOiBpcyB0aGUgJyAnIGZsYWcgZGVmaW5lZCBpbiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAqKVxuICAoKiAgIC0gaWduOiAgIGlzIHRoZSAnXycgZmxhZyBkZWZpbmVkIGluIHRoZSBjdXJyZW50IG1pY3JvLWZvcm1hdC4gICopXG4gICgqICAgLSBwYWQ6IHBhZGRpbmcgb2YgdGhlIGN1cnJlbnQgbWljcm8tZm9ybWF0LiAgICAgICAgICAgICAgICAgICAgKilcbiAgKCogICAtIHByZWM6IHByZWNpc2lvbiBvZiB0aGUgY3VycmVudCBtaWNyby1mb3JtYXQuICAgICAgICAgICAgICAgICAqKVxuICAoKiAgIC0gc3ltYjogY2hhciByZXByZXNlbnRpbmcgdGhlIGNvbnZlcnNpb24gKCdjJywgJ3MnLCAnZCcsIC4uLikuICopXG4gICgqICAgLSBjaGFyX3NldDogc2V0IG9mIGNoYXJhY3RlcnMgYXMgYml0bWFwIChzZWUgc2NhbmYgJVsuLi5dKS4gICAgKilcblxuICBsZXQgbGVnYWN5X2JlaGF2aW9yID0gbWF0Y2ggbGVnYWN5X2JlaGF2aW9yIHdpdGhcbiAgICB8IFNvbWUgZmxhZyAtPiBmbGFnXG4gICAgfCBOb25lIC0+IHRydWVcbiAgKCogIFdoZW4gdGhpcyBmbGFnIGlzIGVuYWJsZWQsIHRoZSBmb3JtYXQgcGFyc2VyIHRyaWVzIHRvIGJlaGF2ZSBhc1xuICAgICAgdGhlIDw0LjAyIGltcGxlbWVudGF0aW9ucywgaW4gcGFydGljdWxhciBpdCBpZ25vcmVzIG1vc3QgYmVuaW5lXG4gICAgICBub25zZW5zaWNhbCBmb3JtYXQuIFdoZW4gdGhlIGZsYWcgaXMgZGlzYWJsZWQsIGl0IHdpbGwgcmVqZWN0IGFueVxuICAgICAgZm9ybWF0IHRoYXQgaXMgbm90IGFjY2VwdGVkIGJ5IHRoZSBzcGVjaWZpY2F0aW9uLlxuXG4gICAgICBBIHR5cGljYWwgZXhhbXBsZSB3b3VsZCBiZSBcIiUrIGRcIjogc3BlY2lmeWluZyBib3RoICcrJyAoaWYgdGhlXG4gICAgICBudW1iZXIgaXMgcG9zaXRpdmUsIHBhZCB3aXRoIGEgJysnIHRvIGdldCB0aGUgc2FtZSB3aWR0aCBhc1xuICAgICAgbmVnYXRpdmUgbnVtYmVycykgYW5kICcgJyAoaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgcGFkIHdpdGhcbiAgICAgIGEgc3BhY2UpIGRvZXMgbm90IG1ha2Ugc2Vuc2UsIGJ1dCB0aGUgbGVnYWN5ICg8IDQuMDIpXG4gICAgICBpbXBsZW1lbnRhdGlvbiB3YXMgaGFwcHkgdG8ganVzdCBpZ25vcmUgdGhlIHNwYWNlLlxuICAqKVxuICBpblxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZS4gKilcbiAgbGV0IGludmFsaWRfZm9ybWF0X21lc3NhZ2Ugc3RyX2luZCBtc2cgPVxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsICVzXCJcbiAgICAgIHN0ciBzdHJfaW5kIG1zZ1xuICBpblxuXG4gICgqIFVzZWQgd2hlbiB0aGUgZW5kIG9mIHRoZSBmb3JtYXQgKG9yIHRoZSBjdXJyZW50IHN1Yi1mb3JtYXQpIHdhcyBlbmNvdW50ZXJlZFxuICAgICAgdW5leHBlY3RlZGx5LiAqKVxuICBsZXQgdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQgPVxuICAgIGludmFsaWRfZm9ybWF0X21lc3NhZ2UgZW5kX2luZFxuICAgICAgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmb3JtYXRcIlxuICBpblxuXG4gICgqIFVzZWQgZm9yICUwYzogbm8gb3RoZXIgd2lkdGhzIGFyZSBpbXBsZW1lbnRlZCAqKVxuICBsZXQgaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZCA9XG4gICAgaW52YWxpZF9mb3JtYXRfbWVzc2FnZSBzdHJfaW5kXG4gICAgICBcIm5vbi16ZXJvIHdpZHRocyBhcmUgdW5zdXBwb3J0ZWQgZm9yICVjIGNvbnZlcnNpb25zXCJcbiAgaW5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIG9wdGlvbiBkZXBlbmRlbmN5XG4gICAgIHByb2JsZW0uICopXG4gIGxldCBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IHN0cl9pbmQgYyBzID1cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAnJWMnIHdpdGhvdXQgJXNcIlxuICAgICAgc3RyIHN0cl9pbmQgYyBzXG4gIGluXG5cbiAgKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYSBmcmllbmRseSBlcnJvciBtZXNzYWdlIGFib3V0IGFuIHVuZXhwZWN0ZWRcbiAgICAgY2hhcmFjdGVyLiAqKVxuICBsZXQgZXhwZWN0ZWRfY2hhcmFjdGVyIHN0cl9pbmQgZXhwZWN0ZWQgcmVhZCA9XG4gICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICBcImludmFsaWQgZm9ybWF0ICVTOiBhdCBjaGFyYWN0ZXIgbnVtYmVyICVkLCAlcyBleHBlY3RlZCwgcmVhZCAlQ1wiXG4gICAgICBzdHIgc3RyX2luZCBleHBlY3RlZCByZWFkXG4gIGluXG5cbiAgKCogUGFyc2UgdGhlIHN0cmluZyBmcm9tIGJlZ19pbmQgKGluY2x1ZGVkKSB0byBlbmRfaW5kIChleGNsdWRlZCkuICopXG4gIGxldCByZWMgcGFyc2UgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gYmVnX2luZCBlbmRfaW5kIC0+IHBhcnNlX2xpdGVyYWwgYmVnX2luZCBiZWdfaW5kIGVuZF9pbmRcblxuICAoKiBSZWFkIGxpdGVyYWwgY2hhcmFjdGVycyB1cCB0byAnJScgb3IgJ0AnIHNwZWNpYWwgY2hhcmFjdGVycy4gKilcbiAgYW5kIHBhcnNlX2xpdGVyYWwgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGVuZF9pbmQgLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIEVuZF9vZl9mb3JtYXQgZWxzZVxuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICclJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlX2Zvcm1hdCBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgICAgYWRkX2xpdGVyYWwgbGl0X3N0YXJ0IHN0cl9pbmQgZm10X3Jlc3RcbiAgICAgIHwgJ0AnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2VfYWZ0ZXJfYXQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIGFkZF9saXRlcmFsIGxpdF9zdGFydCBzdHJfaW5kIGZtdF9yZXN0XG4gICAgICB8IF8gLT5cbiAgICAgICAgcGFyc2VfbGl0ZXJhbCBsaXRfc3RhcnQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG5cbiAgKCogUGFyc2UgYSBmb3JtYXQgYWZ0ZXIgJyUnICopXG4gIGFuZCBwYXJzZV9mb3JtYXQgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBlbmRfaW5kIC0+IHBhcnNlX2lnbiBwY3RfaW5kIChwY3RfaW5kICsgMSkgZW5kX2luZFxuXG4gIGFuZCBwYXJzZV9pZ24gOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJ18nIC0+IHBhcnNlX2ZsYWdzIHBjdF9pbmQgKHN0cl9pbmQrMSkgZW5kX2luZCB0cnVlXG4gICAgICB8IF8gLT4gcGFyc2VfZmxhZ3MgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgZmFsc2VcblxuICBhbmQgcGFyc2VfZmxhZ3MgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmJcbiAgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgaWduIC0+XG4gICAgbGV0IHplcm8gPSByZWYgZmFsc2UgYW5kIG1pbnVzID0gcmVmIGZhbHNlXG4gICAgYW5kIHBsdXMgPSByZWYgZmFsc2UgYW5kIHNwYWNlID0gcmVmIGZhbHNlXG4gICAgYW5kIGhhc2ggPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgc2V0X2ZsYWcgc3RyX2luZCBmbGFnID1cbiAgICAgICgqIGluIGxlZ2FjeSBtb2RlLCBkdXBsaWNhdGUgZmxhZ3MgYXJlIGFjY2VwdGVkICopXG4gICAgICBpZiAhZmxhZyAmJiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIGR1cGxpY2F0ZSBmbGFnICVDXCJcbiAgICAgICAgICBzdHIgc3RyX2luZCBzdHIuW3N0cl9pbmRdO1xuICAgICAgZmxhZyA6PSB0cnVlO1xuICAgIGluXG4gICAgbGV0IHJlYyByZWFkX2ZsYWdzIHN0cl9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnMCcgLT4gc2V0X2ZsYWcgc3RyX2luZCB6ZXJvOyAgcmVhZF9mbGFncyAoc3RyX2luZCArIDEpXG4gICAgICB8ICctJyAtPiBzZXRfZmxhZyBzdHJfaW5kIG1pbnVzOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJysnIC0+IHNldF9mbGFnIHN0cl9pbmQgcGx1czsgIHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCAnIycgLT4gc2V0X2ZsYWcgc3RyX2luZCBoYXNoOyByZWFkX2ZsYWdzIChzdHJfaW5kICsgMSlcbiAgICAgIHwgJyAnIC0+IHNldF9mbGFnIHN0cl9pbmQgc3BhY2U7IHJlYWRfZmxhZ3MgKHN0cl9pbmQgKyAxKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHBhcnNlX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmRcbiAgICAgICAgICAhemVybyAhbWludXMgIXBsdXMgIWhhc2ggIXNwYWNlIGlnblxuICAgICAgZW5kXG4gICAgaW5cbiAgICByZWFkX2ZsYWdzIHN0cl9pbmRcblxuICAoKiBUcnkgdG8gcmVhZCBhIGRpZ2l0YWwgb3IgYSAnKicgcGFkZGluZy4gKilcbiAgYW5kIHBhcnNlX3BhZGRpbmcgOiB0eXBlIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IGludCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCB6ZXJvIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ24gLT5cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIGxldCBwYWR0eSA9IG1hdGNoIHplcm8sIG1pbnVzIHdpdGhcbiAgICAgIHwgZmFsc2UsIGZhbHNlIC0+IFJpZ2h0XG4gICAgICB8IGZhbHNlLCB0cnVlICAtPiBMZWZ0XG4gICAgICB8ICB0cnVlLCBmYWxzZSAtPiBaZXJvc1xuICAgICAgfCAgdHJ1ZSwgdHJ1ZSAgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGVmdFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnLScgXCIwXCIgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT5cbiAgICAgIGxldCBuZXdfaW5kLCB3aWR0aCA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgbmV3X2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgKExpdF9wYWRkaW5nIChwYWR0eSwgd2lkdGgpKVxuICAgIHwgJyonIC0+XG4gICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZVxuICAgICAgICBpZ24gKEFyZ19wYWRkaW5nIHBhZHR5KVxuICAgIHwgXyAtPlxuICAgICAgYmVnaW4gbWF0Y2ggcGFkdHkgd2l0aFxuICAgICAgfCBMZWZ0ICAtPlxuICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy0nIFwicGFkZGluZ1wiO1xuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICB8IFplcm9zIC0+XG4gICAgICAgICAoKiBhICcwJyBwYWRkaW5nIGluZGljYXRpb24gbm90IGZvbGxvd2VkIGJ5IGFueXRoaW5nIHNob3VsZFxuICAgICAgICAgICBiZSBpbnRlcnByZXRlZCBhcyBhIFJpZ2h0IHBhZGRpbmcgb2Ygd2lkdGggMC4gVGhpcyBpcyB1c2VkXG4gICAgICAgICAgIGJ5IHNjYW5uaW5nIGNvbnZlcnNpb25zICUwcyBhbmQgJTBjICopXG4gICAgICAgIHBhcnNlX2FmdGVyX3BhZGRpbmcgcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIChMaXRfcGFkZGluZyAoUmlnaHQsIDApKVxuICAgICAgfCBSaWdodCAtPlxuICAgICAgICBwYXJzZV9hZnRlcl9wYWRkaW5nIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIG1pbnVzIHBsdXMgaGFzaCBzcGFjZSBpZ25cbiAgICAgICAgICBOb19wYWRkaW5nXG4gICAgICBlbmRcblxuICAoKiBJcyBwcmVjaXNpb24gZGVmaW5lZD8gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3BhZGRpbmcgOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgfCAnLicgLT5cbiAgICAgIHBhcnNlX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduXG4gICAgICAgIHBhZFxuICAgIHwgc3ltYiAtPlxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBOb19wcmVjaXNpb24gcGFkIHN5bWJcblxuICAoKiBSZWFkIHRoZSBkaWdpdGFsIG9yICcqJyBwcmVjaXNpb24uICopXG4gIGFuZCBwYXJzZV9wcmVjaXNpb24gOiB0eXBlIHggZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPlxuICAgICAgICAoeCwgXykgcGFkZGluZyAtPiAoXywgXywgZSwgZikgZm10X2ViYiA9XG4gIGZ1biBwY3RfaW5kIHN0cl9pbmQgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2xpdGVyYWwgbWludXMgc3RyX2luZCA9XG4gICAgICBsZXQgbmV3X2luZCwgcHJlYyA9IHBhcnNlX3Bvc2l0aXZlIHN0cl9pbmQgZW5kX2luZCAwIGluXG4gICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBuZXdfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICBwYWQgKExpdF9wcmVjaXNpb24gcHJlYykgaW5cbiAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICB8ICcwJyAuLiAnOScgLT4gcGFyc2VfbGl0ZXJhbCBtaW51cyBzdHJfaW5kXG4gICAgfCAoJysnIHwgJy0nKSBhcyBzeW1iIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+XG4gICAgICAoKiBMZWdhY3kgbW9kZSB3b3VsZCBhY2NlcHQgYW5kIGlnbm9yZSAnKycgb3IgJy0nIGJlZm9yZSB0aGVcbiAgICAgICAgIGludGVnZXIgZGVzY3JpYmluZyB0aGUgZGVzaXJlZCBwcmVjaXNpb247IG5vdGUgdGhhdCB0aGlzXG4gICAgICAgICBjYW5ub3QgaGFwcGVuIGZvciBwYWRkaW5nIHdpZHRoLCBhcyAnKycgYW5kICctJyBhbHJlYWR5IGhhdmVcbiAgICAgICAgIGEgc2VtYW50aWNzIHRoZXJlLlxuXG4gICAgICAgICBUaGF0IHNhaWQsIHRoZSBpZGVhIChzdXBwb3J0ZWQgYnkgdGhpcyB0d2VhaykgdGhhdCB3aWR0aCBhbmRcbiAgICAgICAgIHByZWNpc2lvbiBsaXRlcmFscyBhcmUgXCJpbnRlZ2VyIGxpdGVyYWxzXCIgaW4gdGhlIE9DYW1sIHNlbnNlIGlzXG4gICAgICAgICBzdGlsbCBibGF0YW50bHkgd3JvbmcsIGFzIDEyM180NTYgb3IgMHhGRiBhcmUgcmVqZWN0ZWQuICopXG4gICAgICBwYXJzZV9saXRlcmFsIChtaW51cyB8fCBzeW1iID0gJy0nKSAoc3RyX2luZCArIDEpXG4gICAgfCAnKicgLT5cbiAgICAgIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBtaW51cyBwbHVzIGhhc2ggc3BhY2VcbiAgICAgICAgaWduIHBhZCBBcmdfcHJlY2lzaW9uXG4gICAgfCBfIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlblxuICAgICAgICAoKiBub3RlIHRoYXQgbGVnYWN5IGltcGxlbWVudGF0aW9uIGRpZCBub3QgaWdub3JlICcuJyB3aXRob3V0XG4gICAgICAgICAgIGEgbnVtYmVyIChhcyBpdCBkb2VzIGZvciBwYWRkaW5nIGluZGljYXRpb25zKSwgYnV0XG4gICAgICAgICAgIGludGVycHJldHMgaXQgYXMgJy4wJyAqKVxuICAgICAgICBwYXJzZV9hZnRlcl9wcmVjaXNpb24gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnblxuICAgICAgICAgIHBhZCAoTGl0X3ByZWNpc2lvbiAwKVxuICAgICAgZWxzZVxuICAgICAgICBpbnZhbGlkX2Zvcm1hdF93aXRob3V0IChzdHJfaW5kIC0gMSkgJy4nIFwicHJlY2lzaW9uXCJcblxuICAoKiBUcnkgdG8gcmVhZCB0aGUgY29udmVyc2lvbi4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX3ByZWNpc2lvbiA6IHR5cGUgeCB5IHogdCBlIGYgLlxuICAgICAgaW50IC0+IGludCAtPiBpbnQgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+XG4gICAgICAgICh4LCB5KSBwYWRkaW5nIC0+ICh6LCB0KSBwcmVjaXNpb24gLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gcGN0X2luZCBzdHJfaW5kIGVuZF9pbmQgbWludXMgcGx1cyBoYXNoIHNwYWNlIGlnbiBwYWQgcHJlYyAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgbGV0IHBhcnNlX2NvbnYgKHR5cGUgdSkgKHR5cGUgdikgKHBhZHByZWMgOiAodSwgdikgcGFkZGluZykgPVxuICAgICAgcGFyc2VfY29udmVyc2lvbiBwY3RfaW5kIChzdHJfaW5kICsgMSkgZW5kX2luZCBwbHVzIGhhc2ggc3BhY2UgaWduIHBhZFxuICAgICAgICBwcmVjIHBhZHByZWMgc3RyLltzdHJfaW5kXSBpblxuICAgICgqIGluIGxlZ2FjeSBtb2RlLCBzb21lIGZvcm1hdHMgKCVzIGFuZCAlUykgYWNjZXB0IGEgd2VpcmQgbWl4IG9mXG4gICAgICAgcGFkZGluZyBhbmQgcHJlY2lzaW9uLCB3aGljaCBpcyBtZXJnZWQgYXMgYSBzaW5nbGUgcGFkZGluZ1xuICAgICAgIGluZm9ybWF0aW9uLiBGb3IgZXhhbXBsZSwgaW4gJS4xMHMgdGhlIHByZWNpc2lvbiBpcyBpbXBsaWNpdGx5XG4gICAgICAgdW5kZXJzdG9vZCBhcyBwYWRkaW5nICUxMHMsIGJ1dCB0aGUgbGVmdC1wYWRkaW5nIGNvbXBvbmVudCBtYXlcbiAgICAgICBiZSBzcGVjaWZpZWQgZWl0aGVyIGFzIGEgbGVmdCBwYWRkaW5nIG9yIGEgbmVnYXRpdmUgcHJlY2lzaW9uOlxuICAgICAgICUtLjNzIGFuZCAlLi0zcyBhcmUgZXF1aXZhbGVudCB0byAlLTNzICopXG4gICAgbWF0Y2ggcGFkIHdpdGhcbiAgICB8IE5vX3BhZGRpbmcgLT4gKFxuICAgICAgbWF0Y2ggbWludXMsIHByZWMgd2l0aFxuICAgICAgICB8IF8sIE5vX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IE5vX3BhZGRpbmdcbiAgICAgICAgfCBmYWxzZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChSaWdodCwgbikpXG4gICAgICAgIHwgdHJ1ZSwgTGl0X3ByZWNpc2lvbiBuIC0+IHBhcnNlX2NvbnYgKExpdF9wYWRkaW5nIChMZWZ0LCBuKSlcbiAgICAgICAgfCBmYWxzZSwgQXJnX3ByZWNpc2lvbiAtPiBwYXJzZV9jb252IChBcmdfcGFkZGluZyBSaWdodClcbiAgICAgICAgfCB0cnVlLCBBcmdfcHJlY2lzaW9uIC0+IHBhcnNlX2NvbnYgKEFyZ19wYWRkaW5nIExlZnQpXG4gICAgKVxuICAgIHwgcGFkIC0+IHBhcnNlX2NvbnYgcGFkXG5cbiAgKCogQ2FzZSBhbmFseXNpcyBvbiBjb252ZXJzaW9uLiAqKVxuICBhbmQgcGFyc2VfY29udmVyc2lvbiA6IHR5cGUgeCB5IHogdCB1IHYgZSBmIC5cbiAgICAgIGludCAtPiBpbnQgLT4gaW50IC0+IGJvb2wgLT4gYm9vbCAtPiBib29sIC0+IGJvb2wgLT4gKHgsIHkpIHBhZGRpbmcgLT5cbiAgICAgICAgKHosIHQpIHByZWNpc2lvbiAtPiAodSwgdikgcGFkZGluZyAtPiBjaGFyIC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHBjdF9pbmQgc3RyX2luZCBlbmRfaW5kIHBsdXMgaGFzaCBzcGFjZSBpZ24gcGFkIHByZWMgcGFkcHJlYyBzeW1iIC0+XG4gICAgKCogRmxhZ3MgdXNlZCB0byBjaGVjayBvcHRpb24gdXNhZ2VzL2NvbXBhdGliaWxpdGllcy4gKilcbiAgICBsZXQgcGx1c191c2VkICA9IHJlZiBmYWxzZSBhbmQgaGFzaF91c2VkID0gcmVmIGZhbHNlXG4gICAgYW5kIHNwYWNlX3VzZWQgPSByZWYgZmFsc2UgYW5kIGlnbl91c2VkICAgPSByZWYgZmFsc2VcbiAgICBhbmQgcGFkX3VzZWQgICA9IHJlZiBmYWxzZSBhbmQgcHJlY191c2VkICA9IHJlZiBmYWxzZSBpblxuXG4gICAgKCogQWNjZXNzIHRvIG9wdGlvbnMsIHVwZGF0ZSBmbGFncy4gKilcbiAgICBsZXQgZ2V0X3BsdXMgICAgKCkgPSBwbHVzX3VzZWQgIDo9IHRydWU7IHBsdXNcbiAgICBhbmQgZ2V0X2hhc2ggICAoKSA9IGhhc2hfdXNlZCA6PSB0cnVlOyBoYXNoXG4gICAgYW5kIGdldF9zcGFjZSAgICgpID0gc3BhY2VfdXNlZCA6PSB0cnVlOyBzcGFjZVxuICAgIGFuZCBnZXRfaWduICAgICAoKSA9IGlnbl91c2VkICAgOj0gdHJ1ZTsgaWduXG4gICAgYW5kIGdldF9wYWQgICAgICgpID0gcGFkX3VzZWQgICA6PSB0cnVlOyBwYWRcbiAgICBhbmQgZ2V0X3ByZWMgICAgKCkgPSBwcmVjX3VzZWQgIDo9IHRydWU7IHByZWNcbiAgICBhbmQgZ2V0X3BhZHByZWMgKCkgPSBwYWRfdXNlZCAgIDo9IHRydWU7IHBhZHByZWMgaW5cblxuICAgIGxldCBnZXRfaW50X3BhZCAoKSA9XG4gICAgICAoKiAlNS4zZCBpcyBhY2NlcHRlZCBhbmQgbWVhbmluZ2Z1bDogcGFkIHRvIGxlbmd0aCA1IHdpdGhcbiAgICAgICAgIHNwYWNlcywgYnV0IGZpcnN0IHBhZCB3aXRoIHplcm9zIHVwdG8gbGVuZ3RoIDMgKDAtcGFkZGluZ1xuICAgICAgICAgaXMgdGhlIGludGVycHJldGF0aW9uIG9mIFwicHJlY2lzaW9uXCIgZm9yIGludGVnZXIgZm9ybWF0cykuXG5cbiAgICAgICAgICUwNS4zZCBpcyByZWR1bmRhbnQ6IHBhZCB0byBsZW5ndGggNSAqd2l0aCB6ZXJvcyosIGJ1dFxuICAgICAgICAgZmlyc3QgcGFkIHdpdGggemVyb3MuLi4gVG8gYWRkIGluc3VsdCB0byB0aGUgaW5qdXJ5LCB0aGVcbiAgICAgICAgIGxlZ2FjeSBpbXBsZW1lbnRhdGlvbiBpZ25vcmVzIHRoZSAwLXBhZGRpbmcgaW5kaWNhdGlvbiBhbmRcbiAgICAgICAgIGRvZXMgdGhlIDUgcGFkZGluZyB3aXRoIHNwYWNlcyBpbnN0ZWFkLiBXZSByZXVzZSB0aGlzXG4gICAgICAgICBpbnRlcnByZXRhdGlvbiBmb3IgY29tcGF0aWJpbGl0eSwgYnV0IHN0YXRpY2FsbHkgcmVqZWN0IHRoaXNcbiAgICAgICAgIGZvcm1hdCB3aGVuIHRoZSBsZWdhY3kgbW9kZSBpcyBkaXNhYmxlZCwgdG8gcHJvdGVjdCBzdHJpY3RcbiAgICAgICAgIHVzZXJzIGZyb20gdGhpcyBjb3JuZXIgY2FzZS4gKilcbiAgICAgICBtYXRjaCBnZXRfcGFkICgpLCBnZXRfcHJlYyAoKSB3aXRoXG4gICAgICAgICB8IHBhZCwgTm9fcHJlY2lzaW9uIC0+IHBhZFxuICAgICAgICAgfCBOb19wYWRkaW5nLCBfICAgICAtPiBOb19wYWRkaW5nXG4gICAgICAgICB8IExpdF9wYWRkaW5nIChaZXJvcywgbiksIF8gLT5cbiAgICAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCBuKVxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcywgXyAtPlxuICAgICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnMCcgXCJwcmVjaXNpb25cIlxuICAgICAgICAgfCBMaXRfcGFkZGluZyBfIGFzIHBhZCwgXyAtPiBwYWRcbiAgICAgICAgIHwgQXJnX3BhZGRpbmcgXyBhcyBwYWQsIF8gLT4gcGFkIGluXG5cbiAgICAoKiBDaGVjayB0aGF0IHBhZHR5IDw+IFplcm9zLiAqKVxuICAgIGxldCBjaGVja19ub18wIHN5bWIgKHR5cGUgYSkgKHR5cGUgYikgKHBhZCA6IChhLCBiKSBwYWRkaW5nKSA9XG4gICAgICBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IHBhZFxuICAgICAgfCBMaXRfcGFkZGluZyAoKExlZnQgfCBSaWdodCksIF8pIC0+IHBhZFxuICAgICAgfCBBcmdfcGFkZGluZyAoTGVmdCB8IFJpZ2h0KSAtPiBwYWRcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFplcm9zLCB3aWR0aCkgLT5cbiAgICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aClcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIjBcIlxuICAgICAgfCBBcmdfcGFkZGluZyBaZXJvcyAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBBcmdfcGFkZGluZyBSaWdodFxuICAgICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiMFwiXG4gICAgaW5cblxuICAgICgqIEdldCBwYWRkaW5nIGFzIGEgcGFkX29wdGlvbiAoc2VlIFwiJV9cIiwgXCIle1wiLCBcIiUoXCIgYW5kIFwiJVtcIikuXG4gICAgICAgKG5vIG5lZWQgZm9yIGxlZ2FjeSBtb2RlIHR3ZWFraW5nLCB0aG9zZSB3ZXJlIHJlamVjdGVkIGJ5IHRoZVxuICAgICAgIGxlZ2FjeSBwYXJzZXIgYXMgd2VsbCkgKilcbiAgICBsZXQgb3B0X29mX3BhZCBjICh0eXBlIGEpICh0eXBlIGIpIChwYWQgOiAoYSwgYikgcGFkZGluZykgPSBtYXRjaCBwYWQgd2l0aFxuICAgICAgfCBOb19wYWRkaW5nIC0+IE5vbmVcbiAgICAgIHwgTGl0X3BhZGRpbmcgKFJpZ2h0LCB3aWR0aCkgLT4gU29tZSB3aWR0aFxuICAgICAgfCBMaXRfcGFkZGluZyAoWmVyb3MsIHdpZHRoKSAtPlxuICAgICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiBTb21lIHdpZHRoXG4gICAgICAgIGVsc2UgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInMCdcIlxuICAgICAgfCBMaXRfcGFkZGluZyAoTGVmdCwgd2lkdGgpIC0+XG4gICAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuIFNvbWUgd2lkdGhcbiAgICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgYyBcIictJ1wiXG4gICAgICB8IEFyZ19wYWRkaW5nIF8gLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIGMgXCInKidcIlxuICAgIGluXG4gICAgbGV0IGdldF9wYWRfb3B0IGMgPSBvcHRfb2ZfcGFkIGMgKGdldF9wYWQgKCkpIGluXG4gICAgbGV0IGdldF9wYWRwcmVjX29wdCBjID0gb3B0X29mX3BhZCBjIChnZXRfcGFkcHJlYyAoKSkgaW5cblxuICAgICgqIEdldCBwcmVjaXNpb24gYXMgYSBwcmVjX29wdGlvbiAoc2VlIFwiJV9mXCIpLlxuICAgICAgIChubyBuZWVkIGZvciBsZWdhY3kgbW9kZSB0d2Vha2luZywgdGhvc2Ugd2VyZSByZWplY3RlZCBieSB0aGVcbiAgICAgICBsZWdhY3kgcGFyc2VyIGFzIHdlbGwpICopXG4gICAgbGV0IGdldF9wcmVjX29wdCAoKSA9IG1hdGNoIGdldF9wcmVjICgpIHdpdGhcbiAgICAgIHwgTm9fcHJlY2lzaW9uICAgICAgIC0+IE5vbmVcbiAgICAgIHwgTGl0X3ByZWNpc2lvbiBuZGVjIC0+IFNvbWUgbmRlY1xuICAgICAgfCBBcmdfcHJlY2lzaW9uICAgICAgLT4gaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kICdfJyBcIicqJ1wiXG4gICAgaW5cblxuICAgIGxldCBmbXRfcmVzdWx0ID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnLCcgLT5cbiAgICAgIHBhcnNlIHN0cl9pbmQgZW5kX2luZFxuICAgIHwgJ2MnIC0+XG4gICAgICBsZXQgY2hhcl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlYyAqKVxuICAgICAgICBpZiBnZXRfaWduICgpXG4gICAgICAgIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jaGFyLCBmbXRfcmVzdCkpXG4gICAgICAgIGVsc2UgRm10X0VCQiAoQ2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgc2Nhbl9mb3JtYXQgZm10X3Jlc3QgPSAoKiAlMGMgKilcbiAgICAgICAgaWYgZ2V0X2lnbiAoKVxuICAgICAgICB0aGVuIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKElnbm9yZWRfc2Nhbl9uZXh0X2NoYXIsIGZtdF9yZXN0KSlcbiAgICAgICAgZWxzZSBGbXRfRUJCIChTY2FuX25leHRfY2hhciBmbXRfcmVzdClcbiAgICAgIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgYmVnaW4gbWF0Y2ggZ2V0X3BhZF9vcHQgJ2MnIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGNoYXJfZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSAwIC0+IHNjYW5fZm9ybWF0IGZtdF9yZXN0XG4gICAgICAgIHwgU29tZSBfbiAtPlxuICAgICAgICAgICBpZiBub3QgbGVnYWN5X2JlaGF2aW9yXG4gICAgICAgICAgIHRoZW4gaW52YWxpZF9ub25udWxsX2NoYXJfd2lkdGggc3RyX2luZFxuICAgICAgICAgICBlbHNlICgqIGxlZ2FjeSBpZ25vcmVzICVjIHdpZHRocyAqKSBjaGFyX2Zvcm1hdCBmbXRfcmVzdFxuICAgICAgZW5kXG4gICAgfCAnQycgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW4gRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoSWdub3JlZF9jYW1sX2NoYXIsZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChDYW1sX2NoYXIgZm10X3Jlc3QpXG4gICAgfCAncycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc3RyaW5nIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChTdHJpbmcgKHBhZCcsIGZtdF9yZXN0JykpXG4gICAgfCAnUycgLT5cbiAgICAgIGxldCBwYWQgPSBjaGVja19ub18wIHN5bWIgKGdldF9wYWRwcmVjICgpKSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfY2FtbF9zdHJpbmcgKGdldF9wYWRwcmVjX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZGRpbmdfZm10X0VCQiAocGFkJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRkaW5nX2ZtdF9lYmIgcGFkIGZtdF9yZXN0IGluXG4gICAgICAgIEZtdF9FQkIgKENhbWxfc3RyaW5nIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2QnIHwgJ2knIHwgJ3gnIHwgJ1gnIHwgJ28nIHwgJ3UnIC0+XG4gICAgICBsZXQgaWNvbnYgPSBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCAoZ2V0X3BsdXMgKCkpIChnZXRfaGFzaCAoKSlcbiAgICAgICAgKGdldF9zcGFjZSAoKSkgc3ltYiBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50IChpY29udiwgZ2V0X3BhZF9vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRwcmVjX2ZtdF9FQkIgKHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpID1cbiAgICAgICAgICBtYWtlX3BhZHByZWNfZm10X2ViYiAoZ2V0X2ludF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoSW50IChpY29udiwgcGFkJywgcHJlYycsIGZtdF9yZXN0JykpXG4gICAgfCAnTicgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IFRva2VuX2NvdW50ZXIgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfc2Nhbl9nZXRfY291bnRlciBjb3VudGVyIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgZm10X3Jlc3QpKVxuICAgIHwgJ2wnIHwgJ24nIHwgJ0wnIHdoZW4gc3RyX2luZD1lbmRfaW5kIHx8IG5vdCAoaXNfaW50X2Jhc2Ugc3RyLltzdHJfaW5kXSkgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBsZXQgY291bnRlciA9IGNvdW50ZXJfb2ZfY2hhciBzeW1iIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fZ2V0X2NvdW50ZXIgY291bnRlciBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIGZtdF9yZXN0KSlcbiAgICB8ICdsJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50MzIgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQzMiAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ24nIC0+XG4gICAgICBsZXQgaWNvbnYgPVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgKHN0cl9pbmQgKyAxKSAoZ2V0X3BsdXMgKCkpXG4gICAgICAgICAgKGdldF9oYXNoICgpKSAoZ2V0X3NwYWNlICgpKSBzdHIuW3N0cl9pbmRdIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9uYXRpdmVpbnQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChOYXRpdmVpbnQgKGljb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdMJyAtPlxuICAgICAgbGV0IGljb252ID1cbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIChzdHJfaW5kICsgMSkgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpXG4gICAgICAgICAgKGdldF9zcGFjZSAoKSkgc3RyLltzdHJfaW5kXSBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlblxuICAgICAgICBsZXQgaWdub3JlZCA9IElnbm9yZWRfaW50NjQgKGljb252LCBnZXRfcGFkX29wdCAnXycpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IFBhZHByZWNfZm10X0VCQiAocGFkJywgcHJlYycsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkcHJlY19mbXRfZWJiIChnZXRfaW50X3BhZCAoKSkgKGdldF9wcmVjICgpKSBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChJbnQ2NCAoaWNvbnYsIHBhZCcsIHByZWMnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2YnIHwgJ2UnIHwgJ0UnIHwgJ2cnIHwgJ0cnIHwgJ0YnIHwgJ2gnIHwgJ0gnIC0+XG4gICAgICBsZXQgZmNvbnYgPVxuICAgICAgICBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kXG4gICAgICAgICAgKGdldF9wbHVzICgpKSAoZ2V0X2hhc2ggKCkpIChnZXRfc3BhY2UgKCkpIHN5bWIgaW5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zsb2F0IChnZXRfcGFkX29wdCAnXycsIGdldF9wcmVjX29wdCAoKSkgaW5cbiAgICAgICAgRm10X0VCQiAoSWdub3JlZF9wYXJhbSAoaWdub3JlZCwgZm10X3Jlc3QpKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgUGFkcHJlY19mbXRfRUJCIChwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSA9XG4gICAgICAgICAgbWFrZV9wYWRwcmVjX2ZtdF9lYmIgKGdldF9wYWQgKCkpIChnZXRfcHJlYyAoKSkgZm10X3Jlc3QgaW5cbiAgICAgICAgRm10X0VCQiAoRmxvYXQgKGZjb252LCBwYWQnLCBwcmVjJywgZm10X3Jlc3QnKSlcbiAgICB8ICdiJyB8ICdCJyAtPlxuICAgICAgbGV0IHBhZCA9IGNoZWNrX25vXzAgc3ltYiAoZ2V0X3BhZHByZWMgKCkpIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9ib29sIChnZXRfcGFkcHJlY19vcHQgJ18nKSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIGxldCBQYWRkaW5nX2ZtdF9FQkIgKHBhZCcsIGZtdF9yZXN0JykgPVxuICAgICAgICAgIG1ha2VfcGFkZGluZ19mbXRfZWJiIHBhZCBmbXRfcmVzdCBpblxuICAgICAgICBGbXRfRUJCIChCb29sIChwYWQnLCBmbXRfcmVzdCcpKVxuICAgIHwgJ2EnIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgRm10X0VCQiAoQWxwaGEgZm10X3Jlc3QpXG4gICAgfCAndCcgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChUaGV0YSBmbXRfcmVzdClcbiAgICB8ICdyJyAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBzdHJfaW5kIGVuZF9pbmQgaW5cbiAgICAgIGlmIGdldF9pZ24gKCkgdGhlbiBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChJZ25vcmVkX3JlYWRlciwgZm10X3Jlc3QpKVxuICAgICAgZWxzZSBGbXRfRUJCIChSZWFkZXIgZm10X3Jlc3QpXG4gICAgfCAnIScgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGbHVzaCBmbXRfcmVzdClcbiAgICB8ICgnJScgfCAnQCcpIGFzIGMgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChDaGFyX2xpdGVyYWwgKGMsIGZtdF9yZXN0KSlcbiAgICB8ICd7JyAtPlxuICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgJ30nIGluXG4gICAgICBsZXQgRm10X0VCQiBzdWJfZm10ID0gcGFyc2Ugc3RyX2luZCBzdWJfZW5kIGluXG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdWJfZW5kICsgMikgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mbXR0eSA9IGZtdHR5X29mX2ZtdCBzdWJfZm10IGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX2Zvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9hcmcgKGdldF9wYWRfb3B0ICd7Jywgc3ViX2ZtdHR5LCBmbXRfcmVzdCkpXG4gICAgfCAnKCcgLT5cbiAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgc3RyX2luZCBlbmRfaW5kICcpJyBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3ViX2VuZCArIDIpIGVuZF9pbmQgaW5cbiAgICAgIGxldCBGbXRfRUJCIHN1Yl9mbXQgPSBwYXJzZSBzdHJfaW5kIHN1Yl9lbmQgaW5cbiAgICAgIGxldCBzdWJfZm10dHkgPSBmbXR0eV9vZl9mbXQgc3ViX2ZtdCBpblxuICAgICAgaWYgZ2V0X2lnbiAoKSB0aGVuXG4gICAgICAgIGxldCBpZ25vcmVkID0gSWdub3JlZF9mb3JtYXRfc3Vic3QgKGdldF9wYWRfb3B0ICdfJywgc3ViX2ZtdHR5KSBpblxuICAgICAgICBGbXRfRUJCIChJZ25vcmVkX3BhcmFtIChpZ25vcmVkLCBmbXRfcmVzdCkpXG4gICAgICBlbHNlXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdF9zdWJzdCAoZ2V0X3BhZF9vcHQgJygnLCBzdWJfZm10dHksIGZtdF9yZXN0KSlcbiAgICB8ICdbJyAtPlxuICAgICAgbGV0IG5leHRfaW5kLCBjaGFyX3NldCA9IHBhcnNlX2NoYXJfc2V0IHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBpZiBnZXRfaWduICgpIHRoZW5cbiAgICAgICAgbGV0IGlnbm9yZWQgPSBJZ25vcmVkX3NjYW5fY2hhcl9zZXQgKGdldF9wYWRfb3B0ICdfJywgY2hhcl9zZXQpIGluXG4gICAgICAgIEZtdF9FQkIgKElnbm9yZWRfcGFyYW0gKGlnbm9yZWQsIGZtdF9yZXN0KSlcbiAgICAgIGVsc2VcbiAgICAgICAgRm10X0VCQiAoU2Nhbl9jaGFyX3NldCAoZ2V0X3BhZF9vcHQgJ1snLCBjaGFyX3NldCwgZm10X3Jlc3QpKVxuICAgIHwgJy0nIHwgJysnIHwgJyMnIHwgJyAnIHwgJ18nIC0+XG4gICAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGF0IGNoYXJhY3RlciBudW1iZXIgJWQsIFxcXG4gICAgICAgICBmbGFnICVDIGlzIG9ubHkgYWxsb3dlZCBhZnRlciB0aGUgJyUlJywgYmVmb3JlIHBhZGRpbmcgYW5kIHByZWNpc2lvblwiXG4gICAgICAgIHN0ciBwY3RfaW5kIHN5bWJcbiAgICB8IF8gLT5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgIGludmFsaWQgY29udmVyc2lvbiBcXFwiJSUlY1xcXCJcIiBzdHIgKHN0cl9pbmQgLSAxKSBzeW1iXG4gICAgaW5cbiAgICAoKiBDaGVjayBmb3IgdW51c2VkIG9wdGlvbnMsIGFuZCByZWplY3QgdGhlbSBhcyBpbmNvbXBhdGlibGUuXG5cbiAgICAgICBTdWNoIGNoZWNrcyBuZWVkIHRvIGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLCBhcyB0aGUgbGVnYWN5XG4gICAgICAgcGFyc2VyIHNpbGVudGx5IGlnbm9yZWQgaW5jb21wYXRpYmxlIGZsYWdzLiAqKVxuICAgIGlmIG5vdCBsZWdhY3lfYmVoYXZpb3IgdGhlbiBiZWdpblxuICAgIGlmIG5vdCAhcGx1c191c2VkICYmIHBsdXMgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCInKydcIjtcbiAgICBpZiBub3QgIWhhc2hfdXNlZCAmJiBoYXNoIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCI7XG4gICAgaWYgbm90ICFzcGFjZV91c2VkICYmIHNwYWNlIHRoZW5cbiAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyAnXCI7XG4gICAgaWYgbm90ICFwYWRfdXNlZCAgJiYgUGFkZGluZ19FQkIgcGFkIDw+IFBhZGRpbmdfRUJCIE5vX3BhZGRpbmcgdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIHN5bWIgXCJgcGFkZGluZydcIjtcbiAgICBpZiBub3QgIXByZWNfdXNlZCAmJiBQcmVjaXNpb25fRUJCIHByZWMgPD4gUHJlY2lzaW9uX0VCQiBOb19wcmVjaXNpb24gdGhlblxuICAgICAgaW5jb21wYXRpYmxlX2ZsYWcgcGN0X2luZCBzdHJfaW5kIChpZiBpZ24gdGhlbiAnXycgZWxzZSBzeW1iKVxuICAgICAgICBcImBwcmVjaXNpb24nXCI7XG4gICAgaWYgaWduICYmIHBsdXMgdGhlbiBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgJ18nIFwiJysnXCI7XG4gICAgZW5kO1xuICAgICgqIHRoaXMgbGFzdCB0ZXN0IG11c3Qgbm90IGJlIGRpc2FibGVkIGluIGxlZ2FjeSBtb2RlLFxuICAgICAgIGFzIGlnbm9yaW5nIGl0IHdvdWxkIHR5cGljYWxseSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdHlwaW5nXG4gICAgICAgdGhhbiB3aGF0IHRoZSBsZWdhY3kgcGFyc2VyIHVzZWQgKilcbiAgICBpZiBub3QgIWlnbl91c2VkICYmIGlnbiB0aGVuXG4gICAgICBiZWdpbiBtYXRjaCBzeW1iIHdpdGhcbiAgICAgICAgKCogYXJndW1lbnQtbGVzcyBmb3JtYXRzIGNhbiBzYWZlbHkgYmUgaWdub3JlZCBpbiBsZWdhY3kgbW9kZSAqKVxuICAgICAgICB8ICgnQCcgfCAnJScgfCAnIScgfCAnLCcpIHdoZW4gbGVnYWN5X2JlaGF2aW9yIC0+ICgpXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJ18nXCJcbiAgICAgIGVuZDtcbiAgICBmbXRfcmVzdWx0XG5cbiAgKCogUGFyc2UgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiAoYWZ0ZXIgJ0AnKS4gKilcbiAgYW5kIHBhcnNlX2FmdGVyX2F0IDogdHlwZSBlIGYgLiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gRm10X0VCQiAoQ2hhcl9saXRlcmFsICgnQCcsIEVuZF9vZl9mb3JtYXQpKVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnWycgLT5cbiAgICAgICAgcGFyc2VfdGFnIGZhbHNlIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKENsb3NlX2JveCwgZm10X3Jlc3QpKVxuICAgICAgfCAneycgLT5cbiAgICAgICAgcGFyc2VfdGFnIHRydWUgKHN0cl9pbmQgKyAxKSBlbmRfaW5kXG4gICAgICB8ICd9JyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQ2xvc2VfdGFnLCBmbXRfcmVzdCkpXG4gICAgICB8ICcsJyAtPlxuICAgICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIChzdHJfaW5kICsgMSkgZW5kX2luZCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoQnJlYWsgKFwiQCxcIiwgMCwgMCksIGZtdF9yZXN0KSlcbiAgICAgIHwgJyAnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChCcmVhayAoXCJAIFwiLCAxLCAwKSwgZm10X3Jlc3QpKVxuICAgICAgfCAnOycgLT5cbiAgICAgICAgcGFyc2VfZ29vZF9icmVhayAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgJz8nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGRmx1c2gsIGZtdF9yZXN0KSlcbiAgICAgIHwgJ1xcbicgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEZvcmNlX25ld2xpbmUsIGZtdF9yZXN0KSlcbiAgICAgIHwgJy4nIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChGbHVzaF9uZXdsaW5lLCBmbXRfcmVzdCkpXG4gICAgICB8ICc8JyAtPlxuICAgICAgICBwYXJzZV9tYWdpY19zaXplIChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCAnQCcgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKEVzY2FwZWRfYXQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIHdoZW4gc3RyX2luZCArIDEgPCBlbmRfaW5kICYmIHN0ci5bc3RyX2luZCArIDFdID0gJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKHN0cl9pbmQgKyAyKSBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfbGl0IChFc2NhcGVkX3BlcmNlbnQsIGZtdF9yZXN0KSlcbiAgICAgIHwgJyUnIC0+XG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICAgIEZtdF9FQkIgKENoYXJfbGl0ZXJhbCAoJ0AnLCBmbXRfcmVzdCkpXG4gICAgICB8IGMgLT5cbiAgICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSAoc3RyX2luZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgRm10X0VCQiAoRm9ybWF0dGluZ19saXQgKFNjYW5faW5kaWMgYywgZm10X3Jlc3QpKVxuXG4gICgqIFRyeSB0byByZWFkIHRoZSBvcHRpb25hbCA8bmFtZT4gYWZ0ZXIgXCJAe1wiIG9yIFwiQFtcIi4gKilcbiAgYW5kIHBhcnNlX3RhZyA6IHR5cGUgZSBmIC4gYm9vbCAtPiBpbnQgLT4gaW50IC0+IChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGlzX29wZW5fdGFnIHN0cl9pbmQgZW5kX2luZCAtPlxuICAgIHRyeVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgIHwgJzwnIC0+XG4gICAgICAgIGxldCBpbmQgPSBTdHJpbmcuaW5kZXhfZnJvbSBzdHIgKHN0cl9pbmQgKyAxKSAnPicgaW5cbiAgICAgICAgaWYgaW5kID49IGVuZF9pbmQgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdWJfc3RyID0gU3RyaW5nLnN1YiBzdHIgc3RyX2luZCAoaW5kIC0gc3RyX2luZCArIDEpIGluXG4gICAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2UgKGluZCArIDEpIGVuZF9pbmQgaW5cbiAgICAgICAgbGV0IEZtdF9FQkIgc3ViX2ZtdCA9IHBhcnNlIHN0cl9pbmQgKGluZCArIDEpIGluXG4gICAgICAgIGxldCBzdWJfZm9ybWF0ID0gRm9ybWF0IChzdWJfZm10LCBzdWJfc3RyKSBpblxuICAgICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgICAgaWYgaXNfb3Blbl90YWcgdGhlbiBPcGVuX3RhZyBzdWJfZm9ybWF0IGVsc2UgT3Blbl9ib3ggc3ViX2Zvcm1hdCBpblxuICAgICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2dlbiAoZm9ybWF0dGluZywgZm10X3Jlc3QpKVxuICAgICAgfCBfIC0+XG4gICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgbGV0IHN1Yl9mb3JtYXQgPSBGb3JtYXQgKEVuZF9vZl9mb3JtYXQsIFwiXCIpIGluXG4gICAgICBsZXQgZm9ybWF0dGluZyA9XG4gICAgICAgIGlmIGlzX29wZW5fdGFnIHRoZW4gT3Blbl90YWcgc3ViX2Zvcm1hdCBlbHNlIE9wZW5fYm94IHN1Yl9mb3JtYXQgaW5cbiAgICAgIEZtdF9FQkIgKEZvcm1hdHRpbmdfZ2VuIChmb3JtYXR0aW5nLCBmbXRfcmVzdCkpXG5cbiAgKCogVHJ5IHRvIHJlYWQgdGhlIG9wdGlvbmFsIDx3aWR0aCBvZmZzZXQ+IGFmdGVyIFwiQDtcIi4gKilcbiAgYW5kIHBhcnNlX2dvb2RfYnJlYWsgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbGV0IG5leHRfaW5kLCBmb3JtYXR0aW5nX2xpdCA9XG4gICAgICB0cnlcbiAgICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgfHwgc3RyLltzdHJfaW5kXSA8PiAnPCcgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgIGxldCBzdHJfaW5kXzEgPSBwYXJzZV9zcGFjZXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGluXG4gICAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF8xXSB3aXRoXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiAoXG4gICAgICAgICAgbGV0IHN0cl9pbmRfMiwgd2lkdGggPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMSBlbmRfaW5kIGluXG4gICAgICAgICAgICBsZXQgc3RyX2luZF8zID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmRfMiBlbmRfaW5kIGluXG4gICAgICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfM10gd2l0aFxuICAgICAgICAgICAgICB8ICc+JyAtPlxuICAgICAgICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQtMikgKHN0cl9pbmRfMy1zdHJfaW5kKzMpIGluXG4gICAgICAgICAgICAgICAgc3RyX2luZF8zICsgMSwgQnJlYWsgKHMsIHdpZHRoLCAwKVxuICAgICAgICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICAgICAgICBsZXQgc3RyX2luZF80LCBvZmZzZXQgPSBwYXJzZV9pbnRlZ2VyIHN0cl9pbmRfMyBlbmRfaW5kIGluXG4gICAgICAgICAgICAgICAgbGV0IHN0cl9pbmRfNSA9IHBhcnNlX3NwYWNlcyBzdHJfaW5kXzQgZW5kX2luZCBpblxuICAgICAgICAgICAgICAgIGlmIHN0ci5bc3RyX2luZF81XSA8PiAnPicgdGhlbiByYWlzZSBOb3RfZm91bmQ7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciAoc3RyX2luZC0yKSAoc3RyX2luZF81LXN0cl9pbmQrMykgaW5cbiAgICAgICAgICAgICAgICBzdHJfaW5kXzUgKyAxLCBCcmVhayAocywgd2lkdGgsIG9mZnNldClcbiAgICAgICAgICAgICAgfCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgICApXG4gICAgICAgIHwgXyAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHdpdGggTm90X2ZvdW5kIHwgRmFpbHVyZSBfIC0+XG4gICAgICAgIHN0cl9pbmQsIEJyZWFrIChcIkA7XCIsIDEsIDApXG4gICAgaW5cbiAgICBsZXQgRm10X0VCQiBmbXRfcmVzdCA9IHBhcnNlIG5leHRfaW5kIGVuZF9pbmQgaW5cbiAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSB0aGUgc2l6ZSBpbiBhIDxuPi4gKilcbiAgYW5kIHBhcnNlX21hZ2ljX3NpemUgOiB0eXBlIGUgZiAuIGludCAtPiBpbnQgLT4gKF8sIF8sIGUsIGYpIGZtdF9lYmIgPVxuICBmdW4gc3RyX2luZCBlbmRfaW5kIC0+XG4gICAgbWF0Y2hcbiAgICAgIHRyeVxuICAgICAgICBsZXQgc3RyX2luZF8xID0gcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCBpblxuICAgICAgICBtYXRjaCBzdHIuW3N0cl9pbmRfMV0gd2l0aFxuICAgICAgICB8ICcwJyAuLiAnOScgfCAnLScgLT5cbiAgICAgICAgICBsZXQgc3RyX2luZF8yLCBzaXplID0gcGFyc2VfaW50ZWdlciBzdHJfaW5kXzEgZW5kX2luZCBpblxuICAgICAgICAgIGxldCBzdHJfaW5kXzMgPSBwYXJzZV9zcGFjZXMgc3RyX2luZF8yIGVuZF9pbmQgaW5cbiAgICAgICAgICBpZiBzdHIuW3N0cl9pbmRfM10gPD4gJz4nIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICAgICAgICAgIGxldCBzID0gU3RyaW5nLnN1YiBzdHIgKHN0cl9pbmQgLSAyKSAoc3RyX2luZF8zIC0gc3RyX2luZCArIDMpIGluXG4gICAgICAgICAgU29tZSAoc3RyX2luZF8zICsgMSwgTWFnaWNfc2l6ZSAocywgc2l6ZSkpXG4gICAgICAgIHwgXyAtPiBOb25lXG4gICAgICB3aXRoIE5vdF9mb3VuZCB8IEZhaWx1cmUgXyAtPlxuICAgICAgICBOb25lXG4gICAgd2l0aFxuICAgIHwgU29tZSAobmV4dF9pbmQsIGZvcm1hdHRpbmdfbGl0KSAtPlxuICAgICAgbGV0IEZtdF9FQkIgZm10X3Jlc3QgPSBwYXJzZSBuZXh0X2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoZm9ybWF0dGluZ19saXQsIGZtdF9yZXN0KSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBGbXRfRUJCIGZtdF9yZXN0ID0gcGFyc2Ugc3RyX2luZCBlbmRfaW5kIGluXG4gICAgICBGbXRfRUJCIChGb3JtYXR0aW5nX2xpdCAoU2Nhbl9pbmRpYyAnPCcsIGZtdF9yZXN0KSlcblxuICAoKiBQYXJzZSBhbmQgY29uc3RydWN0IGEgY2hhciBzZXQuICopXG4gIGFuZCBwYXJzZV9jaGFyX3NldCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG5cbiAgICBsZXQgY2hhcl9zZXQgPSBjcmVhdGVfY2hhcl9zZXQgKCkgaW5cbiAgICBsZXQgYWRkX2NoYXIgYyA9XG4gICAgICBhZGRfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYztcbiAgICBpblxuICAgIGxldCBhZGRfcmFuZ2UgYyBjJyA9XG4gICAgICBmb3IgaSA9IGludF9vZl9jaGFyIGMgdG8gaW50X29mX2NoYXIgYycgZG9cbiAgICAgICAgYWRkX2luX2NoYXJfc2V0IGNoYXJfc2V0IChjaGFyX29mX2ludCBpKTtcbiAgICAgIGRvbmU7XG4gICAgaW5cblxuICAgIGxldCBmYWlsX3NpbmdsZV9wZXJjZW50IHN0cl9pbmQgPVxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiAnJSUnIGFsb25lIGlzIG5vdCBhY2NlcHRlZCBpbiBjaGFyYWN0ZXIgc2V0cywgXFxcbiAgICAgICAgIHVzZSAlJSUlIGluc3RlYWQgYXQgcG9zaXRpb24gJWQuXCIgc3RyIHN0cl9pbmRcbiAgICBpblxuXG4gICAgKCogUGFyc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGNoYXIgc2V0LiAqKVxuICAgIGxldCByZWMgcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBsZXQgYyA9IHN0ci5bc3RyX2luZF0gaW5cbiAgICAgIHBhcnNlX2NoYXJfc2V0X2FmdGVyX2NoYXIgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAgICgqIFBhcnNlIHRoZSBjb250ZW50IG9mIGEgY2hhciBzZXQgdW50aWwgdGhlIGZpcnN0ICddJy4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfY29udGVudCBzdHJfaW5kIGVuZF9pbmQgPVxuICAgICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgICAgfCAnXScgLT5cbiAgICAgICAgc3RyX2luZCArIDFcbiAgICAgIHwgJy0nIC0+XG4gICAgICAgIGFkZF9jaGFyICctJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICAgIHwgYyAtPlxuICAgICAgICBwYXJzZV9jaGFyX3NldF9hZnRlcl9jaGFyIChzdHJfaW5kICsgMSkgZW5kX2luZCBjXG5cbiAgICAoKiBUZXN0IGZvciByYW5nZSBpbiBjaGFyIHNldC4gKilcbiAgICBhbmQgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBzdHJfaW5kICsgMVxuICAgICAgfCAnLScgLT5cbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfbWludXMgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcbiAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgd2hlbiBjID0gJyUnIC0+XG4gICAgICAgIGFkZF9jaGFyIGMnO1xuICAgICAgICBwYXJzZV9jaGFyX3NldF9jb250ZW50IChzdHJfaW5kICsgMSkgZW5kX2luZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBpZiBjID0gJyUnIHRoZW4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kO1xuICAgICAgICAoKiBub3RlIHRoYXQgJ0AnIGFsb25lIGlzIGFjY2VwdGVkLCBhcyBkb25lIGJ5IHRoZSBsZWdhY3lcbiAgICAgICAgICAgaW1wbGVtZW50YXRpb247IHRoZSBkb2N1bWVudGF0aW9uIHNwZWNpZmljYWxseSByZXF1aXJlcyAlQFxuICAgICAgICAgICBzbyB3ZSBjb3VsZCB3YXJuIG9uIHRoYXQgKilcbiAgICAgICAgYWRkX2NoYXIgYztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfYWZ0ZXJfY2hhciAoc3RyX2luZCArIDEpIGVuZF9pbmQgYydcblxuICAgICgqIE1hbmFnZSByYW5nZSBpbiBjaGFyIHNldCAoZXhjZXB0IGlmIHRoZSAnLScgdGhlIGxhc3QgY2hhciBiZWZvcmUgJ10nKSAqKVxuICAgIGFuZCBwYXJzZV9jaGFyX3NldF9hZnRlcl9taW51cyBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kXSB3aXRoXG4gICAgICB8ICddJyAtPlxuICAgICAgICBhZGRfY2hhciBjO1xuICAgICAgICBhZGRfY2hhciAnLSc7XG4gICAgICAgIHN0cl9pbmQgKyAxXG4gICAgICB8ICclJyAtPlxuICAgICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgYmVnaW4gbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgICAgIHwgKCclJyB8ICdAJykgYXMgYycgLT5cbiAgICAgICAgICAgIGFkZF9yYW5nZSBjIGMnO1xuICAgICAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDIpIGVuZF9pbmRcbiAgICAgICAgICB8IF8gLT4gZmFpbF9zaW5nbGVfcGVyY2VudCBzdHJfaW5kXG4gICAgICAgIGVuZFxuICAgICAgfCBjJyAtPlxuICAgICAgICBhZGRfcmFuZ2UgYyBjJztcbiAgICAgICAgcGFyc2VfY2hhcl9zZXRfY29udGVudCAoc3RyX2luZCArIDEpIGVuZF9pbmRcbiAgICBpblxuICAgIGxldCBzdHJfaW5kLCByZXZlcnNlID1cbiAgICAgIGlmIHN0cl9pbmQgPSBlbmRfaW5kIHRoZW4gdW5leHBlY3RlZF9lbmRfb2ZfZm9ybWF0IGVuZF9pbmQ7XG4gICAgICBtYXRjaCBzdHIuW3N0cl9pbmRdIHdpdGhcbiAgICAgICAgfCAnXicgLT4gc3RyX2luZCArIDEsIHRydWVcbiAgICAgICAgfCBfIC0+IHN0cl9pbmQsIGZhbHNlIGluXG4gICAgbGV0IG5leHRfaW5kID0gcGFyc2VfY2hhcl9zZXRfc3RhcnQgc3RyX2luZCBlbmRfaW5kIGluXG4gICAgbGV0IGNoYXJfc2V0ID0gZnJlZXplX2NoYXJfc2V0IGNoYXJfc2V0IGluXG4gICAgbmV4dF9pbmQsIChpZiByZXZlcnNlIHRoZW4gcmV2X2NoYXJfc2V0IGNoYXJfc2V0IGVsc2UgY2hhcl9zZXQpXG5cbiAgKCogQ29uc3VtZSBhbGwgbmV4dCBzcGFjZXMsIHJhaXNlIGFuIEZhaWx1cmUgaWYgZW5kX2luZCBpcyByZWFjaGVkLiAqKVxuICBhbmQgcGFyc2Vfc3BhY2VzIHN0cl9pbmQgZW5kX2luZCA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICBpZiBzdHIuW3N0cl9pbmRdID0gJyAnIHRoZW4gcGFyc2Vfc3BhY2VzIChzdHJfaW5kICsgMSkgZW5kX2luZCBlbHNlIHN0cl9pbmRcblxuICAoKiBSZWFkIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIHRoZSBzdHJpbmcsIHJhaXNlIGEgRmFpbHVyZSBpZiBlbmRfaW5kIGlzXG4gICAgIHJlYWNoZWQuICopXG4gIGFuZCBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgYWNjID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyBhcyBjIC0+XG4gICAgICBsZXQgbmV3X2FjYyA9IGFjYyAqIDEwICsgKGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCcpIGluXG4gICAgICBpZiBuZXdfYWNjID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW5cbiAgICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICAgIFwiaW52YWxpZCBmb3JtYXQgJVM6IGludGVnZXIgJWQgaXMgZ3JlYXRlciB0aGFuIHRoZSBsaW1pdCAlZFwiXG4gICAgICAgICAgc3RyIG5ld19hY2MgU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgICBlbHNlXG4gICAgICAgIHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCBuZXdfYWNjXG4gICAgfCBfIC0+IHN0cl9pbmQsIGFjY1xuXG4gICgqIFJlYWQgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyIGZyb20gdGhlIHN0cmluZywgcmFpc2UgYSBGYWlsdXJlXG4gICAgIGlmIGVuZF9pbmQgaXMgcmVhY2hlZC4gKilcbiAgYW5kIHBhcnNlX2ludGVnZXIgc3RyX2luZCBlbmRfaW5kID1cbiAgICBpZiBzdHJfaW5kID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJzAnIC4uICc5JyAtPiBwYXJzZV9wb3NpdGl2ZSBzdHJfaW5kIGVuZF9pbmQgMFxuICAgIHwgJy0nIC0+IChcbiAgICAgIGlmIHN0cl9pbmQgKyAxID0gZW5kX2luZCB0aGVuIHVuZXhwZWN0ZWRfZW5kX29mX2Zvcm1hdCBlbmRfaW5kO1xuICAgICAgbWF0Y2ggc3RyLltzdHJfaW5kICsgMV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgIGxldCBuZXh0X2luZCwgbiA9IHBhcnNlX3Bvc2l0aXZlIChzdHJfaW5kICsgMSkgZW5kX2luZCAwIGluXG4gICAgICAgIG5leHRfaW5kLCAtblxuICAgICAgfCBjIC0+XG4gICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiZGlnaXRcIiBjXG4gICAgKVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxuICAoKiBBZGQgYSBsaXRlcmFsIHRvIGEgZm9ybWF0IGZyb20gYSBsaXRlcmFsIGNoYXJhY3RlciBzdWItc2VxdWVuY2UuICopXG4gIGFuZCBhZGRfbGl0ZXJhbCA6IHR5cGUgYSBkIGUgZiAuXG4gICAgICBpbnQgLT4gaW50IC0+IChhLCBfLCBfLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAgIChfLCBfLCBlLCBmKSBmbXRfZWJiID1cbiAgZnVuIGxpdF9zdGFydCBzdHJfaW5kIGZtdCAtPiBtYXRjaCBzdHJfaW5kIC0gbGl0X3N0YXJ0IHdpdGhcbiAgICB8IDAgICAgLT4gRm10X0VCQiBmbXRcbiAgICB8IDEgICAgLT4gRm10X0VCQiAoQ2hhcl9saXRlcmFsIChzdHIuW2xpdF9zdGFydF0sIGZtdCkpXG4gICAgfCBzaXplIC0+IEZtdF9FQkIgKFN0cmluZ19saXRlcmFsIChTdHJpbmcuc3ViIHN0ciBsaXRfc3RhcnQgc2l6ZSwgZm10KSlcblxuICAoKiBTZWFyY2ggdGhlIGVuZCBvZiB0aGUgY3VycmVudCBzdWItZm9ybWF0XG4gICAgIChpLmUuIHRoZSBjb3JyZXNwb25kaW5nIFwiJX1cIiBvciBcIiUpXCIpICopXG4gIGFuZCBzZWFyY2hfc3ViZm9ybWF0X2VuZCBzdHJfaW5kIGVuZF9pbmQgYyA9XG4gICAgaWYgc3RyX2luZCA9IGVuZF9pbmQgdGhlblxuICAgICAgZmFpbHdpdGhfbWVzc2FnZVxuICAgICAgICBcImludmFsaWQgZm9ybWF0ICVTOiB1bmNsb3NlZCBzdWItZm9ybWF0LCBcXFxuICAgICAgICAgZXhwZWN0ZWQgXFxcIiUlJWNcXFwiIGF0IGNoYXJhY3RlciBudW1iZXIgJWRcIiBzdHIgYyBlbmRfaW5kO1xuICAgIG1hdGNoIHN0ci5bc3RyX2luZF0gd2l0aFxuICAgIHwgJyUnIC0+XG4gICAgICBpZiBzdHJfaW5kICsgMSA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgIGlmIHN0ci5bc3RyX2luZCArIDFdID0gYyB0aGVuICgqIEVuZCBvZiBmb3JtYXQgZm91bmQgKikgc3RyX2luZCBlbHNlXG4gICAgICAgIGJlZ2luIG1hdGNoIHN0ci5bc3RyX2luZCArIDFdIHdpdGhcbiAgICAgICAgfCAnXycgLT5cbiAgICAgICAgICAoKiBTZWFyY2ggZm9yIFwiJV8oXCIgb3IgXCIlX3tcIi4gKilcbiAgICAgICAgICBpZiBzdHJfaW5kICsgMiA9IGVuZF9pbmQgdGhlbiB1bmV4cGVjdGVkX2VuZF9vZl9mb3JtYXQgZW5kX2luZDtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBzdHIuW3N0cl9pbmQgKyAyXSB3aXRoXG4gICAgICAgICAgfCAneycgLT5cbiAgICAgICAgICAgIGxldCBzdWJfZW5kID0gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAzKSBlbmRfaW5kICd9JyBpblxuICAgICAgICAgICAgc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN1Yl9lbmQgKyAyKSBlbmRfaW5kIGNcbiAgICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICAgbGV0IHN1Yl9lbmQgPSBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgJyknIGluXG4gICAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICAgIHwgXyAtPiBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDMpIGVuZF9pbmQgY1xuICAgICAgICAgIGVuZFxuICAgICAgICB8ICd7JyAtPlxuICAgICAgICAgICgqICV7Li4uJX0gc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnfScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICcoJyAtPlxuICAgICAgICAgICgqICUoLi4uJSkgc3ViLWZvcm1hdCBmb3VuZC4gKilcbiAgICAgICAgICBsZXQgc3ViX2VuZCA9IHNlYXJjaF9zdWJmb3JtYXRfZW5kIChzdHJfaW5kICsgMikgZW5kX2luZCAnKScgaW5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3ViX2VuZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICB8ICd9JyAtPlxuICAgICAgICAgICgqIEVycm9yOiAlKC4uLiV9LiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICcpJ1wiICd9J1xuICAgICAgICB8ICcpJyAtPlxuICAgICAgICAgICgqIEVycm9yOiAley4uLiUpLiAqKVxuICAgICAgICAgIGV4cGVjdGVkX2NoYXJhY3RlciAoc3RyX2luZCArIDEpIFwiY2hhcmFjdGVyICd9J1wiICcpJ1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBzZWFyY2hfc3ViZm9ybWF0X2VuZCAoc3RyX2luZCArIDIpIGVuZF9pbmQgY1xuICAgICAgICBlbmRcbiAgICB8IF8gLT4gc2VhcmNoX3N1YmZvcm1hdF9lbmQgKHN0cl9pbmQgKyAxKSBlbmRfaW5kIGNcblxuICAoKiBDaGVjayBpZiBzeW1iIGlzIGEgdmFsaWQgaW50IGNvbnZlcnNpb24gYWZ0ZXIgXCIlbFwiLCBcIiVuXCIgb3IgXCIlTFwiICopXG4gIGFuZCBpc19pbnRfYmFzZSBzeW1iID0gbWF0Y2ggc3ltYiB3aXRoXG4gICAgfCAnZCcgfCAnaScgfCAneCcgfCAnWCcgfCAnbycgfCAndScgLT4gdHJ1ZVxuICAgIHwgXyAtPiBmYWxzZVxuXG4gICgqIENvbnZlcnQgYSBjaGFyIChsLCBuIG9yIEwpIHRvIGl0cyBhc3NvY2lhdGVkIGNvdW50ZXIuICopXG4gIGFuZCBjb3VudGVyX29mX2NoYXIgc3ltYiA9IG1hdGNoIHN5bWIgd2l0aFxuICAgIHwgJ2wnIC0+IExpbmVfY291bnRlciAgfCAnbicgLT4gQ2hhcl9jb3VudGVyXG4gICAgfCAnTCcgLT4gVG9rZW5fY291bnRlciB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3ltYikgdG8gaXRzIGFzc29jaWF0ZWQgaW50X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggc3BhY2Ugc3ltYiA9XG4gICAgbWF0Y2ggcGx1cywgaGFzaCwgc3BhY2UsIHN5bWIgd2l0aFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ2QnIC0+IEludF9kICB8IGZhbHNlLCBmYWxzZSwgZmFsc2UsICdpJyAtPiBJbnRfaVxuICAgIHwgZmFsc2UsIGZhbHNlLCAgdHJ1ZSwgJ2QnIC0+IEludF9zZCB8IGZhbHNlLCBmYWxzZSwgIHRydWUsICdpJyAtPiBJbnRfc2lcbiAgICB8ICB0cnVlLCBmYWxzZSwgZmFsc2UsICdkJyAtPiBJbnRfcGQgfCAgdHJ1ZSwgZmFsc2UsIGZhbHNlLCAnaScgLT4gSW50X3BpXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAneCcgLT4gSW50X3ggIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ1gnIC0+IEludF9YXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAneCcgLT4gSW50X0N4IHwgZmFsc2UsICB0cnVlLCBmYWxzZSwgJ1gnIC0+IEludF9DWFxuICAgIHwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgJ28nIC0+IEludF9vXG4gICAgfCBmYWxzZSwgIHRydWUsIGZhbHNlLCAnbycgLT4gSW50X0NvXG4gICAgfCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAndScgLT4gSW50X3VcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdkJyAtPiBJbnRfQ2RcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICdpJyAtPiBJbnRfQ2lcbiAgICB8IGZhbHNlLCAgdHJ1ZSwgZmFsc2UsICd1JyAtPiBJbnRfQ3VcbiAgICB8IF8sIHRydWUsIF8sICd4JyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ3hcbiAgICB8IF8sIHRydWUsIF8sICdYJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ1hcbiAgICB8IF8sIHRydWUsIF8sICdvJyB3aGVuIGxlZ2FjeV9iZWhhdmlvciAtPiBJbnRfQ29cbiAgICB8IF8sIHRydWUsIF8sICgnZCcgfCAnaScgfCAndScpIC0+XG4gICAgICBpZiBsZWdhY3lfYmVoYXZpb3IgdGhlbiAoKiBpZ25vcmUgKilcbiAgICAgICAgY29tcHV0ZV9pbnRfY29udiBwY3RfaW5kIHN0cl9pbmQgcGx1cyBmYWxzZSBzcGFjZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCBzeW1iIFwiJyMnXCJcbiAgICB8IHRydWUsIF8sIHRydWUsIF8gLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuXG4gICAgICAgICgqIHBsdXMgYW5kIHNwYWNlOiBsZWdhY3kgaW1wbGVtZW50YXRpb24gcHJlZmVycyBwbHVzICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBmYWxzZSBzeW1iXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIlxuICAgIHwgZmFsc2UsIF8sIHRydWUsIF8gICAgLT5cbiAgICAgIGlmIGxlZ2FjeV9iZWhhdmlvciB0aGVuICgqIGlnbm9yZSAqKVxuICAgICAgICBjb21wdXRlX2ludF9jb252IHBjdF9pbmQgc3RyX2luZCBwbHVzIGhhc2ggZmFsc2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicgJ1wiXG4gICAgfCB0cnVlLCBfLCBmYWxzZSwgXyAgICAtPlxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gKCogaWdub3JlICopXG4gICAgICAgIGNvbXB1dGVfaW50X2NvbnYgcGN0X2luZCBzdHJfaW5kIGZhbHNlIGhhc2ggc3BhY2Ugc3ltYlxuICAgICAgZWxzZSBpbmNvbXBhdGlibGVfZmxhZyBwY3RfaW5kIHN0cl9pbmQgc3ltYiBcIicrJ1wiXG4gICAgfCBmYWxzZSwgXywgZmFsc2UsIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiAgKCogQ29udmVydCAocGx1cywgc3BhY2UsIHN5bWIpIHRvIGl0cyBhc3NvY2lhdGVkIGZsb2F0X2NvbnYuICopXG4gIGFuZCBjb21wdXRlX2Zsb2F0X2NvbnYgcGN0X2luZCBzdHJfaW5kIHBsdXMgaGFzaCBzcGFjZSBzeW1iID1cbiAgICBsZXQgZmxhZyA9IG1hdGNoIHBsdXMsIHNwYWNlIHdpdGhcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBGbG9hdF9mbGFnX1xuICAgIHwgZmFsc2UsICB0cnVlIC0+IEZsb2F0X2ZsYWdfc1xuICAgIHwgIHRydWUsIGZhbHNlIC0+IEZsb2F0X2ZsYWdfcFxuICAgIHwgIHRydWUsICB0cnVlIC0+XG4gICAgICAoKiBwbHVzIGFuZCBzcGFjZTogbGVnYWN5IGltcGxlbWVudGF0aW9uIHByZWZlcnMgcGx1cyAqKVxuICAgICAgaWYgbGVnYWN5X2JlaGF2aW9yIHRoZW4gRmxvYXRfZmxhZ19wXG4gICAgICBlbHNlIGluY29tcGF0aWJsZV9mbGFnIHBjdF9pbmQgc3RyX2luZCAnICcgXCInKydcIiBpblxuICAgIGxldCBraW5kID0gbWF0Y2ggaGFzaCwgc3ltYiB3aXRoXG4gICAgfCBfLCAnZicgLT4gRmxvYXRfZlxuICAgIHwgXywgJ2UnIC0+IEZsb2F0X2VcbiAgICB8IF8sICdFJyAtPiBGbG9hdF9FXG4gICAgfCBfLCAnZycgLT4gRmxvYXRfZ1xuICAgIHwgXywgJ0cnIC0+IEZsb2F0X0dcbiAgICB8IF8sICdoJyAtPiBGbG9hdF9oXG4gICAgfCBfLCAnSCcgLT4gRmxvYXRfSFxuICAgIHwgZmFsc2UsICdGJyAtPiBGbG9hdF9GXG4gICAgfCB0cnVlLCAnRicgLT4gRmxvYXRfQ0ZcbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIGluXG4gICAgZmxhZywga2luZFxuXG4gICgqIFJhaXNlIFtGYWlsdXJlXSB3aXRoIGEgZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBhYm91dCBpbmNvbXBhdGlibGUgb3B0aW9ucy4qKVxuICBhbmQgaW5jb21wYXRpYmxlX2ZsYWcgOiB0eXBlIGEgLiBpbnQgLT4gaW50IC0+IGNoYXIgLT4gc3RyaW5nIC0+IGEgPVxuICAgIGZ1biBwY3RfaW5kIHN0cl9pbmQgc3ltYiBvcHRpb24gLT5cbiAgICAgIGxldCBzdWJmbXQgPSBTdHJpbmcuc3ViIHN0ciBwY3RfaW5kIChzdHJfaW5kIC0gcGN0X2luZCkgaW5cbiAgICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgICAgXCJpbnZhbGlkIGZvcm1hdCAlUzogYXQgY2hhcmFjdGVyIG51bWJlciAlZCwgXFxcbiAgICAgICAgICVzIGlzIGluY29tcGF0aWJsZSB3aXRoICclYycgaW4gc3ViLWZvcm1hdCAlU1wiXG4gICAgICAgIHN0ciBwY3RfaW5kIG9wdGlvbiBzeW1iIHN1YmZtdFxuXG4gIGluIHBhcnNlIDAgKFN0cmluZy5sZW5ndGggc3RyKVxuXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuICAgICAgICAgICAgICAgICAgKCogR3VhcmRlZCBzdHJpbmcgdG8gZm9ybWF0IGNvbnZlcnNpb25zICopXG5cbigqIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBmb3JtYXQgYWNjb3JkaW5nIHRvIGFuIGZtdHR5LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mbXR0eSBzdHIgZm10dHkgPVxuICBsZXQgRm10X0VCQiBmbXQgPSBmbXRfZWJiX29mX3N0cmluZyBzdHIgaW5cbiAgdHJ5IEZvcm1hdCAodHlwZV9mb3JtYXQgZm10IGZtdHR5LCBzdHIpXG4gIHdpdGggVHlwZV9taXNtYXRjaCAtPlxuICAgIGZhaWx3aXRoX21lc3NhZ2VcbiAgICAgIFwiYmFkIGlucHV0OiBmb3JtYXQgdHlwZSBtaXNtYXRjaCBiZXR3ZWVuICVTIGFuZCAlU1wiXG4gICAgICBzdHIgKHN0cmluZ19vZl9mbXR0eSBmbXR0eSlcblxuKCogQ29udmVydCBhIHN0cmluZyB0byBhIGZvcm1hdCBjb21wYXRpYmxlIHdpdGggYW4gb3RoZXIgZm9ybWF0LiAqKVxuKCogUmFpc2UgW0ZhaWx1cmVdIHdpdGggYW4gZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHR5cGUgbWlzbWF0Y2guICopXG5sZXQgZm9ybWF0X29mX3N0cmluZ19mb3JtYXQgc3RyIChGb3JtYXQgKGZtdCcsIHN0cicpKSA9XG4gIGxldCBGbXRfRUJCIGZtdCA9IGZtdF9lYmJfb2Zfc3RyaW5nIHN0ciBpblxuICB0cnkgRm9ybWF0ICh0eXBlX2Zvcm1hdCBmbXQgKGZtdHR5X29mX2ZtdCBmbXQnKSwgc3RyKVxuICB3aXRoIFR5cGVfbWlzbWF0Y2ggLT5cbiAgICBmYWlsd2l0aF9tZXNzYWdlXG4gICAgICBcImJhZCBpbnB1dDogZm9ybWF0IHR5cGUgbWlzbWF0Y2ggYmV0d2VlbiAlUyBhbmQgJVNcIiBzdHIgc3RyJ1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIFByaW50ZlxuXG50eXBlIHQgPSBleG4gPSAuLlxuXG5sZXQgcHJpbnRlcnMgPSByZWYgW11cblxubGV0IGxvY2ZtdCA9IGZvcm1hdF9vZl9zdHJpbmcgXCJGaWxlIFxcXCIlc1xcXCIsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQ6ICVzXCJcblxubGV0IGZpZWxkIHggaSA9XG4gIGxldCBmID0gT2JqLmZpZWxkIHggaSBpblxuICBpZiBub3QgKE9iai5pc19ibG9jayBmKSB0aGVuXG4gICAgc3ByaW50ZiBcIiVkXCIgKE9iai5tYWdpYyBmIDogaW50KSAgICAgICAgICAgKCogY2FuIGFsc28gYmUgYSBjaGFyICopXG4gIGVsc2UgaWYgT2JqLnRhZyBmID0gT2JqLnN0cmluZ190YWcgdGhlblxuICAgIHNwcmludGYgXCIlU1wiIChPYmoubWFnaWMgZiA6IHN0cmluZylcbiAgZWxzZSBpZiBPYmoudGFnIGYgPSBPYmouZG91YmxlX3RhZyB0aGVuXG4gICAgc3RyaW5nX29mX2Zsb2F0IChPYmoubWFnaWMgZiA6IGZsb2F0KVxuICBlbHNlXG4gICAgXCJfXCJcblxubGV0IHJlYyBvdGhlcl9maWVsZHMgeCBpID1cbiAgaWYgaSA+PSBPYmouc2l6ZSB4IHRoZW4gXCJcIlxuICBlbHNlIHNwcmludGYgXCIsICVzJXNcIiAoZmllbGQgeCBpKSAob3RoZXJfZmllbGRzIHggKGkrMSkpXG5cbmxldCBmaWVsZHMgeCA9XG4gIG1hdGNoIE9iai5zaXplIHggd2l0aFxuICB8IDAgLT4gXCJcIlxuICB8IDEgLT4gXCJcIlxuICB8IDIgLT4gc3ByaW50ZiBcIiglcylcIiAoZmllbGQgeCAxKVxuICB8IF8gLT4gc3ByaW50ZiBcIiglcyVzKVwiIChmaWVsZCB4IDEpIChvdGhlcl9maWVsZHMgeCAyKVxuXG5sZXQgdXNlX3ByaW50ZXJzIHggPVxuICBsZXQgcmVjIGNvbnYgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgICAgKG1hdGNoIGhkIHggd2l0aFxuICAgICAgICAgfCBOb25lIHwgZXhjZXB0aW9uIF8gLT4gY29udiB0bFxuICAgICAgICAgfCBTb21lIHMgLT4gU29tZSBzKVxuICAgIHwgW10gLT4gTm9uZSBpblxuICBjb252ICFwcmludGVyc1xuXG5sZXQgdG9fc3RyaW5nX2RlZmF1bHQgPSBmdW5jdGlvblxuICB8IE91dF9vZl9tZW1vcnkgLT4gXCJPdXQgb2YgbWVtb3J5XCJcbiAgfCBTdGFja19vdmVyZmxvdyAtPiBcIlN0YWNrIG92ZXJmbG93XCJcbiAgfCBNYXRjaF9mYWlsdXJlKGZpbGUsIGxpbmUsIGNoYXIpIC0+XG4gICAgICBzcHJpbnRmIGxvY2ZtdCBmaWxlIGxpbmUgY2hhciAoY2hhcis1KSBcIlBhdHRlcm4gbWF0Y2hpbmcgZmFpbGVkXCJcbiAgfCBBc3NlcnRfZmFpbHVyZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJBc3NlcnRpb24gZmFpbGVkXCJcbiAgfCBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZShmaWxlLCBsaW5lLCBjaGFyKSAtPlxuICAgICAgc3ByaW50ZiBsb2NmbXQgZmlsZSBsaW5lIGNoYXIgKGNoYXIrNikgXCJVbmRlZmluZWQgcmVjdXJzaXZlIG1vZHVsZVwiXG4gIHwgeCAtPlxuICAgICAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gICAgICBpZiBPYmoudGFnIHggPD4gMCB0aGVuXG4gICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCB4IDApIDogc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgY29uc3RydWN0b3IgPVxuICAgICAgICAgIChPYmoubWFnaWMgKE9iai5maWVsZCAoT2JqLmZpZWxkIHggMCkgMCkgOiBzdHJpbmcpIGluXG4gICAgICAgIGNvbnN0cnVjdG9yIF4gKGZpZWxkcyB4KVxuXG5sZXQgdG9fc3RyaW5nIGUgPVxuICBtYXRjaCB1c2VfcHJpbnRlcnMgZSB3aXRoXG4gIHwgU29tZSBzIC0+IHNcbiAgfCBOb25lIC0+IHRvX3N0cmluZ19kZWZhdWx0IGVcblxubGV0IHByaW50IGZjdCBhcmcgPVxuICB0cnlcbiAgICBmY3QgYXJnXG4gIHdpdGggeCAtPlxuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBmbHVzaCBzdGRlcnI7XG4gICAgcmFpc2UgeFxuXG5sZXQgY2F0Y2ggZmN0IGFyZyA9XG4gIHRyeVxuICAgIGZjdCBhcmdcbiAgd2l0aCB4IC0+XG4gICAgZmx1c2ggc3Rkb3V0O1xuICAgIGVwcmludGYgXCJVbmNhdWdodCBleGNlcHRpb246ICVzXFxuXCIgKHRvX3N0cmluZyB4KTtcbiAgICBleGl0IDJcblxudHlwZSByYXdfYmFja3RyYWNlX3Nsb3RcbnR5cGUgcmF3X2JhY2t0cmFjZVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZTpcbiAgdW5pdCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9leGNlcHRpb25fcmF3X2JhY2t0cmFjZVwiXG5cbmV4dGVybmFsIHJhaXNlX3dpdGhfYmFja3RyYWNlOiBleG4gLT4gcmF3X2JhY2t0cmFjZSAtPiAnYVxuICA9IFwiJXJhaXNlX3dpdGhfYmFja3RyYWNlXCJcblxudHlwZSBiYWNrdHJhY2Vfc2xvdCA9XG4gIHwgS25vd25fbG9jYXRpb24gb2Yge1xuICAgICAgaXNfcmFpc2UgICAgOiBib29sO1xuICAgICAgZmlsZW5hbWUgICAgOiBzdHJpbmc7XG4gICAgICBsaW5lX251bWJlciA6IGludDtcbiAgICAgIHN0YXJ0X2NoYXIgIDogaW50O1xuICAgICAgZW5kX2NoYXIgICAgOiBpbnQ7XG4gICAgICBpc19pbmxpbmUgICA6IGJvb2w7XG4gICAgICBkZWZuYW1lICAgICA6IHN0cmluZztcbiAgICB9XG4gIHwgVW5rbm93bl9sb2NhdGlvbiBvZiB7XG4gICAgICBpc19yYWlzZSA6IGJvb2xcbiAgICB9XG5cbigqIHRvIGF2b2lkIHdhcm5pbmcgKilcbmxldCBfID0gW0tub3duX2xvY2F0aW9uIHsgaXNfcmFpc2UgPSBmYWxzZTsgZmlsZW5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX251bWJlciA9IDA7IHN0YXJ0X2NoYXIgPSAwOyBlbmRfY2hhciA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlzX2lubGluZSA9IGZhbHNlOyBkZWZuYW1lID0gXCJcIiB9O1xuICAgICAgICAgVW5rbm93bl9sb2NhdGlvbiB7IGlzX3JhaXNlID0gZmFsc2UgfV1cblxuZXh0ZXJuYWwgY29udmVydF9yYXdfYmFja3RyYWNlX3Nsb3Q6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiBiYWNrdHJhY2Vfc2xvdCA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGNvbnZlcnRfcmF3X2JhY2t0cmFjZTpcbiAgcmF3X2JhY2t0cmFjZSAtPiBiYWNrdHJhY2Vfc2xvdCBhcnJheSA9IFwiY2FtbF9jb252ZXJ0X3Jhd19iYWNrdHJhY2VcIlxuXG5sZXQgY29udmVydF9yYXdfYmFja3RyYWNlIGJ0ID1cbiAgdHJ5IFNvbWUgKGNvbnZlcnRfcmF3X2JhY2t0cmFjZSBidClcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG5sZXQgZm9ybWF0X2JhY2t0cmFjZV9zbG90IHBvcyBzbG90ID1cbiAgbGV0IGluZm8gaXNfcmFpc2UgPVxuICAgIGlmIGlzX3JhaXNlIHRoZW5cbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBhdFwiIGVsc2UgXCJSZS1yYWlzZWQgYXRcIlxuICAgIGVsc2VcbiAgICAgIGlmIHBvcyA9IDAgdGhlbiBcIlJhaXNlZCBieSBwcmltaXRpdmUgb3BlcmF0aW9uIGF0XCIgZWxzZSBcIkNhbGxlZCBmcm9tXCJcbiAgaW5cbiAgbWF0Y2ggc2xvdCB3aXRoXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBpZiBsLmlzX3JhaXNlIHRoZW5cbiAgICAgICAgKCogY29tcGlsZXItaW5zZXJ0ZWQgcmUtcmFpc2UsIHNraXBwZWQgKikgTm9uZVxuICAgICAgZWxzZVxuICAgICAgICBTb21lIChzcHJpbnRmIFwiJXMgdW5rbm93biBsb2NhdGlvblwiIChpbmZvIGZhbHNlKSlcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgICBTb21lIChzcHJpbnRmIFwiJXMgJXMgaW4gZmlsZSBcXFwiJXNcXFwiJXMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWRcIlxuICAgICAgICAgICAgICAoaW5mbyBsLmlzX3JhaXNlKSBsLmRlZm5hbWUgbC5maWxlbmFtZVxuICAgICAgICAgICAgICAoaWYgbC5pc19pbmxpbmUgdGhlbiBcIiAoaW5saW5lZClcIiBlbHNlIFwiXCIpXG4gICAgICAgICAgICAgIGwubGluZV9udW1iZXIgbC5zdGFydF9jaGFyIGwuZW5kX2NoYXIpXG5cbmxldCBwcmludF9leGNlcHRpb25fYmFja3RyYWNlIG91dGNoYW4gYmFja3RyYWNlID1cbiAgbWF0Y2ggYmFja3RyYWNlIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgICBmcHJpbnRmIG91dGNoYW5cbiAgICAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggYSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggZm9ybWF0X2JhY2t0cmFjZV9zbG90IGkgYS4oaSkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICAgIHwgU29tZSBzdHIgLT4gZnByaW50ZiBvdXRjaGFuIFwiJXNcXG5cIiBzdHJcbiAgICAgIGRvbmVcblxubGV0IHByaW50X3Jhd19iYWNrdHJhY2Ugb3V0Y2hhbiByYXdfYmFja3RyYWNlID1cbiAgcHJpbnRfZXhjZXB0aW9uX2JhY2t0cmFjZSBvdXRjaGFuIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6IHByaW50cyB0aGUgZ2xvYmFsIGN1cnJlbnQgYmFja3RyYWNlICopXG5sZXQgcHJpbnRfYmFja3RyYWNlIG91dGNoYW4gPVxuICBwcmludF9yYXdfYmFja3RyYWNlIG91dGNoYW4gKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5sZXQgYmFja3RyYWNlX3RvX3N0cmluZyBiYWNrdHJhY2UgPVxuICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICB8IE5vbmUgLT5cbiAgICAgXCIoUHJvZ3JhbSBub3QgbGlua2VkIHdpdGggLWcsIGNhbm5vdCBwcmludCBzdGFjayBiYWNrdHJhY2UpXFxuXCJcbiAgfCBTb21lIGEgLT5cbiAgICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGEgLSAxIGRvXG4gICAgICAgIG1hdGNoIGZvcm1hdF9iYWNrdHJhY2Vfc2xvdCBpIGEuKGkpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgc3RyIC0+IGJwcmludGYgYiBcIiVzXFxuXCIgc3RyXG4gICAgICBkb25lO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJcblxubGV0IHJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHJhd19iYWNrdHJhY2UgPVxuICBiYWNrdHJhY2VfdG9fc3RyaW5nIChjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSlcblxubGV0IGJhY2t0cmFjZV9zbG90X2lzX3JhaXNlID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfcmFpc2VcbiAgfCBVbmtub3duX2xvY2F0aW9uIGwgLT4gbC5pc19yYWlzZVxuXG5sZXQgYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lID0gZnVuY3Rpb25cbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+IGwuaXNfaW5saW5lXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IGZhbHNlXG5cbnR5cGUgbG9jYXRpb24gPSB7XG4gIGZpbGVuYW1lIDogc3RyaW5nO1xuICBsaW5lX251bWJlciA6IGludDtcbiAgc3RhcnRfY2hhciA6IGludDtcbiAgZW5kX2NoYXIgOiBpbnQ7XG59XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9sb2NhdGlvbiA9IGZ1bmN0aW9uXG4gIHwgVW5rbm93bl9sb2NhdGlvbiBfIC0+IE5vbmVcbiAgfCBLbm93bl9sb2NhdGlvbiBsIC0+XG4gICAgU29tZSB7XG4gICAgICBmaWxlbmFtZSAgICA9IGwuZmlsZW5hbWU7XG4gICAgICBsaW5lX251bWJlciA9IGwubGluZV9udW1iZXI7XG4gICAgICBzdGFydF9jaGFyICA9IGwuc3RhcnRfY2hhcjtcbiAgICAgIGVuZF9jaGFyICAgID0gbC5lbmRfY2hhcjtcbiAgICB9XG5cbmxldCBiYWNrdHJhY2Vfc2xvdF9kZWZuYW1lID0gZnVuY3Rpb25cbiAgfCBVbmtub3duX2xvY2F0aW9uIF9cbiAgfCBLbm93bl9sb2NhdGlvbiB7IGRlZm5hbWUgPSBcIlwiIH0gLT4gTm9uZVxuICB8IEtub3duX2xvY2F0aW9uIGwgLT4gU29tZSBsLmRlZm5hbWVcblxubGV0IGJhY2t0cmFjZV9zbG90cyByYXdfYmFja3RyYWNlID1cbiAgKCogVGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHRoYXQgU29tZSBpc1xuICAgICByZXR1cm5lZCBvbmx5IGlmIGEgcGFydCBvZiB0aGUgdHJhY2UgaXMgdXNhYmxlLiBUaGlzIGdpdmVzIHVzXG4gICAgIGEgYml0IG1vcmUgd29yayB0aGFuIGp1c3QgY29udmVydF9yYXdfYmFja3RyYWNlLCBidXQgaXQgbWFrZXMgdGhlXG4gICAgIEFQSSBtb3JlIHVzZXItZnJpZW5kbHkgLS0gb3RoZXJ3aXNlIG1vc3QgdXNlcnMgd291bGQgaGF2ZSB0b1xuICAgICByZWltcGxlbWVudCB0aGUgXCJQcm9ncmFtIG5vdCBsaW5rZWQgd2l0aCAtZywgc29ycnlcIiBsb2dpY1xuICAgICB0aGVtc2VsdmVzLiAqKVxuICBtYXRjaCBjb252ZXJ0X3Jhd19iYWNrdHJhY2UgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgYmFja3RyYWNlIC0+XG4gICAgICBsZXQgdXNhYmxlX3Nsb3QgPSBmdW5jdGlvblxuICAgICAgICB8IFVua25vd25fbG9jYXRpb24gXyAtPiBmYWxzZVxuICAgICAgICB8IEtub3duX2xvY2F0aW9uIF8gLT4gdHJ1ZSBpblxuICAgICAgbGV0IHJlYyBleGlzdHNfdXNhYmxlID0gZnVuY3Rpb25cbiAgICAgICAgfCAoLTEpIC0+IGZhbHNlXG4gICAgICAgIHwgaSAtPiB1c2FibGVfc2xvdCBiYWNrdHJhY2UuKGkpIHx8IGV4aXN0c191c2FibGUgKGkgLSAxKSBpblxuICAgICAgaWYgZXhpc3RzX3VzYWJsZSAoQXJyYXkubGVuZ3RoIGJhY2t0cmFjZSAtIDEpXG4gICAgICB0aGVuIFNvbWUgYmFja3RyYWNlXG4gICAgICBlbHNlIE5vbmVcblxubW9kdWxlIFNsb3QgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gYmFja3RyYWNlX3Nsb3RcbiAgbGV0IGZvcm1hdCA9IGZvcm1hdF9iYWNrdHJhY2Vfc2xvdFxuICBsZXQgaXNfcmFpc2UgPSBiYWNrdHJhY2Vfc2xvdF9pc19yYWlzZVxuICBsZXQgaXNfaW5saW5lID0gYmFja3RyYWNlX3Nsb3RfaXNfaW5saW5lXG4gIGxldCBsb2NhdGlvbiA9IGJhY2t0cmFjZV9zbG90X2xvY2F0aW9uXG4gIGxldCBuYW1lID0gYmFja3RyYWNlX3Nsb3RfZGVmbmFtZVxuZW5kXG5cbmV4dGVybmFsIHJhd19iYWNrdHJhY2VfbGVuZ3RoIDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgPSBcImNhbWxfcmF3X2JhY2t0cmFjZV9sZW5ndGhcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBnZXRfcmF3X2JhY2t0cmFjZV9zbG90IDpcbiAgcmF3X2JhY2t0cmFjZSAtPiBpbnQgLT4gcmF3X2JhY2t0cmFjZV9zbG90ID0gXCJjYW1sX3Jhd19iYWNrdHJhY2Vfc2xvdFwiXG5cbmV4dGVybmFsIGdldF9yYXdfYmFja3RyYWNlX25leHRfc2xvdCA6XG4gIHJhd19iYWNrdHJhY2Vfc2xvdCAtPiByYXdfYmFja3RyYWNlX3Nsb3Qgb3B0aW9uXG4gID0gXCJjYW1sX3Jhd19iYWNrdHJhY2VfbmV4dF9zbG90XCJcblxuKCogY29uZnVzaW5nbHkgbmFtZWQ6XG4gICByZXR1cm5zIHRoZSAqc3RyaW5nKiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnbG9iYWwgY3VycmVudCBiYWNrdHJhY2UgKilcbmxldCBnZXRfYmFja3RyYWNlICgpID0gcmF3X2JhY2t0cmFjZV90b19zdHJpbmcgKGdldF9yYXdfYmFja3RyYWNlICgpKVxuXG5leHRlcm5hbCByZWNvcmRfYmFja3RyYWNlOiBib29sIC0+IHVuaXQgPSBcImNhbWxfcmVjb3JkX2JhY2t0cmFjZVwiXG5leHRlcm5hbCBiYWNrdHJhY2Vfc3RhdHVzOiB1bml0IC0+IGJvb2wgPSBcImNhbWxfYmFja3RyYWNlX3N0YXR1c1wiXG5cbmxldCByZWdpc3Rlcl9wcmludGVyIGZuID1cbiAgcHJpbnRlcnMgOj0gZm4gOjogIXByaW50ZXJzXG5cbmV4dGVybmFsIGdldF9jYWxsc3RhY2s6IGludCAtPiByYXdfYmFja3RyYWNlID0gXCJjYW1sX2dldF9jdXJyZW50X2NhbGxzdGFja1wiXG5cbmxldCBleG5fc2xvdCB4ID1cbiAgbGV0IHggPSBPYmoucmVwciB4IGluXG4gIGlmIE9iai50YWcgeCA9IDAgdGhlbiBPYmouZmllbGQgeCAwIGVsc2UgeFxuXG5sZXQgZXhuX3Nsb3RfaWQgeCA9XG4gIGxldCBzbG90ID0gZXhuX3Nsb3QgeCBpblxuICAoT2JqLm9iaiAoT2JqLmZpZWxkIHNsb3QgMSkgOiBpbnQpXG5cbmxldCBleG5fc2xvdF9uYW1lIHggPVxuICBsZXQgc2xvdCA9IGV4bl9zbG90IHggaW5cbiAgKE9iai5vYmogKE9iai5maWVsZCBzbG90IDApIDogc3RyaW5nKVxuXG5sZXQgZGVmYXVsdF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBleG4gcmF3X2JhY2t0cmFjZSA9XG4gIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICBwcmludF9yYXdfYmFja3RyYWNlIHN0ZGVyciByYXdfYmFja3RyYWNlO1xuICBmbHVzaCBzdGRlcnJcblxubGV0IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyID0gcmVmIGRlZmF1bHRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXJcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciBmbiA9IHVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIDo9IGZuXG5cbmxldCBlbXB0eV9iYWNrdHJhY2UgOiByYXdfYmFja3RyYWNlID0gT2JqLm9iaiAoT2JqLm5ld19ibG9jayBPYmouYWJzdHJhY3RfdGFnIDApXG5cbmxldCB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgPVxuICB0cnlcbiAgICBnZXRfcmF3X2JhY2t0cmFjZSAoKVxuICB3aXRoIF8gKCogT3V0X29mX21lbW9yeT8gKikgLT5cbiAgICBlbXB0eV9iYWNrdHJhY2VcblxubGV0IGhhbmRsZV91bmNhdWdodF9leGNlcHRpb24nIGV4biBkZWJ1Z2dlcl9pbl91c2UgPVxuICB0cnlcbiAgICAoKiBHZXQgdGhlIGJhY2t0cmFjZSBub3csIGluIGNhc2Ugb25lIG9mIHRoZSBbYXRfZXhpdF0gZnVuY3Rpb25cbiAgICAgICBkZXN0cm95cyBpdC4gKilcbiAgICBsZXQgcmF3X2JhY2t0cmFjZSA9XG4gICAgICBpZiBkZWJ1Z2dlcl9pbl91c2UgKCogU2FtZSB0ZXN0IGFzIGluIFtydW50aW1lL3ByaW50ZXhjLmNdICopIHRoZW5cbiAgICAgICAgZW1wdHlfYmFja3RyYWNlXG4gICAgICBlbHNlXG4gICAgICAgIHRyeV9nZXRfcmF3X2JhY2t0cmFjZSAoKVxuICAgIGluXG4gICAgKHRyeSBTdGRsaWIuZG9fYXRfZXhpdCAoKSB3aXRoIF8gLT4gKCkpO1xuICAgIHRyeVxuICAgICAgIXVuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIGV4biByYXdfYmFja3RyYWNlXG4gICAgd2l0aCBleG4nIC0+XG4gICAgICBsZXQgcmF3X2JhY2t0cmFjZScgPSB0cnlfZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uICVzXFxuXCIgKHRvX3N0cmluZyBleG4pO1xuICAgICAgcHJpbnRfcmF3X2JhY2t0cmFjZSBzdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgICAgIGVwcmludGYgXCJGYXRhbCBlcnJvciBpbiB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcjogZXhjZXB0aW9uICVzXFxuXCJcbiAgICAgICAgKHRvX3N0cmluZyBleG4nKTtcbiAgICAgIHByaW50X3Jhd19iYWNrdHJhY2Ugc3RkZXJyIHJhd19iYWNrdHJhY2UnO1xuICAgICAgZmx1c2ggc3RkZXJyXG4gIHdpdGhcbiAgICB8IE91dF9vZl9tZW1vcnkgLT5cbiAgICAgICAgcHJlcnJfZW5kbGluZVxuICAgICAgICAgIFwiRmF0YWwgZXJyb3I6IG91dCBvZiBtZW1vcnkgaW4gdW5jYXVnaHQgZXhjZXB0aW9uIGhhbmRsZXJcIlxuXG4oKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBbY2FtbF9mYXRhbF91bmNhdWdodF9leGNlcHRpb25dIGluXG4gICBbcnVudGltZS9wcmludGV4Yy5jXSB3aGljaCBleHBlY3RzIG5vIGV4Y2VwdGlvbiBpcyByYWlzZWQuICopXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbiBleG4gZGVidWdnZXJfaW5fdXNlID1cbiAgdHJ5XG4gICAgaGFuZGxlX3VuY2F1Z2h0X2V4Y2VwdGlvbicgZXhuIGRlYnVnZ2VyX2luX3VzZVxuICB3aXRoIF8gLT5cbiAgICAoKiBUaGVyZSBpcyBub3QgbXVjaCB3ZSBjYW4gZG8gYXQgdGhpcyBwb2ludCAqKVxuICAgICgpXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+ICdhIC0+IHVuaXRcbiAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICByZWdpc3Rlcl9uYW1lZF92YWx1ZSBcIlByaW50ZXhjLmhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cIlxuICAgIGhhbmRsZV91bmNhdWdodF9leGNlcHRpb25cbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBYYXZpZXIgTGVyb3kgYW5kIERhbWllbiBEb2xpZ2V6LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGdlbmVyaWNfcXVvdGUgcXVvdGVxdW90ZSBzID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChsICsgMjApIGluXG4gIEJ1ZmZlci5hZGRfY2hhciBiICdcXCcnO1xuICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICBpZiBzLltpXSA9ICdcXCcnXG4gICAgdGhlbiBCdWZmZXIuYWRkX3N0cmluZyBiIHF1b3RlcXVvdGVcbiAgICBlbHNlIEJ1ZmZlci5hZGRfY2hhciBiICBzLltpXVxuICBkb25lO1xuICBCdWZmZXIuYWRkX2NoYXIgYiAnXFwnJztcbiAgQnVmZmVyLmNvbnRlbnRzIGJcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1sxXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Jhc2VuYW1lLmh0bWxcbiAgSW4gc3RlcCAxIG9mIFtbMV1dLCB3ZSBjaG9vc2UgdG8gcmV0dXJuIFwiLlwiIGZvciBlbXB0eSBpbnB1dC5cbiAgICAoZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBPQ2FtbClcbiAgSW4gc3RlcCAyLCB3ZSBjaG9vc2UgdG8gcHJvY2VzcyBcIi8vXCIgbm9ybWFsbHkuXG4gIFN0ZXAgNiBpcyBub3QgaW1wbGVtZW50ZWQ6IHdlIGNvbnNpZGVyIHRoYXQgdGhlIFtzdWZmaXhdIG9wZXJhbmQgaXNcbiAgICBhbHdheXMgYWJzZW50LiAgU3VmZml4ZXMgYXJlIGhhbmRsZWQgYnkgW2Nob3Bfc3VmZml4XSBhbmQgW2Nob3BfZXh0ZW5zaW9uXS5cbiopXG5sZXQgZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWUgbmFtZSA9XG4gIGxldCByZWMgZmluZF9lbmQgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGZpbmRfZW5kIChuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIG4gKG4gKyAxKVxuICBhbmQgZmluZF9iZWcgbiBwID1cbiAgICBpZiBuIDwgMCB0aGVuIFN0cmluZy5zdWIgbmFtZSAwIHBcbiAgICBlbHNlIGlmIGlzX2Rpcl9zZXAgbmFtZSBuIHRoZW4gU3RyaW5nLnN1YiBuYW1lIChuICsgMSkgKHAgLSBuIC0gMSlcbiAgICBlbHNlIGZpbmRfYmVnIChuIC0gMSkgcFxuICBpblxuICBpZiBuYW1lID0gXCJcIlxuICB0aGVuIGN1cnJlbnRfZGlyX25hbWVcbiAgZWxzZSBmaW5kX2VuZCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxuKCogVGhpcyBmdW5jdGlvbiBpbXBsZW1lbnRzIHRoZSBPcGVuIEdyb3VwIHNwZWNpZmljYXRpb24gZm91bmQgaGVyZTpcbiAgW1syXV0gaHR0cDovL3B1YnMub3Blbmdyb3VwLm9yZy9vbmxpbmVwdWJzLzk2OTk5MTk3OTkvdXRpbGl0aWVzL2Rpcm5hbWUuaHRtbFxuICBJbiBzdGVwIDYgb2YgW1syXV0sIHdlIGNob29zZSB0byBwcm9jZXNzIFwiLy9cIiBub3JtYWxseS5cbiopXG5sZXQgZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBuYW1lID1cbiAgbGV0IHJlYyB0cmFpbGluZ19zZXAgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBTdHJpbmcuc3ViIG5hbWUgMCAxXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIHRyYWlsaW5nX3NlcCAobiAtIDEpXG4gICAgZWxzZSBiYXNlIG5cbiAgYW5kIGJhc2UgbiA9XG4gICAgaWYgbiA8IDAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gICAgZWxzZSBpZiBpc19kaXJfc2VwIG5hbWUgbiB0aGVuIGludGVybWVkaWF0ZV9zZXAgblxuICAgIGVsc2UgYmFzZSAobiAtIDEpXG4gIGFuZCBpbnRlcm1lZGlhdGVfc2VwIG4gPVxuICAgIGlmIG4gPCAwIHRoZW4gU3RyaW5nLnN1YiBuYW1lIDAgMVxuICAgIGVsc2UgaWYgaXNfZGlyX3NlcCBuYW1lIG4gdGhlbiBpbnRlcm1lZGlhdGVfc2VwIChuIC0gMSlcbiAgICBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChuICsgMSlcbiAgaW5cbiAgaWYgbmFtZSA9IFwiXCJcbiAgdGhlbiBjdXJyZW50X2Rpcl9uYW1lXG4gIGVsc2UgdHJhaWxpbmdfc2VwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSAxKVxuXG5tb2R1bGUgdHlwZSBTWVNERVBTID0gc2lnXG4gIHZhbCBudWxsIDogc3RyaW5nXG4gIHZhbCBjdXJyZW50X2Rpcl9uYW1lIDogc3RyaW5nXG4gIHZhbCBwYXJlbnRfZGlyX25hbWUgOiBzdHJpbmdcbiAgdmFsIGRpcl9zZXAgOiBzdHJpbmdcbiAgdmFsIGlzX2Rpcl9zZXAgOiBzdHJpbmcgLT4gaW50IC0+IGJvb2xcbiAgdmFsIGlzX3JlbGF0aXZlIDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGlzX2ltcGxpY2l0IDogc3RyaW5nIC0+IGJvb2xcbiAgdmFsIGNoZWNrX3N1ZmZpeCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuICB2YWwgY2hvcF9zdWZmaXhfb3B0IDogc3VmZml4OnN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nIG9wdGlvblxuICB2YWwgdGVtcF9kaXJfbmFtZSA6IHN0cmluZ1xuICB2YWwgcXVvdGUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIHZhbCBxdW90ZV9jb21tYW5kIDpcbiAgICBzdHJpbmcgLT4gP3N0ZGluOiBzdHJpbmcgLT4gP3N0ZG91dDogc3RyaW5nIC0+ID9zdGRlcnI6IHN0cmluZ1xuICAgICAgICAgICAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbiAgdmFsIGJhc2VuYW1lIDogc3RyaW5nIC0+IHN0cmluZ1xuICB2YWwgZGlybmFtZSA6IHN0cmluZyAtPiBzdHJpbmdcbmVuZFxuXG5tb2R1bGUgVW5peCA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwIHMgaSA9IHMuW2ldID0gJy8nXG4gIGxldCBpc19yZWxhdGl2ZSBuID0gU3RyaW5nLmxlbmd0aCBuIDwgMSB8fCBuLlswXSA8PiAnLydcbiAgbGV0IGlzX2ltcGxpY2l0IG4gPVxuICAgIGlzX3JlbGF0aXZlIG5cbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBTdHJpbmcuc3ViIG4gMCAyIDw+IFwiLi9cIilcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMyB8fCBTdHJpbmcuc3ViIG4gMCAzIDw+IFwiLi4vXCIpXG4gIGxldCBjaGVja19zdWZmaXggbmFtZSBzdWZmID1cbiAgICBTdHJpbmcubGVuZ3RoIG5hbWUgPj0gU3RyaW5nLmxlbmd0aCBzdWZmICYmXG4gICAgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgIChTdHJpbmcubGVuZ3RoIHN1ZmYpID0gc3VmZlxuXG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgfnN1ZmZpeCBmaWxlbmFtZSA9XG4gICAgbGV0IGxlbl9zID0gU3RyaW5nLmxlbmd0aCBzdWZmaXggYW5kIGxlbl9mID0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGlmIGxlbl9mID49IGxlbl9zIHRoZW5cbiAgICAgIGxldCByID0gU3RyaW5nLnN1YiBmaWxlbmFtZSAobGVuX2YgLSBsZW5fcykgbGVuX3MgaW5cbiAgICAgIGlmIHIgPSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB0ZW1wX2Rpcl9uYW1lID1cbiAgICB0cnkgU3lzLmdldGVudiBcIlRNUERJUlwiIHdpdGggTm90X2ZvdW5kIC0+IFwiL3RtcFwiXG4gIGxldCBxdW90ZSA9IGdlbmVyaWNfcXVvdGUgXCInXFxcXCcnXCJcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIiBcIiAoTGlzdC5tYXAgcXVvdGUgKGNtZCA6OiBhcmdzKSlcbiAgICBeIChtYXRjaCBzdGRpbiAgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPFwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGUgZilcbiAgICBeIChtYXRjaCBzdGRlcnIgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gaWYgc3RkZXJyID0gc3Rkb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuIFwiIDI+JjFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGUgZilcbiAgbGV0IGJhc2VuYW1lID0gZ2VuZXJpY19iYXNlbmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbiAgbGV0IGRpcm5hbWUgPSBnZW5lcmljX2Rpcm5hbWUgaXNfZGlyX3NlcCBjdXJyZW50X2Rpcl9uYW1lXG5lbmRcblxubW9kdWxlIFdpbjMyIDogU1lTREVQUyA9IHN0cnVjdFxuICBsZXQgbnVsbCA9IFwiTlVMXCJcbiAgbGV0IGN1cnJlbnRfZGlyX25hbWUgPSBcIi5cIlxuICBsZXQgcGFyZW50X2Rpcl9uYW1lID0gXCIuLlwiXG4gIGxldCBkaXJfc2VwID0gXCJcXFxcXCJcbiAgbGV0IGlzX2Rpcl9zZXAgcyBpID0gbGV0IGMgPSBzLltpXSBpbiBjID0gJy8nIHx8IGMgPSAnXFxcXCcgfHwgYyA9ICc6J1xuICBsZXQgaXNfcmVsYXRpdmUgbiA9XG4gICAgKFN0cmluZy5sZW5ndGggbiA8IDEgfHwgbi5bMF0gPD4gJy8nKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAxIHx8IG4uWzBdIDw+ICdcXFxcJylcbiAgICAmJiAoU3RyaW5nLmxlbmd0aCBuIDwgMiB8fCBuLlsxXSA8PiAnOicpXG4gIGxldCBpc19pbXBsaWNpdCBuID1cbiAgICBpc19yZWxhdGl2ZSBuXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi4vXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDIgfHwgU3RyaW5nLnN1YiBuIDAgMiA8PiBcIi5cXFxcXCIpXG4gICAgJiYgKFN0cmluZy5sZW5ndGggbiA8IDMgfHwgU3RyaW5nLnN1YiBuIDAgMyA8PiBcIi4uL1wiKVxuICAgICYmIChTdHJpbmcubGVuZ3RoIG4gPCAzIHx8IFN0cmluZy5zdWIgbiAwIDMgPD4gXCIuLlxcXFxcIilcbiAgbGV0IGNoZWNrX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICAgU3RyaW5nLmxlbmd0aCBuYW1lID49IFN0cmluZy5sZW5ndGggc3VmZiAmJlxuICAgKGxldCBzID0gU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBTdHJpbmcubGVuZ3RoIHN1ZmYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFN0cmluZy5sZW5ndGggc3VmZikgaW5cbiAgICBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHMgPSBTdHJpbmcubG93ZXJjYXNlX2FzY2lpIHN1ZmYpXG5cbiAgbGV0IGNob3Bfc3VmZml4X29wdCB+c3VmZml4IGZpbGVuYW1lID1cbiAgICBsZXQgbGVuX3MgPSBTdHJpbmcubGVuZ3RoIHN1ZmZpeCBhbmQgbGVuX2YgPSBTdHJpbmcubGVuZ3RoIGZpbGVuYW1lIGluXG4gICAgaWYgbGVuX2YgPj0gbGVuX3MgdGhlblxuICAgICAgbGV0IHIgPSBTdHJpbmcuc3ViIGZpbGVuYW1lIChsZW5fZiAtIGxlbl9zKSBsZW5fcyBpblxuICAgICAgaWYgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSByID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzdWZmaXggdGhlblxuICAgICAgICBTb21lIChTdHJpbmcuc3ViIGZpbGVuYW1lIDAgKGxlbl9mIC0gbGVuX3MpKVxuICAgICAgZWxzZVxuICAgICAgICBOb25lXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG5cbiAgbGV0IHRlbXBfZGlyX25hbWUgPVxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiVEVNUFwiIHdpdGggTm90X2ZvdW5kIC0+IFwiLlwiXG4gIGxldCBxdW90ZSBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAobCArIDIwKSBpblxuICAgIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJztcbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbCB0aGVuIEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJyBlbHNlXG4gICAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICB8ICdcXFwiJyAtPiBsb29wX2JzIDAgaTtcbiAgICAgIHwgJ1xcXFwnIC0+IGxvb3BfYnMgMCBpO1xuICAgICAgfCBjICAgIC0+IEJ1ZmZlci5hZGRfY2hhciBiIGM7IGxvb3AgKGkrMSk7XG4gICAgYW5kIGxvb3BfYnMgbiBpID1cbiAgICAgIGlmIGkgPSBsIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGIgJ1xcXCInO1xuICAgICAgICBhZGRfYnMgbjtcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgICAgfCAnXFxcIicgLT4gYWRkX2JzICgyKm4rMSk7IEJ1ZmZlci5hZGRfY2hhciBiICdcXFwiJzsgbG9vcCAoaSsxKTtcbiAgICAgICAgfCAnXFxcXCcgLT4gbG9vcF9icyAobisxKSAoaSsxKTtcbiAgICAgICAgfCBfICAgIC0+IGFkZF9icyBuOyBsb29wIGlcbiAgICAgIGVuZFxuICAgIGFuZCBhZGRfYnMgbiA9IGZvciBfaiA9IDEgdG8gbiBkbyBCdWZmZXIuYWRkX2NoYXIgYiAnXFxcXCc7IGRvbmVcbiAgICBpblxuICAgIGxvb3AgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYlxuKCpcblF1b3RpbmcgY29tbWFuZHMgZm9yIGV4ZWN1dGlvbiBieSBjbWQuZXhlIGlzIGRpZmZpY3VsdC5cbjEtIEVhY2ggYXJndW1lbnQgaXMgZmlyc3QgcXVvdGVkIHVzaW5nIHRoZSBcInF1b3RlXCIgZnVuY3Rpb24gYWJvdmUsIHRvXG4gICBwcm90ZWN0IGl0IGFnYWluc3QgdGhlIHByb2Nlc3NpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLFxuICAgdGhlbiBjbWQuZXhlJ3Mgc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkIHdpdGggJ14nLCB1c2luZ1xuICAgdGhlIFwicXVvdGVfY21kXCIgZnVuY3Rpb24gYmVsb3cuICBGb3IgbW9yZSBkZXRhaWxzLCBzZWVcbiAgIGh0dHBzOi8vYmxvZ3MubXNkbi5taWNyb3NvZnQuY29tL3R3aXN0eWxpdHRsZXBhc3NhZ2VzYWxsYWxpa2UvMjAxMS8wNC8yM1xuMi0gVGhlIGNvbW1hbmQgYW5kIHRoZSByZWRpcmVjdGlvbiBmaWxlcywgaWYgYW55LCBtdXN0IGJlIGRvdWJsZS1xdW90ZWRcbiAgIGluIGNhc2UgdGhleSBjb250YWluIHNwYWNlcy4gIFRoaXMgcXVvdGluZyBpcyBpbnRlcnByZXRlZCBieSBjbWQuZXhlLFxuICAgbm90IGJ5IHRoZSBDIHJ1bnRpbWUgc3lzdGVtLCBoZW5jZSB0aGUgXCJxdW90ZVwiIGZ1bmN0aW9uIGFib3ZlXG4gICBjYW5ub3QgYmUgdXNlZC4gIFRoZSB0d28gY2hhcmFjdGVycyB3ZSBkb24ndCBrbm93IGhvdyB0byBxdW90ZVxuICAgaW5zaWRlIGEgZG91YmxlLXF1b3RlZCBjbWQuZXhlIHN0cmluZyBhcmUgZG91YmxlLXF1b3RlIGFuZCBwZXJjZW50LlxuICAgV2UganVzdCBmYWlsIGlmIHRoZSBjb21tYW5kIG5hbWUgb3IgdGhlIHJlZGlyZWN0aW9uIGZpbGUgbmFtZXNcbiAgIGNvbnRhaW4gYSBkb3VibGUgcXVvdGUgKG5vdCBhbGxvd2VkIGluIFdpbmRvd3MgZmlsZSBuYW1lcywgYW55d2F5KVxuICAgb3IgYSBwZXJjZW50LiAgU2VlIGZ1bmN0aW9uIFwicXVvdGVfY21kX2ZpbGVuYW1lXCIgYmVsb3cuXG4zLSBUaGUgd2hvbGUgc3RyaW5nIHBhc3NlZCB0byBTeXMuY29tbWFuZCBpcyB0aGVuIGVuY2xvc2VkIGluIGRvdWJsZVxuICAgcXVvdGVzLCB3aGljaCBhcmUgaW1tZWRpYXRlbHkgc3RyaXBwZWQgYnkgY21kLmV4ZS4gIE90aGVyd2lzZSxcbiAgIHNvbWUgb2YgdGhlIGRvdWJsZSBxdW90ZXMgZnJvbSBzdGVwIDIgYWJvdmUgY2FuIGJlIG1pc3BhcnNlZC5cbiAgIFNlZSBlLmcuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85OTY1MTQxXG4qKVxuICBsZXQgcXVvdGVfY21kIHMgPVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAoU3RyaW5nLmxlbmd0aCBzICsgMjApIGluXG4gICAgU3RyaW5nLml0ZXJcbiAgICAgIChmdW4gYyAtPlxuICAgICAgICBtYXRjaCBjIHdpdGhcbiAgICAgICAgfCAnKCcgfCAnKScgfCAnIScgfCAnXicgfCAnJScgfCAnXFxcIicgfCAnPCcgfCAnPicgfCAnJicgfCAnfCcgLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiICdeJzsgQnVmZmVyLmFkZF9jaGFyIGIgY1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBiIGMpXG4gICAgICBzO1xuICAgIEJ1ZmZlci5jb250ZW50cyBiXG4gIGxldCBxdW90ZV9jbWRfZmlsZW5hbWUgZiA9XG4gICAgaWYgU3RyaW5nLmNvbnRhaW5zIGYgJ1xcXCInIHx8IFN0cmluZy5jb250YWlucyBmICclJyB0aGVuXG4gICAgICBmYWlsd2l0aCAoXCJGaWxlbmFtZS5xdW90ZV9jb21tYW5kOiBiYWQgZmlsZSBuYW1lIFwiIF4gZilcbiAgICBlbHNlIGlmIFN0cmluZy5jb250YWlucyBmICcgJyB0aGVuXG4gICAgICBcIlxcXCJcIiBeIGYgXiBcIlxcXCJcIlxuICAgIGVsc2VcbiAgICAgIGZcbiAgKCogUmVkaXJlY3Rpb25zIGluIGNtZC5leGU6IHNlZSBodHRwczovL3NzNjQuY29tL250L3N5bnRheC1yZWRpcmVjdGlvbi5odG1sXG4gICAgIGFuZCBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9wcmV2aW91cy12ZXJzaW9ucy93aW5kb3dzL2l0LXByby93aW5kb3dzLXhwL2JiNDkwOTgyKHY9dGVjaG5ldC4xMClcbiAgKilcbiAgbGV0IHF1b3RlX2NvbW1hbmQgY21kID9zdGRpbiA/c3Rkb3V0ID9zdGRlcnIgYXJncyA9XG4gICAgU3RyaW5nLmNvbmNhdCBcIlwiIFtcbiAgICAgIFwiXFxcIlwiO1xuICAgICAgcXVvdGVfY21kX2ZpbGVuYW1lIGNtZDtcbiAgICAgIFwiIFwiO1xuICAgICAgcXVvdGVfY21kIChTdHJpbmcuY29uY2F0IFwiIFwiIChMaXN0Lm1hcCBxdW90ZSBhcmdzKSk7XG4gICAgICAobWF0Y2ggc3RkaW4gIHdpdGggTm9uZSAtPiBcIlwiIHwgU29tZSBmIC0+IFwiIDxcIiBeIHF1b3RlX2NtZF9maWxlbmFtZSBmKTtcbiAgICAgIChtYXRjaCBzdGRvdXQgd2l0aCBOb25lIC0+IFwiXCIgfCBTb21lIGYgLT4gXCIgPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgKG1hdGNoIHN0ZGVyciB3aXRoIE5vbmUgLT4gXCJcIiB8IFNvbWUgZiAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0ZGVyciA9IHN0ZG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gXCIgMj4mMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcIiAyPlwiIF4gcXVvdGVfY21kX2ZpbGVuYW1lIGYpO1xuICAgICAgXCJcXFwiXCJcbiAgICBdXG4gIGxldCBoYXNfZHJpdmUgcyA9XG4gICAgbGV0IGlzX2xldHRlciA9IGZ1bmN0aW9uXG4gICAgICB8ICdBJyAuLiAnWicgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgICAgIHwgXyAtPiBmYWxzZVxuICAgIGluXG4gICAgU3RyaW5nLmxlbmd0aCBzID49IDIgJiYgaXNfbGV0dGVyIHMuWzBdICYmIHMuWzFdID0gJzonXG4gIGxldCBkcml2ZV9hbmRfcGF0aCBzID1cbiAgICBpZiBoYXNfZHJpdmUgc1xuICAgIHRoZW4gKFN0cmluZy5zdWIgcyAwIDIsIFN0cmluZy5zdWIgcyAyIChTdHJpbmcubGVuZ3RoIHMgLSAyKSlcbiAgICBlbHNlIChcIlwiLCBzKVxuICBsZXQgZGlybmFtZSBzID1cbiAgICBsZXQgKGRyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBsZXQgZGlyID0gZ2VuZXJpY19kaXJuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoIGluXG4gICAgZHJpdmUgXiBkaXJcbiAgbGV0IGJhc2VuYW1lIHMgPVxuICAgIGxldCAoX2RyaXZlLCBwYXRoKSA9IGRyaXZlX2FuZF9wYXRoIHMgaW5cbiAgICBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZSBwYXRoXG5lbmRcblxubW9kdWxlIEN5Z3dpbiA6IFNZU0RFUFMgPSBzdHJ1Y3RcbiAgbGV0IG51bGwgPSBcIi9kZXYvbnVsbFwiXG4gIGxldCBjdXJyZW50X2Rpcl9uYW1lID0gXCIuXCJcbiAgbGV0IHBhcmVudF9kaXJfbmFtZSA9IFwiLi5cIlxuICBsZXQgZGlyX3NlcCA9IFwiL1wiXG4gIGxldCBpc19kaXJfc2VwID0gV2luMzIuaXNfZGlyX3NlcFxuICBsZXQgaXNfcmVsYXRpdmUgPSBXaW4zMi5pc19yZWxhdGl2ZVxuICBsZXQgaXNfaW1wbGljaXQgPSBXaW4zMi5pc19pbXBsaWNpdFxuICBsZXQgY2hlY2tfc3VmZml4ID0gV2luMzIuY2hlY2tfc3VmZml4XG4gIGxldCBjaG9wX3N1ZmZpeF9vcHQgPSBXaW4zMi5jaG9wX3N1ZmZpeF9vcHRcbiAgbGV0IHRlbXBfZGlyX25hbWUgPSBVbml4LnRlbXBfZGlyX25hbWVcbiAgbGV0IHF1b3RlID0gVW5peC5xdW90ZVxuICBsZXQgcXVvdGVfY29tbWFuZCA9IFVuaXgucXVvdGVfY29tbWFuZFxuICBsZXQgYmFzZW5hbWUgPSBnZW5lcmljX2Jhc2VuYW1lIGlzX2Rpcl9zZXAgY3VycmVudF9kaXJfbmFtZVxuICBsZXQgZGlybmFtZSA9IGdlbmVyaWNfZGlybmFtZSBpc19kaXJfc2VwIGN1cnJlbnRfZGlyX25hbWVcbmVuZFxuXG5tb2R1bGUgU3lzZGVwcyA9XG4gICh2YWwgKG1hdGNoIFN5cy5vc190eXBlIHdpdGhcbiAgICAgICB8IFwiV2luMzJcIiAtPiAobW9kdWxlIFdpbjMyOiBTWVNERVBTKVxuICAgICAgIHwgXCJDeWd3aW5cIiAtPiAobW9kdWxlIEN5Z3dpbjogU1lTREVQUylcbiAgICAgICB8IF8gLT4gKG1vZHVsZSBVbml4OiBTWVNERVBTKSkpXG5cbmluY2x1ZGUgU3lzZGVwc1xuXG5sZXQgY29uY2F0IGRpcm5hbWUgZmlsZW5hbWUgPVxuICBsZXQgbCA9IFN0cmluZy5sZW5ndGggZGlybmFtZSBpblxuICBpZiBsID0gMCB8fCBpc19kaXJfc2VwIGRpcm5hbWUgKGwtMSlcbiAgdGhlbiBkaXJuYW1lIF4gZmlsZW5hbWVcbiAgZWxzZSBkaXJuYW1lIF4gZGlyX3NlcCBeIGZpbGVuYW1lXG5cbmxldCBjaG9wX3N1ZmZpeCBuYW1lIHN1ZmYgPVxuICBsZXQgbiA9IFN0cmluZy5sZW5ndGggbmFtZSAtIFN0cmluZy5sZW5ndGggc3VmZiBpblxuICBpZiBuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiRmlsZW5hbWUuY2hvcF9zdWZmaXhcIiBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIG5cblxubGV0IGV4dGVuc2lvbl9sZW4gbmFtZSA9XG4gIGxldCByZWMgY2hlY2sgaTAgaSA9XG4gICAgaWYgaSA8IDAgfHwgaXNfZGlyX3NlcCBuYW1lIGkgdGhlbiAwXG4gICAgZWxzZSBpZiBuYW1lLltpXSA9ICcuJyB0aGVuIGNoZWNrIGkwIChpIC0gMSlcbiAgICBlbHNlIFN0cmluZy5sZW5ndGggbmFtZSAtIGkwXG4gIGluXG4gIGxldCByZWMgc2VhcmNoX2RvdCBpID1cbiAgICBpZiBpIDwgMCB8fCBpc19kaXJfc2VwIG5hbWUgaSB0aGVuIDBcbiAgICBlbHNlIGlmIG5hbWUuW2ldID0gJy4nIHRoZW4gY2hlY2sgaSAoaSAtIDEpXG4gICAgZWxzZSBzZWFyY2hfZG90IChpIC0gMSlcbiAgaW5cbiAgc2VhcmNoX2RvdCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gMSlcblxubGV0IGV4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBcIlwiIGVsc2UgU3RyaW5nLnN1YiBuYW1lIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKSBsXG5cbmxldCBjaG9wX2V4dGVuc2lvbiBuYW1lID1cbiAgbGV0IGwgPSBleHRlbnNpb25fbGVuIG5hbWUgaW5cbiAgaWYgbCA9IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZpbGVuYW1lLmNob3BfZXh0ZW5zaW9uXCJcbiAgZWxzZSBTdHJpbmcuc3ViIG5hbWUgMCAoU3RyaW5nLmxlbmd0aCBuYW1lIC0gbClcblxubGV0IHJlbW92ZV9leHRlbnNpb24gbmFtZSA9XG4gIGxldCBsID0gZXh0ZW5zaW9uX2xlbiBuYW1lIGluXG4gIGlmIGwgPSAwIHRoZW4gbmFtZSBlbHNlIFN0cmluZy5zdWIgbmFtZSAwIChTdHJpbmcubGVuZ3RoIG5hbWUgLSBsKVxuXG5leHRlcm5hbCBvcGVuX2Rlc2M6IHN0cmluZyAtPiBvcGVuX2ZsYWcgbGlzdCAtPiBpbnQgLT4gaW50ID0gXCJjYW1sX3N5c19vcGVuXCJcbmV4dGVybmFsIGNsb3NlX2Rlc2M6IGludCAtPiB1bml0ID0gXCJjYW1sX3N5c19jbG9zZVwiXG5cbmxldCBwcm5nID0gbGF6eShSYW5kb20uU3RhdGUubWFrZV9zZWxmX2luaXQgKCkpXG5cbmxldCB0ZW1wX2ZpbGVfbmFtZSB0ZW1wX2RpciBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJuZCA9IChSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSkgbGFuZCAweEZGRkZGRiBpblxuICBjb25jYXQgdGVtcF9kaXIgKFByaW50Zi5zcHJpbnRmIFwiJXMlMDZ4JXNcIiBwcmVmaXggcm5kIHN1ZmZpeClcblxuXG5sZXQgY3VycmVudF90ZW1wX2Rpcl9uYW1lID0gcmVmIHRlbXBfZGlyX25hbWVcblxubGV0IHNldF90ZW1wX2Rpcl9uYW1lIHMgPSBjdXJyZW50X3RlbXBfZGlyX25hbWUgOj0gc1xubGV0IGdldF90ZW1wX2Rpcl9uYW1lICgpID0gIWN1cnJlbnRfdGVtcF9kaXJfbmFtZVxuXG5sZXQgdGVtcF9maWxlID8odGVtcF9kaXIgPSAhY3VycmVudF90ZW1wX2Rpcl9uYW1lKSBwcmVmaXggc3VmZml4ID1cbiAgbGV0IHJlYyB0cnlfbmFtZSBjb3VudGVyID1cbiAgICBsZXQgbmFtZSA9IHRlbXBfZmlsZV9uYW1lIHRlbXBfZGlyIHByZWZpeCBzdWZmaXggaW5cbiAgICB0cnlcbiAgICAgIGNsb3NlX2Rlc2Mob3Blbl9kZXNjIG5hbWUgW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX2V4Y2xdIDBvNjAwKTtcbiAgICAgIG5hbWVcbiAgICB3aXRoIFN5c19lcnJvciBfIGFzIGUgLT5cbiAgICAgIGlmIGNvdW50ZXIgPj0gMTAwMCB0aGVuIHJhaXNlIGUgZWxzZSB0cnlfbmFtZSAoY291bnRlciArIDEpXG4gIGluIHRyeV9uYW1lIDBcblxubGV0IG9wZW5fdGVtcF9maWxlID8obW9kZSA9IFtPcGVuX3RleHRdKSA/KHBlcm1zID0gMG82MDApXG4gICAgICAgICAgICAgICAgICAgPyh0ZW1wX2RpciA9ICFjdXJyZW50X3RlbXBfZGlyX25hbWUpIHByZWZpeCBzdWZmaXggPVxuICBsZXQgcmVjIHRyeV9uYW1lIGNvdW50ZXIgPVxuICAgIGxldCBuYW1lID0gdGVtcF9maWxlX25hbWUgdGVtcF9kaXIgcHJlZml4IHN1ZmZpeCBpblxuICAgIHRyeVxuICAgICAgKG5hbWUsXG4gICAgICAgb3Blbl9vdXRfZ2VuIChPcGVuX3dyb25seTo6T3Blbl9jcmVhdDo6T3Blbl9leGNsOjptb2RlKSBwZXJtcyBuYW1lKVxuICAgIHdpdGggU3lzX2Vycm9yIF8gYXMgZSAtPlxuICAgICAgaWYgY291bnRlciA+PSAxMDAwIHRoZW4gcmFpc2UgZSBlbHNlIHRyeV9uYW1lIChjb3VudGVyICsgMSlcbiAgaW4gdHJ5X25hbWUgMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDb21wbGV4IG51bWJlcnMgKilcblxudHlwZSB0ID0geyByZTogZmxvYXQ7IGltOiBmbG9hdCB9XG5cbmxldCB6ZXJvID0geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxubGV0IG9uZSA9IHsgcmUgPSAxLjA7IGltID0gMC4wIH1cbmxldCBpID0geyByZSA9IDAuMDsgaW0gPSAxLjAgfVxuXG5sZXQgYWRkIHggeSA9IHsgcmUgPSB4LnJlICsuIHkucmU7IGltID0geC5pbSArLiB5LmltIH1cblxubGV0IHN1YiB4IHkgPSB7IHJlID0geC5yZSAtLiB5LnJlOyBpbSA9IHguaW0gLS4geS5pbSB9XG5cbmxldCBuZWcgeCA9IHsgcmUgPSAtLiB4LnJlOyBpbSA9IC0uIHguaW0gfVxuXG5sZXQgY29uaiB4ID0geyByZSA9IHgucmU7IGltID0gLS4geC5pbSB9XG5cbmxldCBtdWwgeCB5ID0geyByZSA9IHgucmUgKi4geS5yZSAtLiB4LmltICouIHkuaW07XG4gICAgICAgICAgICAgICAgaW0gPSB4LnJlICouIHkuaW0gKy4geC5pbSAqLiB5LnJlIH1cblxubGV0IGRpdiB4IHkgPVxuICBpZiBhYnNfZmxvYXQgeS5yZSA+PSBhYnNfZmxvYXQgeS5pbSB0aGVuXG4gICAgbGV0IHIgPSB5LmltIC8uIHkucmUgaW5cbiAgICBsZXQgZCA9IHkucmUgKy4gciAqLiB5LmltIGluXG4gICAgeyByZSA9ICh4LnJlICsuIHIgKi4geC5pbSkgLy4gZDtcbiAgICAgIGltID0gKHguaW0gLS4gciAqLiB4LnJlKSAvLiBkIH1cbiAgZWxzZVxuICAgIGxldCByID0geS5yZSAvLiB5LmltIGluXG4gICAgbGV0IGQgPSB5LmltICsuIHIgKi4geS5yZSBpblxuICAgIHsgcmUgPSAociAqLiB4LnJlICsuIHguaW0pIC8uIGQ7XG4gICAgICBpbSA9IChyICouIHguaW0gLS4geC5yZSkgLy4gZCB9XG5cbmxldCBpbnYgeCA9IGRpdiBvbmUgeFxuXG5sZXQgbm9ybTIgeCA9IHgucmUgKi4geC5yZSArLiB4LmltICouIHguaW1cblxubGV0IG5vcm0geCA9XG4gICgqIFdhdGNoIG91dCBmb3Igb3ZlcmZsb3cgaW4gY29tcHV0aW5nIHJlXjIgKyBpbV4yICopXG4gIGxldCByID0gYWJzX2Zsb2F0IHgucmUgYW5kIGkgPSBhYnNfZmxvYXQgeC5pbSBpblxuICBpZiByID0gMC4wIHRoZW4gaVxuICBlbHNlIGlmIGkgPSAwLjAgdGhlbiByXG4gIGVsc2UgaWYgciA+PSBpIHRoZW5cbiAgICBsZXQgcSA9IGkgLy4gciBpbiByICouIHNxcnQoMS4wICsuIHEgKi4gcSlcbiAgZWxzZVxuICAgIGxldCBxID0gciAvLiBpIGluIGkgKi4gc3FydCgxLjAgKy4gcSAqLiBxKVxuXG5sZXQgYXJnIHggPSBhdGFuMiB4LmltIHgucmVcblxubGV0IHBvbGFyIG4gYSA9IHsgcmUgPSBjb3MgYSAqLiBuOyBpbSA9IHNpbiBhICouIG4gfVxuXG5sZXQgc3FydCB4ID1cbiAgaWYgeC5yZSA9IDAuMCAmJiB4LmltID0gMC4wIHRoZW4geyByZSA9IDAuMDsgaW0gPSAwLjAgfVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBhYnNfZmxvYXQgeC5yZSBhbmQgaSA9IGFic19mbG9hdCB4LmltIGluXG4gICAgbGV0IHcgPVxuICAgICAgaWYgciA+PSBpIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHEgPSBpIC8uIHIgaW5cbiAgICAgICAgc3FydChyKSAqLiBzcXJ0KDAuNSAqLiAoMS4wICsuIHNxcnQoMS4wICsuIHEgKi4gcSkpKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IHEgPSByIC8uIGkgaW5cbiAgICAgICAgc3FydChpKSAqLiBzcXJ0KDAuNSAqLiAocSArLiBzcXJ0KDEuMCArLiBxICouIHEpKSlcbiAgICAgIGVuZCBpblxuICAgIGlmIHgucmUgPj0gMC4wXG4gICAgdGhlbiB7IHJlID0gdzsgIGltID0gMC41ICouIHguaW0gLy4gdyB9XG4gICAgZWxzZSB7IHJlID0gMC41ICouIGkgLy4gdzsgIGltID0gaWYgeC5pbSA+PSAwLjAgdGhlbiB3IGVsc2UgLS4gdyB9XG4gIGVuZFxuXG5sZXQgZXhwIHggPVxuICBsZXQgZSA9IGV4cCB4LnJlIGluIHsgcmUgPSBlICouIGNvcyB4LmltOyBpbSA9IGUgKi4gc2luIHguaW0gfVxuXG5sZXQgbG9nIHggPSB7IHJlID0gbG9nIChub3JtIHgpOyBpbSA9IGF0YW4yIHguaW0geC5yZSB9XG5cbmxldCBwb3cgeCB5ID0gZXhwIChtdWwgeSAobG9nIHgpKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgIEJlbm9pdCBWYXVnb24sIEVOU1RBICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBQYWRkaW5nIHBvc2l0aW9uLiAqKVxudHlwZSBwYWR0eSA9XG4gIHwgTGVmdCAgICgqIFRleHQgaXMgbGVmdCBqdXN0aWZpZWQgKCctJyBvcHRpb24pLiAgICAgICAgICAgICAgICopXG4gIHwgUmlnaHQgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIChubyAnLScgb3B0aW9uKS4gICAgICAgICAgICopXG4gIHwgWmVyb3MgICgqIFRleHQgaXMgcmlnaHQganVzdGlmaWVkIGJ5IHplcm9zIChzZWUgJzAnIG9wdGlvbikuICopXG5cbigqKiopXG5cbigqIEludGVnZXIgY29udmVyc2lvbi4gKilcbnR5cGUgaW50X2NvbnYgPVxuICB8IEludF9kIHwgSW50X3BkIHwgSW50X3NkICAgICAgICAoKiAgJWQgfCAlK2QgfCAlIGQgICopXG4gIHwgSW50X2kgfCBJbnRfcGkgfCBJbnRfc2kgICAgICAgICgqICAlaSB8ICUraSB8ICUgaSAgKilcbiAgfCBJbnRfeCB8IEludF9DeCAgICAgICAgICAgICAgICAgKCogICV4IHwgJSN4ICAgICAgICAqKVxuICB8IEludF9YIHwgSW50X0NYICAgICAgICAgICAgICAgICAoKiAgJVggfCAlI1ggICAgICAgICopXG4gIHwgSW50X28gfCBJbnRfQ28gICAgICAgICAgICAgICAgICgqICAlbyB8ICUjbyAgICAgICAgKilcbiAgfCBJbnRfdSAgICAgICAgICAgICAgICAgICAgICAgICAgKCogICV1ICAgICAgICAgICAgICAqKVxuICB8IEludF9DZCB8IEludF9DaSB8IEludF9DdSAgICAgICAoKiAgJSNkIHwgJSNpIHwgJSN1ICopXG5cbigqIEZsb2F0IGNvbnZlcnNpb24uICopXG50eXBlIGZsb2F0X2ZsYWdfY29udiA9XG4gIHwgRmxvYXRfZmxhZ18gICAgICAgICAgICAgICAgICAgICgqICVbZmVFZ0dGaEhdICopXG4gIHwgRmxvYXRfZmxhZ19wICAgICAgICAgICAgICAgICAgICgqICUrW2ZlRWdHRmhIXSAqKVxuICB8IEZsb2F0X2ZsYWdfcyAgICAgICAgICAgICAgICAgICAoKiAlIFtmZUVnR0ZoSF0gKilcbnR5cGUgZmxvYXRfa2luZF9jb252ID1cbiAgfCBGbG9hdF9mICAgICAgICAgICAgICAgICAgICAgICAgKCogICVmIHwgJStmIHwgJSBmICAqKVxuICB8IEZsb2F0X2UgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJWUgfCAlK2UgfCAlIGUgICopXG4gIHwgRmxvYXRfRSAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRSB8ICUrRSB8ICUgRSAgKilcbiAgfCBGbG9hdF9nICAgICAgICAgICAgICAgICAgICAgICAgKCogICVnIHwgJStnIHwgJSBnICAqKVxuICB8IEZsb2F0X0cgICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUcgfCAlK0cgfCAlIEcgICopXG4gIHwgRmxvYXRfRiAgICAgICAgICAgICAgICAgICAgICAgICgqICAlRiB8ICUrRiB8ICUgRiAgKilcbiAgfCBGbG9hdF9oICAgICAgICAgICAgICAgICAgICAgICAgKCogICVoIHwgJStoIHwgJSBoICAqKVxuICB8IEZsb2F0X0ggICAgICAgICAgICAgICAgICAgICAgICAoKiAgJUggfCAlK0ggfCAlIEggICopXG4gIHwgRmxvYXRfQ0YgICAgICAgICAgICAgICAgICAgICAgICgqICAlI0Z8ICUrI0Z8ICUgI0YgKilcbnR5cGUgZmxvYXRfY29udiA9IGZsb2F0X2ZsYWdfY29udiAqIGZsb2F0X2tpbmRfY29udlxuXG4oKioqKVxuXG4oKiBDaGFyIHNldHMgKHNlZSAlWy4uLl0pIGFyZSBiaXRtYXBzIGltcGxlbWVudGVkIGFzIDMyLWNoYXIgc3RyaW5ncy4gKilcbnR5cGUgY2hhcl9zZXQgPSBzdHJpbmdcblxuKCoqKilcblxuKCogQ291bnRlciB1c2VkIGluIFNjYW5mLiAqKVxudHlwZSBjb3VudGVyID1cbiAgfCBMaW5lX2NvdW50ZXIgICAgICgqICAlbCAgICAgICopXG4gIHwgQ2hhcl9jb3VudGVyICAgICAoKiAgJW4gICAgICAqKVxuICB8IFRva2VuX2NvdW50ZXIgICAgKCogICVOLCAlTCAgKilcblxuKCoqKilcblxuKCogUGFkZGluZyBvZiBzdHJpbmdzIGFuZCBudW1iZXJzLiAqKVxudHlwZSAoJ2EsICdiKSBwYWRkaW5nID1cbiAgKCogTm8gcGFkZGluZyAoZXg6IFwiJWRcIikgKilcbiAgfCBOb19wYWRkaW5nICA6ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogTGl0ZXJhbCBwYWRkaW5nIChleDogXCIlOGRcIikgKilcbiAgfCBMaXRfcGFkZGluZyA6IHBhZHR5ICogaW50IC0+ICgnYSwgJ2EpIHBhZGRpbmdcbiAgKCogUGFkZGluZyBhcyBleHRyYSBhcmd1bWVudCAoZXg6IFwiJSpkXCIpICopXG4gIHwgQXJnX3BhZGRpbmcgOiBwYWR0eSAtPiAoaW50IC0+ICdhLCAnYSkgcGFkZGluZ1xuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9kLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHBhZGRpbmcgb3B0aW9uIChubyBleHRyYSBhcmd1bWVudCkgKilcbnR5cGUgcGFkX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogUHJlY2lzaW9uIG9mIGZsb2F0cyBhbmQgJzAnLXBhZGRpbmcgb2YgaW50ZWdlcnMuICopXG50eXBlICgnYSwgJ2IpIHByZWNpc2lvbiA9XG4gICgqIE5vIHByZWNpc2lvbiAoZXg6IFwiJWZcIikgKilcbiAgfCBOb19wcmVjaXNpb24gOiAoJ2EsICdhKSBwcmVjaXNpb25cbiAgKCogTGl0ZXJhbCBwcmVjaXNpb24gKGV4OiBcIiUuM2ZcIikgKilcbiAgfCBMaXRfcHJlY2lzaW9uIDogaW50IC0+ICgnYSwgJ2EpIHByZWNpc2lvblxuICAoKiBQcmVjaXNpb24gYXMgZXh0cmEgYXJndW1lbnQgKGV4OiBcIiUuKmZcIikgKilcbiAgfCBBcmdfcHJlY2lzaW9uIDogKGludCAtPiAnYSwgJ2EpIHByZWNpc2lvblxuXG4oKiBTb21lIGZvcm1hdHMsIHN1Y2ggYXMgJV9mLFxuICAgb25seSBhY2NlcHQgYW4gb3B0aW9uYWwgbnVtYmVyIGFzIHByZWNpc2lvbiBvcHRpb24gKG5vIGV4dHJhIGFyZ3VtZW50KSAqKVxudHlwZSBwcmVjX29wdGlvbiA9IGludCBvcHRpb25cblxuKCogc2VlIHRoZSBDdXN0b20gZm9ybWF0IGNvbWJpbmF0b3IgKilcbnR5cGUgKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSA9XG4gIHwgQ3VzdG9tX3plcm8gOiAoJ2EsIHN0cmluZywgJ2EpIGN1c3RvbV9hcml0eVxuICB8IEN1c3RvbV9zdWNjIDogKCdhLCAnYiwgJ2MpIGN1c3RvbV9hcml0eSAtPlxuICAgICgnYSwgJ3ggLT4gJ2IsICd4IC0+ICdjKSBjdXN0b21fYXJpdHlcblxuKCoqKilcblxuKCogICAgICAgIFJlbGF0aW9uYWwgZm9ybWF0IHR5cGVzXG5cbkluIHRoZSBmaXJzdCBmb3JtYXQrZ2FkdHMgaW1wbGVtZW50YXRpb24sIHRoZSB0eXBlIGZvciAlKC4uJSkgaW4gdGhlXG5mbXQgR0FEVCB3YXMgYXMgZm9sbG93czpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqICgnZDEsICdxMSwgJ2QyLCAncTIpIHJlYWRlcl9uYl91bmlmaWVyICpcbiAgICAoJ3gsICdiLCAnYywgJ2QxLCAncTEsICd1KSBmbXR0eSAqXG4gICAgKCd1LCAnYiwgJ2MsICdxMSwgJ2UxLCAnZikgZm10IC0+XG4gICAgICAoKCd4LCAnYiwgJ2MsICdkMiwgJ3EyLCAndSkgZm9ybWF0NiAtPiAneCwgJ2IsICdjLCAnZDEsICdlMSwgJ2YpIGZtdFxuXG5Ob3RpY2UgdGhhdCB0aGUgJ3UgcGFyYW1ldGVyIGluICdmIHBvc2l0aW9uIGluIHRoZSBmb3JtYXQgYXJndW1lbnRcbigoJ3gsIC4uLCAndSkgZm9ybWF0NiAtPiAuLikgaXMgZXF1YWwgdG8gdGhlICd1IHBhcmFtZXRlciBpbiAnYVxucG9zaXRpb24gaW4gdGhlIGZvcm1hdCB0YWlsICgoJ3UsIC4uLCAnZikgZm10KS4gVGhpcyBtZWFucyB0aGF0IHRoZVxudHlwZSBvZiB0aGUgZXhwZWN0ZWQgZm9ybWF0IHBhcmFtZXRlciBkZXBlbmRzIG9mIHdoZXJlIHRoZSAlKC4uLiUpXG5hcmUgaW4gdGhlIGZvcm1hdCBzdHJpbmc6XG5cbiAgIyBQcmludGYucHJpbnRmIFwiJSglKVwiXG4gIC0gOiAodW5pdCwgb3V0X2NoYW5uZWwsIHVuaXQsICdfYSwgJ19hLCB1bml0KVxuICAgICAgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZvcm1hdDYgLT4gdW5pdFxuICA9IDxmdW4+XG4gICMgUHJpbnRmLnByaW50ZiBcIiUoJSklZFwiXG4gIC0gOiAoaW50IC0+IHVuaXQsIG91dF9jaGFubmVsLCB1bml0LCAnX2EsICdfYSwgaW50IC0+IHVuaXQpXG4gICAgICBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NiAtPiBpbnQgLT4gdW5pdFxuICA9IDxmdW4+XG5cbk9uIHRoZSBjb250cmFyeSwgdGhlIGxlZ2FjeSB0eXBlciBnaXZlcyBhIGNsZXZlciB0eXBlIHRoYXQgZG9lcyBub3RcbmRlcGVuZCBvbiB0aGUgcG9zaXRpb24gb2YgJSguLiUpIGluIHRoZSBmb3JtYXQgc3RyaW5nLiBGb3IgZXhhbXBsZSxcbiUoJSkgd2lsbCBoYXZlIHRoZSBwb2x5bW9ycGhpYyB0eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKTogaXQgY2FuXG5iZSBjb25jYXRlbmF0ZWQgdG8gYW55IGZvcm1hdCB0eXBlLCBhbmQgb25seSBlbmZvcmNlcyB0aGUgY29uc3RyYWludFxudGhhdCBpdHMgJ2EgYW5kICdmIHBhcmFtZXRlcnMgYXJlIGVxdWFsIChubyBmb3JtYXQgYXJndW1lbnRzKSBhbmQgJ2RcbmFuZCAnZSBhcmUgZXF1YWwgKG5vIHJlYWRlciBhcmd1bWVudCkuXG5cblRoZSB3ZWFrZW5pbmcgb2YgdGhpcyBwYXJhbWV0ZXIgdHlwZSBpbiB0aGUgR0FEVCB2ZXJzaW9uIGJyb2tlIHVzZXJcbmNvZGUgKGluIGZhY3QgaXQgZXNzZW50aWFsbHkgbWFkZSAlKC4uLiUpIHVudXNhYmxlIGV4Y2VwdCBhdCB0aGUgbGFzdFxucG9zaXRpb24gb2YgYSBmb3JtYXQpLiBJbiBwYXJ0aWN1bGFyLCB0aGUgZm9sbG93aW5nIHdvdWxkIG5vdCB3b3JrXG5hbnltb3JlOlxuXG4gIGZ1biBzZXAgLT5cbiAgICBGb3JtYXQucHJpbnRmIFwiZm9vJSglKWJhciUoJSliYXpcIiBzZXAgc2VwXG5cbkFzIHRoZSB0eXBlLWNoZWNrZXIgd291bGQgcmVxdWlyZSB0d28gKmluY29tcGF0aWJsZSogdHlwZXMgZm9yIHRoZSAlKCUpXG5pbiBkaWZmZXJlbnQgcG9zaXRpb25zLlxuXG5UaGUgc29sdXRpb24gdG8gcmVnYWluIGEgZ2VuZXJhbCB0eXBlIGZvciAlKC4uJSkgaXMgdG8gZ2VuZXJhbGl6ZSB0aGlzXG50ZWNobmlxdWUsIG5vdCBvbmx5IG9uIHRoZSAnZCwgJ2UgcGFyYW1ldGVycywgYnV0IG9uIGFsbCBzaXhcbnBhcmFtZXRlcnMgb2YgYSBmb3JtYXQ6IHdlIGludHJvZHVjZSBhIFwicmVsYXRpb25hbFwiIHR5cGVcbiAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbndob3NlIHZhbHVlcyBhcmUgcHJvb2ZzIHRoYXQgKCdhMSwgLi4sICdmMSkgYW5kICgnYTIsIC4uLCAnZjIpIG1vcmFsbHlcbmNvcnJlc3BvbmQgdG8gdGhlIHNhbWUgZm9ybWF0IHR5cGU6ICdhMSBpcyBvYnRhaW5lZCBmcm9tICdmMSwnYjEsJ2MxXG5pbiB0aGUgZXhhY3Qgc2FtZSB3YXkgdGhhdCAnYTIgaXMgb2J0YWluZWQgZnJvbSAnZjIsJ2IyLCdjMiwgZXRjLlxuXG5Gb3IgZXhhbXBsZSwgdGhlIHJlbGF0aW9uIGJldHdlZW4gdHdvIGZvcm1hdCB0eXBlcyBiZWdpbm5pbmcgd2l0aCBhIENoYXJcbnBhcmFtZXRlciBpcyBhcyBmb2xsb3dzOlxuXG58IENoYXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYyAgKilcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKGNoYXIgLT4gJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgY2hhciAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcblxuSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIHRlcm0gc3RydWN0dXJlIG9mIGZtdHR5X3JlbCBpcyAoYWxtb3N0WzFdKVxuaXNvbW9ycGhpYyB0byB0aGUgZm10dHkgb2YgdGhlIHByZXZpb3VzIGltcGxlbWVudGF0aW9uOiBldmVyeVxuY29uc3RydWN0b3IgaXMgcmUtcmVhZCB3aXRoIGEgYmluYXJ5LCByZWxhdGlvbmFsIHR5cGUsIGluc3RlYWQgb2YgdGhlXG5wcmV2aW91cyB1bmFyeSB0eXBpbmcuIGZtdHR5IGNhbiB0aGVuIGJlIHJlLWRlZmluZWQgYXMgdGhlIGRpYWdvbmFsIG9mXG5mbXR0eV9yZWw6XG5cbiAgdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHkgPVxuICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgICAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eV9yZWxcblxuT25jZSB3ZSBoYXZlIHRoaXMgZm10dHlfcmVsIHR5cGUgaW4gcGxhY2UsIHdlIGNhbiBnaXZlIHRoZSBtb3JlXG5nZW5lcmFsIHR5cGUgdG8gJSguLi4lKTpcblxufCBGb3JtYXRfc3Vic3QgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlKC4uLiUpICopXG4gICAgcGFkX29wdGlvbiAqXG4gICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wsXG4gICAgICdnMiwgJ2IsICdjLCAnajIsICdkLCAnYSkgZm10dHlfcmVsICpcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IsICdjLCAnajIsICdlLCAnZikgZm10XG5cbldlIGFjY2VwdCBhbnkgZm9ybWF0ICgoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NikgKHRoaXMgaXNcbmNvbXBsZXRlbHkgdW5yZWxhdGVkIHRvIHRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IGZvcm1hdCksIGJ1dCBhbHNvXG5yZXF1aXJlIGEgcHJvb2YgdGhhdCB0aGlzIGZvcm1hdCBpcyBpbiByZWxhdGlvbiB0byBhbm90aGVyIGZvcm1hdCB0aGF0XG5pcyBjb25jYXRlbmFibGUgdG8gdGhlIGZvcm1hdCB0YWlsLiBXaGVuIGV4ZWN1dGluZyBhICUoLi4uJSkgZm9ybWF0XG4oaW4gY2FtbGludGVybmFsRm9ybWF0Lm1sOm1ha2VfcHJpbnRmIG9yIHNjYW5mLm1sOm1ha2Vfc2NhbmYpLCB3ZVxudHJhbnN0eXBlIHRoZSBmb3JtYXQgYWxvbmcgdGhpcyByZWxhdGlvbiB1c2luZyB0aGUgJ3JlY2FzdCcgZnVuY3Rpb25cbnRvIHRyYW5zcG9zZSBiZXR3ZWVuIHJlbGF0ZWQgZm9ybWF0IHR5cGVzLlxuXG4gIHZhbCByZWNhc3QgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSkgZm10XG4gIC0+ICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIC0+ICgnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXRcblxuTk9URSBbMV06IHRoZSB0eXBpbmcgb2YgRm9ybWF0X3N1YnN0X3R5IHJlcXVpcmVzIG5vdCBvbmUgZm9ybWF0IHR5cGUsIGJ1dFxudHdvLCBvbmUgdG8gZXN0YWJsaXNoIHRoZSBsaW5rIGJldHdlZW4gdGhlIGZvcm1hdCBhcmd1bWVudCBhbmQgdGhlXG5maXJzdCBzaXggcGFyYW1ldGVycywgYW5kIHRoZSBvdGhlciBmb3IgdGhlIGxpbmsgYmV0d2VlbiB0aGUgZm9ybWF0XG5hcmd1bWVudCBhbmQgdGhlIGxhc3Qgc2l4IHBhcmFtZXRlcnMuXG5cbnwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZDEsICdhMSkgZm10dHlfcmVsICpcbiAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgJ2cyLCAnYjIsICdjMiwgJ2oyLCAnZDIsICdhMikgZm10dHlfcmVsICpcbiAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2UxLCAnZjEsXG4gICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdnMiwgJ2IyLCAnYzIsICdqMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG5XaGVuIHdlIGdlbmVyYXRlIGEgZm9ybWF0IEFTVCwgd2UgZ2VuZXJhdGUgZXhhY3RseSB0aGUgc2FtZSB3aXRuZXNzXG5mb3IgYm90aCByZWxhdGlvbnMsIGFuZCB0aGUgd2l0bmVzcy1jb252ZXJzaW9uIGZ1bmN0aW9ucyBpblxuY2FtbGludGVybmFsRm9ybWF0IGRvIHJlbHkgb24gdGhpcyBpbnZhcmlhbnQuIEZvciBleGFtcGxlLCB0aGVcbmZ1bmN0aW9uIHRoYXQgcHJvdmVzIHRoYXQgdGhlIHJlbGF0aW9uIGlzIHRyYW5zaXRpdmVcblxuICB2YWwgdHJhbnMgOlxuICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICAtPiAoJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMixcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuICAtPiAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICdhMywgJ2IzLCAnYzMsICdkMywgJ2UzLCAnZjMpIGZtdHR5X3JlbFxuXG5kb2VzIGFzc3VtZSB0aGF0IHRoZSB0d28gaW5wdXRzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSB0ZXJtIHN0cnVjdHVyZVxuKGFuZCBpcyBvbmx5IGV2ZXJ5IHVzZWQgZm9yIGFyZ3VtZW50IHdpdG5lc3NlcyBvZiB0aGVcbkZvcm1hdF9zdWJzdF90eSBjb25zdHJ1Y3RvcikuXG4qKVxuXG4oKiBUeXBlIG9mIGEgYmxvY2sgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBibG9ja190eXBlID1cbiAgfCBQcF9oYm94ICAgKCogSG9yaXpvbnRhbCBibG9jayBubyBsaW5lIGJyZWFraW5nICopXG4gIHwgUHBfdmJveCAgICgqIFZlcnRpY2FsIGJsb2NrIGVhY2ggYnJlYWsgbGVhZHMgdG8gYSBuZXcgbGluZSAqKVxuICB8IFBwX2h2Ym94ICAoKiBIb3Jpem9udGFsLXZlcnRpY2FsIGJsb2NrOiBzYW1lIGFzIHZib3gsIGV4Y2VwdCBpZiB0aGlzIGJsb2NrXG4gICAgICAgICAgICAgICAgIGlzIHNtYWxsIGVub3VnaCB0byBmaXQgb24gYSBzaW5nbGUgbGluZSAqKVxuICB8IFBwX2hvdmJveCAoKiBIb3Jpem9udGFsIG9yIFZlcnRpY2FsIGJsb2NrOiBicmVha3MgbGVhZCB0byBuZXcgbGluZVxuICAgICAgICAgICAgICAgICBvbmx5IHdoZW4gbmVjZXNzYXJ5IHRvIHByaW50IHRoZSBjb250ZW50IG9mIHRoZSBibG9jayAqKVxuICB8IFBwX2JveCAgICAoKiBIb3Jpem9udGFsIG9yIEluZGVudCBibG9jazogYnJlYWtzIGxlYWQgdG8gbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgb25seSB3aGVuIG5lY2Vzc2FyeSB0byBwcmludCB0aGUgY29udGVudCBvZiB0aGUgYmxvY2ssIG9yXG4gICAgICAgICAgICAgICAgIHdoZW4gaXQgbGVhZHMgdG8gYSBuZXcgaW5kZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgbGluZSAqKVxuICB8IFBwX2ZpdHMgICAoKiBJbnRlcm5hbCB1c2FnZTogd2hlbiBhIGJsb2NrIGZpdHMgb24gYSBzaW5nbGUgbGluZSAqKVxuXG4oKiBGb3JtYXR0aW5nIGVsZW1lbnQgdXNlZCBieSB0aGUgRm9ybWF0IHByZXR0eS1wcmludGVyLiAqKVxudHlwZSBmb3JtYXR0aW5nX2xpdCA9XG4gIHwgQ2xvc2VfYm94ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBdICAgKilcbiAgfCBDbG9zZV90YWcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQH0gICAqKVxuICB8IEJyZWFrIG9mIHN0cmluZyAqIGludCAqIGludCAgICAgICAgICAoKiBALCB8IEAgIHwgQDsgfCBAOzw+ICopXG4gIHwgRkZsdXNoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEA/ICAgKilcbiAgfCBGb3JjZV9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQFxcbiAgKilcbiAgfCBGbHVzaF9uZXdsaW5lICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQC4gICAqKVxuICB8IE1hZ2ljX3NpemUgb2Ygc3RyaW5nICogaW50ICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAPG4+ICopXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBAICAgKilcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQCUlICAqKVxuICB8IFNjYW5faW5kaWMgb2YgY2hhciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBAWCAgICopXG5cbigqIEZvcm1hdHRpbmcgZWxlbWVudCB1c2VkIGJ5IHRoZSBGb3JtYXQgcHJldHR5LXByaW50ZXIuICopXG50eXBlICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlbiA9XG4gIHwgT3Blbl90YWcgOiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPiAgICAgICgqIEB7ICAgKilcbiAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0dGluZ19nZW5cbiAgfCBPcGVuX2JveCA6ICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICAgICAgKCogQFsgICAqKVxuICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXR0aW5nX2dlblxuXG4oKioqKVxuXG4oKiBMaXN0IG9mIGZvcm1hdCB0eXBlIGVsZW1lbnRzLiAqKVxuKCogSW4gcGFydGljdWxhciB1c2VkIHRvIHJlcHJlc2VudCAlKC4uLiUpIGFuZCAley4uLiV9IGNvbnRlbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXR0eSA9XG4gICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmLFxuICAgICAgJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10dHlfcmVsXG5hbmQgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCA9XG4gIHwgQ2hhcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoY2hhciAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGNoYXIgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgU3RyaW5nX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoc3RyaW5nIC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgc3RyaW5nIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQzMl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJWxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQzMiAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDMyIC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IE5hdGl2ZWludF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbmQgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKG5hdGl2ZWludCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIG5hdGl2ZWludCAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBJbnQ2NF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJUxkICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgIChpbnQ2NCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGludDY0IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IEZsb2F0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlZiAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKGZsb2F0IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgZmxvYXQgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgQm9vbF90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVCICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoYm9vbCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgIGJvb2wgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBGb3JtYXRfYXJnX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJXsuLi4lfSAqKVxuICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZtdHR5ICpcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmb3JtYXQ2IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMilcbiAgICAgICAgICAgZm10dHlfcmVsXG4gIHwgRm9ybWF0X3N1YnN0X3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICUoLi4uJSkgKilcbiAgICAgICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsLFxuICAgICAgICdnMSwgJ2IxLCAnYzEsICdqMSwgJ2QxLCAnYTEpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiMiwgJ2MyLCAnajIsICdkMiwgJ2EyKSBmbXR0eV9yZWwgKlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cxLCAnYjEsICdjMSwgJ2oxLCAnZTEsICdmMSxcbiAgICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm9ybWF0NiAtPiAnZzIsICdiMiwgJ2MyLCAnajIsICdlMiwgJ2YyKVxuICAgICAgICAgICBmbXR0eV9yZWxcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3RvcnMuICopXG4gIHwgQWxwaGFfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVhICAqKVxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsIC0+XG4gICAgICAoKCdiMSAtPiAneCAtPiAnYzEpIC0+ICd4IC0+ICdhMSwgJ2IxLCAnYzEsICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgKCdiMiAtPiAneCAtPiAnYzIpIC0+ICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuICB8IFRoZXRhX3R5IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCgnYjEgLT4gJ2MxKSAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICgnYjIgLT4gJ2MyKSAtPiAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWxcbiAgfCBBbnlfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFVzZWQgZm9yIGN1c3RvbSBmb3JtYXRzICopXG4gICAgICAoJ2ExLCAnYjEsICdjMSwgJ2QxLCAnZTEsICdmMSxcbiAgICAgICAnYTIsICdiMiwgJ2MyLCAnZDIsICdlMiwgJ2YyKSBmbXR0eV9yZWwgLT5cbiAgICAgICgneCAtPiAnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICd4IC0+ICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbFxuXG4gICgqIFNjYW5mIHNwZWNpZmljIGNvbnN0cnVjdG9yLiAqKVxuICB8IFJlYWRlcl90eSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCd4IC0+ICdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ3ggLT4gJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfciAgKilcbiAgICAgICgnYTEsICdiMSwgJ2MxLCAnZDEsICdlMSwgJ2YxLFxuICAgICAgICdhMiwgJ2IyLCAnYzIsICdkMiwgJ2UyLCAnZjIpIGZtdHR5X3JlbCAtPlxuICAgICAgKCdhMSwgJ2IxLCAnYzEsICgnYjEgLT4gJ3gpIC0+ICdkMSwgJ2UxLCAnZjEsXG4gICAgICAgJ2EyLCAnYjIsICdjMiwgKCdiMiAtPiAneCkgLT4gJ2QyLCAnZTIsICdmMikgZm10dHlfcmVsXG5cbiAgfCBFbmRfb2ZfZm10dHkgOlxuICAgICAgKCdmMSwgJ2IxLCAnYzEsICdkMSwgJ2QxLCAnZjEsXG4gICAgICAgJ2YyLCAnYjIsICdjMiwgJ2QyLCAnZDIsICdmMikgZm10dHlfcmVsXG5cbigqKiopXG5cbigqIExpc3Qgb2YgZm9ybWF0IGVsZW1lbnRzLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgPVxuICB8IENoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfY2hhciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVDICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChjaGFyIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFN0cmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVzICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENhbWxfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVTICopXG4gICAgICAoJ3gsIHN0cmluZyAtPiAnYSkgcGFkZGluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEludCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlbFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDMyIC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgTmF0aXZlaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJW5bZGl4WHVvXSAqKVxuICAgICAgaW50X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBuYXRpdmVpbnQgLT4gJ2EpIHByZWNpc2lvbiAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlTFtkaXhYdW9dICopXG4gICAgICBpbnRfY29udiAqICgneCwgJ3kpIHBhZGRpbmcgKiAoJ3ksIGludDY0IC0+ICdhKSBwcmVjaXNpb24gKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ3gsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRmxvYXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJVtmZUVnR0ZoSF0gKilcbiAgICAgIGZsb2F0X2NvbnYgKiAoJ3gsICd5KSBwYWRkaW5nICogKCd5LCBmbG9hdCAtPiAnYSkgcHJlY2lzaW9uICpcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCd4LCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IEJvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbYkJdICopXG4gICAgICAoJ3gsIGJvb2wgLT4gJ2EpIHBhZGRpbmcgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBGbHVzaCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlISAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBhYmMgKilcbiAgICAgIHN0cmluZyAqICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXQgLT5cbiAgICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IENoYXJfbGl0ZXJhbCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIHggKilcbiAgICAgIGNoYXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICB8IEZvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICV7Li4uJX0gKilcbiAgICAgIHBhZF9vcHRpb24gKiAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCkgZm10dHkgKlxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJSguLi4lKSAqKVxuICAgICAgcGFkX29wdGlvbiAqXG4gICAgICAoJ2csICdoLCAnaSwgJ2osICdrLCAnbCxcbiAgICAgICAnZzIsICdiLCAnYywgJ2oyLCAnZCwgJ2EpIGZtdHR5X3JlbCAqXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoKCdnLCAnaCwgJ2ksICdqLCAnaywgJ2wpIGZvcm1hdDYgLT4gJ2cyLCAnYiwgJ2MsICdqMiwgJ2UsICdmKSBmbXRcblxuICAoKiBQcmludGYgYW5kIEZvcm1hdCBzcGVjaWZpYyBjb25zdHJ1Y3Rvci4gKilcbiAgfCBBbHBoYSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlYSAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICd4IC0+ICdjKSAtPiAneCAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBUaGV0YSA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAldCAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoKCdiIC0+ICdjKSAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBGb3JtYXQgc3BlY2lmaWMgY29uc3RydWN0b3I6ICopXG4gIHwgRm9ybWF0dGluZ19saXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogQF8gKilcbiAgICAgIGZvcm1hdHRpbmdfbGl0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgRm9ybWF0dGluZ19nZW4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEBfICopXG4gICAgICAoJ2ExLCAnYiwgJ2MsICdkMSwgJ2UxLCAnZjEpIGZvcm1hdHRpbmdfZ2VuICpcbiAgICAgICgnZjEsICdiLCAnYywgJ2UxLCAnZTIsICdmMikgZm10IC0+ICgnYTEsICdiLCAnYywgJ2QxLCAnZTIsICdmMikgZm10XG5cbiAgKCogU2NhbmYgc3BlY2lmaWMgY29uc3RydWN0b3JzOiAqKVxuICB8IFJlYWRlciA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVyICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgICgneCAtPiAnYSwgJ2IsICdjLCAoJ2IgLT4gJ3gpIC0+ICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fY2hhcl9zZXQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0ICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAtPlxuICAgICAgICAoc3RyaW5nIC0+ICdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVbbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAgIChpbnQgLT4gJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG4gIHwgU2Nhbl9uZXh0X2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJTBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoY2hhciAtPiAnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcbiAgfCBJZ25vcmVkX3BhcmFtIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXyAqKVxuICAgICAgKCdhLCAnYiwgJ2MsICdkLCAneSwgJ3gpIGlnbm9yZWQgKiAoJ3gsICdiLCAnYywgJ3ksICdlLCAnZikgZm10IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmbXRcblxuICAoKiBDdXN0b20gcHJpbnRpbmcgZm9ybWF0IChQUiM2NDUyLCBHUFIjMTQwKVxuXG4gICAgIFdlIGluY2x1ZGUgYSB0eXBlIEN1c3RvbSBvZiBcImN1c3RvbSBjb252ZXJ0ZXJzXCIsIHdoZXJlIGFuXG4gICAgIGFyYml0cmFyeSBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBjb252ZXJ0IG9uZSBvciBtb3JlXG4gICAgIGFyZ3VtZW50cy4gVGhlcmUgaXMgbm8gc3ludGF4IGZvciBjdXN0b20gY29udmVydGVycywgaXQgaXMgb25seVxuICAgICBpbnRlbmRlZCBmb3IgY3VzdG9tIHByb2Nlc3NvcnMgdGhhdCB3aXNoIHRvIHJlbHkgb24gdGhlXG4gICAgIHN0ZGxpYi1kZWZpbmVkIGZvcm1hdCBHQURUcy5cblxuICAgICBGb3IgaW5zdGFuY2UgYSBwcmUtcHJvY2Vzc29yIGNvdWxkIGNob29zZSB0byBpbnRlcnByZXQgc3RyaW5nc1xuICAgICBwcmVmaXhlZCB3aXRoIFtcIiFcIl0gYXMgZm9ybWF0IHN0cmluZ3Mgd2hlcmUgWyV7eyAuLi4gfX1dIGlzXG4gICAgIGEgc3BlY2lhbCBmb3JtIHRvIHBhc3MgYSB0b19zdHJpbmcgZnVuY3Rpb24sIHNvIHRoYXQgb25lIGNvdWxkXG4gICAgIHdyaXRlOlxuXG4gICAgIHtbXG4gICAgICAgdHlwZSB0ID0geyB4IDogaW50OyB5IDogaW50IH1cblxuICAgICAgIGxldCBzdHJpbmdfb2ZfdCB0ID0gUHJpbnRmLnNwcmludGYgXCJ7IHggPSAlZDsgeSA9ICVkIH1cIiB0LnggdC55XG5cbiAgICAgICBQcmludGYucHJpbnRmICFcInQgPSAle3tzdHJpbmdfb2ZfdH19XCIgeyB4ID0gNDI7IHkgPSA0MiB9XG4gICAgIF19XG4gICopXG4gIHwgQ3VzdG9tIDpcbiAgICAgICgnYSwgJ3gsICd5KSBjdXN0b21fYXJpdHkgKiAodW5pdCAtPiAneCkgKiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm10IC0+XG4gICAgICAoJ3ksICdiLCAnYywgJ2QsICdlLCAnZikgZm10XG5cbiAgKCogZW5kIG9mIGEgZm9ybWF0IHNwZWNpZmljYXRpb24gKilcbiAgfCBFbmRfb2ZfZm9ybWF0IDpcbiAgICAgICAgKCdmLCAnYiwgJ2MsICdlLCAnZSwgJ2YpIGZtdFxuXG4oKioqKVxuXG4oKiBUeXBlIGZvciBpZ25vcmVkIHBhcmFtZXRlcnMgKHNlZSBcIiVfXCIpLiAqKVxuYW5kICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkID1cbiAgfCBJZ25vcmVkX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX2MgKilcbiAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9DICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfc3RyaW5nIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfcyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfY2FtbF9zdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfUyAqKVxuICAgICAgcGFkX29wdGlvbiAtPiAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfaW50IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQzMiA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9sZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9uZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9pbnQ2NCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9MZCAqKVxuICAgICAgaW50X2NvbnYgKiBwYWRfb3B0aW9uIC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9mbG9hdCA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9mICopXG4gICAgICBwYWRfb3B0aW9uICogcHJlY19vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Jvb2wgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX0IgKilcbiAgICAgIHBhZF9vcHRpb24gLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX2Zvcm1hdF9hcmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlX3suLi4lfSAqKVxuICAgICAgcGFkX29wdGlvbiAqICgnZywgJ2gsICdpLCAnaiwgJ2ssICdsKSBmbXR0eSAtPlxuICAgICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuICB8IElnbm9yZWRfZm9ybWF0X3N1YnN0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgqICVfKC4uLiUpICopXG4gICAgICBwYWRfb3B0aW9uICogKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdHR5IC0+XG4gICAgICAgICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9yZWFkZXIgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9yICopXG4gICAgICAoJ2EsICdiLCAnYywgKCdiIC0+ICd4KSAtPiAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bLi4uXSAqKVxuICAgICAgcGFkX29wdGlvbiAqIGNoYXJfc2V0IC0+ICgnYSwgJ2IsICdjLCAnZCwgJ2QsICdhKSBpZ25vcmVkXG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCogJV9bbmxOTF0gKilcbiAgICAgIGNvdW50ZXIgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZCwgJ2EpIGlnbm9yZWRcbiAgfCBJZ25vcmVkX3NjYW5fbmV4dF9jaGFyIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiAlXzBjICopXG4gICAgICAoJ2EsICdiLCAnYywgJ2QsICdkLCAnYSkgaWdub3JlZFxuXG5hbmQgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgPVxuICBGb3JtYXQgb2YgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZtdCAqIHN0cmluZ1xuXG5sZXQgcmVjIGVyYXNlX3JlbCA6IHR5cGUgYSBiIGMgZCBlIGYgZyBoIGkgaiBrIGwgLlxuICAoYSwgYiwgYywgZCwgZSwgZixcbiAgIGcsIGgsIGksIGosIGssIGwpIGZtdHR5X3JlbCAtPiAoYSwgYiwgYywgZCwgZSwgZikgZm10dHlcbj0gZnVuY3Rpb25cbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBTdHJpbmdfdHkgcmVzdCAtPlxuICAgIFN0cmluZ190eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50X3R5IHJlc3QgLT5cbiAgICBJbnRfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBOYXRpdmVpbnRfdHkgcmVzdCAtPlxuICAgIE5hdGl2ZWludF90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBCb29sX3R5IHJlc3QgLT5cbiAgICBCb29sX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIF90eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MSwgZXJhc2VfcmVsIHJlc3QpXG4gIHwgQWxwaGFfdHkgcmVzdCAtPlxuICAgIEFscGhhX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBUaGV0YV90eSByZXN0IC0+XG4gICAgVGhldGFfdHkgKGVyYXNlX3JlbCByZXN0KVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBSZWFkZXJfdHkgcmVzdCAtPlxuICAgIFJlYWRlcl90eSAoZXJhc2VfcmVsIHJlc3QpXG4gIHwgSWdub3JlZF9yZWFkZXJfdHkgcmVzdCAtPlxuICAgIElnbm9yZWRfcmVhZGVyX3R5IChlcmFzZV9yZWwgcmVzdClcbiAgfCBFbmRfb2ZfZm10dHkgLT4gRW5kX29mX2ZtdHR5XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCogRm9ybWF0IHR5cGUgY29uY2F0ZW5hdGlvbiAqKVxuXG4oKiBDb25jYXRlbmF0ZSB0d28gZm9ybWF0IHR5cGVzLiAqKVxuKCogVXNlZCBieTpcbiAgICogcmVhZGVyX25iX3VuaWZpZXJfb2ZfZm10dHkgdG8gY291bnQgcmVhZGVycyBpbiBhbiBmbXR0eSxcbiAgICogU2NhbmYudGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyB0byBleHRyYWN0IHJlYWRlcnMgaW5zaWRlICUoLi4uJSksXG4gICAqIENhbWxpbnRlcm5hbEZvcm1hdC5mbXR0eV9vZl9pZ25vcmVkX2Zvcm1hdCB0byBleHRyYWN0IGZvcm1hdCB0eXBlLiAqKVxuXG4oKlxubGV0IHJlYyBjb25jYXRfZm10dHkgOiB0eXBlIGEgYiBjIGQgZSBmIGcgaCAuXG4gICAgKGEsIGIsIGMsIGQsIGUsIGYpIGZtdHR5IC0+XG4gICAgKGYsIGIsIGMsIGUsIGcsIGgpIGZtdHR5IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdHR5ID1cbiopXG5sZXQgcmVjIGNvbmNhdF9mbXR0eSA6XG4gIHR5cGUgYTEgYjEgYzEgZDEgZTEgZjFcbiAgICAgICBhMiBiMiBjMiBkMiBlMiBmMlxuICAgICAgIGcxIGoxIGcyIGoyXG4gIC5cbiAgICAoZzEsIGIxLCBjMSwgajEsIGQxLCBhMSxcbiAgICAgZzIsIGIyLCBjMiwgajIsIGQyLCBhMikgZm10dHlfcmVsIC0+XG4gICAgKGExLCBiMSwgYzEsIGQxLCBlMSwgZjEsXG4gICAgIGEyLCBiMiwgYzIsIGQyLCBlMiwgZjIpIGZtdHR5X3JlbCAtPlxuICAgIChnMSwgYjEsIGMxLCBqMSwgZTEsIGYxLFxuICAgICBnMiwgYjIsIGMyLCBqMiwgZTIsIGYyKSBmbXR0eV9yZWwgPVxuZnVuIGZtdHR5MSBmbXR0eTIgLT4gbWF0Y2ggZm10dHkxIHdpdGhcbiAgfCBDaGFyX3R5IHJlc3QgLT5cbiAgICBDaGFyX3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgU3RyaW5nX3R5IHJlc3QgLT5cbiAgICBTdHJpbmdfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJbnRfdHkgcmVzdCAtPlxuICAgIEludF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEludDMyX3R5IHJlc3QgLT5cbiAgICBJbnQzMl90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IE5hdGl2ZWludF90eSByZXN0IC0+XG4gICAgTmF0aXZlaW50X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgSW50NjRfdHkgcmVzdCAtPlxuICAgIEludDY0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgRmxvYXRfdHkgcmVzdCAtPlxuICAgIEZsb2F0X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgQm9vbF90eSByZXN0IC0+XG4gICAgQm9vbF90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFscGhhX3R5IHJlc3QgLT5cbiAgICBBbHBoYV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IFRoZXRhX3R5IHJlc3QgLT5cbiAgICBUaGV0YV90eSAoY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEFueV90eSByZXN0IC0+XG4gICAgQW55X3R5IChjb25jYXRfZm10dHkgcmVzdCBmbXR0eTIpXG4gIHwgUmVhZGVyX3R5IHJlc3QgLT5cbiAgICBSZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBJZ25vcmVkX3JlYWRlcl90eSByZXN0IC0+XG4gICAgSWdub3JlZF9yZWFkZXJfdHkgKGNvbmNhdF9mbXR0eSByZXN0IGZtdHR5MilcbiAgfCBGb3JtYXRfYXJnX3R5ICh0eSwgcmVzdCkgLT5cbiAgICBGb3JtYXRfYXJnX3R5ICh0eSwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEZvcm1hdF9zdWJzdF90eSAodHkxLCB0eTIsIHJlc3QpIC0+XG4gICAgRm9ybWF0X3N1YnN0X3R5ICh0eTEsIHR5MiwgY29uY2F0X2ZtdHR5IHJlc3QgZm10dHkyKVxuICB8IEVuZF9vZl9mbXR0eSAtPiBmbXR0eTJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIEZvcm1hdCBjb25jYXRlbmF0aW9uICopXG5cbigqIENvbmNhdGVuYXRlIHR3byBmb3JtYXRzLiAqKVxubGV0IHJlYyBjb25jYXRfZm10IDogdHlwZSBhIGIgYyBkIGUgZiBnIGggLlxuICAgIChhLCBiLCBjLCBkLCBlLCBmKSBmbXQgLT5cbiAgICAoZiwgYiwgYywgZSwgZywgaCkgZm10IC0+XG4gICAgKGEsIGIsIGMsIGQsIGcsIGgpIGZtdCA9XG5mdW4gZm10MSBmbXQyIC0+IG1hdGNoIGZtdDEgd2l0aFxuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIFN0cmluZyAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBDYW1sX3N0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIENhbWxfc3RyaW5nIChwYWQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgSW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludCAoaWNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgSW50MzIgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IE5hdGl2ZWludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBOYXRpdmVpbnQgKGljb252LCBwYWQsIHByZWMsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEludDY0IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIEludDY0IChpY29udiwgcGFkLCBwcmVjLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBGbG9hdCAoZmNvbnYsIHBhZCwgcHJlYywgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBDaGFyIChyZXN0KSAtPlxuICAgIENoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgQ2FtbF9jaGFyIChjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBCb29sIChwYWQsIHJlc3QpIC0+XG4gICAgQm9vbCAocGFkLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBBbHBoYSByZXN0IC0+XG4gICAgQWxwaGEgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFRoZXRhIHJlc3QgLT5cbiAgICBUaGV0YSAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ3VzdG9tIChhcml0eSwgZiwgcmVzdCkgLT5cbiAgICBDdXN0b20gKGFyaXR5LCBmLCBjb25jYXRfZm10IHJlc3QgZm10MilcbiAgfCBSZWFkZXIgcmVzdCAtPlxuICAgIFJlYWRlciAoY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRmx1c2ggcmVzdCAtPlxuICAgIEZsdXNoIChjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IFN0cmluZ19saXRlcmFsIChzdHIsIHJlc3QpIC0+XG4gICAgU3RyaW5nX2xpdGVyYWwgKHN0ciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgQ2hhcl9saXRlcmFsIChjaHIsIHJlc3QpIC0+XG4gICAgQ2hhcl9saXRlcmFsICAgKGNociwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBGb3JtYXRfYXJnIChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9hcmcgICAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgRm9ybWF0X3N1YnN0IChwYWQsIGZtdHR5LCByZXN0KSAtPlxuICAgIEZvcm1hdF9zdWJzdCAocGFkLCBmbXR0eSwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG5cbiAgfCBTY2FuX2NoYXJfc2V0ICh3aWR0aF9vcHQsIGNoYXJfc2V0LCByZXN0KSAtPlxuICAgIFNjYW5fY2hhcl9zZXQgKHdpZHRoX29wdCwgY2hhcl9zZXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgU2Nhbl9nZXRfY291bnRlciAoY291bnRlciwgY29uY2F0X2ZtdCByZXN0IGZtdDIpXG4gIHwgU2Nhbl9uZXh0X2NoYXIgKHJlc3QpIC0+XG4gICAgU2Nhbl9uZXh0X2NoYXIgKGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBJZ25vcmVkX3BhcmFtIChpZ24sIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpIC0+XG4gICAgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIGNvbmNhdF9mbXQgcmVzdCBmbXQyKVxuICB8IEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCByZXN0KSAtPlxuICAgIEZvcm1hdHRpbmdfZ2VuIChmbXRpbmdfZ2VuLCBjb25jYXRfZm10IHJlc3QgZm10MilcblxuICB8IEVuZF9vZl9mb3JtYXQgLT5cbiAgICBmbXQyXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEV4Y2VwdGlvbnMgKilcblxuZXh0ZXJuYWwgcmVnaXN0ZXJfbmFtZWRfdmFsdWUgOiBzdHJpbmcgLT4gJ2EgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfcmVnaXN0ZXJfbmFtZWRfdmFsdWVcIlxuXG5sZXQgKCkgPVxuICAoKiBmb3IgcnVudGltZS9mYWlsX25hdC5jICopXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5hcnJheV9ib3VuZF9lcnJvclwiXG4gICAgKEludmFsaWRfYXJndW1lbnQgXCJpbmRleCBvdXQgb2YgYm91bmRzXCIpXG5cbmV4dGVybmFsIHJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmFpc2VcIlxuZXh0ZXJuYWwgcmFpc2Vfbm90cmFjZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlX25vdHJhY2VcIlxuXG5sZXQgZmFpbHdpdGggcyA9IHJhaXNlKEZhaWx1cmUgcylcbmxldCBpbnZhbGlkX2FyZyBzID0gcmFpc2UoSW52YWxpZF9hcmd1bWVudCBzKVxuXG5leGNlcHRpb24gRXhpdFxuZXhjZXB0aW9uIE1hdGNoX2ZhaWx1cmUgPSBNYXRjaF9mYWlsdXJlXG5leGNlcHRpb24gQXNzZXJ0X2ZhaWx1cmUgPSBBc3NlcnRfZmFpbHVyZVxuZXhjZXB0aW9uIEludmFsaWRfYXJndW1lbnQgPSBJbnZhbGlkX2FyZ3VtZW50XG5leGNlcHRpb24gRmFpbHVyZSA9IEZhaWx1cmVcbmV4Y2VwdGlvbiBOb3RfZm91bmQgPSBOb3RfZm91bmRcbmV4Y2VwdGlvbiBPdXRfb2ZfbWVtb3J5ID0gT3V0X29mX21lbW9yeVxuZXhjZXB0aW9uIFN0YWNrX292ZXJmbG93ID0gU3RhY2tfb3ZlcmZsb3dcbmV4Y2VwdGlvbiBTeXNfZXJyb3IgPSBTeXNfZXJyb3JcbmV4Y2VwdGlvbiBFbmRfb2ZfZmlsZSA9IEVuZF9vZl9maWxlXG5leGNlcHRpb24gRGl2aXNpb25fYnlfemVybyA9IERpdmlzaW9uX2J5X3plcm9cbmV4Y2VwdGlvbiBTeXNfYmxvY2tlZF9pbyA9IFN5c19ibG9ja2VkX2lvXG5leGNlcHRpb24gVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgPSBVbmRlZmluZWRfcmVjdXJzaXZlX21vZHVsZVxuXG4oKiBDb21wb3NpdGlvbiBvcGVyYXRvcnMgKilcblxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbigqIERlYnVnZ2luZyAqKVxuXG5leHRlcm5hbCBfX0xPQ19fIDogc3RyaW5nID0gXCIlbG9jX0xPQ1wiXG5leHRlcm5hbCBfX0ZJTEVfXyA6IHN0cmluZyA9IFwiJWxvY19GSUxFXCJcbmV4dGVybmFsIF9fTElORV9fIDogaW50ID0gXCIlbG9jX0xJTkVcIlxuZXh0ZXJuYWwgX19NT0RVTEVfXyA6IHN0cmluZyA9IFwiJWxvY19NT0RVTEVcIlxuZXh0ZXJuYWwgX19QT1NfXyA6IHN0cmluZyAqIGludCAqIGludCAqIGludCA9IFwiJWxvY19QT1NcIlxuXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuXG4oKiBDb21wYXJpc29ucyAqKVxuXG5leHRlcm5hbCAoID0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoID49ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcmVxdWFsXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcblxubGV0IG1pbiB4IHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxubGV0IG1heCB4IHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuXG5leHRlcm5hbCAoID09ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXFcIlxuZXh0ZXJuYWwgKCAhPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJW5vdGVxXCJcblxuKCogQm9vbGVhbiBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuZXh0ZXJuYWwgKCAmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggb3IgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcblxuKCogSW50ZWdlciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgKCB+KyApIDogaW50IC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHN1Y2MgOiBpbnQgLT4gaW50ID0gXCIlc3VjY2ludFwiXG5leHRlcm5hbCBwcmVkIDogaW50IC0+IGludCA9IFwiJXByZWRpbnRcIlxuZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG5leHRlcm5hbCAoIC0gKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlc3ViaW50XCJcbmV4dGVybmFsICggKiApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG5leHRlcm5hbCAoIG1vZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcblxuZXh0ZXJuYWwgKCBsYW5kICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFuZGludFwiXG5leHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG5leHRlcm5hbCAoIGx4b3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcblxubGV0IGxub3QgeCA9IHggbHhvciAoLTEpXG5cbmV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCAoIGxzciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc3JpbnRcIlxuZXh0ZXJuYWwgKCBhc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcblxubGV0IG1heF9pbnQgPSAoLTEpIGxzciAxXG5sZXQgbWluX2ludCA9IG1heF9pbnQgKyAxXG5cbigqIEZsb2F0aW5nLXBvaW50IG9wZXJhdGlvbnMgKilcblxuZXh0ZXJuYWwgKCB+LS4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgKCB+Ky4gKSA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCArLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCAoIC0uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsICggKi4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgKCAvLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCAoICoqICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9wb3dlcl9mbG9hdFwiIFwicG93XCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cF9mbG9hdFwiIFwiZXhwXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGV4cG0xIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwbTFfZmxvYXRcIiBcImNhbWxfZXhwbTFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMXAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxcF9mbG9hdFwiIFwiY2FtbF9sb2cxcFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9zaW5fZmxvYXRcIiBcInNpblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzaW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luaF9mbG9hdFwiIFwic2luaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB0YW5oIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuaF9mbG9hdFwiIFwidGFuaFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBjZWlsIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY2VpbF9mbG9hdFwiIFwiY2VpbFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9vciA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb29yX2Zsb2F0XCIgXCJmbG9vclwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBhYnNfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFic2Zsb2F0XCJcbmV4dGVybmFsIGNvcHlzaWduIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICAgICAgICAgICAgICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBtb2RfZmxvYXQgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZyZXhwIDogZmxvYXQgLT4gZmxvYXQgKiBpbnQgPSBcImNhbWxfZnJleHBfZmxvYXRcIlxuZXh0ZXJuYWwgbGRleHAgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gKGludCBbQHVudGFnZ2VkXSkgLT4gKGZsb2F0IFtAdW5ib3hlZF0pID1cbiAgXCJjYW1sX2xkZXhwX2Zsb2F0XCIgXCJjYW1sX2xkZXhwX2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kZiA6IGZsb2F0IC0+IGZsb2F0ICogZmxvYXQgPSBcImNhbWxfbW9kZl9mbG9hdFwiXG5leHRlcm5hbCBmbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgZmxvYXRfb2ZfaW50IDogaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRvZmludFwiXG5leHRlcm5hbCB0cnVuY2F0ZSA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxuZXh0ZXJuYWwgaW50X29mX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxubGV0IGluZmluaXR5ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0YwXzAwXzAwXzAwXzAwXzAwXzAwTFxubGV0IG5lZ19pbmZpbml0eSA9XG4gIGZsb2F0X29mX2JpdHMgMHhGRl9GMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBuYW4gPVxuICBmbG9hdF9vZl9iaXRzIDB4N0ZfRjBfMDBfMDBfMDBfMDBfMDBfMDFMXG5sZXQgbWF4X2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDdGX0VGX0ZGX0ZGX0ZGX0ZGX0ZGX0ZGTFxubGV0IG1pbl9mbG9hdCA9XG4gIGZsb2F0X29mX2JpdHMgMHgwMF8xMF8wMF8wMF8wMF8wMF8wMF8wMExcbmxldCBlcHNpbG9uX2Zsb2F0ID1cbiAgZmxvYXRfb2ZfYml0cyAweDNDX0IwXzAwXzAwXzAwXzAwXzAwXzAwTFxuXG50eXBlIGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cblxuKCogU3RyaW5nIGFuZCBieXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGVzIFN0cmluZyBhbmQgQnl0ZXMgKilcblxuZXh0ZXJuYWwgc3RyaW5nX2xlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGJ5dGVzX2xlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBieXRlc19jcmVhdGUgOiBpbnQgLT4gYnl0ZXMgPSBcImNhbWxfY3JlYXRlX2J5dGVzXCJcbmV4dGVybmFsIHN0cmluZ19ibGl0IDogc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX2JsaXQgOiBieXRlcyAtPiBpbnQgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgKCBeICkgczEgczIgPVxuICBsZXQgbDEgPSBzdHJpbmdfbGVuZ3RoIHMxIGFuZCBsMiA9IHN0cmluZ19sZW5ndGggczIgaW5cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgKGwxICsgbDIpIGluXG4gIHN0cmluZ19ibGl0IHMxIDAgcyAwIGwxO1xuICBzdHJpbmdfYmxpdCBzMiAwIHMgbDEgbDI7XG4gIGJ5dGVzX3Vuc2FmZV90b19zdHJpbmcgc1xuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAtLSBtb3JlIGluIG1vZHVsZSBDaGFyICopXG5cbmV4dGVybmFsIGludF9vZl9jaGFyIDogY2hhciAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCB1bnNhZmVfY2hhcl9vZl9pbnQgOiBpbnQgLT4gY2hhciA9IFwiJWlkZW50aXR5XCJcbmxldCBjaGFyX29mX2ludCBuID1cbiAgaWYgbiA8IDAgfHwgbiA+IDI1NSB0aGVuIGludmFsaWRfYXJnIFwiY2hhcl9vZl9pbnRcIiBlbHNlIHVuc2FmZV9jaGFyX29mX2ludCBuXG5cbigqIFVuaXQgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBpZ25vcmUgOiAnYSAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuKCogUGFpciBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGZzdCA6ICdhICogJ2IgLT4gJ2EgPSBcIiVmaWVsZDBcIlxuZXh0ZXJuYWwgc25kIDogJ2EgKiAnYiAtPiAnYiA9IFwiJWZpZWxkMVwiXG5cbigqIFJlZmVyZW5jZXMgKilcblxudHlwZSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG5cbigqIFJlc3VsdCB0eXBlICopXG5cbnR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiXG5cbigqIFN0cmluZyBjb252ZXJzaW9uIGZ1bmN0aW9ucyAqKVxuXG5leHRlcm5hbCBmb3JtYXRfaW50IDogc3RyaW5nIC0+IGludCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2ludFwiXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbmxldCBzdHJpbmdfb2ZfYm9vbCBiID1cbiAgaWYgYiB0aGVuIFwidHJ1ZVwiIGVsc2UgXCJmYWxzZVwiXG5sZXQgYm9vbF9vZl9zdHJpbmcgPSBmdW5jdGlvblxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBfIC0+IGludmFsaWRfYXJnIFwiYm9vbF9vZl9zdHJpbmdcIlxuXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gZnVuY3Rpb25cbiAgfCBcInRydWVcIiAtPiBTb21lIHRydWVcbiAgfCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxuICB8IF8gLT4gTm9uZVxuXG5sZXQgc3RyaW5nX29mX2ludCBuID1cbiAgZm9ybWF0X2ludCBcIiVkXCIgblxuXG5leHRlcm5hbCBpbnRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludCA9IFwiY2FtbF9pbnRfb2Zfc3RyaW5nXCJcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIHMpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxuZXh0ZXJuYWwgc3RyaW5nX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5cbmxldCB2YWxpZF9mbG9hdF9sZXhlbSBzID1cbiAgbGV0IGwgPSBzdHJpbmdfbGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPj0gbCB0aGVuIHMgXiBcIi5cIiBlbHNlXG4gICAgbWF0Y2ggc3RyaW5nX2dldCBzIGkgd2l0aFxuICAgIHwgJzAnIC4uICc5JyB8ICctJyAtPiBsb29wIChpICsgMSlcbiAgICB8IF8gLT4gc1xuICBpblxuICBsb29wIDBcblxubGV0IHN0cmluZ19vZl9mbG9hdCBmID0gdmFsaWRfZmxvYXRfbGV4ZW0gKGZvcm1hdF9mbG9hdCBcIiUuMTJnXCIgZilcblxuZXh0ZXJuYWwgZmxvYXRfb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0X29mX3N0cmluZ1wiXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBwcm92aWRlIHRoaXMgZGlyZWN0bHkgYXMgYSBub24tcmFpc2luZyBwcmltaXRpdmUuICopXG4gIHRyeSBTb21lIChmbG9hdF9vZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG4oKiBMaXN0IG9wZXJhdGlvbnMgLS0gbW9yZSBpbiBtb2R1bGUgTGlzdCAqKVxuXG5sZXQgcmVjICggQCApIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgaGQgOjogdGwgLT4gaGQgOjogKHRsIEAgbDIpXG5cbigqIEkvTyBvcGVyYXRpb25zICopXG5cbnR5cGUgaW5fY2hhbm5lbFxudHlwZSBvdXRfY2hhbm5lbFxuXG5leHRlcm5hbCBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDogaW50IC0+IG91dF9jaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX29wZW5fZGVzY3JpcHRvcl9vdXRcIlxuZXh0ZXJuYWwgb3Blbl9kZXNjcmlwdG9yX2luIDogaW50IC0+IGluX2NoYW5uZWwgPSBcImNhbWxfbWxfb3Blbl9kZXNjcmlwdG9yX2luXCJcblxubGV0IHN0ZGluID0gb3Blbl9kZXNjcmlwdG9yX2luIDBcbmxldCBzdGRvdXQgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDFcbmxldCBzdGRlcnIgPSBvcGVuX2Rlc2NyaXB0b3Jfb3V0IDJcblxuKCogR2VuZXJhbCBvdXRwdXQgZnVuY3Rpb25zICopXG5cbnR5cGUgb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seSB8IE9wZW5fd3Jvbmx5IHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0IHwgT3Blbl90cnVuYyB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5IHwgT3Blbl90ZXh0IHwgT3Blbl9ub25ibG9ja1xuXG5leHRlcm5hbCBvcGVuX2Rlc2MgOiBzdHJpbmcgLT4gb3Blbl9mbGFnIGxpc3QgLT4gaW50IC0+IGludCA9IFwiY2FtbF9zeXNfb3BlblwiXG5cbmV4dGVybmFsIHNldF9vdXRfY2hhbm5lbF9uYW1lOiBvdXRfY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5fb3V0X2dlbiBtb2RlIHBlcm0gbmFtZSA9XG4gIGxldCBjID0gb3Blbl9kZXNjcmlwdG9yX291dChvcGVuX2Rlc2MgbmFtZSBtb2RlIHBlcm0pIGluXG4gIHNldF9vdXRfY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9vdXQgbmFtZSA9XG4gIG9wZW5fb3V0X2dlbiBbT3Blbl93cm9ubHk7IE9wZW5fY3JlYXQ7IE9wZW5fdHJ1bmM7IE9wZW5fdGV4dF0gMG82NjYgbmFtZVxuXG5sZXQgb3Blbl9vdXRfYmluIG5hbWUgPVxuICBvcGVuX291dF9nZW4gW09wZW5fd3Jvbmx5OyBPcGVuX2NyZWF0OyBPcGVuX3RydW5jOyBPcGVuX2JpbmFyeV0gMG82NjYgbmFtZVxuXG5leHRlcm5hbCBmbHVzaCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfZmx1c2hcIlxuXG5leHRlcm5hbCBvdXRfY2hhbm5lbHNfbGlzdCA6IHVuaXQgLT4gb3V0X2NoYW5uZWwgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfb3V0X2NoYW5uZWxzX2xpc3RcIlxuXG5sZXQgZmx1c2hfYWxsICgpID1cbiAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIFtdIC0+ICgpXG4gICAgfCBhOjpsIC0+XG4gICAgICAgIGJlZ2luIHRyeVxuICAgICAgICAgICAgZmx1c2ggYVxuICAgICAgICB3aXRoIFN5c19lcnJvciBfIC0+XG4gICAgICAgICAgKCkgKCogaWdub3JlIGNoYW5uZWxzIGNsb3NlZCBkdXJpbmcgYSBwcmVjZWRpbmcgZmx1c2guICopXG4gICAgICAgIGVuZDtcbiAgICAgICAgaXRlciBsXG4gIGluIGl0ZXIgKG91dF9jaGFubmVsc19saXN0ICgpKVxuXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0IDogb3V0X2NoYW5uZWwgLT4gYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dF9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfb3V0cHV0X3N0cmluZyA6IG91dF9jaGFubmVsIC0+IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX291dHB1dFwiXG5cbmV4dGVybmFsIG91dHB1dF9jaGFyIDogb3V0X2NoYW5uZWwgLT4gY2hhciAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcblxubGV0IG91dHB1dF9ieXRlcyBvYyBzID1cbiAgdW5zYWZlX291dHB1dCBvYyBzIDAgKGJ5dGVzX2xlbmd0aCBzKVxuXG5sZXQgb3V0cHV0X3N0cmluZyBvYyBzID1cbiAgdW5zYWZlX291dHB1dF9zdHJpbmcgb2MgcyAwIChzdHJpbmdfbGVuZ3RoIHMpXG5cbmxldCBvdXRwdXQgb2MgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJvdXRwdXRcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXQgb2MgcyBvZnMgbGVuXG5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIG9jIHMgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBzdHJpbmdfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIm91dHB1dF9zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9vdXRwdXRfc3RyaW5nIG9jIHMgb2ZzIGxlblxuXG5leHRlcm5hbCBvdXRwdXRfYnl0ZSA6IG91dF9jaGFubmVsIC0+IGludCAtPiB1bml0ID0gXCJjYW1sX21sX291dHB1dF9jaGFyXCJcbmV4dGVybmFsIG91dHB1dF9iaW5hcnlfaW50IDogb3V0X2NoYW5uZWwgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfbWxfb3V0cHV0X2ludFwiXG5cbmV4dGVybmFsIG1hcnNoYWxfdG9fY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+ICdhIC0+IHVuaXQgbGlzdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX291dHB1dF92YWx1ZVwiXG5sZXQgb3V0cHV0X3ZhbHVlIGNoYW4gdiA9IG1hcnNoYWxfdG9fY2hhbm5lbCBjaGFuIHYgW11cblxuZXh0ZXJuYWwgc2Vla19vdXQgOiBvdXRfY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dFwiXG5leHRlcm5hbCBwb3Nfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19vdXRcIlxuZXh0ZXJuYWwgb3V0X2NoYW5uZWxfbGVuZ3RoIDogb3V0X2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9vdXRfY2hhbm5lbCA6IG91dF9jaGFubmVsIC0+IHVuaXQgPSBcImNhbWxfbWxfY2xvc2VfY2hhbm5lbFwiXG5sZXQgY2xvc2Vfb3V0IG9jID0gZmx1c2ggb2M7IGNsb3NlX291dF9jaGFubmVsIG9jXG5sZXQgY2xvc2Vfb3V0X25vZXJyIG9jID1cbiAgKHRyeSBmbHVzaCBvYyB3aXRoIF8gLT4gKCkpO1xuICAodHJ5IGNsb3NlX291dF9jaGFubmVsIG9jIHdpdGggXyAtPiAoKSlcbmV4dGVybmFsIHNldF9iaW5hcnlfbW9kZV9vdXQgOiBvdXRfY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfc2V0X2JpbmFyeV9tb2RlXCJcblxuKCogR2VuZXJhbCBpbnB1dCBmdW5jdGlvbnMgKilcblxuZXh0ZXJuYWwgc2V0X2luX2NoYW5uZWxfbmFtZTogaW5fY2hhbm5lbCAtPiBzdHJpbmcgLT4gdW5pdCA9XG4gIFwiY2FtbF9tbF9zZXRfY2hhbm5lbF9uYW1lXCJcblxubGV0IG9wZW5faW5fZ2VuIG1vZGUgcGVybSBuYW1lID1cbiAgbGV0IGMgPSBvcGVuX2Rlc2NyaXB0b3JfaW4ob3Blbl9kZXNjIG5hbWUgbW9kZSBwZXJtKSBpblxuICBzZXRfaW5fY2hhbm5lbF9uYW1lIGMgbmFtZTtcbiAgY1xuXG5sZXQgb3Blbl9pbiBuYW1lID1cbiAgb3Blbl9pbl9nZW4gW09wZW5fcmRvbmx5OyBPcGVuX3RleHRdIDAgbmFtZVxuXG5sZXQgb3Blbl9pbl9iaW4gbmFtZSA9XG4gIG9wZW5faW5fZ2VuIFtPcGVuX3Jkb25seTsgT3Blbl9iaW5hcnldIDAgbmFtZVxuXG5leHRlcm5hbCBpbnB1dF9jaGFyIDogaW5fY2hhbm5lbCAtPiBjaGFyID0gXCJjYW1sX21sX2lucHV0X2NoYXJcIlxuXG5leHRlcm5hbCB1bnNhZmVfaW5wdXQgOiBpbl9jaGFubmVsIC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gaW50XG4gICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfbWxfaW5wdXRcIlxuXG5sZXQgaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGJ5dGVzX2xlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJpbnB1dFwiXG4gIGVsc2UgdW5zYWZlX2lucHV0IGljIHMgb2ZzIGxlblxuXG5sZXQgcmVjIHVuc2FmZV9yZWFsbHlfaW5wdXQgaWMgcyBvZnMgbGVuID1cbiAgaWYgbGVuIDw9IDAgdGhlbiAoKSBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSB1bnNhZmVfaW5wdXQgaWMgcyBvZnMgbGVuIGluXG4gICAgaWYgciA9IDBcbiAgICB0aGVuIHJhaXNlIEVuZF9vZl9maWxlXG4gICAgZWxzZSB1bnNhZmVfcmVhbGx5X2lucHV0IGljIHMgKG9mcyArIHIpIChsZW4gLSByKVxuICBlbmRcblxubGV0IHJlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gYnl0ZXNfbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcInJlYWxseV9pbnB1dFwiXG4gIGVsc2UgdW5zYWZlX3JlYWxseV9pbnB1dCBpYyBzIG9mcyBsZW5cblxubGV0IHJlYWxseV9pbnB1dF9zdHJpbmcgaWMgbGVuID1cbiAgbGV0IHMgPSBieXRlc19jcmVhdGUgbGVuIGluXG4gIHJlYWxseV9pbnB1dCBpYyBzIDAgbGVuO1xuICBieXRlc191bnNhZmVfdG9fc3RyaW5nIHNcblxuZXh0ZXJuYWwgaW5wdXRfc2Nhbl9saW5lIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfc2Nhbl9saW5lXCJcblxubGV0IGlucHV0X2xpbmUgY2hhbiA9XG4gIGxldCByZWMgYnVpbGRfcmVzdWx0IGJ1ZiBwb3MgPSBmdW5jdGlvblxuICAgIFtdIC0+IGJ1ZlxuICB8IGhkIDo6IHRsIC0+XG4gICAgICBsZXQgbGVuID0gYnl0ZXNfbGVuZ3RoIGhkIGluXG4gICAgICBieXRlc19ibGl0IGhkIDAgYnVmIChwb3MgLSBsZW4pIGxlbjtcbiAgICAgIGJ1aWxkX3Jlc3VsdCBidWYgKHBvcyAtIGxlbikgdGwgaW5cbiAgbGV0IHJlYyBzY2FuIGFjY3UgbGVuID1cbiAgICBsZXQgbiA9IGlucHV0X3NjYW5fbGluZSBjaGFuIGluXG4gICAgaWYgbiA9IDAgdGhlbiBiZWdpbiAgICAgICAgICAgICAgICAgICAoKiBuID0gMDogd2UgYXJlIGF0IEVPRiAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJhaXNlIEVuZF9vZl9maWxlXG4gICAgICB8IF8gIC0+IGJ1aWxkX3Jlc3VsdCAoYnl0ZXNfY3JlYXRlIGxlbikgbGVuIGFjY3VcbiAgICBlbmQgZWxzZSBpZiBuID4gMCB0aGVuIGJlZ2luICAgICAgICAgICgqIG4gPiAwOiBuZXdsaW5lIGZvdW5kIGluIGJ1ZmZlciAqKVxuICAgICAgbGV0IHJlcyA9IGJ5dGVzX2NyZWF0ZSAobiAtIDEpIGluXG4gICAgICBpZ25vcmUgKHVuc2FmZV9pbnB1dCBjaGFuIHJlcyAwIChuIC0gMSkpO1xuICAgICAgaWdub3JlIChpbnB1dF9jaGFyIGNoYW4pOyAgICAgICAgICAgKCogc2tpcCB0aGUgbmV3bGluZSAqKVxuICAgICAgbWF0Y2ggYWNjdSB3aXRoXG4gICAgICAgIFtdIC0+IHJlc1xuICAgICAgfCAgXyAtPiBsZXQgbGVuID0gbGVuICsgbiAtIDEgaW5cbiAgICAgICAgICAgICAgYnVpbGRfcmVzdWx0IChieXRlc19jcmVhdGUgbGVuKSBsZW4gKHJlcyA6OiBhY2N1KVxuICAgIGVuZCBlbHNlIGJlZ2luICAgICAgICAgICAgICAgICAgICAgICAgKCogbiA8IDA6IG5ld2xpbmUgbm90IGZvdW5kICopXG4gICAgICBsZXQgYmVnID0gYnl0ZXNfY3JlYXRlICgtbikgaW5cbiAgICAgIGlnbm9yZSh1bnNhZmVfaW5wdXQgY2hhbiBiZWcgMCAoLW4pKTtcbiAgICAgIHNjYW4gKGJlZyA6OiBhY2N1KSAobGVuIC0gbilcbiAgICBlbmRcbiAgaW4gYnl0ZXNfdW5zYWZlX3RvX3N0cmluZyAoc2NhbiBbXSAwKVxuXG5leHRlcm5hbCBpbnB1dF9ieXRlIDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfY2hhclwiXG5leHRlcm5hbCBpbnB1dF9iaW5hcnlfaW50IDogaW5fY2hhbm5lbCAtPiBpbnQgPSBcImNhbWxfbWxfaW5wdXRfaW50XCJcbmV4dGVybmFsIGlucHV0X3ZhbHVlIDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBzZWVrX2luIDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXCJcbmV4dGVybmFsIHBvc19pbiA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX3Bvc19pblwiXG5leHRlcm5hbCBpbl9jaGFubmVsX2xlbmd0aCA6IGluX2NoYW5uZWwgLT4gaW50ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZVwiXG5leHRlcm5hbCBjbG9zZV9pbiA6IGluX2NoYW5uZWwgLT4gdW5pdCA9IFwiY2FtbF9tbF9jbG9zZV9jaGFubmVsXCJcbmxldCBjbG9zZV9pbl9ub2VyciBpYyA9ICh0cnkgY2xvc2VfaW4gaWMgd2l0aCBfIC0+ICgpKVxuZXh0ZXJuYWwgc2V0X2JpbmFyeV9tb2RlX2luIDogaW5fY2hhbm5lbCAtPiBib29sIC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9tbF9zZXRfYmluYXJ5X21vZGVcIlxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIG91dHB1dCAqKVxuXG5sZXQgcHJpbnRfY2hhciBjID0gb3V0cHV0X2NoYXIgc3Rkb3V0IGNcbmxldCBwcmludF9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3Rkb3V0IHNcbmxldCBwcmludF9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZG91dCBzXG5sZXQgcHJpbnRfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByaW50X2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZG91dCAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJpbnRfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRvdXQgczsgb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcbmxldCBwcmludF9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3Rkb3V0ICdcXG4nOyBmbHVzaCBzdGRvdXRcblxuKCogT3V0cHV0IGZ1bmN0aW9ucyBvbiBzdGFuZGFyZCBlcnJvciAqKVxuXG5sZXQgcHJlcnJfY2hhciBjID0gb3V0cHV0X2NoYXIgc3RkZXJyIGNcbmxldCBwcmVycl9zdHJpbmcgcyA9IG91dHB1dF9zdHJpbmcgc3RkZXJyIHNcbmxldCBwcmVycl9ieXRlcyBzID0gb3V0cHV0X2J5dGVzIHN0ZGVyciBzXG5sZXQgcHJlcnJfaW50IGkgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2ludCBpKVxubGV0IHByZXJyX2Zsb2F0IGYgPSBvdXRwdXRfc3RyaW5nIHN0ZGVyciAoc3RyaW5nX29mX2Zsb2F0IGYpXG5sZXQgcHJlcnJfZW5kbGluZSBzID1cbiAgb3V0cHV0X3N0cmluZyBzdGRlcnIgczsgb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcbmxldCBwcmVycl9uZXdsaW5lICgpID0gb3V0cHV0X2NoYXIgc3RkZXJyICdcXG4nOyBmbHVzaCBzdGRlcnJcblxuKCogSW5wdXQgZnVuY3Rpb25zIG9uIHN0YW5kYXJkIGlucHV0ICopXG5cbmxldCByZWFkX2xpbmUgKCkgPSBmbHVzaCBzdGRvdXQ7IGlucHV0X2xpbmUgc3RkaW5cbmxldCByZWFkX2ludCAoKSA9IGludF9vZl9zdHJpbmcocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9pbnRfb3B0ICgpID0gaW50X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5sZXQgcmVhZF9mbG9hdCAoKSA9IGZsb2F0X29mX3N0cmluZyhyZWFkX2xpbmUoKSlcbmxldCByZWFkX2Zsb2F0X29wdCAoKSA9IGZsb2F0X29mX3N0cmluZ19vcHQocmVhZF9saW5lKCkpXG5cbigqIE9wZXJhdGlvbnMgb24gbGFyZ2UgZmlsZXMgKilcblxubW9kdWxlIExhcmdlRmlsZSA9XG4gIHN0cnVjdFxuICAgIGV4dGVybmFsIHNlZWtfb3V0IDogb3V0X2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX291dF82NFwiXG4gICAgZXh0ZXJuYWwgcG9zX291dCA6IG91dF9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19vdXRfNjRcIlxuICAgIGV4dGVybmFsIG91dF9jaGFubmVsX2xlbmd0aCA6IG91dF9jaGFubmVsIC0+IGludDY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gICAgZXh0ZXJuYWwgc2Vla19pbiA6IGluX2NoYW5uZWwgLT4gaW50NjQgLT4gdW5pdCA9IFwiY2FtbF9tbF9zZWVrX2luXzY0XCJcbiAgICBleHRlcm5hbCBwb3NfaW4gOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX3Bvc19pbl82NFwiXG4gICAgZXh0ZXJuYWwgaW5fY2hhbm5lbF9sZW5ndGggOiBpbl9jaGFubmVsIC0+IGludDY0ID0gXCJjYW1sX21sX2NoYW5uZWxfc2l6ZV82NFwiXG4gIGVuZFxuXG4oKiBGb3JtYXRzICopXG5cbnR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG4gICA9IEZvcm1hdCBvZiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzLmZtdFxuICAgICAgICAgICAgICAgKiBzdHJpbmdcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxuXG50eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgPSAoJ2EsICdiLCAnYywgJ2MpIGZvcm1hdDRcblxubGV0IHN0cmluZ19vZl9mb3JtYXQgKEZvcm1hdCAoX2ZtdCwgc3RyKSkgPSBzdHJcblxuZXh0ZXJuYWwgZm9ybWF0X29mX3N0cmluZyA6XG4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcblxubGV0ICggXl4gKSAoRm9ybWF0IChmbXQxLCBzdHIxKSkgKEZvcm1hdCAoZm10Miwgc3RyMikpID1cbiAgRm9ybWF0IChDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuY29uY2F0X2ZtdCBmbXQxIGZtdDIsXG4gICAgICAgICAgc3RyMSBeIFwiJSxcIiBeIHN0cjIpXG5cbigqIE1pc2NlbGxhbmVvdXMgKilcblxuZXh0ZXJuYWwgc3lzX2V4aXQgOiBpbnQgLT4gJ2EgPSBcImNhbWxfc3lzX2V4aXRcIlxuXG5sZXQgZXhpdF9mdW5jdGlvbiA9IHJlZiBmbHVzaF9hbGxcblxubGV0IGF0X2V4aXQgZiA9XG4gIGxldCBnID0gIWV4aXRfZnVuY3Rpb24gaW5cbiAgKCogTVBSIzcyNTMsIE1QUiM3Nzk2OiBtYWtlIHN1cmUgXCJmXCIgaXMgZXhlY3V0ZWQgb25seSBvbmNlICopXG4gIGxldCBmX2FscmVhZHlfcmFuID0gcmVmIGZhbHNlIGluXG4gIGV4aXRfZnVuY3Rpb24gOj1cbiAgICAoZnVuICgpIC0+XG4gICAgICBpZiBub3QgIWZfYWxyZWFkeV9yYW4gdGhlbiBiZWdpbiBmX2FscmVhZHlfcmFuIDo9IHRydWU7IGYoKSBlbmQ7XG4gICAgICBnKCkpXG5cbmxldCBkb19hdF9leGl0ICgpID0gKCFleGl0X2Z1bmN0aW9uKSAoKVxuXG5sZXQgZXhpdCByZXRjb2RlID1cbiAgZG9fYXRfZXhpdCAoKTtcbiAgc3lzX2V4aXQgcmV0Y29kZVxuXG5sZXQgXyA9IHJlZ2lzdGVyX25hbWVkX3ZhbHVlIFwiUGVydmFzaXZlcy5kb19hdF9leGl0XCIgZG9fYXRfZXhpdFxuXG4oKk1PRFVMRV9BTElBU0VTKilcbm1vZHVsZSBBcmcgICAgICAgICAgPSBBcmdcbm1vZHVsZSBBcnJheSAgICAgICAgPSBBcnJheVxubW9kdWxlIEFycmF5TGFiZWxzICA9IEFycmF5TGFiZWxzXG5tb2R1bGUgQmlnYXJyYXkgICAgID0gQmlnYXJyYXlcbm1vZHVsZSBCb29sICAgICAgICAgPSBCb29sXG5tb2R1bGUgQnVmZmVyICAgICAgID0gQnVmZmVyXG5tb2R1bGUgQnl0ZXMgICAgICAgID0gQnl0ZXNcbm1vZHVsZSBCeXRlc0xhYmVscyAgPSBCeXRlc0xhYmVsc1xubW9kdWxlIENhbGxiYWNrICAgICA9IENhbGxiYWNrXG5tb2R1bGUgQ2hhciAgICAgICAgID0gQ2hhclxubW9kdWxlIENvbXBsZXggICAgICA9IENvbXBsZXhcbm1vZHVsZSBEaWdlc3QgICAgICAgPSBEaWdlc3Rcbm1vZHVsZSBFcGhlbWVyb24gICAgPSBFcGhlbWVyb25cbm1vZHVsZSBGaWxlbmFtZSAgICAgPSBGaWxlbmFtZVxubW9kdWxlIEZsb2F0ICAgICAgICA9IEZsb2F0XG5tb2R1bGUgRm9ybWF0ICAgICAgID0gRm9ybWF0XG5tb2R1bGUgRnVuICAgICAgICAgID0gRnVuXG5tb2R1bGUgR2MgICAgICAgICAgID0gR2Ncbm1vZHVsZSBHZW5sZXggICAgICAgPSBHZW5sZXhcbm1vZHVsZSBIYXNodGJsICAgICAgPSBIYXNodGJsXG5tb2R1bGUgSW50ICAgICAgICAgID0gSW50XG5tb2R1bGUgSW50MzIgICAgICAgID0gSW50MzJcbm1vZHVsZSBJbnQ2NCAgICAgICAgPSBJbnQ2NFxubW9kdWxlIExhenkgICAgICAgICA9IExhenlcbm1vZHVsZSBMZXhpbmcgICAgICAgPSBMZXhpbmdcbm1vZHVsZSBMaXN0ICAgICAgICAgPSBMaXN0XG5tb2R1bGUgTGlzdExhYmVscyAgID0gTGlzdExhYmVsc1xubW9kdWxlIE1hcCAgICAgICAgICA9IE1hcFxubW9kdWxlIE1hcnNoYWwgICAgICA9IE1hcnNoYWxcbm1vZHVsZSBNb3JlTGFiZWxzICAgPSBNb3JlTGFiZWxzXG5tb2R1bGUgTmF0aXZlaW50ICAgID0gTmF0aXZlaW50XG5tb2R1bGUgT2JqICAgICAgICAgID0gT2JqXG5tb2R1bGUgT28gICAgICAgICAgID0gT29cbm1vZHVsZSBPcHRpb24gICAgICAgPSBPcHRpb25cbm1vZHVsZSBQYXJzaW5nICAgICAgPSBQYXJzaW5nXG5tb2R1bGUgUGVydmFzaXZlcyAgID0gUGVydmFzaXZlc1xubW9kdWxlIFByaW50ZXhjICAgICA9IFByaW50ZXhjXG5tb2R1bGUgUHJpbnRmICAgICAgID0gUHJpbnRmXG5tb2R1bGUgUXVldWUgICAgICAgID0gUXVldWVcbm1vZHVsZSBSYW5kb20gICAgICAgPSBSYW5kb21cbm1vZHVsZSBSZXN1bHQgICAgICAgPSBSZXN1bHRcbm1vZHVsZSBTY2FuZiAgICAgICAgPSBTY2FuZlxubW9kdWxlIFNlcSAgICAgICAgICA9IFNlcVxubW9kdWxlIFNldCAgICAgICAgICA9IFNldFxubW9kdWxlIFNwYWNldGltZSAgICA9IFNwYWNldGltZVxubW9kdWxlIFN0YWNrICAgICAgICA9IFN0YWNrXG5tb2R1bGUgU3RkTGFiZWxzICAgID0gU3RkTGFiZWxzXG5tb2R1bGUgU3RyZWFtICAgICAgID0gU3RyZWFtXG5tb2R1bGUgU3RyaW5nICAgICAgID0gU3RyaW5nXG5tb2R1bGUgU3RyaW5nTGFiZWxzID0gU3RyaW5nTGFiZWxzXG5tb2R1bGUgU3lzICAgICAgICAgID0gU3lzXG5tb2R1bGUgVWNoYXIgICAgICAgID0gVWNoYXJcbm1vZHVsZSBVbml0ICAgICAgICAgPSBVbml0XG5tb2R1bGUgV2VhayAgICAgICAgID0gV2Vha1xuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgSmVyZW1pZSBEaW1pbm8sIEphbmUgU3RyZWV0IEV1cm9wZSAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBKYW5lIFN0cmVldCBHcm91cCBMTEMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiogQGRlcHJlY2F0ZWQgVXNlIHshU3RkbGlifSAqKVxuXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJhaXNlXCJcbmV4dGVybmFsIHJhaXNlX25vdHJhY2UgOiBleG4gLT4gJ2EgPSBcIiVyYWlzZV9ub3RyYWNlXCJcbmxldCBpbnZhbGlkX2FyZyA9IGludmFsaWRfYXJnXG5sZXQgZmFpbHdpdGggPSBmYWlsd2l0aFxuZXhjZXB0aW9uIEV4aXRcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbmV4dGVybmFsICggPD4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcXVhbFwiXG5leHRlcm5hbCAoIDwgKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVsZXNzdGhhblwiXG5leHRlcm5hbCAoID4gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG5leHRlcm5hbCAoIDw9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc2VxdWFsXCJcbmV4dGVybmFsICggPj0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZXh0ZXJuYWwgY29tcGFyZSA6ICdhIC0+ICdhIC0+IGludCA9IFwiJWNvbXBhcmVcIlxubGV0IG1pbiA9IG1pblxubGV0IG1heCA9IG1heFxuZXh0ZXJuYWwgKCA9PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxXCJcbmV4dGVybmFsICggIT0gKSA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVub3RlcVwiXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoICYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgKCYmKSBpbnN0ZWFkLlwiXVxuZXh0ZXJuYWwgKCB8fCApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuZXh0ZXJuYWwgKCBvciApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1b3JcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlICh8fCkgaW5zdGVhZC5cIl1cbmV4dGVybmFsIF9fTE9DX18gOiBzdHJpbmcgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fRklMRV9fIDogc3RyaW5nID0gXCIlbG9jX0ZJTEVcIlxuZXh0ZXJuYWwgX19MSU5FX18gOiBpbnQgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX01PRFVMRV9fIDogc3RyaW5nID0gXCIlbG9jX01PRFVMRVwiXG5leHRlcm5hbCBfX1BPU19fIDogc3RyaW5nICogaW50ICogaW50ICogaW50ID0gXCIlbG9jX1BPU1wiXG5leHRlcm5hbCBfX0xPQ19PRl9fIDogJ2EgLT4gc3RyaW5nICogJ2EgPSBcIiVsb2NfTE9DXCJcbmV4dGVybmFsIF9fTElORV9PRl9fIDogJ2EgLT4gaW50ICogJ2EgPSBcIiVsb2NfTElORVwiXG5leHRlcm5hbCBfX1BPU19PRl9fIDogJ2EgLT4gKHN0cmluZyAqIGludCAqIGludCAqIGludCkgKiAnYSA9IFwiJWxvY19QT1NcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcbmV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5leHRlcm5hbCAoIH4tICkgOiBpbnQgLT4gaW50ID0gXCIlbmVnaW50XCJcbmV4dGVybmFsICggfisgKSA6IGludCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBzdWNjIDogaW50IC0+IGludCA9IFwiJXN1Y2NpbnRcIlxuZXh0ZXJuYWwgcHJlZCA6IGludCAtPiBpbnQgPSBcIiVwcmVkaW50XCJcbmV4dGVybmFsICggKyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgKCAtICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJXN1YmludFwiXG5leHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbmV4dGVybmFsICggLyApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgKCBtb2QgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbW9kaW50XCJcbmxldCBhYnMgPSBhYnNcbmxldCBtYXhfaW50ID0gbWF4X2ludFxubGV0IG1pbl9pbnQgPSBtaW5faW50XG5leHRlcm5hbCAoIGxhbmQgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYW5kaW50XCJcbmV4dGVybmFsICggbG9yICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxubGV0IGxub3QgPSBsbm90XG5leHRlcm5hbCAoIGxzbCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVsc2xpbnRcIlxuZXh0ZXJuYWwgKCBsc3IgKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbHNyaW50XCJcbmV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5leHRlcm5hbCAoIH4tLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVuZWdmbG9hdFwiXG5leHRlcm5hbCAoIH4rLiApIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCAoICsuICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWFkZGZsb2F0XCJcbmV4dGVybmFsICggLS4gKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlc3ViZmxvYXRcIlxuZXh0ZXJuYWwgKCAqLiApIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVtdWxmbG9hdFwiXG5leHRlcm5hbCAoIC8uICkgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJWRpdmZsb2F0XCJcbmV4dGVybmFsICggKiogKSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Bvd2VyX2Zsb2F0XCIgXCJwb3dcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc3FydCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NxcnRfZmxvYXRcIiBcInNxcnRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nX2Zsb2F0XCIgXCJsb2dcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxcCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzFwX2Zsb2F0XCIgXCJjYW1sX2xvZzFwXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc19mbG9hdFwiIFwiY29zXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIHRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Rhbl9mbG9hdFwiIFwidGFuXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFjb3MgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hY29zX2Zsb2F0XCIgXCJhY29zXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuX2Zsb2F0XCIgXCJhdGFuXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGF0YW4yIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbjJfZmxvYXRcIiBcImF0YW4yXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY2VpbCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NlaWxfZmxvYXRcIiBcImNlaWxcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZmxvb3IgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbG9vcl9mbG9hdFwiIFwiZmxvb3JcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5leHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgbW9kX2Zsb2F0IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZm1vZF9mbG9hdFwiIFwiZm1vZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxuZXh0ZXJuYWwgZmxvYXQgOiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdG9maW50XCJcbmV4dGVybmFsIGZsb2F0X29mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdHJ1bmNhdGUgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcbmV4dGVybmFsIGludF9vZl9mbG9hdCA6IGZsb2F0IC0+IGludCA9IFwiJWludG9mZmxvYXRcIlxubGV0IGluZmluaXR5ID0gaW5maW5pdHlcbmxldCBuZWdfaW5maW5pdHkgPSBuZWdfaW5maW5pdHlcbmxldCBuYW4gPSBuYW5cbmxldCBtYXhfZmxvYXQgPSBtYXhfZmxvYXRcbmxldCBtaW5fZmxvYXQgPSBtaW5fZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gZXBzaWxvbl9mbG9hdFxudHlwZSBub25yZWMgZnBjbGFzcyA9IGZwY2xhc3MgPVxuICAgIEZQX25vcm1hbFxuICB8IEZQX3N1Ym5vcm1hbFxuICB8IEZQX3plcm9cbiAgfCBGUF9pbmZpbml0ZVxuICB8IEZQX25hblxuZXh0ZXJuYWwgY2xhc3NpZnlfZmxvYXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gZnBjbGFzcyA9XG4gIFwiY2FtbF9jbGFzc2lmeV9mbG9hdFwiIFwiY2FtbF9jbGFzc2lmeV9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmxldCAoIF4gKSA9ICggXiApXG5leHRlcm5hbCBpbnRfb2ZfY2hhciA6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxubGV0IGNoYXJfb2ZfaW50ID0gY2hhcl9vZl9pbnRcbmV4dGVybmFsIGlnbm9yZSA6ICdhIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxubGV0IHN0cmluZ19vZl9ib29sID0gc3RyaW5nX29mX2Jvb2xcbmxldCBib29sX29mX3N0cmluZyA9IGJvb2xfb2Zfc3RyaW5nXG5sZXQgYm9vbF9vZl9zdHJpbmdfb3B0ID0gYm9vbF9vZl9zdHJpbmdfb3B0XG5sZXQgc3RyaW5nX29mX2ludCA9IHN0cmluZ19vZl9pbnRcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IGludF9vZl9zdHJpbmdfb3B0ID0gaW50X29mX3N0cmluZ19vcHRcbmxldCBzdHJpbmdfb2ZfZmxvYXQgPSBzdHJpbmdfb2ZfZmxvYXRcbmV4dGVybmFsIGZsb2F0X29mX3N0cmluZyA6IHN0cmluZyAtPiBmbG9hdCA9IFwiY2FtbF9mbG9hdF9vZl9zdHJpbmdcIlxubGV0IGZsb2F0X29mX3N0cmluZ19vcHQgPSBmbG9hdF9vZl9zdHJpbmdfb3B0XG5leHRlcm5hbCBmc3QgOiAnYSAqICdiIC0+ICdhID0gXCIlZmllbGQwXCJcbmV4dGVybmFsIHNuZCA6ICdhICogJ2IgLT4gJ2IgPSBcIiVmaWVsZDFcIlxubGV0ICggQCApICA9ICggQCApXG50eXBlIG5vbnJlYyBpbl9jaGFubmVsID0gaW5fY2hhbm5lbFxudHlwZSBub25yZWMgb3V0X2NoYW5uZWwgPSBvdXRfY2hhbm5lbFxubGV0IHN0ZGluID0gc3RkaW5cbmxldCBzdGRvdXQgPSBzdGRvdXRcbmxldCBzdGRlcnIgPSBzdGRlcnJcbmxldCBwcmludF9jaGFyID0gcHJpbnRfY2hhclxubGV0IHByaW50X3N0cmluZyA9IHByaW50X3N0cmluZ1xubGV0IHByaW50X2J5dGVzID0gcHJpbnRfYnl0ZXNcbmxldCBwcmludF9pbnQgPSBwcmludF9pbnRcbmxldCBwcmludF9mbG9hdCA9IHByaW50X2Zsb2F0XG5sZXQgcHJpbnRfZW5kbGluZSA9IHByaW50X2VuZGxpbmVcbmxldCBwcmludF9uZXdsaW5lID0gcHJpbnRfbmV3bGluZVxubGV0IHByZXJyX2NoYXIgPSBwcmVycl9jaGFyXG5sZXQgcHJlcnJfc3RyaW5nID0gcHJlcnJfc3RyaW5nXG5sZXQgcHJlcnJfYnl0ZXMgPSBwcmVycl9ieXRlc1xubGV0IHByZXJyX2ludCA9IHByZXJyX2ludFxubGV0IHByZXJyX2Zsb2F0ID0gcHJlcnJfZmxvYXRcbmxldCBwcmVycl9lbmRsaW5lID0gcHJlcnJfZW5kbGluZVxubGV0IHByZXJyX25ld2xpbmUgPSBwcmVycl9uZXdsaW5lXG5sZXQgcmVhZF9saW5lID0gcmVhZF9saW5lXG5sZXQgcmVhZF9pbnQgPSByZWFkX2ludFxubGV0IHJlYWRfaW50X29wdCA9IHJlYWRfaW50X29wdFxubGV0IHJlYWRfZmxvYXQgPSByZWFkX2Zsb2F0XG5sZXQgcmVhZF9mbG9hdF9vcHQgPSByZWFkX2Zsb2F0X29wdFxudHlwZSBub25yZWMgb3Blbl9mbGFnID0gb3Blbl9mbGFnID1cbiAgICBPcGVuX3Jkb25seVxuICB8IE9wZW5fd3Jvbmx5XG4gIHwgT3Blbl9hcHBlbmRcbiAgfCBPcGVuX2NyZWF0XG4gIHwgT3Blbl90cnVuY1xuICB8IE9wZW5fZXhjbFxuICB8IE9wZW5fYmluYXJ5XG4gIHwgT3Blbl90ZXh0XG4gIHwgT3Blbl9ub25ibG9ja1xubGV0IG9wZW5fb3V0ID0gb3Blbl9vdXRcbmxldCBvcGVuX291dF9iaW4gPSBvcGVuX291dF9iaW5cbmxldCBvcGVuX291dF9nZW4gPSBvcGVuX291dF9nZW5cbmxldCBmbHVzaCA9IGZsdXNoXG5sZXQgZmx1c2hfYWxsID0gZmx1c2hfYWxsXG5sZXQgb3V0cHV0X2NoYXIgPSBvdXRwdXRfY2hhclxubGV0IG91dHB1dF9zdHJpbmcgPSBvdXRwdXRfc3RyaW5nXG5sZXQgb3V0cHV0X2J5dGVzID0gb3V0cHV0X2J5dGVzXG5sZXQgb3V0cHV0ID0gb3V0cHV0XG5sZXQgb3V0cHV0X3N1YnN0cmluZyA9IG91dHB1dF9zdWJzdHJpbmdcbmxldCBvdXRwdXRfYnl0ZSA9IG91dHB1dF9ieXRlXG5sZXQgb3V0cHV0X2JpbmFyeV9pbnQgPSBvdXRwdXRfYmluYXJ5X2ludFxubGV0IG91dHB1dF92YWx1ZSA9IG91dHB1dF92YWx1ZVxubGV0IHNlZWtfb3V0ID0gc2Vla19vdXRcbmxldCBwb3Nfb3V0ID0gcG9zX291dFxubGV0IG91dF9jaGFubmVsX2xlbmd0aCA9IG91dF9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX291dCA9IGNsb3NlX291dFxubGV0IGNsb3NlX291dF9ub2VyciA9IGNsb3NlX291dF9ub2VyclxubGV0IHNldF9iaW5hcnlfbW9kZV9vdXQgPSBzZXRfYmluYXJ5X21vZGVfb3V0XG5sZXQgb3Blbl9pbiA9IG9wZW5faW5cbmxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fYmluXG5sZXQgb3Blbl9pbl9nZW4gPSBvcGVuX2luX2dlblxubGV0IGlucHV0X2NoYXIgPSBpbnB1dF9jaGFyXG5sZXQgaW5wdXRfbGluZSA9IGlucHV0X2xpbmVcbmxldCBpbnB1dCA9IGlucHV0XG5sZXQgcmVhbGx5X2lucHV0ID0gcmVhbGx5X2lucHV0XG5sZXQgcmVhbGx5X2lucHV0X3N0cmluZyA9IHJlYWxseV9pbnB1dF9zdHJpbmdcbmxldCBpbnB1dF9ieXRlID0gaW5wdXRfYnl0ZVxubGV0IGlucHV0X2JpbmFyeV9pbnQgPSBpbnB1dF9iaW5hcnlfaW50XG5sZXQgaW5wdXRfdmFsdWUgPSBpbnB1dF92YWx1ZVxubGV0IHNlZWtfaW4gPSBzZWVrX2luXG5sZXQgcG9zX2luID0gcG9zX2luXG5sZXQgaW5fY2hhbm5lbF9sZW5ndGggPSBpbl9jaGFubmVsX2xlbmd0aFxubGV0IGNsb3NlX2luID0gY2xvc2VfaW5cbmxldCBjbG9zZV9pbl9ub2VyciA9IGNsb3NlX2luX25vZXJyXG5sZXQgc2V0X2JpbmFyeV9tb2RlX2luID0gc2V0X2JpbmFyeV9tb2RlX2luXG5tb2R1bGUgTGFyZ2VGaWxlID0gTGFyZ2VGaWxlXG50eXBlIG5vbnJlYyAnYSByZWYgPSAnYSByZWYgPSB7IG11dGFibGUgY29udGVudHMgOiAnYSB9XG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5leHRlcm5hbCBpbmNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlaW5jclwiXG5leHRlcm5hbCBkZWNyIDogaW50IHJlZiAtPiB1bml0ID0gXCIlZGVjclwiXG50eXBlIG5vbnJlYyAoJ2EsJ2IpIHJlc3VsdCA9ICgnYSwnYikgcmVzdWx0ID0gT2sgb2YgJ2EgfCBFcnJvciBvZiAnYlxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgPSAoJ2EsICdiLCAnYywgJ2MsICdjLCAnZCkgZm9ybWF0NlxudHlwZSAoJ2EsICdiLCAnYykgZm9ybWF0ID0gKCdhLCAnYiwgJ2MsICdjKSBmb3JtYXQ0XG5sZXQgc3RyaW5nX29mX2Zvcm1hdCA9IHN0cmluZ19vZl9mb3JtYXRcbmV4dGVybmFsIGZvcm1hdF9vZl9zdHJpbmcgOlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9IFwiJWlkZW50aXR5XCJcbmxldCAoIF5eICkgPSAoIF5eIClcbmxldCBleGl0ID0gZXhpdFxubGV0IGF0X2V4aXQgPSBhdF9leGl0XG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gPSB2YWxpZF9mbG9hdF9sZXhlbVxubGV0IGRvX2F0X2V4aXQgPSBkb19hdF9leGl0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgIE5pY29sYXMgT2plZGEgQmFyLCBMZXhpRmkgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIG5lZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCIlbmVnZmxvYXRcIlxuZXh0ZXJuYWwgYWRkIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVhZGRmbG9hdFwiXG5leHRlcm5hbCBzdWIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiJXN1YmZsb2F0XCJcbmV4dGVybmFsIG11bCA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCIlbXVsZmxvYXRcIlxuZXh0ZXJuYWwgZGl2IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcIiVkaXZmbG9hdFwiXG5leHRlcm5hbCByZW0gOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9mbW9kX2Zsb2F0XCIgXCJmbW9kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZtYSA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2ZtYV9mbG9hdFwiIFwiY2FtbF9mbWFcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWJzIDogZmxvYXQgLT4gZmxvYXQgPSBcIiVhYnNmbG9hdFwiXG5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IGluZmluaXR5ID0gU3RkbGliLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gU3RkbGliLm5lZ19pbmZpbml0eVxubGV0IG5hbiA9IFN0ZGxpYi5uYW5cbmxldCBpc19maW5pdGUgKHg6IGZsb2F0KSA9IHggLS4geCA9IDAuXG5sZXQgaXNfaW5maW5pdGUgKHg6IGZsb2F0KSA9IDEuIC8uIHggPSAwLlxubGV0IGlzX25hbiAoeDogZmxvYXQpID0geCA8PiB4XG5cbmxldCBwaSA9IDB4MS45MjFmYjU0NDQyZDE4cCsxXG5sZXQgbWF4X2Zsb2F0ID0gU3RkbGliLm1heF9mbG9hdFxubGV0IG1pbl9mbG9hdCA9IFN0ZGxpYi5taW5fZmxvYXRcbmxldCBlcHNpbG9uID0gU3RkbGliLmVwc2lsb25fZmxvYXRcbmV4dGVybmFsIG9mX2ludCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgdG9faW50IDogZmxvYXQgLT4gaW50ID0gXCIlaW50b2ZmbG9hdFwiXG5leHRlcm5hbCBvZl9zdHJpbmcgOiBzdHJpbmcgLT4gZmxvYXQgPSBcImNhbWxfZmxvYXRfb2Zfc3RyaW5nXCJcbmxldCBvZl9zdHJpbmdfb3B0ID0gU3RkbGliLmZsb2F0X29mX3N0cmluZ19vcHRcbmxldCB0b19zdHJpbmcgPSBTdGRsaWIuc3RyaW5nX29mX2Zsb2F0XG50eXBlIGZwY2xhc3MgPSBTdGRsaWIuZnBjbGFzcyA9XG4gICAgRlBfbm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsXG4gIHwgRlBfemVyb1xuICB8IEZQX2luZmluaXRlXG4gIHwgRlBfbmFuXG5leHRlcm5hbCBjbGFzc2lmeV9mbG9hdCA6IChmbG9hdCBbQHVuYm94ZWRdKSAtPiBmcGNsYXNzID1cbiAgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0XCIgXCJjYW1sX2NsYXNzaWZ5X2Zsb2F0X3VuYm94ZWRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgcG93IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfcG93ZXJfZmxvYXRcIiBcInBvd1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBfZmxvYXRcIiBcImV4cFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2dfZmxvYXRcIiBcImxvZ1wiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBsb2cxMCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZzEwX2Zsb2F0XCIgXCJsb2cxMFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBleHBtMSA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2V4cG0xX2Zsb2F0XCIgXCJjYW1sX2V4cG0xXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc2luX2Zsb2F0XCIgXCJzaW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfdGFuX2Zsb2F0XCIgXCJ0YW5cIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2FzaW5fZmxvYXRcIiBcImFzaW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW5fZmxvYXRcIiBcImF0YW5cIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgYXRhbjIgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hdGFuMl9mbG9hdFwiIFwiYXRhbjJcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHlwb3QgOiBmbG9hdCAtPiBmbG9hdCAtPiBmbG9hdFxuICAgICAgICAgICAgICAgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgY29zaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Nvc2hfZmxvYXRcIiBcImNvc2hcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdGFuaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3RhbmhfZmxvYXRcIiBcInRhbmhcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdHJ1bmMgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90cnVuY19mbG9hdFwiIFwiY2FtbF90cnVuY1wiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCByb3VuZCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3JvdW5kX2Zsb2F0XCIgXCJjYW1sX3JvdW5kXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGNlaWwgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9jZWlsX2Zsb2F0XCIgXCJjZWlsXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGZsb29yIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZmxvb3JfZmxvYXRcIiBcImZsb29yXCJcbltAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBpc19pbnRlZ2VyIHggPSB4ID0gdHJ1bmMgeCAmJiBpc19maW5pdGUgeFxuXG5leHRlcm5hbCBuZXh0X2FmdGVyIDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmV4dGFmdGVyX2Zsb2F0XCIgXCJjYW1sX25leHRhZnRlclwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbmxldCBzdWNjIHggPSBuZXh0X2FmdGVyIHggaW5maW5pdHlcbmxldCBwcmVkIHggPSBuZXh0X2FmdGVyIHggbmVnX2luZmluaXR5XG5cbmV4dGVybmFsIGNvcHlfc2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0XG4gICAgICAgICAgICAgICAgICA9IFwiY2FtbF9jb3B5c2lnbl9mbG9hdFwiIFwiY2FtbF9jb3B5c2lnblwiXG4gICAgICAgICAgICAgICAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgc2lnbl9iaXQgOiAoZmxvYXQgW0B1bmJveGVkXSkgLT4gYm9vbFxuICA9IFwiY2FtbF9zaWduYml0X2Zsb2F0XCIgXCJjYW1sX3NpZ25iaXRcIiBbQEBub2FsbG9jXVxuXG5leHRlcm5hbCBmcmV4cCA6IGZsb2F0IC0+IGZsb2F0ICogaW50ID0gXCJjYW1sX2ZyZXhwX2Zsb2F0XCJcbmV4dGVybmFsIGxkZXhwIDogKGZsb2F0IFtAdW5ib3hlZF0pIC0+IChpbnQgW0B1bnRhZ2dlZF0pIC0+IChmbG9hdCBbQHVuYm94ZWRdKSA9XG4gIFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG1vZGYgOiBmbG9hdCAtPiBmbG9hdCAqIGZsb2F0ID0gXCJjYW1sX21vZGZfZmxvYXRcIlxudHlwZSB0ID0gZmxvYXRcbmV4dGVybmFsIGNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmxldCBlcXVhbCB4IHkgPSBjb21wYXJlIHggeSA9IDBcblxubGV0W0BpbmxpbmVdIG1pbiAoeDogZmxvYXQpICh5OiBmbG9hdCkgPVxuICBpZiB5ID4geCB8fCAobm90KHNpZ25fYml0IHkpICYmIHNpZ25fYml0IHgpIHRoZW5cbiAgICBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG4gIGVsc2UgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxuXG5sZXRbQGlubGluZV0gbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlblxuICAgIGlmIGlzX25hbiB4IHRoZW4geCBlbHNlIHlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuIHkgZWxzZSB4XG5cbmxldFtAaW5saW5lXSBtaW5fbWF4ICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHx8IGlzX25hbiB5IHRoZW4gKG5hbiwgbmFuKVxuICBlbHNlIGlmIHkgPiB4IHx8IChub3Qoc2lnbl9iaXQgeSkgJiYgc2lnbl9iaXQgeCkgdGhlbiAoeCwgeSkgZWxzZSAoeSwgeClcblxubGV0W0BpbmxpbmVdIG1pbl9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHggdGhlbiB5IGVsc2UgeFxuICBlbHNlIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIHlcblxubGV0W0BpbmxpbmVdIG1heF9udW0gKHg6IGZsb2F0KSAoeTogZmxvYXQpID1cbiAgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuXG4gICAgaWYgaXNfbmFuIHkgdGhlbiB4IGVsc2UgeVxuICBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIHhcblxubGV0W0BpbmxpbmVdIG1pbl9tYXhfbnVtICh4OiBmbG9hdCkgKHk6IGZsb2F0KSA9XG4gIGlmIGlzX25hbiB4IHRoZW4gKHkseSlcbiAgZWxzZSBpZiBpc19uYW4geSB0aGVuICh4LHgpXG4gIGVsc2UgaWYgeSA+IHggfHwgKG5vdChzaWduX2JpdCB5KSAmJiBzaWduX2JpdCB4KSB0aGVuICh4LHkpIGVsc2UgKHkseClcblxuZXh0ZXJuYWwgc2VlZGVkX2hhc2hfcGFyYW0gOiBpbnQgLT4gaW50IC0+IGludCAtPiBmbG9hdCAtPiBpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX2hhc2hcIiBbQEBub2FsbG9jXVxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG5cbiAgdHlwZSB0ID0gZmxvYXRhcnJheVxuXG4gIGV4dGVybmFsIGxlbmd0aCA6IHQgLT4gaW50ID0gXCIlZmxvYXRhcnJheV9sZW5ndGhcIlxuICBleHRlcm5hbCBnZXQgOiB0IC0+IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBzZXQgOiB0IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCIlZmxvYXRhcnJheV9zYWZlX3NldFwiXG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiB0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfY3JlYXRlXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHQgLT4gaW50IC0+IGZsb2F0ID0gXCIlZmxvYXRhcnJheV91bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldCA6IHQgLT4gaW50IC0+IGZsb2F0IC0+IHVuaXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGxldCB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdiA9XG4gICAgZm9yIGkgPSBvZnMgdG8gb2ZzICsgbGVuIC0gMSBkbyB1bnNhZmVfc2V0IGEgaSB2IGRvbmVcblxuICBsZXQgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRvZnMgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNvZnMgKyBpKSlcbiAgICBkb25lXG5cbiAgbGV0IGNoZWNrIGEgb2ZzIGxlbiBtc2cgPVxuICAgIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgKyBsZW4gPCAwIHx8IG9mcyArIGxlbiA+IGxlbmd0aCBhIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIG1zZ1xuXG4gIGxldCBtYWtlIG4gdiA9XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBuIGluXG4gICAgdW5zYWZlX2ZpbGwgcmVzdWx0IDAgbiB2O1xuICAgIHJlc3VsdFxuXG4gIGxldCBpbml0IGwgZiA9XG4gICAgaWYgbCA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkZsb2F0LkFycmF5LmluaXRcIlxuICAgIGVsc2VcbiAgICAgIGxldCByZXMgPSBjcmVhdGUgbCBpblxuICAgICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgcmVzIGkgKGYgaSlcbiAgICAgIGRvbmU7XG4gICAgICByZXNcblxuICBsZXQgYXBwZW5kIGExIGEyID1cbiAgICBsZXQgbDEgPSBsZW5ndGggYTEgaW5cbiAgICBsZXQgbDIgPSBsZW5ndGggYTIgaW5cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChsMSArIGwyKSBpblxuICAgIHVuc2FmZV9ibGl0IGExIDAgcmVzdWx0IDAgbDE7XG4gICAgdW5zYWZlX2JsaXQgYTIgMCByZXN1bHQgbDEgbDI7XG4gICAgcmVzdWx0XG5cbiAgKCogbmV4dCAzIGZ1bmN0aW9uczogbW9kaWZpZWQgY29weSBvZiBjb2RlIGZyb20gc3RyaW5nLm1sICopXG4gIGxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID1cbiAgICBpZiB4ID49IHkgdGhlbiB4IGVsc2UgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5jb25jYXRcIlxuXG4gIGxldCByZWMgc3VtX2xlbmd0aHMgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaGQgOjogdGwgLT4gc3VtX2xlbmd0aHMgKGVuc3VyZV9nZSAobGVuZ3RoIGhkICsgYWNjKSBhY2MpIHRsXG5cbiAgbGV0IGNvbmNhdCBsID1cbiAgICBsZXQgbGVuID0gc3VtX2xlbmd0aHMgMCBsIGluXG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICBsZXQgcmVjIGxvb3AgbCBpID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBhc3NlcnQgKGkgPSBsZW4pXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIGxldCBobGVuID0gbGVuZ3RoIGhkIGluXG4gICAgICAgIHVuc2FmZV9ibGl0IGhkIDAgcmVzdWx0IGkgaGxlbjtcbiAgICAgICAgbG9vcCB0bCAoaSArIGhsZW4pXG4gICAgaW5cbiAgICBsb29wIGwgMDtcbiAgICByZXN1bHRcblxuICBsZXQgc3ViIGEgb2ZzIGxlbiA9XG4gICAgY2hlY2sgYSBvZnMgbGVuIFwiRmxvYXQuQXJyYXkuc3ViXCI7XG4gICAgbGV0IHJlc3VsdCA9IGNyZWF0ZSBsZW4gaW5cbiAgICB1bnNhZmVfYmxpdCBhIG9mcyByZXN1bHQgMCBsZW47XG4gICAgcmVzdWx0XG5cbiAgbGV0IGNvcHkgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByZXN1bHQgPSBjcmVhdGUgbCBpblxuICAgIHVuc2FmZV9ibGl0IGEgMCByZXN1bHQgMCBsO1xuICAgIHJlc3VsdFxuXG4gIGxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgICBjaGVjayBhIG9mcyBsZW4gXCJGbG9hdC5BcnJheS5maWxsXCI7XG4gICAgdW5zYWZlX2ZpbGwgYSBvZnMgbGVuIHZcblxuICBsZXQgYmxpdCBzcmMgc29mcyBkc3QgZG9mcyBsZW4gPVxuICAgIGNoZWNrIHNyYyBzb2ZzIGxlbiBcIkZsb2F0LmFycmF5LmJsaXRcIjtcbiAgICBjaGVjayBkc3QgZG9mcyBsZW4gXCJGbG9hdC5hcnJheS5ibGl0XCI7XG4gICAgdW5zYWZlX2JsaXQgc3JjIHNvZnMgZHN0IGRvZnMgbGVuXG5cbiAgbGV0IHRvX2xpc3QgYSA9XG4gICAgTGlzdC5pbml0IChsZW5ndGggYSkgKHVuc2FmZV9nZXQgYSlcblxuICBsZXQgb2ZfbGlzdCBsID1cbiAgICBsZXQgcmVzdWx0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICAgIGxldCByZWMgZmlsbCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IHJlc3VsdFxuICAgICAgfCBoIDo6IHQgLT4gdW5zYWZlX3NldCByZXN1bHQgaSBoOyBmaWxsIChpICsgMSkgdFxuICAgIGluXG4gICAgZmlsbCAwIGxcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGl0ZXIgZiBhID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyMiBmIGEgYiA9XG4gICAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJGbG9hdC5BcnJheS5pdGVyMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2VcbiAgICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG4gIGxldCBtYXAgZiBhID1cbiAgICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gICAgbGV0IHIgPSBjcmVhdGUgbCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICBsZXQgbWFwMiBmIGEgYiA9XG4gICAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgbGIgPSBsZW5ndGggYiBpblxuICAgIGlmIGxhIDw+IGxiIHRoZW5cbiAgICAgIGludmFsaWRfYXJnIFwiRmxvYXQuQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gY3JlYXRlIGxhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBpdGVyaSBmIGEgPVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IGEgaSkgZG9uZVxuXG4gIGxldCBtYXBpIGYgYSA9XG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gICAgZG9uZTtcbiAgICAhclxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgZm9sZF9yaWdodCBmIGEgeCA9XG4gICAgbGV0IHIgPSByZWYgeCBpblxuICAgIGZvciBpID0gbGVuZ3RoIGEgLSAxIGRvd250byAwIGRvXG4gICAgICByIDo9IGYgKHVuc2FmZV9nZXQgYSBpKSAhclxuICAgIGRvbmU7XG4gICAgIXJcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IGV4aXN0cyBwIGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgYSBpKSB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gICAgbG9vcCAwXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBmb3JfYWxsIHAgYSA9XG4gICAgbGV0IG4gPSBsZW5ndGggYSBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPSBuIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChpICsgMSlcbiAgICAgIGVsc2UgZmFsc2UgaW5cbiAgICBsb29wIDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IG1lbSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIGNvbXBhcmUgKHVuc2FmZV9nZXQgYSBpKSB4ID0gMCB0aGVuIHRydWVcbiAgICAgIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sLCBidXQgc2xpZ2h0bHkgZGlmZmVyZW50ICopXG4gIGxldCBtZW1faWVlZSB4IGEgPVxuICAgIGxldCBuID0gbGVuZ3RoIGEgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID0gbiB0aGVuIGZhbHNlXG4gICAgICBlbHNlIGlmIHggPSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBleGNlcHRpb24gQm90dG9tIG9mIGludFxuICBsZXQgc29ydCBjbXAgYSA9XG4gICAgbGV0IG1heHNvbiBsIGkgPVxuICAgICAgbGV0IGkzMSA9IGkraStpKzEgaW5cbiAgICAgIGxldCB4ID0gcmVmIGkzMSBpblxuICAgICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgY21wIChnZXQgYSBpMzEpIChnZXQgYSAoaTMxKzEpKSA8IDAgdGhlbiB4IDo9IGkzMSsxO1xuICAgICAgICBpZiBjbXAgKGdldCBhICF4KSAoZ2V0IGEgKGkzMSsyKSkgPCAwIHRoZW4geCA6PSBpMzErMjtcbiAgICAgICAgIXhcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGlmIGkzMSsxIDwgbCAmJiBjbXAgKGdldCBhIGkzMSkgKGdldCBhIChpMzErMSkpIDwgMFxuICAgICAgICB0aGVuIGkzMSsxXG4gICAgICAgIGVsc2UgaWYgaTMxIDwgbCB0aGVuIGkzMSBlbHNlIHJhaXNlIChCb3R0b20gaSlcbiAgICBpblxuICAgIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgICBpZiBjbXAgKGdldCBhIGopIGUgPiAwIHRoZW4gYmVnaW5cbiAgICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICAgIHRyaWNrbGVkb3duIGwgaiBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgICBsZXQgcmVjIGJ1YmJsZWRvd24gbCBpID1cbiAgICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICBidWJibGVkb3duIGwgalxuICAgIGluXG4gICAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gICAgbGV0IHJlYyB0cmlja2xldXAgaSBlID1cbiAgICAgIGxldCBmYXRoZXIgPSAoaSAtIDEpIC8gMyBpblxuICAgICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgICBpZiBjbXAgKGdldCBhIGZhdGhlcikgZSA8IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgYSBpIChnZXQgYSBmYXRoZXIpO1xuICAgICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGEgaSBlO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbGV0IGwgPSBsZW5ndGggYSBpblxuICAgIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgICBmb3IgaSA9IGwgLSAxIGRvd250byAyIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSBpKSBpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgICB0cmlja2xldXAgKGJ1YmJsZSBpIDApIGU7XG4gICAgZG9uZTtcbiAgICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCwgZXhjZXB0IGZvciB0aGUgY2FsbCB0byBbY3JlYXRlXSAqKVxuICBsZXQgY3V0b2ZmID0gNVxuICBsZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICAgIGxldCBtZXJnZSBzcmMxb2ZzIHNyYzFsZW4gc3JjMiBzcmMyb2ZzIHNyYzJsZW4gZHN0IGRzdG9mcyA9XG4gICAgICBsZXQgc3JjMXIgPSBzcmMxb2ZzICsgc3JjMWxlbiBhbmQgc3JjMnIgPSBzcmMyb2ZzICsgc3JjMmxlbiBpblxuICAgICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgICBpZiBjbXAgczEgczIgPD0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMxO1xuICAgICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICAgIGlmIGkxIDwgc3JjMXIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSAoZ2V0IGEgaTEpIGkyIHMyIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IHNyYzIgaTIgZHN0IChkICsgMSkgKHNyYzJyIC0gaTIpXG4gICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICAgIGxldCBpMiA9IGkyICsgMSBpblxuICAgICAgICAgIGlmIGkyIDwgc3JjMnIgdGhlblxuICAgICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBibGl0IGEgaTEgZHN0IChkICsgMSkgKHNyYzFyIC0gaTEpXG4gICAgICAgIGVuZFxuICAgICAgaW4gbG9vcCBzcmMxb2ZzIChnZXQgYSBzcmMxb2ZzKSBzcmMyb2ZzIChnZXQgc3JjMiBzcmMyb2ZzKSBkc3RvZnM7XG4gICAgaW5cbiAgICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgbGV0IGUgPSAoZ2V0IGEgKHNyY29mcyArIGkpKSBpblxuICAgICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICAgIHdoaWxlICghaiA+PSBkc3RvZnMgJiYgY21wIChnZXQgZHN0ICFqKSBlID4gMCkgZG9cbiAgICAgICAgICBzZXQgZHN0ICghaiArIDEpIChnZXQgZHN0ICFqKTtcbiAgICAgICAgICBkZWNyIGo7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgZTtcbiAgICAgIGRvbmU7XG4gICAgaW5cbiAgICBsZXQgcmVjIHNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGwxID0gbGVuIC8gMiBpblxuICAgICAgICBsZXQgbDIgPSBsZW4gLSBsMSBpblxuICAgICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgICAgc29ydHRvIHNyY29mcyBhIChzcmNvZnMgKyBsMikgbDE7XG4gICAgICAgIG1lcmdlIChzcmNvZnMgKyBsMikgbDEgZHN0IChkc3RvZnMgKyBsMSkgbDIgZHN0IGRzdG9mcztcbiAgICAgIGVuZDtcbiAgICBpblxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgICBsZXQgbDEgPSBsIC8gMiBpblxuICAgICAgbGV0IGwyID0gbCAtIGwxIGluXG4gICAgICBsZXQgdCA9IGNyZWF0ZSBsMiBpblxuICAgICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICAgIHNvcnR0byAwIGEgbDIgbDE7XG4gICAgICBtZXJnZSBsMiBsMSB0IDAgbDIgYSAwO1xuICAgIGVuZFxuXG4gIGxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4gICgqIGR1cGxpY2F0ZWQgZnJvbSBhcnJheS5tbCAqKVxuICBsZXQgdG9fc2VxIGEgPVxuICAgIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgICB0aGVuXG4gICAgICAgIGxldCB4ID0gdW5zYWZlX2dldCBhIGkgaW5cbiAgICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBkdXBsaWNhdGVkIGZyb20gYXJyYXkubWwgKilcbiAgbGV0IHRvX3NlcWkgYSA9XG4gICAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICAgIHRoZW5cbiAgICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgICAgIGVsc2UgU2VxLk5pbFxuICAgIGluXG4gICAgYXV4IDBcblxuICAoKiBtb3N0bHkgZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9yZXZfbGlzdCBsID1cbiAgICBsZXQgbGVuID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBhID0gY3JlYXRlIGxlbiBpblxuICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgW10gLT4gYVxuICAgICAgfCBoZDo6dGwgLT4gdW5zYWZlX3NldCBhIGkgaGQ7IGZpbGwgKGktMSkgdGxcbiAgICBpblxuICAgIGZpbGwgKGxlbi0xKSBsXG5cbiAgKCogZHVwbGljYXRlZCBmcm9tIGFycmF5Lm1sICopXG4gIGxldCBvZl9zZXEgaSA9XG4gICAgbGV0IGwgPSBTZXEuZm9sZF9sZWZ0IChmdW4gYWNjIHggLT4geDo6YWNjKSBbXSBpIGluXG4gICAgb2ZfcmV2X2xpc3QgbFxuXG5cbiAgbGV0IG1hcF90b19hcnJheSBmIGEgPVxuICAgIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgICBpZiBsID0gMCB0aGVuIFt8IHxdIGVsc2UgYmVnaW5cbiAgICAgIGxldCByID0gQXJyYXkubWFrZSBsIChmICh1bnNhZmVfZ2V0IGEgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgICAgQXJyYXkudW5zYWZlX3NldCByIGkgKGYgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG5cbiAgbGV0IG1hcF9mcm9tX2FycmF5IGYgYSA9XG4gICAgbGV0IGwgPSBBcnJheS5sZW5ndGggYSBpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIChBcnJheS51bnNhZmVfZ2V0IGEgaSkpXG4gICAgZG9uZTtcbiAgICByXG5cbmVuZFxuXG5tb2R1bGUgQXJyYXlMYWJlbHMgPSBBcnJheVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW05hdGl2ZWludF06IHByb2Nlc3Nvci1uYXRpdmUgaW50ZWdlcnMgKilcblxuZXh0ZXJuYWwgbmVnOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X25lZ1wiXG5leHRlcm5hbCBhZGQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FkZFwiXG5leHRlcm5hbCBzdWI6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X3N1YlwiXG5leHRlcm5hbCBtdWw6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X211bFwiXG5leHRlcm5hbCBkaXY6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2RpdlwiXG5leHRlcm5hbCByZW06IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X21vZFwiXG5leHRlcm5hbCBsb2dhbmQ6IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50ID0gXCIlbmF0aXZlaW50X2FuZFwiXG5leHRlcm5hbCBsb2dvcjogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb3JcIlxuZXh0ZXJuYWwgbG9neG9yOiBuYXRpdmVpbnQgLT4gbmF0aXZlaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF94b3JcIlxuZXh0ZXJuYWwgc2hpZnRfbGVmdDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0OiBuYXRpdmVpbnQgLT4gaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9hc3JcIlxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbDogbmF0aXZlaW50IC0+IGludCAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfbHNyXCJcbmV4dGVybmFsIG9mX2ludDogaW50IC0+IG5hdGl2ZWludCA9IFwiJW5hdGl2ZWludF9vZl9pbnRcIlxuZXh0ZXJuYWwgdG9faW50OiBuYXRpdmVpbnQgLT4gaW50ID0gXCIlbmF0aXZlaW50X3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IG5hdGl2ZWludFxuICA9IFwiY2FtbF9uYXRpdmVpbnRfb2ZfZmxvYXRcIiBcImNhbWxfbmF0aXZlaW50X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBuYXRpdmVpbnQgLT4gZmxvYXRcbiAgPSBcImNhbWxfbmF0aXZlaW50X3RvX2Zsb2F0XCIgXCJjYW1sX25hdGl2ZWludF90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIG9mX2ludDMyOiBpbnQzMiAtPiBuYXRpdmVpbnQgPSBcIiVuYXRpdmVpbnRfb2ZfaW50MzJcIlxuZXh0ZXJuYWwgdG9faW50MzI6IG5hdGl2ZWludCAtPiBpbnQzMiA9IFwiJW5hdGl2ZWludF90b19pbnQzMlwiXG5cbmxldCB6ZXJvID0gMG5cbmxldCBvbmUgPSAxblxubGV0IG1pbnVzX29uZSA9IC0xblxubGV0IHN1Y2MgbiA9IGFkZCBuIDFuXG5sZXQgcHJlZCBuID0gc3ViIG4gMW5cbmxldCBhYnMgbiA9IGlmIG4gPj0gMG4gdGhlbiBuIGVsc2UgbmVnIG5cbmxldCBzaXplID0gU3lzLndvcmRfc2l6ZVxubGV0IG1pbl9pbnQgPSBzaGlmdF9sZWZ0IDFuIChzaXplIC0gMSlcbmxldCBtYXhfaW50ID0gc3ViIG1pbl9pbnQgMW5cbmxldCBsb2dub3QgbiA9IGxvZ3hvciBuICgtMW4pXG5cbmxldCB1bnNpZ25lZF90b19pbnQgPVxuICBsZXQgbWF4X2ludCA9IG9mX2ludCBTdGRsaWIubWF4X2ludCBpblxuICBmdW4gbiAtPlxuICAgIGlmIGNvbXBhcmUgemVybyBuIDw9IDAgJiYgY29tcGFyZSBuIG1heF9pbnQgPD0gMCB0aGVuXG4gICAgICBTb21lICh0b19pbnQgbilcbiAgICBlbHNlXG4gICAgICBOb25lXG5cbmV4dGVybmFsIGZvcm1hdCA6IHN0cmluZyAtPiBuYXRpdmVpbnQgLT4gc3RyaW5nID0gXCJjYW1sX25hdGl2ZWludF9mb3JtYXRcIlxubGV0IHRvX3N0cmluZyBuID0gZm9ybWF0IFwiJWRcIiBuXG5cbmV4dGVybmFsIG9mX3N0cmluZzogc3RyaW5nIC0+IG5hdGl2ZWludCA9IFwiY2FtbF9uYXRpdmVpbnRfb2Zfc3RyaW5nXCJcblxubGV0IG9mX3N0cmluZ19vcHQgcyA9XG4gICgqIFRPRE86IGV4cG9zZSBhIG5vbi1yYWlzaW5nIHByaW1pdGl2ZSBkaXJlY3RseS4gKilcbiAgdHJ5IFNvbWUgKG9mX3N0cmluZyBzKVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbnR5cGUgdCA9IG5hdGl2ZWludFxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogQW4gYWxpYXMgZm9yIHRoZSB0eXBlIG9mIGxpc3RzLiAqKVxudHlwZSAnYSB0ID0gJ2EgbGlzdCA9IFtdIHwgKDo6KSBvZiAnYSAqICdhIGxpc3RcblxuKCogTGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZWMgbGVuZ3RoX2F1eCBsZW4gPSBmdW5jdGlvblxuICAgIFtdIC0+IGxlblxuICB8IF86OmwgLT4gbGVuZ3RoX2F1eCAobGVuICsgMSkgbFxuXG5sZXQgbGVuZ3RoIGwgPSBsZW5ndGhfYXV4IDAgbFxuXG5sZXQgY29ucyBhIGwgPSBhOjpsXG5cbmxldCBoZCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJoZFwiXG4gIHwgYTo6XyAtPiBhXG5cbmxldCB0bCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZmFpbHdpdGggXCJ0bFwiXG4gIHwgXzo6bCAtPiBsXG5cbmxldCBudGggbCBuID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkxpc3QubnRoXCIgZWxzZVxuICBsZXQgcmVjIG50aF9hdXggbCBuID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IGZhaWx3aXRoIFwibnRoXCJcbiAgICB8IGE6OmwgLT4gaWYgbiA9IDAgdGhlbiBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBudGhfb3B0IGwgbiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0Lm50aFwiIGVsc2VcbiAgbGV0IHJlYyBudGhfYXV4IGwgbiA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCBhOjpsIC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCBsIChuLTEpXG4gIGluIG50aF9hdXggbCBuXG5cbmxldCBhcHBlbmQgPSAoQClcblxubGV0IHJlYyByZXZfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEgd2l0aFxuICAgIFtdIC0+IGwyXG4gIHwgYSA6OiBsIC0+IHJldl9hcHBlbmQgbCAoYSA6OiBsMilcblxubGV0IHJldiBsID0gcmV2X2FwcGVuZCBsIFtdXG5cbmxldCByZWMgaW5pdF90YWlscmVjX2F1eCBhY2MgaSBuIGYgPVxuICBpZiBpID49IG4gdGhlbiBhY2NcbiAgZWxzZSBpbml0X3RhaWxyZWNfYXV4IChmIGkgOjogYWNjKSAoaSsxKSBuIGZcblxubGV0IHJlYyBpbml0X2F1eCBpIG4gZiA9XG4gIGlmIGkgPj0gbiB0aGVuIFtdXG4gIGVsc2VcbiAgICBsZXQgciA9IGYgaSBpblxuICAgIHIgOjogaW5pdF9hdXggKGkrMSkgbiBmXG5cbmxldCByZXZfaW5pdF90aHJlc2hvbGQgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDEwXzAwMFxuICAoKiBXZSBkb24ndCBrbm93IHRoZSBzaXplIG9mIHRoZSBzdGFjaywgYmV0dGVyIGJlIHNhZmUgYW5kIGFzc3VtZSBpdCdzXG4gICAgIHNtYWxsLiAqKVxuICB8IFN5cy5PdGhlciBfIC0+IDUwXG5cbmxldCBpbml0IGxlbiBmID1cbiAgaWYgbGVuIDwgMCB0aGVuIGludmFsaWRfYXJnIFwiTGlzdC5pbml0XCIgZWxzZVxuICBpZiBsZW4gPiByZXZfaW5pdF90aHJlc2hvbGQgdGhlbiByZXYgKGluaXRfdGFpbHJlY19hdXggW10gMCBsZW4gZilcbiAgZWxzZSBpbml0X2F1eCAwIGxlbiBmXG5cbmxldCByZWMgZmxhdHRlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBsOjpyIC0+IGwgQCBmbGF0dGVuIHJcblxubGV0IGNvbmNhdCA9IGZsYXR0ZW5cblxubGV0IHJlYyBtYXAgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW11cbiAgfCBhOjpsIC0+IGxldCByID0gZiBhIGluIHIgOjogbWFwIGYgbFxuXG5sZXQgcmVjIG1hcGkgaSBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiBbXVxuICB8IGE6OmwgLT4gbGV0IHIgPSBmIGkgYSBpbiByIDo6IG1hcGkgKGkgKyAxKSBmIGxcblxubGV0IG1hcGkgZiBsID0gbWFwaSAwIGYgbFxuXG5sZXQgcmV2X21hcCBmIGwgPVxuICBsZXQgcmVjIHJtYXBfZiBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY3VcbiAgICB8IGE6OmwgLT4gcm1hcF9mIChmIGEgOjogYWNjdSkgbFxuICBpblxuICBybWFwX2YgW10gbFxuXG5cbmxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICBbXSAtPiAoKVxuICB8IGE6OmwgLT4gZiBhOyBpdGVyIGYgbFxuXG5sZXQgcmVjIGl0ZXJpIGkgZiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gKClcbiAgfCBhOjpsIC0+IGYgaSBhOyBpdGVyaSAoaSArIDEpIGYgbFxuXG5sZXQgaXRlcmkgZiBsID0gaXRlcmkgMCBmIGxcblxubGV0IHJlYyBmb2xkX2xlZnQgZiBhY2N1IGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAtPiBhY2N1XG4gIHwgYTo6bCAtPiBmb2xkX2xlZnQgZiAoZiBhY2N1IGEpIGxcblxubGV0IHJlYyBmb2xkX3JpZ2h0IGYgbCBhY2N1ID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gLT4gYWNjdVxuICB8IGE6OmwgLT4gZiBhIChmb2xkX3JpZ2h0IGYgbCBhY2N1KVxuXG5sZXQgcmVjIG1hcDIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBbXVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gbGV0IHIgPSBmIGExIGEyIGluIHIgOjogbWFwMiBmIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5tYXAyXCJcblxubGV0IHJldl9tYXAyIGYgbDEgbDIgPVxuICBsZXQgcmVjIHJtYXAyX2YgYWNjdSBsMSBsMiA9XG4gICAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIHwgKFtdLCBbXSkgLT4gYWNjdVxuICAgIHwgKGExOjpsMSwgYTI6OmwyKSAtPiBybWFwMl9mIChmIGExIGEyIDo6IGFjY3UpIGwxIGwyXG4gICAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJldl9tYXAyXCJcbiAgaW5cbiAgcm1hcDJfZiBbXSBsMSBsMlxuXG5cbmxldCByZWMgaXRlcjIgZiBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiAoKVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gZiBhMSBhMjsgaXRlcjIgZiBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuaXRlcjJcIlxuXG5sZXQgcmVjIGZvbGRfbGVmdDIgZiBhY2N1IGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGZvbGRfbGVmdDIgZiAoZiBhY2N1IGExIGEyKSBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9sZF9sZWZ0MlwiXG5cbmxldCByZWMgZm9sZF9yaWdodDIgZiBsMSBsMiBhY2N1ID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IGFjY3VcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IGYgYTEgYTIgKGZvbGRfcmlnaHQyIGYgbDEgbDIgYWNjdSlcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmZvbGRfcmlnaHQyXCJcblxubGV0IHJlYyBmb3JfYWxsIHAgPSBmdW5jdGlvblxuICAgIFtdIC0+IHRydWVcbiAgfCBhOjpsIC0+IHAgYSAmJiBmb3JfYWxsIHAgbFxuXG5sZXQgcmVjIGV4aXN0cyBwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gcCBhIHx8IGV4aXN0cyBwIGxcblxubGV0IHJlYyBmb3JfYWxsMiBwIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IHRydWVcbiAgfCAoYTE6OmwxLCBhMjo6bDIpIC0+IHAgYTEgYTIgJiYgZm9yX2FsbDIgcCBsMSBsMlxuICB8IChfLCBfKSAtPiBpbnZhbGlkX2FyZyBcIkxpc3QuZm9yX2FsbDJcIlxuXG5sZXQgcmVjIGV4aXN0czIgcCBsMSBsMiA9XG4gIG1hdGNoIChsMSwgbDIpIHdpdGhcbiAgICAoW10sIFtdKSAtPiBmYWxzZVxuICB8IChhMTo6bDEsIGEyOjpsMikgLT4gcCBhMSBhMiB8fCBleGlzdHMyIHAgbDEgbDJcbiAgfCAoXywgXykgLT4gaW52YWxpZF9hcmcgXCJMaXN0LmV4aXN0czJcIlxuXG5sZXQgcmVjIG1lbSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBmYWxzZVxuICB8IGE6OmwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbSB4IGxcblxubGV0IHJlYyBtZW1xIHggPSBmdW5jdGlvblxuICAgIFtdIC0+IGZhbHNlXG4gIHwgYTo6bCAtPiBhID09IHggfHwgbWVtcSB4IGxcblxubGV0IHJlYyBhc3NvYyB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBiIGVsc2UgYXNzb2MgeCBsXG5cbmxldCByZWMgYXNzb2Nfb3B0IHggPSBmdW5jdGlvblxuICAgIFtdIC0+IE5vbmVcbiAgfCAoYSxiKTo6bCAtPiBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBTb21lIGIgZWxzZSBhc3NvY19vcHQgeCBsXG5cbmxldCByZWMgYXNzcSB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgfCAoYSxiKTo6bCAtPiBpZiBhID09IHggdGhlbiBiIGVsc2UgYXNzcSB4IGxcblxubGV0IHJlYyBhc3NxX29wdCB4ID0gZnVuY3Rpb25cbiAgICBbXSAtPiBOb25lXG4gIHwgKGEsYik6OmwgLT4gaWYgYSA9PSB4IHRoZW4gU29tZSBiIGVsc2UgYXNzcV9vcHQgeCBsXG5cbmxldCByZWMgbWVtX2Fzc29jIHggPSBmdW5jdGlvblxuICB8IFtdIC0+IGZhbHNlXG4gIHwgKGEsIF8pIDo6IGwgLT4gY29tcGFyZSBhIHggPSAwIHx8IG1lbV9hc3NvYyB4IGxcblxubGV0IHJlYyBtZW1fYXNzcSB4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBmYWxzZVxuICB8IChhLCBfKSA6OiBsIC0+IGEgPT0geCB8fCBtZW1fYXNzcSB4IGxcblxubGV0IHJlYyByZW1vdmVfYXNzb2MgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+XG4gICAgICBpZiBjb21wYXJlIGEgeCA9IDAgdGhlbiBsIGVsc2UgcGFpciA6OiByZW1vdmVfYXNzb2MgeCBsXG5cbmxldCByZWMgcmVtb3ZlX2Fzc3EgeCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAoYSwgXyBhcyBwYWlyKSA6OiBsIC0+IGlmIGEgPT0geCB0aGVuIGwgZWxzZSBwYWlyIDo6IHJlbW92ZV9hc3NxIHggbFxuXG5sZXQgcmVjIGZpbmQgcCA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHggZWxzZSBmaW5kIHAgbFxuXG5sZXQgcmVjIGZpbmRfb3B0IHAgPSBmdW5jdGlvblxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IGwgLT4gaWYgcCB4IHRoZW4gU29tZSB4IGVsc2UgZmluZF9vcHQgcCBsXG5cbmxldCByZWMgZmluZF9tYXAgZiA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gTm9uZVxuICB8IHggOjogbCAtPlxuICAgICBiZWdpbiBtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgU29tZSBfIGFzIHJlc3VsdCAtPiByZXN1bHRcbiAgICAgICB8IE5vbmUgLT4gZmluZF9tYXAgZiBsXG4gICAgIGVuZFxuXG5sZXQgZmluZF9hbGwgcCA9XG4gIGxldCByZWMgZmluZCBhY2N1ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiByZXYgYWNjdVxuICB8IHggOjogbCAtPiBpZiBwIHggdGhlbiBmaW5kICh4IDo6IGFjY3UpIGwgZWxzZSBmaW5kIGFjY3UgbCBpblxuICBmaW5kIFtdXG5cbmxldCBmaWx0ZXIgPSBmaW5kX2FsbFxuXG5sZXQgZmlsdGVyaSBwIGwgPVxuICBsZXQgcmVjIGF1eCBpIGFjYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gcmV2IGFjY1xuICB8IHg6OmwgLT4gYXV4IChpICsgMSkgKGlmIHAgaSB4IHRoZW4geDo6YWNjIGVsc2UgYWNjKSBsXG4gIGluXG4gIGF1eCAwIFtdIGxcblxubGV0IGZpbHRlcl9tYXAgZiA9XG4gIGxldCByZWMgYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY3VcbiAgICB8IHggOjogbCAtPlxuICAgICAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgICB8IE5vbmUgLT4gYXV4IGFjY3UgbFxuICAgICAgICB8IFNvbWUgdiAtPiBhdXggKHYgOjogYWNjdSkgbFxuICBpblxuICBhdXggW11cblxubGV0IGNvbmNhdF9tYXAgZiBsID1cbiAgbGV0IHJlYyBhdXggZiBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmV2IGFjY1xuICAgIHwgeCA6OiBsIC0+XG4gICAgICAgbGV0IHhzID0gZiB4IGluXG4gICAgICAgYXV4IGYgKHJldl9hcHBlbmQgeHMgYWNjKSBsXG4gIGluIGF1eCBmIFtdIGxcblxubGV0IGZvbGRfbGVmdF9tYXAgZiBhY2N1IGwgPVxuICBsZXQgcmVjIGF1eCBhY2N1IGxfYWNjdSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2N1LCByZXYgbF9hY2N1XG4gICAgfCB4IDo6IGwgLT5cbiAgICAgICAgbGV0IGFjY3UsIHggPSBmIGFjY3UgeCBpblxuICAgICAgICBhdXggYWNjdSAoeCA6OiBsX2FjY3UpIGwgaW5cbiAgYXV4IGFjY3UgW10gbFxuXG5sZXQgcGFydGl0aW9uIHAgbCA9XG4gIGxldCByZWMgcGFydCB5ZXMgbm8gPSBmdW5jdGlvblxuICB8IFtdIC0+IChyZXYgeWVzLCByZXYgbm8pXG4gIHwgeCA6OiBsIC0+IGlmIHAgeCB0aGVuIHBhcnQgKHggOjogeWVzKSBubyBsIGVsc2UgcGFydCB5ZXMgKHggOjogbm8pIGwgaW5cbiAgcGFydCBbXSBbXSBsXG5cbmxldCByZWMgc3BsaXQgPSBmdW5jdGlvblxuICAgIFtdIC0+IChbXSwgW10pXG4gIHwgKHgseSk6OmwgLT5cbiAgICAgIGxldCAocngsIHJ5KSA9IHNwbGl0IGwgaW4gKHg6OnJ4LCB5OjpyeSlcblxubGV0IHJlYyBjb21iaW5lIGwxIGwyID1cbiAgbWF0Y2ggKGwxLCBsMikgd2l0aFxuICAgIChbXSwgW10pIC0+IFtdXG4gIHwgKGExOjpsMSwgYTI6OmwyKSAtPiAoYTEsIGEyKSA6OiBjb21iaW5lIGwxIGwyXG4gIHwgKF8sIF8pIC0+IGludmFsaWRfYXJnIFwiTGlzdC5jb21iaW5lXCJcblxuKCoqIHNvcnRpbmcgKilcblxubGV0IHJlYyBtZXJnZSBjbXAgbDEgbDIgPVxuICBtYXRjaCBsMSwgbDIgd2l0aFxuICB8IFtdLCBsMiAtPiBsMlxuICB8IGwxLCBbXSAtPiBsMVxuICB8IGgxIDo6IHQxLCBoMiA6OiB0MiAtPlxuICAgICAgaWYgY21wIGgxIGgyIDw9IDBcbiAgICAgIHRoZW4gaDEgOjogbWVyZ2UgY21wIHQxIGwyXG4gICAgICBlbHNlIGgyIDo6IG1lcmdlIGNtcCBsMSB0MlxuXG5cbmxldCBzdGFibGVfc29ydCBjbXAgbCA9XG4gIGxldCByZWMgcmV2X21lcmdlIGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPD0gMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBpZiBjbXAgaDEgaDIgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPSBpZiBjbXAgeDEgeDIgPD0gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA8PSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlIGlmIGNtcCB4MSB4MyA8PSAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzIDw9IDAgdGhlbiBbeDI7IHgxOyB4M11cbiAgICAgICAgICBlbHNlIGlmIGNtcCB4MiB4MyA8PSAwIHRoZW4gW3gyOyB4MzsgeDFdXG4gICAgICAgICAgZWxzZSBbeDM7IHgyOyB4MV1cbiAgICAgICAgaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgbiwgbCAtPlxuICAgICAgICBsZXQgbjEgPSBuIGFzciAxIGluXG4gICAgICAgIGxldCBuMiA9IG4gLSBuMSBpblxuICAgICAgICBsZXQgczEsIGwyID0gcmV2X3NvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gcmV2X3NvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZV9yZXYgczEgczIgW10sIHRsKVxuICBhbmQgcmV2X3NvcnQgbiBsID1cbiAgICBtYXRjaCBuLCBsIHdpdGhcbiAgICB8IDIsIHgxIDo6IHgyIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID0gaWYgY21wIHgxIHgyID4gMCB0aGVuIFt4MTsgeDJdIGVsc2UgW3gyOyB4MV0gaW5cbiAgICAgICAgKHMsIHRsKVxuICAgIHwgMywgeDEgOjogeDIgOjogeDMgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGlmIGNtcCB4MSB4MiA+IDAgdGhlblxuICAgICAgICAgICAgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MTsgeDI7IHgzXVxuICAgICAgICAgICAgZWxzZSBpZiBjbXAgeDEgeDMgPiAwIHRoZW4gW3gxOyB4MzsgeDJdXG4gICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgxIHgzID4gMCB0aGVuIFt4MjsgeDE7IHgzXVxuICAgICAgICAgIGVsc2UgaWYgY21wIHgyIHgzID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgIGVsc2UgW3gzOyB4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IG4sIGwgLT5cbiAgICAgICAgbGV0IG4xID0gbiBhc3IgMSBpblxuICAgICAgICBsZXQgbjIgPSBuIC0gbjEgaW5cbiAgICAgICAgbGV0IHMxLCBsMiA9IHNvcnQgbjEgbCBpblxuICAgICAgICBsZXQgczIsIHRsID0gc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlIHMxIHMyIFtdLCB0bClcbiAgaW5cbiAgbGV0IGxlbiA9IGxlbmd0aCBsIGluXG4gIGlmIGxlbiA8IDIgdGhlbiBsIGVsc2UgZnN0IChzb3J0IGxlbiBsKVxuXG5cbmxldCBzb3J0ID0gc3RhYmxlX3NvcnRcbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiBOb3RlOiBvbiBhIGxpc3Qgb2YgbGVuZ3RoIGJldHdlZW4gYWJvdXQgMTAwMDAwIChkZXBlbmRpbmcgb24gdGhlIG1pbm9yXG4gICBoZWFwIHNpemUgYW5kIHRoZSB0eXBlIG9mIHRoZSBsaXN0KSBhbmQgU3lzLm1heF9hcnJheV9zaXplLCBpdCBpc1xuICAgYWN0dWFsbHkgZmFzdGVyIHRvIHVzZSB0aGUgZm9sbG93aW5nLCBidXQgaXQgbWlnaHQgYWxzbyB1c2UgbW9yZSBtZW1vcnlcbiAgIGJlY2F1c2UgdGhlIGFyZ3VtZW50IGxpc3QgY2Fubm90IGJlIGRlYWxsb2NhdGVkIGluY3JlbWVudGFsbHkuXG5cbiAgIEFsc28sIHRoZXJlIHNlZW1zIHRvIGJlIGEgYnVnIGluIHRoaXMgY29kZSBvciBpbiB0aGVcbiAgIGltcGxlbWVudGF0aW9uIG9mIG9ial90cnVuY2F0ZS5cblxuZXh0ZXJuYWwgb2JqX3RydW5jYXRlIDogJ2EgYXJyYXkgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3RydW5jYXRlXCJcblxubGV0IGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYSA9XG4gIGxldCBsID0gQXJyYXkubGVuZ3RoIGEgaW5cbiAgbGV0IHJlYyBsb29wIGFjY3UgbiBwID1cbiAgICBpZiBwIDw9IDAgdGhlbiBhY2N1IGVsc2UgYmVnaW5cbiAgICAgIGlmIHAgPSBuIHRoZW4gYmVnaW5cbiAgICAgICAgb2JqX3RydW5jYXRlIGEgcDtcbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSAobi0xMDAwKSAocC0xKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbG9vcCAoYS4ocC0xKSA6OiBhY2N1KSBuIChwLTEpXG4gICAgICBlbmRcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBbXSAobC0xMDAwKSBsXG5cblxubGV0IHN0YWJsZV9zb3J0IGNtcCBsID1cbiAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgQXJyYXkuc3RhYmxlX3NvcnQgY21wIGE7XG4gIGFycmF5X3RvX2xpc3RfaW5fcGxhY2UgYVxuXG4qKVxuXG5cbigqKiBzb3J0aW5nICsgcmVtb3ZpbmcgZHVwbGljYXRlcyAqKVxuXG5sZXQgc29ydF91bmlxIGNtcCBsID1cbiAgbGV0IHJlYyByZXZfbWVyZ2UgbDEgbDIgYWNjdSA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBsMiAtPiByZXZfYXBwZW5kIGwyIGFjY3VcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGwxIGFjY3VcbiAgICB8IGgxOjp0MSwgaDI6OnQyIC0+XG4gICAgICAgIGxldCBjID0gY21wIGgxIGgyIGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gcmV2X21lcmdlIHQxIHQyIChoMTo6YWNjdSlcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIHJldl9tZXJnZSB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlIGwxIHQyIChoMjo6YWNjdSlcbiAgaW5cbiAgbGV0IHJlYyByZXZfbWVyZ2VfcmV2IGwxIGwyIGFjY3UgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBsMiBhY2N1XG4gICAgfCBsMSwgW10gLT4gcmV2X2FwcGVuZCBsMSBhY2N1XG4gICAgfCBoMTo6dDEsIGgyOjp0MiAtPlxuICAgICAgICBsZXQgYyA9IGNtcCBoMSBoMiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIHJldl9tZXJnZV9yZXYgdDEgdDIgKGgxOjphY2N1KVxuICAgICAgICBlbHNlIGlmIGMgPiAwXG4gICAgICAgIHRoZW4gcmV2X21lcmdlX3JldiB0MSBsMiAoaDE6OmFjY3UpXG4gICAgICAgIGVsc2UgcmV2X21lcmdlX3JldiBsMSB0MiAoaDI6OmFjY3UpXG4gIGluXG4gIGxldCByZWMgc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA8IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjIDwgMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSByZXZfc29ydCBuMSBsIGluXG4gICAgICAgIGxldCBzMiwgdGwgPSByZXZfc29ydCBuMiBsMiBpblxuICAgICAgICAocmV2X21lcmdlX3JldiBzMSBzMiBbXSwgdGwpXG4gIGFuZCByZXZfc29ydCBuIGwgPVxuICAgIG1hdGNoIG4sIGwgd2l0aFxuICAgIHwgMiwgeDEgOjogeDIgOjogdGwgLT5cbiAgICAgICAgbGV0IHMgPVxuICAgICAgICAgIGxldCBjID0gY21wIHgxIHgyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBbeDFdIGVsc2UgaWYgYyA+IDAgdGhlbiBbeDE7IHgyXSBlbHNlIFt4MjsgeDFdXG4gICAgICAgIGluXG4gICAgICAgIChzLCB0bClcbiAgICB8IDMsIHgxIDo6IHgyIDo6IHgzIDo6IHRsIC0+XG4gICAgICAgIGxldCBzID1cbiAgICAgICAgICBsZXQgYyA9IGNtcCB4MSB4MiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4Ml0gZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDNdIGVsc2UgW3gzOyB4Ml1cbiAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MTsgeDJdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gxOyB4MjsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gxOyB4Ml1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MTsgeDM7IHgyXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDE7IHgyXVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIHgxIHgzIGluXG4gICAgICAgICAgICBpZiBjID0gMCB0aGVuIFt4MjsgeDFdXG4gICAgICAgICAgICBlbHNlIGlmIGMgPiAwIHRoZW4gW3gyOyB4MTsgeDNdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxldCBjID0gY21wIHgyIHgzIGluXG4gICAgICAgICAgICAgIGlmIGMgPSAwIHRoZW4gW3gyOyB4MV1cbiAgICAgICAgICAgICAgZWxzZSBpZiBjID4gMCB0aGVuIFt4MjsgeDM7IHgxXVxuICAgICAgICAgICAgICBlbHNlIFt4MzsgeDI7IHgxXVxuICAgICAgICBpblxuICAgICAgICAocywgdGwpXG4gICAgfCBuLCBsIC0+XG4gICAgICAgIGxldCBuMSA9IG4gYXNyIDEgaW5cbiAgICAgICAgbGV0IG4yID0gbiAtIG4xIGluXG4gICAgICAgIGxldCBzMSwgbDIgPSBzb3J0IG4xIGwgaW5cbiAgICAgICAgbGV0IHMyLCB0bCA9IHNvcnQgbjIgbDIgaW5cbiAgICAgICAgKHJldl9tZXJnZSBzMSBzMiBbXSwgdGwpXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggbCBpblxuICBpZiBsZW4gPCAyIHRoZW4gbCBlbHNlIGZzdCAoc29ydCBsZW4gbClcblxuXG5sZXQgcmVjIGNvbXBhcmVfbGVuZ3RocyBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCBfIDo6IGwxLCBfIDo6IGwyIC0+IGNvbXBhcmVfbGVuZ3RocyBsMSBsMlxuOztcblxubGV0IHJlYyBjb21wYXJlX2xlbmd0aF93aXRoIGwgbiA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgaWYgbiA9IDAgdGhlbiAwIGVsc2VcbiAgICAgIGlmIG4gPiAwIHRoZW4gLTEgZWxzZSAxXG4gIHwgXyA6OiBsIC0+XG4gICAgaWYgbiA8PSAwIHRoZW4gMSBlbHNlXG4gICAgICBjb21wYXJlX2xlbmd0aF93aXRoIGwgKG4tMSlcbjs7XG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgbCA9XG4gIGxldCByZWMgYXV4IGwgKCkgPSBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IFNlcS5OaWxcbiAgICB8IHggOjogdGFpbCAtPiBTZXEuQ29ucyAoeCwgYXV4IHRhaWwpXG4gIGluXG4gIGF1eCBsXG5cbmxldCBvZl9zZXEgc2VxID1cbiAgbGV0IHJlYyBkaXJlY3QgZGVwdGggc2VxIDogXyBsaXN0ID1cbiAgICBpZiBkZXB0aD0wXG4gICAgdGhlblxuICAgICAgU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gc2VxXG4gICAgICB8PiByZXYgKCogdGFpbHJlYyAqKVxuICAgIGVsc2UgbWF0Y2ggc2VxKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IFtdXG4gICAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPiB4IDo6IGRpcmVjdCAoZGVwdGgtMSkgbmV4dFxuICBpblxuICBkaXJlY3QgNTAwIHNlcVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgIFNpbW9uIENydWFuZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNyBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW1NlcV06IGZ1bmN0aW9uYWwgaXRlcmF0b3JzICopXG5cbnR5cGUgKydhIG5vZGUgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgJ2EgKiAnYSB0XG5cbmFuZCAnYSB0ID0gdW5pdCAtPiAnYSBub2RlXG5cbmxldCBlbXB0eSAoKSA9IE5pbFxuXG5sZXQgcmV0dXJuIHggKCkgPSBDb25zICh4LCBlbXB0eSlcblxubGV0IGNvbnMgeCBuZXh0ICgpID0gQ29ucyAoeCwgbmV4dClcblxubGV0IHJlYyBhcHBlbmQgc2VxMSBzZXEyICgpID1cbiAgbWF0Y2ggc2VxMSgpIHdpdGhcbiAgfCBOaWwgLT4gc2VxMigpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMilcblxubGV0IHJlYyBtYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEoKSB3aXRoXG4gIHwgTmlsIC0+IE5pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IENvbnMgKGYgeCwgbWFwIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID0gbWF0Y2ggc2VxKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbWF0Y2ggZiB4IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICAgIHwgU29tZSB5IC0+IENvbnMgKHksIGZpbHRlcl9tYXAgZiBuZXh0KVxuXG5sZXQgcmVjIGZpbHRlciBmIHNlcSAoKSA9IG1hdGNoIHNlcSgpIHdpdGhcbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGlmIGYgeFxuICAgICAgdGhlbiBDb25zICh4LCBmaWx0ZXIgZiBuZXh0KVxuICAgICAgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5cbmxldCByZWMgZmxhdF9tYXAgZiBzZXEgKCkgPSBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gIHwgTmlsIC0+IGZsYXRfbWFwIGYgdGFpbCAoKVxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKVxuXG5sZXQgZm9sZF9sZWZ0IGYgYWNjIHNlcSA9XG4gIGxldCByZWMgYXV4IGYgYWNjIHNlcSA9IG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBpdGVyIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID0gbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IE5pbCAtPiAoKVxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCByZWMgdW5mb2xkIGYgdSAoKSA9XG4gIG1hdGNoIGYgdSB3aXRoXG4gIHwgTm9uZSAtPiBOaWxcbiAgfCBTb21lICh4LCB1JykgLT4gQ29ucyAoeCwgdW5mb2xkIGYgdScpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIG9wdGlvbiA9IE5vbmUgfCBTb21lIG9mICdhXG5cbmxldCBub25lID0gTm9uZVxubGV0IHNvbWUgdiA9IFNvbWUgdlxubGV0IHZhbHVlIG8gfmRlZmF1bHQgPSBtYXRjaCBvIHdpdGggU29tZSB2IC0+IHYgfCBOb25lIC0+IGRlZmF1bHRcbmxldCBnZXQgPSBmdW5jdGlvbiBTb21lIHYgLT4gdiB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJvcHRpb24gaXMgTm9uZVwiXG5sZXQgYmluZCBvIGYgPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IGYgdlxubGV0IGpvaW4gPSBmdW5jdGlvbiBTb21lIG8gLT4gbyB8IE5vbmUgLT4gTm9uZVxubGV0IG1hcCBmIG8gPSBtYXRjaCBvIHdpdGggTm9uZSAtPiBOb25lIHwgU29tZSB2IC0+IFNvbWUgKGYgdilcbmxldCBmb2xkIH5ub25lIH5zb21lID0gZnVuY3Rpb24gU29tZSB2IC0+IHNvbWUgdiB8IE5vbmUgLT4gbm9uZVxubGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgdiAtPiBmIHYgfCBOb25lIC0+ICgpXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uIE5vbmUgLT4gdHJ1ZSB8IFNvbWUgXyAtPiBmYWxzZVxubGV0IGlzX3NvbWUgPSBmdW5jdGlvbiBOb25lIC0+IGZhbHNlIHwgU29tZSBfIC0+IHRydWVcblxubGV0IGVxdWFsIGVxIG8wIG8xID0gbWF0Y2ggbzAsIG8xIHdpdGhcbnwgU29tZSB2MCwgU29tZSB2MSAtPiBlcSB2MCB2MVxufCBOb25lLCBOb25lIC0+IHRydWVcbnwgXyAtPiBmYWxzZVxuXG5sZXQgY29tcGFyZSBjbXAgbzAgbzEgPSBtYXRjaCBvMCwgbzEgd2l0aFxufCBTb21lIHYwLCBTb21lIHYxIC0+IGNtcCB2MCB2MVxufCBOb25lLCBOb25lIC0+IDBcbnwgTm9uZSwgU29tZSBfIC0+IC0xXG58IFNvbWUgXywgTm9uZSAtPiAxXG5cbmxldCB0b19yZXN1bHQgfm5vbmUgPSBmdW5jdGlvbiBOb25lIC0+IEVycm9yIG5vbmUgfCBTb21lIHYgLT4gT2sgdlxubGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE5vbmUgLT4gU2VxLmVtcHR5IHwgU29tZSB2IC0+IFNlcS5yZXR1cm4gdlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgVGhlIE9DYW1sIHByb2dyYW1tZXJzICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxOCBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdlXG5cbmxldCBvayB2ID0gT2sgdlxubGV0IGVycm9yIGUgPSBFcnJvciBlXG5sZXQgdmFsdWUgciB+ZGVmYXVsdCA9IG1hdGNoIHIgd2l0aCBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGRlZmF1bHRcbmxldCBnZXRfb2sgPSBmdW5jdGlvbiBPayB2IC0+IHYgfCBFcnJvciBfIC0+IGludmFsaWRfYXJnIFwicmVzdWx0IGlzIEVycm9yIF9cIlxubGV0IGdldF9lcnJvciA9IGZ1bmN0aW9uIEVycm9yIGUgLT4gZSB8IE9rIF8gLT4gaW52YWxpZF9hcmcgXCJyZXN1bHQgaXMgT2sgX1wiXG5sZXQgYmluZCByIGYgPSBtYXRjaCByIHdpdGggT2sgdiAtPiBmIHYgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IGpvaW4gPSBmdW5jdGlvbiBPayByIC0+IHIgfCBFcnJvciBfIGFzIGUgLT4gZVxubGV0IG1hcCBmID0gZnVuY3Rpb24gT2sgdiAtPiBPayAoZiB2KSB8IEVycm9yIF8gYXMgZSAtPiBlXG5sZXQgbWFwX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IEVycm9yIChmIGUpIHwgT2sgXyBhcyB2IC0+IHZcbmxldCBmb2xkIH5vayB+ZXJyb3IgPSBmdW5jdGlvbiBPayB2IC0+IG9rIHYgfCBFcnJvciBlIC0+IGVycm9yIGVcbmxldCBpdGVyIGYgPSBmdW5jdGlvbiBPayB2IC0+IGYgdiB8IEVycm9yIF8gLT4gKClcbmxldCBpdGVyX2Vycm9yIGYgPSBmdW5jdGlvbiBFcnJvciBlIC0+IGYgZSB8IE9rIF8gLT4gKClcbmxldCBpc19vayA9IGZ1bmN0aW9uIE9rIF8gLT4gdHJ1ZSB8IEVycm9yIF8gLT4gZmFsc2VcbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uIEVycm9yIF8gLT4gdHJ1ZSB8IE9rIF8gLT4gZmFsc2VcblxubGV0IGVxdWFsIH5vayB+ZXJyb3IgcjAgcjEgPSBtYXRjaCByMCwgcjEgd2l0aFxufCBPayB2MCwgT2sgdjEgLT4gb2sgdjAgdjFcbnwgRXJyb3IgZTAsIEVycm9yIGUxIC0+IGVycm9yIGUwIGUxXG58IF8sIF8gLT4gZmFsc2VcblxubGV0IGNvbXBhcmUgfm9rIH5lcnJvciByMCByMSA9IG1hdGNoIHIwLCByMSB3aXRoXG58IE9rIHYwLCBPayB2MSAtPiBvayB2MCB2MVxufCBFcnJvciBlMCwgRXJyb3IgZTEgLT4gZXJyb3IgZTAgZTFcbnwgT2sgXywgRXJyb3IgXyAtPiAtMVxufCBFcnJvciBfLCBPayBfIC0+IDFcblxubGV0IHRvX29wdGlvbiA9IGZ1bmN0aW9uIE9rIHYgLT4gU29tZSB2IHwgRXJyb3IgXyAtPiBOb25lXG5sZXQgdG9fbGlzdCA9IGZ1bmN0aW9uIE9rIHYgLT4gW3ZdIHwgRXJyb3IgXyAtPiBbXVxubGV0IHRvX3NlcSA9IGZ1bmN0aW9uIE9rIHYgLT4gU2VxLnJldHVybiB2IHwgRXJyb3IgXyAtPiBTZXEuZW1wdHlcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBPQ2FtbCBwcm9ncmFtbWVycyAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTggSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSB0ID0gYm9vbCA9IGZhbHNlIHwgdHJ1ZVxuXG5leHRlcm5hbCBub3QgOiBib29sIC0+IGJvb2wgPSBcIiVib29sbm90XCJcbmV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG5leHRlcm5hbCAoIHx8ICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVvclwiXG5sZXQgZXF1YWwgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9ICggPSApXG5sZXQgY29tcGFyZSA6IGJvb2wgLT4gYm9vbCAtPiBpbnQgPSBTdGRsaWIuY29tcGFyZVxuZXh0ZXJuYWwgdG9faW50IDogYm9vbCAtPiBpbnQgPSBcIiVpZGVudGl0eVwiXG5sZXQgdG9fZmxvYXQgPSBmdW5jdGlvbiBmYWxzZSAtPiAwLiB8IHRydWUgLT4gMS5cblxuKCpcbmxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxufCBcImZhbHNlXCIgLT4gU29tZSBmYWxzZVxufCBcInRydWVcIiAtPiBTb21lIHRydWVcbnwgXyAtPiBOb25lXG4qKVxuXG5sZXQgdG9fc3RyaW5nID0gZnVuY3Rpb24gZmFsc2UgLT4gXCJmYWxzZVwiIHwgdHJ1ZSAtPiBcInRydWVcIlxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBDaGFyYWN0ZXIgb3BlcmF0aW9ucyAqKVxuXG5leHRlcm5hbCBjb2RlOiBjaGFyIC0+IGludCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIHVuc2FmZV9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgY2hyIG4gPVxuICBpZiBuIDwgMCB8fCBuID4gMjU1IHRoZW4gaW52YWxpZF9hcmcgXCJDaGFyLmNoclwiIGVsc2UgdW5zYWZlX2NociBuXG5cbmV4dGVybmFsIGJ5dGVzX2NyZWF0ZTogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCBieXRlc191bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBcIiVieXRlc191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuXG5sZXQgZXNjYXBlZCA9IGZ1bmN0aW9uXG4gIHwgJ1xcJycgLT4gXCJcXFxcJ1wiXG4gIHwgJ1xcXFwnIC0+IFwiXFxcXFxcXFxcIlxuICB8ICdcXG4nIC0+IFwiXFxcXG5cIlxuICB8ICdcXHQnIC0+IFwiXFxcXHRcIlxuICB8ICdcXHInIC0+IFwiXFxcXHJcIlxuICB8ICdcXGInIC0+IFwiXFxcXGJcIlxuICB8ICcgJyAuLiAnficgYXMgYyAtPlxuICAgICAgbGV0IHMgPSBieXRlc19jcmVhdGUgMSBpblxuICAgICAgYnl0ZXNfdW5zYWZlX3NldCBzIDAgYztcbiAgICAgIHVuc2FmZV90b19zdHJpbmcgc1xuICB8IGMgLT5cbiAgICAgIGxldCBuID0gY29kZSBjIGluXG4gICAgICBsZXQgcyA9IGJ5dGVzX2NyZWF0ZSA0IGluXG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMCAnXFxcXCc7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMSAodW5zYWZlX2NociAoNDggKyBuIC8gMTAwKSk7XG4gICAgICBieXRlc191bnNhZmVfc2V0IHMgMiAodW5zYWZlX2NociAoNDggKyAobiAvIDEwKSBtb2QgMTApKTtcbiAgICAgIGJ5dGVzX3Vuc2FmZV9zZXQgcyAzICh1bnNhZmVfY2hyICg0OCArIG4gbW9kIDEwKSk7XG4gICAgICB1bnNhZmVfdG9fc3RyaW5nIHNcblxubGV0IGxvd2VyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJ1xuICB8ICdcXDE5MicgLi4gJ1xcMjE0J1xuICB8ICdcXDIxNicgLi4gJ1xcMjIyJyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgKyAzMilcbiAgfCBjIC0+IGNcblxubGV0IHVwcGVyY2FzZSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6J1xuICB8ICdcXDIyNCcgLi4gJ1xcMjQ2J1xuICB8ICdcXDI0OCcgLi4gJ1xcMjU0JyBhcyBjIC0+XG4gICAgdW5zYWZlX2Nocihjb2RlIGMgLSAzMilcbiAgfCBjIC0+IGNcblxubGV0IGxvd2VyY2FzZV9hc2NpaSA9IGZ1bmN0aW9uXG4gIHwgJ0EnIC4uICdaJyBhcyBjIC0+IHVuc2FmZV9jaHIoY29kZSBjICsgMzIpXG4gIHwgYyAtPiBjXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgPSBmdW5jdGlvblxuICB8ICdhJyAuLiAneicgYXMgYyAtPiB1bnNhZmVfY2hyKGNvZGUgYyAtIDMyKVxuICB8IGMgLT4gY1xuXG50eXBlIHQgPSBjaGFyXG5cbmxldCBjb21wYXJlIGMxIGMyID0gY29kZSBjMSAtIGNvZGUgYzJcbmxldCBlcXVhbCAoYzE6IHQpIChjMjogdCkgPSBjb21wYXJlIGMxIGMyID0gMFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBCeXRlIHNlcXVlbmNlIG9wZXJhdGlvbnMgKilcblxuKCogV0FSTklORzogU29tZSBmdW5jdGlvbnMgaW4gdGhpcyBmaWxlIGFyZSBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCBmb3JcbiAgIGVmZmljaWVuY3kgcmVhc29ucy4gV2hlbiB5b3UgbW9kaWZ5IHRoZSBvbmUgaW4gdGhpcyBmaWxlIHlvdSBuZWVkIHRvXG4gICBtb2RpZnkgaXRzIGR1cGxpY2F0ZSBpbiBzdHJpbmcubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IGJ5dGVzIC0+IGludCA9IFwiJWJ5dGVzX2xlbmd0aFwiXG5leHRlcm5hbCBzdHJpbmdfbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuZXh0ZXJuYWwgZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9ieXRlc1wiXG5leHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX2J5dGVzXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV90b19zdHJpbmcgOiBieXRlcyAtPiBzdHJpbmcgPSBcIiVieXRlc190b19zdHJpbmdcIlxuZXh0ZXJuYWwgdW5zYWZlX29mX3N0cmluZyA6IHN0cmluZyAtPiBieXRlcyA9IFwiJWJ5dGVzX29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogYnl0ZXMgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9ieXRlc1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICAgICAgICAgICAgICAgICAgICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuXG5sZXQgbWFrZSBuIGMgPVxuICBsZXQgcyA9IGNyZWF0ZSBuIGluXG4gIHVuc2FmZV9maWxsIHMgMCBuIGM7XG4gIHNcblxubGV0IGluaXQgbiBmID1cbiAgbGV0IHMgPSBjcmVhdGUgbiBpblxuICBmb3IgaSA9IDAgdG8gbiAtIDEgZG9cbiAgICB1bnNhZmVfc2V0IHMgaSAoZiBpKVxuICBkb25lO1xuICBzXG5cbmxldCBlbXB0eSA9IGNyZWF0ZSAwXG5cbmxldCBjb3B5IHMgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgaW5cbiAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gIHVuc2FmZV9ibGl0IHMgMCByIDAgbGVuO1xuICByXG5cbmxldCB0b19zdHJpbmcgYiA9IHVuc2FmZV90b19zdHJpbmcgKGNvcHkgYilcbmxldCBvZl9zdHJpbmcgcyA9IGNvcHkgKHVuc2FmZV9vZl9zdHJpbmcgcylcblxubGV0IHN1YiBzIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIHMgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5zdWIgLyBCeXRlcy5zdWJcIlxuICBlbHNlIGJlZ2luXG4gICAgbGV0IHIgPSBjcmVhdGUgbGVuIGluXG4gICAgdW5zYWZlX2JsaXQgcyBvZnMgciAwIGxlbjtcbiAgICByXG4gIGVuZFxuXG5sZXQgc3ViX3N0cmluZyBiIG9mcyBsZW4gPSB1bnNhZmVfdG9fc3RyaW5nIChzdWIgYiBvZnMgbGVuKVxuXG4oKiBhZGRpdGlvbiB3aXRoIGFuIG92ZXJmbG93IGNoZWNrICopXG5sZXQgKCsrKSBhIGIgPVxuICBsZXQgYyA9IGEgKyBiIGluXG4gIG1hdGNoIGEgPCAwLCBiIDwgMCwgYyA8IDAgd2l0aFxuICB8IHRydWUgLCB0cnVlICwgZmFsc2VcbiAgfCBmYWxzZSwgZmFsc2UsIHRydWUgIC0+IGludmFsaWRfYXJnIFwiQnl0ZXMuZXh0ZW5kXCIgKCogb3ZlcmZsb3cgKilcbiAgfCBfIC0+IGNcblxubGV0IGV4dGVuZCBzIGxlZnQgcmlnaHQgPVxuICBsZXQgbGVuID0gbGVuZ3RoIHMgKysgbGVmdCArKyByaWdodCBpblxuICBsZXQgciA9IGNyZWF0ZSBsZW4gaW5cbiAgbGV0IChzcmNvZmYsIGRzdG9mZikgPSBpZiBsZWZ0IDwgMCB0aGVuIC1sZWZ0LCAwIGVsc2UgMCwgbGVmdCBpblxuICBsZXQgY3B5bGVuID0gbWluIChsZW5ndGggcyAtIHNyY29mZikgKGxlbiAtIGRzdG9mZikgaW5cbiAgaWYgY3B5bGVuID4gMCB0aGVuIHVuc2FmZV9ibGl0IHMgc3Jjb2ZmIHIgZHN0b2ZmIGNweWxlbjtcbiAgclxuXG5sZXQgZmlsbCBzIG9mcyBsZW4gYyA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBsZW5ndGggcyAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmZpbGwgLyBCeXRlcy5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBzIG9mcyBsZW4gY1xuXG5sZXQgYmxpdCBzMSBvZnMxIHMyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIHMxIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBzMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQnl0ZXMuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG5sZXQgYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlbiA9XG4gIGlmIGxlbiA8IDAgfHwgb2ZzMSA8IDAgfHwgb2ZzMSA+IHN0cmluZ19sZW5ndGggczEgLSBsZW5cbiAgICAgICAgICAgICB8fCBvZnMyIDwgMCB8fCBvZnMyID4gbGVuZ3RoIHMyIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcuYmxpdCAvIEJ5dGVzLmJsaXRfc3RyaW5nXCJcbiAgZWxzZSB1bnNhZmVfYmxpdF9zdHJpbmcgczEgb2ZzMSBzMiBvZnMyIGxlblxuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGl0ZXIgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBlbnN1cmVfZ2UgKHg6aW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIGludmFsaWRfYXJnIFwiQnl0ZXMuY29uY2F0XCJcblxubGV0IHJlYyBzdW1fbGVuZ3RocyBhY2Mgc2VwbGVuID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBhY2NcbiAgfCBoZCA6OiBbXSAtPiBsZW5ndGggaGQgKyBhY2NcbiAgfCBoZCA6OiB0bCAtPiBzdW1fbGVuZ3RocyAoZW5zdXJlX2dlIChsZW5ndGggaGQgKyBzZXBsZW4gKyBhY2MpIGFjYykgc2VwbGVuIHRsXG5cbmxldCByZWMgdW5zYWZlX2JsaXRzIGRzdCBwb3Mgc2VwIHNlcGxlbiA9IGZ1bmN0aW9uXG4gICAgW10gLT4gZHN0XG4gIHwgaGQgOjogW10gLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7IGRzdFxuICB8IGhkIDo6IHRsIC0+XG4gICAgdW5zYWZlX2JsaXQgaGQgMCBkc3QgcG9zIChsZW5ndGggaGQpO1xuICAgIHVuc2FmZV9ibGl0IHNlcCAwIGRzdCAocG9zICsgbGVuZ3RoIGhkKSBzZXBsZW47XG4gICAgdW5zYWZlX2JsaXRzIGRzdCAocG9zICsgbGVuZ3RoIGhkICsgc2VwbGVuKSBzZXAgc2VwbGVuIHRsXG5cbmxldCBjb25jYXQgc2VwID0gZnVuY3Rpb25cbiAgICBbXSAtPiBlbXB0eVxuICB8IGwgLT4gbGV0IHNlcGxlbiA9IGxlbmd0aCBzZXAgaW5cbiAgICAgICAgICB1bnNhZmVfYmxpdHNcbiAgICAgICAgICAgIChjcmVhdGUgKHN1bV9sZW5ndGhzIDAgc2VwbGVuIGwpKVxuICAgICAgICAgICAgMCBzZXAgc2VwbGVuIGxcblxubGV0IGNhdCBzMSBzMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBzMSBpblxuICBsZXQgbDIgPSBsZW5ndGggczIgaW5cbiAgbGV0IHIgPSBjcmVhdGUgKGwxICsgbDIpIGluXG4gIHVuc2FmZV9ibGl0IHMxIDAgciAwIGwxO1xuICB1bnNhZmVfYmxpdCBzMiAwIHIgbDEgbDI7XG4gIHJcblxuXG5leHRlcm5hbCBjaGFyX2NvZGU6IGNoYXIgLT4gaW50ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgY2hhcl9jaHI6IGludCAtPiBjaGFyID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuICYmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgIWkpIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGxldCBqID0gcmVmIChsZW4gLSAxKSBpblxuICB3aGlsZSAhaiA+PSAhaSAmJiBpc19zcGFjZSAodW5zYWZlX2dldCBzICFqKSBkb1xuICAgIGRlY3IgalxuICBkb25lO1xuICBpZiAhaiA+PSAhaSB0aGVuXG4gICAgc3ViIHMgIWkgKCFqIC0gIWkgKyAxKVxuICBlbHNlXG4gICAgZW1wdHlcblxubGV0IGVzY2FwZWQgcyA9XG4gIGxldCBuID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgIG4gOj0gIW4gK1xuICAgICAgKG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICB8ICcgJyAuLiAnficgLT4gMVxuICAgICAgIHwgXyAtPiA0KVxuICBkb25lO1xuICBpZiAhbiA9IGxlbmd0aCBzIHRoZW4gY29weSBzIGVsc2UgYmVnaW5cbiAgICBsZXQgcycgPSBjcmVhdGUgIW4gaW5cbiAgICBuIDo9IDA7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCBzIC0gMSBkb1xuICAgICAgYmVnaW4gbWF0Y2ggdW5zYWZlX2dldCBzIGkgd2l0aFxuICAgICAgfCAoJ1xcXCInIHwgJ1xcXFwnKSBhcyBjIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnbidcbiAgICAgIHwgJ1xcdCcgLT5cbiAgICAgICAgICB1bnNhZmVfc2V0IHMnICFuICdcXFxcJzsgaW5jciBuOyB1bnNhZmVfc2V0IHMnICFuICd0J1xuICAgICAgfCAnXFxyJyAtPlxuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnOyBpbmNyIG47IHVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7IGluY3IgbjsgdW5zYWZlX3NldCBzJyAhbiAnYidcbiAgICAgIHwgKCcgJyAuLiAnficpIGFzIGMgLT4gdW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICB8IGMgLT5cbiAgICAgICAgICBsZXQgYSA9IGNoYXJfY29kZSBjIGluXG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgLyAxMDApKTtcbiAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgdW5zYWZlX3NldCBzJyAhbiAoY2hhcl9jaHIgKDQ4ICsgKGEgLyAxMCkgbW9kIDEwKSk7XG4gICAgICAgICAgaW5jciBuO1xuICAgICAgICAgIHVuc2FmZV9zZXQgcycgIW4gKGNoYXJfY2hyICg0OCArIGEgbW9kIDEwKSk7XG4gICAgICBlbmQ7XG4gICAgICBpbmNyIG5cbiAgICBkb25lO1xuICAgIHMnXG4gIGVuZFxuXG5sZXQgbWFwIGYgcyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgbCA9IDAgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIGluXG4gICAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IHMgaSkpIGRvbmU7XG4gICAgclxuICBlbmRcblxubGV0IG1hcGkgZiBzID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBsID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY3JlYXRlIGwgaW5cbiAgICBmb3IgaSA9IDAgdG8gbCAtIDEgZG8gdW5zYWZlX3NldCByIGkgKGYgaSAodW5zYWZlX2dldCBzIGkpKSBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB1cHBlcmNhc2VfYXNjaWkgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZV9hc2NpaSBzXG5sZXQgbG93ZXJjYXNlX2FzY2lpIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2VfYXNjaWkgc1xuXG5sZXQgYXBwbHkxIGYgcyA9XG4gIGlmIGxlbmd0aCBzID0gMCB0aGVuIHMgZWxzZSBiZWdpblxuICAgIGxldCByID0gY29weSBzIGluXG4gICAgdW5zYWZlX3NldCByIDAgKGYodW5zYWZlX2dldCBzIDApKTtcbiAgICByXG4gIGVuZFxuXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlX2FzY2lpIHNcbmxldCB1bmNhcGl0YWxpemVfYXNjaWkgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZV9hc2NpaSBzXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmVjIGluZGV4X3JlYyBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSBpbmRleF9yZWMgcyBsaW0gKGkgKyAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgaW5kZXggcyBjID0gaW5kZXhfcmVjIHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X29wdCBzIGMgPSBpbmRleF9yZWNfb3B0IHMgKGxlbmd0aCBzKSAwIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCBpbmRleF9mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb20gLyBCeXRlcy5pbmRleF9mcm9tXCIgZWxzZVxuICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IGluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuaW5kZXhfZnJvbV9vcHQgLyBCeXRlcy5pbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICBpbmRleF9yZWNfb3B0IHMgbCBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlYyBzIGkgYyA9XG4gIGlmIGkgPCAwIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIHJpbmRleF9yZWMgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAtMSB8fCBpID49IGxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5yaW5kZXhfZnJvbSAvIEJ5dGVzLnJpbmRleF9mcm9tXCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWMgcyBpIGNcblxuKCogZHVwbGljYXRlZCBpbiBzdHJpbmcubWwgKilcbmxldCByZWMgcmluZGV4X3JlY19vcHQgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSByaW5kZXhfcmVjX29wdCBzIChpIC0gMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgcmluZGV4X2Zyb21fb3B0IHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tX29wdCAvIEJ5dGVzLnJpbmRleF9mcm9tX29wdFwiXG4gIGVsc2VcbiAgICByaW5kZXhfcmVjX29wdCBzIGkgY1xuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5jb250YWluc19mcm9tXCJcbiAgZWxzZVxuICAgIHRyeSBpZ25vcmUgKGluZGV4X3JlYyBzIGwgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbigqIGR1cGxpY2F0ZWQgaW4gc3RyaW5nLm1sICopXG5sZXQgY29udGFpbnMgcyBjID0gY29udGFpbnNfZnJvbSBzIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIHN0cmluZy5tbCAqKVxubGV0IHJjb250YWluc19mcm9tIHMgaSBjID1cbiAgaWYgaSA8IDAgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmNvbnRhaW5zX2Zyb20gLyBCeXRlcy5yY29udGFpbnNfZnJvbVwiXG4gIGVsc2VcbiAgICB0cnkgaWdub3JlIChyaW5kZXhfcmVjIHMgaSBjKTsgdHJ1ZSB3aXRoIE5vdF9mb3VuZCAtPiBmYWxzZVxuXG5cbnR5cGUgdCA9IGJ5dGVzXG5cbmxldCBjb21wYXJlICh4OiB0KSAoeTogdCkgPSBTdGRsaWIuY29tcGFyZSB4IHlcbmV4dGVybmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2wgPSBcImNhbWxfYnl0ZXNfZXF1YWxcIiBbQEBub2FsbG9jXVxuXG4oKiBEZXByZWNhdGVkIGZ1bmN0aW9ucyBpbXBsZW1lbnRlZCB2aWEgb3RoZXIgZGVwcmVjYXRlZCBmdW5jdGlvbnMgKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbmxldCB1cHBlcmNhc2UgcyA9IG1hcCBDaGFyLnVwcGVyY2FzZSBzXG5sZXQgbG93ZXJjYXNlIHMgPSBtYXAgQ2hhci5sb3dlcmNhc2Ugc1xuXG5sZXQgY2FwaXRhbGl6ZSBzID0gYXBwbHkxIENoYXIudXBwZXJjYXNlIHNcbmxldCB1bmNhcGl0YWxpemUgcyA9IGFwcGx5MSBDaGFyLmxvd2VyY2FzZSBzXG5cbigqKiB7MSBJdGVyYXRvcnN9ICopXG5cbmxldCB0b19zZXEgcyA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgIGlmIGkgPSBsZW5ndGggcyB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IGdldCBzIGkgaW5cbiAgICAgIFNlcS5Db25zICh4LCBhdXggKGkrMSkpXG4gIGluXG4gIGF1eCAwXG5cbmxldCB0b19zZXFpIHMgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpID0gbGVuZ3RoIHMgdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBnZXQgcyBpIGluXG4gICAgICBTZXEuQ29ucyAoKGkseCksIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IG4gPSByZWYgMCBpblxuICBsZXQgYnVmID0gcmVmIChtYWtlIDI1NiAnXFwwMDAnKSBpblxuICBsZXQgcmVzaXplICgpID1cbiAgICAoKiByZXNpemUgKilcbiAgICBsZXQgbmV3X2xlbiA9IG1pbiAoMiAqIGxlbmd0aCAhYnVmKSBTeXMubWF4X3N0cmluZ19sZW5ndGggaW5cbiAgICBpZiBsZW5ndGggIWJ1ZiA9IG5ld19sZW4gdGhlbiBmYWlsd2l0aCBcIkJ5dGVzLm9mX3NlcTogY2Fubm90IGdyb3cgYnl0ZXNcIjtcbiAgICBsZXQgbmV3X2J1ZiA9IG1ha2UgbmV3X2xlbiAnXFwwMDAnIGluXG4gICAgYmxpdCAhYnVmIDAgbmV3X2J1ZiAwICFuO1xuICAgIGJ1ZiA6PSBuZXdfYnVmXG4gIGluXG4gIFNlcS5pdGVyXG4gICAgKGZ1biBjIC0+XG4gICAgICAgaWYgIW4gPSBsZW5ndGggIWJ1ZiB0aGVuIHJlc2l6ZSgpO1xuICAgICAgIHNldCAhYnVmICFuIGM7XG4gICAgICAgaW5jciBuKVxuICAgIGk7XG4gIHN1YiAhYnVmIDAgIW5cblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZy9kZWNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgZ2V0X3VpbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiJWJ5dGVzX3NhZmVfZ2V0XCJcbmV4dGVybmFsIGdldF91aW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9ieXRlc19nZXQxNlwiXG5leHRlcm5hbCBnZXRfaW50MzJfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50MzIgPSBcIiVjYW1sX2J5dGVzX2dldDMyXCJcbmV4dGVybmFsIGdldF9pbnQ2NF9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCA9IFwiJWNhbWxfYnl0ZXNfZ2V0NjRcIlxuZXh0ZXJuYWwgc2V0X2ludDggOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG5leHRlcm5hbCBzZXRfaW50MTZfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXQgPSBcIiVjYW1sX2J5dGVzX3NldDE2XCJcbmV4dGVybmFsIHNldF9pbnQzMl9uZSA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMlwiXG5leHRlcm5hbCBzZXRfaW50NjRfbmUgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjRcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxubGV0IGdldF9pbnQ4IGIgaSA9XG4gICgoZ2V0X3VpbnQ4IGIgaSkgbHNsIChTeXMuaW50X3NpemUgLSA4KSkgYXNyIChTeXMuaW50X3NpemUgLSA4KVxuXG5sZXQgZ2V0X3VpbnQxNl9sZSBiIGkgPVxuICBpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAxNiAoZ2V0X3VpbnQxNl9uZSBiIGkpXG4gIGVsc2UgZ2V0X3VpbnQxNl9uZSBiIGlcblxubGV0IGdldF91aW50MTZfYmUgYiBpID1cbiAgaWYgbm90IFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDE2IChnZXRfdWludDE2X25lIGIgaSlcbiAgZWxzZSBnZXRfdWludDE2X25lIGIgaVxuXG5sZXQgZ2V0X2ludDE2X25lIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9uZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2xlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9sZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDE2X2JlIGIgaSA9XG4gICgoZ2V0X3VpbnQxNl9iZSBiIGkpIGxzbCAoU3lzLmludF9zaXplIC0gMTYpKSBhc3IgKFN5cy5pbnRfc2l6ZSAtIDE2KVxuXG5sZXQgZ2V0X2ludDMyX2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDMyIChnZXRfaW50MzJfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQzMl9uZSBiIGlcblxubGV0IGdldF9pbnQzMl9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMzIgKGdldF9pbnQzMl9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDMyX25lIGIgaVxuXG5sZXQgZ2V0X2ludDY0X2xlIGIgaSA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IChnZXRfaW50NjRfbmUgYiBpKVxuICBlbHNlIGdldF9pbnQ2NF9uZSBiIGlcblxubGV0IGdldF9pbnQ2NF9iZSBiIGkgPVxuICBpZiBub3QgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwNjQgKGdldF9pbnQ2NF9uZSBiIGkpXG4gIGVsc2UgZ2V0X2ludDY0X25lIGIgaVxuXG5sZXQgc2V0X2ludDE2X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MTZfbmUgYiBpIChzd2FwMTYgeClcbiAgZWxzZSBzZXRfaW50MTZfbmUgYiBpIHhcblxubGV0IHNldF9pbnQxNl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQxNl9uZSBiIGkgKHN3YXAxNiB4KVxuICBlbHNlIHNldF9pbnQxNl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDMyX2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50MzJfbmUgYiBpIChzd2FwMzIgeClcbiAgZWxzZSBzZXRfaW50MzJfbmUgYiBpIHhcblxubGV0IHNldF9pbnQzMl9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQzMl9uZSBiIGkgKHN3YXAzMiB4KVxuICBlbHNlIHNldF9pbnQzMl9uZSBiIGkgeFxuXG5sZXQgc2V0X2ludDY0X2xlIGIgaSB4ID1cbiAgaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzZXRfaW50NjRfbmUgYiBpIChzd2FwNjQgeClcbiAgZWxzZSBzZXRfaW50NjRfbmUgYiBpIHhcblxubGV0IHNldF9pbnQ2NF9iZSBiIGkgeCA9XG4gIGlmIG5vdCBTeXMuYmlnX2VuZGlhbiB0aGVuIHNldF9pbnQ2NF9uZSBiIGkgKHN3YXA2NCB4KVxuICBlbHNlIHNldF9pbnQ2NF9uZSBiIGkgeFxuXG5sZXQgc2V0X3VpbnQ4ID0gc2V0X2ludDhcbmxldCBzZXRfdWludDE2X25lID0gc2V0X2ludDE2X25lXG5sZXQgc2V0X3VpbnQxNl9iZSA9IHNldF9pbnQxNl9iZVxubGV0IHNldF91aW50MTZfbGUgPSBzZXRfaW50MTZfbGVcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMTQgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU3RyaW5nIG9wZXJhdGlvbnMsIGJhc2VkIG9uIGJ5dGUgc2VxdWVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4oKiBXQVJOSU5HOiBTb21lIGZ1bmN0aW9ucyBpbiB0aGlzIGZpbGUgYXJlIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgZm9yXG4gICBlZmZpY2llbmN5IHJlYXNvbnMuIFdoZW4geW91IG1vZGlmeSB0aGUgb25lIGluIHRoaXMgZmlsZSB5b3UgbmVlZCB0b1xuICAgbW9kaWZ5IGl0cyBkdXBsaWNhdGUgaW4gYnl0ZXMubWwuXG4gICBUaGVzZSBmdW5jdGlvbnMgaGF2ZSBhIFwiZHVwbGljYXRlZFwiIGNvbW1lbnQgYWJvdmUgdGhlaXIgZGVmaW5pdGlvbi5cbiopXG5cbmV4dGVybmFsIGxlbmd0aCA6IHN0cmluZyAtPiBpbnQgPSBcIiVzdHJpbmdfbGVuZ3RoXCJcbmV4dGVybmFsIGdldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ19zYWZlX2dldFwiXG5leHRlcm5hbCBzZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3NhZmVfc2V0XCJcbmV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiBieXRlcyA9IFwiY2FtbF9jcmVhdGVfc3RyaW5nXCJcbmV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ191bnNhZmVfc2V0XCJcbmV4dGVybmFsIHVuc2FmZV9ibGl0IDogc3RyaW5nIC0+IGludCAtPiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9ibGl0X3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5leHRlcm5hbCB1bnNhZmVfZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gICAgICAgICAgICAgICAgICAgICA9IFwiY2FtbF9maWxsX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5cbm1vZHVsZSBCID0gQnl0ZXNcblxubGV0IGJ0cyA9IEIudW5zYWZlX3RvX3N0cmluZ1xubGV0IGJvcyA9IEIudW5zYWZlX29mX3N0cmluZ1xuXG5sZXQgbWFrZSBuIGMgPVxuICBCLm1ha2UgbiBjIHw+IGJ0c1xubGV0IGluaXQgbiBmID1cbiAgQi5pbml0IG4gZiB8PiBidHNcbmxldCBjb3B5IHMgPVxuICBCLmNvcHkgKGJvcyBzKSB8PiBidHNcbmxldCBzdWIgcyBvZnMgbGVuID1cbiAgQi5zdWIgKGJvcyBzKSBvZnMgbGVuIHw+IGJ0c1xubGV0IGZpbGwgPVxuICBCLmZpbGxcbmxldCBibGl0ID1cbiAgQi5ibGl0X3N0cmluZ1xuXG5sZXQgZW5zdXJlX2dlICh4OmludCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSBpbnZhbGlkX2FyZyBcIlN0cmluZy5jb25jYXRcIlxuXG5sZXQgcmVjIHN1bV9sZW5ndGhzIGFjYyBzZXBsZW4gPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY1xuICB8IGhkIDo6IFtdIC0+IGxlbmd0aCBoZCArIGFjY1xuICB8IGhkIDo6IHRsIC0+IHN1bV9sZW5ndGhzIChlbnN1cmVfZ2UgKGxlbmd0aCBoZCArIHNlcGxlbiArIGFjYykgYWNjKSBzZXBsZW4gdGxcblxubGV0IHJlYyB1bnNhZmVfYmxpdHMgZHN0IHBvcyBzZXAgc2VwbGVuID0gZnVuY3Rpb25cbiAgICBbXSAtPiBkc3RcbiAgfCBoZCA6OiBbXSAtPlxuICAgIHVuc2FmZV9ibGl0IGhkIDAgZHN0IHBvcyAobGVuZ3RoIGhkKTsgZHN0XG4gIHwgaGQgOjogdGwgLT5cbiAgICB1bnNhZmVfYmxpdCBoZCAwIGRzdCBwb3MgKGxlbmd0aCBoZCk7XG4gICAgdW5zYWZlX2JsaXQgc2VwIDAgZHN0IChwb3MgKyBsZW5ndGggaGQpIHNlcGxlbjtcbiAgICB1bnNhZmVfYmxpdHMgZHN0IChwb3MgKyBsZW5ndGggaGQgKyBzZXBsZW4pIHNlcCBzZXBsZW4gdGxcblxubGV0IGNvbmNhdCBzZXAgPSBmdW5jdGlvblxuICAgIFtdIC0+IFwiXCJcbiAgfCBsIC0+IGxldCBzZXBsZW4gPSBsZW5ndGggc2VwIGluIGJ0cyBAQFxuICAgICAgICAgIHVuc2FmZV9ibGl0c1xuICAgICAgICAgICAgKEIuY3JlYXRlIChzdW1fbGVuZ3RocyAwIHNlcGxlbiBsKSlcbiAgICAgICAgICAgIDAgc2VwIHNlcGxlbiBsXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBpdGVyIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiAodW5zYWZlX2dldCBzIGkpIGRvbmVcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGl0ZXJpIGYgcyA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG8gZiBpICh1bnNhZmVfZ2V0IHMgaSkgZG9uZVxuXG5sZXQgbWFwIGYgcyA9XG4gIEIubWFwIGYgKGJvcyBzKSB8PiBidHNcbmxldCBtYXBpIGYgcyA9XG4gIEIubWFwaSBmIChib3MgcykgfD4gYnRzXG5cbigqIEJld2FyZTogd2UgY2Fubm90IHVzZSBCLnRyaW0gb3IgQi5lc2NhcGUgYmVjYXVzZSB0aGV5IGFsd2F5cyBtYWtlIGFcbiAgIGNvcHksIGJ1dCBTdHJpbmcubWxpIHNwZWxscyBvdXQgc29tZSBjYXNlcyB3aGVyZSB3ZSBhcmUgbm90IGFsbG93ZWRcbiAgIHRvIG1ha2UgYSBjb3B5LiAqKVxuXG5sZXQgaXNfc3BhY2UgPSBmdW5jdGlvblxuICB8ICcgJyB8ICdcXDAxMicgfCAnXFxuJyB8ICdcXHInIHwgJ1xcdCcgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IHRyaW0gcyA9XG4gIGlmIHMgPSBcIlwiIHRoZW4gc1xuICBlbHNlIGlmIGlzX3NwYWNlICh1bnNhZmVfZ2V0IHMgMCkgfHwgaXNfc3BhY2UgKHVuc2FmZV9nZXQgcyAobGVuZ3RoIHMgLSAxKSlcbiAgICB0aGVuIGJ0cyAoQi50cmltIChib3MgcykpXG4gIGVsc2Ugc1xuXG5sZXQgZXNjYXBlZCBzID1cbiAgbGV0IHJlYyBlc2NhcGVfaWZfbmVlZGVkIHMgbiBpID1cbiAgICBpZiBpID49IG4gdGhlbiBzIGVsc2VcbiAgICAgIG1hdGNoIHVuc2FmZV9nZXQgcyBpIHdpdGhcbiAgICAgIHwgJ1xcXCInIHwgJ1xcXFwnIHwgJ1xcMDAwJy4uJ1xcMDMxJyB8ICdcXDEyNycuLiAnXFwyNTUnIC0+XG4gICAgICAgICAgYnRzIChCLmVzY2FwZWQgKGJvcyBzKSlcbiAgICAgIHwgXyAtPiBlc2NhcGVfaWZfbmVlZGVkIHMgbiAoaSsxKVxuICBpblxuICBlc2NhcGVfaWZfbmVlZGVkIHMgKGxlbmd0aCBzKSAwXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjIHMgbGltIGkgYyA9XG4gIGlmIGkgPj0gbGltIHRoZW4gcmFpc2UgTm90X2ZvdW5kIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gaSBlbHNlIGluZGV4X3JlYyBzIGxpbSAoaSArIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IGluZGV4IHMgYyA9IGluZGV4X3JlYyBzIChsZW5ndGggcykgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByZWMgaW5kZXhfcmVjX29wdCBzIGxpbSBpIGMgPVxuICBpZiBpID49IGxpbSB0aGVuIE5vbmUgZWxzZVxuICBpZiB1bnNhZmVfZ2V0IHMgaSA9IGMgdGhlbiBTb21lIGkgZWxzZSBpbmRleF9yZWNfb3B0IHMgbGltIChpICsgMSkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfb3B0IHMgYyA9IGluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMpIDAgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbSBzIGkgYyA9XG4gIGxldCBsID0gbGVuZ3RoIHMgaW5cbiAgaWYgaSA8IDAgfHwgaSA+IGwgdGhlbiBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tIC8gQnl0ZXMuaW5kZXhfZnJvbVwiIGVsc2VcbiAgICBpbmRleF9yZWMgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBsZXQgbCA9IGxlbmd0aCBzIGluXG4gIGlmIGkgPCAwIHx8IGkgPiBsIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBcIlN0cmluZy5pbmRleF9mcm9tX29wdCAvIEJ5dGVzLmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIGluZGV4X3JlY19vcHQgcyBsIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWMgcyBpIGMgPVxuICBpZiBpIDwgMCB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIGlmIHVuc2FmZV9nZXQgcyBpID0gYyB0aGVuIGkgZWxzZSByaW5kZXhfcmVjIHMgKGkgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXggcyBjID0gcmluZGV4X3JlYyBzIChsZW5ndGggcyAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9mcm9tIHMgaSBjID1cbiAgaWYgaSA8IC0xIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJpbmRleF9mcm9tIC8gQnl0ZXMucmluZGV4X2Zyb21cIlxuICBlbHNlXG4gICAgcmluZGV4X3JlYyBzIGkgY1xuXG4oKiBkdXBsaWNhdGVkIGluIGJ5dGVzLm1sICopXG5sZXQgcmVjIHJpbmRleF9yZWNfb3B0IHMgaSBjID1cbiAgaWYgaSA8IDAgdGhlbiBOb25lIGVsc2VcbiAgaWYgdW5zYWZlX2dldCBzIGkgPSBjIHRoZW4gU29tZSBpIGVsc2UgcmluZGV4X3JlY19vcHQgcyAoaSAtIDEpIGNcblxuKCogZHVwbGljYXRlZCBpbiBieXRlcy5tbCAqKVxubGV0IHJpbmRleF9vcHQgcyBjID0gcmluZGV4X3JlY19vcHQgcyAobGVuZ3RoIHMgLSAxKSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByaW5kZXhfZnJvbV9vcHQgcyBpIGMgPVxuICBpZiBpIDwgLTEgfHwgaSA+PSBsZW5ndGggcyB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fb3B0IC8gQnl0ZXMucmluZGV4X2Zyb21fb3B0XCJcbiAgZWxzZVxuICAgIHJpbmRleF9yZWNfb3B0IHMgaSBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWluc19mcm9tIHMgaSBjID1cbiAgbGV0IGwgPSBsZW5ndGggcyBpblxuICBpZiBpIDwgMCB8fCBpID4gbCB0aGVuXG4gICAgaW52YWxpZF9hcmcgXCJTdHJpbmcuY29udGFpbnNfZnJvbSAvIEJ5dGVzLmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAoaW5kZXhfcmVjIHMgbCBpIGMpOyB0cnVlIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCBjb250YWlucyBzIGMgPSBjb250YWluc19mcm9tIHMgMCBjXG5cbigqIGR1cGxpY2F0ZWQgaW4gYnl0ZXMubWwgKilcbmxldCByY29udGFpbnNfZnJvbSBzIGkgYyA9XG4gIGlmIGkgPCAwIHx8IGkgPj0gbGVuZ3RoIHMgdGhlblxuICAgIGludmFsaWRfYXJnIFwiU3RyaW5nLnJjb250YWluc19mcm9tIC8gQnl0ZXMucmNvbnRhaW5zX2Zyb21cIlxuICBlbHNlXG4gICAgdHJ5IGlnbm9yZSAocmluZGV4X3JlYyBzIGkgYyk7IHRydWUgd2l0aCBOb3RfZm91bmQgLT4gZmFsc2VcblxubGV0IHVwcGVyY2FzZV9hc2NpaSBzID1cbiAgQi51cHBlcmNhc2VfYXNjaWkgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2VfYXNjaWkgcyA9XG4gIEIubG93ZXJjYXNlX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZV9hc2NpaSBzID1cbiAgQi5jYXBpdGFsaXplX2FzY2lpIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplX2FzY2lpIHMgPVxuICBCLnVuY2FwaXRhbGl6ZV9hc2NpaSAoYm9zIHMpIHw+IGJ0c1xuXG50eXBlIHQgPSBzdHJpbmdcblxubGV0IGNvbXBhcmUgKHg6IHQpICh5OiB0KSA9IFN0ZGxpYi5jb21wYXJlIHggeVxuZXh0ZXJuYWwgZXF1YWwgOiBzdHJpbmcgLT4gc3RyaW5nIC0+IGJvb2wgPSBcImNhbWxfc3RyaW5nX2VxdWFsXCIgW0BAbm9hbGxvY11cblxubGV0IHNwbGl0X29uX2NoYXIgc2VwIHMgPVxuICBsZXQgciA9IHJlZiBbXSBpblxuICBsZXQgaiA9IHJlZiAobGVuZ3RoIHMpIGluXG4gIGZvciBpID0gbGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgaWYgdW5zYWZlX2dldCBzIGkgPSBzZXAgdGhlbiBiZWdpblxuICAgICAgciA6PSBzdWIgcyAoaSArIDEpICghaiAtIGkgLSAxKSA6OiAhcjtcbiAgICAgIGogOj0gaVxuICAgIGVuZFxuICBkb25lO1xuICBzdWIgcyAwICFqIDo6ICFyXG5cbigqIERlcHJlY2F0ZWQgZnVuY3Rpb25zIGltcGxlbWVudGVkIHZpYSBvdGhlciBkZXByZWNhdGVkIGZ1bmN0aW9ucyAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubGV0IHVwcGVyY2FzZSBzID1cbiAgQi51cHBlcmNhc2UgKGJvcyBzKSB8PiBidHNcbmxldCBsb3dlcmNhc2UgcyA9XG4gIEIubG93ZXJjYXNlIChib3MgcykgfD4gYnRzXG5sZXQgY2FwaXRhbGl6ZSBzID1cbiAgQi5jYXBpdGFsaXplIChib3MgcykgfD4gYnRzXG5sZXQgdW5jYXBpdGFsaXplIHMgPVxuICBCLnVuY2FwaXRhbGl6ZSAoYm9zIHMpIHw+IGJ0c1xuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHMgPSBib3MgcyB8PiBCLnRvX3NlcVxuXG5sZXQgdG9fc2VxaSBzID0gYm9zIHMgfD4gQi50b19zZXFpXG5cbmxldCBvZl9zZXEgZyA9IEIub2Zfc2VxIGcgfD4gYnRzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IHVuaXQgPSAoKVxuXG5sZXQgZXF1YWwgKCkgKCkgPSB0cnVlXG5sZXQgY29tcGFyZSAoKSAoKSA9IDBcbmxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxudHlwZSBleHRlcm5fZmxhZ3MgPVxuICAgIE5vX3NoYXJpbmdcbiAgfCBDbG9zdXJlc1xuICB8IENvbXBhdF8zMlxuKCogbm90ZTogdGhpcyB0eXBlIGRlZmluaXRpb24gaXMgdXNlZCBpbiAncnVudGltZS9kZWJ1Z2dlci5jJyAqKVxuXG5leHRlcm5hbCB0b19jaGFubmVsOiBvdXRfY2hhbm5lbCAtPiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiB1bml0XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlXCJcbmV4dGVybmFsIHRvX2J5dGVzOiAnYSAtPiBleHRlcm5fZmxhZ3MgbGlzdCAtPiBieXRlc1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19ieXRlc1wiXG5leHRlcm5hbCB0b19zdHJpbmc6ICdhIC0+IGV4dGVybl9mbGFncyBsaXN0IC0+IHN0cmluZ1xuICAgID0gXCJjYW1sX291dHB1dF92YWx1ZV90b19zdHJpbmdcIlxuZXh0ZXJuYWwgdG9fYnVmZmVyX3Vuc2FmZTpcbiAgICAgIGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gZXh0ZXJuX2ZsYWdzIGxpc3QgLT4gaW50XG4gICAgPSBcImNhbWxfb3V0cHV0X3ZhbHVlX3RvX2J1ZmZlclwiXG5cbmxldCB0b19idWZmZXIgYnVmZiBvZnMgbGVuIHYgZmxhZ3MgPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwudG9fYnVmZmVyOiBzdWJzdHJpbmcgb3V0IG9mIGJvdW5kc1wiXG4gIGVsc2UgdG9fYnVmZmVyX3Vuc2FmZSBidWZmIG9mcyBsZW4gdiBmbGFnc1xuXG4oKiBUaGUgZnVuY3Rpb25zIGJlbG93IHVzZSBieXRlIHNlcXVlbmNlcyBhcyBpbnB1dCwgbmV2ZXIgdXNpbmcgYW55XG4gICBtdXRhdGlvbi4gSXQgbWFrZXMgc2Vuc2UgdG8gdXNlIG5vbi1tdXRhdGVkIFtieXRlc10gcmF0aGVyIHRoYW5cbiAgIFtzdHJpbmddLCBiZWNhdXNlIHdlIHJlYWxseSB3b3JrIHdpdGggc2VxdWVuY2VzIG9mIGJ5dGVzLCBub3RcbiAgIGEgdGV4dCByZXByZXNlbnRhdGlvbi5cbiopXG5cbmV4dGVybmFsIGZyb21fY2hhbm5lbDogaW5fY2hhbm5lbCAtPiAnYSA9IFwiY2FtbF9pbnB1dF92YWx1ZVwiXG5leHRlcm5hbCBmcm9tX2J5dGVzX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+ICdhID0gXCJjYW1sX2lucHV0X3ZhbHVlX2Zyb21fYnl0ZXNcIlxuZXh0ZXJuYWwgZGF0YV9zaXplX3Vuc2FmZTogYnl0ZXMgLT4gaW50IC0+IGludCA9IFwiY2FtbF9tYXJzaGFsX2RhdGFfc2l6ZVwiXG5cbmxldCBoZWFkZXJfc2l6ZSA9IDIwXG5sZXQgZGF0YV9zaXplIGJ1ZmYgb2ZzID1cbiAgaWYgb2ZzIDwgMCB8fCBvZnMgPiBCeXRlcy5sZW5ndGggYnVmZiAtIGhlYWRlcl9zaXplXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJNYXJzaGFsLmRhdGFfc2l6ZVwiXG4gIGVsc2UgZGF0YV9zaXplX3Vuc2FmZSBidWZmIG9mc1xubGV0IHRvdGFsX3NpemUgYnVmZiBvZnMgPSBoZWFkZXJfc2l6ZSArIGRhdGFfc2l6ZSBidWZmIG9mc1xuXG5sZXQgZnJvbV9ieXRlcyBidWZmIG9mcyA9XG4gIGlmIG9mcyA8IDAgfHwgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSBoZWFkZXJfc2l6ZVxuICB0aGVuIGludmFsaWRfYXJnIFwiTWFyc2hhbC5mcm9tX2J5dGVzXCJcbiAgZWxzZSBiZWdpblxuICAgIGxldCBsZW4gPSBkYXRhX3NpemVfdW5zYWZlIGJ1ZmYgb2ZzIGluXG4gICAgaWYgb2ZzID4gQnl0ZXMubGVuZ3RoIGJ1ZmYgLSAoaGVhZGVyX3NpemUgKyBsZW4pXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIk1hcnNoYWwuZnJvbV9ieXRlc1wiXG4gICAgZWxzZSBmcm9tX2J5dGVzX3Vuc2FmZSBidWZmIG9mc1xuICBlbmRcblxubGV0IGZyb21fc3RyaW5nIGJ1ZmYgb2ZzID1cbiAgKCogQnl0ZXMudW5zYWZlX29mX3N0cmluZyBpcyBzYWZlIGhlcmUsIGFzIHRoZSBwcm9kdWNlZCBieXRlXG4gICAgIHNlcXVlbmNlIGlzIG5ldmVyIG11dGF0ZWQgKilcbiAgZnJvbV9ieXRlcyAoQnl0ZXMudW5zYWZlX29mX3N0cmluZyBidWZmKSBvZnNcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogT3BlcmF0aW9ucyBvbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbnMgb2YgdmFsdWVzICopXG5cbnR5cGUgdFxuXG5leHRlcm5hbCByZXByIDogJ2EgLT4gdCA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIG9iaiA6IHQgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5leHRlcm5hbCBtYWdpYyA6ICdhIC0+ICdiID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgaXNfaW50IDogdCAtPiBib29sID0gXCIlb2JqX2lzX2ludFwiXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBpc19ibG9jayBhID0gbm90IChpc19pbnQgYSlcbmV4dGVybmFsIHRhZyA6IHQgLT4gaW50ID0gXCJjYW1sX29ial90YWdcIlxuZXh0ZXJuYWwgc2V0X3RhZyA6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfb2JqX3NldF90YWdcIlxuZXh0ZXJuYWwgc2l6ZSA6IHQgLT4gaW50ID0gXCIlb2JqX3NpemVcIlxuZXh0ZXJuYWwgcmVhY2hhYmxlX3dvcmRzIDogdCAtPiBpbnQgPSBcImNhbWxfb2JqX3JlYWNoYWJsZV93b3Jkc1wiXG5leHRlcm5hbCBmaWVsZCA6IHQgLT4gaW50IC0+IHQgPSBcIiVvYmpfZmllbGRcIlxuZXh0ZXJuYWwgc2V0X2ZpZWxkIDogdCAtPiBpbnQgLT4gdCAtPiB1bml0ID0gXCIlb2JqX3NldF9maWVsZFwiXG5leHRlcm5hbCBmbG9hdGFycmF5X2dldCA6IGZsb2F0YXJyYXkgLT4gaW50IC0+IGZsb2F0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfZ2V0XCJcbmV4dGVybmFsIGZsb2F0YXJyYXlfc2V0IDpcbiAgICBmbG9hdGFycmF5IC0+IGludCAtPiBmbG9hdCAtPiB1bml0ID0gXCJjYW1sX2Zsb2F0YXJyYXlfc2V0XCJcbmxldCBbQGlubGluZSBhbHdheXNdIGRvdWJsZV9maWVsZCB4IGkgPSBmbG9hdGFycmF5X2dldCAob2JqIHggOiBmbG9hdGFycmF5KSBpXG5sZXQgW0BpbmxpbmUgYWx3YXlzXSBzZXRfZG91YmxlX2ZpZWxkIHggaSB2ID1cbiAgZmxvYXRhcnJheV9zZXQgKG9iaiB4IDogZmxvYXRhcnJheSkgaSB2XG5leHRlcm5hbCBuZXdfYmxvY2sgOiBpbnQgLT4gaW50IC0+IHQgPSBcImNhbWxfb2JqX2Jsb2NrXCJcbmV4dGVybmFsIGR1cCA6IHQgLT4gdCA9IFwiY2FtbF9vYmpfZHVwXCJcbmV4dGVybmFsIHRydW5jYXRlIDogdCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF9vYmpfdHJ1bmNhdGVcIlxuZXh0ZXJuYWwgYWRkX29mZnNldCA6IHQgLT4gSW50MzIudCAtPiB0ID0gXCJjYW1sX29ial9hZGRfb2Zmc2V0XCJcbmV4dGVybmFsIHdpdGhfdGFnIDogaW50IC0+IHQgLT4gdCA9IFwiY2FtbF9vYmpfd2l0aF90YWdcIlxuXG5sZXQgbWFyc2hhbCAob2JqIDogdCkgPVxuICBNYXJzaGFsLnRvX2J5dGVzIG9iaiBbXVxubGV0IHVubWFyc2hhbCBzdHIgcG9zID1cbiAgKE1hcnNoYWwuZnJvbV9ieXRlcyBzdHIgcG9zLCBwb3MgKyBNYXJzaGFsLnRvdGFsX3NpemUgc3RyIHBvcylcblxubGV0IGZpcnN0X25vbl9jb25zdGFudF9jb25zdHJ1Y3Rvcl90YWcgPSAwXG5sZXQgbGFzdF9ub25fY29uc3RhbnRfY29uc3RydWN0b3JfdGFnID0gMjQ1XG5cbmxldCBsYXp5X3RhZyA9IDI0NlxubGV0IGNsb3N1cmVfdGFnID0gMjQ3XG5sZXQgb2JqZWN0X3RhZyA9IDI0OFxubGV0IGluZml4X3RhZyA9IDI0OVxubGV0IGZvcndhcmRfdGFnID0gMjUwXG5cbmxldCBub19zY2FuX3RhZyA9IDI1MVxuXG5sZXQgYWJzdHJhY3RfdGFnID0gMjUxXG5sZXQgc3RyaW5nX3RhZyA9IDI1MlxubGV0IGRvdWJsZV90YWcgPSAyNTNcbmxldCBkb3VibGVfYXJyYXlfdGFnID0gMjU0XG5sZXQgY3VzdG9tX3RhZyA9IDI1NVxubGV0IGZpbmFsX3RhZyA9IGN1c3RvbV90YWdcblxuXG5sZXQgaW50X3RhZyA9IDEwMDBcbmxldCBvdXRfb2ZfaGVhcF90YWcgPSAxMDAxXG5sZXQgdW5hbGlnbmVkX3RhZyA9IDEwMDJcblxubW9kdWxlIEV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9XG5zdHJ1Y3RcbiAgdHlwZSB0ID0gZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXG4gIGxldCBvZl92YWwgeCA9XG4gICAgbGV0IHggPSByZXByIHggaW5cbiAgICBsZXQgc2xvdCA9XG4gICAgICBpZiAoaXNfYmxvY2sgeCkgJiYgKHRhZyB4KSA8PiBvYmplY3RfdGFnICYmIChzaXplIHgpID49IDEgdGhlbiBmaWVsZCB4IDBcbiAgICAgIGVsc2UgeFxuICAgIGluXG4gICAgbGV0IG5hbWUgPVxuICAgICAgaWYgKGlzX2Jsb2NrIHNsb3QpICYmICh0YWcgc2xvdCkgPSBvYmplY3RfdGFnIHRoZW4gZmllbGQgc2xvdCAwXG4gICAgICBlbHNlIGludmFsaWRfYXJnIFwiT2JqLmV4dGVuc2lvbl9jb25zdHJ1Y3RvclwiXG4gICAgaW5cbiAgICAgIGlmICh0YWcgbmFtZSkgPSBzdHJpbmdfdGFnIHRoZW4gKG9iaiBzbG90IDogdClcbiAgICAgIGVsc2UgaW52YWxpZF9hcmcgXCJPYmouZXh0ZW5zaW9uX2NvbnN0cnVjdG9yXCJcblxuICBsZXQgW0BpbmxpbmUgYWx3YXlzXSBuYW1lIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDApIDogc3RyaW5nKVxuXG4gIGxldCBbQGlubGluZSBhbHdheXNdIGlkIChzbG90IDogdCkgPVxuICAgIChvYmogKGZpZWxkIChyZXByIHNsb3QpIDEpIDogaW50KVxuZW5kXG5cbmxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBFeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsXG5sZXQgZXh0ZW5zaW9uX25hbWUgPSBFeHRlbnNpb25fY29uc3RydWN0b3IubmFtZVxubGV0IGV4dGVuc2lvbl9pZCA9IEV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuXG5tb2R1bGUgRXBoZW1lcm9uID0gc3RydWN0XG4gIHR5cGUgb2JqX3QgPSB0XG5cbiAgdHlwZSB0ICgqKiBlcGhlbWVyb24gKilcblxuICAgKCoqIFRvIGNoYW5nZSBpbiBzeW5jIHdpdGggd2Vhay5oICopXG4gIGxldCBhZGRpdGlvbmFsX3ZhbHVlcyA9IDJcbiAgbGV0IG1heF9lcGhlX2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBleHRlcm5hbCBjcmVhdGUgOiBpbnQgLT4gdCA9IFwiY2FtbF9lcGhlX2NyZWF0ZVwiOztcbiAgbGV0IGNyZWF0ZSBsID1cbiAgICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IG1heF9lcGhlX2xlbmd0aCkgdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJPYmouRXBoZW1lcm9uLmNyZWF0ZVwiO1xuICAgIGNyZWF0ZSBsXG5cbiAgbGV0IGxlbmd0aCB4ID0gc2l6ZShyZXByIHgpIC0gYWRkaXRpb25hbF92YWx1ZXNcblxuICBsZXQgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIG1zZyA9XG4gICAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBtc2dcblxuICBleHRlcm5hbCBnZXRfa2V5OiB0IC0+IGludCAtPiBvYmpfdCBvcHRpb24gPSBcImNhbWxfZXBoZV9nZXRfa2V5XCJcbiAgbGV0IGdldF9rZXkgZSBvID1cbiAgICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJPYmouRXBoZW1lcm9uLmdldF9rZXlcIjtcbiAgICBnZXRfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGdldF9rZXlfY29weTogdCAtPiBpbnQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2tleV9jb3B5XCJcbiAgbGV0IGdldF9rZXlfY29weSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uZ2V0X2tleV9jb3B5XCI7XG4gICAgZ2V0X2tleV9jb3B5IGUgb1xuXG4gIGV4dGVybmFsIHNldF9rZXk6IHQgLT4gaW50IC0+IG9ial90IC0+IHVuaXQgPSBcImNhbWxfZXBoZV9zZXRfa2V5XCJcbiAgbGV0IHNldF9rZXkgZSBvIHggPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uc2V0X2tleVwiO1xuICAgIHNldF9rZXkgZSBvIHhcblxuICBleHRlcm5hbCB1bnNldF9rZXk6IHQgLT4gaW50IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9rZXlcIlxuICBsZXQgdW5zZXRfa2V5IGUgbyA9XG4gICAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiT2JqLkVwaGVtZXJvbi51bnNldF9rZXlcIjtcbiAgICB1bnNldF9rZXkgZSBvXG5cbiAgZXh0ZXJuYWwgY2hlY2tfa2V5OiB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfa2V5XCJcbiAgbGV0IGNoZWNrX2tleSBlIG8gPVxuICAgIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIk9iai5FcGhlbWVyb24uY2hlY2tfa2V5XCI7XG4gICAgY2hlY2tfa2V5IGUgb1xuXG4gIGV4dGVybmFsIGJsaXRfa2V5IDogdCAtPiBpbnQgLT4gdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgICA9IFwiY2FtbF9lcGhlX2JsaXRfa2V5XCJcblxuICBsZXQgYmxpdF9rZXkgZTEgbzEgZTIgbzIgbCA9XG4gICAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICAgIHx8IG8yIDwgMCB8fCBvMiA+IGxlbmd0aCBlMiAtIGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiT2JqLkVwaGVtZXJvbi5ibGl0X2tleVwiXG4gICAgZWxzZSBpZiBsIDw+IDAgdGhlbiBibGl0X2tleSBlMSBvMSBlMiBvMiBsXG5cbiAgZXh0ZXJuYWwgZ2V0X2RhdGE6IHQgLT4gb2JqX3Qgb3B0aW9uID0gXCJjYW1sX2VwaGVfZ2V0X2RhdGFcIlxuICBleHRlcm5hbCBnZXRfZGF0YV9jb3B5OiB0IC0+IG9ial90IG9wdGlvbiA9IFwiY2FtbF9lcGhlX2dldF9kYXRhX2NvcHlcIlxuICBleHRlcm5hbCBzZXRfZGF0YTogdCAtPiBvYmpfdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfc2V0X2RhdGFcIlxuICBleHRlcm5hbCB1bnNldF9kYXRhOiB0IC0+IHVuaXQgPSBcImNhbWxfZXBoZV91bnNldF9kYXRhXCJcbiAgZXh0ZXJuYWwgY2hlY2tfZGF0YTogdCAtPiBib29sID0gXCJjYW1sX2VwaGVfY2hlY2tfZGF0YVwiXG4gIGV4dGVybmFsIGJsaXRfZGF0YSA6IHQgLT4gdCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfYmxpdF9kYXRhXCJcblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiBhcnJheXMuICopXG50eXBlICdhIHQgPSAnYSBhcnJheVxuXG4oKiBBcnJheSBvcGVyYXRpb25zICopXG5cbmV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG5leHRlcm5hbCBnZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSA9IFwiJWFycmF5X3NhZmVfZ2V0XCJcbmV4dGVybmFsIHNldDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcIiVhcnJheV9zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfZ2V0OiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV91bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQ6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfdW5zYWZlX3NldFwiXG5leHRlcm5hbCBtYWtlOiBpbnQgLT4gJ2EgLT4gJ2EgYXJyYXkgPSBcImNhbWxfbWFrZV92ZWN0XCJcbmV4dGVybmFsIGNyZWF0ZTogaW50IC0+ICdhIC0+ICdhIGFycmF5ID0gXCJjYW1sX21ha2VfdmVjdFwiXG5leHRlcm5hbCB1bnNhZmVfc3ViIDogJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9zdWJcIlxuZXh0ZXJuYWwgYXBwZW5kX3ByaW0gOiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9hcHBlbmRcIlxuZXh0ZXJuYWwgY29uY2F0IDogJ2EgYXJyYXkgbGlzdCAtPiAnYSBhcnJheSA9IFwiY2FtbF9hcnJheV9jb25jYXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgYXJyYXkgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2FycmF5X2JsaXRcIlxuZXh0ZXJuYWwgdW5zYWZlX2ZpbGwgOlxuICAnYSBhcnJheSAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYXJyYXlfZmlsbFwiXG5leHRlcm5hbCBjcmVhdGVfZmxvYXQ6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxubGV0IG1ha2VfZmxvYXQgPSBjcmVhdGVfZmxvYXRcblxubW9kdWxlIEZsb2F0YXJyYXkgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGZsb2F0YXJyYXkgPSBcImNhbWxfZmxvYXRhcnJheV9jcmVhdGVcIlxuICBleHRlcm5hbCBsZW5ndGggOiBmbG9hdGFycmF5IC0+IGludCA9IFwiJWZsb2F0YXJyYXlfbGVuZ3RoXCJcbiAgZXh0ZXJuYWwgZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3NhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdCA9IFwiJWZsb2F0YXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9nZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogZmxvYXRhcnJheSAtPiBpbnQgLT4gZmxvYXQgLT4gdW5pdFxuICAgICAgPSBcIiVmbG9hdGFycmF5X3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmxldCBpbml0IGwgZiA9XG4gIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlXG4gIGlmIGwgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5pbml0XCJcbiAgKCogU2VlICM2NTc1LiBXZSBjb3VsZCBhbHNvIGNoZWNrIGZvciBtYXhpbXVtIGFycmF5IHNpemUsIGJ1dCB0aGlzIGRlcGVuZHNcbiAgICAgb24gd2hldGhlciB3ZSBjcmVhdGUgYSBmbG9hdCBhcnJheSBvciBhIHJlZ3VsYXIgb25lLi4uICopXG4gIGVsc2VcbiAgIGxldCByZXMgPSBjcmVhdGUgbCAoZiAwKSBpblxuICAgZm9yIGkgPSAxIHRvIHByZWQgbCBkb1xuICAgICB1bnNhZmVfc2V0IHJlcyBpIChmIGkpXG4gICBkb25lO1xuICAgcmVzXG5cbmxldCBtYWtlX21hdHJpeCBzeCBzeSBpbml0ID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSBzeCBbfHxdIGluXG4gIGZvciB4ID0gMCB0byBwcmVkIHN4IGRvXG4gICAgdW5zYWZlX3NldCByZXMgeCAoY3JlYXRlIHN5IGluaXQpXG4gIGRvbmU7XG4gIHJlc1xuXG5sZXQgY3JlYXRlX21hdHJpeCA9IG1ha2VfbWF0cml4XG5cbmxldCBjb3B5IGEgPVxuICBsZXQgbCA9IGxlbmd0aCBhIGluIGlmIGwgPSAwIHRoZW4gW3x8XSBlbHNlIHVuc2FmZV9zdWIgYSAwIGxcblxubGV0IGFwcGVuZCBhMSBhMiA9XG4gIGxldCBsMSA9IGxlbmd0aCBhMSBpblxuICBpZiBsMSA9IDAgdGhlbiBjb3B5IGEyXG4gIGVsc2UgaWYgbGVuZ3RoIGEyID0gMCB0aGVuIHVuc2FmZV9zdWIgYTEgMCBsMVxuICBlbHNlIGFwcGVuZF9wcmltIGExIGEyXG5cbmxldCBzdWIgYSBvZnMgbGVuID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5zdWJcIlxuICBlbHNlIHVuc2FmZV9zdWIgYSBvZnMgbGVuXG5cbmxldCBmaWxsIGEgb2ZzIGxlbiB2ID1cbiAgaWYgb2ZzIDwgMCB8fCBsZW4gPCAwIHx8IG9mcyA+IGxlbmd0aCBhIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5maWxsXCJcbiAgZWxzZSB1bnNhZmVfZmlsbCBhIG9mcyBsZW4gdlxuXG5sZXQgYmxpdCBhMSBvZnMxIGEyIG9mczIgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBvZnMxIDwgMCB8fCBvZnMxID4gbGVuZ3RoIGExIC0gbGVuXG4gICAgICAgICAgICAgfHwgb2ZzMiA8IDAgfHwgb2ZzMiA+IGxlbmd0aCBhMiAtIGxlblxuICB0aGVuIGludmFsaWRfYXJnIFwiQXJyYXkuYmxpdFwiXG4gIGVsc2UgdW5zYWZlX2JsaXQgYTEgb2ZzMSBhMiBvZnMyIGxlblxuXG5sZXQgaXRlciBmIGEgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvIGYodW5zYWZlX2dldCBhIGkpIGRvbmVcblxubGV0IGl0ZXIyIGYgYSBiID1cbiAgaWYgbGVuZ3RoIGEgPD4gbGVuZ3RoIGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkuaXRlcjI6IGFycmF5cyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCJcbiAgZWxzZVxuICAgIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG8gZiAodW5zYWZlX2dldCBhIGkpICh1bnNhZmVfZ2V0IGIgaSkgZG9uZVxuXG5sZXQgbWFwIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCBtYXAyIGYgYSBiID1cbiAgbGV0IGxhID0gbGVuZ3RoIGEgaW5cbiAgbGV0IGxiID0gbGVuZ3RoIGIgaW5cbiAgaWYgbGEgPD4gbGIgdGhlblxuICAgIGludmFsaWRfYXJnIFwiQXJyYXkubWFwMjogYXJyYXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIlxuICBlbHNlIGJlZ2luXG4gICAgaWYgbGEgPSAwIHRoZW4gW3x8XSBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGNyZWF0ZSBsYSAoZiAodW5zYWZlX2dldCBhIDApICh1bnNhZmVfZ2V0IGIgMCkpIGluXG4gICAgICBmb3IgaSA9IDEgdG8gbGEgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgciBpIChmICh1bnNhZmVfZ2V0IGEgaSkgKHVuc2FmZV9nZXQgYiBpKSlcbiAgICAgIGRvbmU7XG4gICAgICByXG4gICAgZW5kXG4gIGVuZFxuXG5sZXQgaXRlcmkgZiBhID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkbyBmIGkgKHVuc2FmZV9nZXQgYSBpKSBkb25lXG5cbmxldCBtYXBpIGYgYSA9XG4gIGxldCBsID0gbGVuZ3RoIGEgaW5cbiAgaWYgbCA9IDAgdGhlbiBbfHxdIGVsc2UgYmVnaW5cbiAgICBsZXQgciA9IGNyZWF0ZSBsIChmIDAgKHVuc2FmZV9nZXQgYSAwKSkgaW5cbiAgICBmb3IgaSA9IDEgdG8gbCAtIDEgZG9cbiAgICAgIHVuc2FmZV9zZXQgciBpIChmIGkgKHVuc2FmZV9nZXQgYSBpKSlcbiAgICBkb25lO1xuICAgIHJcbiAgZW5kXG5cbmxldCB0b19saXN0IGEgPVxuICBsZXQgcmVjIHRvbGlzdCBpIHJlcyA9XG4gICAgaWYgaSA8IDAgdGhlbiByZXMgZWxzZSB0b2xpc3QgKGkgLSAxKSAodW5zYWZlX2dldCBhIGkgOjogcmVzKSBpblxuICB0b2xpc3QgKGxlbmd0aCBhIC0gMSkgW11cblxuKCogQ2Fubm90IHVzZSBMaXN0Lmxlbmd0aCBoZXJlIGJlY2F1c2UgdGhlIExpc3QgbW9kdWxlIGRlcGVuZHMgb24gQXJyYXkuICopXG5sZXQgcmVjIGxpc3RfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IFtdIC0+IGFjY3VcbiAgfCBfOjp0IC0+IGxpc3RfbGVuZ3RoIChzdWNjIGFjY3UpIHRcblxubGV0IG9mX2xpc3QgPSBmdW5jdGlvblxuICAgIFtdIC0+IFt8fF1cbiAgfCBoZDo6dGwgYXMgbCAtPlxuICAgICAgbGV0IGEgPSBjcmVhdGUgKGxpc3RfbGVuZ3RoIDAgbCkgaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpKzEpIHRsIGluXG4gICAgICBmaWxsIDEgdGxcblxubGV0IGZvbGRfbGVmdCBmIHggYSA9XG4gIGxldCByID0gcmVmIHggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmU7XG4gICFyXG5cbmxldCBmb2xkX3JpZ2h0IGYgYSB4ID1cbiAgbGV0IHIgPSByZWYgeCBpblxuICBmb3IgaSA9IGxlbmd0aCBhIC0gMSBkb3dudG8gMCBkb1xuICAgIHIgOj0gZiAodW5zYWZlX2dldCBhIGkpICFyXG4gIGRvbmU7XG4gICFyXG5cbmxldCBleGlzdHMgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwgcCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiB0cnVlXG4gICAgZWxzZSBpZiBwICh1bnNhZmVfZ2V0IGEgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGZvcl9hbGwyIHAgbDEgbDIgPVxuICBsZXQgbjEgPSBsZW5ndGggbDFcbiAgYW5kIG4yID0gbGVuZ3RoIGwyIGluXG4gIGlmIG4xIDw+IG4yIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5mb3JfYWxsMlwiXG4gIGVsc2UgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPSBuMSB0aGVuIHRydWVcbiAgICBlbHNlIGlmIHAgKHVuc2FmZV9nZXQgbDEgaSkgKHVuc2FmZV9nZXQgbDIgaSkgdGhlbiBsb29wIChzdWNjIGkpXG4gICAgZWxzZSBmYWxzZSBpblxuICBsb29wIDBcblxubGV0IGV4aXN0czIgcCBsMSBsMiA9XG4gIGxldCBuMSA9IGxlbmd0aCBsMVxuICBhbmQgbjIgPSBsZW5ndGggbDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiBpbnZhbGlkX2FyZyBcIkFycmF5LmV4aXN0czJcIlxuICBlbHNlIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBpID0gbjEgdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgcCAodW5zYWZlX2dldCBsMSBpKSAodW5zYWZlX2dldCBsMiBpKSB0aGVuIHRydWVcbiAgICBlbHNlIGxvb3AgKHN1Y2MgaSkgaW5cbiAgbG9vcCAwXG5cbmxldCBtZW0geCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhIGkpIHggPSAwIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxubGV0IG1lbXEgeCBhID1cbiAgbGV0IG4gPSBsZW5ndGggYSBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG4gdGhlbiBmYWxzZVxuICAgIGVsc2UgaWYgeCA9PSAodW5zYWZlX2dldCBhIGkpIHRoZW4gdHJ1ZVxuICAgIGVsc2UgbG9vcCAoc3VjYyBpKSBpblxuICBsb29wIDBcblxuZXhjZXB0aW9uIEJvdHRvbSBvZiBpbnRcbmxldCBzb3J0IGNtcCBhID1cbiAgbGV0IG1heHNvbiBsIGkgPVxuICAgIGxldCBpMzEgPSBpK2kraSsxIGluXG4gICAgbGV0IHggPSByZWYgaTMxIGluXG4gICAgaWYgaTMxKzIgPCBsIHRoZW4gYmVnaW5cbiAgICAgIGlmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwIHRoZW4geCA6PSBpMzErMTtcbiAgICAgIGlmIGNtcCAoZ2V0IGEgIXgpIChnZXQgYSAoaTMxKzIpKSA8IDAgdGhlbiB4IDo9IGkzMSsyO1xuICAgICAgIXhcbiAgICBlbmQgZWxzZVxuICAgICAgaWYgaTMxKzEgPCBsICYmIGNtcCAoZ2V0IGEgaTMxKSAoZ2V0IGEgKGkzMSsxKSkgPCAwXG4gICAgICB0aGVuIGkzMSsxXG4gICAgICBlbHNlIGlmIGkzMSA8IGwgdGhlbiBpMzEgZWxzZSByYWlzZSAoQm90dG9tIGkpXG4gIGluXG4gIGxldCByZWMgdHJpY2tsZWRvd24gbCBpIGUgPVxuICAgIGxldCBqID0gbWF4c29uIGwgaSBpblxuICAgIGlmIGNtcCAoZ2V0IGEgaikgZSA+IDAgdGhlbiBiZWdpblxuICAgICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgICB0cmlja2xlZG93biBsIGogZTtcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgc2V0IGEgaSBlO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IHRyaWNrbGUgbCBpIGUgPSB0cnkgdHJpY2tsZWRvd24gbCBpIGUgd2l0aCBCb3R0b20gaSAtPiBzZXQgYSBpIGUgaW5cbiAgbGV0IHJlYyBidWJibGVkb3duIGwgaSA9XG4gICAgbGV0IGogPSBtYXhzb24gbCBpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgaik7XG4gICAgYnViYmxlZG93biBsIGpcbiAgaW5cbiAgbGV0IGJ1YmJsZSBsIGkgPSB0cnkgYnViYmxlZG93biBsIGkgd2l0aCBCb3R0b20gaSAtPiBpIGluXG4gIGxldCByZWMgdHJpY2tsZXVwIGkgZSA9XG4gICAgbGV0IGZhdGhlciA9IChpIC0gMSkgLyAzIGluXG4gICAgYXNzZXJ0IChpIDw+IGZhdGhlcik7XG4gICAgaWYgY21wIChnZXQgYSBmYXRoZXIpIGUgPCAwIHRoZW4gYmVnaW5cbiAgICAgIHNldCBhIGkgKGdldCBhIGZhdGhlcik7XG4gICAgICBpZiBmYXRoZXIgPiAwIHRoZW4gdHJpY2tsZXVwIGZhdGhlciBlIGVsc2Ugc2V0IGEgMCBlO1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBzZXQgYSBpIGU7XG4gICAgZW5kO1xuICBpblxuICBsZXQgbCA9IGxlbmd0aCBhIGluXG4gIGZvciBpID0gKGwgKyAxKSAvIDMgLSAxIGRvd250byAwIGRvIHRyaWNrbGUgbCBpIChnZXQgYSBpKTsgZG9uZTtcbiAgZm9yIGkgPSBsIC0gMSBkb3dudG8gMiBkb1xuICAgIGxldCBlID0gKGdldCBhIGkpIGluXG4gICAgc2V0IGEgaSAoZ2V0IGEgMCk7XG4gICAgdHJpY2tsZXVwIChidWJibGUgaSAwKSBlO1xuICBkb25lO1xuICBpZiBsID4gMSB0aGVuIChsZXQgZSA9IChnZXQgYSAxKSBpbiBzZXQgYSAxIChnZXQgYSAwKTsgc2V0IGEgMCBlKVxuXG5cbmxldCBjdXRvZmYgPSA1XG5sZXQgc3RhYmxlX3NvcnQgY21wIGEgPVxuICBsZXQgbWVyZ2Ugc3JjMW9mcyBzcmMxbGVuIHNyYzIgc3JjMm9mcyBzcmMybGVuIGRzdCBkc3RvZnMgPVxuICAgIGxldCBzcmMxciA9IHNyYzFvZnMgKyBzcmMxbGVuIGFuZCBzcmMyciA9IHNyYzJvZnMgKyBzcmMybGVuIGluXG4gICAgbGV0IHJlYyBsb29wIGkxIHMxIGkyIHMyIGQgPVxuICAgICAgaWYgY21wIHMxIHMyIDw9IDAgdGhlbiBiZWdpblxuICAgICAgICBzZXQgZHN0IGQgczE7XG4gICAgICAgIGxldCBpMSA9IGkxICsgMSBpblxuICAgICAgICBpZiBpMSA8IHNyYzFyIHRoZW5cbiAgICAgICAgICBsb29wIGkxIChnZXQgYSBpMSkgaTIgczIgKGQgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmxpdCBzcmMyIGkyIGRzdCAoZCArIDEpIChzcmMyciAtIGkyKVxuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgc2V0IGRzdCBkIHMyO1xuICAgICAgICBsZXQgaTIgPSBpMiArIDEgaW5cbiAgICAgICAgaWYgaTIgPCBzcmMyciB0aGVuXG4gICAgICAgICAgbG9vcCBpMSBzMSBpMiAoZ2V0IHNyYzIgaTIpIChkICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJsaXQgYSBpMSBkc3QgKGQgKyAxKSAoc3JjMXIgLSBpMSlcbiAgICAgIGVuZFxuICAgIGluIGxvb3Agc3JjMW9mcyAoZ2V0IGEgc3JjMW9mcykgc3JjMm9mcyAoZ2V0IHNyYzIgc3JjMm9mcykgZHN0b2ZzO1xuICBpblxuICBsZXQgaXNvcnR0byBzcmNvZnMgZHN0IGRzdG9mcyBsZW4gPVxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgZSA9IChnZXQgYSAoc3Jjb2ZzICsgaSkpIGluXG4gICAgICBsZXQgaiA9IHJlZiAoZHN0b2ZzICsgaSAtIDEpIGluXG4gICAgICB3aGlsZSAoIWogPj0gZHN0b2ZzICYmIGNtcCAoZ2V0IGRzdCAhaikgZSA+IDApIGRvXG4gICAgICAgIHNldCBkc3QgKCFqICsgMSkgKGdldCBkc3QgIWopO1xuICAgICAgICBkZWNyIGo7XG4gICAgICBkb25lO1xuICAgICAgc2V0IGRzdCAoIWogKyAxKSBlO1xuICAgIGRvbmU7XG4gIGluXG4gIGxldCByZWMgc29ydHRvIHNyY29mcyBkc3QgZHN0b2ZzIGxlbiA9XG4gICAgaWYgbGVuIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gc3Jjb2ZzIGRzdCBkc3RvZnMgbGVuIGVsc2UgYmVnaW5cbiAgICAgIGxldCBsMSA9IGxlbiAvIDIgaW5cbiAgICAgIGxldCBsMiA9IGxlbiAtIGwxIGluXG4gICAgICBzb3J0dG8gKHNyY29mcyArIGwxKSBkc3QgKGRzdG9mcyArIGwxKSBsMjtcbiAgICAgIHNvcnR0byBzcmNvZnMgYSAoc3Jjb2ZzICsgbDIpIGwxO1xuICAgICAgbWVyZ2UgKHNyY29mcyArIGwyKSBsMSBkc3QgKGRzdG9mcyArIGwxKSBsMiBkc3QgZHN0b2ZzO1xuICAgIGVuZDtcbiAgaW5cbiAgbGV0IGwgPSBsZW5ndGggYSBpblxuICBpZiBsIDw9IGN1dG9mZiB0aGVuIGlzb3J0dG8gMCBhIDAgbCBlbHNlIGJlZ2luXG4gICAgbGV0IGwxID0gbCAvIDIgaW5cbiAgICBsZXQgbDIgPSBsIC0gbDEgaW5cbiAgICBsZXQgdCA9IG1ha2UgbDIgKGdldCBhIDApIGluXG4gICAgc29ydHRvIGwxIHQgMCBsMjtcbiAgICBzb3J0dG8gMCBhIGwyIGwxO1xuICAgIG1lcmdlIGwyIGwxIHQgMCBsMiBhIDA7XG4gIGVuZFxuXG5cbmxldCBmYXN0X3NvcnQgPSBzdGFibGVfc29ydFxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIGEgPVxuICBsZXQgcmVjIGF1eCBpICgpID1cbiAgICBpZiBpIDwgbGVuZ3RoIGFcbiAgICB0aGVuXG4gICAgICBsZXQgeCA9IHVuc2FmZV9nZXQgYSBpIGluXG4gICAgICBTZXEuQ29ucyAoeCwgYXV4IChpKzEpKVxuICAgIGVsc2UgU2VxLk5pbFxuICBpblxuICBhdXggMFxuXG5sZXQgdG9fc2VxaSBhID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgaWYgaSA8IGxlbmd0aCBhXG4gICAgdGhlblxuICAgICAgbGV0IHggPSB1bnNhZmVfZ2V0IGEgaSBpblxuICAgICAgU2VxLkNvbnMgKChpLHgpLCBhdXggKGkrMSkpXG4gICAgZWxzZSBTZXEuTmlsXG4gIGluXG4gIGF1eCAwXG5cbmxldCBvZl9yZXZfbGlzdCA9IGZ1bmN0aW9uXG4gICAgW10gLT4gW3x8XVxuICB8IGhkOjp0bCBhcyBsIC0+XG4gICAgICBsZXQgbGVuID0gbGlzdF9sZW5ndGggMCBsIGluXG4gICAgICBsZXQgYSA9IGNyZWF0ZSBsZW4gaGQgaW5cbiAgICAgIGxldCByZWMgZmlsbCBpID0gZnVuY3Rpb25cbiAgICAgICAgICBbXSAtPiBhXG4gICAgICAgIHwgaGQ6OnRsIC0+IHVuc2FmZV9zZXQgYSBpIGhkOyBmaWxsIChpLTEpIHRsXG4gICAgICBpblxuICAgICAgZmlsbCAobGVuLTIpIHRsXG5cbmxldCBvZl9zZXEgaSA9XG4gIGxldCBsID0gU2VxLmZvbGRfbGVmdCAoZnVuIGFjYyB4IC0+IHg6OmFjYykgW10gaSBpblxuICBvZl9yZXZfbGlzdCBsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgdCA9IGludFxuXG5sZXQgemVybyA9IDBcbmxldCBvbmUgPSAxXG5sZXQgbWludXNfb25lID0gLTFcbmV4dGVybmFsIG5lZyA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuZXh0ZXJuYWwgYWRkIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhZGRpbnRcIlxuZXh0ZXJuYWwgc3ViIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuZXh0ZXJuYWwgbXVsIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtdWxpbnRcIlxuZXh0ZXJuYWwgZGl2IDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVkaXZpbnRcIlxuZXh0ZXJuYWwgcmVtIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVtb2RpbnRcIlxuZXh0ZXJuYWwgc3VjYyA6IGludCAtPiBpbnQgPSBcIiVzdWNjaW50XCJcbmV4dGVybmFsIHByZWQgOiBpbnQgLT4gaW50ID0gXCIlcHJlZGludFwiXG5sZXQgYWJzIHggPSBpZiB4ID49IDAgdGhlbiB4IGVsc2UgLXhcbmxldCBtYXhfaW50ID0gKC0xKSBsc3IgMVxubGV0IG1pbl9pbnQgPSBtYXhfaW50ICsgMVxuZXh0ZXJuYWwgbG9nYW5kIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuZXh0ZXJuYWwgbG9nb3IgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJW9yaW50XCJcbmV4dGVybmFsIGxvZ3hvciA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIleG9yaW50XCJcbmxldCBsb2dub3QgeCA9IGxvZ3hvciB4ICgtMSlcbmV4dGVybmFsIHNoaWZ0X2xlZnQgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG5leHRlcm5hbCBzaGlmdF9yaWdodCA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlYXNyaW50XCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG5sZXQgZXF1YWwgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSAoID0gKVxubGV0IGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFN0ZGxpYi5jb21wYXJlXG5leHRlcm5hbCB0b19mbG9hdCA6IGludCAtPiBmbG9hdCA9IFwiJWZsb2F0b2ZpbnRcIlxuZXh0ZXJuYWwgb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQgPSBcIiVpbnRvZmZsb2F0XCJcblxuKCpcbmV4dGVybmFsIGludF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50ID0gXCJjYW1sX2ludF9vZl9zdHJpbmdcIlxubGV0IG9mX3N0cmluZyBzID0gdHJ5IFNvbWUgKGludF9vZl9zdHJpbmcgcykgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuKilcblxuZXh0ZXJuYWwgZm9ybWF0X2ludCA6IHN0cmluZyAtPiBpbnQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9pbnRcIlxubGV0IHRvX3N0cmluZyB4ID0gZm9ybWF0X2ludCBcIiVkXCIgeFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBNb2R1bGUgW0ludDMyXTogMzItYml0IGludGVnZXJzICopXG5cbmV4dGVybmFsIG5lZyA6IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbmVnXCJcbmV4dGVybmFsIGFkZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYWRkXCJcbmV4dGVybmFsIHN1YiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfc3ViXCJcbmV4dGVybmFsIG11bCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbXVsXCJcbmV4dGVybmFsIGRpdiA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfZGl2XCJcbmV4dGVybmFsIHJlbSA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfbW9kXCJcbmV4dGVybmFsIGxvZ2FuZCA6IGludDMyIC0+IGludDMyIC0+IGludDMyID0gXCIlaW50MzJfYW5kXCJcbmV4dGVybmFsIGxvZ29yIDogaW50MzIgLT4gaW50MzIgLT4gaW50MzIgPSBcIiVpbnQzMl9vclwiXG5leHRlcm5hbCBsb2d4b3IgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQzMiA9IFwiJWludDMyX3hvclwiXG5leHRlcm5hbCBzaGlmdF9sZWZ0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfbHNsXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0IDogaW50MzIgLT4gaW50IC0+IGludDMyID0gXCIlaW50MzJfYXNyXCJcbmV4dGVybmFsIHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgOiBpbnQzMiAtPiBpbnQgLT4gaW50MzIgPSBcIiVpbnQzMl9sc3JcIlxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIHRvX2ludCA6IGludDMyIC0+IGludCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDMyXG4gID0gXCJjYW1sX2ludDMyX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgdG9fZmxvYXQgOiBpbnQzMiAtPiBmbG9hdFxuICA9IFwiY2FtbF9pbnQzMl90b19mbG9hdFwiIFwiY2FtbF9pbnQzMl90b19mbG9hdF91bmJveGVkXCJcbiAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDMyX2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50MzIgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50MzJfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQzMl9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG5sZXQgemVybyA9IDBsXG5sZXQgb25lID0gMWxcbmxldCBtaW51c19vbmUgPSAtMWxcbmxldCBzdWNjIG4gPSBhZGQgbiAxbFxubGV0IHByZWQgbiA9IHN1YiBuIDFsXG5sZXQgYWJzIG4gPSBpZiBuID49IDBsIHRoZW4gbiBlbHNlIG5lZyBuXG5sZXQgbWluX2ludCA9IDB4ODAwMDAwMDBsXG5sZXQgbWF4X2ludCA9IDB4N0ZGRkZGRkZsXG5sZXQgbG9nbm90IG4gPSBsb2d4b3IgbiAoLTFsKVxuXG5sZXQgdW5zaWduZWRfdG9faW50ID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZSB3aXRoXG4gIHwgMzIgLT5cbiAgICAgIGxldCBtYXhfaW50ID0gb2ZfaW50IFN0ZGxpYi5tYXhfaW50IGluXG4gICAgICBmdW4gbiAtPlxuICAgICAgICBpZiBjb21wYXJlIHplcm8gbiA8PSAwICYmIGNvbXBhcmUgbiBtYXhfaW50IDw9IDAgdGhlblxuICAgICAgICAgIFNvbWUgKHRvX2ludCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgTm9uZVxuICB8IDY0IC0+XG4gICAgICAoKiBTbyB0aGF0IGl0IGNvbXBpbGVzIGluIDMyLWJpdCAqKVxuICAgICAgbGV0IG1vdmUgPSBpbnRfb2Zfc3RyaW5nIFwiMHgxXzAwMDBfMDAwMFwiIGluXG4gICAgICBmdW4gbiAtPiBsZXQgaSA9IHRvX2ludCBuIGluIFNvbWUgKGlmIGkgPCAwIHRoZW4gaSArIG1vdmUgZWxzZSBpKVxuICB8IF8gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50MzIgLT4gc3RyaW5nID0gXCJjYW1sX2ludDMyX2Zvcm1hdFwiXG5sZXQgdG9fc3RyaW5nIG4gPSBmb3JtYXQgXCIlZFwiIG5cblxuZXh0ZXJuYWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IGludDMyID0gXCJjYW1sX2ludDMyX29mX3N0cmluZ1wiXG5cbmxldCBvZl9zdHJpbmdfb3B0IHMgPVxuICAoKiBUT0RPOiBleHBvc2UgYSBub24tcmFpc2luZyBwcmltaXRpdmUgZGlyZWN0bHkuICopXG4gIHRyeSBTb21lIChvZl9zdHJpbmcgcylcbiAgd2l0aCBGYWlsdXJlIF8gLT4gTm9uZVxuXG50eXBlIHQgPSBpbnQzMlxuXG5sZXQgY29tcGFyZSAoeDogdCkgKHk6IHQpID0gU3RkbGliLmNvbXBhcmUgeCB5XG5sZXQgZXF1YWwgKHg6IHQpICh5OiB0KSA9IGNvbXBhcmUgeCB5ID0gMFxuXG5sZXQgdW5zaWduZWRfY29tcGFyZSBuIG0gPVxuICBjb21wYXJlIChzdWIgbiBtaW5faW50KSAoc3ViIG0gbWluX2ludClcblxuKCogVW5zaWduZWQgZGl2aXNpb24gZnJvbSBzaWduZWQgZGl2aXNpb24gb2YgdGhlIHNhbWVcbiAgIGJpdG5lc3MuIFNlZSBXYXJyZW4gSnIuLCBIZW5yeSBTLiAoMjAxMykuIEhhY2tlcidzIERlbGlnaHQgKDIgZWQuKSwgU2VjIDktMy5cbiopXG5sZXQgdW5zaWduZWRfZGl2IG4gZCA9XG4gIGlmIGQgPCB6ZXJvIHRoZW5cbiAgICBpZiB1bnNpZ25lZF9jb21wYXJlIG4gZCA8IDAgdGhlbiB6ZXJvIGVsc2Ugb25lXG4gIGVsc2VcbiAgICBsZXQgcSA9IHNoaWZ0X2xlZnQgKGRpdiAoc2hpZnRfcmlnaHRfbG9naWNhbCBuIDEpIGQpIDEgaW5cbiAgICBsZXQgciA9IHN1YiBuIChtdWwgcSBkKSBpblxuICAgIGlmIHVuc2lnbmVkX2NvbXBhcmUgciBkID49IDAgdGhlbiBzdWNjIHEgZWxzZSBxXG5cbmxldCB1bnNpZ25lZF9yZW0gbiBkID1cbiAgc3ViIG4gKG11bCAodW5zaWduZWRfZGl2IG4gZCkgZClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogVGhlIHBhcnNpbmcgZW5naW5lICopXG5cbm9wZW4gTGV4aW5nXG5cbigqIEludGVybmFsIGludGVyZmFjZSB0byB0aGUgcGFyc2luZyBlbmdpbmUgKilcblxudHlwZSBwYXJzZXJfZW52ID1cbiAgeyBtdXRhYmxlIHNfc3RhY2sgOiBpbnQgYXJyYXk7ICAgICAgICAoKiBTdGF0ZXMgKilcbiAgICBtdXRhYmxlIHZfc3RhY2sgOiBPYmoudCBhcnJheTsgICAgICAoKiBTZW1hbnRpYyBhdHRyaWJ1dGVzICopXG4gICAgbXV0YWJsZSBzeW1iX3N0YXJ0X3N0YWNrIDogcG9zaXRpb24gYXJyYXk7ICgqIFN0YXJ0IHBvc2l0aW9ucyAqKVxuICAgIG11dGFibGUgc3ltYl9lbmRfc3RhY2sgOiBwb3NpdGlvbiBhcnJheTsgICAoKiBFbmQgcG9zaXRpb25zICopXG4gICAgbXV0YWJsZSBzdGFja3NpemUgOiBpbnQ7ICAgICAgICAgICAgKCogU2l6ZSBvZiB0aGUgc3RhY2tzICopXG4gICAgbXV0YWJsZSBzdGFja2Jhc2UgOiBpbnQ7ICAgICAgICAgICAgKCogQmFzZSBzcCBmb3IgY3VycmVudCBwYXJzZSAqKVxuICAgIG11dGFibGUgY3Vycl9jaGFyIDogaW50OyAgICAgICAgICAgICgqIExhc3QgdG9rZW4gcmVhZCAqKVxuICAgIG11dGFibGUgbHZhbCA6IE9iai50OyAgICAgICAgICAgICAgICgqIEl0cyBzZW1hbnRpYyBhdHRyaWJ1dGUgKilcbiAgICBtdXRhYmxlIHN5bWJfc3RhcnQgOiBwb3NpdGlvbjsgICAgICAoKiBTdGFydCBwb3MuIG9mIHRoZSBjdXJyZW50IHN5bWJvbCopXG4gICAgbXV0YWJsZSBzeW1iX2VuZCA6IHBvc2l0aW9uOyAgICAgICAgKCogRW5kIHBvcy4gb2YgdGhlIGN1cnJlbnQgc3ltYm9sICopXG4gICAgbXV0YWJsZSBhc3AgOiBpbnQ7ICAgICAgICAgICAgICAgICAgKCogVGhlIHN0YWNrIHBvaW50ZXIgZm9yIGF0dHJpYnV0ZXMgKilcbiAgICBtdXRhYmxlIHJ1bGVfbGVuIDogaW50OyAgICAgICAgICAgICAoKiBOdW1iZXIgb2YgcmhzIGl0ZW1zIGluIHRoZSBydWxlICopXG4gICAgbXV0YWJsZSBydWxlX251bWJlciA6IGludDsgICAgICAgICAgKCogUnVsZSBudW1iZXIgdG8gcmVkdWNlIGJ5ICopXG4gICAgbXV0YWJsZSBzcCA6IGludDsgICAgICAgICAgICAgICAgICAgKCogU2F2ZWQgc3AgZm9yIHBhcnNlX2VuZ2luZSAqKVxuICAgIG11dGFibGUgc3RhdGUgOiBpbnQ7ICAgICAgICAgICAgICAgICgqIFNhdmVkIHN0YXRlIGZvciBwYXJzZV9lbmdpbmUgKilcbiAgICBtdXRhYmxlIGVycmZsYWcgOiBpbnQgfSAgICAgICAgICAgICAoKiBTYXZlZCBlcnJvciBmbGFnIGZvciBwYXJzZV9lbmdpbmUgKilcblxudHlwZSBwYXJzZV90YWJsZXMgPVxuICB7IGFjdGlvbnMgOiAocGFyc2VyX2VudiAtPiBPYmoudCkgYXJyYXk7XG4gICAgdHJhbnNsX2NvbnN0IDogaW50IGFycmF5O1xuICAgIHRyYW5zbF9ibG9jayA6IGludCBhcnJheTtcbiAgICBsaHMgOiBzdHJpbmc7XG4gICAgbGVuIDogc3RyaW5nO1xuICAgIGRlZnJlZCA6IHN0cmluZztcbiAgICBkZ290byA6IHN0cmluZztcbiAgICBzaW5kZXggOiBzdHJpbmc7XG4gICAgcmluZGV4IDogc3RyaW5nO1xuICAgIGdpbmRleCA6IHN0cmluZztcbiAgICB0YWJsZXNpemUgOiBpbnQ7XG4gICAgdGFibGUgOiBzdHJpbmc7XG4gICAgY2hlY2sgOiBzdHJpbmc7XG4gICAgZXJyb3JfZnVuY3Rpb24gOiBzdHJpbmcgLT4gdW5pdDtcbiAgICBuYW1lc19jb25zdCA6IHN0cmluZztcbiAgICBuYW1lc19ibG9jayA6IHN0cmluZyB9XG5cbmV4Y2VwdGlvbiBZWWV4aXQgb2YgT2JqLnRcbmV4Y2VwdGlvbiBQYXJzZV9lcnJvclxuXG50eXBlIHBhcnNlcl9pbnB1dCA9XG4gICAgU3RhcnRcbiAgfCBUb2tlbl9yZWFkXG4gIHwgU3RhY2tzX2dyb3duXzFcbiAgfCBTdGFja3NfZ3Jvd25fMlxuICB8IFNlbWFudGljX2FjdGlvbl9jb21wdXRlZFxuICB8IEVycm9yX2RldGVjdGVkXG5cbnR5cGUgcGFyc2VyX291dHB1dCA9XG4gICAgUmVhZF90b2tlblxuICB8IFJhaXNlX3BhcnNlX2Vycm9yXG4gIHwgR3Jvd19zdGFja3NfMVxuICB8IEdyb3dfc3RhY2tzXzJcbiAgfCBDb21wdXRlX3NlbWFudGljX2FjdGlvblxuICB8IENhbGxfZXJyb3JfZnVuY3Rpb25cblxuKCogdG8gYXZvaWQgd2FybmluZ3MgKilcbmxldCBfID0gW1JlYWRfdG9rZW47IFJhaXNlX3BhcnNlX2Vycm9yOyBHcm93X3N0YWNrc18xOyBHcm93X3N0YWNrc18yO1xuICAgICAgICAgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb247IENhbGxfZXJyb3JfZnVuY3Rpb25dXG5cbmV4dGVybmFsIHBhcnNlX2VuZ2luZSA6XG4gICAgcGFyc2VfdGFibGVzIC0+IHBhcnNlcl9lbnYgLT4gcGFyc2VyX2lucHV0IC0+IE9iai50IC0+IHBhcnNlcl9vdXRwdXRcbiAgICA9IFwiY2FtbF9wYXJzZV9lbmdpbmVcIlxuXG5leHRlcm5hbCBzZXRfdHJhY2U6IGJvb2wgLT4gYm9vbFxuICAgID0gXCJjYW1sX3NldF9wYXJzZXJfdHJhY2VcIlxuXG5sZXQgZW52ID1cbiAgeyBzX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgMDtcbiAgICB2X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgKE9iai5yZXByICgpKTtcbiAgICBzeW1iX3N0YXJ0X3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN5bWJfZW5kX3N0YWNrID0gQXJyYXkubWFrZSAxMDAgZHVtbXlfcG9zO1xuICAgIHN0YWNrc2l6ZSA9IDEwMDtcbiAgICBzdGFja2Jhc2UgPSAwO1xuICAgIGN1cnJfY2hhciA9IDA7XG4gICAgbHZhbCA9IE9iai5yZXByICgpO1xuICAgIHN5bWJfc3RhcnQgPSBkdW1teV9wb3M7XG4gICAgc3ltYl9lbmQgPSBkdW1teV9wb3M7XG4gICAgYXNwID0gMDtcbiAgICBydWxlX2xlbiA9IDA7XG4gICAgcnVsZV9udW1iZXIgPSAwO1xuICAgIHNwID0gMDtcbiAgICBzdGF0ZSA9IDA7XG4gICAgZXJyZmxhZyA9IDAgfVxuXG5sZXQgZ3Jvd19zdGFja3MoKSA9XG4gIGxldCBvbGRzaXplID0gZW52LnN0YWNrc2l6ZSBpblxuICBsZXQgbmV3c2l6ZSA9IG9sZHNpemUgKiAyIGluXG4gIGxldCBuZXdfcyA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAwXG4gIGFuZCBuZXdfdiA9IEFycmF5Lm1ha2UgbmV3c2l6ZSAoT2JqLnJlcHIgKCkpXG4gIGFuZCBuZXdfc3RhcnQgPSBBcnJheS5tYWtlIG5ld3NpemUgZHVtbXlfcG9zXG4gIGFuZCBuZXdfZW5kID0gQXJyYXkubWFrZSBuZXdzaXplIGR1bW15X3BvcyBpblxuICAgIEFycmF5LmJsaXQgZW52LnNfc3RhY2sgMCBuZXdfcyAwIG9sZHNpemU7XG4gICAgZW52LnNfc3RhY2sgPC0gbmV3X3M7XG4gICAgQXJyYXkuYmxpdCBlbnYudl9zdGFjayAwIG5ld192IDAgb2xkc2l6ZTtcbiAgICBlbnYudl9zdGFjayA8LSBuZXdfdjtcbiAgICBBcnJheS5ibGl0IGVudi5zeW1iX3N0YXJ0X3N0YWNrIDAgbmV3X3N0YXJ0IDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9zdGFydF9zdGFjayA8LSBuZXdfc3RhcnQ7XG4gICAgQXJyYXkuYmxpdCBlbnYuc3ltYl9lbmRfc3RhY2sgMCBuZXdfZW5kIDAgb2xkc2l6ZTtcbiAgICBlbnYuc3ltYl9lbmRfc3RhY2sgPC0gbmV3X2VuZDtcbiAgICBlbnYuc3RhY2tzaXplIDwtIG5ld3NpemVcblxubGV0IGNsZWFyX3BhcnNlcigpID1cbiAgQXJyYXkuZmlsbCBlbnYudl9zdGFjayAwIGVudi5zdGFja3NpemUgKE9iai5yZXByICgpKTtcbiAgZW52Lmx2YWwgPC0gT2JqLnJlcHIgKClcblxubGV0IGN1cnJlbnRfbG9va2FoZWFkX2Z1biA9IHJlZiAoZnVuIChfIDogT2JqLnQpIC0+IGZhbHNlKVxuXG5sZXQgeXlwYXJzZSB0YWJsZXMgc3RhcnQgbGV4ZXIgbGV4YnVmID1cbiAgbGV0IHJlYyBsb29wIGNtZCBhcmcgPVxuICAgIG1hdGNoIHBhcnNlX2VuZ2luZSB0YWJsZXMgZW52IGNtZCBhcmcgd2l0aFxuICAgICAgUmVhZF90b2tlbiAtPlxuICAgICAgICBsZXQgdCA9IE9iai5yZXByKGxleGVyIGxleGJ1ZikgaW5cbiAgICAgICAgZW52LnN5bWJfc3RhcnQgPC0gbGV4YnVmLmxleF9zdGFydF9wO1xuICAgICAgICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gICAgICAgIGxvb3AgVG9rZW5fcmVhZCB0XG4gICAgfCBSYWlzZV9wYXJzZV9lcnJvciAtPlxuICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgIHwgQ29tcHV0ZV9zZW1hbnRpY19hY3Rpb24gLT5cbiAgICAgICAgbGV0IChhY3Rpb24sIHZhbHVlKSA9XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAoU2VtYW50aWNfYWN0aW9uX2NvbXB1dGVkLCB0YWJsZXMuYWN0aW9ucy4oZW52LnJ1bGVfbnVtYmVyKSBlbnYpXG4gICAgICAgICAgd2l0aCBQYXJzZV9lcnJvciAtPlxuICAgICAgICAgICAgKEVycm9yX2RldGVjdGVkLCBPYmoucmVwciAoKSkgaW5cbiAgICAgICAgbG9vcCBhY3Rpb24gdmFsdWVcbiAgICB8IEdyb3dfc3RhY2tzXzEgLT5cbiAgICAgICAgZ3Jvd19zdGFja3MoKTsgbG9vcCBTdGFja3NfZ3Jvd25fMSAoT2JqLnJlcHIgKCkpXG4gICAgfCBHcm93X3N0YWNrc18yIC0+XG4gICAgICAgIGdyb3dfc3RhY2tzKCk7IGxvb3AgU3RhY2tzX2dyb3duXzIgKE9iai5yZXByICgpKVxuICAgIHwgQ2FsbF9lcnJvcl9mdW5jdGlvbiAtPlxuICAgICAgICB0YWJsZXMuZXJyb3JfZnVuY3Rpb24gXCJzeW50YXggZXJyb3JcIjtcbiAgICAgICAgbG9vcCBFcnJvcl9kZXRlY3RlZCAoT2JqLnJlcHIgKCkpIGluXG4gIGxldCBpbml0X2FzcCA9IGVudi5hc3BcbiAgYW5kIGluaXRfc3AgPSBlbnYuc3BcbiAgYW5kIGluaXRfc3RhY2tiYXNlID0gZW52LnN0YWNrYmFzZVxuICBhbmQgaW5pdF9zdGF0ZSA9IGVudi5zdGF0ZVxuICBhbmQgaW5pdF9jdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyXG4gIGFuZCBpbml0X2x2YWwgPSBlbnYubHZhbFxuICBhbmQgaW5pdF9lcnJmbGFnID0gZW52LmVycmZsYWcgaW5cbiAgZW52LnN0YWNrYmFzZSA8LSBlbnYuc3AgKyAxO1xuICBlbnYuY3Vycl9jaGFyIDwtIHN0YXJ0O1xuICBlbnYuc3ltYl9lbmQgPC0gbGV4YnVmLmxleF9jdXJyX3A7XG4gIHRyeVxuICAgIGxvb3AgU3RhcnQgKE9iai5yZXByICgpKVxuICB3aXRoIGV4biAtPlxuICAgIGxldCBjdXJyX2NoYXIgPSBlbnYuY3Vycl9jaGFyIGluXG4gICAgZW52LmFzcCA8LSBpbml0X2FzcDtcbiAgICBlbnYuc3AgPC0gaW5pdF9zcDtcbiAgICBlbnYuc3RhY2tiYXNlIDwtIGluaXRfc3RhY2tiYXNlO1xuICAgIGVudi5zdGF0ZSA8LSBpbml0X3N0YXRlO1xuICAgIGVudi5jdXJyX2NoYXIgPC0gaW5pdF9jdXJyX2NoYXI7XG4gICAgZW52Lmx2YWwgPC0gaW5pdF9sdmFsO1xuICAgIGVudi5lcnJmbGFnIDwtIGluaXRfZXJyZmxhZztcbiAgICBtYXRjaCBleG4gd2l0aFxuICAgICAgWVlleGl0IHYgLT5cbiAgICAgICAgT2JqLm1hZ2ljIHZcbiAgICB8IF8gLT5cbiAgICAgICAgY3VycmVudF9sb29rYWhlYWRfZnVuIDo9XG4gICAgICAgICAgKGZ1biB0b2sgLT5cbiAgICAgICAgICAgIGlmIE9iai5pc19ibG9jayB0b2tcbiAgICAgICAgICAgIHRoZW4gdGFibGVzLnRyYW5zbF9ibG9jay4oT2JqLnRhZyB0b2spID0gY3Vycl9jaGFyXG4gICAgICAgICAgICBlbHNlIHRhYmxlcy50cmFuc2xfY29uc3QuKE9iai5tYWdpYyB0b2spID0gY3Vycl9jaGFyKTtcbiAgICAgICAgcmFpc2UgZXhuXG5cbmxldCBwZWVrX3ZhbCBlbnYgbiA9XG4gIE9iai5tYWdpYyBlbnYudl9zdGFjay4oZW52LmFzcCAtIG4pXG5cbmxldCBzeW1ib2xfc3RhcnRfcG9zICgpID1cbiAgbGV0IHJlYyBsb29wIGkgPVxuICAgIGlmIGkgPD0gMCB0aGVuIGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgc3QgPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIGkgKyAxKSBpblxuICAgICAgbGV0IGVuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gaSArIDEpIGluXG4gICAgICBpZiBzdCA8PiBlbiB0aGVuIHN0IGVsc2UgbG9vcCAoaSAtIDEpXG4gICAgZW5kXG4gIGluXG4gIGxvb3AgZW52LnJ1bGVfbGVuXG5cbmxldCBzeW1ib2xfZW5kX3BvcyAoKSA9IGVudi5zeW1iX2VuZF9zdGFjay4oZW52LmFzcClcbmxldCByaHNfc3RhcnRfcG9zIG4gPSBlbnYuc3ltYl9zdGFydF9zdGFjay4oZW52LmFzcCAtIChlbnYucnVsZV9sZW4gLSBuKSlcbmxldCByaHNfZW5kX3BvcyBuID0gZW52LnN5bWJfZW5kX3N0YWNrLihlbnYuYXNwIC0gKGVudi5ydWxlX2xlbiAtIG4pKVxuXG5sZXQgc3ltYm9sX3N0YXJ0ICgpID0gKHN5bWJvbF9zdGFydF9wb3MgKCkpLnBvc19jbnVtXG5sZXQgc3ltYm9sX2VuZCAoKSA9IChzeW1ib2xfZW5kX3BvcyAoKSkucG9zX2NudW1cbmxldCByaHNfc3RhcnQgbiA9IChyaHNfc3RhcnRfcG9zIG4pLnBvc19jbnVtXG5sZXQgcmhzX2VuZCBuID0gKHJoc19lbmRfcG9zIG4pLnBvc19jbnVtXG5cbmxldCBpc19jdXJyZW50X2xvb2thaGVhZCB0b2sgPVxuICAoIWN1cnJlbnRfbG9va2FoZWFkX2Z1bikoT2JqLnJlcHIgdG9rKVxuXG5sZXQgcGFyc2VfZXJyb3IgKF8gOiBzdHJpbmcpID0gKClcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUgZWx0XG4gICAgdHlwZSB0XG4gICAgdmFsIGVtcHR5OiB0XG4gICAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgICB2YWwgbWVtOiBlbHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCBzaW5nbGV0b246IGVsdCAtPiB0XG4gICAgdmFsIHJlbW92ZTogZWx0IC0+IHQgLT4gdFxuICAgIHZhbCB1bmlvbjogdCAtPiB0IC0+IHRcbiAgICB2YWwgaW50ZXI6IHQgLT4gdCAtPiB0XG4gICAgdmFsIGRpc2pvaW50OiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBkaWZmOiB0IC0+IHQgLT4gdFxuICAgIHZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBzdWJzZXQ6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGl0ZXI6IChlbHQgLT4gdW5pdCkgLT4gdCAtPiB1bml0XG4gICAgdmFsIG1hcDogKGVsdCAtPiBlbHQpIC0+IHQgLT4gdFxuICAgIHZhbCBmb2xkOiAoZWx0IC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gICAgdmFsIGZvcl9hbGw6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBib29sXG4gICAgdmFsIGV4aXN0czogKGVsdCAtPiBib29sKSAtPiB0IC0+IGJvb2xcbiAgICB2YWwgZmlsdGVyOiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gdFxuICAgIHZhbCBmaWx0ZXJfbWFwOiAoZWx0IC0+IGVsdCBvcHRpb24pIC0+IHQgLT4gdFxuICAgIHZhbCBwYXJ0aXRpb246IChlbHQgLT4gYm9vbCkgLT4gdCAtPiB0ICogdFxuICAgIHZhbCBjYXJkaW5hbDogdCAtPiBpbnRcbiAgICB2YWwgZWxlbWVudHM6IHQgLT4gZWx0IGxpc3RcbiAgICB2YWwgbWluX2VsdDogdCAtPiBlbHRcbiAgICB2YWwgbWluX2VsdF9vcHQ6IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBtYXhfZWx0OiB0IC0+IGVsdFxuICAgIHZhbCBtYXhfZWx0X29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGNob29zZTogdCAtPiBlbHRcbiAgICB2YWwgY2hvb3NlX29wdDogdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIHNwbGl0OiBlbHQgLT4gdCAtPiB0ICogYm9vbCAqIHRcbiAgICB2YWwgZmluZDogZWx0IC0+IHQgLT4gZWx0XG4gICAgdmFsIGZpbmRfb3B0OiBlbHQgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfZmlyc3Q6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHRcbiAgICB2YWwgZmluZF9maXJzdF9vcHQ6IChlbHQgLT4gYm9vbCkgLT4gdCAtPiBlbHQgb3B0aW9uXG4gICAgdmFsIGZpbmRfbGFzdDogKGVsdCAtPiBib29sKSAtPiB0IC0+IGVsdFxuICAgIHZhbCBmaW5kX2xhc3Rfb3B0OiAoZWx0IC0+IGJvb2wpIC0+IHQgLT4gZWx0IG9wdGlvblxuICAgIHZhbCBvZl9saXN0OiBlbHQgbGlzdCAtPiB0XG4gICAgdmFsIHRvX3NlcV9mcm9tIDogZWx0IC0+IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIHRvX3NlcSA6IHQgLT4gZWx0IFNlcS50XG4gICAgdmFsIGFkZF9zZXEgOiBlbHQgU2VxLnQgLT4gdCAtPiB0XG4gICAgdmFsIG9mX3NlcSA6IGVsdCBTZXEudCAtPiB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZShPcmQ6IE9yZGVyZWRUeXBlKSA9XG4gIHN0cnVjdFxuICAgIHR5cGUgZWx0ID0gT3JkLnRcbiAgICB0eXBlIHQgPSBFbXB0eSB8IE5vZGUgb2Yge2w6dDsgdjplbHQ7IHI6dDsgaDppbnR9XG5cbiAgICAoKiBTZXRzIGFyZSByZXByZXNlbnRlZCBieSBiYWxhbmNlZCBiaW5hcnkgdHJlZXMgKHRoZSBoZWlnaHRzIG9mIHRoZVxuICAgICAgIGNoaWxkcmVuIGRpZmZlciBieSBhdCBtb3N0IDIgKilcblxuICAgIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAwXG4gICAgICB8IE5vZGUge2h9IC0+IGhcblxuICAgICgqIENyZWF0ZXMgYSBuZXcgbm9kZSB3aXRoIGxlZnQgc29uIGwsIHZhbHVlIHYgYW5kIHJpZ2h0IHNvbiByLlxuICAgICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgICBsIGFuZCByIG11c3QgYmUgYmFsYW5jZWQgYW5kIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuXG4gICAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBoZWlnaHQgZm9yIGJldHRlciBzcGVlZC4gKilcblxuICAgIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIE5vZGV7bDsgdjsgcjsgaD0oaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEpfVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgICAgQXNzdW1lcyBsIGFuZCByIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAzLlxuICAgICAgIElubGluZSBleHBhbnNpb24gb2YgY3JlYXRlIGZvciBiZXR0ZXIgc3BlZWQgaW4gdGhlIG1vc3QgZnJlcXVlbnQgY2FzZVxuICAgICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gICAgbGV0IGJhbCBsIHYgciA9XG4gICAgICBsZXQgaGwgPSBtYXRjaCBsIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGxldCBociA9IG1hdGNoIHIgd2l0aCBFbXB0eSAtPiAwIHwgTm9kZSB7aH0gLT4gaCBpblxuICAgICAgaWYgaGwgPiBociArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1sbDsgdj1sdjsgcj1scn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHIgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgbGwgbHYgKGNyZWF0ZSBsciB2IHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIlNldC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyByPWxycn0tPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBpZiBociA+IGhsICsgMiB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIHIgd2l0aFxuICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgIHwgTm9kZXtsPXJsOyB2PXJ2OyByPXJyfSAtPlxuICAgICAgICAgICAgaWYgaGVpZ2h0IHJyID49IGhlaWdodCBybCB0aGVuXG4gICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBybCkgcnYgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IHI9cmxyfSAtPlxuICAgICAgICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB2IHJsbCkgcmx2IChjcmVhdGUgcmxyIHJ2IHJyKVxuICAgICAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBOb2Rle2w7IHY7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgICgqIEluc2VydGlvbiBvZiBvbmUgZWxlbWVudCAqKVxuXG4gICAgbGV0IHJlYyBhZGQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gYXMgdCAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB0IGVsc2VcbiAgICAgICAgICBpZiBjIDwgMCB0aGVuXG4gICAgICAgICAgICBsZXQgbGwgPSBhZGQgeCBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdCBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSBhZGQgeCByIGluXG4gICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdCBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCBzaW5nbGV0b24geCA9IE5vZGV7bD1FbXB0eTsgdj14OyByPUVtcHR5OyBoPTF9XG5cbiAgICAoKiBCZXdhcmU6IHRob3NlIHR3byBmdW5jdGlvbnMgYXNzdW1lIHRoYXQgdGhlIGFkZGVkIHYgaXMgKnN0cmljdGx5KlxuICAgICAgIHNtYWxsZXIgKG9yIGJpZ2dlcikgdGhhbiBhbGwgdGhlIHByZXNlbnQgZWxlbWVudHMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkgZWxlbWVudC5cbiAgICAgICBJbmRlZWQsIHRoZXkgYXJlIG9ubHkgdXNlZCBkdXJpbmcgdGhlIFwiam9pblwiIG9wZXJhdGlvbiB3aGljaFxuICAgICAgIHJlc3BlY3RzIHRoaXMgcHJlY29uZGl0aW9uLlxuICAgICopXG5cbiAgICBsZXQgcmVjIGFkZF9taW5fZWxlbWVudCB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgcn0gLT5cbiAgICAgICAgYmFsIChhZGRfbWluX2VsZW1lbnQgeCBsKSB2IHJcblxuICAgIGxldCByZWMgYWRkX21heF9lbGVtZW50IHggPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBzaW5nbGV0b24geFxuICAgICAgfCBOb2RlIHtsOyB2OyByfSAtPlxuICAgICAgICBiYWwgbCB2IChhZGRfbWF4X2VsZW1lbnQgeCByKVxuXG4gICAgKCogU2FtZSBhcyBjcmVhdGUgYW5kIGJhbCwgYnV0IG5vIGFzc3VtcHRpb25zIGFyZSBtYWRlIG9uIHRoZVxuICAgICAgIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCByZWMgam9pbiBsIHYgciA9XG4gICAgICBtYXRjaCAobCwgcikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIC0+IGFkZF9taW5fZWxlbWVudCB2IHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2VsZW1lbnQgdiBsXG4gICAgICB8IChOb2Rle2w9bGw7IHY9bHY7IHI9bHI7IGg9bGh9LCBOb2Rle2w9cmw7IHY9cnY7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IChqb2luIGxyIHYgcikgZWxzZVxuICAgICAgICAgIGlmIHJoID4gbGggKyAyIHRoZW4gYmFsIChqb2luIGwgdiBybCkgcnYgcnIgZWxzZVxuICAgICAgICAgIGNyZWF0ZSBsIHYgclxuXG4gICAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcblxuICAgIGxldCByZWMgbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w9RW1wdHk7IHZ9IC0+IHZcbiAgICAgIHwgTm9kZXtsfSAtPiBtaW5fZWx0IGxcblxuICAgIGxldCByZWMgbWluX2VsdF9vcHQgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bD1FbXB0eTsgdn0gLT4gU29tZSB2XG4gICAgICB8IE5vZGV7bH0gLT4gbWluX2VsdF9vcHQgbFxuXG4gICAgbGV0IHJlYyBtYXhfZWx0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGV7djsgcj1FbXB0eX0gLT4gdlxuICAgICAgfCBOb2Rle3J9IC0+IG1heF9lbHQgclxuXG4gICAgbGV0IHJlYyBtYXhfZWx0X29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZXt2OyByPUVtcHR5fSAtPiBTb21lIHZcbiAgICAgIHwgTm9kZXtyfSAtPiBtYXhfZWx0X29wdCByXG5cbiAgICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gICAgbGV0IHJlYyByZW1vdmVfbWluX2VsdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiU2V0LnJlbW92ZV9taW5fZWx0XCJcbiAgICAgIHwgTm9kZXtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcblxuICAgICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLlxuICAgICAgIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgICBBc3N1bWUgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMi4gKilcblxuICAgIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgICBtYXRjaCAodDEsIHQyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgdCkgLT4gdFxuICAgICAgfCAodCwgRW1wdHkpIC0+IHRcbiAgICAgIHwgKF8sIF8pIC0+IGJhbCB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiBqb2luIHQxIChtaW5fZWx0IHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpXG5cbiAgICAoKiBTcGxpdHRpbmcuICBzcGxpdCB4IHMgcmV0dXJucyBhIHRyaXBsZSAobCwgcHJlc2VudCwgcikgd2hlcmVcbiAgICAgICAgLSBsIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA8IHhcbiAgICAgICAgLSByIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgb2YgcyB0aGF0IGFyZSA+IHhcbiAgICAgICAgLSBwcmVzZW50IGlzIGZhbHNlIGlmIHMgY29udGFpbnMgbm8gZWxlbWVudCBlcXVhbCB0byB4LFxuICAgICAgICAgIG9yIHRydWUgaWYgcyBjb250YWlucyBhbiBlbGVtZW50IGVxdWFsIHRvIHguICopXG5cbiAgICBsZXQgcmVjIHNwbGl0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIChFbXB0eSwgZmFsc2UsIEVtcHR5KVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIChsLCB0cnVlLCByKVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IChsbCwgcHJlcywgcmwpID0gc3BsaXQgeCBsIGluIChsbCwgcHJlcywgam9pbiBybCB2IHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBsciwgcHJlcywgcnIpXG5cbiAgICAoKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgc2V0IG9wZXJhdGlvbnMgKilcblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBtZW0geCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGMgPSAwIHx8IG1lbSB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyByZW1vdmUgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9IGFzIHQpIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgICAgbGV0IGxsID0gcmVtb3ZlIHggbCBpblxuICAgICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsbCB2IHJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbGV0IHJyID0gcmVtb3ZlIHggciBpblxuICAgICAgICAgICAgICBpZiByID09IHJyIHRoZW4gdFxuICAgICAgICAgICAgICBlbHNlIGJhbCBsIHYgcnJcblxuICAgIGxldCByZWMgdW5pb24gczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIHQyKSAtPiB0MlxuICAgICAgfCAodDEsIEVtcHR5KSAtPiB0MVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxOyBoPWgxfSwgTm9kZXtsPWwyOyB2PXYyOyByPXIyOyBoPWgyfSkgLT5cbiAgICAgICAgICBpZiBoMSA+PSBoMiB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDEgdGhlbiBhZGQgdjIgczEgZWxzZSBiZWdpblxuICAgICAgICAgICAgICBsZXQgKGwyLCBfLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjEgKHVuaW9uIHIxIHIyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaWYgaDEgPSAxIHRoZW4gYWRkIHYxIHMyIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbGV0IChsMSwgXywgcjEpID0gc3BsaXQgdjIgczEgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYyICh1bmlvbiByMSByMilcbiAgICAgICAgICAgIGVuZFxuXG4gICAgbGV0IHJlYyBpbnRlciBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBFbXB0eVxuICAgICAgfCAoTm9kZXtsPWwxOyB2PXYxOyByPXIxfSwgdDIpIC0+XG4gICAgICAgICAgbWF0Y2ggc3BsaXQgdjEgdDIgd2l0aFxuICAgICAgICAgICAgKGwyLCBmYWxzZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpXG5cbiAgICAoKiBTYW1lIGFzIHNwbGl0LCBidXQgY29tcHV0ZSB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXNcbiAgICAgICBvbmx5IGlmIHRoZSBwaXZvdCBlbGVtZW50IGlzIG5vdCBpbiB0aGUgc2V0LiAgVGhlIHJpZ2h0IHN1YnRyZWVcbiAgICAgICBpcyBjb21wdXRlZCBvbiBkZW1hbmQuICopXG5cbiAgICB0eXBlIHNwbGl0X2JpcyA9XG4gICAgICB8IEZvdW5kXG4gICAgICB8IE5vdEZvdW5kIG9mIHQgKiAodW5pdCAtPiB0KVxuXG4gICAgbGV0IHJlYyBzcGxpdF9iaXMgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm90Rm91bmQgKEVtcHR5LCAoZnVuICgpIC0+IEVtcHR5KSlcbiAgICAgIHwgTm9kZXtsOyB2OyByOyBffSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBGb3VuZFxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbWF0Y2ggc3BsaXRfYmlzIHggbCB3aXRoXG4gICAgICAgICAgICB8IEZvdW5kIC0+IEZvdW5kXG4gICAgICAgICAgICB8IE5vdEZvdW5kIChsbCwgcmwpIC0+IE5vdEZvdW5kIChsbCwgKGZ1biAoKSAtPiBqb2luIChybCAoKSkgdiByKSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXRjaCBzcGxpdF9iaXMgeCByIHdpdGhcbiAgICAgICAgICAgIHwgRm91bmQgLT4gRm91bmRcbiAgICAgICAgICAgIHwgTm90Rm91bmQgKGxyLCBycikgLT4gTm90Rm91bmQgKGpvaW4gbCB2IGxyLCBycilcblxuICAgIGxldCByZWMgZGlzam9pbnQgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgICAoRW1wdHksIF8pIHwgKF8sIEVtcHR5KSAtPiB0cnVlXG4gICAgICB8IChOb2Rle2w9bDE7IHY9djE7IHI9cjF9LCB0MikgLT5cbiAgICAgICAgICBpZiBzMSA9PSBzMiB0aGVuIGZhbHNlXG4gICAgICAgICAgZWxzZSBtYXRjaCBzcGxpdF9iaXMgdjEgdDIgd2l0aFxuICAgICAgICAgICAgICBOb3RGb3VuZChsMiwgcjIpIC0+IGRpc2pvaW50IGwxIGwyICYmIGRpc2pvaW50IHIxIChyMiAoKSlcbiAgICAgICAgICAgIHwgRm91bmQgLT4gZmFsc2VcblxuICAgIGxldCByZWMgZGlmZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgXykgLT4gRW1wdHlcbiAgICAgIHwgKHQxLCBFbXB0eSkgLT4gdDFcbiAgICAgIHwgKE5vZGV7bD1sMTsgdj12MTsgcj1yMX0sIHQyKSAtPlxuICAgICAgICAgIG1hdGNoIHNwbGl0IHYxIHQyIHdpdGhcbiAgICAgICAgICAgIChsMiwgZmFsc2UsIHIyKSAtPlxuICAgICAgICAgICAgICBqb2luIChkaWZmIGwxIGwyKSB2MSAoZGlmZiByMSByMilcbiAgICAgICAgICB8IChsMiwgdHJ1ZSwgcjIpIC0+XG4gICAgICAgICAgICAgIGNvbmNhdCAoZGlmZiBsMSBsMikgKGRpZmYgcjEgcjIpXG5cbiAgICB0eXBlIGVudW1lcmF0aW9uID0gRW5kIHwgTW9yZSBvZiBlbHQgKiB0ICogZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIHMgZSA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGNvbnNfZW51bSBsIChNb3JlKHYsIHIsIGUpKVxuXG4gICAgbGV0IHJlYyBjb21wYXJlX2F1eCBlMSBlMiA9XG4gICAgICAgIG1hdGNoIChlMSwgZTIpIHdpdGhcbiAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICB8IChFbmQsIF8pICAtPiAtMVxuICAgICAgfCAoXywgRW5kKSAtPiAxXG4gICAgICB8IChNb3JlKHYxLCByMSwgZTEpLCBNb3JlKHYyLCByMiwgZTIpKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG5cbiAgICBsZXQgY29tcGFyZSBzMSBzMiA9XG4gICAgICBjb21wYXJlX2F1eCAoY29uc19lbnVtIHMxIEVuZCkgKGNvbnNfZW51bSBzMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgczEgczIgPVxuICAgICAgY29tcGFyZSBzMSBzMiA9IDBcblxuICAgIGxldCByZWMgc3Vic2V0IHMxIHMyID1cbiAgICAgIG1hdGNoIChzMSwgczIpIHdpdGhcbiAgICAgICAgRW1wdHksIF8gLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IF8sIEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgTm9kZSB7bD1sMTsgdj12MTsgcj1yMX0sIChOb2RlIHtsPWwyOyB2PXYyOyByPXIyfSBhcyB0MikgLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IGwxIGwyICYmIHN1YnNldCByMSByMlxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgc3Vic2V0IChOb2RlIHtsPWwxOyB2PXYxOyByPUVtcHR5OyBoPTB9KSBsMiAmJiBzdWJzZXQgcjEgdDJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBzdWJzZXQgKE5vZGUge2w9RW1wdHk7IHY9djE7IHI9cjE7IGg9MH0pIHIyICYmIHN1YnNldCBsMSB0MlxuXG4gICAgbGV0IHJlYyBpdGVyIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiAoKVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IGl0ZXIgZiBsOyBmIHY7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIGZvbGQgZiBzIGFjY3UgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICAgIEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPiBmb2xkIGYgciAoZiB2IChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+IHAgdiAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gcCB2IHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IChOb2Rle2w7IHY7IHJ9KSBhcyB0IC0+XG4gICAgICAgICAgKCogY2FsbCBbcF0gaW4gdGhlIGV4cGVjdGVkIGxlZnQtdG8tcmlnaHQgb3JkZXIgKilcbiAgICAgICAgICBsZXQgbCcgPSBmaWx0ZXIgcCBsIGluXG4gICAgICAgICAgbGV0IHB2ID0gcCB2IGluXG4gICAgICAgICAgbGV0IHInID0gZmlsdGVyIHAgciBpblxuICAgICAgICAgIGlmIHB2IHRoZW5cbiAgICAgICAgICAgIGlmIGw9PWwnICYmIHI9PXInIHRoZW4gdCBlbHNlIGpvaW4gbCcgdiByJ1xuICAgICAgICAgIGVsc2UgY29uY2F0IGwnIHInXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW3BdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IChsdCwgbGYpID0gcGFydGl0aW9uIHAgbCBpblxuICAgICAgICAgIGxldCBwdiA9IHAgdiBpblxuICAgICAgICAgIGxldCAocnQsIHJmKSA9IHBhcnRpdGlvbiBwIHIgaW5cbiAgICAgICAgICBpZiBwdlxuICAgICAgICAgIHRoZW4gKGpvaW4gbHQgdiBydCwgY29uY2F0IGxmIHJmKVxuICAgICAgICAgIGVsc2UgKGNvbmNhdCBsdCBydCwgam9pbiBsZiB2IHJmKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZXtsOyByfSAtPiBjYXJkaW5hbCBsICsgMSArIGNhcmRpbmFsIHJcblxuICAgIGxldCByZWMgZWxlbWVudHNfYXV4IGFjY3UgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT4gZWxlbWVudHNfYXV4ICh2IDo6IGVsZW1lbnRzX2F1eCBhY2N1IHIpIGxcblxuICAgIGxldCBlbGVtZW50cyBzID1cbiAgICAgIGVsZW1lbnRzX2F1eCBbXSBzXG5cbiAgICBsZXQgY2hvb3NlID0gbWluX2VsdFxuXG4gICAgbGV0IGNob29zZV9vcHQgPSBtaW5fZWx0X29wdFxuXG4gICAgbGV0IHJlYyBmaW5kIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiB2XG4gICAgICAgICAgZWxzZSBmaW5kIHggKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3RfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdiBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2MCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3QgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lIHYwXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYwIGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHRfYXV4IHYgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9vcHQgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9hdXggdjAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3RfYXV4IHYgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2MCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3QgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIFNvbWUgdjBcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYwIGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgTm9kZXtsOyB2OyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2IGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHQgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfb3B0IHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBOb25lXG4gICAgICB8IE5vZGV7bDsgdjsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gU29tZSB2XG4gICAgICAgICAgZWxzZSBmaW5kX29wdCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHRyeV9qb2luIGwgdiByID1cbiAgICAgICgqIFtqb2luIGwgdiByXSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiAoZWxlbWVudHMgb2YgbCA8IHYgPFxuICAgICAgICAgZWxlbWVudHMgb2Ygcik7IHVzZSBbdHJ5X2pvaW4gbCB2IHJdIHdoZW4gdGhpcyBwcm9wZXJ0eSBtYXlcbiAgICAgICAgIG5vdCBob2xkLCBidXQgeW91IGhvcGUgaXQgZG9lcyBob2xkIGluIHRoZSBjb21tb24gY2FzZSAqKVxuICAgICAgaWYgKGwgPSBFbXB0eSB8fCBPcmQuY29tcGFyZSAobWF4X2VsdCBsKSB2IDwgMClcbiAgICAgICYmIChyID0gRW1wdHkgfHwgT3JkLmNvbXBhcmUgdiAobWluX2VsdCByKSA8IDApXG4gICAgICB0aGVuIGpvaW4gbCB2IHJcbiAgICAgIGVsc2UgdW5pb24gbCAoYWRkIHYgcilcblxuICAgIGxldCByZWMgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBtYXAgZiBsIGluXG4gICAgICAgICBsZXQgdicgPSBmIHYgaW5cbiAgICAgICAgIGxldCByJyA9IG1hcCBmIHIgaW5cbiAgICAgICAgIGlmIGwgPT0gbCcgJiYgdiA9PSB2JyAmJiByID09IHInIHRoZW4gdFxuICAgICAgICAgZWxzZSB0cnlfam9pbiBsJyB2JyByJ1xuXG4gICAgbGV0IHRyeV9jb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPiB0cnlfam9pbiB0MSAobWluX2VsdCB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2Rle2w7IHY7IHJ9IGFzIHQgLT5cbiAgICAgICAgICgqIGVuZm9yY2UgbGVmdC10by1yaWdodCBldmFsdWF0aW9uIG9yZGVyICopXG4gICAgICAgICBsZXQgbCcgPSBmaWx0ZXJfbWFwIGYgbCBpblxuICAgICAgICAgbGV0IHYnID0gZiB2IGluXG4gICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgYmVnaW4gbWF0Y2ggdicgd2l0aFxuICAgICAgICAgICB8IFNvbWUgdicgLT5cbiAgICAgICAgICAgICAgaWYgbCA9PSBsJyAmJiB2ID09IHYnICYmIHIgPT0gcicgdGhlbiB0XG4gICAgICAgICAgICAgIGVsc2UgdHJ5X2pvaW4gbCcgdicgcidcbiAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIHRyeV9jb25jYXQgbCcgcidcbiAgICAgICAgIGVuZFxuXG4gICAgbGV0IG9mX3NvcnRlZF9saXN0IGwgPVxuICAgICAgbGV0IHJlYyBzdWIgbiBsID1cbiAgICAgICAgbWF0Y2ggbiwgbCB3aXRoXG4gICAgICAgIHwgMCwgbCAtPiBFbXB0eSwgbFxuICAgICAgICB8IDEsIHgwIDo6IGwgLT4gTm9kZSB7bD1FbXB0eTsgdj14MDsgcj1FbXB0eTsgaD0xfSwgbFxuICAgICAgICB8IDIsIHgwIDo6IHgxIDo6IGwgLT5cbiAgICAgICAgICAgIE5vZGV7bD1Ob2Rle2w9RW1wdHk7IHY9eDA7IHI9RW1wdHk7IGg9MX07IHY9eDE7IHI9RW1wdHk7IGg9Mn0sIGxcbiAgICAgICAgfCAzLCB4MCA6OiB4MSA6OiB4MiA6OiBsIC0+XG4gICAgICAgICAgICBOb2Rle2w9Tm9kZXtsPUVtcHR5OyB2PXgwOyByPUVtcHR5OyBoPTF9OyB2PXgxO1xuICAgICAgICAgICAgICAgICByPU5vZGV7bD1FbXB0eTsgdj14Mjsgcj1FbXB0eTsgaD0xfTsgaD0yfSwgbFxuICAgICAgICB8IG4sIGwgLT5cbiAgICAgICAgICBsZXQgbmwgPSBuIC8gMiBpblxuICAgICAgICAgIGxldCBsZWZ0LCBsID0gc3ViIG5sIGwgaW5cbiAgICAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICAgICB8IFtdIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgbWlkIDo6IGwgLT5cbiAgICAgICAgICAgIGxldCByaWdodCwgbCA9IHN1YiAobiAtIG5sIC0gMSkgbCBpblxuICAgICAgICAgICAgY3JlYXRlIGxlZnQgbWlkIHJpZ2h0LCBsXG4gICAgICBpblxuICAgICAgZnN0IChzdWIgKExpc3QubGVuZ3RoIGwpIGwpXG5cbiAgICBsZXQgb2ZfbGlzdCBsID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXSAtPiBlbXB0eVxuICAgICAgfCBbeDBdIC0+IHNpbmdsZXRvbiB4MFxuICAgICAgfCBbeDA7IHgxXSAtPiBhZGQgeDEgKHNpbmdsZXRvbiB4MClcbiAgICAgIHwgW3gwOyB4MTsgeDJdIC0+IGFkZCB4MiAoYWRkIHgxIChzaW5nbGV0b24geDApKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDNdIC0+IGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKVxuICAgICAgfCBbeDA7IHgxOyB4MjsgeDM7IHg0XSAtPiBhZGQgeDQgKGFkZCB4MyAoYWRkIHgyIChhZGQgeDEgKHNpbmdsZXRvbiB4MCkpKSlcbiAgICAgIHwgXyAtPiBvZl9zb3J0ZWRfbGlzdCAoTGlzdC5zb3J0X3VuaXEgT3JkLmNvbXBhcmUgbClcblxuICAgIGxldCBhZGRfc2VxIGkgbSA9XG4gICAgICBTZXEuZm9sZF9sZWZ0IChmdW4gcyB4IC0+IGFkZCB4IHMpIG0gaVxuXG4gICAgbGV0IG9mX3NlcSBpID0gYWRkX3NlcSBpIGVtcHR5XG5cbiAgICBsZXQgcmVjIHNlcV9vZl9lbnVtXyBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgICB8IEVuZCAtPiBTZXEuTmlsXG4gICAgICB8IE1vcmUgKHgsIHQsIHJlc3QpIC0+IFNlcS5Db25zICh4LCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBjID0gc2VxX29mX2VudW1fIChjb25zX2VudW0gYyBFbmQpXG5cbiAgICBsZXQgdG9fc2VxX2Zyb20gbG93IHMgPVxuICAgICAgbGV0IHJlYyBhdXggbG93IHMgYyA9IG1hdGNoIHMgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGNcbiAgICAgICAgfCBOb2RlIHtsOyByOyB2OyBffSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggT3JkLmNvbXBhcmUgdiBsb3cgd2l0aFxuICAgICAgICAgICAgICB8IDAgLT4gTW9yZSAodiwgciwgYylcbiAgICAgICAgICAgICAgfCBuIHdoZW4gbjwwIC0+IGF1eCBsb3cgciBjXG4gICAgICAgICAgICAgIHwgXyAtPiBhdXggbG93IGwgKE1vcmUgKHYsIHIsIGMpKVxuICAgICAgICAgICAgZW5kXG4gICAgICBpblxuICAgICAgc2VxX29mX2VudW1fIChhdXggbG93IHMgRW5kKVxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuICBlbmRcblxubW9kdWxlIHR5cGUgUyA9XG4gIHNpZ1xuICAgIHR5cGUga2V5XG4gICAgdHlwZSArJ2EgdFxuICAgIHZhbCBlbXB0eTogJ2EgdFxuICAgIHZhbCBpc19lbXB0eTogJ2EgdCAtPiBib29sXG4gICAgdmFsIG1lbTogIGtleSAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgYWRkOiBrZXkgLT4gJ2EgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIHVwZGF0ZToga2V5IC0+ICgnYSBvcHRpb24gLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgc2luZ2xldG9uOiBrZXkgLT4gJ2EgLT4gJ2EgdFxuICAgIHZhbCByZW1vdmU6IGtleSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgbWVyZ2U6XG4gICAgICAgICAgKGtleSAtPiAnYSBvcHRpb24gLT4gJ2Igb3B0aW9uIC0+ICdjIG9wdGlvbikgLT4gJ2EgdCAtPiAnYiB0IC0+ICdjIHRcbiAgICB2YWwgdW5pb246IChrZXkgLT4gJ2EgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBjb21wYXJlOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIGVxdWFsOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgICB2YWwgaXRlcjogKGtleSAtPiAnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBmb3JfYWxsOiAoa2V5IC0+ICdhIC0+IGJvb2wpIC0+ICdhIHQgLT4gYm9vbFxuICAgIHZhbCBleGlzdHM6IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiBib29sXG4gICAgdmFsIGZpbHRlcjogKGtleSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHRcbiAgICB2YWwgZmlsdGVyX21hcDogKGtleSAtPiAnYSAtPiAnYiBvcHRpb24pIC0+ICdhIHQgLT4gJ2IgdFxuICAgIHZhbCBwYXJ0aXRpb246IChrZXkgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0ICogJ2EgdFxuICAgIHZhbCBjYXJkaW5hbDogJ2EgdCAtPiBpbnRcbiAgICB2YWwgYmluZGluZ3M6ICdhIHQgLT4gKGtleSAqICdhKSBsaXN0XG4gICAgdmFsIG1pbl9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWluX2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1heF9iaW5kaW5nOiAnYSB0IC0+IChrZXkgKiAnYSlcbiAgICB2YWwgbWF4X2JpbmRpbmdfb3B0OiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIGNob29zZTogJ2EgdCAtPiAoa2V5ICogJ2EpXG4gICAgdmFsIGNob29zZV9vcHQ6ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgc3BsaXQ6IGtleSAtPiAnYSB0IC0+ICdhIHQgKiAnYSBvcHRpb24gKiAnYSB0XG4gICAgdmFsIGZpbmQ6IGtleSAtPiAnYSB0IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiBrZXkgLT4gJ2EgdCAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9maXJzdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IGtleSAqICdhXG4gICAgdmFsIGZpbmRfZmlyc3Rfb3B0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgICB2YWwgZmluZF9sYXN0OiAoa2V5IC0+IGJvb2wpIC0+ICdhIHQgLT4ga2V5ICogJ2FcbiAgICB2YWwgZmluZF9sYXN0X29wdDogKGtleSAtPiBib29sKSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgb3B0aW9uXG4gICAgdmFsIG1hcDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgICB2YWwgbWFwaTogKGtleSAtPiAnYSAtPiAnYikgLT4gJ2EgdCAtPiAnYiB0XG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfZnJvbSA6IGtleSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdCAtPiAnYSB0XG4gICAgdmFsIG9mX3NlcSA6IChrZXkgKiAnYSkgU2VxLnQgLT4gJ2EgdFxuICBlbmRcblxubW9kdWxlIE1ha2UoT3JkOiBPcmRlcmVkVHlwZSkgPSBzdHJ1Y3RcblxuICAgIHR5cGUga2V5ID0gT3JkLnRcblxuICAgIHR5cGUgJ2EgdCA9XG4gICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUgb2Yge2w6J2EgdDsgdjprZXk7IGQ6J2E7IHI6J2EgdDsgaDppbnR9XG5cbiAgICBsZXQgaGVpZ2h0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gMFxuICAgICAgfCBOb2RlIHtofSAtPiBoXG5cbiAgICBsZXQgY3JlYXRlIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gaGVpZ2h0IGwgYW5kIGhyID0gaGVpZ2h0IHIgaW5cbiAgICAgIE5vZGV7bDsgdj14OyBkOyByOyBoPShpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSl9XG5cbiAgICBsZXQgc2luZ2xldG9uIHggZCA9IE5vZGV7bD1FbXB0eTsgdj14OyBkOyByPUVtcHR5OyBoPTF9XG5cbiAgICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgICAgbGV0IGhsID0gbWF0Y2ggbCB3aXRoIEVtcHR5IC0+IDAgfCBOb2RlIHtofSAtPiBoIGluXG4gICAgICBsZXQgaHIgPSBtYXRjaCByIHdpdGggRW1wdHkgLT4gMCB8IE5vZGUge2h9IC0+IGggaW5cbiAgICAgIGlmIGhsID4gaHIgKyAyIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgfCBOb2Rle2w9bGw7IHY9bHY7IGQ9bGQ7IHI9bHJ9IC0+XG4gICAgICAgICAgICBpZiBoZWlnaHQgbGwgPj0gaGVpZ2h0IGxyIHRoZW5cbiAgICAgICAgICAgICAgY3JlYXRlIGxsIGx2IGxkIChjcmVhdGUgbHIgeCBkIHIpXG4gICAgICAgICAgICBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIG1hdGNoIGxyIHdpdGhcbiAgICAgICAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICAgICAgICB8IE5vZGV7bD1scmw7IHY9bHJ2OyBkPWxyZDsgcj1scnJ9LT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGxsIGx2IGxkIGxybCkgbHJ2IGxyZCAoY3JlYXRlIGxyciB4IGQgcilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2UgaWYgaHIgPiBobCArIDIgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgICBFbXB0eSAtPiBpbnZhbGlkX2FyZyBcIk1hcC5iYWxcIlxuICAgICAgICB8IE5vZGV7bD1ybDsgdj1ydjsgZD1yZDsgcj1ycn0gLT5cbiAgICAgICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmwgdGhlblxuICAgICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgICAgICAgIEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICAgICAgICAgIHwgTm9kZXtsPXJsbDsgdj1ybHY7IGQ9cmxkOyByPXJscn0gLT5cbiAgICAgICAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgeCBkIHJsbCkgcmx2IHJsZCAoY3JlYXRlIHJsciBydiByZCBycilcbiAgICAgICAgICAgIGVuZFxuICAgICAgZW5kIGVsc2VcbiAgICAgICAgTm9kZXtsOyB2PXg7IGQ7IHI7IGg9KGlmIGhsID49IGhyIHRoZW4gaGwgKyAxIGVsc2UgaHIgKyAxKX1cblxuICAgIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvbiBFbXB0eSAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gICAgbGV0IHJlYyBhZGQgeCBkYXRhID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb2Rle2w9RW1wdHk7IHY9eDsgZD1kYXRhOyByPUVtcHR5OyBoPTF9XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IGFzIG0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW5cbiAgICAgICAgICAgIGlmIGQgPT0gZGF0YSB0aGVuIG0gZWxzZSBOb2Rle2w7IHY9eDsgZD1kYXRhOyByOyBofVxuICAgICAgICAgIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gYWRkIHggZGF0YSBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IGFkZCB4IGRhdGEgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgZmluZCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gZFxuICAgICAgICAgIGVsc2UgZmluZCB4IChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKVxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X2F1eCB2IGQgZiBsXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9maXJzdF9hdXggdjAgZDAgZiByXG5cbiAgICBsZXQgcmVjIGZpbmRfZmlyc3QgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfZmlyc3RfYXV4IHYgZCBmIGxcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2ZpcnN0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2ZpcnN0X29wdF9hdXggdjAgZDAgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgU29tZSAodjAsIGQwKVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0X2F1eCB2MCBkMCBmIHJcblxuICAgIGxldCByZWMgZmluZF9maXJzdF9vcHQgZiA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgIGlmIGYgdiB0aGVuXG4gICAgICAgICAgICBmaW5kX2ZpcnN0X29wdF9hdXggdiBkIGYgbFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfZmlyc3Rfb3B0IGYgclxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3RfYXV4IHYwIGQwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdiBkIGYgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmRfbGFzdF9hdXggdjAgZDAgZiBsXG5cbiAgICBsZXQgcmVjIGZpbmRfbGFzdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpZiBmIHYgdGhlblxuICAgICAgICAgICAgZmluZF9sYXN0X2F1eCB2IGQgZiByXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZmluZF9sYXN0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBTb21lICh2MCwgZDApXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0X2F1eCB2MCBkMCBmIGxcblxuICAgIGxldCByZWMgZmluZF9sYXN0X29wdCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgaWYgZiB2IHRoZW5cbiAgICAgICAgICAgIGZpbmRfbGFzdF9vcHRfYXV4IHYgZCBmIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmaW5kX2xhc3Rfb3B0IGYgbFxuXG4gICAgbGV0IHJlYyBmaW5kX29wdCB4ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBOb25lXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZFxuICAgICAgICAgIGVsc2UgZmluZF9vcHQgeCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWVtIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IHJ9IC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBjID0gMCB8fCBtZW0geCAoaWYgYyA8IDAgdGhlbiBsIGVsc2UgcilcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmcgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgTm9kZSB7bD1FbXB0eTsgdjsgZH0gLT4gKHYsIGQpXG4gICAgICB8IE5vZGUge2x9IC0+IG1pbl9iaW5kaW5nIGxcblxuICAgIGxldCByZWMgbWluX2JpbmRpbmdfb3B0ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gTm9uZVxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyB2OyBkfSAtPiBTb21lICh2LCBkKVxuICAgICAgfCBOb2RlIHtsfS0+IG1pbl9iaW5kaW5nX29wdCBsXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICB8IE5vZGUge3Y7IGQ7IHI9RW1wdHl9IC0+ICh2LCBkKVxuICAgICAgfCBOb2RlIHtyfSAtPiBtYXhfYmluZGluZyByXG5cbiAgICBsZXQgcmVjIG1heF9iaW5kaW5nX29wdCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IE5vbmVcbiAgICAgIHwgTm9kZSB7djsgZDsgcj1FbXB0eX0gLT4gU29tZSAodiwgZClcbiAgICAgIHwgTm9kZSB7cn0gLT4gbWF4X2JpbmRpbmdfb3B0IHJcblxuICAgIGxldCByZWMgcmVtb3ZlX21pbl9iaW5kaW5nID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgICAgfCBOb2RlIHtsPUVtcHR5OyByfSAtPiByXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IGJhbCAocmVtb3ZlX21pbl9iaW5kaW5nIGwpIHYgZCByXG5cbiAgICBsZXQgbWVyZ2UgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGJhbCB0MSB4IGQgKHJlbW92ZV9taW5fYmluZGluZyB0MilcblxuICAgIGxldCByZWMgcmVtb3ZlIHggPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IChOb2RlIHtsOyB2OyBkOyByfSBhcyBtKSAtPlxuICAgICAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgeCB2IGluXG4gICAgICAgICAgaWYgYyA9IDAgdGhlbiBtZXJnZSBsIHJcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCBsbCA9IHJlbW92ZSB4IGwgaW4gaWYgbCA9PSBsbCB0aGVuIG0gZWxzZSBiYWwgbGwgdiBkIHJcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsZXQgcnIgPSByZW1vdmUgeCByIGluIGlmIHIgPT0gcnIgdGhlbiBtIGVsc2UgYmFsIGwgdiBkIHJyXG5cbiAgICBsZXQgcmVjIHVwZGF0ZSB4IGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIGJlZ2luIG1hdGNoIGYgTm9uZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5XG4gICAgICAgICAgfCBTb21lIGRhdGEgLT4gTm9kZXtsPUVtcHR5OyB2PXg7IGQ9ZGF0YTsgcj1FbXB0eTsgaD0xfVxuICAgICAgICAgIGVuZFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSBhcyBtIC0+XG4gICAgICAgICAgbGV0IGMgPSBPcmQuY29tcGFyZSB4IHYgaW5cbiAgICAgICAgICBpZiBjID0gMCB0aGVuIGJlZ2luXG4gICAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiBtZXJnZSBsIHJcbiAgICAgICAgICAgIHwgU29tZSBkYXRhIC0+XG4gICAgICAgICAgICAgICAgaWYgZCA9PSBkYXRhIHRoZW4gbSBlbHNlIE5vZGV7bDsgdj14OyBkPWRhdGE7IHI7IGh9XG4gICAgICAgICAgZW5kIGVsc2UgaWYgYyA8IDAgdGhlblxuICAgICAgICAgICAgbGV0IGxsID0gdXBkYXRlIHggZiBsIGluXG4gICAgICAgICAgICBpZiBsID09IGxsIHRoZW4gbSBlbHNlIGJhbCBsbCB2IGQgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCByciA9IHVwZGF0ZSB4IGYgciBpblxuICAgICAgICAgICAgaWYgciA9PSByciB0aGVuIG0gZWxzZSBiYWwgbCB2IGQgcnJcblxuICAgIGxldCByZWMgaXRlciBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKClcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBpdGVyIGYgbDsgZiB2IGQ7IGl0ZXIgZiByXG5cbiAgICBsZXQgcmVjIG1hcCBmID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByOyBofSAtPlxuICAgICAgICAgIGxldCBsJyA9IG1hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBtYXAgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBtYXBpIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPlxuICAgICAgICAgIEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHI7IGh9IC0+XG4gICAgICAgICAgbGV0IGwnID0gbWFwaSBmIGwgaW5cbiAgICAgICAgICBsZXQgZCcgPSBmIHYgZCBpblxuICAgICAgICAgIGxldCByJyA9IG1hcGkgZiByIGluXG4gICAgICAgICAgTm9kZXtsPWwnOyB2OyBkPWQnOyByPXInOyBofVxuXG4gICAgbGV0IHJlYyBmb2xkIGYgbSBhY2N1ID1cbiAgICAgIG1hdGNoIG0gd2l0aFxuICAgICAgICBFbXB0eSAtPiBhY2N1XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+XG4gICAgICAgICAgZm9sZCBmIHIgKGYgdiBkIChmb2xkIGYgbCBhY2N1KSlcblxuICAgIGxldCByZWMgZm9yX2FsbCBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBwIHYgZCAmJiBmb3JfYWxsIHAgbCAmJiBmb3JfYWxsIHAgclxuXG4gICAgbGV0IHJlYyBleGlzdHMgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IGZhbHNlXG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IC0+IHAgdiBkIHx8IGV4aXN0cyBwIGwgfHwgZXhpc3RzIHAgclxuXG4gICAgKCogQmV3YXJlOiB0aG9zZSB0d28gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IHRoZSBhZGRlZCBrIGlzICpzdHJpY3RseSpcbiAgICAgICBzbWFsbGVyIChvciBiaWdnZXIpIHRoYW4gYWxsIHRoZSBwcmVzZW50IGtleXMgaW4gdGhlIHRyZWU7IGl0XG4gICAgICAgZG9lcyBub3QgdGVzdCBmb3IgZXF1YWxpdHkgd2l0aCB0aGUgY3VycmVudCBtaW4gKG9yIG1heCkga2V5LlxuXG4gICAgICAgSW5kZWVkLCB0aGV5IGFyZSBvbmx5IHVzZWQgZHVyaW5nIHRoZSBcImpvaW5cIiBvcGVyYXRpb24gd2hpY2hcbiAgICAgICByZXNwZWN0cyB0aGlzIHByZWNvbmRpdGlvbi5cbiAgICAqKVxuXG4gICAgbGV0IHJlYyBhZGRfbWluX2JpbmRpbmcgayB4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gc2luZ2xldG9uIGsgeFxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICBiYWwgKGFkZF9taW5fYmluZGluZyBrIHggbCkgdiBkIHJcblxuICAgIGxldCByZWMgYWRkX21heF9iaW5kaW5nIGsgeCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IHNpbmdsZXRvbiBrIHhcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgYmFsIGwgdiBkIChhZGRfbWF4X2JpbmRpbmcgayB4IHIpXG5cbiAgICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlXG4gICAgICAgcmVsYXRpdmUgaGVpZ2h0cyBvZiBsIGFuZCByLiAqKVxuXG4gICAgbGV0IHJlYyBqb2luIGwgdiBkIHIgPVxuICAgICAgbWF0Y2ggKGwsIHIpIHdpdGhcbiAgICAgICAgKEVtcHR5LCBfKSAtPiBhZGRfbWluX2JpbmRpbmcgdiBkIHJcbiAgICAgIHwgKF8sIEVtcHR5KSAtPiBhZGRfbWF4X2JpbmRpbmcgdiBkIGxcbiAgICAgIHwgKE5vZGV7bD1sbDsgdj1sdjsgZD1sZDsgcj1scjsgaD1saH0sXG4gICAgICAgICBOb2Rle2w9cmw7IHY9cnY7IGQ9cmQ7IHI9cnI7IGg9cmh9KSAtPlxuICAgICAgICAgIGlmIGxoID4gcmggKyAyIHRoZW4gYmFsIGxsIGx2IGxkIChqb2luIGxyIHYgZCByKSBlbHNlXG4gICAgICAgICAgaWYgcmggPiBsaCArIDIgdGhlbiBiYWwgKGpvaW4gbCB2IGQgcmwpIHJ2IHJkIHJyIGVsc2VcbiAgICAgICAgICBjcmVhdGUgbCB2IGQgclxuXG4gICAgKCogTWVyZ2UgdHdvIHRyZWVzIGwgYW5kIHIgaW50byBvbmUuXG4gICAgICAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICAgIE5vIGFzc3VtcHRpb24gb24gdGhlIGhlaWdodHMgb2YgbCBhbmQgci4gKilcblxuICAgIGxldCBjb25jYXQgdDEgdDIgPVxuICAgICAgbWF0Y2ggKHQxLCB0Mikgd2l0aFxuICAgICAgICAoRW1wdHksIHQpIC0+IHRcbiAgICAgIHwgKHQsIEVtcHR5KSAtPiB0XG4gICAgICB8IChfLCBfKSAtPlxuICAgICAgICAgIGxldCAoeCwgZCkgPSBtaW5fYmluZGluZyB0MiBpblxuICAgICAgICAgIGpvaW4gdDEgeCBkIChyZW1vdmVfbWluX2JpbmRpbmcgdDIpXG5cbiAgICBsZXQgY29uY2F0X29yX2pvaW4gdDEgdiBkIHQyID1cbiAgICAgIG1hdGNoIGQgd2l0aFxuICAgICAgfCBTb21lIGQgLT4gam9pbiB0MSB2IGQgdDJcbiAgICAgIHwgTm9uZSAtPiBjb25jYXQgdDEgdDJcblxuICAgIGxldCByZWMgc3BsaXQgeCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+XG4gICAgICAgICAgKEVtcHR5LCBOb25lLCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHggdiBpblxuICAgICAgICAgIGlmIGMgPSAwIHRoZW4gKGwsIFNvbWUgZCwgcilcbiAgICAgICAgICBlbHNlIGlmIGMgPCAwIHRoZW5cbiAgICAgICAgICAgIGxldCAobGwsIHByZXMsIHJsKSA9IHNwbGl0IHggbCBpbiAobGwsIHByZXMsIGpvaW4gcmwgdiBkIHIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGV0IChsciwgcHJlcywgcnIpID0gc3BsaXQgeCByIGluIChqb2luIGwgdiBkIGxyLCBwcmVzLCBycilcblxuICAgIGxldCByZWMgbWVyZ2UgZiBzMSBzMiA9XG4gICAgICBtYXRjaCAoczEsIHMyKSB3aXRoXG4gICAgICAgIChFbXB0eSwgRW1wdHkpIC0+IEVtcHR5XG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSwgXykgd2hlbiBoMSA+PSBoZWlnaHQgczIgLT5cbiAgICAgICAgICBsZXQgKGwyLCBkMiwgcjIpID0gc3BsaXQgdjEgczIgaW5cbiAgICAgICAgICBjb25jYXRfb3Jfam9pbiAobWVyZ2UgZiBsMSBsMikgdjEgKGYgdjEgKFNvbWUgZDEpIGQyKSAobWVyZ2UgZiByMSByMilcbiAgICAgIHwgKF8sIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjJ9KSAtPlxuICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgIGNvbmNhdF9vcl9qb2luIChtZXJnZSBmIGwxIGwyKSB2MiAoZiB2MiBkMSAoU29tZSBkMikpIChtZXJnZSBmIHIxIHIyKVxuICAgICAgfCBfIC0+XG4gICAgICAgICAgYXNzZXJ0IGZhbHNlXG5cbiAgICBsZXQgcmVjIHVuaW9uIGYgczEgczIgPVxuICAgICAgbWF0Y2ggKHMxLCBzMikgd2l0aFxuICAgICAgfCAoRW1wdHksIHMpIHwgKHMsIEVtcHR5KSAtPiBzXG4gICAgICB8IChOb2RlIHtsPWwxOyB2PXYxOyBkPWQxOyByPXIxOyBoPWgxfSxcbiAgICAgICAgIE5vZGUge2w9bDI7IHY9djI7IGQ9ZDI7IHI9cjI7IGg9aDJ9KSAtPlxuICAgICAgICAgIGlmIGgxID49IGgyIHRoZW5cbiAgICAgICAgICAgIGxldCAobDIsIGQyLCByMikgPSBzcGxpdCB2MSBzMiBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDIgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MSBkMSByXG4gICAgICAgICAgICB8IFNvbWUgZDIgLT4gY29uY2F0X29yX2pvaW4gbCB2MSAoZiB2MSBkMSBkMikgclxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxldCAobDEsIGQxLCByMSkgPSBzcGxpdCB2MiBzMSBpblxuICAgICAgICAgICAgbGV0IGwgPSB1bmlvbiBmIGwxIGwyIGFuZCByID0gdW5pb24gZiByMSByMiBpblxuICAgICAgICAgICAgbWF0Y2ggZDEgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IGpvaW4gbCB2MiBkMiByXG4gICAgICAgICAgICB8IFNvbWUgZDEgLT4gY29uY2F0X29yX2pvaW4gbCB2MiAoZiB2MiBkMSBkMikgclxuXG4gICAgbGV0IHJlYyBmaWx0ZXIgcCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IEVtcHR5XG4gICAgICB8IE5vZGUge2w7IHY7IGQ7IHJ9IGFzIG0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCBsJyA9IGZpbHRlciBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXIgcCByIGluXG4gICAgICAgICAgaWYgcHZkIHRoZW4gaWYgbD09bCcgJiYgcj09cicgdGhlbiBtIGVsc2Ugam9pbiBsJyB2IGQgcidcbiAgICAgICAgICBlbHNlIGNvbmNhdCBsJyByJ1xuXG4gICAgbGV0IHJlYyBmaWx0ZXJfbWFwIGYgPSBmdW5jdGlvblxuICAgICAgICBFbXB0eSAtPiBFbXB0eVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPlxuICAgICAgICAgICgqIGNhbGwgW2ZdIGluIHRoZSBleHBlY3RlZCBsZWZ0LXRvLXJpZ2h0IG9yZGVyICopXG4gICAgICAgICAgbGV0IGwnID0gZmlsdGVyX21hcCBmIGwgaW5cbiAgICAgICAgICBsZXQgZnZkID0gZiB2IGQgaW5cbiAgICAgICAgICBsZXQgcicgPSBmaWx0ZXJfbWFwIGYgciBpblxuICAgICAgICAgIGJlZ2luIG1hdGNoIGZ2ZCB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgZCcgLT4gam9pbiBsJyB2IGQnIHInXG4gICAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0IGwnIHInXG4gICAgICAgICAgZW5kXG5cbiAgICBsZXQgcmVjIHBhcnRpdGlvbiBwID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gKEVtcHR5LCBFbXB0eSlcbiAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcn0gLT5cbiAgICAgICAgICAoKiBjYWxsIFtwXSBpbiB0aGUgZXhwZWN0ZWQgbGVmdC10by1yaWdodCBvcmRlciAqKVxuICAgICAgICAgIGxldCAobHQsIGxmKSA9IHBhcnRpdGlvbiBwIGwgaW5cbiAgICAgICAgICBsZXQgcHZkID0gcCB2IGQgaW5cbiAgICAgICAgICBsZXQgKHJ0LCByZikgPSBwYXJ0aXRpb24gcCByIGluXG4gICAgICAgICAgaWYgcHZkXG4gICAgICAgICAgdGhlbiAoam9pbiBsdCB2IGQgcnQsIGNvbmNhdCBsZiByZilcbiAgICAgICAgICBlbHNlIChjb25jYXQgbHQgcnQsIGpvaW4gbGYgdiBkIHJmKVxuXG4gICAgdHlwZSAnYSBlbnVtZXJhdGlvbiA9IEVuZCB8IE1vcmUgb2Yga2V5ICogJ2EgKiAnYSB0ICogJ2EgZW51bWVyYXRpb25cblxuICAgIGxldCByZWMgY29uc19lbnVtIG0gZSA9XG4gICAgICBtYXRjaCBtIHdpdGhcbiAgICAgICAgRW1wdHkgLT4gZVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBjb25zX2VudW0gbCAoTW9yZSh2LCBkLCByLCBlKSlcblxuICAgIGxldCBjb21wYXJlIGNtcCBtMSBtMiA9XG4gICAgICBsZXQgcmVjIGNvbXBhcmVfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiAwXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IC0xXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gMVxuICAgICAgICB8IChNb3JlKHYxLCBkMSwgcjEsIGUxKSwgTW9yZSh2MiwgZDIsIHIyLCBlMikpIC0+XG4gICAgICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHYxIHYyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGxldCBjID0gY21wIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmVfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBjb21wYXJlX2F1eCAoY29uc19lbnVtIG0xIEVuZCkgKGNvbnNfZW51bSBtMiBFbmQpXG5cbiAgICBsZXQgZXF1YWwgY21wIG0xIG0yID1cbiAgICAgIGxldCByZWMgZXF1YWxfYXV4IGUxIGUyID1cbiAgICAgICAgICBtYXRjaCAoZTEsIGUyKSB3aXRoXG4gICAgICAgICAgKEVuZCwgRW5kKSAtPiB0cnVlXG4gICAgICAgIHwgKEVuZCwgXykgIC0+IGZhbHNlXG4gICAgICAgIHwgKF8sIEVuZCkgLT4gZmFsc2VcbiAgICAgICAgfCAoTW9yZSh2MSwgZDEsIHIxLCBlMSksIE1vcmUodjIsIGQyLCByMiwgZTIpKSAtPlxuICAgICAgICAgICAgT3JkLmNvbXBhcmUgdjEgdjIgPSAwICYmIGNtcCBkMSBkMiAmJlxuICAgICAgICAgICAgZXF1YWxfYXV4IChjb25zX2VudW0gcjEgZTEpIChjb25zX2VudW0gcjIgZTIpXG4gICAgICBpbiBlcXVhbF9hdXggKGNvbnNfZW51bSBtMSBFbmQpIChjb25zX2VudW0gbTIgRW5kKVxuXG4gICAgbGV0IHJlYyBjYXJkaW5hbCA9IGZ1bmN0aW9uXG4gICAgICAgIEVtcHR5IC0+IDBcbiAgICAgIHwgTm9kZSB7bDsgcn0gLT4gY2FyZGluYWwgbCArIDEgKyBjYXJkaW5hbCByXG5cbiAgICBsZXQgcmVjIGJpbmRpbmdzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICAgICAgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBOb2RlIHtsOyB2OyBkOyByfSAtPiBiaW5kaW5nc19hdXggKCh2LCBkKSA6OiBiaW5kaW5nc19hdXggYWNjdSByKSBsXG5cbiAgICBsZXQgYmluZGluZ3MgcyA9XG4gICAgICBiaW5kaW5nc19hdXggW10gc1xuXG4gICAgbGV0IGNob29zZSA9IG1pbl9iaW5kaW5nXG5cbiAgICBsZXQgY2hvb3NlX29wdCA9IG1pbl9iaW5kaW5nX29wdFxuXG4gICAgbGV0IGFkZF9zZXEgaSBtID1cbiAgICAgIFNlcS5mb2xkX2xlZnQgKGZ1biBtIChrLHYpIC0+IGFkZCBrIHYgbSkgbSBpXG5cbiAgICBsZXQgb2Zfc2VxIGkgPSBhZGRfc2VxIGkgZW1wdHlcblxuICAgIGxldCByZWMgc2VxX29mX2VudW1fIGMgKCkgPSBtYXRjaCBjIHdpdGhcbiAgICAgIHwgRW5kIC0+IFNlcS5OaWxcbiAgICAgIHwgTW9yZSAoayx2LHQscmVzdCkgLT4gU2VxLkNvbnMgKChrLHYpLCBzZXFfb2ZfZW51bV8gKGNvbnNfZW51bSB0IHJlc3QpKVxuXG4gICAgbGV0IHRvX3NlcSBtID1cbiAgICAgIHNlcV9vZl9lbnVtXyAoY29uc19lbnVtIG0gRW5kKVxuXG4gICAgbGV0IHRvX3NlcV9mcm9tIGxvdyBtID1cbiAgICAgIGxldCByZWMgYXV4IGxvdyBtIGMgPSBtYXRjaCBtIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBjXG4gICAgICAgIHwgTm9kZSB7bDsgdjsgZDsgcjsgX30gLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIE9yZC5jb21wYXJlIHYgbG93IHdpdGhcbiAgICAgICAgICAgICAgfCAwIC0+IE1vcmUgKHYsIGQsIHIsIGMpXG4gICAgICAgICAgICAgIHwgbiB3aGVuIG48MCAtPiBhdXggbG93IHIgY1xuICAgICAgICAgICAgICB8IF8gLT4gYXV4IGxvdyBsIChNb3JlICh2LCBkLCByLCBjKSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNlcV9vZl9lbnVtXyAoYXV4IGxvdyBtIEVuZClcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlICdhIHQgPSB7IG11dGFibGUgYyA6ICdhIGxpc3Q7IG11dGFibGUgbGVuIDogaW50OyB9XG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG5sZXQgY3JlYXRlICgpID0geyBjID0gW107IGxlbiA9IDA7IH1cblxubGV0IGNsZWFyIHMgPSBzLmMgPC0gW107IHMubGVuIDwtIDBcblxubGV0IGNvcHkgcyA9IHsgYyA9IHMuYzsgbGVuID0gcy5sZW47IH1cblxubGV0IHB1c2ggeCBzID0gcy5jIDwtIHggOjogcy5jOyBzLmxlbiA8LSBzLmxlbiArIDFcblxubGV0IHBvcCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6dGwgLT4gcy5jIDwtIHRsOyBzLmxlbiA8LSBzLmxlbiAtIDE7IGhkXG4gIHwgW10gICAgIC0+IHJhaXNlIEVtcHR5XG5cbmxldCBwb3Bfb3B0IHMgPVxuICBtYXRjaCBzLmMgd2l0aFxuICB8IGhkOjp0bCAtPiBzLmMgPC0gdGw7IHMubGVuIDwtIHMubGVuIC0gMTsgU29tZSBoZFxuICB8IFtdICAgICAtPiBOb25lXG5cbmxldCB0b3AgcyA9XG4gIG1hdGNoIHMuYyB3aXRoXG4gIHwgaGQ6Ol8gLT4gaGRcbiAgfCBbXSAgICAtPiByYWlzZSBFbXB0eVxuXG5sZXQgdG9wX29wdCBzID1cbiAgbWF0Y2ggcy5jIHdpdGhcbiAgfCBoZDo6XyAtPiBTb21lIGhkXG4gIHwgW10gICAgLT4gTm9uZVxuXG5sZXQgaXNfZW1wdHkgcyA9IChzLmMgPSBbXSlcblxubGV0IGxlbmd0aCBzID0gcy5sZW5cblxubGV0IGl0ZXIgZiBzID0gTGlzdC5pdGVyIGYgcy5jXG5cbmxldCBmb2xkIGYgYWNjIHMgPSBMaXN0LmZvbGRfbGVmdCBmIGFjYyBzLmNcblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBzID0gTGlzdC50b19zZXEgcy5jXG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcyA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcyBnO1xuICBzXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIEZyYW5jb2lzIFBvdHRpZXIsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgIEplcmVtaWUgRGltaW5vLCBKYW5lIFN0cmVldCBFdXJvcGUgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAyIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIGNlbGwgPVxuICB8IE5pbFxuICB8IENvbnMgb2YgeyBjb250ZW50OiAnYTsgbXV0YWJsZSBuZXh0OiAnYSBjZWxsIH1cblxudHlwZSAnYSB0ID0ge1xuICBtdXRhYmxlIGxlbmd0aDogaW50O1xuICBtdXRhYmxlIGZpcnN0OiAnYSBjZWxsO1xuICBtdXRhYmxlIGxhc3Q6ICdhIGNlbGxcbn1cblxubGV0IGNyZWF0ZSAoKSA9IHtcbiAgbGVuZ3RoID0gMDtcbiAgZmlyc3QgPSBOaWw7XG4gIGxhc3QgPSBOaWxcbn1cblxubGV0IGNsZWFyIHEgPVxuICBxLmxlbmd0aCA8LSAwO1xuICBxLmZpcnN0IDwtIE5pbDtcbiAgcS5sYXN0IDwtIE5pbFxuXG5sZXQgYWRkIHggcSA9XG4gIGxldCBjZWxsID0gQ29ucyB7XG4gICAgY29udGVudCA9IHg7XG4gICAgbmV4dCA9IE5pbFxuICB9IGluXG4gIG1hdGNoIHEubGFzdCB3aXRoXG4gIHwgTmlsIC0+XG4gICAgcS5sZW5ndGggPC0gMTtcbiAgICBxLmZpcnN0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcbiAgfCBDb25zIGxhc3QgLT5cbiAgICBxLmxlbmd0aCA8LSBxLmxlbmd0aCArIDE7XG4gICAgbGFzdC5uZXh0IDwtIGNlbGw7XG4gICAgcS5sYXN0IDwtIGNlbGxcblxubGV0IHB1c2ggPVxuICBhZGRcblxubGV0IHBlZWsgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50IH0gLT4gY29udGVudFxuXG5sZXQgcGVla19vcHQgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiBOb25lXG4gIHwgQ29ucyB7IGNvbnRlbnQgfSAtPiBTb21lIGNvbnRlbnRcblxubGV0IHRvcCA9XG4gIHBlZWtcblxubGV0IHRha2UgcSA9XG4gIG1hdGNoIHEuZmlyc3Qgd2l0aFxuICB8IE5pbCAtPiByYWlzZSBFbXB0eVxuICB8IENvbnMgeyBjb250ZW50OyBuZXh0ID0gTmlsIH0gLT5cbiAgICBjbGVhciBxO1xuICAgIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBjb250ZW50XG5cbmxldCB0YWtlX29wdCBxID1cbiAgbWF0Y2ggcS5maXJzdCB3aXRoXG4gIHwgTmlsIC0+IE5vbmVcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCA9IE5pbCB9IC0+XG4gICAgY2xlYXIgcTtcbiAgICBTb21lIGNvbnRlbnRcbiAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgcS5sZW5ndGggPC0gcS5sZW5ndGggLSAxO1xuICAgIHEuZmlyc3QgPC0gbmV4dDtcbiAgICBTb21lIGNvbnRlbnRcblxubGV0IHBvcCA9XG4gIHRha2VcblxubGV0IGNvcHkgPVxuICBsZXQgcmVjIGNvcHkgcV9yZXMgcHJldiBjZWxsID1cbiAgICBtYXRjaCBjZWxsIHdpdGhcbiAgICB8IE5pbCAtPiBxX3Jlcy5sYXN0IDwtIHByZXY7IHFfcmVzXG4gICAgfCBDb25zIHsgY29udGVudDsgbmV4dCB9IC0+XG4gICAgICBsZXQgcmVzID0gQ29ucyB7IGNvbnRlbnQ7IG5leHQgPSBOaWwgfSBpblxuICAgICAgYmVnaW4gbWF0Y2ggcHJldiB3aXRoXG4gICAgICB8IE5pbCAtPiBxX3Jlcy5maXJzdCA8LSByZXNcbiAgICAgIHwgQ29ucyBwIC0+IHAubmV4dCA8LSByZXNcbiAgICAgIGVuZDtcbiAgICAgIGNvcHkgcV9yZXMgcmVzIG5leHRcbiAgaW5cbiAgZnVuIHEgLT4gY29weSB7IGxlbmd0aCA9IHEubGVuZ3RoOyBmaXJzdCA9IE5pbDsgbGFzdCA9IE5pbCB9IE5pbCBxLmZpcnN0XG5cbmxldCBpc19lbXB0eSBxID1cbiAgcS5sZW5ndGggPSAwXG5cbmxldCBsZW5ndGggcSA9XG4gIHEubGVuZ3RoXG5cbmxldCBpdGVyID1cbiAgbGV0IHJlYyBpdGVyIGYgY2VsbCA9XG4gICAgbWF0Y2ggY2VsbCB3aXRoXG4gICAgfCBOaWwgLT4gKClcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGYgY29udGVudDtcbiAgICAgIGl0ZXIgZiBuZXh0XG4gIGluXG4gIGZ1biBmIHEgLT4gaXRlciBmIHEuZmlyc3RcblxubGV0IGZvbGQgPVxuICBsZXQgcmVjIGZvbGQgZiBhY2N1IGNlbGwgPVxuICAgIG1hdGNoIGNlbGwgd2l0aFxuICAgIHwgTmlsIC0+IGFjY3VcbiAgICB8IENvbnMgeyBjb250ZW50OyBuZXh0IH0gLT5cbiAgICAgIGxldCBhY2N1ID0gZiBhY2N1IGNvbnRlbnQgaW5cbiAgICAgIGZvbGQgZiBhY2N1IG5leHRcbiAgaW5cbiAgZnVuIGYgYWNjdSBxIC0+IGZvbGQgZiBhY2N1IHEuZmlyc3RcblxubGV0IHRyYW5zZmVyIHExIHEyID1cbiAgaWYgcTEubGVuZ3RoID4gMCB0aGVuXG4gICAgbWF0Y2ggcTIubGFzdCB3aXRoXG4gICAgfCBOaWwgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMS5sZW5ndGg7XG4gICAgICBxMi5maXJzdCA8LSBxMS5maXJzdDtcbiAgICAgIHEyLmxhc3QgPC0gcTEubGFzdDtcbiAgICAgIGNsZWFyIHExXG4gICAgfCBDb25zIGxhc3QgLT5cbiAgICAgIHEyLmxlbmd0aCA8LSBxMi5sZW5ndGggKyBxMS5sZW5ndGg7XG4gICAgICBsYXN0Lm5leHQgPC0gcTEuZmlyc3Q7XG4gICAgICBxMi5sYXN0IDwtIHExLmxhc3Q7XG4gICAgICBjbGVhciBxMVxuXG4oKiogezEgSXRlcmF0b3JzfSAqKVxuXG5sZXQgdG9fc2VxIHEgPVxuICBsZXQgcmVjIGF1eCBjICgpID0gbWF0Y2ggYyB3aXRoXG4gICAgfCBOaWwgLT4gU2VxLk5pbFxuICAgIHwgQ29ucyB7IGNvbnRlbnQ9eDsgbmV4dDsgfSAtPiBTZXEuQ29ucyAoeCwgYXV4IG5leHQpXG4gIGluXG4gIGF1eCBxLmZpcnN0XG5cbmxldCBhZGRfc2VxIHEgaSA9IFNlcS5pdGVyIChmdW4geCAtPiBwdXNoIHggcSkgaVxuXG5sZXQgb2Zfc2VxIGcgPVxuICBsZXQgcSA9IGNyZWF0ZSgpIGluXG4gIGFkZF9zZXEgcSBnO1xuICBxXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEludGVybmFscyBvZiBmb3JjaW5nIGxhenkgdmFsdWVzLiAqKVxuXG50eXBlICdhIHQgPSAnYSBsYXp5X3RcblxuZXhjZXB0aW9uIFVuZGVmaW5lZFxuXG5sZXQgcmFpc2VfdW5kZWZpbmVkID0gT2JqLnJlcHIgKGZ1biAoKSAtPiByYWlzZSBVbmRlZmluZWQpXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6IE9iai50IC0+IE9iai50IC0+IHVuaXQgPSBcImNhbWxfb2JqX21ha2VfZm9yd2FyZFwiXG5cbigqIEFzc3VtZSBbYmxrXSBpcyBhIGJsb2NrIHdpdGggdGFnIGxhenkgKilcbmxldCBmb3JjZV9sYXp5X2Jsb2NrIChibGsgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgY2xvc3VyZSA9IChPYmoub2JqIChPYmouZmllbGQgKE9iai5yZXByIGJsaykgMCkgOiB1bml0IC0+ICdhcmcpIGluXG4gIE9iai5zZXRfZmllbGQgKE9iai5yZXByIGJsaykgMCByYWlzZV91bmRlZmluZWQ7XG4gIHRyeVxuICAgIGxldCByZXN1bHQgPSBjbG9zdXJlICgpIGluXG4gICAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICAgIHJlc3VsdFxuICB3aXRoIGUgLT5cbiAgICBPYmouc2V0X2ZpZWxkIChPYmoucmVwciBibGspIDAgKE9iai5yZXByIChmdW4gKCkgLT4gcmFpc2UgZSkpO1xuICAgIHJhaXNlIGVcblxuXG4oKiBBc3N1bWUgW2Jsa10gaXMgYSBibG9jayB3aXRoIHRhZyBsYXp5ICopXG5sZXQgZm9yY2VfdmFsX2xhenlfYmxvY2sgKGJsayA6ICdhcmcgbGF6eV90KSA9XG4gIGxldCBjbG9zdXJlID0gKE9iai5vYmogKE9iai5maWVsZCAoT2JqLnJlcHIgYmxrKSAwKSA6IHVuaXQgLT4gJ2FyZykgaW5cbiAgT2JqLnNldF9maWVsZCAoT2JqLnJlcHIgYmxrKSAwIHJhaXNlX3VuZGVmaW5lZDtcbiAgbGV0IHJlc3VsdCA9IGNsb3N1cmUgKCkgaW5cbiAgbWFrZV9mb3J3YXJkIChPYmoucmVwciBibGspIChPYmoucmVwciByZXN1bHQpO1xuICByZXN1bHRcblxuXG4oKiBbZm9yY2VdIGlzIG5vdCB1c2VkLCBzaW5jZSBbTGF6eS5mb3JjZV0gaXMgZGVjbGFyZWQgYXMgYSBwcmltaXRpdmVcbiAgIHdob3NlIGNvZGUgaW5saW5lcyB0aGUgdGFnIHRlc3RzIG9mIGl0cyBhcmd1bWVudC4gIFRoaXMgZnVuY3Rpb24gaXNcbiAgIGhlcmUgZm9yIHRoZSBzYWtlIG9mIGNvbXBsZXRlbmVzcywgYW5kIGZvciBkZWJ1Z2dpbmcgcHVycG9zZS4gKilcblxubGV0IGZvcmNlIChsenYgOiAnYXJnIGxhenlfdCkgPVxuICBsZXQgeCA9IE9iai5yZXByIGx6diBpblxuICBsZXQgdCA9IE9iai50YWcgeCBpblxuICBpZiB0ID0gT2JqLmZvcndhcmRfdGFnIHRoZW4gKE9iai5vYmogKE9iai5maWVsZCB4IDApIDogJ2FyZykgZWxzZVxuICBpZiB0IDw+IE9iai5sYXp5X3RhZyB0aGVuIChPYmoub2JqIHggOiAnYXJnKVxuICBlbHNlIGZvcmNlX2xhenlfYmxvY2sgbHp2XG5cblxubGV0IGZvcmNlX3ZhbCAobHp2IDogJ2FyZyBsYXp5X3QpID1cbiAgbGV0IHggPSBPYmoucmVwciBsenYgaW5cbiAgbGV0IHQgPSBPYmoudGFnIHggaW5cbiAgaWYgdCA9IE9iai5mb3J3YXJkX3RhZyB0aGVuIChPYmoub2JqIChPYmouZmllbGQgeCAwKSA6ICdhcmcpIGVsc2VcbiAgaWYgdCA8PiBPYmoubGF6eV90YWcgdGhlbiAoT2JqLm9iaiB4IDogJ2FyZylcbiAgZWxzZSBmb3JjZV92YWxfbGF6eV9ibG9jayBsenZcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kdWxlIFtMYXp5XTogZGVmZXJyZWQgY29tcHV0YXRpb25zICopXG5cblxuKCpcbiAgIFdBUk5JTkc6IHNvbWUgcHVycGxlIG1hZ2ljIGlzIGdvaW5nIG9uIGhlcmUuICBEbyBub3QgdGFrZSB0aGlzIGZpbGVcbiAgIGFzIGFuIGV4YW1wbGUgb2YgaG93IHRvIHByb2dyYW0gaW4gT0NhbWwuXG4qKVxuXG5cbigqIFdlIG1ha2UgdXNlIG9mIHR3byBzcGVjaWFsIHRhZ3MgcHJvdmlkZWQgYnkgdGhlIHJ1bnRpbWU6XG4gICBbbGF6eV90YWddIGFuZCBbZm9yd2FyZF90YWddLlxuXG4gICBBIHZhbHVlIG9mIHR5cGUgWydhIExhenkudF0gY2FuIGJlIG9uZSBvZiB0aHJlZSB0aGluZ3M6XG4gICAxLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbbGF6eV90YWddLiAgSXRzIGZpZWxkIGlzIGEgY2xvc3VyZSBvZlxuICAgICAgdHlwZSBbdW5pdCAtPiAnYV0gdGhhdCBjb21wdXRlcyB0aGUgdmFsdWUuXG4gICAyLiBBIGJsb2NrIG9mIHNpemUgMSB3aXRoIHRhZyBbZm9yd2FyZF90YWddLiAgSXRzIGZpZWxkIGlzIHRoZSB2YWx1ZVxuICAgICAgb2YgdHlwZSBbJ2FdIHRoYXQgd2FzIGNvbXB1dGVkLlxuICAgMy4gQW55dGhpbmcgZWxzZSBleGNlcHQgYSBmbG9hdC4gIFRoaXMgaGFzIHR5cGUgWydhXSBhbmQgaXMgdGhlIHZhbHVlXG4gICAgICB0aGF0IHdhcyBjb21wdXRlZC5cbiAgIEV4Y2VwdGlvbnMgYXJlIHN0b3JlZCBpbiBmb3JtYXQgKDEpLlxuICAgVGhlIEdDIHdpbGwgbWFnaWNhbGx5IGNoYW5nZSB0aGluZ3MgZnJvbSAoMikgdG8gKDMpIGFjY29yZGluZyB0byBpdHNcbiAgIGZhbmN5LlxuXG4gICBJZiBPQ2FtbCB3YXMgY29uZmlndXJlZCB3aXRoIHRoZSAtZmxhdC1mbG9hdC1hcnJheSBvcHRpb24gKHdoaWNoIGlzXG4gICBjdXJyZW50bHkgdGhlIGRlZmF1bHQpLCB0aGUgZm9sbG93aW5nIGlzIGFsc28gdHJ1ZTpcbiAgIFdlIGNhbm5vdCB1c2UgcmVwcmVzZW50YXRpb24gKDMpIGZvciBhIFtmbG9hdCBMYXp5LnRdIGJlY2F1c2VcbiAgIFtjYW1sX21ha2VfYXJyYXldIGFzc3VtZXMgdGhhdCBvbmx5IGEgW2Zsb2F0XSB2YWx1ZSBjYW4gaGF2ZSB0YWdcbiAgIFtEb3VibGVfdGFnXS5cblxuICAgV2UgaGF2ZSB0byB1c2UgdGhlIGJ1aWx0LWluIHR5cGUgY29uc3RydWN0b3IgW2xhenlfdF0gdG9cbiAgIGxldCB0aGUgY29tcGlsZXIgaW1wbGVtZW50IHRoZSBzcGVjaWFsIHR5cGluZyBhbmQgY29tcGlsYXRpb25cbiAgIHJ1bGVzIGZvciB0aGUgW2xhenldIGtleXdvcmQuXG4qKVxuXG50eXBlICdhIHQgPSAnYSBDYW1saW50ZXJuYWxMYXp5LnRcblxuZXhjZXB0aW9uIFVuZGVmaW5lZCA9IENhbWxpbnRlcm5hbExhenkuVW5kZWZpbmVkXG5cbmV4dGVybmFsIG1ha2VfZm9yd2FyZCA6ICdhIC0+ICdhIGxhenlfdCA9IFwiY2FtbF9sYXp5X21ha2VfZm9yd2FyZFwiXG5cbmV4dGVybmFsIGZvcmNlIDogJ2EgdCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuXG4oKiBsZXQgZm9yY2UgPSBmb3JjZSAqKVxuXG5sZXQgZm9yY2VfdmFsID0gQ2FtbGludGVybmFsTGF6eS5mb3JjZV92YWxcblxubGV0IGZyb21fZnVuIChmIDogdW5pdCAtPiAnYXJnKSA9XG4gIGxldCB4ID0gT2JqLm5ld19ibG9jayBPYmoubGF6eV90YWcgMSBpblxuICBPYmouc2V0X2ZpZWxkIHggMCAoT2JqLnJlcHIgZik7XG4gIChPYmoub2JqIHggOiAnYXJnIHQpXG5cblxubGV0IGZyb21fdmFsICh2IDogJ2FyZykgPVxuICBsZXQgdCA9IE9iai50YWcgKE9iai5yZXByIHYpIGluXG4gIGlmIHQgPSBPYmouZm9yd2FyZF90YWcgfHwgdCA9IE9iai5sYXp5X3RhZyB8fCB0ID0gT2JqLmRvdWJsZV90YWcgdGhlbiBiZWdpblxuICAgIG1ha2VfZm9yd2FyZCB2XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgKE9iai5tYWdpYyB2IDogJ2FyZyB0KVxuICBlbmRcblxuXG5sZXQgaXNfdmFsIChsIDogJ2FyZyB0KSA9IE9iai50YWcgKE9iai5yZXByIGwpIDw+IE9iai5sYXp5X3RhZ1xuXG5sZXQgbGF6eV9mcm9tX2Z1biA9IGZyb21fZnVuXG5cbmxldCBsYXp5X2Zyb21fdmFsID0gZnJvbV92YWxcblxubGV0IGxhenlfaXNfdmFsID0gaXNfdmFsXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgIERhbmllbCBkZSBSYXVnbGF1ZHJlLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgJ2EgdCA9ICdhIGNlbGwgb3B0aW9uXG5hbmQgJ2EgY2VsbCA9IHsgbXV0YWJsZSBjb3VudCA6IGludDsgbXV0YWJsZSBkYXRhIDogJ2EgZGF0YSB9XG5hbmQgJ2EgZGF0YSA9XG4gICAgU2VtcHR5XG4gIHwgU2NvbnMgb2YgJ2EgKiAnYSBkYXRhXG4gIHwgU2FwcCBvZiAnYSBkYXRhICogJ2EgZGF0YVxuICB8IFNsYXp5IG9mICdhIGRhdGEgTGF6eS50XG4gIHwgU2dlbiBvZiAnYSBnZW5cbiAgfCBTYnVmZmlvIDogYnVmZmlvIC0+IGNoYXIgZGF0YVxuYW5kICdhIGdlbiA9IHsgbXV0YWJsZSBjdXJyIDogJ2Egb3B0aW9uIG9wdGlvbjsgZnVuYyA6IGludCAtPiAnYSBvcHRpb24gfVxuYW5kIGJ1ZmZpbyA9XG4gIHsgaWMgOiBpbl9jaGFubmVsOyBidWZmIDogYnl0ZXM7IG11dGFibGUgbGVuIDogaW50OyBtdXRhYmxlIGluZCA6IGludCB9XG5cbmV4Y2VwdGlvbiBGYWlsdXJlXG5leGNlcHRpb24gRXJyb3Igb2Ygc3RyaW5nXG5cbmxldCBjb3VudCA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSB7IGNvdW50IH0gLT4gY291bnRcbmxldCBkYXRhID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFNlbXB0eVxuICB8IFNvbWUgeyBkYXRhIH0gLT4gZGF0YVxuXG5sZXQgZmlsbF9idWZmIGIgPVxuICBiLmxlbiA8LSBpbnB1dCBiLmljIGIuYnVmZiAwIChCeXRlcy5sZW5ndGggYi5idWZmKTsgYi5pbmQgPC0gMFxuXG5cbmxldCByZWMgZ2V0X2RhdGEgOiB0eXBlIHYuIGludCAtPiB2IGRhdGEgLT4gdiBkYXRhID0gZnVuIGNvdW50IGQgLT4gbWF0Y2ggZCB3aXRoXG4gKCogUmV0dXJucyBlaXRoZXIgU2VtcHR5IG9yIFNjb25zKGEsIF8pIGV2ZW4gd2hlbiBkIGlzIGEgZ2VuZXJhdG9yXG4gICAgb3IgYSBidWZmZXIuIEluIHRob3NlIGNhc2VzLCB0aGUgaXRlbSBhIGlzIHNlZW4gYXMgZXh0cmFjdGVkIGZyb21cbiB0aGUgZ2VuZXJhdG9yL2J1ZmZlci5cbiBUaGUgY291bnQgcGFyYW1ldGVyIGlzIHVzZWQgZm9yIGNhbGxpbmcgYFNnZW4tZnVuY3Rpb25zJy4gICopXG4gICBTZW1wdHkgfCBTY29ucyAoXywgXykgLT4gZFxuIHwgU2FwcCAoZDEsIGQyKSAtPlxuICAgICBiZWdpbiBtYXRjaCBnZXRfZGF0YSBjb3VudCBkMSB3aXRoXG4gICAgICAgU2NvbnMgKGEsIGQxMSkgLT4gU2NvbnMgKGEsIFNhcHAgKGQxMSwgZDIpKVxuICAgICB8IFNlbXB0eSAtPiBnZXRfZGF0YSBjb3VudCBkMlxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2dlbiB7Y3VyciA9IFNvbWUgTm9uZX0gLT4gU2VtcHR5XG4gfCBTZ2VuICh7Y3VyciA9IFNvbWUoU29tZSBhKX0gYXMgZykgLT5cbiAgICAgZy5jdXJyIDwtIE5vbmU7IFNjb25zKGEsIGQpXG4gfCBTZ2VuIGcgLT5cbiAgICAgYmVnaW4gbWF0Y2ggZy5mdW5jIGNvdW50IHdpdGhcbiAgICAgICBOb25lIC0+IGcuY3VyciA8LSBTb21lKE5vbmUpOyBTZW1wdHlcbiAgICAgfCBTb21lIGEgLT4gU2NvbnMoYSwgZClcbiAgICAgICAgICgqIFdhcm5pbmc6IGFueW9uZSB1c2luZyBnIHRoaW5rcyB0aGF0IGFuIGl0ZW0gaGFzIGJlZW4gcmVhZCAqKVxuICAgICBlbmRcbiB8IFNidWZmaW8gYiAtPlxuICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICBpZiBiLmxlbiA9PSAwIHRoZW4gU2VtcHR5IGVsc2VcbiAgICAgICBsZXQgciA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmIGIuaW5kIGluXG4gICAgICAgKCogV2FybmluZzogYW55b25lIHVzaW5nIGcgdGhpbmtzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZWFkICopXG4gICAgICAgYi5pbmQgPC0gc3VjYyBiLmluZDsgU2NvbnMociwgZClcbiB8IFNsYXp5IGYgLT4gZ2V0X2RhdGEgY291bnQgKExhenkuZm9yY2UgZilcblxuXG5sZXQgcmVjIHBlZWtfZGF0YSA6IHR5cGUgdi4gdiBjZWxsIC0+IHYgb3B0aW9uID0gZnVuIHMgLT5cbiAoKiBjb25zdWx0IHRoZSBmaXJzdCBpdGVtIG9mIHMgKilcbiBtYXRjaCBzLmRhdGEgd2l0aFxuICAgU2VtcHR5IC0+IE5vbmVcbiB8IFNjb25zIChhLCBfKSAtPiBTb21lIGFcbiB8IFNhcHAgKF8sIF8pIC0+XG4gICAgIGJlZ2luIG1hdGNoIGdldF9kYXRhIHMuY291bnQgcy5kYXRhIHdpdGhcbiAgICAgICBTY29ucyhhLCBfKSBhcyBkIC0+IHMuZGF0YSA8LSBkOyBTb21lIGFcbiAgICAgfCBTZW1wdHkgLT4gTm9uZVxuICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgIGVuZFxuIHwgU2xhenkgZiAtPiBzLmRhdGEgPC0gKExhenkuZm9yY2UgZik7IHBlZWtfZGF0YSBzXG4gfCBTZ2VuIHtjdXJyID0gU29tZSBhfSAtPiBhXG4gfCBTZ2VuIGcgLT4gbGV0IHggPSBnLmZ1bmMgcy5jb3VudCBpbiBnLmN1cnIgPC0gU29tZSB4OyB4XG4gfCBTYnVmZmlvIGIgLT5cbiAgICAgaWYgYi5pbmQgPj0gYi5sZW4gdGhlbiBmaWxsX2J1ZmYgYjtcbiAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIGJlZ2luIHMuZGF0YSA8LSBTZW1wdHk7IE5vbmUgZW5kXG4gICAgIGVsc2UgU29tZSAoQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmYgYi5pbmQpXG5cblxubGV0IHBlZWsgPSBmdW5jdGlvblxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgcyAtPiBwZWVrX2RhdGEgc1xuXG5cbmxldCByZWMganVua19kYXRhIDogdHlwZSB2LiB2IGNlbGwgLT4gdW5pdCA9IGZ1biBzIC0+XG4gIG1hdGNoIHMuZGF0YSB3aXRoXG4gICAgU2NvbnMgKF8sIGQpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IHMuZGF0YSA8LSBkXG4gIHwgU2dlbiAoe2N1cnIgPSBTb21lIF99IGFzIGcpIC0+IHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGcuY3VyciA8LSBOb25lXG4gIHwgU2J1ZmZpbyBiIC0+XG4gICAgICBpZiBiLmluZCA+PSBiLmxlbiB0aGVuIGZpbGxfYnVmZiBiO1xuICAgICAgaWYgYi5sZW4gPT0gMCB0aGVuIHMuZGF0YSA8LSBTZW1wdHlcbiAgICAgIGVsc2UgKHMuY291bnQgPC0gKHN1Y2Mgcy5jb3VudCk7IGIuaW5kIDwtIHN1Y2MgYi5pbmQpXG4gIHwgXyAtPlxuICAgICAgbWF0Y2ggcGVla19kYXRhIHMgd2l0aFxuICAgICAgICBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyAtPiBqdW5rX2RhdGEgc1xuXG5cbmxldCBqdW5rID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBkYXRhIC0+IGp1bmtfZGF0YSBkYXRhXG5cbmxldCByZWMgbmdldF9kYXRhIG4gcyA9XG4gIGlmIG4gPD0gMCB0aGVuIFtdLCBzLmRhdGEsIDBcbiAgZWxzZVxuICAgIG1hdGNoIHBlZWtfZGF0YSBzIHdpdGhcbiAgICAgIFNvbWUgYSAtPlxuICAgICAgICBqdW5rX2RhdGEgcztcbiAgICAgICAgbGV0IChhbCwgZCwgaykgPSBuZ2V0X2RhdGEgKHByZWQgbikgcyBpbiBhIDo6IGFsLCBTY29ucyAoYSwgZCksIHN1Y2Mga1xuICAgIHwgTm9uZSAtPiBbXSwgcy5kYXRhLCAwXG5cblxubGV0IG5wZWVrX2RhdGEgbiBzID1cbiAgbGV0IChhbCwgZCwgbGVuKSA9IG5nZXRfZGF0YSBuIHMgaW5cbiAgcy5jb3VudCA8LSAocy5jb3VudCAtIGxlbik7XG4gIHMuZGF0YSA8LSBkO1xuICBhbFxuXG5cbmxldCBucGVlayBuID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBkIC0+IG5wZWVrX2RhdGEgbiBkXG5cbmxldCBuZXh0IHMgPVxuICBtYXRjaCBwZWVrIHMgd2l0aFxuICAgIFNvbWUgYSAtPiBqdW5rIHM7IGFcbiAgfCBOb25lIC0+IHJhaXNlIEZhaWx1cmVcblxuXG5sZXQgZW1wdHkgcyA9XG4gIG1hdGNoIHBlZWsgcyB3aXRoXG4gICAgU29tZSBfIC0+IHJhaXNlIEZhaWx1cmVcbiAgfCBOb25lIC0+ICgpXG5cblxubGV0IGl0ZXIgZiBzdHJtID1cbiAgbGV0IHJlYyBkb19yZWMgKCkgPVxuICAgIG1hdGNoIHBlZWsgc3RybSB3aXRoXG4gICAgICBTb21lIGEgLT4ganVuayBzdHJtOyBpZ25vcmUoZiBhKTsgZG9fcmVjICgpXG4gICAgfCBOb25lIC0+ICgpXG4gIGluXG4gIGRvX3JlYyAoKVxuXG5cbigqIFN0cmVhbSBidWlsZGluZyBmdW5jdGlvbnMgKilcblxubGV0IGZyb20gZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNnZW4ge2N1cnIgPSBOb25lOyBmdW5jID0gZn19XG5cbmxldCBvZl9saXN0IGwgPVxuICBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biB4IGwgLT4gU2NvbnMgKHgsIGwpKSBsIFNlbXB0eX1cblxuXG5sZXQgb2Zfc3RyaW5nIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgICgqIFdlIGNhbm5vdCB1c2UgdGhlIGluZGV4IHBhc3NlZCBieSB0aGUgW2Zyb21dIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICAgYmVjYXVzZSBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHN0cmVhbSBjb3VudCwgd2l0aCBhYnNvbHV0ZWx5IG5vXG4gICAgICAgZ3VhcmFudGVlIHRoYXQgaXQgd2lsbCBzdGFydCBmcm9tIDAuIEZvciBleGFtcGxlLCBpbiB0aGUgY2FzZVxuICAgICAgIG9mIFtTdHJlYW0uaWNvbnMgJ2MnIChTdHJlYW0uZnJvbV9zdHJpbmcgXCJhYlwiKV0sIHRoZSBmaXJzdFxuICAgICAgIGFjY2VzcyB0byB0aGUgc3RyaW5nIHdpbGwgYmUgbWFkZSB3aXRoIGNvdW50IFsxXSBhbHJlYWR5LlxuICAgICopXG4gICAgbGV0IGMgPSAhY291bnQgaW5cbiAgICBpZiBjIDwgU3RyaW5nLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSBzLltjXSlcbiAgICBlbHNlIE5vbmUpXG5cblxubGV0IG9mX2J5dGVzIHMgPVxuICBsZXQgY291bnQgPSByZWYgMCBpblxuICBmcm9tIChmdW4gXyAtPlxuICAgIGxldCBjID0gIWNvdW50IGluXG4gICAgaWYgYyA8IEJ5dGVzLmxlbmd0aCBzXG4gICAgdGhlbiAoaW5jciBjb3VudDsgU29tZSAoQnl0ZXMuZ2V0IHMgYykpXG4gICAgZWxzZSBOb25lKVxuXG5cbmxldCBvZl9jaGFubmVsIGljID1cbiAgU29tZSB7Y291bnQgPSAwO1xuICAgICAgICBkYXRhID0gU2J1ZmZpbyB7aWMgPSBpYzsgYnVmZiA9IEJ5dGVzLmNyZWF0ZSA0MDk2OyBsZW4gPSAwOyBpbmQgPSAwfX1cblxuXG4oKiBTdHJlYW0gZXhwcmVzc2lvbnMgYnVpbGRlcnMgKilcblxubGV0IGlhcHAgaSBzID0gU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2FwcCAoZGF0YSBpLCBkYXRhIHMpfVxubGV0IGljb25zIGkgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNjb25zIChpLCBkYXRhIHMpfVxubGV0IGlzaW5nIGkgPSBTb21lIHtjb3VudCA9IDA7IGRhdGEgPSBTY29ucyAoaSwgU2VtcHR5KX1cblxubGV0IGxhcHAgZiBzID1cbiAgU29tZSB7Y291bnQgPSAwOyBkYXRhID0gU2xhenkgKGxhenkoU2FwcCAoZGF0YSAoZiAoKSksIGRhdGEgcykpKX1cblxubGV0IGxjb25zIGYgcyA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBkYXRhIHMpKSl9XG5sZXQgbHNpbmcgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KFNjb25zIChmICgpLCBTZW1wdHkpKSl9XG5cbmxldCBzZW1wdHkgPSBOb25lXG5sZXQgc2xhenkgZiA9IFNvbWUge2NvdW50ID0gMDsgZGF0YSA9IFNsYXp5IChsYXp5KGRhdGEgKGYgKCkpKSl9XG5cbigqIEZvciBkZWJ1Z2dpbmcgdXNlICopXG5cbmxldCByZWMgZHVtcCA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiB0IC0+IHVuaXQgPSBmdW4gZiBzIC0+XG4gIHByaW50X3N0cmluZyBcIntjb3VudCA9IFwiO1xuICBwcmludF9pbnQgKGNvdW50IHMpO1xuICBwcmludF9zdHJpbmcgXCI7IGRhdGEgPSBcIjtcbiAgZHVtcF9kYXRhIGYgKGRhdGEgcyk7XG4gIHByaW50X3N0cmluZyBcIn1cIjtcbiAgcHJpbnRfbmV3bGluZSAoKVxuYW5kIGR1bXBfZGF0YSA6IHR5cGUgdi4gKHYgLT4gdW5pdCkgLT4gdiBkYXRhIC0+IHVuaXQgPSBmdW4gZiAtPlxuICBmdW5jdGlvblxuICAgIFNlbXB0eSAtPiBwcmludF9zdHJpbmcgXCJTZW1wdHlcIlxuICB8IFNjb25zIChhLCBkKSAtPlxuICAgICAgcHJpbnRfc3RyaW5nIFwiU2NvbnMgKFwiO1xuICAgICAgZiBhO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQ7XG4gICAgICBwcmludF9zdHJpbmcgXCIpXCJcbiAgfCBTYXBwIChkMSwgZDIpIC0+XG4gICAgICBwcmludF9zdHJpbmcgXCJTYXBwIChcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQxO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiLCBcIjtcbiAgICAgIGR1bXBfZGF0YSBmIGQyO1xuICAgICAgcHJpbnRfc3RyaW5nIFwiKVwiXG4gIHwgU2xhenkgXyAtPiBwcmludF9zdHJpbmcgXCJTbGF6eVwiXG4gIHwgU2dlbiBfIC0+IHByaW50X3N0cmluZyBcIlNnZW5cIlxuICB8IFNidWZmaW8gXyAtPiBwcmludF9zdHJpbmcgXCJTYnVmZmlvXCJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgIFBpZXJyZSBXZWlzIGFuZCBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTkgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogRXh0ZW5zaWJsZSBidWZmZXJzICopXG5cbnR5cGUgdCA9XG4ge211dGFibGUgYnVmZmVyIDogYnl0ZXM7XG4gIG11dGFibGUgcG9zaXRpb24gOiBpbnQ7XG4gIG11dGFibGUgbGVuZ3RoIDogaW50O1xuICBpbml0aWFsX2J1ZmZlciA6IGJ5dGVzfVxuKCogSW52YXJpYW50czogYWxsIHBhcnRzIG9mIHRoZSBjb2RlIHByZXNlcnZlIHRoZSBpbnZhcmlhbnRzIHRoYXQ6XG4gICAtIFswIDw9IGIucG9zaXRpb24gPD0gYi5sZW5ndGhdXG4gICAtIFtiLmxlbmd0aCA9IEJ5dGVzLmxlbmd0aCBiLmJ1ZmZlcl1cblxuICAgTm90ZSBpbiBwYXJ0aWN1bGFyIHRoYXQgW2IucG9zaXRpb24gPSBiLmxlbmd0aF0gaXMgbGVnYWwsXG4gICBpdCBtZWFucyB0aGF0IHRoZSBidWZmZXIgaXMgZnVsbCBhbmQgd2lsbCBoYXZlIHRvIGJlIGV4dGVuZGVkXG4gICBiZWZvcmUgYW55IGZ1cnRoZXIgYWRkaXRpb24uICopXG5cbmxldCBjcmVhdGUgbiA9XG4gbGV0IG4gPSBpZiBuIDwgMSB0aGVuIDEgZWxzZSBuIGluXG4gbGV0IG4gPSBpZiBuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIGVsc2UgbiBpblxuIGxldCBzID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiB7YnVmZmVyID0gczsgcG9zaXRpb24gPSAwOyBsZW5ndGggPSBuOyBpbml0aWFsX2J1ZmZlciA9IHN9XG5cbmxldCBjb250ZW50cyBiID0gQnl0ZXMuc3ViX3N0cmluZyBiLmJ1ZmZlciAwIGIucG9zaXRpb25cbmxldCB0b19ieXRlcyBiID0gQnl0ZXMuc3ViIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgc3ViIGIgb2ZzIGxlbiA9XG4gIGlmIG9mcyA8IDAgfHwgbGVuIDwgMCB8fCBvZnMgPiBiLnBvc2l0aW9uIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuc3ViXCJcbiAgZWxzZSBCeXRlcy5zdWJfc3RyaW5nIGIuYnVmZmVyIG9mcyBsZW5cblxuXG5sZXQgYmxpdCBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuID1cbiAgaWYgbGVuIDwgMCB8fCBzcmNvZmYgPCAwIHx8IHNyY29mZiA+IHNyYy5wb3NpdGlvbiAtIGxlblxuICAgICAgICAgICAgIHx8IGRzdG9mZiA8IDAgfHwgZHN0b2ZmID4gKEJ5dGVzLmxlbmd0aCBkc3QpIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYmxpdFwiXG4gIGVsc2VcbiAgICBCeXRlcy51bnNhZmVfYmxpdCBzcmMuYnVmZmVyIHNyY29mZiBkc3QgZHN0b2ZmIGxlblxuXG5cbmxldCBudGggYiBvZnMgPVxuICBpZiBvZnMgPCAwIHx8IG9mcyA+PSBiLnBvc2l0aW9uIHRoZW5cbiAgIGludmFsaWRfYXJnIFwiQnVmZmVyLm50aFwiXG4gIGVsc2UgQnl0ZXMudW5zYWZlX2dldCBiLmJ1ZmZlciBvZnNcblxuXG5sZXQgbGVuZ3RoIGIgPSBiLnBvc2l0aW9uXG5cbmxldCBjbGVhciBiID0gYi5wb3NpdGlvbiA8LSAwXG5cbmxldCByZXNldCBiID1cbiAgYi5wb3NpdGlvbiA8LSAwO1xuICBiLmJ1ZmZlciA8LSBiLmluaXRpYWxfYnVmZmVyO1xuICBiLmxlbmd0aCA8LSBCeXRlcy5sZW5ndGggYi5idWZmZXJcblxuKCogW3Jlc2l6ZSBiIG1vcmVdIGVuc3VyZXMgdGhhdCBbYi5wb3NpdGlvbiArIG1vcmUgPD0gYi5sZW5ndGhdIGhvbGRzXG4gICBieSBkeW5hbWljYWxseSBleHRlbmRpbmcgW2IuYnVmZmVyXSBpZiBuZWNlc3NhcnkgLS0gYW5kIHRodXNcbiAgIGluY3JlYXNpbmcgW2IubGVuZ3RoXS5cblxuICAgSW4gcGFydGljdWxhciwgYWZ0ZXIgW3Jlc2l6ZSBiIG1vcmVdIGlzIGNhbGxlZCwgYSBkaXJlY3QgYWNjZXNzIG9mXG4gICBzaXplIFttb3JlXSBhdCBbYi5wb3NpdGlvbl0gd2lsbCBhbHdheXMgYmUgaW4tYm91bmRzLCBzbyB0aGF0XG4gICAodW5zYWZlX3tnZXQsc2V0fSkgbWF5IGJlIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuKilcbmxldCByZXNpemUgYiBtb3JlID1cbiAgbGV0IG9sZF9wb3MgPSBiLnBvc2l0aW9uIGluXG4gIGxldCBvbGRfbGVuID0gYi5sZW5ndGggaW5cbiAgbGV0IG5ld19sZW4gPSByZWYgb2xkX2xlbiBpblxuICB3aGlsZSBvbGRfcG9zICsgbW9yZSA+ICFuZXdfbGVuIGRvIG5ld19sZW4gOj0gMiAqICFuZXdfbGVuIGRvbmU7XG4gIGlmICFuZXdfbGVuID4gU3lzLm1heF9zdHJpbmdfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBpZiBvbGRfcG9zICsgbW9yZSA8PSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbiAgICB0aGVuIG5ld19sZW4gOj0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG4gICAgZWxzZSBmYWlsd2l0aCBcIkJ1ZmZlci5hZGQ6IGNhbm5vdCBncm93IGJ1ZmZlclwiXG4gIGVuZDtcbiAgbGV0IG5ld19idWZmZXIgPSBCeXRlcy5jcmVhdGUgIW5ld19sZW4gaW5cbiAgKCogUFIjNjE0ODogbGV0J3Mga2VlcCB1c2luZyBbYmxpdF0gcmF0aGVyIHRoYW4gW3Vuc2FmZV9ibGl0XSBpblxuICAgICB0aGlzIHRyaWNreSBmdW5jdGlvbiB0aGF0IGlzIHNsb3cgYW55d2F5LiAqKVxuICBCeXRlcy5ibGl0IGIuYnVmZmVyIDAgbmV3X2J1ZmZlciAwIGIucG9zaXRpb247XG4gIGIuYnVmZmVyIDwtIG5ld19idWZmZXI7XG4gIGIubGVuZ3RoIDwtICFuZXdfbGVuO1xuICBhc3NlcnQgKGIucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoKTtcbiAgYXNzZXJ0IChvbGRfcG9zICsgbW9yZSA8PSBiLmxlbmd0aCk7XG4gICgpXG4gICgqIE5vdGU6IHRoZXJlIGFyZSB2YXJpb3VzIHNpdHVhdGlvbnMgKHByZWVtcHRpdmUgdGhyZWFkcywgc2lnbmFscyBhbmRcbiAgICAgZ2MgZmluYWxpemVycykgd2hlcmUgT0NhbWwgY29kZSBtYXkgYmUgcnVuIGFzeW5jaHJvbm91c2x5OyBpblxuICAgICBwYXJ0aWN1bGFyLCB0aGVyZSBtYXkgYmUgYSByYWNlIHdpdGggYW5vdGhlciB1c2VyIG9mIFtiXSwgY2hhbmdpbmdcbiAgICAgaXRzIG11dGFibGUgZmllbGRzIGluIHRoZSBtaWRkbGUgb2YgdGhlIFtyZXNpemVdIGNhbGwuIFRoZSBCdWZmZXJcbiAgICAgbW9kdWxlIGRvZXMgbm90IHByb3ZpZGUgYW55IGNvcnJlY3RuZXNzIGd1YXJhbnRlZSBpZiB0aGF0IGhhcHBlbnMsXG4gICAgIGJ1dCB3ZSBtdXN0IHN0aWxsIGVuc3VyZSB0aGF0IHRoZSBkYXRhc3RydWN0dXJlIGludmFyaWFudHMgaG9sZCBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAtLSBhcyB3ZSBwbGFuIHRvIHVzZSBbdW5zYWZlX3tnZXQsc2V0fV0uXG5cbiAgICAgVGhlcmUgYXJlIHR3byBwb3RlbnRpYWwgYWxsb2NhdGlvbiBwb2ludHMgaW4gdGhpcyBmdW5jdGlvbixcbiAgICAgW3JlZl0gYW5kIFtCeXRlcy5jcmVhdGVdLCBidXQgYWxsIHJlYWRzIGFuZCB3cml0ZXMgdG8gdGhlIGZpZWxkc1xuICAgICBvZiBbYl0gaGFwcGVuIGJlZm9yZSBib3RoIG9mIHRoZW0gb3IgYWZ0ZXIgYm90aCBvZiB0aGVtLlxuXG4gICAgIFdlIHRoZXJlZm9yZSBhc3N1bWUgdGhhdCBbYi5wb3NpdGlvbl0gbWF5IGNoYW5nZSBhdCB0aGVzZSBhbGxvY2F0aW9ucyxcbiAgICAgYW5kIGNoZWNrIHRoYXQgdGhlIFtiLnBvc2l0aW9uICsgbW9yZSA8PSBiLmxlbmd0aF0gcG9zdGNvbmRpdGlvblxuICAgICBob2xkcyBmb3IgYm90aCB2YWx1ZXMgb2YgW2IucG9zaXRpb25dLCBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGZ1bmN0aW9uXG4gICAgIGlzIGNhbGxlZC4gTW9yZSBwcmVjaXNlbHksIHRoZSBmb2xsb3dpbmcgaW52YXJpYW50cyBtdXN0IGhvbGQgaWYgdGhlXG4gICAgIGZ1bmN0aW9uIHJldHVybnMgY29ycmVjdGx5LCBpbiBhZGRpdGlvbiB0byB0aGUgdXN1YWwgYnVmZmVyIGludmFyaWFudHM6XG4gICAgIC0gW29sZChiLnBvc2l0aW9uKSArIG1vcmUgPD0gbmV3KGIubGVuZ3RoKV1cbiAgICAgLSBbbmV3KGIucG9zaXRpb24pICsgbW9yZSA8PSBuZXcoYi5sZW5ndGgpXVxuICAgICAtIFtvbGQoYi5sZW5ndGgpIDw9IG5ldyhiLmxlbmd0aCldXG5cbiAgICAgTm90ZTogW2IucG9zaXRpb24gKyBtb3JlIDw9IG9sZChiLmxlbmd0aCldIGRvZXMgKm5vdCpcbiAgICAgaG9sZCBpbiBnZW5lcmFsLCBhcyBpdCBpcyBwcmVjaXNlbHkgdGhlIGNhc2Ugd2hlcmUgeW91IG5lZWRcbiAgICAgdG8gY2FsbCBbcmVzaXplXSB0byBpbmNyZWFzZSBbYi5sZW5ndGhdLlxuXG4gICAgIE5vdGU6IFthc3NlcnRdIGFib3ZlIGRvZXMgbm90IG1lYW4gdGhhdCB3ZSBrbm93IHRoZSBjb25kaXRpb25zXG4gICAgIGFsd2F5cyBob2xkLCBidXQgdGhhdCB0aGUgZnVuY3Rpb24gbWF5IHJldHVybiBjb3JyZWN0bHlcbiAgICAgb25seSBpZiB0aGV5IGhvbGQuXG5cbiAgICAgTm90ZTogdGhlIG90aGVyIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBkb2VzIG5vdCBuZWVkXG4gICAgIHRvIGJlIGNoZWNrZWQgd2l0aCB0aGlzIGxldmVsIG9mIHNjcnV0aW55LCBnaXZlbiB0aGF0IHRoZXlcbiAgICAgcmVhZC93cml0ZSB0aGUgYnVmZmVyIGltbWVkaWF0ZWx5IGFmdGVyIGNoZWNraW5nIHRoYXRcbiAgICAgW2IucG9zaXRpb24gKyBtb3JlIDw9IGIubGVuZ3RoXSBob2xkIG9yIGNhbGxpbmcgW3Jlc2l6ZV0uXG4gICopXG5cbmxldCBhZGRfY2hhciBiIGMgPVxuICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICBpZiBwb3MgPj0gYi5sZW5ndGggdGhlbiByZXNpemUgYiAxO1xuICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIHBvcyBjO1xuICBiLnBvc2l0aW9uIDwtIHBvcyArIDFcblxuIGxldCBhZGRfdXRmXzhfdWNoYXIgYiB1ID0gbWF0Y2ggVWNoYXIudG9faW50IHUgd2l0aFxuIHwgdSB3aGVuIHUgPCAwIC0+IGFzc2VydCBmYWxzZVxuIHwgdSB3aGVuIHUgPD0gMHgwMDdGIC0+XG4gICAgIGFkZF9jaGFyIGIgKENoYXIudW5zYWZlX2NociB1KVxuIHwgdSB3aGVuIHUgPD0gMHgwN0ZGIC0+XG4gICAgIGxldCBwb3MgPSBiLnBvc2l0aW9uIGluXG4gICAgIGlmIHBvcyArIDIgPiBiLmxlbmd0aCB0aGVuIHJlc2l6ZSBiIDI7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyAgICApXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHhDMCBsb3IgKHUgbHNyIDYpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKHUgbGFuZCAweDNGKSkpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAzID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAzO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4RTAgbG9yICh1IGxzciAxMikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSlcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAoKHUgbHNyIDYpIGxhbmQgMHgzRikpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMilcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweDgwIGxvciAodSBsYW5kIDB4M0YpKSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgM1xuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgIClcbiAgICAgICAoQ2hhci51bnNhZmVfY2hyICgweEYwIGxvciAodSBsc3IgMTgpKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDEpXG4gICAgICAgKENoYXIudW5zYWZlX2NociAoMHg4MCBsb3IgKCh1IGxzciAxMikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAyKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICgodSBsc3IgNikgbGFuZCAweDNGKSkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAzKVxuICAgICAgIChDaGFyLnVuc2FmZV9jaHIgKDB4ODAgbG9yICh1IGxhbmQgMHgzRikpKTtcbiAgICAgYi5wb3NpdGlvbiA8LSBwb3MgKyA0XG4gfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4gbGV0IGFkZF91dGZfMTZiZV91Y2hhciBiIHUgPSBtYXRjaCBVY2hhci50b19pbnQgdSB3aXRoXG4gfCB1IHdoZW4gdSA8IDAgLT4gYXNzZXJ0IGZhbHNlXG4gfCB1IHdoZW4gdSA8PSAweEZGRkYgLT5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgMiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMjtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAodSBsc3IgOCkpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDJcbiB8IHUgd2hlbiB1IDw9IDB4MTBGRkZGIC0+XG4gICAgIGxldCB1JyA9IHUgLSAweDEwMDAwIGluXG4gICAgIGxldCBoaSA9IDB4RDgwMCBsb3IgKHUnIGxzciAxMCkgaW5cbiAgICAgbGV0IGxvID0gMHhEQzAwIGxvciAodScgbGFuZCAweDNGRikgaW5cbiAgICAgbGV0IHBvcyA9IGIucG9zaXRpb24gaW5cbiAgICAgaWYgcG9zICsgNCA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgNDtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICAgICkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDIpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxhbmQgMHhGRikpO1xuICAgICBiLnBvc2l0aW9uIDwtIHBvcyArIDRcbiB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbiBsZXQgYWRkX3V0Zl8xNmxlX3VjaGFyIGIgdSA9IG1hdGNoIFVjaGFyLnRvX2ludCB1IHdpdGhcbiB8IHUgd2hlbiB1IDwgMCAtPiBhc3NlcnQgZmFsc2VcbiB8IHUgd2hlbiB1IDw9IDB4RkZGRiAtPlxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyAyID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyICh1IGxhbmQgMHhGRikpO1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgKyAxKSAoQ2hhci51bnNhZmVfY2hyICh1IGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgMlxuIHwgdSB3aGVuIHUgPD0gMHgxMEZGRkYgLT5cbiAgICAgbGV0IHUnID0gdSAtIDB4MTAwMDAgaW5cbiAgICAgbGV0IGhpID0gMHhEODAwIGxvciAodScgbHNyIDEwKSBpblxuICAgICBsZXQgbG8gPSAweERDMDAgbG9yICh1JyBsYW5kIDB4M0ZGKSBpblxuICAgICBsZXQgcG9zID0gYi5wb3NpdGlvbiBpblxuICAgICBpZiBwb3MgKyA0ID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICAgICBCeXRlcy51bnNhZmVfc2V0IGIuYnVmZmVyIChwb3MgICAgKSAoQ2hhci51bnNhZmVfY2hyIChoaSBsYW5kIDB4RkYpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMSkgKENoYXIudW5zYWZlX2NociAoaGkgbHNyIDgpKTtcbiAgICAgQnl0ZXMudW5zYWZlX3NldCBiLmJ1ZmZlciAocG9zICsgMikgKENoYXIudW5zYWZlX2NociAobG8gbGFuZCAweEZGKSk7XG4gICAgIEJ5dGVzLnVuc2FmZV9zZXQgYi5idWZmZXIgKHBvcyArIDMpIChDaGFyLnVuc2FmZV9jaHIgKGxvIGxzciA4KSk7XG4gICAgIGIucG9zaXRpb24gPC0gcG9zICsgNFxuIHwgXyAtPiBhc3NlcnQgZmFsc2VcblxubGV0IGFkZF9zdWJzdHJpbmcgYiBzIG9mZnNldCBsZW4gPVxuICBpZiBvZmZzZXQgPCAwIHx8IGxlbiA8IDAgfHwgb2Zmc2V0ID4gU3RyaW5nLmxlbmd0aCBzIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJCdWZmZXIuYWRkX3N1YnN0cmluZy9hZGRfc3ViYnl0ZXNcIjtcbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIG9mZnNldCBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbjtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9zdWJieXRlcyBiIHMgb2Zmc2V0IGxlbiA9XG4gIGFkZF9zdWJzdHJpbmcgYiAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBzKSBvZmZzZXQgbGVuXG5cbmxldCBhZGRfc3RyaW5nIGIgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyBsZW4gaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiBsZW47XG4gIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyBzIDAgYi5idWZmZXIgYi5wb3NpdGlvbiBsZW47XG4gIGIucG9zaXRpb24gPC0gbmV3X3Bvc2l0aW9uXG5cbmxldCBhZGRfYnl0ZXMgYiBzID0gYWRkX3N0cmluZyBiIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHMpXG5cbmxldCBhZGRfYnVmZmVyIGIgYnMgPVxuICBhZGRfc3ViYnl0ZXMgYiBicy5idWZmZXIgMCBicy5wb3NpdGlvblxuXG4oKiB0aGlzIChwcml2YXRlKSBmdW5jdGlvbiBjb3VsZCBtb3ZlIGludG8gdGhlIHN0YW5kYXJkIGxpYnJhcnkgKilcbmxldCByZWFsbHlfaW5wdXRfdXBfdG8gaWMgYnVmIG9mcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaWMgYnVmIH5hbHJlYWR5X3JlYWQgfm9mcyB+dG9fcmVhZCA9XG4gICAgaWYgdG9fcmVhZCA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICBsZXQgciA9IGlucHV0IGljIGJ1ZiBvZnMgdG9fcmVhZCBpblxuICAgICAgaWYgciA9IDAgdGhlbiBhbHJlYWR5X3JlYWRcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IGFscmVhZHlfcmVhZCA9IGFscmVhZHlfcmVhZCArIHIgaW5cbiAgICAgICAgbGV0IG9mcyA9IG9mcyArIHIgaW5cbiAgICAgICAgbGV0IHRvX3JlYWQgPSB0b19yZWFkIC0gciBpblxuICAgICAgICBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkIH5vZnMgfnRvX3JlYWRcbiAgICAgIGVuZFxuICAgIGVuZFxuICBpbiBsb29wIGljIGJ1ZiB+YWxyZWFkeV9yZWFkOjAgfm9mcyB+dG9fcmVhZDpsZW5cblxuXG5sZXQgdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuID1cbiAgaWYgYi5wb3NpdGlvbiArIGxlbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgbGVuO1xuICBsZXQgbiA9IHJlYWxseV9pbnB1dF91cF90byBpYyBiLmJ1ZmZlciBiLnBvc2l0aW9uIGxlbiBpblxuICAoKiBUaGUgYXNzZXJ0aW9uIGJlbG93IG1heSBmYWlsIGluIHdlaXJkIHNjZW5hcmlvIHdoZXJlXG4gICAgIHRocmVhZGVkL2ZpbmFsaXplciBjb2RlLCBydW4gYXN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZVxuICAgICBbcmVhbGx5X2lucHV0X3VwX3RvXSBjYWxsLCByYWNlcyBvbiB0aGUgYnVmZmVyOyB3ZSBkb24ndCBlbnN1cmVcbiAgICAgY29ycmVjdG5lc3MgaW4gdGhpcyBjYXNlLCBidXQgbmVlZCB0byBwcmVzZXJ2ZSB0aGUgaW52YXJpYW50cyBmb3JcbiAgICAgbWVtb3J5LXNhZmV0eSAoc2VlIGRpc2N1c3Npb24gb2YgW3Jlc2l6ZV0pLiAqKVxuICBhc3NlcnQgKGIucG9zaXRpb24gKyBuIDw9IGIubGVuZ3RoKTtcbiAgYi5wb3NpdGlvbiA8LSBiLnBvc2l0aW9uICsgbjtcbiAgblxuXG5sZXQgYWRkX2NoYW5uZWwgYiBpYyBsZW4gPVxuICBpZiBsZW4gPCAwIHx8IGxlbiA+IFN5cy5tYXhfc3RyaW5nX2xlbmd0aCB0aGVuICAgKCogUFIjNTAwNCAqKVxuICAgIGludmFsaWRfYXJnIFwiQnVmZmVyLmFkZF9jaGFubmVsXCI7XG4gIGxldCBuID0gdW5zYWZlX2FkZF9jaGFubmVsX3VwX3RvIGIgaWMgbGVuIGluXG4gICgqIEl0IGlzIGludGVudGlvbmFsIHRoYXQgYSBjb25zdW1lciBjYXRjaGluZyBFbmRfb2ZfZmlsZVxuICAgICB3aWxsIHNlZSB0aGUgZGF0YSB3cml0dGVuIChzZWUgIzY3MTksICM3MTM2KS4gKilcbiAgaWYgbiA8IGxlbiB0aGVuIHJhaXNlIEVuZF9vZl9maWxlO1xuICAoKVxuXG5sZXQgb3V0cHV0X2J1ZmZlciBvYyBiID1cbiAgb3V0cHV0IG9jIGIuYnVmZmVyIDAgYi5wb3NpdGlvblxuXG5sZXQgY2xvc2luZyA9IGZ1bmN0aW9uXG4gIHwgJygnIC0+ICcpJ1xuICB8ICd7JyAtPiAnfSdcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG4oKiBvcGVuaW5nIGFuZCBjbG9zaW5nOiBvcGVuIGFuZCBjbG9zZSBjaGFyYWN0ZXJzLCB0eXBpY2FsbHkgKCBhbmQgKVxuICAgazogYmFsYW5jZSBvZiBvcGVuaW5nIGFuZCBjbG9zaW5nIGNoYXJzXG4gICBzOiB0aGUgc3RyaW5nIHdoZXJlIHdlIGFyZSBzZWFyY2hpbmdcbiAgIHN0YXJ0OiB0aGUgaW5kZXggd2hlcmUgd2Ugc3RhcnQgdGhlIHNlYXJjaC4gKilcbmxldCBhZHZhbmNlX3RvX2Nsb3Npbmcgb3BlbmluZyBjbG9zaW5nIGsgcyBzdGFydCA9XG4gIGxldCByZWMgYWR2YW5jZSBrIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gICAgaWYgcy5baV0gPSBvcGVuaW5nIHRoZW4gYWR2YW5jZSAoayArIDEpIChpICsgMSkgbGltIGVsc2VcbiAgICBpZiBzLltpXSA9IGNsb3NpbmcgdGhlblxuICAgICAgaWYgayA9IDAgdGhlbiBpIGVsc2UgYWR2YW5jZSAoayAtIDEpIChpICsgMSkgbGltXG4gICAgZWxzZSBhZHZhbmNlIGsgKGkgKyAxKSBsaW0gaW5cbiAgYWR2YW5jZSBrIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbmxldCBhZHZhbmNlX3RvX25vbl9hbHBoYSBzIHN0YXJ0ID1cbiAgbGV0IHJlYyBhZHZhbmNlIGkgbGltID1cbiAgICBpZiBpID49IGxpbSB0aGVuIGxpbSBlbHNlXG4gICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgfCAnMCcgLi4gJzknIHwgJ18nIC0+IGFkdmFuY2UgKGkgKyAxKSBsaW1cbiAgICB8IF8gLT4gaSBpblxuICBhZHZhbmNlIHN0YXJ0IChTdHJpbmcubGVuZ3RoIHMpXG5cbigqIFdlIGFyZSBqdXN0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYW4gaWRlbnQgaW4gcywgc3RhcnRpbmcgYXQgc3RhcnQuICopXG5sZXQgZmluZF9pZGVudCBzIHN0YXJ0IGxpbSA9XG4gIGlmIHN0YXJ0ID49IGxpbSB0aGVuIHJhaXNlIE5vdF9mb3VuZCBlbHNlXG4gIG1hdGNoIHMuW3N0YXJ0XSB3aXRoXG4gICgqIFBhcmVudGhlc2l6ZWQgaWRlbnQgPyAqKVxuICB8ICcoJyB8ICd7JyBhcyBjIC0+XG4gICAgIGxldCBuZXdfc3RhcnQgPSBzdGFydCArIDEgaW5cbiAgICAgbGV0IHN0b3AgPSBhZHZhbmNlX3RvX2Nsb3NpbmcgYyAoY2xvc2luZyBjKSAwIHMgbmV3X3N0YXJ0IGluXG4gICAgIFN0cmluZy5zdWIgcyBuZXdfc3RhcnQgKHN0b3AgLSBzdGFydCAtIDEpLCBzdG9wICsgMVxuICAoKiBSZWd1bGFyIGlkZW50ICopXG4gIHwgXyAtPlxuICAgICBsZXQgc3RvcCA9IGFkdmFuY2VfdG9fbm9uX2FscGhhIHMgKHN0YXJ0ICsgMSkgaW5cbiAgICAgU3RyaW5nLnN1YiBzIHN0YXJ0IChzdG9wIC0gc3RhcnQpLCBzdG9wXG5cbigqIFN1YnN0aXR1dGUgJGlkZW50LCAkKGlkZW50KSwgb3IgJHtpZGVudH0gaW4gcyxcbiAgICBhY2NvcmRpbmcgdG8gdGhlIGZ1bmN0aW9uIG1hcHBpbmcgZi4gKilcbmxldCBhZGRfc3Vic3RpdHV0ZSBiIGYgcyA9XG4gIGxldCBsaW0gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBzdWJzdCBwcmV2aW91cyBpID1cbiAgICBpZiBpIDwgbGltIHRoZW4gYmVnaW5cbiAgICAgIG1hdGNoIHMuW2ldIHdpdGhcbiAgICAgIHwgJyQnIGFzIGN1cnJlbnQgd2hlbiBwcmV2aW91cyA9ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiBjdXJyZW50O1xuICAgICAgICAgc3Vic3QgJyAnIChpICsgMSlcbiAgICAgIHwgJyQnIC0+XG4gICAgICAgICBsZXQgaiA9IGkgKyAxIGluXG4gICAgICAgICBsZXQgaWRlbnQsIG5leHRfaSA9IGZpbmRfaWRlbnQgcyBqIGxpbSBpblxuICAgICAgICAgYWRkX3N0cmluZyBiIChmIGlkZW50KTtcbiAgICAgICAgIHN1YnN0ICcgJyBuZXh0X2lcbiAgICAgIHwgY3VycmVudCB3aGVuIHByZXZpb3VzID09ICdcXFxcJyAtPlxuICAgICAgICAgYWRkX2NoYXIgYiAnXFxcXCc7XG4gICAgICAgICBhZGRfY2hhciBiIGN1cnJlbnQ7XG4gICAgICAgICBzdWJzdCAnICcgKGkgKyAxKVxuICAgICAgfCAnXFxcXCcgYXMgY3VycmVudCAtPlxuICAgICAgICAgc3Vic3QgY3VycmVudCAoaSArIDEpXG4gICAgICB8IGN1cnJlbnQgLT5cbiAgICAgICAgIGFkZF9jaGFyIGIgY3VycmVudDtcbiAgICAgICAgIHN1YnN0IGN1cnJlbnQgKGkgKyAxKVxuICAgIGVuZCBlbHNlXG4gICAgaWYgcHJldmlvdXMgPSAnXFxcXCcgdGhlbiBhZGRfY2hhciBiIHByZXZpb3VzIGluXG4gIHN1YnN0ICcgJyAwXG5cbmxldCB0cnVuY2F0ZSBiIGxlbiA9XG4gICAgaWYgbGVuIDwgMCB8fCBsZW4gPiBsZW5ndGggYiB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkJ1ZmZlci50cnVuY2F0ZVwiXG4gICAgZWxzZVxuICAgICAgYi5wb3NpdGlvbiA8LSBsZW5cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSBiID1cbiAgbGV0IHJlYyBhdXggaSAoKSA9XG4gICAgKCogTm90ZSB0aGF0IGIucG9zaXRpb24gaXMgbm90IGEgY29uc3RhbnQgYW5kIGNhbm5vdCBiZSBsaWZ0ZWQgb3V0IG9mIGF1eCAqKVxuICAgIGlmIGkgPj0gYi5wb3NpdGlvbiB0aGVuIFNlcS5OaWxcbiAgICBlbHNlXG4gICAgICBsZXQgeCA9IEJ5dGVzLnVuc2FmZV9nZXQgYi5idWZmZXIgaSBpblxuICAgICAgU2VxLkNvbnMgKHgsIGF1eCAoaSsxKSlcbiAgaW5cbiAgYXV4IDBcblxubGV0IHRvX3NlcWkgYiA9XG4gIGxldCByZWMgYXV4IGkgKCkgPVxuICAgICgqIE5vdGUgdGhhdCBiLnBvc2l0aW9uIGlzIG5vdCBhIGNvbnN0YW50IGFuZCBjYW5ub3QgYmUgbGlmdGVkIG91dCBvZiBhdXggKilcbiAgICBpZiBpID49IGIucG9zaXRpb24gdGhlbiBTZXEuTmlsXG4gICAgZWxzZVxuICAgICAgbGV0IHggPSBCeXRlcy51bnNhZmVfZ2V0IGIuYnVmZmVyIGkgaW5cbiAgICAgIFNlcS5Db25zICgoaSx4KSwgYXV4IChpKzEpKVxuICBpblxuICBhdXggMFxuXG5sZXQgYWRkX3NlcSBiIHNlcSA9IFNlcS5pdGVyIChhZGRfY2hhciBiKSBzZXFcblxubGV0IG9mX3NlcSBpID1cbiAgbGV0IGIgPSBjcmVhdGUgMzIgaW5cbiAgYWRkX3NlcSBiIGk7XG4gIGJcblxuKCoqIHs2IEJpbmFyeSBlbmNvZGluZyBvZiBpbnRlZ2Vyc30gKilcblxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ4IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5leHRlcm5hbCB1bnNhZmVfc2V0X2ludDE2IDogYnl0ZXMgLT4gaW50IC0+IGludCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQxNnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQzMiA6IGJ5dGVzIC0+IGludCAtPiBpbnQzMiAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQzMnVcIlxuZXh0ZXJuYWwgdW5zYWZlX3NldF9pbnQ2NCA6IGJ5dGVzIC0+IGludCAtPiBpbnQ2NCAtPiB1bml0ID0gXCIlY2FtbF9ieXRlc19zZXQ2NHVcIlxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIlxuZXh0ZXJuYWwgc3dhcDMyIDogaW50MzIgLT4gaW50MzIgPSBcIiVic3dhcF9pbnQzMlwiXG5leHRlcm5hbCBzd2FwNjQgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWJzd2FwX2ludDY0XCJcblxuXG5sZXQgYWRkX2ludDggYiB4ID1cbiAgbGV0IG5ld19wb3NpdGlvbiA9IGIucG9zaXRpb24gKyAxIGluXG4gIGlmIG5ld19wb3NpdGlvbiA+IGIubGVuZ3RoIHRoZW4gcmVzaXplIGIgMTtcbiAgdW5zYWZlX3NldF9pbnQ4IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDIgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiAyO1xuICB1bnNhZmVfc2V0X2ludDE2IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQzMl9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDQgaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA0O1xuICB1bnNhZmVfc2V0X2ludDMyIGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQ2NF9uZSBiIHggPVxuICBsZXQgbmV3X3Bvc2l0aW9uID0gYi5wb3NpdGlvbiArIDggaW5cbiAgaWYgbmV3X3Bvc2l0aW9uID4gYi5sZW5ndGggdGhlbiByZXNpemUgYiA4O1xuICB1bnNhZmVfc2V0X2ludDY0IGIuYnVmZmVyIGIucG9zaXRpb24geDtcbiAgYi5wb3NpdGlvbiA8LSBuZXdfcG9zaXRpb25cblxubGV0IGFkZF9pbnQxNl9sZSBiIHggPVxuICBhZGRfaW50MTZfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiBzd2FwMTYgeCBlbHNlIHgpXG5cbmxldCBhZGRfaW50MTZfYmUgYiB4ID1cbiAgYWRkX2ludDE2X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4geCBlbHNlIHN3YXAxNiB4KVxuXG5sZXQgYWRkX2ludDMyX2xlIGIgeCA9XG4gIGFkZF9pbnQzMl9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHN3YXAzMiB4IGVsc2UgeClcblxubGV0IGFkZF9pbnQzMl9iZSBiIHggPVxuICBhZGRfaW50MzJfbmUgYiAoaWYgU3lzLmJpZ19lbmRpYW4gdGhlbiB4IGVsc2Ugc3dhcDMyIHgpXG5cbmxldCBhZGRfaW50NjRfbGUgYiB4ID1cbiAgYWRkX2ludDY0X25lIGIgKGlmIFN5cy5iaWdfZW5kaWFuIHRoZW4gc3dhcDY0IHggZWxzZSB4KVxuXG5sZXQgYWRkX2ludDY0X2JlIGIgeCA9XG4gIGFkZF9pbnQ2NF9uZSBiIChpZiBTeXMuYmlnX2VuZGlhbiB0aGVuIHggZWxzZSBzd2FwNjQgeClcblxubGV0IGFkZF91aW50OCA9IGFkZF9pbnQ4XG5sZXQgYWRkX3VpbnQxNl9uZSA9IGFkZF9pbnQxNl9uZVxubGV0IGFkZF91aW50MTZfbGUgPSBhZGRfaW50MTZfbGVcbmxldCBhZGRfdWludDE2X2JlID0gYWRkX2ludDE2X2JlXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIFhhdmllciBMZXJveSBhbmQgUGllcnJlIFdlaXMsIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0QmFzaWNzXG5vcGVuIENhbWxpbnRlcm5hbEZvcm1hdFxuXG5sZXQga2ZwcmludGYgayBvIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9wcmludGYgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBvIGFjYzsgayBvKSBFbmRfb2ZfYWNjIGZtdFxubGV0IGticHJpbnRmIGsgYiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmIChmdW4gYWNjIC0+IGJ1ZnB1dF9hY2MgYiBhY2M7IGsgYikgRW5kX29mX2FjYyBmbXRcbmxldCBpa2ZwcmludGYgayBvYyAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBrIG9jIGZtdFxubGV0IGlrYnByaW50ZiA9IGlrZnByaW50ZlxuXG5sZXQgZnByaW50ZiBvYyBmbXQgPSBrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgYnByaW50ZiBiIGZtdCA9IGticHJpbnRmIGlnbm9yZSBiIGZtdFxubGV0IGlmcHJpbnRmIG9jIGZtdCA9IGlrZnByaW50ZiBpZ25vcmUgb2MgZm10XG5sZXQgaWJwcmludGYgYiBmbXQgPSBpa2JwcmludGYgaWdub3JlIGIgZm10XG5sZXQgcHJpbnRmIGZtdCA9IGZwcmludGYgc3Rkb3V0IGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBzdGRlcnIgZm10XG5cbmxldCBrc3ByaW50ZiBrIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbGV0IGsnIGFjYyA9XG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgNjQgaW5cbiAgICBzdHJwdXRfYWNjIGJ1ZiBhY2M7XG4gICAgayAoQnVmZmVyLmNvbnRlbnRzIGJ1ZikgaW5cbiAgbWFrZV9wcmludGYgaycgRW5kX29mX2FjYyBmbXRcblxubGV0IHNwcmludGYgZm10ID0ga3NwcmludGYgKGZ1biBzIC0+IHMpIGZtdFxuXG5sZXQga3ByaW50ZiA9IGtzcHJpbnRmXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUga2V5ID0gc3RyaW5nXG50eXBlIGRvYyA9IHN0cmluZ1xudHlwZSB1c2FnZV9tc2cgPSBzdHJpbmdcbnR5cGUgYW5vbl9mdW4gPSAoc3RyaW5nIC0+IHVuaXQpXG5cbnR5cGUgc3BlYyA9XG4gIHwgVW5pdCBvZiAodW5pdCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB1bml0IGFyZ3VtZW50ICopXG4gIHwgQm9vbCBvZiAoYm9vbCAtPiB1bml0KSAgICAgKCogQ2FsbCB0aGUgZnVuY3Rpb24gd2l0aCBhIGJvb2wgYXJndW1lbnQgKilcbiAgfCBTZXQgb2YgYm9vbCByZWYgICAgICAgICAgICAoKiBTZXQgdGhlIHJlZmVyZW5jZSB0byB0cnVlICopXG4gIHwgQ2xlYXIgb2YgYm9vbCByZWYgICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gZmFsc2UgKilcbiAgfCBTdHJpbmcgb2YgKHN0cmluZyAtPiB1bml0KSAoKiBDYWxsIHRoZSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFyZ3VtZW50ICopXG4gIHwgU2V0X3N0cmluZyBvZiBzdHJpbmcgcmVmICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIHN0cmluZyBhcmd1bWVudCAqKVxuICB8IEludCBvZiAoaW50IC0+IHVuaXQpICAgICAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYW4gaW50IGFyZ3VtZW50ICopXG4gIHwgU2V0X2ludCBvZiBpbnQgcmVmICAgICAgICAgKCogU2V0IHRoZSByZWZlcmVuY2UgdG8gdGhlIGludCBhcmd1bWVudCAqKVxuICB8IEZsb2F0IG9mIChmbG9hdCAtPiB1bml0KSAgICgqIENhbGwgdGhlIGZ1bmN0aW9uIHdpdGggYSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFNldF9mbG9hdCBvZiBmbG9hdCByZWYgICAgICgqIFNldCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBmbG9hdCBhcmd1bWVudCAqKVxuICB8IFR1cGxlIG9mIHNwZWMgbGlzdCAgICAgICAgICgqIFRha2Ugc2V2ZXJhbCBhcmd1bWVudHMgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWMgbGlzdCAqKVxuICB8IFN5bWJvbCBvZiBzdHJpbmcgbGlzdCAqIChzdHJpbmcgLT4gdW5pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKiBUYWtlIG9uZSBvZiB0aGUgc3ltYm9scyBhcyBhcmd1bWVudCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBzeW1ib2wuICopXG4gIHwgUmVzdCBvZiAoc3RyaW5nIC0+IHVuaXQpICAgKCogU3RvcCBpbnRlcnByZXRpbmcga2V5d29yZHMgYW5kIGNhbGwgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gd2l0aCBlYWNoIHJlbWFpbmluZyBhcmd1bWVudCAqKVxuICB8IEV4cGFuZCBvZiAoc3RyaW5nIC0+IHN0cmluZyBhcnJheSkgKCogSWYgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMgdG8gcHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIG9mIHRoZSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbW1wiLWZvb1wiOyBcImFyZ1wiXSBAIHJlc3RdIHdoZXJlIFwiZm9vXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHJlZ2lzdGVyZWQgYXMgW0V4cGFuZCBmXSwgdGhlbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50cyBbZiBcImFyZ1wiIEAgcmVzdF0gYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQuIE9ubHkgYWxsb3dlZCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3BhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljXS4gKilcblxuZXhjZXB0aW9uIEJhZCBvZiBzdHJpbmdcbmV4Y2VwdGlvbiBIZWxwIG9mIHN0cmluZ1xuXG50eXBlIGVycm9yID1cbiAgfCBVbmtub3duIG9mIHN0cmluZ1xuICB8IFdyb25nIG9mIHN0cmluZyAqIHN0cmluZyAqIHN0cmluZyAgKCogb3B0aW9uLCBhY3R1YWwsIGV4cGVjdGVkICopXG4gIHwgTWlzc2luZyBvZiBzdHJpbmdcbiAgfCBNZXNzYWdlIG9mIHN0cmluZ1xuXG5leGNlcHRpb24gU3RvcCBvZiBlcnJvciAoKiB1c2VkIGludGVybmFsbHkgKilcblxub3BlbiBQcmludGZcblxubGV0IHJlYyBhc3NvYzMgeCBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgKHkxLCB5MiwgXykgOjogXyB3aGVuIHkxID0geCAtPiB5MlxuICB8IF8gOjogdCAtPiBhc3NvYzMgeCB0XG5cblxubGV0IHNwbGl0IHMgPVxuICBsZXQgaSA9IFN0cmluZy5pbmRleCBzICc9JyBpblxuICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIFN0cmluZy5zdWIgcyAwIGksIFN0cmluZy5zdWIgcyAoaSsxKSAobGVuLShpKzEpKVxuXG5cbmxldCBtYWtlX3N5bWxpc3QgcHJlZml4IHNlcCBzdWZmaXggbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiPG5vbmU+XCJcbiAgfCBoOjp0IC0+IChMaXN0LmZvbGRfbGVmdCAoZnVuIHggeSAtPiB4IF4gc2VwIF4geSkgKHByZWZpeCBeIGgpIHQpIF4gc3VmZml4XG5cblxubGV0IHByaW50X3NwZWMgYnVmIChrZXksIHNwZWMsIGRvYykgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGRvYyA+IDAgdGhlblxuICAgIG1hdGNoIHNwZWMgd2l0aFxuICAgIHwgU3ltYm9sIChsLCBfKSAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXMlc1xcblwiIGtleSAobWFrZV9zeW1saXN0IFwie1wiIFwifFwiIFwifVwiIGwpIGRvY1xuICAgIHwgXyAtPlxuICAgICAgICBicHJpbnRmIGJ1ZiBcIiAgJXMgJXNcXG5cIiBrZXkgZG9jXG5cblxubGV0IGhlbHBfYWN0aW9uICgpID0gcmFpc2UgKFN0b3AgKFVua25vd24gXCItaGVscFwiKSlcblxubGV0IGFkZF9oZWxwIHNwZWNsaXN0ID1cbiAgbGV0IGFkZDEgPVxuICAgIHRyeSBpZ25vcmUgKGFzc29jMyBcIi1oZWxwXCIgc3BlY2xpc3QpOyBbXVxuICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICBbXCItaGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGFuZCBhZGQyID1cbiAgICB0cnkgaWdub3JlIChhc3NvYzMgXCItLWhlbHBcIiBzcGVjbGlzdCk7IFtdXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgICAgIFtcIi0taGVscFwiLCBVbml0IGhlbHBfYWN0aW9uLCBcIiBEaXNwbGF5IHRoaXMgbGlzdCBvZiBvcHRpb25zXCJdXG4gIGluXG4gIHNwZWNsaXN0IEAgKGFkZDEgQCBhZGQyKVxuXG5cbmxldCB1c2FnZV9iIGJ1ZiBzcGVjbGlzdCBlcnJtc2cgPVxuICBicHJpbnRmIGJ1ZiBcIiVzXFxuXCIgZXJybXNnO1xuICBMaXN0Lml0ZXIgKHByaW50X3NwZWMgYnVmKSAoYWRkX2hlbHAgc3BlY2xpc3QpXG5cblxubGV0IHVzYWdlX3N0cmluZyBzcGVjbGlzdCBlcnJtc2cgPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIHVzYWdlX2IgYiBzcGVjbGlzdCBlcnJtc2c7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG5cblxubGV0IHVzYWdlIHNwZWNsaXN0IGVycm1zZyA9XG4gIGVwcmludGYgXCIlc1wiICh1c2FnZV9zdHJpbmcgc3BlY2xpc3QgZXJybXNnKVxuXG5cbmxldCBjdXJyZW50ID0gcmVmIDBcblxubGV0IGJvb2xfb2Zfc3RyaW5nX29wdCB4ID1cbiAgdHJ5IFNvbWUgKGJvb2xfb2Zfc3RyaW5nIHgpXG4gIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IE5vbmVcblxubGV0IGludF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoaW50X29mX3N0cmluZyB4KVxuICB3aXRoIEZhaWx1cmUgXyAtPiBOb25lXG5cbmxldCBmbG9hdF9vZl9zdHJpbmdfb3B0IHggPVxuICB0cnkgU29tZSAoZmxvYXRfb2Zfc3RyaW5nIHgpXG4gIHdpdGggRmFpbHVyZSBfIC0+IE5vbmVcblxubGV0IHBhcnNlX2FuZF9leHBhbmRfYXJndl9keW5hbWljX2F1eCBhbGxvd19leHBhbmQgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJybXNnID1cbiAgbGV0IGluaXRwb3MgPSAhY3VycmVudCBpblxuICBsZXQgY29udmVydF9lcnJvciBlcnJvciA9XG4gICAgKCogY29udmVydCBhbiBpbnRlcm5hbCBlcnJvciB0byBhIEJhZC9IZWxwIGV4Y2VwdGlvblxuICAgICAgICpvciogYWRkIHRoZSBwcm9ncmFtIG5hbWUgYXMgYSBwcmVmaXggYW5kIHRoZSB1c2FnZSBtZXNzYWdlIGFzIGEgc3VmZml4XG4gICAgICAgdG8gYW4gdXNlci1yYWlzZWQgQmFkIGV4Y2VwdGlvbi5cbiAgICAqKVxuICAgIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAyMDAgaW5cbiAgICBsZXQgcHJvZ25hbWUgPVxuICAgICAgaWYgaW5pdHBvcyA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKGluaXRwb3MpIGVsc2UgXCIoPylcIiBpblxuICAgIGJlZ2luIG1hdGNoIGVycm9yIHdpdGhcbiAgICAgIHwgVW5rbm93biBcIi1oZWxwXCIgLT4gKClcbiAgICAgIHwgVW5rbm93biBcIi0taGVscFwiIC0+ICgpXG4gICAgICB8IFVua25vd24gcyAtPlxuICAgICAgICAgIGJwcmludGYgYiBcIiVzOiB1bmtub3duIG9wdGlvbiAnJXMnLlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgTWlzc2luZyBzIC0+XG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6IG9wdGlvbiAnJXMnIG5lZWRzIGFuIGFyZ3VtZW50LlxcblwiIHByb2duYW1lIHNcbiAgICAgIHwgV3JvbmcgKG9wdCwgYXJnLCBleHBlY3RlZCkgLT5cbiAgICAgICAgICBicHJpbnRmIGIgXCIlczogd3JvbmcgYXJndW1lbnQgJyVzJzsgb3B0aW9uICclcycgZXhwZWN0cyAlcy5cXG5cIlxuICAgICAgICAgICAgICAgICAgcHJvZ25hbWUgYXJnIG9wdCBleHBlY3RlZFxuICAgICAgfCBNZXNzYWdlIHMgLT4gKCogdXNlciBlcnJvciBtZXNzYWdlICopXG4gICAgICAgICAgYnByaW50ZiBiIFwiJXM6ICVzLlxcblwiIHByb2duYW1lIHNcbiAgICBlbmQ7XG4gICAgdXNhZ2VfYiBiICFzcGVjbGlzdCBlcnJtc2c7XG4gICAgaWYgZXJyb3IgPSBVbmtub3duIFwiLWhlbHBcIiB8fCBlcnJvciA9IFVua25vd24gXCItLWhlbHBcIlxuICAgIHRoZW4gSGVscCAoQnVmZmVyLmNvbnRlbnRzIGIpXG4gICAgZWxzZSBCYWQgKEJ1ZmZlci5jb250ZW50cyBiKVxuICBpblxuICBpbmNyIGN1cnJlbnQ7XG4gIHdoaWxlICFjdXJyZW50IDwgKEFycmF5Lmxlbmd0aCAhYXJndikgZG9cbiAgICBiZWdpbiB0cnlcbiAgICAgIGxldCBzID0gIWFyZ3YuKCFjdXJyZW50KSBpblxuICAgICAgaWYgU3RyaW5nLmxlbmd0aCBzID49IDEgJiYgcy5bMF0gPSAnLScgdGhlbiBiZWdpblxuICAgICAgICBsZXQgYWN0aW9uLCBmb2xsb3cgPVxuICAgICAgICAgIHRyeSBhc3NvYzMgcyAhc3BlY2xpc3QsIE5vbmVcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGtleXdvcmQsIGFyZyA9IHNwbGl0IHMgaW5cbiAgICAgICAgICAgIGFzc29jMyBrZXl3b3JkICFzcGVjbGlzdCwgU29tZSBhcmdcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiByYWlzZSAoU3RvcCAoVW5rbm93biBzKSlcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IG5vX2FyZyAoKSA9XG4gICAgICAgICAgbWF0Y2ggZm9sbG93IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcIm5vIGFyZ3VtZW50XCIpKSkgaW5cbiAgICAgICAgbGV0IGdldF9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmICFjdXJyZW50ICsgMSA8IChBcnJheS5sZW5ndGggIWFyZ3YpIHRoZW4gIWFyZ3YuKCFjdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgZWxzZSByYWlzZSAoU3RvcCAoTWlzc2luZyBzKSlcbiAgICAgICAgICB8IFNvbWUgYXJnIC0+IGFyZ1xuICAgICAgICBpblxuICAgICAgICBsZXQgY29uc3VtZV9hcmcgKCkgPVxuICAgICAgICAgIG1hdGNoIGZvbGxvdyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluY3IgY3VycmVudFxuICAgICAgICAgIHwgU29tZSBfIC0+ICgpXG4gICAgICAgIGluXG4gICAgICAgIGxldCByZWMgdHJlYXRfYWN0aW9uID0gZnVuY3Rpb25cbiAgICAgICAgfCBVbml0IGYgLT4gbm9fYXJnICgpOyBmICgpO1xuICAgICAgICB8IEJvb2wgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGJvb2xfb2Zfc3RyaW5nX29wdCBhcmcgd2l0aFxuICAgICAgICAgICAgfCBOb25lIC0+IHJhaXNlIChTdG9wIChXcm9uZyAocywgYXJnLCBcImEgYm9vbGVhblwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgcyAtPiBmIHNcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFNldCByIC0+IG5vX2FyZyAoKTsgciA6PSB0cnVlO1xuICAgICAgICB8IENsZWFyIHIgLT4gbm9fYXJnICgpOyByIDo9IGZhbHNlO1xuICAgICAgICB8IFN0cmluZyBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgZiBhcmc7XG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgfCBTeW1ib2wgKHN5bWIsIGYpIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgaWYgTGlzdC5tZW0gYXJnIHN5bWIgdGhlbiBiZWdpblxuICAgICAgICAgICAgICBmIGFyZztcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICAgICAgICByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJvbmUgb2Y6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeIChtYWtlX3N5bWxpc3QgXCJcIiBcIiBcIiBcIlwiIHN5bWIpKSkpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBTZXRfc3RyaW5nIHIgLT5cbiAgICAgICAgICAgIHIgOj0gZ2V0X2FyZyAoKTtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IEludCBmIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2ludCByIC0+XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggaW50X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhbiBpbnRlZ2VyXCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IHIgOj0geFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgRmxvYXQgZiAtPlxuICAgICAgICAgICAgbGV0IGFyZyA9IGdldF9hcmcgKCkgaW5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIGZsb2F0X29mX3N0cmluZ19vcHQgYXJnIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSAtPiByYWlzZSAoU3RvcCAoV3JvbmcgKHMsIGFyZywgXCJhIGZsb2F0XCIpKSlcbiAgICAgICAgICAgIHwgU29tZSB4IC0+IGYgeFxuICAgICAgICAgICAgZW5kO1xuICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgIHwgU2V0X2Zsb2F0IHIgLT5cbiAgICAgICAgICAgIGxldCBhcmcgPSBnZXRfYXJnICgpIGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBmbG9hdF9vZl9zdHJpbmdfb3B0IGFyZyB3aXRoXG4gICAgICAgICAgICB8IE5vbmUgLT4gcmFpc2UgKFN0b3AgKFdyb25nIChzLCBhcmcsIFwiYSBmbG9hdFwiKSkpXG4gICAgICAgICAgICB8IFNvbWUgeCAtPiByIDo9IHhcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGNvbnN1bWVfYXJnICgpO1xuICAgICAgICB8IFR1cGxlIHNwZWNzIC0+XG4gICAgICAgICAgICBub19hcmcgKCk7XG4gICAgICAgICAgICBMaXN0Lml0ZXIgdHJlYXRfYWN0aW9uIHNwZWNzO1xuICAgICAgICB8IFJlc3QgZiAtPlxuICAgICAgICAgICAgbm9fYXJnICgpO1xuICAgICAgICAgICAgd2hpbGUgIWN1cnJlbnQgPCAoQXJyYXkubGVuZ3RoICFhcmd2KSAtIDEgZG9cbiAgICAgICAgICAgICAgZiAhYXJndi4oIWN1cnJlbnQgKyAxKTtcbiAgICAgICAgICAgICAgY29uc3VtZV9hcmcgKCk7XG4gICAgICAgICAgICBkb25lO1xuICAgICAgICB8IEV4cGFuZCBmIC0+XG4gICAgICAgICAgICBpZiBub3QgYWxsb3dfZXhwYW5kIHRoZW5cbiAgICAgICAgICAgICAgcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJBcmcuRXhwYW5kIGlzIGlzIG9ubHkgYWxsb3dlZCB3aXRoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmcucGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNcIik7XG4gICAgICAgICAgICBsZXQgYXJnID0gZ2V0X2FyZyAoKSBpblxuICAgICAgICAgICAgbGV0IG5ld2FyZyA9IGYgYXJnIGluXG4gICAgICAgICAgICBjb25zdW1lX2FyZyAoKTtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSBBcnJheS5zdWIgIWFyZ3YgMCAoIWN1cnJlbnQgKyAxKVxuICAgICAgICAgICAgYW5kIGFmdGVyID1cbiAgICAgICAgICAgICAgQXJyYXkuc3ViICFhcmd2ICghY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAoKEFycmF5Lmxlbmd0aCAhYXJndikgLSAhY3VycmVudCAtIDEpIGluXG4gICAgICAgICAgICBhcmd2Oj0gQXJyYXkuY29uY2F0IFtiZWZvcmU7bmV3YXJnO2FmdGVyXTtcbiAgICAgICAgaW5cbiAgICAgICAgdHJlYXRfYWN0aW9uIGFjdGlvbiBlbmRcbiAgICAgIGVsc2UgYW5vbmZ1biBzXG4gICAgd2l0aCB8IEJhZCBtIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIChNZXNzYWdlIG0pKTtcbiAgICAgICAgIHwgU3RvcCBlIC0+IHJhaXNlIChjb252ZXJ0X2Vycm9yIGUpO1xuICAgIGVuZDtcbiAgICBpbmNyIGN1cnJlbnRcbiAgZG9uZVxuXG5sZXQgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWMgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnID1cbiAgcGFyc2VfYW5kX2V4cGFuZF9hcmd2X2R5bmFtaWNfYXV4IHRydWUgY3VycmVudCBhcmd2IHNwZWNsaXN0IGFub25mdW4gZXJybXNnXG5cbmxldCBwYXJzZV9hcmd2X2R5bmFtaWMgPyhjdXJyZW50PWN1cnJlbnQpIGFyZ3Ygc3BlY2xpc3QgYW5vbmZ1biBlcnJtc2cgPVxuICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pY19hdXggZmFsc2UgY3VycmVudCAocmVmIGFyZ3YpIHNwZWNsaXN0IGFub25mdW5cbiAgICBlcnJtc2dcblxuXG5sZXQgcGFyc2VfYXJndiA/KGN1cnJlbnQ9Y3VycmVudCkgYXJndiBzcGVjbGlzdCBhbm9uZnVuIGVycm1zZyA9XG4gIHBhcnNlX2FyZ3ZfZHluYW1pYyB+Y3VycmVudDpjdXJyZW50IGFyZ3YgKHJlZiBzcGVjbGlzdCkgYW5vbmZ1biBlcnJtc2dcblxuXG5sZXQgcGFyc2UgbCBmIG1zZyA9XG4gIHRyeVxuICAgIHBhcnNlX2FyZ3YgU3lzLmFyZ3YgbCBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgcGFyc2VfZHluYW1pYyBsIGYgbXNnID1cbiAgdHJ5XG4gICAgcGFyc2VfYXJndl9keW5hbWljIFN5cy5hcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEJhZCBtc2cgLT4gZXByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDJcbiAgfCBIZWxwIG1zZyAtPiBwcmludGYgXCIlc1wiIG1zZzsgZXhpdCAwXG5cbmxldCBwYXJzZV9leHBhbmQgbCBmIG1zZyA9XG4gIHRyeVxuICAgIGxldCBhcmd2ID0gcmVmIFN5cy5hcmd2IGluXG4gICAgbGV0IHNwZWMgPSByZWYgbCBpblxuICAgIGxldCBjdXJyZW50ID0gcmVmICghY3VycmVudCkgaW5cbiAgICBwYXJzZV9hbmRfZXhwYW5kX2FyZ3ZfZHluYW1pYyBjdXJyZW50IGFyZ3Ygc3BlYyBmIG1zZ1xuICB3aXRoXG4gIHwgQmFkIG1zZyAtPiBlcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMlxuICB8IEhlbHAgbXNnIC0+IHByaW50ZiBcIiVzXCIgbXNnOyBleGl0IDBcblxuXG5sZXQgc2Vjb25kX3dvcmQgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IHJlYyBsb29wIG4gPVxuICAgIGlmIG4gPj0gbGVuIHRoZW4gbGVuXG4gICAgZWxzZSBpZiBzLltuXSA9ICcgJyB0aGVuIGxvb3AgKG4rMSlcbiAgICBlbHNlIG5cbiAgaW5cbiAgbWF0Y2ggU3RyaW5nLmluZGV4IHMgJ1xcdCcgd2l0aFxuICB8IG4gLT4gbG9vcCAobisxKVxuICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT5cbiAgICAgIGJlZ2luIG1hdGNoIFN0cmluZy5pbmRleCBzICcgJyB3aXRoXG4gICAgICB8IG4gLT4gbG9vcCAobisxKVxuICAgICAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+IGxlblxuICAgICAgZW5kXG5cblxubGV0IG1heF9hcmdfbGVuIGN1ciAoa3dkLCBzcGVjLCBkb2MpID1cbiAgbWF0Y2ggc3BlYyB3aXRoXG4gIHwgU3ltYm9sIF8gLT4gbWF4IGN1ciAoU3RyaW5nLmxlbmd0aCBrd2QpXG4gIHwgXyAtPiBtYXggY3VyIChTdHJpbmcubGVuZ3RoIGt3ZCArIHNlY29uZF93b3JkIGRvYylcblxuXG5sZXQgcmVwbGFjZV9sZWFkaW5nX3RhYiBzID1cbiAgbGV0IHNlZW4gPSByZWYgZmFsc2UgaW5cbiAgU3RyaW5nLm1hcCAoZnVuY3Rpb24gJ1xcdCcgd2hlbiBub3QgIXNlZW4gLT4gc2VlbiA6PSB0cnVlOyAnICcgfCBjIC0+IGMpIHNcblxubGV0IGFkZF9wYWRkaW5nIGxlbiBrc2QgPVxuICBtYXRjaCBrc2Qgd2l0aFxuICB8IChfLCBfLCBcIlwiKSAtPlxuICAgICAgKCogRG8gbm90IHBhZCB1bmRvY3VtZW50ZWQgb3B0aW9ucywgc28gdGhhdCB0aGV5IHN0aWxsIGRvbid0IHNob3cgdXAgd2hlblxuICAgICAgICogcnVuIHRocm91Z2ggW3VzYWdlXSBvciBbcGFyc2VdLiAqKVxuICAgICAga3NkXG4gIHwgKGt3ZCwgKFN5bWJvbCBfIGFzIHNwZWMpLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgKChtYXggMCAobGVuIC0gY3V0Y29sKSkgKyAzKSAnICcgaW5cbiAgICAgIChrd2QsIHNwZWMsIFwiXFxuXCIgXiBzcGFjZXMgXiByZXBsYWNlX2xlYWRpbmdfdGFiIG1zZylcbiAgfCAoa3dkLCBzcGVjLCBtc2cpIC0+XG4gICAgICBsZXQgY3V0Y29sID0gc2Vjb25kX3dvcmQgbXNnIGluXG4gICAgICBsZXQga3dkX2xlbiA9IFN0cmluZy5sZW5ndGgga3dkIGluXG4gICAgICBsZXQgZGlmZiA9IGxlbiAtIGt3ZF9sZW4gLSBjdXRjb2wgaW5cbiAgICAgIGlmIGRpZmYgPD0gMCB0aGVuXG4gICAgICAgIChrd2QsIHNwZWMsIHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKVxuICAgICAgZWxzZVxuICAgICAgICBsZXQgc3BhY2VzID0gU3RyaW5nLm1ha2UgZGlmZiAnICcgaW5cbiAgICAgICAgbGV0IHByZWZpeCA9IFN0cmluZy5zdWIgKHJlcGxhY2VfbGVhZGluZ190YWIgbXNnKSAwIGN1dGNvbCBpblxuICAgICAgICBsZXQgc3VmZml4ID0gU3RyaW5nLnN1YiBtc2cgY3V0Y29sIChTdHJpbmcubGVuZ3RoIG1zZyAtIGN1dGNvbCkgaW5cbiAgICAgICAgKGt3ZCwgc3BlYywgcHJlZml4IF4gc3BhY2VzIF4gc3VmZml4KVxuXG5cbmxldCBhbGlnbiA/KGxpbWl0PW1heF9pbnQpIHNwZWNsaXN0ID1cbiAgbGV0IGNvbXBsZXRlZCA9IGFkZF9oZWxwIHNwZWNsaXN0IGluXG4gIGxldCBsZW4gPSBMaXN0LmZvbGRfbGVmdCBtYXhfYXJnX2xlbiAwIGNvbXBsZXRlZCBpblxuICBsZXQgbGVuID0gbWluIGxlbiBsaW1pdCBpblxuICBMaXN0Lm1hcCAoYWRkX3BhZGRpbmcgbGVuKSBjb21wbGV0ZWRcblxubGV0IHRyaW1fY3IgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgaWYgbGVuID4gMCAmJiBTdHJpbmcuZ2V0IHMgKGxlbiAtIDEpID0gJ1xccicgdGhlblxuICAgIFN0cmluZy5zdWIgcyAwIChsZW4gLSAxKVxuICBlbHNlXG4gICAgc1xuXG5sZXQgcmVhZF9hdXggdHJpbSBzZXAgZmlsZSA9XG4gIGxldCBpYyA9IG9wZW5faW5fYmluIGZpbGUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMjAwIGluXG4gIGxldCB3b3JkcyA9IHJlZiBbXSBpblxuICBsZXQgc3Rhc2ggKCkgPVxuICAgIGxldCB3b3JkID0gQnVmZmVyLmNvbnRlbnRzIGJ1ZiBpblxuICAgIGxldCB3b3JkID0gaWYgdHJpbSB0aGVuIHRyaW1fY3Igd29yZCBlbHNlIHdvcmQgaW5cbiAgICB3b3JkcyA6PSB3b3JkIDo6ICF3b3JkcztcbiAgICBCdWZmZXIuY2xlYXIgYnVmXG4gIGluXG4gIGJlZ2luXG4gICAgdHJ5IHdoaWxlIHRydWUgZG9cbiAgICAgICAgbGV0IGMgPSBpbnB1dF9jaGFyIGljIGluXG4gICAgICAgIGlmIGMgPSBzZXAgdGhlbiBzdGFzaCAoKSBlbHNlIEJ1ZmZlci5hZGRfY2hhciBidWYgY1xuICAgICAgZG9uZVxuICAgIHdpdGggRW5kX29mX2ZpbGUgLT4gKClcbiAgZW5kO1xuICBpZiBCdWZmZXIubGVuZ3RoIGJ1ZiA+IDAgdGhlbiBzdGFzaCAoKTtcbiAgY2xvc2VfaW4gaWM7XG4gIEFycmF5Lm9mX2xpc3QgKExpc3QucmV2ICF3b3JkcylcblxubGV0IHJlYWRfYXJnID0gcmVhZF9hdXggdHJ1ZSAnXFxuJ1xuXG5sZXQgcmVhZF9hcmcwID0gcmVhZF9hdXggZmFsc2UgJ1xceDAwJ1xuXG5sZXQgd3JpdGVfYXV4IHNlcCBmaWxlIGFyZ3MgPVxuICBsZXQgb2MgPSBvcGVuX291dF9iaW4gZmlsZSBpblxuICBBcnJheS5pdGVyIChmdW4gcyAtPiBmcHJpbnRmIG9jIFwiJXMlY1wiIHMgc2VwKSBhcmdzO1xuICBjbG9zZV9vdXQgb2NcblxubGV0IHdyaXRlX2FyZyA9IHdyaXRlX2F1eCAnXFxuJ1xuXG5sZXQgd3JpdGVfYXJnMCA9IHdyaXRlX2F1eCAnXFx4MDAnXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgT0NhbWwgcHJvZ3JhbW1lcnMgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDE4IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbmV4dGVybmFsIGlkIDogJ2EgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5sZXQgY29uc3QgYyBfID0gY1xubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IG5lZ2F0ZSBwIHYgPSBub3QgKHAgdilcblxuZXhjZXB0aW9uIEZpbmFsbHlfcmFpc2VkIG9mIGV4blxuXG5sZXQgKCkgPSBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIEBAIGZ1bmN0aW9uXG58IEZpbmFsbHlfcmFpc2VkIGV4biAtPiBTb21lIChcIkZ1bi5GaW5hbGx5X3JhaXNlZDogXCIgXiBQcmludGV4Yy50b19zdHJpbmcgZXhuKVxufCBfIC0+IE5vbmVcblxubGV0IHByb3RlY3QgfihmaW5hbGx5IDogdW5pdCAtPiB1bml0KSB3b3JrID1cbiAgbGV0IGZpbmFsbHlfbm9fZXhuICgpID1cbiAgICB0cnkgZmluYWxseSAoKSB3aXRoIGUgLT5cbiAgICAgIGxldCBidCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSAoRmluYWxseV9yYWlzZWQgZSkgYnRcbiAgaW5cbiAgbWF0Y2ggd29yayAoKSB3aXRoXG4gIHwgcmVzdWx0IC0+IGZpbmFsbHlfbm9fZXhuICgpIDsgcmVzdWx0XG4gIHwgZXhjZXB0aW9uIHdvcmtfZXhuIC0+XG4gICAgICBsZXQgd29ya19idCA9IFByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgICBmaW5hbGx5X25vX2V4biAoKSA7XG4gICAgICBQcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB3b3JrX2V4biB3b3JrX2J0XG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIEphY3F1ZXMtSGVucmkgSm91cmRhbiwgcHJvamV0IEdhbGxpdW0sIElOUklBIFBhcmlzICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2LTIwMTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSAgICopXG4oKiAgICAgZXQgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbnR5cGUgc3RhdCA9IHtcbiAgbWlub3Jfd29yZHMgOiBmbG9hdDtcbiAgcHJvbW90ZWRfd29yZHMgOiBmbG9hdDtcbiAgbWFqb3Jfd29yZHMgOiBmbG9hdDtcbiAgbWlub3JfY29sbGVjdGlvbnMgOiBpbnQ7XG4gIG1ham9yX2NvbGxlY3Rpb25zIDogaW50O1xuICBoZWFwX3dvcmRzIDogaW50O1xuICBoZWFwX2NodW5rcyA6IGludDtcbiAgbGl2ZV93b3JkcyA6IGludDtcbiAgbGl2ZV9ibG9ja3MgOiBpbnQ7XG4gIGZyZWVfd29yZHMgOiBpbnQ7XG4gIGZyZWVfYmxvY2tzIDogaW50O1xuICBsYXJnZXN0X2ZyZWUgOiBpbnQ7XG4gIGZyYWdtZW50cyA6IGludDtcbiAgY29tcGFjdGlvbnMgOiBpbnQ7XG4gIHRvcF9oZWFwX3dvcmRzIDogaW50O1xuICBzdGFja19zaXplIDogaW50O1xufVxuXG50eXBlIGNvbnRyb2wgPSB7XG4gIG11dGFibGUgbWlub3JfaGVhcF9zaXplIDogaW50O1xuICBtdXRhYmxlIG1ham9yX2hlYXBfaW5jcmVtZW50IDogaW50O1xuICBtdXRhYmxlIHNwYWNlX292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHZlcmJvc2UgOiBpbnQ7XG4gIG11dGFibGUgbWF4X292ZXJoZWFkIDogaW50O1xuICBtdXRhYmxlIHN0YWNrX2xpbWl0IDogaW50O1xuICBtdXRhYmxlIGFsbG9jYXRpb25fcG9saWN5IDogaW50O1xuICB3aW5kb3dfc2l6ZSA6IGludDtcbiAgY3VzdG9tX21ham9yX3JhdGlvIDogaW50O1xuICBjdXN0b21fbWlub3JfcmF0aW8gOiBpbnQ7XG4gIGN1c3RvbV9taW5vcl9tYXhfc2l6ZSA6IGludDtcbn1cblxuZXh0ZXJuYWwgc3RhdCA6IHVuaXQgLT4gc3RhdCA9IFwiY2FtbF9nY19zdGF0XCJcbmV4dGVybmFsIHF1aWNrX3N0YXQgOiB1bml0IC0+IHN0YXQgPSBcImNhbWxfZ2NfcXVpY2tfc3RhdFwiXG5leHRlcm5hbCBjb3VudGVycyA6IHVuaXQgLT4gKGZsb2F0ICogZmxvYXQgKiBmbG9hdCkgPSBcImNhbWxfZ2NfY291bnRlcnNcIlxuZXh0ZXJuYWwgbWlub3Jfd29yZHMgOiB1bml0IC0+IChmbG9hdCBbQHVuYm94ZWRdKVxuICA9IFwiY2FtbF9nY19taW5vcl93b3Jkc1wiIFwiY2FtbF9nY19taW5vcl93b3Jkc191bmJveGVkXCJcbmV4dGVybmFsIGdldCA6IHVuaXQgLT4gY29udHJvbCA9IFwiY2FtbF9nY19nZXRcIlxuZXh0ZXJuYWwgc2V0IDogY29udHJvbCAtPiB1bml0ID0gXCJjYW1sX2djX3NldFwiXG5leHRlcm5hbCBtaW5vciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19taW5vclwiXG5leHRlcm5hbCBtYWpvcl9zbGljZSA6IGludCAtPiBpbnQgPSBcImNhbWxfZ2NfbWFqb3Jfc2xpY2VcIlxuZXh0ZXJuYWwgbWFqb3IgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfbWFqb3JcIlxuZXh0ZXJuYWwgZnVsbF9tYWpvciA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9nY19mdWxsX21ham9yXCJcbmV4dGVybmFsIGNvbXBhY3QgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZ2NfY29tcGFjdGlvblwiXG5leHRlcm5hbCBnZXRfbWlub3JfZnJlZSA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9taW5vcl9mcmVlXCJcbmV4dGVybmFsIGdldF9idWNrZXQgOiBpbnQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9idWNrZXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgZ2V0X2NyZWRpdCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2dldF9tYWpvcl9jcmVkaXRcIiBbQEBub2FsbG9jXVxuZXh0ZXJuYWwgaHVnZV9mYWxsYmFja19jb3VudCA6IHVuaXQgLT4gaW50ID0gXCJjYW1sX2djX2h1Z2VfZmFsbGJhY2tfY291bnRcIlxuZXh0ZXJuYWwgZXZlbnRsb2dfcGF1c2UgOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfZXZlbnRsb2dfcGF1c2VcIlxuZXh0ZXJuYWwgZXZlbnRsb2dfcmVzdW1lIDogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2V2ZW50bG9nX3Jlc3VtZVwiXG5cbm9wZW4gUHJpbnRmXG5cbmxldCBwcmludF9zdGF0IGMgPVxuICBsZXQgc3QgPSBzdGF0ICgpIGluXG4gIGZwcmludGYgYyBcIm1pbm9yX2NvbGxlY3Rpb25zOiAlZFxcblwiIHN0Lm1pbm9yX2NvbGxlY3Rpb25zO1xuICBmcHJpbnRmIGMgXCJtYWpvcl9jb2xsZWN0aW9uczogJWRcXG5cIiBzdC5tYWpvcl9jb2xsZWN0aW9ucztcbiAgZnByaW50ZiBjIFwiY29tcGFjdGlvbnM6ICAgICAgICVkXFxuXCIgc3QuY29tcGFjdGlvbnM7XG4gIGZwcmludGYgYyBcIlxcblwiO1xuICBsZXQgbDEgPSBTdHJpbmcubGVuZ3RoIChzcHJpbnRmIFwiJS4wZlwiIHN0Lm1pbm9yX3dvcmRzKSBpblxuICBmcHJpbnRmIGMgXCJtaW5vcl93b3JkczogICAgJSouMGZcXG5cIiBsMSBzdC5taW5vcl93b3JkcztcbiAgZnByaW50ZiBjIFwicHJvbW90ZWRfd29yZHM6ICUqLjBmXFxuXCIgbDEgc3QucHJvbW90ZWRfd29yZHM7XG4gIGZwcmludGYgYyBcIm1ham9yX3dvcmRzOiAgICAlKi4wZlxcblwiIGwxIHN0Lm1ham9yX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJcXG5cIjtcbiAgbGV0IGwyID0gU3RyaW5nLmxlbmd0aCAoc3ByaW50ZiBcIiVkXCIgc3QudG9wX2hlYXBfd29yZHMpIGluXG4gIGZwcmludGYgYyBcInRvcF9oZWFwX3dvcmRzOiAlKmRcXG5cIiBsMiBzdC50b3BfaGVhcF93b3JkcztcbiAgZnByaW50ZiBjIFwiaGVhcF93b3JkczogICAgICUqZFxcblwiIGwyIHN0LmhlYXBfd29yZHM7XG4gIGZwcmludGYgYyBcImxpdmVfd29yZHM6ICAgICAlKmRcXG5cIiBsMiBzdC5saXZlX3dvcmRzO1xuICBmcHJpbnRmIGMgXCJmcmVlX3dvcmRzOiAgICAgJSpkXFxuXCIgbDIgc3QuZnJlZV93b3JkcztcbiAgZnByaW50ZiBjIFwibGFyZ2VzdF9mcmVlOiAgICUqZFxcblwiIGwyIHN0Lmxhcmdlc3RfZnJlZTtcbiAgZnByaW50ZiBjIFwiZnJhZ21lbnRzOiAgICAgICUqZFxcblwiIGwyIHN0LmZyYWdtZW50cztcbiAgZnByaW50ZiBjIFwiXFxuXCI7XG4gIGZwcmludGYgYyBcImxpdmVfYmxvY2tzOiAlZFxcblwiIHN0LmxpdmVfYmxvY2tzO1xuICBmcHJpbnRmIGMgXCJmcmVlX2Jsb2NrczogJWRcXG5cIiBzdC5mcmVlX2Jsb2NrcztcbiAgZnByaW50ZiBjIFwiaGVhcF9jaHVua3M6ICVkXFxuXCIgc3QuaGVhcF9jaHVua3NcblxuXG5sZXQgYWxsb2NhdGVkX2J5dGVzICgpID1cbiAgbGV0IChtaSwgcHJvLCBtYSkgPSBjb3VudGVycyAoKSBpblxuICAobWkgKy4gbWEgLS4gcHJvKSAqLiBmbG9hdF9vZl9pbnQgKFN5cy53b3JkX3NpemUgLyA4KVxuXG5cbmV4dGVybmFsIGZpbmFsaXNlIDogKCdhIC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfZmluYWxfcmVnaXN0ZXJcIlxuZXh0ZXJuYWwgZmluYWxpc2VfbGFzdCA6ICh1bml0IC0+IHVuaXQpIC0+ICdhIC0+IHVuaXQgPVxuICBcImNhbWxfZmluYWxfcmVnaXN0ZXJfY2FsbGVkX3dpdGhvdXRfdmFsdWVcIlxuZXh0ZXJuYWwgZmluYWxpc2VfcmVsZWFzZSA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9maW5hbF9yZWxlYXNlXCJcblxuXG50eXBlIGFsYXJtID0gYm9vbCByZWZcbnR5cGUgYWxhcm1fcmVjID0ge2FjdGl2ZSA6IGFsYXJtOyBmIDogdW5pdCAtPiB1bml0fVxuXG5sZXQgcmVjIGNhbGxfYWxhcm0gYXJlYyA9XG4gIGlmICEoYXJlYy5hY3RpdmUpIHRoZW4gYmVnaW5cbiAgICBmaW5hbGlzZSBjYWxsX2FsYXJtIGFyZWM7XG4gICAgYXJlYy5mICgpO1xuICBlbmRcblxuXG5sZXQgY3JlYXRlX2FsYXJtIGYgPVxuICBsZXQgYXJlYyA9IHsgYWN0aXZlID0gcmVmIHRydWU7IGYgPSBmIH0gaW5cbiAgZmluYWxpc2UgY2FsbF9hbGFybSBhcmVjO1xuICBhcmVjLmFjdGl2ZVxuXG5cbmxldCBkZWxldGVfYWxhcm0gYSA9IGEgOj0gZmFsc2VcblxubW9kdWxlIE1lbXByb2YgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGFsbG9jYXRpb24gPVxuICAgICAgeyBuX3NhbXBsZXMgOiBpbnQ7XG4gICAgICAgIHNpemUgOiBpbnQ7XG4gICAgICAgIHVubWFyc2hhbGxlZCA6IGJvb2w7XG4gICAgICAgIGNhbGxzdGFjayA6IFByaW50ZXhjLnJhd19iYWNrdHJhY2UgfVxuXG4gICAgdHlwZSAoJ21pbm9yLCAnbWFqb3IpIHRyYWNrZXIgPSB7XG4gICAgICBhbGxvY19taW5vcjogYWxsb2NhdGlvbiAtPiAnbWlub3Igb3B0aW9uO1xuICAgICAgYWxsb2NfbWFqb3I6IGFsbG9jYXRpb24gLT4gJ21ham9yIG9wdGlvbjtcbiAgICAgIHByb21vdGU6ICdtaW5vciAtPiAnbWFqb3Igb3B0aW9uO1xuICAgICAgZGVhbGxvY19taW5vcjogJ21pbm9yIC0+IHVuaXQ7XG4gICAgICBkZWFsbG9jX21ham9yOiAnbWFqb3IgLT4gdW5pdDtcbiAgICB9XG5cbiAgICBsZXQgbnVsbF90cmFja2VyID0ge1xuICAgICAgYWxsb2NfbWlub3IgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBhbGxvY19tYWpvciA9IChmdW4gXyAtPiBOb25lKTtcbiAgICAgIHByb21vdGUgPSAoZnVuIF8gLT4gTm9uZSk7XG4gICAgICBkZWFsbG9jX21pbm9yID0gKGZ1biBfIC0+ICgpKTtcbiAgICAgIGRlYWxsb2NfbWFqb3IgPSAoZnVuIF8gLT4gKCkpO1xuICAgIH1cblxuICAgIGV4dGVybmFsIGNfc3RhcnQgOlxuICAgICAgZmxvYXQgLT4gaW50IC0+ICgnbWlub3IsICdtYWpvcikgdHJhY2tlciAtPiB1bml0XG4gICAgICA9IFwiY2FtbF9tZW1wcm9mX3N0YXJ0XCJcblxuICAgIGxldCBzdGFydFxuICAgICAgfnNhbXBsaW5nX3JhdGVcbiAgICAgID8oY2FsbHN0YWNrX3NpemUgPSBtYXhfaW50KVxuICAgICAgdHJhY2tlciA9XG4gICAgICBjX3N0YXJ0IHNhbXBsaW5nX3JhdGUgY2FsbHN0YWNrX3NpemUgdHJhY2tlclxuXG4gICAgZXh0ZXJuYWwgc3RvcCA6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9tZW1wcm9mX3N0b3BcIlxuICBlbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTWVzc2FnZSBkaWdlc3QgKE1ENSkgKilcblxudHlwZSB0ID0gc3RyaW5nXG5cbmxldCBjb21wYXJlID0gU3RyaW5nLmNvbXBhcmVcbmxldCBlcXVhbCA9IFN0cmluZy5lcXVhbFxuXG5leHRlcm5hbCB1bnNhZmVfc3RyaW5nOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB0ID0gXCJjYW1sX21kNV9zdHJpbmdcIlxuZXh0ZXJuYWwgY2hhbm5lbDogaW5fY2hhbm5lbCAtPiBpbnQgLT4gdCA9IFwiY2FtbF9tZDVfY2hhblwiXG5cbmxldCBzdHJpbmcgc3RyID1cbiAgdW5zYWZlX3N0cmluZyBzdHIgMCAoU3RyaW5nLmxlbmd0aCBzdHIpXG5cbmxldCBieXRlcyBiID0gc3RyaW5nIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIGIpXG5cbmxldCBzdWJzdHJpbmcgc3RyIG9mcyBsZW4gPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gU3RyaW5nLmxlbmd0aCBzdHIgLSBsZW5cbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC5zdWJzdHJpbmdcIlxuICBlbHNlIHVuc2FmZV9zdHJpbmcgc3RyIG9mcyBsZW5cblxubGV0IHN1YmJ5dGVzIGIgb2ZzIGxlbiA9IHN1YnN0cmluZyAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBiKSBvZnMgbGVuXG5cbmxldCBmaWxlIGZpbGVuYW1lID1cbiAgbGV0IGljID0gb3Blbl9pbl9iaW4gZmlsZW5hbWUgaW5cbiAgbWF0Y2ggY2hhbm5lbCBpYyAoLTEpIHdpdGhcbiAgICB8IGQgLT4gY2xvc2VfaW4gaWM7IGRcbiAgICB8IGV4Y2VwdGlvbiBlIC0+IGNsb3NlX2luIGljOyByYWlzZSBlXG5cbmxldCBvdXRwdXQgY2hhbiBkaWdlc3QgPVxuICBvdXRwdXRfc3RyaW5nIGNoYW4gZGlnZXN0XG5cbmxldCBpbnB1dCBjaGFuID0gcmVhbGx5X2lucHV0X3N0cmluZyBjaGFuIDE2XG5cbmxldCBjaGFyX2hleCBuID1cbiAgQ2hhci51bnNhZmVfY2hyIChuICsgaWYgbiA8IDEwIHRoZW4gQ2hhci5jb2RlICcwJyBlbHNlIChDaGFyLmNvZGUgJ2EnIC0gMTApKVxuXG5sZXQgdG9faGV4IGQgPVxuICBpZiBTdHJpbmcubGVuZ3RoIGQgPD4gMTYgdGhlbiBpbnZhbGlkX2FyZyBcIkRpZ2VzdC50b19oZXhcIjtcbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAzMiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBsZXQgeCA9IENoYXIuY29kZSBkLltpXSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIpIChjaGFyX2hleCAoeCBsc3IgNCkpO1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgcmVzdWx0IChpKjIrMSkgKGNoYXJfaGV4ICh4IGxhbmQgMHgwZikpO1xuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlc3VsdFxuXG5sZXQgZnJvbV9oZXggcyA9XG4gIGlmIFN0cmluZy5sZW5ndGggcyA8PiAzMiB0aGVuIGludmFsaWRfYXJnIFwiRGlnZXN0LmZyb21faGV4XCI7XG4gIGxldCBkaWdpdCBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcwJy4uJzknIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ0EnLi4nRicgLT4gQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJ0EnICsgMTBcbiAgICB8ICdhJy4uJ2YnIC0+IENoYXIuY29kZSBjIC0gQ2hhci5jb2RlICdhJyArIDEwXG4gICAgfCBfIC0+IHJhaXNlIChJbnZhbGlkX2FyZ3VtZW50IFwiRGlnZXN0LmZyb21faGV4XCIpXG4gIGluXG4gIGxldCBieXRlIGkgPSBkaWdpdCBzLltpXSBsc2wgNCArIGRpZ2l0IHMuW2krMV0gaW5cbiAgbGV0IHJlc3VsdCA9IEJ5dGVzLmNyZWF0ZSAxNiBpblxuICBmb3IgaSA9IDAgdG8gMTUgZG9cbiAgICBCeXRlcy5zZXQgcmVzdWx0IGkgKENoYXIuY2hyIChieXRlICgyICogaSkpKTtcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXN1bHRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgRGFtaWVuIERvbGlnZXosIHByb2pldCBQYXJhLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUHNldWRvLXJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG4gICBUaGlzIGlzIGEgbGFnZ2VkLUZpYm9uYWNjaSBGKDU1LCAyNCwgKykgd2l0aCBhIG1vZGlmaWVkIGFkZGl0aW9uXG4gICBmdW5jdGlvbiB0byBlbmhhbmNlIHRoZSBtaXhpbmcgb2YgYml0cy5cbiAgIElmIHdlIHVzZSBub3JtYWwgYWRkaXRpb24sIHRoZSBsb3ctb3JkZXIgYml0IGZhaWxzIHRlc3RzIDEgYW5kIDdcbiAgIG9mIHRoZSBEaWVoYXJkIHRlc3Qgc3VpdGUsIGFuZCBiaXRzIDEgYW5kIDIgYWxzbyBmYWlsIHRlc3QgNy5cbiAgIElmIHdlIHVzZSBtdWx0aXBsaWNhdGlvbiBhcyBzdWdnZXN0ZWQgYnkgTWFyc2FnbGlhLCBpdCBkb2Vzbid0IGZhcmVcbiAgIG11Y2ggYmV0dGVyLlxuICAgQnkgbWl4aW5nIHRoZSBiaXRzIG9mIG9uZSBvZiB0aGUgbnVtYmVycyBiZWZvcmUgYWRkaXRpb24gKFhPUiB0aGVcbiAgIDUgaGlnaC1vcmRlciBiaXRzIGludG8gdGhlIGxvdy1vcmRlciBiaXRzKSwgd2UgZ2V0IGEgZ2VuZXJhdG9yIHRoYXRcbiAgIHBhc3NlcyBhbGwgdGhlIERpZWhhcmQgdGVzdHMuXG4qKVxuXG5leHRlcm5hbCByYW5kb21fc2VlZDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubW9kdWxlIFN0YXRlID0gc3RydWN0XG5cbiAgdHlwZSB0ID0geyBzdCA6IGludCBhcnJheTsgbXV0YWJsZSBpZHggOiBpbnQgfVxuXG4gIGxldCBuZXdfc3RhdGUgKCkgPSB7IHN0ID0gQXJyYXkubWFrZSA1NSAwOyBpZHggPSAwIH1cbiAgbGV0IGFzc2lnbiBzdDEgc3QyID1cbiAgICBBcnJheS5ibGl0IHN0Mi5zdCAwIHN0MS5zdCAwIDU1O1xuICAgIHN0MS5pZHggPC0gc3QyLmlkeFxuXG5cbiAgbGV0IGZ1bGxfaW5pdCBzIHNlZWQgPVxuICAgIGxldCBjb21iaW5lIGFjY3UgeCA9IERpZ2VzdC5zdHJpbmcgKGFjY3UgXiBJbnQudG9fc3RyaW5nIHgpIGluXG4gICAgbGV0IGV4dHJhY3QgZCA9XG4gICAgICBDaGFyLmNvZGUgZC5bMF0gKyAoQ2hhci5jb2RlIGQuWzFdIGxzbCA4KSArIChDaGFyLmNvZGUgZC5bMl0gbHNsIDE2KVxuICAgICAgKyAoQ2hhci5jb2RlIGQuWzNdIGxzbCAyNClcbiAgICBpblxuICAgIGxldCBzZWVkID0gaWYgQXJyYXkubGVuZ3RoIHNlZWQgPSAwIHRoZW4gW3wgMCB8XSBlbHNlIHNlZWQgaW5cbiAgICBsZXQgbCA9IEFycmF5Lmxlbmd0aCBzZWVkIGluXG4gICAgZm9yIGkgPSAwIHRvIDU0IGRvXG4gICAgICBzLnN0LihpKSA8LSBpO1xuICAgIGRvbmU7XG4gICAgbGV0IGFjY3UgPSByZWYgXCJ4XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gNTQgKyBtYXggNTUgbCBkb1xuICAgICAgbGV0IGogPSBpIG1vZCA1NSBpblxuICAgICAgbGV0IGsgPSBpIG1vZCBsIGluXG4gICAgICBhY2N1IDo9IGNvbWJpbmUgIWFjY3Ugc2VlZC4oayk7XG4gICAgICBzLnN0LihqKSA8LSAocy5zdC4oaikgbHhvciBleHRyYWN0ICFhY2N1KSBsYW5kIDB4M0ZGRkZGRkY7ICAoKiBQUiM1NTc1ICopXG4gICAgZG9uZTtcbiAgICBzLmlkeCA8LSAwXG5cblxuICBsZXQgbWFrZSBzZWVkID1cbiAgICBsZXQgcmVzdWx0ID0gbmV3X3N0YXRlICgpIGluXG4gICAgZnVsbF9pbml0IHJlc3VsdCBzZWVkO1xuICAgIHJlc3VsdFxuXG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ICgpID0gbWFrZSAocmFuZG9tX3NlZWQgKCkpXG5cbiAgbGV0IGNvcHkgcyA9XG4gICAgbGV0IHJlc3VsdCA9IG5ld19zdGF0ZSAoKSBpblxuICAgIGFzc2lnbiByZXN1bHQgcztcbiAgICByZXN1bHRcblxuXG4gICgqIFJldHVybnMgMzAgcmFuZG9tIGJpdHMgYXMgYW4gaW50ZWdlciAwIDw9IHggPCAxMDczNzQxODI0ICopXG4gIGxldCBiaXRzIHMgPVxuICAgIHMuaWR4IDwtIChzLmlkeCArIDEpIG1vZCA1NTtcbiAgICBsZXQgY3VydmFsID0gcy5zdC4ocy5pZHgpIGluXG4gICAgbGV0IG5ld3ZhbCA9IHMuc3QuKChzLmlkeCArIDI0KSBtb2QgNTUpXG4gICAgICAgICAgICAgICAgICsgKGN1cnZhbCBseG9yICgoY3VydmFsIGxzciAyNSkgbGFuZCAweDFGKSkgaW5cbiAgICBsZXQgbmV3dmFsMzAgPSBuZXd2YWwgbGFuZCAweDNGRkZGRkZGIGluICAoKiBQUiM1NTc1ICopXG4gICAgcy5zdC4ocy5pZHgpIDwtIG5ld3ZhbDMwO1xuICAgIG5ld3ZhbDMwXG5cblxuICBsZXQgcmVjIGludGF1eCBzIG4gPVxuICAgIGxldCByID0gYml0cyBzIGluXG4gICAgbGV0IHYgPSByIG1vZCBuIGluXG4gICAgaWYgciAtIHYgPiAweDNGRkZGRkZGIC0gbiArIDEgdGhlbiBpbnRhdXggcyBuIGVsc2UgdlxuXG4gIGxldCBpbnQgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPiAweDNGRkZGRkZGIHx8IGJvdW5kIDw9IDBcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludFwiXG4gICAgZWxzZSBpbnRhdXggcyBib3VuZFxuXG5cbiAgbGV0IHJlYyBpbnQzMmF1eCBzIG4gPVxuICAgIGxldCBiMSA9IEludDMyLm9mX2ludCAoYml0cyBzKSBpblxuICAgIGxldCBiMiA9IEludDMyLnNoaWZ0X2xlZnQgKEludDMyLm9mX2ludCAoYml0cyBzIGxhbmQgMSkpIDMwIGluXG4gICAgbGV0IHIgPSBJbnQzMi5sb2dvciBiMSBiMiBpblxuICAgIGxldCB2ID0gSW50MzIucmVtIHIgbiBpblxuICAgIGlmIEludDMyLnN1YiByIHYgPiBJbnQzMi5hZGQgKEludDMyLnN1YiBJbnQzMi5tYXhfaW50IG4pIDFsXG4gICAgdGhlbiBpbnQzMmF1eCBzIG5cbiAgICBlbHNlIHZcblxuICBsZXQgaW50MzIgcyBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMGxcbiAgICB0aGVuIGludmFsaWRfYXJnIFwiUmFuZG9tLmludDMyXCJcbiAgICBlbHNlIGludDMyYXV4IHMgYm91bmRcblxuXG4gIGxldCByZWMgaW50NjRhdXggcyBuID1cbiAgICBsZXQgYjEgPSBJbnQ2NC5vZl9pbnQgKGJpdHMgcykgaW5cbiAgICBsZXQgYjIgPSBJbnQ2NC5zaGlmdF9sZWZ0IChJbnQ2NC5vZl9pbnQgKGJpdHMgcykpIDMwIGluXG4gICAgbGV0IGIzID0gSW50NjQuc2hpZnRfbGVmdCAoSW50NjQub2ZfaW50IChiaXRzIHMgbGFuZCA3KSkgNjAgaW5cbiAgICBsZXQgciA9IEludDY0LmxvZ29yIGIxIChJbnQ2NC5sb2dvciBiMiBiMykgaW5cbiAgICBsZXQgdiA9IEludDY0LnJlbSByIG4gaW5cbiAgICBpZiBJbnQ2NC5zdWIgciB2ID4gSW50NjQuYWRkIChJbnQ2NC5zdWIgSW50NjQubWF4X2ludCBuKSAxTFxuICAgIHRoZW4gaW50NjRhdXggcyBuXG4gICAgZWxzZSB2XG5cbiAgbGV0IGludDY0IHMgYm91bmQgPVxuICAgIGlmIGJvdW5kIDw9IDBMXG4gICAgdGhlbiBpbnZhbGlkX2FyZyBcIlJhbmRvbS5pbnQ2NFwiXG4gICAgZWxzZSBpbnQ2NGF1eCBzIGJvdW5kXG5cblxuICBsZXQgbmF0aXZlaW50ID1cbiAgICBpZiBOYXRpdmVpbnQuc2l6ZSA9IDMyXG4gICAgdGhlbiBmdW4gcyBib3VuZCAtPiBOYXRpdmVpbnQub2ZfaW50MzIgKGludDMyIHMgKE5hdGl2ZWludC50b19pbnQzMiBib3VuZCkpXG4gICAgZWxzZSBmdW4gcyBib3VuZCAtPiBJbnQ2NC50b19uYXRpdmVpbnQgKGludDY0IHMgKEludDY0Lm9mX25hdGl2ZWludCBib3VuZCkpXG5cblxuICAoKiBSZXR1cm5zIGEgZmxvYXQgMCA8PSB4IDw9IDEgd2l0aCBhdCBtb3N0IDYwIGJpdHMgb2YgcHJlY2lzaW9uLiAqKVxuICBsZXQgcmF3ZmxvYXQgcyA9XG4gICAgbGV0IHNjYWxlID0gMTA3Mzc0MTgyNC4wICAoKiAyXjMwICopXG4gICAgYW5kIHIxID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgYW5kIHIyID0gU3RkbGliLmZsb2F0IChiaXRzIHMpXG4gICAgaW4gKHIxIC8uIHNjYWxlICsuIHIyKSAvLiBzY2FsZVxuXG5cbiAgbGV0IGZsb2F0IHMgYm91bmQgPSByYXdmbG9hdCBzICouIGJvdW5kXG5cbiAgbGV0IGJvb2wgcyA9IChiaXRzIHMgbGFuZCAxID0gMClcblxuZW5kXG5cbigqIFRoaXMgaXMgdGhlIHN0YXRlIHlvdSBnZXQgd2l0aCBbaW5pdCAyNzE4MjgxOF0gYW5kIHRoZW4gYXBwbHlpbmdcbiAgIHRoZSBcImxhbmQgMHgzRkZGRkZGRlwiIGZpbHRlciB0byB0aGVtLiAgU2VlICM1NTc1LCAjNTc5MywgIzU5NzcuICopXG5sZXQgZGVmYXVsdCA9IHtcbiAgU3RhdGUuc3QgPSBbfFxuICAgICAgMHgzYWUyNTIyYjsgMHgxZDhkNDYzNDsgMHgxNWI0ZmFkMDsgMHgxOGIxNGFjZTsgMHgxMmY4YTNjNDsgMHgzYjA4NmM0NztcbiAgICAgIDB4MTZkNDY3ZDY7IDB4MTAxZDkxYzc7IDB4MzIxZGYxNzc7IDB4MDE3NmMxOTM7IDB4MWZmNzJiZjE7IDB4MWU4ODkxMDk7XG4gICAgICAweDBiNDY0YjE4OyAweDJiODZiOTdjOyAweDA4OTFkYTQ4OyAweDAzMTM3NDYzOyAweDA4NWFjNWExOyAweDE1ZDYxZjJmO1xuICAgICAgMHgzYmNlZDM1OTsgMHgyOWMxYzEzMjsgMHgzYTg2NzY2ZTsgMHgzNjZkOGM4NjsgMHgxZjViNjIyMjsgMHgzY2UxYjU5ZjtcbiAgICAgIDB4MmViZjc4ZTE7IDB4MjdjZDFiODY7IDB4MjU4ZjNkYzM7IDB4Mzg5YTgxOTQ7IDB4MDJlNGM0NGM7IDB4MThjNDNmN2Q7XG4gICAgICAweDBmNmU1MzRmOyAweDFlN2RmMzU5OyAweDA1NWQwYjdlOyAweDEwZTg0ZTdlOyAweDEyNjE5OGU0OyAweDBlNzcyMmNiO1xuICAgICAgMHgxY2JlZGUyODsgMHgzMzkxYjk2NDsgMHgzZDQwZTkyYTsgMHgwYzU5OTMzZDsgMHgwYjhjZDBiNzsgMHgyNGVmZmYxYztcbiAgICAgIDB4MjgwM2ZkYWE7IDB4MDhlYmM3MmU7IDB4MGY1MjJlMzI7IDB4MDUzOThlZGM7IDB4MjE0NGEwNGM7IDB4MGFlZjNjYmQ7XG4gICAgICAweDAxYWQ0NzE5OyAweDM1YjkzY2Q2OyAweDJhNTU5ZDRmOyAweDFlNmZkNzY4OyAweDI2ZTI3ZjM2OyAweDE4NmYxOGMzO1xuICAgICAgMHgyZmJmOTY3YTtcbiAgICB8XTtcbiAgU3RhdGUuaWR4ID0gMDtcbn1cblxubGV0IGJpdHMgKCkgPSBTdGF0ZS5iaXRzIGRlZmF1bHRcbmxldCBpbnQgYm91bmQgPSBTdGF0ZS5pbnQgZGVmYXVsdCBib3VuZFxubGV0IGludDMyIGJvdW5kID0gU3RhdGUuaW50MzIgZGVmYXVsdCBib3VuZFxubGV0IG5hdGl2ZWludCBib3VuZCA9IFN0YXRlLm5hdGl2ZWludCBkZWZhdWx0IGJvdW5kXG5sZXQgaW50NjQgYm91bmQgPSBTdGF0ZS5pbnQ2NCBkZWZhdWx0IGJvdW5kXG5sZXQgZmxvYXQgc2NhbGUgPSBTdGF0ZS5mbG9hdCBkZWZhdWx0IHNjYWxlXG5sZXQgYm9vbCAoKSA9IFN0YXRlLmJvb2wgZGVmYXVsdFxuXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgZGVmYXVsdCBzZWVkXG5sZXQgaW5pdCBzZWVkID0gU3RhdGUuZnVsbF9pbml0IGRlZmF1bHQgW3wgc2VlZCB8XVxubGV0IHNlbGZfaW5pdCAoKSA9IGZ1bGxfaW5pdCAocmFuZG9tX3NlZWQoKSlcblxuKCogTWFuaXB1bGF0aW5nIHRoZSBjdXJyZW50IHN0YXRlLiAqKVxuXG5sZXQgZ2V0X3N0YXRlICgpID0gU3RhdGUuY29weSBkZWZhdWx0XG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gZGVmYXVsdCBzXG5cbigqKioqKioqKioqKioqKioqKioqKlxuXG4oKiBUZXN0IGZ1bmN0aW9ucy4gIE5vdCBpbmNsdWRlZCBpbiB0aGUgbGlicmFyeS5cbiAgIFRoZSBbY2hpc3F1YXJlXSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIHdpdGggbiA+IDEwci5cbiAgIEl0IHJldHVybnMgYSB0cmlwbGUgKGxvdywgYWN0dWFsLCBoaWdoKS5cbiAgIElmIGxvdyA8PSBhY3R1YWwgPD0gaGlnaCwgdGhlIFtnXSBmdW5jdGlvbiBwYXNzZWQgdGhlIHRlc3QsXG4gICBvdGhlcndpc2UgaXQgZmFpbGVkLlxuXG4gIFNvbWUgcmVzdWx0czpcblxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMCA1MDAwXG5pbml0IDI3MTgyODE4OyBjaGlzcXVhcmUgaW50IDEwMDAwMDAgMTAwMFxuaW5pdCAyNzE4MjgxODsgY2hpc3F1YXJlIGludCAxMDAwMDAgMTAyNFxuaW5pdCAyOTk3OTI2NDM7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMTQxNDIxMzY7IGNoaXNxdWFyZSBpbnQgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZiAxMDI0OyBjaGlzcXVhcmUgZGlmZiAxMDAwMDAgMTAyNFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmIDEwMDsgY2hpc3F1YXJlIGRpZmYgMTAwMDAwIDEwMFxuaW5pdCAyNzE4MjgxODsgaW5pdF9kaWZmMiAxMDI0OyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMjRcbmluaXQgMjcxODI4MTg7IGluaXRfZGlmZjIgMTAwOyBjaGlzcXVhcmUgZGlmZjIgMTAwMDAwIDEwMFxuaW5pdCAxNDE0MjEzNjsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG5pbml0IDI5OTc5MjY0MzsgaW5pdF9kaWZmMiAxMDA7IGNoaXNxdWFyZSBkaWZmMiAxMDAwMDAgMTAwXG4tIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk5Ny41LCAxMDYzLjI0NTU1MzIwMzM2NzU0KVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODkuNzQwMDAwMDAwMDA1MjM4NywgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg0ODU4LjU3ODY0Mzc2MjY5LCA1MDQ1LjUsIDUxNDEuNDIxMzU2MjM3MzEpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPVxuKDkzNi43NTQ0NDY3OTY2MzI0NjUsIDk0NC44MDU5OTk5OTk5ODIzMDUsIDEwNjMuMjQ1NTUzMjAzMzY3NTQpXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAxOS4xOTc0NDAwMDAwMDM1NSwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1OS4zMTc3NjAwMDAwMDUzNiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTAzOS45ODQ2Mzk5OTk5OTUxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA1NC4zODIwNzk5OTk5OTU3NywgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA5MC4wOTYwMDAwMDAwMDUsIDEyMC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoOTYwLiwgMTA3Ni43ODcyMDAwMDAwMDYxMiwgMTA4OC4pXG4jIC0gOiBmbG9hdCAqIGZsb2F0ICogZmxvYXQgPSAoODAuLCA4NS4xNzYwMDAwMDAwMDY3NTIxLCAxMjAuKVxuIyAtIDogZmxvYXQgKiBmbG9hdCAqIGZsb2F0ID0gKDgwLiwgODUuMjE2MDAwMDAwMDAwMzQ5MiwgMTIwLilcbiMgLSA6IGZsb2F0ICogZmxvYXQgKiBmbG9hdCA9ICg4MC4sIDgwLjYyMjAwMDAwMDAwMzAyNjgsIDEyMC4pXG5cbiopXG5cbigqIFJldHVybiB0aGUgc3VtIG9mIHRoZSBzcXVhcmVzIG9mIHZbaTAsaTFbICopXG5sZXQgcmVjIHN1bXNxIHYgaTAgaTEgPVxuICBpZiBpMCA+PSBpMSB0aGVuIDAuMFxuICBlbHNlIGlmIGkxID0gaTAgKyAxIHRoZW4gU3RkbGliLmZsb2F0IHYuKGkwKSAqLiBTdGRsaWIuZmxvYXQgdi4oaTApXG4gIGVsc2Ugc3Vtc3EgdiBpMCAoKGkwK2kxKS8yKSArLiBzdW1zcSB2ICgoaTAraTEpLzIpIGkxXG5cblxubGV0IGNoaXNxdWFyZSBnIG4gciA9XG4gIGlmIG4gPD0gMTAgKiByIHRoZW4gaW52YWxpZF9hcmcgXCJjaGlzcXVhcmVcIjtcbiAgbGV0IGYgPSBBcnJheS5tYWtlIHIgMCBpblxuICBmb3IgaSA9IDEgdG8gbiBkb1xuICAgIGxldCB0ID0gZyByIGluXG4gICAgZi4odCkgPC0gZi4odCkgKyAxXG4gIGRvbmU7XG4gIGxldCB0ID0gc3Vtc3EgZiAwIHJcbiAgYW5kIHIgPSBTdGRsaWIuZmxvYXQgclxuICBhbmQgbiA9IFN0ZGxpYi5mbG9hdCBuIGluXG4gIGxldCBzciA9IDIuMCAqLiBzcXJ0IHIgaW5cbiAgKHIgLS4gc3IsICAgKHIgKi4gdCAvLiBuKSAtLiBuLCAgIHIgKy4gc3IpXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBsaW5lYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb20gbnVtYmVycy5cbiopXG5sZXQgc3QgPSByZWYgMFxubGV0IGluaXRfZGlmZiByID0gc3QgOj0gaW50IHJcbmxldCBkaWZmIHIgPVxuICBsZXQgeDEgPSAhc3RcbiAgYW5kIHgyID0gaW50IHJcbiAgaW5cbiAgc3QgOj0geDI7XG4gIGlmIHgxID49IHgyIHRoZW5cbiAgICB4MSAtIHgyXG4gIGVsc2VcbiAgICByICsgeDEgLSB4MlxuXG5cbmxldCBzdDEgPSByZWYgMFxuYW5kIHN0MiA9IHJlZiAwXG5cblxuKCogVGhpcyBpcyB0byB0ZXN0IGZvciBxdWFkcmF0aWMgZGVwZW5kZW5jaWVzIGJldHdlZW4gc3VjY2Vzc2l2ZSByYW5kb21cbiAgIG51bWJlcnMuXG4qKVxubGV0IGluaXRfZGlmZjIgciA9IHN0MSA6PSBpbnQgcjsgc3QyIDo9IGludCByXG5sZXQgZGlmZjIgciA9XG4gIGxldCB4MSA9ICFzdDFcbiAgYW5kIHgyID0gIXN0MlxuICBhbmQgeDMgPSBpbnQgclxuICBpblxuICBzdDEgOj0geDI7XG4gIHN0MiA6PSB4MztcbiAgKHgzIC0geDIgLSB4MiArIHgxICsgMipyKSBtb2QgclxuXG5cbioqKioqKioqKioqKioqKioqKioqKVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBIYXNoIHRhYmxlcyAqKVxuXG4oKiBXZSBkbyBkeW5hbWljIGhhc2hpbmcsIGFuZCByZXNpemUgdGhlIHRhYmxlIGFuZCByZWhhc2ggdGhlIGVsZW1lbnRzXG4gICB3aGVuIGJ1Y2tldHMgYmVjb21lIHRvbyBsb25nLiAqKVxuXG50eXBlICgnYSwgJ2IpIHQgPVxuICB7IG11dGFibGUgc2l6ZTogaW50OyAgICAgICAgICAgICAgICAgICAgICAgICgqIG51bWJlciBvZiBlbnRyaWVzICopXG4gICAgbXV0YWJsZSBkYXRhOiAoJ2EsICdiKSBidWNrZXRsaXN0IGFycmF5OyAgKCogdGhlIGJ1Y2tldHMgKilcbiAgICBtdXRhYmxlIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgIG11dGFibGUgaW5pdGlhbF9zaXplOiBpbnQ7ICAgICAgICAgICAgICAgICgqIGluaXRpYWwgYXJyYXkgc2l6ZSAqKVxuICB9XG5cbmFuZCAoJ2EsICdiKSBidWNrZXRsaXN0ID1cbiAgICBFbXB0eVxuICB8IENvbnMgb2YgeyBtdXRhYmxlIGtleTogJ2E7XG4gICAgICAgICAgICAgIG11dGFibGUgZGF0YTogJ2I7XG4gICAgICAgICAgICAgIG11dGFibGUgbmV4dDogKCdhLCAnYikgYnVja2V0bGlzdCB9XG5cbigqIFRoZSBzaWduIG9mIGluaXRpYWxfc2l6ZSBlbmNvZGVzIHRoZSBmYWN0IHRoYXQgYSB0cmF2ZXJzYWwgaXNcbiAgIG9uZ29pbmcgb3Igbm90LlxuXG4gICBUaGlzIGRpc2FibGVzIHRoZSBlZmZpY2llbnQgaW4gcGxhY2UgaW1wbGVtZW50YXRpb24gb2YgcmVzaXppbmcuXG4qKVxuXG5sZXQgb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICB8fCBoLmluaXRpYWxfc2l6ZSA8IDBcblxubGV0IGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaCA9XG4gIGguaW5pdGlhbF9zaXplIDwtIC0gaC5pbml0aWFsX3NpemVcblxuKCogVG8gcGljayByYW5kb20gc2VlZHMgaWYgcmVxdWVzdGVkICopXG5cbmxldCByYW5kb21pemVkX2RlZmF1bHQgPVxuICBsZXQgcGFyYW1zID1cbiAgICB0cnkgU3lzLmdldGVudiBcIk9DQU1MUlVOUEFSQU1cIiB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIHRyeSBTeXMuZ2V0ZW52IFwiQ0FNTFJVTlBBUkFNXCIgd2l0aCBOb3RfZm91bmQgLT4gXCJcIiBpblxuICBTdHJpbmcuY29udGFpbnMgcGFyYW1zICdSJ1xuXG5sZXQgcmFuZG9taXplZCA9IHJlZiByYW5kb21pemVkX2RlZmF1bHRcblxubGV0IHJhbmRvbWl6ZSAoKSA9IHJhbmRvbWl6ZWQgOj0gdHJ1ZVxubGV0IGlzX3JhbmRvbWl6ZWQgKCkgPSAhcmFuZG9taXplZFxuXG5sZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4oKiBGdW5jdGlvbnMgd2hpY2ggYXBwZWFyIGJlZm9yZSB0aGUgZnVuY3RvcmlhbCBpbnRlcmZhY2UgbXVzdCBlaXRoZXIgYmVcbiAgIGluZGVwZW5kZW50IG9mIHRoZSBoYXNoIGZ1bmN0aW9uIG9yIHRha2UgaXQgYXMgYSBwYXJhbWV0ZXIgKHNlZSAjMjIwMiBhbmRcbiAgIGNvZGUgYmVsb3cgdGhlIGZ1bmN0b3IgZGVmaW5pdGlvbnMuICopXG5cbigqIENyZWF0aW5nIGEgZnJlc2gsIGVtcHR5IHRhYmxlICopXG5cbmxldCByZWMgcG93ZXJfMl9hYm92ZSB4IG4gPVxuICBpZiB4ID49IG4gdGhlbiB4XG4gIGVsc2UgaWYgeCAqIDIgPiBTeXMubWF4X2FycmF5X2xlbmd0aCB0aGVuIHhcbiAgZWxzZSBwb3dlcl8yX2Fib3ZlICh4ICogMikgblxuXG5sZXQgY3JlYXRlID8ocmFuZG9tID0gIXJhbmRvbWl6ZWQpIGluaXRpYWxfc2l6ZSA9XG4gIGxldCBzID0gcG93ZXJfMl9hYm92ZSAxNiBpbml0aWFsX3NpemUgaW5cbiAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgeyBpbml0aWFsX3NpemUgPSBzOyBzaXplID0gMDsgc2VlZCA9IHNlZWQ7IGRhdGEgPSBBcnJheS5tYWtlIHMgRW1wdHkgfVxuXG5sZXQgY2xlYXIgaCA9XG4gIGlmIGguc2l6ZSA+IDAgdGhlbiBiZWdpblxuICAgIGguc2l6ZSA8LSAwO1xuICAgIEFycmF5LmZpbGwgaC5kYXRhIDAgKEFycmF5Lmxlbmd0aCBoLmRhdGEpIEVtcHR5XG4gIGVuZFxuXG5sZXQgcmVzZXQgaCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA8IDQgKCogY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBoYXNoIHRhYmxlcyAqKVxuICAgIHx8IGxlbiA9IGFicyBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgY2xlYXIgaFxuICBlbHNlIGJlZ2luXG4gICAgaC5zaXplIDwtIDA7XG4gICAgaC5kYXRhIDwtIEFycmF5Lm1ha2UgKGFicyBoLmluaXRpYWxfc2l6ZSkgRW1wdHlcbiAgZW5kXG5cbmxldCBjb3B5X2J1Y2tldGxpc3QgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IEVtcHR5XG4gIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgbGV0IHJlYyBsb29wIHByZWMgPSBmdW5jdGlvblxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB7a2V5OyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IENvbnMgcHJlYyAtPiAgcHJlYy5uZXh0IDwtIHJcbiAgICAgICAgICAgIGVuZDtcbiAgICAgICAgICAgIGxvb3AgciBuZXh0XG4gICAgICBpblxuICAgICAgbGV0IHIgPSBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGluXG4gICAgICBsb29wIHIgbmV4dDtcbiAgICAgIHJcblxubGV0IGNvcHkgaCA9IHsgaCB3aXRoIGRhdGEgPSBBcnJheS5tYXAgY29weV9idWNrZXRsaXN0IGguZGF0YSB9XG5cbmxldCBsZW5ndGggaCA9IGguc2l6ZVxuXG5sZXQgcmVzaXplIGluZGV4ZnVuIGggPVxuICBsZXQgb2RhdGEgPSBoLmRhdGEgaW5cbiAgbGV0IG9zaXplID0gQXJyYXkubGVuZ3RoIG9kYXRhIGluXG4gIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICBpZiBuc2l6ZSA8IFN5cy5tYXhfYXJyYXlfbGVuZ3RoIHRoZW4gYmVnaW5cbiAgICBsZXQgbmRhdGEgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IG5kYXRhX3RhaWwgPSBBcnJheS5tYWtlIG5zaXplIEVtcHR5IGluXG4gICAgbGV0IGlucGxhY2UgPSBub3QgKG9uZ29pbmdfdHJhdmVyc2FsIGgpIGluXG4gICAgaC5kYXRhIDwtIG5kYXRhOyAgICAgICAgICAoKiBzbyB0aGF0IGluZGV4ZnVuIHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICBsZXQgcmVjIGluc2VydF9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiAoKVxuICAgICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IGFzIGNlbGwgLT5cbiAgICAgICAgICBsZXQgY2VsbCA9XG4gICAgICAgICAgICBpZiBpbnBsYWNlIHRoZW4gY2VsbFxuICAgICAgICAgICAgZWxzZSBDb25zIHtrZXk7IGRhdGE7IG5leHQgPSBFbXB0eX1cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBuaWR4ID0gaW5kZXhmdW4gaCBrZXkgaW5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBuZGF0YV90YWlsLihuaWR4KSB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBuZGF0YS4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICB8IENvbnMgdGFpbCAtPiB0YWlsLm5leHQgPC0gY2VsbDtcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbmRhdGFfdGFpbC4obmlkeCkgPC0gY2VsbDtcbiAgICAgICAgICBpbnNlcnRfYnVja2V0IG5leHRcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBvc2l6ZSAtIDEgZG9cbiAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBpbnBsYWNlIHRoZW5cbiAgICAgIGZvciBpID0gMCB0byBuc2l6ZSAtIDEgZG9cbiAgICAgICAgbWF0Y2ggbmRhdGFfdGFpbC4oaSkgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+ICgpXG4gICAgICAgIHwgQ29ucyB0YWlsIC0+IHRhaWwubmV4dCA8LSBFbXB0eVxuICAgICAgZG9uZTtcbiAgZW5kXG5cbmxldCBpdGVyIGYgaCA9XG4gIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+XG4gICAgICAgICgpXG4gICAgfCBDb25ze2tleTsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgZiBrZXkgZGF0YTsgZG9fYnVja2V0IG5leHQgaW5cbiAgbGV0IG9sZF90cmF2ID0gb25nb2luZ190cmF2ZXJzYWwgaCBpblxuICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHRyeVxuICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZG9fYnVja2V0IGQuKGkpXG4gICAgZG9uZTtcbiAgICBpZiBub3Qgb2xkX3RyYXYgdGhlbiBmbGlwX29uZ29pbmdfdHJhdmVyc2FsIGg7XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG5sZXQgcmVjIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgcHJlYyA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIGJlZ2luIG1hdGNoIHByZWMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIEVtcHR5XG4gICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gRW1wdHlcbiAgICAgIGVuZFxuICB8IChDb25zICh7a2V5OyBkYXRhOyBuZXh0fSBhcyBjKSkgYXMgc2xvdCAtPlxuICAgICAgYmVnaW4gbWF0Y2ggZiBrZXkgZGF0YSB3aXRoXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgICBoLnNpemUgPC0gaC5zaXplIC0gMTtcbiAgICAgICAgICBmaWx0ZXJfbWFwX2lucGxhY2VfYnVja2V0IGYgaCBpIHByZWMgbmV4dFxuICAgICAgfCBTb21lIGRhdGEgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IGguZGF0YS4oaSkgPC0gc2xvdFxuICAgICAgICAgIHwgQ29ucyBjIC0+IGMubmV4dCA8LSBzbG90XG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGMuZGF0YSA8LSBkYXRhO1xuICAgICAgICAgIGZpbHRlcl9tYXBfaW5wbGFjZV9idWNrZXQgZiBoIGkgc2xvdCBuZXh0XG4gICAgICBlbmRcblxubGV0IGZpbHRlcl9tYXBfaW5wbGFjZSBmIGggPVxuICBsZXQgZCA9IGguZGF0YSBpblxuICBsZXQgb2xkX3RyYXYgPSBvbmdvaW5nX3RyYXZlcnNhbCBoIGluXG4gIGlmIG5vdCBvbGRfdHJhdiB0aGVuIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgdHJ5XG4gICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgZmlsdGVyX21hcF9pbnBsYWNlX2J1Y2tldCBmIGggaSBFbXB0eSBoLmRhdGEuKGkpXG4gICAgZG9uZVxuICB3aXRoIGV4biB3aGVuIG5vdCBvbGRfdHJhdiAtPlxuICAgIGZsaXBfb25nb2luZ190cmF2ZXJzYWwgaDtcbiAgICByYWlzZSBleG5cblxubGV0IGZvbGQgZiBoIGluaXQgPVxuICBsZXQgcmVjIGRvX2J1Y2tldCBiIGFjY3UgPVxuICAgIG1hdGNoIGIgd2l0aFxuICAgICAgRW1wdHkgLT5cbiAgICAgICAgYWNjdVxuICAgIHwgQ29uc3trZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIGRvX2J1Y2tldCBuZXh0IChmIGtleSBkYXRhIGFjY3UpIGluXG4gIGxldCBvbGRfdHJhdiA9IG9uZ29pbmdfdHJhdmVyc2FsIGggaW5cbiAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICB0cnlcbiAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgIGxldCBhY2N1ID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgIGRvbmU7XG4gICAgaWYgbm90IG9sZF90cmF2IHRoZW4gZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgICFhY2N1XG4gIHdpdGggZXhuIHdoZW4gbm90IG9sZF90cmF2IC0+XG4gICAgZmxpcF9vbmdvaW5nX3RyYXZlcnNhbCBoO1xuICAgIHJhaXNlIGV4blxuXG50eXBlIHN0YXRpc3RpY3MgPSB7XG4gIG51bV9iaW5kaW5nczogaW50O1xuICBudW1fYnVja2V0czogaW50O1xuICBtYXhfYnVja2V0X2xlbmd0aDogaW50O1xuICBidWNrZXRfaGlzdG9ncmFtOiBpbnQgYXJyYXlcbn1cblxubGV0IHJlYyBidWNrZXRfbGVuZ3RoIGFjY3UgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IGFjY3VcbiAgfCBDb25ze25leHR9IC0+IGJ1Y2tldF9sZW5ndGggKGFjY3UgKyAxKSBuZXh0XG5cbmxldCBzdGF0cyBoID1cbiAgbGV0IG1ibCA9XG4gICAgQXJyYXkuZm9sZF9sZWZ0IChmdW4gbSBiIC0+IG1heCBtIChidWNrZXRfbGVuZ3RoIDAgYikpIDAgaC5kYXRhIGluXG4gIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgQXJyYXkuaXRlclxuICAgIChmdW4gYiAtPlxuICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgaGlzdG8uKGwpIDwtIGhpc3RvLihsKSArIDEpXG4gICAgaC5kYXRhO1xuICB7IG51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICBudW1fYnVja2V0cyA9IEFycmF5Lmxlbmd0aCBoLmRhdGE7XG4gICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuKCoqIHsxIEl0ZXJhdG9yc30gKilcblxubGV0IHRvX3NlcSB0YmwgPVxuICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICBrZWVwIGl0ZXJhdGluZyBvbiB0aGUgc2FtZSBhcnJheSAqKVxuICBsZXQgdGJsX2RhdGEgPSB0YmwuZGF0YSBpblxuICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICBsZXQgcmVjIGF1eCBpIGJ1Y2sgKCkgPSBtYXRjaCBidWNrIHdpdGhcbiAgICB8IEVtcHR5IC0+XG4gICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgdGhlbiBTZXEuTmlsXG4gICAgICAgIGVsc2UgYXV4KGkrMSkgdGJsX2RhdGEuKGkpICgpXG4gICAgfCBDb25zIHtrZXk7IGRhdGE7IG5leHR9IC0+XG4gICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgaW5cbiAgYXV4IDAgRW1wdHlcblxubGV0IHRvX3NlcV9rZXlzIG0gPSBTZXEubWFwIGZzdCAodG9fc2VxIG0pXG5cbmxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbigqIEZ1bmN0b3JpYWwgaW50ZXJmYWNlICopXG5cbm1vZHVsZSB0eXBlIEhhc2hlZFR5cGUgPVxuICBzaWdcbiAgICB0eXBlIHRcbiAgICB2YWwgZXF1YWw6IHQgLT4gdCAtPiBib29sXG4gICAgdmFsIGhhc2g6IHQgLT4gaW50XG4gIGVuZFxuXG5tb2R1bGUgdHlwZSBTZWVkZWRIYXNoZWRUeXBlID1cbiAgc2lnXG4gICAgdHlwZSB0XG4gICAgdmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgJ2EgdFxuICAgIHZhbCBjcmVhdGU6IGludCAtPiAnYSB0XG4gICAgdmFsIGNsZWFyIDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIHJlc2V0IDogJ2EgdCAtPiB1bml0XG4gICAgdmFsIGNvcHk6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQ6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgcmVtb3ZlOiAnYSB0IC0+IGtleSAtPiB1bml0XG4gICAgdmFsIGZpbmQ6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGw6ICdhIHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgICB2YWwgcmVwbGFjZSA6ICdhIHQgLT4ga2V5IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgbWVtIDogJ2EgdCAtPiBrZXkgLT4gYm9vbFxuICAgIHZhbCBpdGVyOiAoa2V5IC0+ICdhIC0+IHVuaXQpIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmaWx0ZXJfbWFwX2lucGxhY2U6IChrZXkgLT4gJ2EgLT4gJ2Egb3B0aW9uKSAtPiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgZm9sZDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGg6ICdhIHQgLT4gaW50XG4gICAgdmFsIHN0YXRzOiAnYSB0IC0+IHN0YXRpc3RpY3NcbiAgICB2YWwgdG9fc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50XG4gICAgdmFsIHRvX3NlcV9rZXlzIDogXyB0IC0+IGtleSBTZXEudFxuICAgIHZhbCB0b19zZXFfdmFsdWVzIDogJ2EgdCAtPiAnYSBTZXEudFxuICAgIHZhbCBhZGRfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgcmVwbGFjZV9zZXEgOiAnYSB0IC0+IChrZXkgKiAnYSkgU2VxLnQgLT4gdW5pdFxuICAgIHZhbCBvZl9zZXEgOiAoa2V5ICogJ2EpIFNlcS50IC0+ICdhIHRcbiAgZW5kXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPVxuICBzaWdcbiAgICB0eXBlIGtleVxuICAgIHR5cGUgJ2EgdFxuICAgIHZhbCBjcmVhdGUgOiA/cmFuZG9tOmJvb2wgLT4gaW50IC0+ICdhIHRcbiAgICB2YWwgY2xlYXIgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgcmVzZXQgOiAnYSB0IC0+IHVuaXRcbiAgICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCBhZGQgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIHJlbW92ZSA6ICdhIHQgLT4ga2V5IC0+IHVuaXRcbiAgICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhXG4gICAgdmFsIGZpbmRfb3B0OiAnYSB0IC0+IGtleSAtPiAnYSBvcHRpb25cbiAgICB2YWwgZmluZF9hbGwgOiAnYSB0IC0+IGtleSAtPiAnYSBsaXN0XG4gICAgdmFsIHJlcGxhY2UgOiAnYSB0IC0+IGtleSAtPiAnYSAtPiB1bml0XG4gICAgdmFsIG1lbSA6ICdhIHQgLT4ga2V5IC0+IGJvb2xcbiAgICB2YWwgaXRlciA6IChrZXkgLT4gJ2EgLT4gdW5pdCkgLT4gJ2EgdCAtPiB1bml0XG4gICAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZTogKGtleSAtPiAnYSAtPiAnYSBvcHRpb24pIC0+ICdhIHQgLT4gdW5pdFxuICAgIHZhbCBmb2xkIDogKGtleSAtPiAnYSAtPiAnYiAtPiAnYikgLT4gJ2EgdCAtPiAnYiAtPiAnYlxuICAgIHZhbCBsZW5ndGggOiAnYSB0IC0+IGludFxuICAgIHZhbCBzdGF0czogJ2EgdCAtPiBzdGF0aXN0aWNzXG4gICAgdmFsIHRvX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudFxuICAgIHZhbCB0b19zZXFfa2V5cyA6IF8gdCAtPiBrZXkgU2VxLnRcbiAgICB2YWwgdG9fc2VxX3ZhbHVlcyA6ICdhIHQgLT4gJ2EgU2VxLnRcbiAgICB2YWwgYWRkX3NlcSA6ICdhIHQgLT4gKGtleSAqICdhKSBTZXEudCAtPiB1bml0XG4gICAgdmFsIHJlcGxhY2Vfc2VxIDogJ2EgdCAtPiAoa2V5ICogJ2EpIFNlcS50IC0+IHVuaXRcbiAgICB2YWwgb2Zfc2VxIDogKGtleSAqICdhKSBTZXEudCAtPiAnYSB0XG4gIGVuZFxuXG5tb2R1bGUgTWFrZVNlZWRlZChIOiBTZWVkZWRIYXNoZWRUeXBlKTogKFNlZWRlZFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICB0eXBlIGtleSA9IEgudFxuICAgIHR5cGUgJ2EgaGFzaHRibCA9IChrZXksICdhKSB0XG4gICAgdHlwZSAnYSB0ID0gJ2EgaGFzaHRibFxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVcbiAgICBsZXQgY2xlYXIgPSBjbGVhclxuICAgIGxldCByZXNldCA9IHJlc2V0XG4gICAgbGV0IGNvcHkgPSBjb3B5XG5cbiAgICBsZXQga2V5X2luZGV4IGgga2V5ID1cbiAgICAgIChILmhhc2ggaC5zZWVkIGtleSkgbGFuZCAoQXJyYXkubGVuZ3RoIGguZGF0YSAtIDEpXG5cbiAgICBsZXQgYWRkIGgga2V5IGRhdGEgPVxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBrZXkgaW5cbiAgICAgIGxldCBidWNrZXQgPSBDb25ze2tleTsgZGF0YTsgbmV4dD1oLmRhdGEuKGkpfSBpblxuICAgICAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUga2V5X2luZGV4IGhcblxuICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICgpXG4gICAgICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiBiZWdpblxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgICAgIHwgRW1wdHkgLT4gaC5kYXRhLihpKSA8LSBuZXh0XG4gICAgICAgICAgICB8IENvbnMgYyAtPiBjLm5leHQgPC0gbmV4dFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2UgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IGMgbmV4dFxuXG4gICAgbGV0IHJlbW92ZSBoIGtleSA9XG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICAgICAgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IEVtcHR5IGguZGF0YS4oaSlcblxuICAgIGxldCByZWMgZmluZF9yZWMga2V5ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YTsgbmV4dH0gLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGtleSBrIHRoZW4gZGF0YSBlbHNlIGZpbmRfcmVjIGtleSBuZXh0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazEgdGhlbiBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICAgICAgaWYgSC5lcXVhbCBrZXkgazIgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICAgICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGszIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxuICAgIGxldCByZWMgZmluZF9yZWNfb3B0IGtleSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgTm9uZVxuICAgICAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsgdGhlbiBTb21lIGRhdGEgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHRcblxuICAgIGxldCBmaW5kX29wdCBoIGtleSA9XG4gICAgICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsxOyBkYXRhPWQxOyBuZXh0PW5leHQxfSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsxIHRoZW4gU29tZSBkMSBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgICAgICAgIHwgQ29uc3trZXk9azI7IGRhdGE9ZDI7IG5leHQ9bmV4dDJ9IC0+XG4gICAgICAgICAgICAgIGlmIEguZXF1YWwga2V5IGsyIHRoZW4gU29tZSBkMiBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICAgICAgICAgIHwgQ29uc3trZXk9azM7IGRhdGE9ZDM7IG5leHQ9bmV4dDN9IC0+XG4gICAgICAgICAgICAgICAgICBpZiBILmVxdWFsIGtleSBrMyB0aGVuIFNvbWUgZDMgZWxzZSBmaW5kX3JlY19vcHQga2V5IG5leHQzXG5cbiAgICBsZXQgZmluZF9hbGwgaCBrZXkgPVxuICAgICAgbGV0IHJlYyBmaW5kX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgW11cbiAgICAgIHwgQ29uc3trZXk9azsgZGF0YT1kOyBuZXh0fSAtPlxuICAgICAgICAgIGlmIEguZXF1YWwgayBrZXlcbiAgICAgICAgICB0aGVuIGQgOjogZmluZF9pbl9idWNrZXQgbmV4dFxuICAgICAgICAgIGVsc2UgZmluZF9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbiAgICBsZXQgcmVjIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICB0cnVlXG4gICAgICB8IENvbnMgKHtrZXk9azsgbmV4dH0gYXMgc2xvdCkgLT5cbiAgICAgICAgICBpZiBILmVxdWFsIGsga2V5XG4gICAgICAgICAgdGhlbiAoc2xvdC5rZXkgPC0ga2V5OyBzbG90LmRhdGEgPC0gZGF0YTsgZmFsc2UpXG4gICAgICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbiAgICBsZXQgcmVwbGFjZSBoIGtleSBkYXRhID1cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGgga2V5IGluXG4gICAgICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgICAgIGlmIHJlcGxhY2VfYnVja2V0IGtleSBkYXRhIGwgdGhlbiBiZWdpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnN7a2V5OyBkYXRhOyBuZXh0PWx9O1xuICAgICAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBrZXlfaW5kZXggaFxuICAgICAgZW5kXG5cbiAgICBsZXQgbWVtIGgga2V5ID1cbiAgICAgIGxldCByZWMgbWVtX2luX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIHwgQ29uc3trZXk9azsgbmV4dH0gLT5cbiAgICAgICAgICBILmVxdWFsIGsga2V5IHx8IG1lbV9pbl9idWNrZXQgbmV4dCBpblxuICAgICAgbWVtX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSlcblxuICAgIGxldCBhZGRfc2VxIHRibCBpID1cbiAgICAgIFNlcS5pdGVyIChmdW4gKGssdikgLT4gYWRkIHRibCBrIHYpIGlcblxuICAgIGxldCByZXBsYWNlX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG5cbiAgICBsZXQgaXRlciA9IGl0ZXJcbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBzdGF0cyA9IHN0YXRzXG4gICAgbGV0IHRvX3NlcSA9IHRvX3NlcVxuICAgIGxldCB0b19zZXFfa2V5cyA9IHRvX3NlcV9rZXlzXG4gICAgbGV0IHRvX3NlcV92YWx1ZXMgPSB0b19zZXFfdmFsdWVzXG4gIGVuZFxuXG5tb2R1bGUgTWFrZShIOiBIYXNoZWRUeXBlKTogKFMgd2l0aCB0eXBlIGtleSA9IEgudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWQoc3RydWN0XG4gICAgICAgIHR5cGUgdCA9IEgudFxuICAgICAgICBsZXQgZXF1YWwgPSBILmVxdWFsXG4gICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSC5oYXNoIHhcbiAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbigqIFBvbHltb3JwaGljIGhhc2ggZnVuY3Rpb24tYmFzZWQgdGFibGVzICopXG4oKiBDb2RlIGluY2x1ZGVkIGJlbG93IHRoZSBmdW5jdG9yaWFsIGludGVyZmFjZSB0byBndWFyZCBhZ2FpbnN0IGFjY2lkZW50YWxcbiAgIHVzZSAtIHNlZSAjMjIwMiAqKVxuXG5leHRlcm5hbCBzZWVkZWRfaGFzaF9wYXJhbSA6XG4gIGludCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IGludCA9IFwiY2FtbF9oYXNoXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIG9sZF9oYXNoX3BhcmFtIDpcbiAgaW50IC0+IGludCAtPiAnYSAtPiBpbnQgPSBcImNhbWxfaGFzaF91bml2X3BhcmFtXCIgW0BAbm9hbGxvY11cblxubGV0IGhhc2ggeCA9IHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCAwIHhcbmxldCBoYXNoX3BhcmFtIG4xIG4yIHggPSBzZWVkZWRfaGFzaF9wYXJhbSBuMSBuMiAwIHhcbmxldCBzZWVkZWRfaGFzaCBzZWVkIHggPSBzZWVkZWRfaGFzaF9wYXJhbSAxMCAxMDAgc2VlZCB4XG5cbmxldCBrZXlfaW5kZXggaCBrZXkgPVxuICAoKiBjb21wYXRpYmlsaXR5IHdpdGggb2xkIGhhc2ggdGFibGVzICopXG4gIGlmIE9iai5zaXplIChPYmoucmVwciBoKSA+PSAzXG4gIHRoZW4gKHNlZWRlZF9oYXNoX3BhcmFtIDEwIDEwMCBoLnNlZWQga2V5KSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcbiAgZWxzZSAob2xkX2hhc2hfcGFyYW0gMTAgMTAwIGtleSkgbW9kIChBcnJheS5sZW5ndGggaC5kYXRhKVxuXG5sZXQgYWRkIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgYnVja2V0ID0gQ29uc3trZXk7IGRhdGE7IG5leHQ9aC5kYXRhLihpKX0gaW5cbiAgaC5kYXRhLihpKSA8LSBidWNrZXQ7XG4gIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG5cbmxldCByZWMgcmVtb3ZlX2J1Y2tldCBoIGkga2V5IHByZWMgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICAoKVxuICB8IChDb25zIHtrZXk9azsgbmV4dH0pIGFzIGMgLT5cbiAgICAgIGlmIGNvbXBhcmUgayBrZXkgPSAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGguc2l6ZSA8LSBoLnNpemUgLSAxO1xuICAgICAgICBtYXRjaCBwcmVjIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiBoLmRhdGEuKGkpIDwtIG5leHRcbiAgICAgICAgfCBDb25zIGMgLT4gYy5uZXh0IDwtIG5leHRcbiAgICAgIGVuZFxuICAgICAgZWxzZSByZW1vdmVfYnVja2V0IGggaSBrZXkgYyBuZXh0XG5cbmxldCByZW1vdmUgaCBrZXkgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICByZW1vdmVfYnVja2V0IGggaSBrZXkgRW1wdHkgaC5kYXRhLihpKVxuXG5sZXQgcmVjIGZpbmRfcmVjIGtleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT5cbiAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIGRhdGEgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dFxuXG5sZXQgZmluZCBoIGtleSA9XG4gIG1hdGNoIGguZGF0YS4oa2V5X2luZGV4IGgga2V5KSB3aXRoXG4gIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gIHwgQ29uc3trZXk9azE7IGRhdGE9ZDE7IG5leHQ9bmV4dDF9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrMSA9IDAgdGhlbiBkMSBlbHNlXG4gICAgICBtYXRjaCBuZXh0MSB3aXRoXG4gICAgICB8IEVtcHR5IC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25ze2tleT1rMjsgZGF0YT1kMjsgbmV4dD1uZXh0Mn0gLT5cbiAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMiA9IDAgdGhlbiBkMiBlbHNlXG4gICAgICAgICAgbWF0Y2ggbmV4dDIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgICAgfCBDb25ze2tleT1rMzsgZGF0YT1kMzsgbmV4dD1uZXh0M30gLT5cbiAgICAgICAgICAgICAgaWYgY29tcGFyZSBrZXkgazMgPSAwIHRoZW4gZDMgZWxzZSBmaW5kX3JlYyBrZXkgbmV4dDNcblxubGV0IHJlYyBmaW5kX3JlY19vcHQga2V5ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgTm9uZVxuICB8IENvbnN7a2V5PWs7IGRhdGE7IG5leHR9IC0+XG4gICAgICBpZiBjb21wYXJlIGtleSBrID0gMCB0aGVuIFNvbWUgZGF0YSBlbHNlIGZpbmRfcmVjX29wdCBrZXkgbmV4dFxuXG5sZXQgZmluZF9vcHQgaCBrZXkgPVxuICBtYXRjaCBoLmRhdGEuKGtleV9pbmRleCBoIGtleSkgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBDb25ze2tleT1rMTsgZGF0YT1kMTsgbmV4dD1uZXh0MX0gLT5cbiAgICAgIGlmIGNvbXBhcmUga2V5IGsxID0gMCB0aGVuIFNvbWUgZDEgZWxzZVxuICAgICAgbWF0Y2ggbmV4dDEgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBOb25lXG4gICAgICB8IENvbnN7a2V5PWsyOyBkYXRhPWQyOyBuZXh0PW5leHQyfSAtPlxuICAgICAgICAgIGlmIGNvbXBhcmUga2V5IGsyID0gMCB0aGVuIFNvbWUgZDIgZWxzZVxuICAgICAgICAgIG1hdGNoIG5leHQyIHdpdGhcbiAgICAgICAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICAgICAgICB8IENvbnN7a2V5PWszOyBkYXRhPWQzOyBuZXh0PW5leHQzfSAtPlxuICAgICAgICAgICAgICBpZiBjb21wYXJlIGtleSBrMyA9IDAgdGhlbiBTb21lIGQzIGVsc2UgZmluZF9yZWNfb3B0IGtleSBuZXh0M1xuXG5sZXQgZmluZF9hbGwgaCBrZXkgPVxuICBsZXQgcmVjIGZpbmRfaW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgW11cbiAgfCBDb25ze2tleT1rOyBkYXRhOyBuZXh0fSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gZGF0YSA6OiBmaW5kX2luX2J1Y2tldCBuZXh0XG4gICAgICBlbHNlIGZpbmRfaW5fYnVja2V0IG5leHQgaW5cbiAgZmluZF9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCByZWMgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+XG4gICAgICB0cnVlXG4gIHwgQ29ucyAoe2tleT1rOyBuZXh0fSBhcyBzbG90KSAtPlxuICAgICAgaWYgY29tcGFyZSBrIGtleSA9IDBcbiAgICAgIHRoZW4gKHNsb3Qua2V5IDwtIGtleTsgc2xvdC5kYXRhIDwtIGRhdGE7IGZhbHNlKVxuICAgICAgZWxzZSByZXBsYWNlX2J1Y2tldCBrZXkgZGF0YSBuZXh0XG5cbmxldCByZXBsYWNlIGgga2V5IGRhdGEgPVxuICBsZXQgaSA9IGtleV9pbmRleCBoIGtleSBpblxuICBsZXQgbCA9IGguZGF0YS4oaSkgaW5cbiAgaWYgcmVwbGFjZV9idWNrZXQga2V5IGRhdGEgbCB0aGVuIGJlZ2luXG4gICAgaC5kYXRhLihpKSA8LSBDb25ze2tleTsgZGF0YTsgbmV4dD1sfTtcbiAgICBoLnNpemUgPC0gaC5zaXplICsgMTtcbiAgICBpZiBoLnNpemUgPiBBcnJheS5sZW5ndGggaC5kYXRhIGxzbCAxIHRoZW4gcmVzaXplIGtleV9pbmRleCBoXG4gIGVuZFxuXG5sZXQgbWVtIGgga2V5ID1cbiAgbGV0IHJlYyBtZW1faW5fYnVja2V0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPlxuICAgICAgZmFsc2VcbiAgfCBDb25ze2tleT1rOyBuZXh0fSAtPlxuICAgICAgY29tcGFyZSBrIGtleSA9IDAgfHwgbWVtX2luX2J1Y2tldCBuZXh0IGluXG4gIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBrZXkpXG5cbmxldCBhZGRfc2VxIHRibCBpID1cbiAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiBhZGQgdGJsIGsgdikgaVxuXG5sZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IHJlcGxhY2UgdGJsIGsgdikgaVxuXG5sZXQgb2Zfc2VxIGkgPVxuICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gIHJlcGxhY2Vfc2VxIHRibCBpO1xuICB0YmxcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIERhbWllbiBEb2xpZ2V6LCBwcm9qZXQgUGFyYSwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTcgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCoqIFdlYWsgYXJyYXkgb3BlcmF0aW9ucyAqKVxuXG50eXBlICdhIHRcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+ICdhIHQgPSBcImNhbWxfd2Vha19jcmVhdGVcIlxuXG5sZXQgY3JlYXRlIGwgPVxuICBpZiBub3QgKDAgPD0gbCAmJiBsIDw9IE9iai5FcGhlbWVyb24ubWF4X2VwaGVfbGVuZ3RoKSB0aGVuXG4gICAgaW52YWxpZF9hcmcoXCJXZWFrLmNyZWF0ZVwiKTtcbiAgY3JlYXRlIGxcblxuKCoqIG51bWJlciBvZiBhZGRpdGlvbmFsIHZhbHVlcyBpbiBhIHdlYWsgcG9pbnRlciAqKVxubGV0IGFkZGl0aW9uYWxfdmFsdWVzID0gMlxuXG5sZXQgbGVuZ3RoIHggPSBPYmouc2l6ZShPYmoucmVwciB4KSAtIGFkZGl0aW9uYWxfdmFsdWVzXG5cbmxldCByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gbXNnID1cbiAgaWYgbm90ICgwIDw9IG8gJiYgbyA8IGxlbmd0aCBlKSB0aGVuXG4gICAgaW52YWxpZF9hcmcobXNnKVxuXG5leHRlcm5hbCBzZXQnIDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiY2FtbF9lcGhlX3NldF9rZXlcIlxuZXh0ZXJuYWwgdW5zZXQgOiAnYSB0IC0+IGludCAtPiB1bml0ID0gXCJjYW1sX2VwaGVfdW5zZXRfa2V5XCJcbmxldCBzZXQgZSBvIHggPVxuICByYWlzZV9pZl9pbnZhbGlkX29mZnNldCBlIG8gXCJXZWFrLnNldFwiO1xuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHVuc2V0IGUgb1xuICB8IFNvbWUgeCAtPiBzZXQnIGUgbyB4XG5cbmV4dGVybmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvbiA9IFwiY2FtbF93ZWFrX2dldFwiXG5sZXQgZ2V0IGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuZ2V0XCI7XG4gIGdldCBlIG9cblxuZXh0ZXJuYWwgZ2V0X2NvcHkgOiAnYSB0IC0+IGludCAtPiAnYSBvcHRpb24gPSBcImNhbWxfd2Vha19nZXRfY29weVwiXG5sZXQgZ2V0X2NvcHkgZSBvID1cbiAgcmFpc2VfaWZfaW52YWxpZF9vZmZzZXQgZSBvIFwiV2Vhay5nZXRfY29weVwiO1xuICBnZXRfY29weSBlIG9cblxuZXh0ZXJuYWwgY2hlY2sgOiAnYSB0IC0+IGludCAtPiBib29sID0gXCJjYW1sX3dlYWtfY2hlY2tcIlxubGV0IGNoZWNrIGUgbyA9XG4gIHJhaXNlX2lmX2ludmFsaWRfb2Zmc2V0IGUgbyBcIldlYWsuY2hlY2tcIjtcbiAgY2hlY2sgZSBvXG5cbmV4dGVybmFsIGJsaXQgOiAnYSB0IC0+IGludCAtPiAnYSB0IC0+IGludCAtPiBpbnQgLT4gdW5pdCA9IFwiY2FtbF93ZWFrX2JsaXRcIlxuXG4oKiBibGl0OiBzcmMgc3Jjb2ZmIGRzdCBkc3RvZmYgbGVuICopXG5sZXQgYmxpdCBlMSBvMSBlMiBvMiBsID1cbiAgaWYgbCA8IDAgfHwgbzEgPCAwIHx8IG8xID4gbGVuZ3RoIGUxIC0gbFxuICAgICB8fCBvMiA8IDAgfHwgbzIgPiBsZW5ndGggZTIgLSBsXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJXZWFrLmJsaXRcIlxuICBlbHNlIGlmIGwgPD4gMCB0aGVuIGJsaXQgZTEgbzEgZTIgbzIgbFxuXG5sZXQgZmlsbCBhciBvZnMgbGVuIHggPVxuICBpZiBvZnMgPCAwIHx8IGxlbiA8IDAgfHwgb2ZzID4gbGVuZ3RoIGFyIC0gbGVuXG4gIHRoZW4gcmFpc2UgKEludmFsaWRfYXJndW1lbnQgXCJXZWFrLmZpbGxcIilcbiAgZWxzZSBiZWdpblxuICAgIGZvciBpID0gb2ZzIHRvIChvZnMgKyBsZW4gLSAxKSBkb1xuICAgICAgc2V0IGFyIGkgeFxuICAgIGRvbmVcbiAgZW5kXG5cblxuKCoqIFdlYWsgaGFzaCB0YWJsZXMgKilcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIGRhdGFcbiAgdHlwZSB0XG4gIHZhbCBjcmVhdGUgOiBpbnQgLT4gdFxuICB2YWwgY2xlYXIgOiB0IC0+IHVuaXRcbiAgdmFsIG1lcmdlIDogdCAtPiBkYXRhIC0+IGRhdGFcbiAgdmFsIGFkZCA6IHQgLT4gZGF0YSAtPiB1bml0XG4gIHZhbCByZW1vdmUgOiB0IC0+IGRhdGEgLT4gdW5pdFxuICB2YWwgZmluZCA6IHQgLT4gZGF0YSAtPiBkYXRhXG4gIHZhbCBmaW5kX29wdCA6IHQgLT4gZGF0YSAtPiBkYXRhIG9wdGlvblxuICB2YWwgZmluZF9hbGwgOiB0IC0+IGRhdGEgLT4gZGF0YSBsaXN0XG4gIHZhbCBtZW0gOiB0IC0+IGRhdGEgLT4gYm9vbFxuICB2YWwgaXRlciA6IChkYXRhIC0+IHVuaXQpIC0+IHQgLT4gdW5pdFxuICB2YWwgZm9sZCA6IChkYXRhIC0+ICdhIC0+ICdhKSAtPiB0IC0+ICdhIC0+ICdhXG4gIHZhbCBjb3VudCA6IHQgLT4gaW50XG4gIHZhbCBzdGF0cyA6IHQgLT4gaW50ICogaW50ICogaW50ICogaW50ICogaW50ICogaW50XG5lbmRcblxubW9kdWxlIE1ha2UgKEggOiBIYXNodGJsLkhhc2hlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGRhdGEgPSBILnQpID0gc3RydWN0XG5cbiAgdHlwZSAnYSB3ZWFrX3QgPSAnYSB0XG4gIGxldCB3ZWFrX2NyZWF0ZSA9IGNyZWF0ZVxuICBsZXQgZW1wdHlidWNrZXQgPSB3ZWFrX2NyZWF0ZSAwXG5cbiAgdHlwZSBkYXRhID0gSC50XG5cbiAgdHlwZSB0ID0ge1xuICAgIG11dGFibGUgdGFibGUgOiBkYXRhIHdlYWtfdCBhcnJheTtcbiAgICBtdXRhYmxlIGhhc2hlcyA6IGludCBhcnJheSBhcnJheTtcbiAgICBtdXRhYmxlIGxpbWl0IDogaW50OyAgICAgICAgICAgICAgICgqIGJ1Y2tldCBzaXplIGxpbWl0ICopXG4gICAgbXV0YWJsZSBvdmVyc2l6ZSA6IGludDsgICAgICAgICAgICAoKiBudW1iZXIgb2Ygb3ZlcnNpemUgYnVja2V0cyAqKVxuICAgIG11dGFibGUgcm92ZXIgOiBpbnQ7ICAgICAgICAgICAgICAgKCogZm9yIGludGVybmFsIGJvb2trZWVwaW5nICopXG4gIH1cblxuICBsZXQgZ2V0X2luZGV4IHQgaCA9IChoIGxhbmQgbWF4X2ludCkgbW9kIChBcnJheS5sZW5ndGggdC50YWJsZSlcblxuICBsZXQgbGltaXQgPSA3XG4gIGxldCBvdmVyX2xpbWl0ID0gMlxuXG4gIGxldCBjcmVhdGUgc3ogPVxuICAgIGxldCBzeiA9IGlmIHN6IDwgNyB0aGVuIDcgZWxzZSBzeiBpblxuICAgIGxldCBzeiA9IGlmIHN6ID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiBTeXMubWF4X2FycmF5X2xlbmd0aCBlbHNlIHN6IGluXG4gICAge1xuICAgICAgdGFibGUgPSBBcnJheS5tYWtlIHN6IGVtcHR5YnVja2V0O1xuICAgICAgaGFzaGVzID0gQXJyYXkubWFrZSBzeiBbfCB8XTtcbiAgICAgIGxpbWl0ID0gbGltaXQ7XG4gICAgICBvdmVyc2l6ZSA9IDA7XG4gICAgICByb3ZlciA9IDA7XG4gICAgfVxuXG4gIGxldCBjbGVhciB0ID1cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxIGRvXG4gICAgICB0LnRhYmxlLihpKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgIHQuaGFzaGVzLihpKSA8LSBbfCB8XTtcbiAgICBkb25lO1xuICAgIHQubGltaXQgPC0gbGltaXQ7XG4gICAgdC5vdmVyc2l6ZSA8LSAwXG5cblxuICBsZXQgZm9sZCBmIHQgaW5pdCA9XG4gICAgbGV0IHJlYyBmb2xkX2J1Y2tldCBpIGIgYWNjdSA9XG4gICAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGZvbGRfYnVja2V0IChpKzEpIGIgKGYgdiBhY2N1KVxuICAgICAgfCBOb25lIC0+IGZvbGRfYnVja2V0IChpKzEpIGIgYWNjdVxuICAgIGluXG4gICAgQXJyYXkuZm9sZF9yaWdodCAoZm9sZF9idWNrZXQgMCkgdC50YWJsZSBpbml0XG5cblxuICBsZXQgaXRlciBmIHQgPVxuICAgIGxldCByZWMgaXRlcl9idWNrZXQgaSBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBnZXQgYiBpIHdpdGhcbiAgICAgIHwgU29tZSB2IC0+IGYgdjsgaXRlcl9idWNrZXQgKGkrMSkgYlxuICAgICAgfCBOb25lIC0+IGl0ZXJfYnVja2V0IChpKzEpIGJcbiAgICBpblxuICAgIEFycmF5Lml0ZXIgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCBpdGVyX3dlYWsgZiB0ID1cbiAgICBsZXQgcmVjIGl0ZXJfYnVja2V0IGkgaiBiID1cbiAgICAgIGlmIGkgPj0gbGVuZ3RoIGIgdGhlbiAoKSBlbHNlXG4gICAgICBtYXRjaCBjaGVjayBiIGkgd2l0aFxuICAgICAgfCB0cnVlIC0+IGYgYiB0Lmhhc2hlcy4oaikgaTsgaXRlcl9idWNrZXQgKGkrMSkgaiBiXG4gICAgICB8IGZhbHNlIC0+IGl0ZXJfYnVja2V0IChpKzEpIGogYlxuICAgIGluXG4gICAgQXJyYXkuaXRlcmkgKGl0ZXJfYnVja2V0IDApIHQudGFibGVcblxuXG4gIGxldCByZWMgY291bnRfYnVja2V0IGkgYiBhY2N1ID1cbiAgICBpZiBpID49IGxlbmd0aCBiIHRoZW4gYWNjdSBlbHNlXG4gICAgY291bnRfYnVja2V0IChpKzEpIGIgKGFjY3UgKyAoaWYgY2hlY2sgYiBpIHRoZW4gMSBlbHNlIDApKVxuXG5cbiAgbGV0IGNvdW50IHQgPVxuICAgIEFycmF5LmZvbGRfcmlnaHQgKGNvdW50X2J1Y2tldCAwKSB0LnRhYmxlIDBcblxuXG4gIGxldCBuZXh0X3N6IG4gPSBtaW4gKDMgKiBuIC8gMiArIDMpIFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG4gIGxldCBwcmV2X3N6IG4gPSAoKG4gLSAzKSAqIDIgKyAyKSAvIDNcblxuICBsZXQgdGVzdF9zaHJpbmtfYnVja2V0IHQgPVxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLih0LnJvdmVyKSBpblxuICAgIGxldCBoYnVja2V0ID0gdC5oYXNoZXMuKHQucm92ZXIpIGluXG4gICAgbGV0IGxlbiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcHJldl9sZW4gPSBwcmV2X3N6IGxlbiBpblxuICAgIGxldCBsaXZlID0gY291bnRfYnVja2V0IDAgYnVja2V0IDAgaW5cbiAgICBpZiBsaXZlIDw9IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCByZWMgbG9vcCBpIGogPVxuICAgICAgICBpZiBqID49IHByZXZfbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgICBpZiBjaGVjayBidWNrZXQgaSB0aGVuIGxvb3AgKGkgKyAxKSBqXG4gICAgICAgICAgZWxzZSBpZiBjaGVjayBidWNrZXQgaiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBibGl0IGJ1Y2tldCBqIGJ1Y2tldCBpIDE7XG4gICAgICAgICAgICBoYnVja2V0LihpKSA8LSBoYnVja2V0LihqKTtcbiAgICAgICAgICAgIGxvb3AgKGkgKyAxKSAoaiAtIDEpO1xuICAgICAgICAgIGVuZCBlbHNlIGxvb3AgaSAoaiAtIDEpO1xuICAgICAgICBlbmQ7XG4gICAgICBpblxuICAgICAgbG9vcCAwIChsZW5ndGggYnVja2V0IC0gMSk7XG4gICAgICBpZiBwcmV2X2xlbiA9IDAgdGhlbiBiZWdpblxuICAgICAgICB0LnRhYmxlLih0LnJvdmVyKSA8LSBlbXB0eWJ1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIFt8IHxdO1xuICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgbGV0IG5ld2J1Y2tldCA9IHdlYWtfY3JlYXRlIHByZXZfbGVuIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgcHJldl9sZW47XG4gICAgICAgIHQudGFibGUuKHQucm92ZXIpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKHQucm92ZXIpIDwtIEFycmF5LnN1YiBoYnVja2V0IDAgcHJldl9sZW5cbiAgICAgIGVuZDtcbiAgICAgIGlmIGxlbiA+IHQubGltaXQgJiYgcHJldl9sZW4gPD0gdC5saW1pdCB0aGVuIHQub3ZlcnNpemUgPC0gdC5vdmVyc2l6ZSAtIDE7XG4gICAgZW5kO1xuICAgIHQucm92ZXIgPC0gKHQucm92ZXIgKyAxKSBtb2QgKEFycmF5Lmxlbmd0aCB0LnRhYmxlKVxuXG5cbiAgbGV0IHJlYyByZXNpemUgdCA9XG4gICAgbGV0IG9sZGxlbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG5ld2xlbiA9IG5leHRfc3ogb2xkbGVuIGluXG4gICAgaWYgbmV3bGVuID4gb2xkbGVuIHRoZW4gYmVnaW5cbiAgICAgIGxldCBuZXd0ID0gY3JlYXRlIG5ld2xlbiBpblxuICAgICAgbGV0IGFkZF93ZWFrIG9iIG9oIG9pID1cbiAgICAgICAgbGV0IHNldHRlciBuYiBuaSBfID0gYmxpdCBvYiBvaSBuYiBuaSAxIGluXG4gICAgICAgIGxldCBoID0gb2guKG9pKSBpblxuICAgICAgICBhZGRfYXV4IG5ld3Qgc2V0dGVyIE5vbmUgaCAoZ2V0X2luZGV4IG5ld3QgaCk7XG4gICAgICBpblxuICAgICAgaXRlcl93ZWFrIGFkZF93ZWFrIHQ7XG4gICAgICB0LnRhYmxlIDwtIG5ld3QudGFibGU7XG4gICAgICB0Lmhhc2hlcyA8LSBuZXd0Lmhhc2hlcztcbiAgICAgIHQubGltaXQgPC0gbmV3dC5saW1pdDtcbiAgICAgIHQub3ZlcnNpemUgPC0gbmV3dC5vdmVyc2l6ZTtcbiAgICAgIHQucm92ZXIgPC0gdC5yb3ZlciBtb2QgQXJyYXkubGVuZ3RoIG5ld3QudGFibGU7XG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIHQubGltaXQgPC0gbWF4X2ludDsgICAgICAgICAgICAgKCogbWF4aW11bSBzaXplIGFscmVhZHkgcmVhY2hlZCAqKVxuICAgICAgdC5vdmVyc2l6ZSA8LSAwO1xuICAgIGVuZFxuXG4gIGFuZCBhZGRfYXV4IHQgc2V0dGVyIGQgaCBpbmRleCA9XG4gICAgbGV0IGJ1Y2tldCA9IHQudGFibGUuKGluZGV4KSBpblxuICAgIGxldCBoYXNoZXMgPSB0Lmhhc2hlcy4oaW5kZXgpIGluXG4gICAgbGV0IHN6ID0gbGVuZ3RoIGJ1Y2tldCBpblxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGlmIGkgPj0gc3ogdGhlbiBiZWdpblxuICAgICAgICBsZXQgbmV3c3ogPVxuICAgICAgICAgIG1pbiAoMyAqIHN6IC8gMiArIDMpIChTeXMubWF4X2FycmF5X2xlbmd0aCAtIGFkZGl0aW9uYWxfdmFsdWVzKVxuICAgICAgICBpblxuICAgICAgICBpZiBuZXdzeiA8PSBzeiB0aGVuIGZhaWx3aXRoIFwiV2Vhay5NYWtlOiBoYXNoIGJ1Y2tldCBjYW5ub3QgZ3JvdyBtb3JlXCI7XG4gICAgICAgIGxldCBuZXdidWNrZXQgPSB3ZWFrX2NyZWF0ZSBuZXdzeiBpblxuICAgICAgICBsZXQgbmV3aGFzaGVzID0gQXJyYXkubWFrZSBuZXdzeiAwIGluXG4gICAgICAgIGJsaXQgYnVja2V0IDAgbmV3YnVja2V0IDAgc3o7XG4gICAgICAgIEFycmF5LmJsaXQgaGFzaGVzIDAgbmV3aGFzaGVzIDAgc3o7XG4gICAgICAgIHNldHRlciBuZXdidWNrZXQgc3ogZDtcbiAgICAgICAgbmV3aGFzaGVzLihzeikgPC0gaDtcbiAgICAgICAgdC50YWJsZS4oaW5kZXgpIDwtIG5ld2J1Y2tldDtcbiAgICAgICAgdC5oYXNoZXMuKGluZGV4KSA8LSBuZXdoYXNoZXM7XG4gICAgICAgIGlmIHN6IDw9IHQubGltaXQgJiYgbmV3c3ogPiB0LmxpbWl0IHRoZW4gYmVnaW5cbiAgICAgICAgICB0Lm92ZXJzaXplIDwtIHQub3ZlcnNpemUgKyAxO1xuICAgICAgICAgIGZvciBfaSA9IDAgdG8gb3Zlcl9saW1pdCBkbyB0ZXN0X3Nocmlua19idWNrZXQgdCBkb25lO1xuICAgICAgICBlbmQ7XG4gICAgICAgIGlmIHQub3ZlcnNpemUgPiBBcnJheS5sZW5ndGggdC50YWJsZSAvIG92ZXJfbGltaXQgdGhlbiByZXNpemUgdDtcbiAgICAgIGVuZCBlbHNlIGlmIGNoZWNrIGJ1Y2tldCBpIHRoZW4gYmVnaW5cbiAgICAgICAgbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBzZXR0ZXIgYnVja2V0IGkgZDtcbiAgICAgICAgaGFzaGVzLihpKSA8LSBoO1xuICAgICAgZW5kO1xuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgYWRkIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGFkZF9hdXggdCBzZXQgKFNvbWUgZCkgaCAoZ2V0X2luZGV4IHQgaClcblxuXG4gIGxldCBmaW5kX29yIHQgZCBpZm5vdGZvdW5kID1cbiAgICBsZXQgaCA9IEguaGFzaCBkIGluXG4gICAgbGV0IGluZGV4ID0gZ2V0X2luZGV4IHQgaCBpblxuICAgIGxldCBidWNrZXQgPSB0LnRhYmxlLihpbmRleCkgaW5cbiAgICBsZXQgaGFzaGVzID0gdC5oYXNoZXMuKGluZGV4KSBpblxuICAgIGxldCBzeiA9IGxlbmd0aCBidWNrZXQgaW5cbiAgICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gaWZub3Rmb3VuZCBoIGluZGV4XG4gICAgICBlbHNlIGlmIGggPSBoYXNoZXMuKGkpIHRoZW4gYmVnaW5cbiAgICAgICAgbWF0Y2ggZ2V0X2NvcHkgYnVja2V0IGkgd2l0aFxuICAgICAgICB8IFNvbWUgdiB3aGVuIEguZXF1YWwgdiBkXG4gICAgICAgICAgIC0+IGJlZ2luIG1hdGNoIGdldCBidWNrZXQgaSB3aXRoXG4gICAgICAgICAgICAgIHwgU29tZSB2IC0+IHZcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgZW5kIGVsc2UgbG9vcCAoaSArIDEpXG4gICAgaW5cbiAgICBsb29wIDBcblxuXG4gIGxldCBtZXJnZSB0IGQgPVxuICAgIGZpbmRfb3IgdCBkIChmdW4gaCBpbmRleCAtPiBhZGRfYXV4IHQgc2V0IChTb21lIGQpIGggaW5kZXg7IGQpXG5cblxuICBsZXQgZmluZCB0IGQgPSBmaW5kX29yIHQgZCAoZnVuIF9oIF9pbmRleCAtPiByYWlzZSBOb3RfZm91bmQpXG5cbiAgbGV0IGZpbmRfb3B0IHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIE5vbmVcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGRcbiAgICAgICAgICAgLT4gYmVnaW4gbWF0Y2ggZ2V0IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgICAgICAgfCBTb21lIF8gYXMgdiAtPiB2XG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgIHwgXyAtPiBsb29wIChpICsgMSlcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKVxuICAgIGluXG4gICAgbG9vcCAwXG5cblxuICBsZXQgZmluZF9zaGFkb3cgdCBkIGlmZm91bmQgaWZub3Rmb3VuZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgaWYgaSA+PSBzeiB0aGVuIGlmbm90Zm91bmRcbiAgICAgIGVsc2UgaWYgaCA9IGhhc2hlcy4oaSkgdGhlbiBiZWdpblxuICAgICAgICBtYXRjaCBnZXRfY29weSBidWNrZXQgaSB3aXRoXG4gICAgICAgIHwgU29tZSB2IHdoZW4gSC5lcXVhbCB2IGQgLT4gaWZmb3VuZCBidWNrZXQgaVxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpXG4gICAgICBlbmQgZWxzZSBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuXG5cbiAgbGV0IHJlbW92ZSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biB3IGkgLT4gc2V0IHcgaSBOb25lKSAoKVxuXG5cbiAgbGV0IG1lbSB0IGQgPSBmaW5kX3NoYWRvdyB0IGQgKGZ1biBfdyBfaSAtPiB0cnVlKSBmYWxzZVxuXG5cbiAgbGV0IGZpbmRfYWxsIHQgZCA9XG4gICAgbGV0IGggPSBILmhhc2ggZCBpblxuICAgIGxldCBpbmRleCA9IGdldF9pbmRleCB0IGggaW5cbiAgICBsZXQgYnVja2V0ID0gdC50YWJsZS4oaW5kZXgpIGluXG4gICAgbGV0IGhhc2hlcyA9IHQuaGFzaGVzLihpbmRleCkgaW5cbiAgICBsZXQgc3ogPSBsZW5ndGggYnVja2V0IGluXG4gICAgbGV0IHJlYyBsb29wIGkgYWNjdSA9XG4gICAgICBpZiBpID49IHN6IHRoZW4gYWNjdVxuICAgICAgZWxzZSBpZiBoID0gaGFzaGVzLihpKSB0aGVuIGJlZ2luXG4gICAgICAgIG1hdGNoIGdldF9jb3B5IGJ1Y2tldCBpIHdpdGhcbiAgICAgICAgfCBTb21lIHYgd2hlbiBILmVxdWFsIHYgZFxuICAgICAgICAgICAtPiBiZWdpbiBtYXRjaCBnZXQgYnVja2V0IGkgd2l0aFxuICAgICAgICAgICAgICB8IFNvbWUgdiAtPiBsb29wIChpICsgMSkgKHYgOjogYWNjdSlcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICB8IF8gLT4gbG9vcCAoaSArIDEpIGFjY3VcbiAgICAgIGVuZCBlbHNlIGxvb3AgKGkgKyAxKSBhY2N1XG4gICAgaW5cbiAgICBsb29wIDAgW11cblxuXG4gIGxldCBzdGF0cyB0ID1cbiAgICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHQudGFibGUgaW5cbiAgICBsZXQgbGVucyA9IEFycmF5Lm1hcCBsZW5ndGggdC50YWJsZSBpblxuICAgIEFycmF5LnNvcnQgY29tcGFyZSBsZW5zO1xuICAgIGxldCB0b3RsZW4gPSBBcnJheS5mb2xkX2xlZnQgKCArICkgMCBsZW5zIGluXG4gICAgKGxlbiwgY291bnQgdCwgdG90bGVuLCBsZW5zLigwKSwgbGVucy4obGVuLzIpLCBsZW5zLihsZW4tMSkpXG5cblxuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBQaWVycmUgV2VpcywgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIEEgcHJldHR5LXByaW50aW5nIGZhY2lsaXR5IGFuZCBkZWZpbml0aW9uIG9mIGZvcm1hdHRlcnMgZm9yICdwYXJhbGxlbCdcbiAgIChpLmUuIHVucmVsYXRlZCBvciBpbmRlcGVuZGVudCkgcHJldHR5LXByaW50aW5nIG9uIG11bHRpcGxlIG91dCBjaGFubmVscy4gKilcblxuKCpcbiAgIFRoZSBwcmV0dHktcHJpbnRpbmcgZW5naW5lIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiopXG5cbmxldCBpZCB4ID0geFxuXG4oKiBBIGRldm90ZWQgdHlwZSBmb3Igc2l6ZXMgdG8gYXZvaWQgY29uZnVzaW9uXG4gICBiZXR3ZWVuIHNpemVzIGFuZCBtZXJlIGludGVnZXJzLiAqKVxubW9kdWxlIFNpemUgOiBzaWdcbiAgdHlwZSB0XG5cbiAgdmFsIHRvX2ludCA6IHQgLT4gaW50XG4gIHZhbCBvZl9pbnQgOiBpbnQgLT4gdFxuICB2YWwgemVybyA6IHRcbiAgdmFsIHVua25vd24gOiB0XG4gIHZhbCBpc19rbm93biA6IHQgLT4gYm9vbFxuZW5kICA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgdG9faW50ID0gaWRcbiAgbGV0IG9mX2ludCA9IGlkXG4gIGxldCB6ZXJvID0gMFxuICBsZXQgdW5rbm93biA9IC0xXG4gIGxldCBpc19rbm93biBuID0gbiA+PSAwXG5lbmRcblxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRpbmcgYm94ZXMgZGVmaW5pdGlvbjpcbiAgIGEgcHJldHR5LXByaW50aW5nIGJveCBpcyBlaXRoZXJcbiAgIC0gaGJveDogaG9yaXpvbnRhbCBib3ggKG5vIGxpbmUgc3BsaXR0aW5nKVxuICAgLSB2Ym94OiB2ZXJ0aWNhbCBib3ggKGV2ZXJ5IGJyZWFrIGhpbnQgc3BsaXRzIHRoZSBsaW5lKVxuICAgLSBodmJveDogaG9yaXpvbnRhbC92ZXJ0aWNhbCBib3hcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIGJveCBpZiBpdCBmaXRzIG9uXG4gICAgICB0aGUgY3VycmVudCBsaW5lLCBvdGhlcndpc2UgdGhlIGJveCBiZWhhdmVzIGFzIGEgdmVydGljYWwgYm94KVxuICAgLSBob3Zib3g6IGhvcml6b250YWwgb3IgdmVydGljYWwgY29tcGFjdGluZyBib3hcbiAgICAgKHRoZSBib3ggaXMgY29tcGFjdGluZyBtYXRlcmlhbCwgcHJpbnRpbmcgYXMgbXVjaCBtYXRlcmlhbCBhcyBwb3NzaWJsZVxuICAgICAgb24gZXZlcnkgbGluZXMpXG4gICAtIGJveDogaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBjb21wYWN0aW5nIGJveCB3aXRoIGVuaGFuY2VkIGJveCBzdHJ1Y3R1cmVcbiAgICAgKHRoZSBib3ggYmVoYXZlcyBhcyBhbiBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGJveCBidXQgYnJlYWsgaGludHMgc3BsaXRcbiAgICAgIHRoZSBsaW5lIGlmIHNwbGl0dGluZyB3b3VsZCBtb3ZlIHRvIHRoZSBsZWZ0KVxuKilcbnR5cGUgYm94X3R5cGUgPSBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3MuYmxvY2tfdHlwZSA9XG4gIHwgUHBfaGJveCB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCB8IFBwX2ZpdHNcblxuXG4oKiBUaGUgcHJldHR5LXByaW50aW5nIHRva2VucyBkZWZpbml0aW9uOlxuICAgYXJlIGVpdGhlciB0ZXh0IHRvIHByaW50IG9yIHByZXR0eSBwcmludGluZ1xuICAgZWxlbWVudHMgdGhhdCBkcml2ZSBpbmRlbnRhdGlvbiBhbmQgbGluZSBzcGxpdHRpbmcuICopXG50eXBlIHBwX3Rva2VuID1cbiAgfCBQcF90ZXh0IG9mIHN0cmluZyAgICAgICAgICAoKiBub3JtYWwgdGV4dCAqKVxuICB8IFBwX2JyZWFrIG9mIHsgICAgICAgICAgICAgICgqIGNvbXBsZXRlIGJyZWFrICopXG4gICAgICBmaXRzOiBzdHJpbmcgKiBpbnQgKiBzdHJpbmc7ICAgKCogbGluZSBpcyBub3Qgc3BsaXQgKilcbiAgICAgIGJyZWFrczogc3RyaW5nICogaW50ICogc3RyaW5nOyAoKiBsaW5lIGlzIHNwbGl0ICopXG4gICAgfVxuICB8IFBwX3RicmVhayBvZiBpbnQgKiBpbnQgICAgICgqIGdvIHRvIG5leHQgdGFidWxhdGlvbiAqKVxuICB8IFBwX3N0YWIgICAgICAgICAgICAgICAgICAgICgqIHNldCBhIHRhYnVsYXRpb24gKilcbiAgfCBQcF9iZWdpbiBvZiBpbnQgKiBib3hfdHlwZSAoKiBiZWdpbm5pbmcgb2YgYSBib3ggKilcbiAgfCBQcF9lbmQgICAgICAgICAgICAgICAgICAgICAoKiBlbmQgb2YgYSBib3ggKilcbiAgfCBQcF90YmVnaW4gb2YgdGJveCAgICAgICAgICAoKiBiZWdpbm5pbmcgb2YgYSB0YWJ1bGF0aW9uIGJveCAqKVxuICB8IFBwX3RlbmQgICAgICAgICAgICAgICAgICAgICgqIGVuZCBvZiBhIHRhYnVsYXRpb24gYm94ICopXG4gIHwgUHBfbmV3bGluZSAgICAgICAgICAgICAgICAgKCogdG8gZm9yY2UgYSBuZXdsaW5lIGluc2lkZSBhIGJveCAqKVxuICB8IFBwX2lmX25ld2xpbmUgICAgICAgICAgICAgICgqIHRvIGRvIHNvbWV0aGluZyBvbmx5IGlmIHRoaXMgdmVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgaGFzIGJlZW4gYnJva2VuICopXG4gIHwgUHBfb3Blbl90YWcgb2Ygc3RhZyAgICAgICAgICgqIG9wZW5pbmcgYSB0YWcgbmFtZSAqKVxuICB8IFBwX2Nsb3NlX3RhZyAgICAgICAgICAgICAgICgqIGNsb3NpbmcgdGhlIG1vc3QgcmVjZW50bHkgb3BlbiB0YWcgKilcblxuYW5kIHN0YWcgPSAuLlxuXG5hbmQgdGJveCA9IFBwX3Rib3ggb2YgaW50IGxpc3QgcmVmICAoKiBUYWJ1bGF0aW9uIGJveCAqKVxuXG50eXBlIHRhZyA9IHN0cmluZ1xudHlwZSBzdGFnICs9IFN0cmluZ190YWcgb2YgdGFnXG5cblxuKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlOlxuICAgcHJldHR5LXByaW50aW5nIG1hdGVyaWFsIGlzIG5vdCB3cml0dGVuIGluIHRoZSBvdXRwdXQgYXMgc29vbiBhcyBlbWl0dGVkO1xuICAgaW5zdGVhZCwgdGhlIG1hdGVyaWFsIGlzIHNpbXBseSByZWNvcmRlZCBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUsXG4gICB1bnRpbCB0aGUgZW5jbG9zaW5nIGJveCBoYXMgYSBrbm93biBjb21wdXRlZCBzaXplIGFuZCBwcm9wZXIgc3BsaXR0aW5nXG4gICBkZWNpc2lvbnMgY2FuIGJlIG1hZGUuXG5cbiAgIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBjb250YWlucyBmb3JtYXR0aW5nIGVsZW1lbnRzIHRvIGJlIHByaW50ZWQuXG4gICBFYWNoIGZvcm1hdHRpbmcgZWxlbWVudCBpcyBhIHR1cGxlIChzaXplLCB0b2tlbiwgbGVuZ3RoKSwgd2hlcmVcbiAgIC0gbGVuZ3RoIGlzIHRoZSBkZWNsYXJlZCBsZW5ndGggb2YgdGhlIHRva2VuLFxuICAgLSBzaXplIGlzIGVmZmVjdGl2ZSBzaXplIG9mIHRoZSB0b2tlbiB3aGVuIGl0IGlzIHByaW50ZWRcbiAgICAgKHNpemUgaXMgc2V0IHdoZW4gdGhlIHNpemUgb2YgdGhlIGJveCBpcyBrbm93biwgc28gdGhhdCBzaXplIG9mIGJyZWFrXG4gICAgICBoaW50cyBhcmUgZGVmaW5pdGl2ZSkuICopXG50eXBlIHBwX3F1ZXVlX2VsZW0gPSB7XG4gIG11dGFibGUgc2l6ZSA6IFNpemUudDtcbiAgdG9rZW4gOiBwcF90b2tlbjtcbiAgbGVuZ3RoIDogaW50O1xufVxuXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9xdWV1ZSA9IHBwX3F1ZXVlX2VsZW0gUXVldWUudFxuXG4oKiBUaGUgcHJldHR5LXByaW50ZXIgc2Nhbm5pbmcgc3RhY2suICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjazogc2Nhbm5pbmcgZWxlbWVudCBkZWZpbml0aW9uLiAqKVxudHlwZSBwcF9zY2FuX2VsZW0gPSB7XG4gIGxlZnRfdG90YWwgOiBpbnQ7ICgqIFZhbHVlIG9mIHBwX2xlZnRfdG90YWwgd2hlbiB0aGUgZWxlbWVudCB3YXMgZW5xdWV1ZWQuICopXG4gIHF1ZXVlX2VsZW0gOiBwcF9xdWV1ZV9lbGVtXG59XG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOlxuICAgdGhlIGZvcm1hdHRpbmcgc3RhY2sgY29udGFpbnMgdGhlIGRlc2NyaXB0aW9uIG9mIGFsbCB0aGUgY3VycmVudGx5IGFjdGl2ZVxuICAgYm94ZXM7IHRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrIGlzIHVzZWQgdG8gc3BsaXQgdGhlIGxpbmVzXG4gICB3aGlsZSBwcmludGluZyB0b2tlbnMuICopXG5cbigqIFRoZSBwcmV0dHktcHJpbnRlciBmb3JtYXR0aW5nIHN0YWNrOiBmb3JtYXR0aW5nIHN0YWNrIGVsZW1lbnQgZGVmaW5pdGlvbi5cbiAgIEVhY2ggc3RhY2sgZWxlbWVudCBkZXNjcmliZXMgYSBwcmV0dHktcHJpbnRpbmcgYm94LiAqKVxudHlwZSBwcF9mb3JtYXRfZWxlbSA9IHsgYm94X3R5cGUgOiBib3hfdHlwZTsgd2lkdGggOiBpbnQgfVxuXG4oKiBUaGUgZm9ybWF0dGVyIGRlZmluaXRpb24uXG4gICBFYWNoIGZvcm1hdHRlciB2YWx1ZSBpcyBhIHByZXR0eS1wcmludGVyIGluc3RhbmNlIHdpdGggYWxsIGl0c1xuICAgbWFjaGluZXJ5LiAqKVxudHlwZSBmb3JtYXR0ZXIgPSB7XG4gICgqIFRoZSBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay4gKilcbiAgcHBfc2Nhbl9zdGFjayA6IHBwX3NjYW5fZWxlbSBTdGFjay50O1xuICAoKiBUaGUgcHJldHR5LXByaW50ZXIgZm9ybWF0dGluZyBzdGFjay4gKilcbiAgcHBfZm9ybWF0X3N0YWNrIDogcHBfZm9ybWF0X2VsZW0gU3RhY2sudDtcbiAgcHBfdGJveF9zdGFjayA6IHRib3ggU3RhY2sudDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHNlbWFudGljcyB0YWcgc3RhY2suICopXG4gIHBwX3RhZ19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgcHBfbWFya19zdGFjayA6IHN0YWcgU3RhY2sudDtcbiAgKCogVmFsdWUgb2YgcmlnaHQgbWFyZ2luLiAqKVxuICBtdXRhYmxlIHBwX21hcmdpbiA6IGludDtcbiAgKCogTWluaW1hbCBzcGFjZSBsZWZ0IGJlZm9yZSBtYXJnaW4sIHdoZW4gb3BlbmluZyBhIGJveC4gKilcbiAgbXV0YWJsZSBwcF9taW5fc3BhY2VfbGVmdCA6IGludDtcbiAgKCogTWF4aW11bSB2YWx1ZSBvZiBpbmRlbnRhdGlvbjpcbiAgICAgbm8gYm94IGNhbiBiZSBvcGVuZWQgZnVydGhlci4gKilcbiAgbXV0YWJsZSBwcF9tYXhfaW5kZW50IDogaW50O1xuICAoKiBTcGFjZSByZW1haW5pbmcgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbiAgbXV0YWJsZSBwcF9zcGFjZV9sZWZ0IDogaW50O1xuICAoKiBDdXJyZW50IHZhbHVlIG9mIGluZGVudGF0aW9uLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJlbnRfaW5kZW50IDogaW50O1xuICAoKiBUcnVlIHdoZW4gdGhlIGxpbmUgaGFzIGJlZW4gYnJva2VuIGJ5IHRoZSBwcmV0dHktcHJpbnRlci4gKilcbiAgbXV0YWJsZSBwcF9pc19uZXdfbGluZSA6IGJvb2w7XG4gICgqIFRvdGFsIHdpZHRoIG9mIHRva2VucyBhbHJlYWR5IHByaW50ZWQuICopXG4gIG11dGFibGUgcHBfbGVmdF90b3RhbCA6IGludDtcbiAgKCogVG90YWwgd2lkdGggb2YgdG9rZW5zIGV2ZXIgcHV0IGluIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHBwX3JpZ2h0X3RvdGFsIDogaW50O1xuICAoKiBDdXJyZW50IG51bWJlciBvZiBvcGVuIGJveGVzLiAqKVxuICBtdXRhYmxlIHBwX2N1cnJfZGVwdGggOiBpbnQ7XG4gICgqIE1heGltdW0gbnVtYmVyIG9mIGJveGVzIHdoaWNoIGNhbiBiZSBzaW11bHRhbmVvdXNseSBvcGVuLiAqKVxuICBtdXRhYmxlIHBwX21heF9ib3hlcyA6IGludDtcbiAgKCogRWxsaXBzaXMgc3RyaW5nLiAqKVxuICBtdXRhYmxlIHBwX2VsbGlwc2lzIDogc3RyaW5nO1xuICAoKiBPdXRwdXQgZnVuY3Rpb24uICopXG4gIG11dGFibGUgcHBfb3V0X3N0cmluZyA6IHN0cmluZyAtPiBpbnQgLT4gaW50IC0+IHVuaXQ7XG4gICgqIEZsdXNoaW5nIGZ1bmN0aW9uLiAqKVxuICBtdXRhYmxlIHBwX291dF9mbHVzaCA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIG5ldyBsaW5lcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfbmV3bGluZSA6IHVuaXQgLT4gdW5pdDtcbiAgKCogT3V0cHV0IG9mIGJyZWFrIGhpbnRzIHNwYWNlcy4gKilcbiAgbXV0YWJsZSBwcF9vdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gICgqIE91dHB1dCBvZiBpbmRlbnRhdGlvbiBvZiBuZXcgbGluZXMuICopXG4gIG11dGFibGUgcHBfb3V0X2luZGVudCA6IGludCAtPiB1bml0O1xuICAoKiBBcmUgdGFncyBwcmludGVkID8gKilcbiAgbXV0YWJsZSBwcF9wcmludF90YWdzIDogYm9vbDtcbiAgKCogQXJlIHRhZ3MgbWFya2VkID8gKilcbiAgbXV0YWJsZSBwcF9tYXJrX3RhZ3MgOiBib29sO1xuICAoKiBGaW5kIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWFya2VycyBvZiB0YWdzLiAqKVxuICBtdXRhYmxlIHBwX21hcmtfb3Blbl90YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgbXV0YWJsZSBwcF9tYXJrX2Nsb3NlX3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtdXRhYmxlIHBwX3ByaW50X29wZW5fdGFnIDogc3RhZyAtPiB1bml0O1xuICBtdXRhYmxlIHBwX3ByaW50X2Nsb3NlX3RhZyA6IHN0YWcgLT4gdW5pdDtcbiAgKCogVGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxuICBwcF9xdWV1ZSA6IHBwX3F1ZXVlO1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgc3BlY2lmaWMgdGFnIGhhbmRsaW5nIGZ1bmN0aW9ucy4gKilcbnR5cGUgZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fc3RhZyA6IHN0YWcgLT4gc3RyaW5nO1xuICBtYXJrX2Nsb3NlX3N0YWcgOiBzdGFnIC0+IHN0cmluZztcbiAgcHJpbnRfb3Blbl9zdGFnIDogc3RhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV9zdGFnIDogc3RhZyAtPiB1bml0O1xufVxuXG5cbigqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb25zIHRvIG91dHB1dCBtYXRlcmlhbC4gKilcbnR5cGUgZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPSB7XG4gIG91dF9zdHJpbmcgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiB1bml0O1xuICBvdXRfZmx1c2ggOiB1bml0IC0+IHVuaXQ7XG4gIG91dF9uZXdsaW5lIDogdW5pdCAtPiB1bml0O1xuICBvdXRfc3BhY2VzIDogaW50IC0+IHVuaXQ7XG4gIG91dF9pbmRlbnQgOiBpbnQgLT4gdW5pdDtcbn1cblxuXG4oKlxuXG4gIEF1eGlsaWFyaWVzIGFuZCBiYXNpYyBmdW5jdGlvbnMuXG5cbiopXG5cbigqIEVudGVyIGEgdG9rZW4gaW4gdGhlIHByZXR0eS1wcmludGVyIHF1ZXVlLiAqKVxubGV0IHBwX2VucXVldWUgc3RhdGUgdG9rZW4gPVxuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBzdGF0ZS5wcF9yaWdodF90b3RhbCArIHRva2VuLmxlbmd0aDtcbiAgUXVldWUuYWRkIHRva2VuIHN0YXRlLnBwX3F1ZXVlXG5cblxubGV0IHBwX2NsZWFyX3F1ZXVlIHN0YXRlID1cbiAgc3RhdGUucHBfbGVmdF90b3RhbCA8LSAxOyBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSAxO1xuICBRdWV1ZS5jbGVhciBzdGF0ZS5wcF9xdWV1ZVxuXG5cbigqIFBwX2luZmluaXR5OiBsYXJnZSB2YWx1ZSBmb3IgZGVmYXVsdCB0b2tlbnMgc2l6ZS5cblxuICAgUHBfaW5maW5pdHkgaXMgZG9jdW1lbnRlZCBhcyBiZWluZyBncmVhdGVyIHRoYW4gMWUxMDsgdG8gYXZvaWRcbiAgIGNvbmZ1c2lvbiBhYm91dCB0aGUgd29yZCAnZ3JlYXRlcicsIHdlIGNob29zZSBwcF9pbmZpbml0eSBncmVhdGVyXG4gICB0aGFuIDFlMTAgKyAxOyBmb3IgY29ycmVjdCBoYW5kbGluZyBvZiB0ZXN0cyBpbiB0aGUgYWxnb3JpdGhtLFxuICAgcHBfaW5maW5pdHkgbXVzdCBiZSBldmVuIG9uZSBtb3JlIHRoYW4gMWUxMCArIDE7IGxldCdzIHN0YW5kIG9uIHRoZVxuICAgc2FmZSBzaWRlIGJ5IGNob29zaW5nIDEuZTEwKzEwLlxuXG4gICBQcF9pbmZpbml0eSBjb3VsZCBwcm9iYWJseSBiZSAxMDczNzQxODIzIHRoYXQgaXMgMl4zMCAtIDEsIHRoYXQgaXNcbiAgIHRoZSBtaW5pbWFsIHVwcGVyIGJvdW5kIGZvciBpbnRlZ2Vyczsgbm93IHRoYXQgbWF4X2ludCBpcyBkZWZpbmVkLFxuICAgdGhpcyBsaW1pdCBjb3VsZCBhbHNvIGJlIGRlZmluZWQgYXMgbWF4X2ludCAtIDEuXG5cbiAgIEhvd2V2ZXIsIGJlZm9yZSBzZXR0aW5nIHBwX2luZmluaXR5IHRvIHNvbWV0aGluZyBhcm91bmQgbWF4X2ludCwgd2VcbiAgIG11c3QgY2FyZWZ1bGx5IGRvdWJsZS1jaGVjayBhbGwgdGhlIGludGVnZXIgYXJpdGhtZXRpYyBvcGVyYXRpb25zXG4gICB0aGF0IGludm9sdmUgcHBfaW5maW5pdHksIHNpbmNlIGFueSBvdmVyZmxvdyB3b3VsZCB3cmVjayBoYXZvYyB0aGVcbiAgIHByZXR0eS1wcmludGluZyBhbGdvcml0aG0ncyBpbnZhcmlhbnRzLiBHaXZlbiB0aGF0IHRoaXMgYXJpdGhtZXRpY1xuICAgY29ycmVjdG5lc3MgY2hlY2sgaXMgZGlmZmljdWx0IGFuZCBlcnJvciBwcm9uZSBhbmQgZ2l2ZW4gdGhhdCAxZTEwXG4gICArIDEgaXMgaW4gcHJhY3RpY2UgbGFyZ2UgZW5vdWdoLCB0aGVyZSBpcyBubyBuZWVkIHRvIGF0dGVtcHQgdG8gc2V0XG4gICBwcF9pbmZpbml0eSB0byB0aGUgdGhlb3JldGljYWxseSBtYXhpbXVtIGxpbWl0LiBJdCBpcyBub3Qgd29ydGggdGhlXG4gICBidXJkZW4gISAqKVxubGV0IHBwX2luZmluaXR5ID0gMTAwMDAwMDAxMFxuXG4oKiBPdXRwdXQgZnVuY3Rpb25zIGZvciB0aGUgZm9ybWF0dGVyLiAqKVxubGV0IHBwX291dHB1dF9zdHJpbmcgc3RhdGUgcyA9IHN0YXRlLnBwX291dF9zdHJpbmcgcyAwIChTdHJpbmcubGVuZ3RoIHMpXG5hbmQgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZSAoKVxuYW5kIHBwX291dHB1dF9zcGFjZXMgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9zcGFjZXMgblxuYW5kIHBwX291dHB1dF9pbmRlbnQgc3RhdGUgbiA9IHN0YXRlLnBwX291dF9pbmRlbnQgblxuXG4oKiBGb3JtYXQgYSB0ZXh0dWFsIHRva2VuICopXG5sZXQgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSB0ZXh0ID1cbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IC0gc2l6ZTtcbiAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSB0ZXh0O1xuICBzdGF0ZS5wcF9pc19uZXdfbGluZSA8LSBmYWxzZVxuXG4oKiBGb3JtYXQgYSBzdHJpbmcgYnkgaXRzIGxlbmd0aCwgaWYgbm90IGVtcHR5ICopXG5sZXQgZm9ybWF0X3N0cmluZyBzdGF0ZSBzID1cbiAgaWYgcyA8PiBcIlwiIHRoZW4gZm9ybWF0X3BwX3RleHQgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG4oKiBUbyBmb3JtYXQgYSBicmVhaywgaW5kZW50aW5nIGEgbmV3IGxpbmUuICopXG5sZXQgYnJlYWtfbmV3X2xpbmUgc3RhdGUgKGJlZm9yZSwgb2Zmc2V0LCBhZnRlcikgd2lkdGggPVxuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGJlZm9yZTtcbiAgcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHN0YXRlLnBwX2lzX25ld19saW5lIDwtIHRydWU7XG4gIGxldCBpbmRlbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSB3aWR0aCArIG9mZnNldCBpblxuICAoKiBEb24ndCBpbmRlbnQgbW9yZSB0aGFuIHBwX21heF9pbmRlbnQuICopXG4gIGxldCByZWFsX2luZGVudCA9IG1pbiBzdGF0ZS5wcF9tYXhfaW5kZW50IGluZGVudCBpblxuICBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCA8LSByZWFsX2luZGVudDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgcHBfb3V0cHV0X2luZGVudCBzdGF0ZSBzdGF0ZS5wcF9jdXJyZW50X2luZGVudDtcbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBhZnRlclxuXG5cbigqIFRvIGZvcmNlIGEgbGluZSBicmVhayBpbnNpZGUgYSBib3g6IG5vIG9mZnNldCBpcyBhZGRlZC4gKilcbmxldCBicmVha19saW5lIHN0YXRlIHdpZHRoID0gYnJlYWtfbmV3X2xpbmUgc3RhdGUgKFwiXCIsIDAsIFwiXCIpIHdpZHRoXG5cbigqIFRvIGZvcm1hdCBhIGJyZWFrIHRoYXQgZml0cyBvbiB0aGUgY3VycmVudCBsaW5lLiAqKVxubGV0IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSAoYmVmb3JlLCB3aWR0aCwgYWZ0ZXIpID1cbiAgZm9ybWF0X3N0cmluZyBzdGF0ZSBiZWZvcmU7XG4gIHN0YXRlLnBwX3NwYWNlX2xlZnQgPC0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIHdpZHRoO1xuICBwcF9vdXRwdXRfc3BhY2VzIHN0YXRlIHdpZHRoO1xuICBmb3JtYXRfc3RyaW5nIHN0YXRlIGFmdGVyXG5cblxuKCogVG8gaW5kZW50IG5vIG1vcmUgdGhhbiBwcF9tYXhfaW5kZW50LCBpZiBvbmUgdHJpZXMgdG8gb3BlbiBhIGJveFxuICAgYmV5b25kIHBwX21heF9pbmRlbnQsIHRoZW4gdGhlIGJveCBpcyByZWplY3RlZCBvbiB0aGUgbGVmdFxuICAgYnkgc2ltdWxhdGluZyBhIGJyZWFrLiAqKVxubGV0IHBwX2ZvcmNlX2JyZWFrX2xpbmUgc3RhdGUgPVxuICBtYXRjaCBTdGFjay50b3Bfb3B0IHN0YXRlLnBwX2Zvcm1hdF9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiBwcF9vdXRwdXRfbmV3bGluZSBzdGF0ZVxuICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgIGlmIHdpZHRoID4gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuXG4gICAgICBtYXRjaCBib3hfdHlwZSB3aXRoXG4gICAgICB8IFBwX2ZpdHMgfCBQcF9oYm94IC0+ICgpXG4gICAgICB8IFBwX3Zib3ggfCBQcF9odmJveCB8IFBwX2hvdmJveCB8IFBwX2JveCAtPiBicmVha19saW5lIHN0YXRlIHdpZHRoXG5cblxuKCogVG8gc2tpcCBhIHRva2VuLCBpZiB0aGUgcHJldmlvdXMgbGluZSBoYXMgYmVlbiBicm9rZW4uICopXG5sZXQgcHBfc2tpcF90b2tlbiBzdGF0ZSA9XG4gIG1hdGNoIFF1ZXVlLnRha2Vfb3B0IHN0YXRlLnBwX3F1ZXVlIHdpdGhcbiAgfCBOb25lIC0+ICgpICgqIHByaW50X2lmX25ld2xpbmUgbXVzdCBoYXZlIGJlZW4gdGhlIGxhc3QgcHJpbnRpbmcgY29tbWFuZCAqKVxuICB8IFNvbWUgeyBzaXplOyBsZW5ndGg7IF8gfSAtPlxuICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gc3RhdGUucHBfbGVmdF90b3RhbCAtIGxlbmd0aDtcbiAgICBzdGF0ZS5wcF9zcGFjZV9sZWZ0IDwtIHN0YXRlLnBwX3NwYWNlX2xlZnQgKyBTaXplLnRvX2ludCBzaXplXG5cblxuKCpcblxuICBUaGUgbWFpbiBwcmV0dHkgcHJpbnRpbmcgZnVuY3Rpb25zLlxuXG4qKVxuXG4oKiBGb3JtYXR0aW5nIGEgdG9rZW4gd2l0aCBhIGdpdmVuIHNpemUuICopXG5sZXQgZm9ybWF0X3BwX3Rva2VuIHN0YXRlIHNpemUgPSBmdW5jdGlvblxuXG4gIHwgUHBfdGV4dCBzIC0+XG4gICAgZm9ybWF0X3BwX3RleHQgc3RhdGUgc2l6ZSBzXG5cbiAgfCBQcF9iZWdpbiAob2ZmLCB0eSkgLT5cbiAgICBsZXQgaW5zZXJ0aW9uX3BvaW50ID0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCBpblxuICAgIGlmIGluc2VydGlvbl9wb2ludCA+IHN0YXRlLnBwX21heF9pbmRlbnQgdGhlblxuICAgICAgKCogY2FuIG5vdCBvcGVuIGEgYm94IHJpZ2h0IHRoZXJlLiAqKVxuICAgICAgYmVnaW4gcHBfZm9yY2VfYnJlYWtfbGluZSBzdGF0ZSBlbmQ7XG4gICAgbGV0IHdpZHRoID0gc3RhdGUucHBfc3BhY2VfbGVmdCAtIG9mZiBpblxuICAgIGxldCBib3hfdHlwZSA9XG4gICAgICBtYXRjaCB0eSB3aXRoXG4gICAgICB8IFBwX3Zib3ggLT4gUHBfdmJveFxuICAgICAgfCBQcF9oYm94IHwgUHBfaHZib3ggfCBQcF9ob3Zib3ggfCBQcF9ib3ggfCBQcF9maXRzIC0+XG4gICAgICAgIGlmIHNpemUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0IHRoZW4gdHkgZWxzZSBQcF9maXRzIGluXG4gICAgU3RhY2sucHVzaCB7IGJveF90eXBlOyB3aWR0aCB9IHN0YXRlLnBwX2Zvcm1hdF9zdGFja1xuXG4gIHwgUHBfZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgfD4gaWdub3JlXG5cbiAgfCBQcF90YmVnaW4gKFBwX3Rib3ggXyBhcyB0Ym94KSAtPlxuICAgIFN0YWNrLnB1c2ggdGJveCBzdGF0ZS5wcF90Ym94X3N0YWNrXG5cbiAgfCBQcF90ZW5kIC0+XG4gICAgU3RhY2sucG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHw+IGlnbm9yZVxuXG4gIHwgUHBfc3RhYiAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfdGJveF9zdGFjayB3aXRoXG4gICAgfCBOb25lIC0+ICgpICgqIE5vIG9wZW4gdGFidWxhdGlvbiBib3guICopXG4gICAgfCBTb21lIChQcF90Ym94IHRhYnMpIC0+XG4gICAgICBsZXQgcmVjIGFkZF90YWIgbiA9IGZ1bmN0aW9uXG4gICAgICAgIHwgW10gLT4gW25dXG4gICAgICAgIHwgeCA6OiBsIGFzIGxzIC0+IGlmIG4gPCB4IHRoZW4gbiA6OiBscyBlbHNlIHggOjogYWRkX3RhYiBuIGwgaW5cbiAgICAgIHRhYnMgOj0gYWRkX3RhYiAoc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfc3BhY2VfbGVmdCkgIXRhYnNcbiAgICBlbmRcblxuICB8IFBwX3RicmVhayAobiwgb2ZmKSAtPlxuICAgIGxldCBpbnNlcnRpb25fcG9pbnQgPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0IGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF90Ym94X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gb3BlbiB0YWJ1bGF0aW9uIGJveC4gKilcbiAgICB8IFNvbWUgKFBwX3Rib3ggdGFicykgLT5cbiAgICAgIGxldCB0YWIgPVxuICAgICAgICBtYXRjaCAhdGFicyB3aXRoXG4gICAgICAgIHwgW10gLT4gaW5zZXJ0aW9uX3BvaW50XG4gICAgICAgIHwgZmlyc3QgOjogXyAtPlxuICAgICAgICAgIGxldCByZWMgZmluZCA9IGZ1bmN0aW9uXG4gICAgICAgICAgICB8IGhlYWQgOjogdGFpbCAtPlxuICAgICAgICAgICAgICBpZiBoZWFkID49IGluc2VydGlvbl9wb2ludCB0aGVuIGhlYWQgZWxzZSBmaW5kIHRhaWxcbiAgICAgICAgICAgIHwgW10gLT4gZmlyc3QgaW5cbiAgICAgICAgICBmaW5kICF0YWJzIGluXG4gICAgICBsZXQgb2Zmc2V0ID0gdGFiIC0gaW5zZXJ0aW9uX3BvaW50IGluXG4gICAgICBpZiBvZmZzZXQgPj0gMFxuICAgICAgdGhlbiBicmVha19zYW1lX2xpbmUgc3RhdGUgKFwiXCIsIG9mZnNldCArIG4sIFwiXCIpXG4gICAgICBlbHNlIGJyZWFrX25ld19saW5lIHN0YXRlIChcIlwiLCB0YWIgKyBvZmYsIFwiXCIpIHN0YXRlLnBwX21hcmdpblxuICAgIGVuZFxuXG4gIHwgUHBfbmV3bGluZSAtPlxuICAgIGJlZ2luIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfZm9ybWF0X3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGUgKCogTm8gb3BlbiBib3guICopXG4gICAgfCBTb21lIHsgd2lkdGg7IF99IC0+IGJyZWFrX2xpbmUgc3RhdGUgd2lkdGhcbiAgICBlbmRcblxuICB8IFBwX2lmX25ld2xpbmUgLT5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyZW50X2luZGVudCAhPSBzdGF0ZS5wcF9tYXJnaW4gLSBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgdGhlbiBwcF9za2lwX3Rva2VuIHN0YXRlXG5cbiAgfCBQcF9icmVhayB7IGZpdHM7IGJyZWFrcyB9IC0+XG4gICAgbGV0IGJlZm9yZSwgb2ZmLCBfID0gYnJlYWtzIGluXG4gICAgYmVnaW4gbWF0Y2ggU3RhY2sudG9wX29wdCBzdGF0ZS5wcF9mb3JtYXRfc3RhY2sgd2l0aFxuICAgIHwgTm9uZSAtPiAoKSAoKiBObyBvcGVuIGJveC4gKilcbiAgICB8IFNvbWUgeyBib3hfdHlwZTsgd2lkdGggfSAtPlxuICAgICAgYmVnaW4gbWF0Y2ggYm94X3R5cGUgd2l0aFxuICAgICAgfCBQcF9ob3Zib3ggLT5cbiAgICAgICAgaWYgc2l6ZSArIFN0cmluZy5sZW5ndGggYmVmb3JlID4gc3RhdGUucHBfc3BhY2VfbGVmdFxuICAgICAgICB0aGVuIGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgICBlbHNlIGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICB8IFBwX2JveCAtPlxuICAgICAgICAoKiBIYXZlIHRoZSBsaW5lIGp1c3QgYmVlbiBicm9rZW4gaGVyZSA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2lzX25ld19saW5lIHRoZW4gYnJlYWtfc2FtZV9saW5lIHN0YXRlIGZpdHMgZWxzZVxuICAgICAgICBpZiBzaXplICsgU3RyaW5nLmxlbmd0aCBiZWZvcmUgPiBzdGF0ZS5wcF9zcGFjZV9sZWZ0XG4gICAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGggZWxzZVxuICAgICAgICAoKiBicmVhayB0aGUgbGluZSBoZXJlIGxlYWRzIHRvIG5ldyBpbmRlbnRhdGlvbiA/ICopXG4gICAgICAgIGlmIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50ID4gc3RhdGUucHBfbWFyZ2luIC0gd2lkdGggKyBvZmZcbiAgICAgICAgdGhlbiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgICAgZWxzZSBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF9odmJveCAtPiBicmVha19uZXdfbGluZSBzdGF0ZSBicmVha3Mgd2lkdGhcbiAgICAgIHwgUHBfZml0cyAtPiBicmVha19zYW1lX2xpbmUgc3RhdGUgZml0c1xuICAgICAgfCBQcF92Ym94IC0+IGJyZWFrX25ld19saW5lIHN0YXRlIGJyZWFrcyB3aWR0aFxuICAgICAgfCBQcF9oYm94IC0+IGJyZWFrX3NhbWVfbGluZSBzdGF0ZSBmaXRzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgfCBQcF9vcGVuX3RhZyB0YWdfbmFtZSAtPlxuICAgICBsZXQgbWFya2VyID0gc3RhdGUucHBfbWFya19vcGVuX3RhZyB0YWdfbmFtZSBpblxuICAgICBwcF9vdXRwdXRfc3RyaW5nIHN0YXRlIG1hcmtlcjtcbiAgICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF9tYXJrX3N0YWNrXG5cbiAgIHwgUHBfY2xvc2VfdGFnIC0+XG4gICAgIGJlZ2luIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfbWFya19zdGFjayB3aXRoXG4gICAgIHwgTm9uZSAtPiAoKSAoKiBObyBtb3JlIHRhZyB0byBjbG9zZS4gKilcbiAgICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICAgbGV0IG1hcmtlciA9IHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIHRhZ19uYW1lIGluXG4gICAgICAgcHBfb3V0cHV0X3N0cmluZyBzdGF0ZSBtYXJrZXJcbiAgICAgZW5kXG5cblxuKCogUHJpbnQgaWYgdG9rZW4gc2l6ZSBpcyBrbm93biBlbHNlIHByaW50aW5nIGlzIGRlbGF5ZWQuXG4gICBQcmludGluZyBpcyBkZWxheWVkIHdoZW4gdGhlIHRleHQgd2FpdGluZyBpbiB0aGUgcXVldWUgcmVxdWlyZXNcbiAgIG1vcmUgcm9vbSB0byBmb3JtYXQgdGhhbiBleGlzdHMgb24gdGhlIGN1cnJlbnQgbGluZS4gKilcbmxldCByZWMgYWR2YW5jZV9sZWZ0IHN0YXRlID1cbiAgbWF0Y2ggUXVldWUucGVla19vcHQgc3RhdGUucHBfcXVldWUgd2l0aFxuICB8IE5vbmUgLT4gKCkgKCogTm8gdG9rZW5zIHRvIHByaW50ICopXG4gIHwgU29tZSB7IHNpemU7IHRva2VuOyBsZW5ndGggfSAtPlxuICAgIGxldCBwZW5kaW5nX2NvdW50ID0gc3RhdGUucHBfcmlnaHRfdG90YWwgLSBzdGF0ZS5wcF9sZWZ0X3RvdGFsIGluXG4gICAgaWYgU2l6ZS5pc19rbm93biBzaXplIHx8IHBlbmRpbmdfY291bnQgPj0gc3RhdGUucHBfc3BhY2VfbGVmdCB0aGVuIGJlZ2luXG4gICAgICBRdWV1ZS50YWtlIHN0YXRlLnBwX3F1ZXVlIHw+IGlnbm9yZTsgKCogTm90IGVtcHR5OiB3ZSBwZWVrIGludG8gaXQgKilcbiAgICAgIGxldCBzaXplID0gaWYgU2l6ZS5pc19rbm93biBzaXplIHRoZW4gU2l6ZS50b19pbnQgc2l6ZSBlbHNlIHBwX2luZmluaXR5IGluXG4gICAgICBmb3JtYXRfcHBfdG9rZW4gc3RhdGUgc2l6ZSB0b2tlbjtcbiAgICAgIHN0YXRlLnBwX2xlZnRfdG90YWwgPC0gbGVuZ3RoICsgc3RhdGUucHBfbGVmdF90b3RhbDtcbiAgICAgIChhZHZhbmNlX2xlZnQgW0B0YWlsY2FsbF0pIHN0YXRlXG4gICAgZW5kXG5cblxuKCogVG8gZW5xdWV1ZSBhIHRva2VuIDogdHJ5IHRvIGFkdmFuY2UuICopXG5sZXQgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHRvayA9IHBwX2VucXVldWUgc3RhdGUgdG9rOyBhZHZhbmNlX2xlZnQgc3RhdGVcblxuXG4oKiBUbyBlbnF1ZXVlIHN0cmluZ3MuICopXG5sZXQgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgc2l6ZSBzID1cbiAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIHsgc2l6ZTsgdG9rZW4gPSBQcF90ZXh0IHM7IGxlbmd0aCA9IFNpemUudG9faW50IHNpemUgfVxuXG5cbmxldCBlbnF1ZXVlX3N0cmluZyBzdGF0ZSBzID1cbiAgZW5xdWV1ZV9zdHJpbmdfYXMgc3RhdGUgKFNpemUub2ZfaW50IChTdHJpbmcubGVuZ3RoIHMpKSBzXG5cblxuKCogUm91dGluZXMgZm9yIHNjYW4gc3RhY2tcbiAgIGRldGVybWluZSBzaXplIG9mIGJveGVzLiAqKVxuXG4oKiBUaGUgc2Nhbl9zdGFjayBpcyBuZXZlciBlbXB0eS4gKilcbmxldCBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhY2sgPVxuICBTdGFjay5jbGVhciBzdGFjaztcbiAgbGV0IHF1ZXVlX2VsZW0gPSB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfdGV4dCBcIlwiOyBsZW5ndGggPSAwIH0gaW5cbiAgU3RhY2sucHVzaCB7IGxlZnRfdG90YWwgPSAtMTsgcXVldWVfZWxlbSB9IHN0YWNrXG5cbigqIFNldHRpbmcgdGhlIHNpemUgb2YgYm94ZXMgb24gc2NhbiBzdGFjazpcbiAgIGlmIHR5ID0gdHJ1ZSB0aGVuIHNpemUgb2YgYnJlYWsgaXMgc2V0IGVsc2Ugc2l6ZSBvZiBib3ggaXMgc2V0O1xuICAgaW4gZWFjaCBjYXNlIHBwX3NjYW5fc3RhY2sgaXMgcG9wcGVkLlxuXG4gICBOb3RlOlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiBzY2FuIHN0YWNrIGlzIGV4aGF1c3RpdmUsIHNpbmNlIHNjYW5fc3RhY2sgaXMgbmV2ZXJcbiAgIGVtcHR5LlxuICAgUGF0dGVybiBtYXRjaGluZyBvbiB0b2tlbiBpbiBzY2FuIHN0YWNrIGlzIGFsc28gZXhoYXVzdGl2ZSxcbiAgIHNpbmNlIHNjYW5fcHVzaCBpcyB1c2VkIG9uIGJyZWFrcyBhbmQgb3BlbmluZyBvZiBib3hlcy4gKilcbmxldCBzZXRfc2l6ZSBzdGF0ZSB0eSA9XG4gIG1hdGNoIFN0YWNrLnRvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB3aXRoXG4gIHwgTm9uZSAtPiAoKSAoKiBzY2FuX3N0YWNrIGlzIG5ldmVyIGVtcHR5LiAqKVxuICB8IFNvbWUgeyBsZWZ0X3RvdGFsOyBxdWV1ZV9lbGVtIH0gLT5cbiAgICBsZXQgc2l6ZSA9IFNpemUudG9faW50IHF1ZXVlX2VsZW0uc2l6ZSBpblxuICAgICgqIHRlc3QgaWYgc2NhbiBzdGFjayBjb250YWlucyBhbnkgZGF0YSB0aGF0IGlzIG5vdCBvYnNvbGV0ZS4gKilcbiAgICBpZiBsZWZ0X3RvdGFsIDwgc3RhdGUucHBfbGVmdF90b3RhbCB0aGVuXG4gICAgICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFja1xuICAgIGVsc2VcbiAgICAgIG1hdGNoIHF1ZXVlX2VsZW0udG9rZW4gd2l0aFxuICAgICAgfCBQcF9icmVhayBfIHwgUHBfdGJyZWFrIChfLCBfKSAtPlxuICAgICAgICBpZiB0eSB0aGVuIGJlZ2luXG4gICAgICAgICAgcXVldWVfZWxlbS5zaXplIDwtIFNpemUub2ZfaW50IChzdGF0ZS5wcF9yaWdodF90b3RhbCArIHNpemUpO1xuICAgICAgICAgIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfc2Nhbl9zdGFjayB8PiBpZ25vcmVcbiAgICAgICAgZW5kXG4gICAgICB8IFBwX2JlZ2luIChfLCBfKSAtPlxuICAgICAgICBpZiBub3QgdHkgdGhlbiBiZWdpblxuICAgICAgICAgIHF1ZXVlX2VsZW0uc2l6ZSA8LSBTaXplLm9mX2ludCAoc3RhdGUucHBfcmlnaHRfdG90YWwgKyBzaXplKTtcbiAgICAgICAgICBTdGFjay5wb3Bfb3B0IHN0YXRlLnBwX3NjYW5fc3RhY2sgfD4gaWdub3JlXG4gICAgICAgIGVuZFxuICAgICAgfCBQcF90ZXh0IF8gfCBQcF9zdGFiIHwgUHBfdGJlZ2luIF8gfCBQcF90ZW5kIHwgUHBfZW5kXG4gICAgICB8IFBwX25ld2xpbmUgfCBQcF9pZl9uZXdsaW5lIHwgUHBfb3Blbl90YWcgXyB8IFBwX2Nsb3NlX3RhZyAtPlxuICAgICAgICAoKSAoKiBzY2FuX3B1c2ggaXMgb25seSB1c2VkIGZvciBicmVha3MgYW5kIGJveGVzLiAqKVxuXG5cbigqIFB1c2ggYSB0b2tlbiBvbiBwcmV0dHktcHJpbnRlciBzY2FubmluZyBzdGFjay5cbiAgIElmIGIgaXMgdHJ1ZSBzZXRfc2l6ZSBpcyBjYWxsZWQuICopXG5sZXQgc2Nhbl9wdXNoIHN0YXRlIGIgdG9rZW4gPVxuICBwcF9lbnF1ZXVlIHN0YXRlIHRva2VuO1xuICBpZiBiIHRoZW4gc2V0X3NpemUgc3RhdGUgdHJ1ZTtcbiAgbGV0IGVsZW0gPSB7IGxlZnRfdG90YWwgPSBzdGF0ZS5wcF9yaWdodF90b3RhbDsgcXVldWVfZWxlbSA9IHRva2VuIH0gaW5cbiAgU3RhY2sucHVzaCBlbGVtIHN0YXRlLnBwX3NjYW5fc3RhY2tcblxuXG4oKiBUbyBvcGVuIGEgbmV3IGJveCA6XG4gICB0aGUgdXNlciBtYXkgc2V0IHRoZSBkZXB0aCBib3VuZCBwcF9tYXhfYm94ZXNcbiAgIGFueSB0ZXh0IG5lc3RlZCBkZWVwZXIgaXMgcHJpbnRlZCBhcyB0aGUgZWxsaXBzaXMgc3RyaW5nLiAqKVxubGV0IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgYnJfdHkgPVxuICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggKyAxO1xuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX2JlZ2luIChpbmRlbnQsIGJyX3R5KTsgbGVuZ3RoID0gMCB9IGluXG4gICAgc2Nhbl9wdXNoIHN0YXRlIGZhbHNlIGVsZW0gZWxzZVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoID0gc3RhdGUucHBfbWF4X2JveGVzXG4gIHRoZW4gZW5xdWV1ZV9zdHJpbmcgc3RhdGUgc3RhdGUucHBfZWxsaXBzaXNcblxuXG4oKiBUaGUgYm94IHdoaWNoIGlzIGFsd2F5cyBvcGVuLiAqKVxubGV0IHBwX29wZW5fc3lzX2JveCBzdGF0ZSA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSAwIFBwX2hvdmJveFxuXG4oKiBDbG9zZSBhIGJveCwgc2V0dGluZyBzaXplcyBvZiBpdHMgc3ViIGJveGVzLiAqKVxubGV0IHBwX2Nsb3NlX2JveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBiZWdpblxuICAgICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfZW5kOyBsZW5ndGggPSAwIH07XG4gICAgICBzZXRfc2l6ZSBzdGF0ZSB0cnVlOyBzZXRfc2l6ZSBzdGF0ZSBmYWxzZVxuICAgIGVuZDtcbiAgICBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwtIHN0YXRlLnBwX2N1cnJfZGVwdGggLSAxO1xuICBlbmRcblxuXG4oKiBPcGVuIGEgdGFnLCBwdXNoaW5nIGl0IG9uIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfb3Blbl9zdGFnIHN0YXRlIHRhZ19uYW1lID1cbiAgaWYgc3RhdGUucHBfcHJpbnRfdGFncyB0aGVuXG4gIGJlZ2luXG4gICAgU3RhY2sucHVzaCB0YWdfbmFtZSBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gICAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgdGFnX25hbWVcbiAgZW5kO1xuICBpZiBzdGF0ZS5wcF9tYXJrX3RhZ3MgdGhlblxuICAgIGxldCB0b2tlbiA9IFBwX29wZW5fdGFnIHRhZ19uYW1lIGluXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuOyBsZW5ndGggPSAwIH1cblxuXG4oKiBDbG9zZSBhIHRhZywgcG9wcGluZyBpdCBmcm9tIHRoZSB0YWcgc3RhY2suICopXG5sZXQgcHBfY2xvc2Vfc3RhZyBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX21hcmtfdGFncyB0aGVuXG4gICAgcHBfZW5xdWV1ZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfY2xvc2VfdGFnOyBsZW5ndGggPSAwIH07XG4gIGlmIHN0YXRlLnBwX3ByaW50X3RhZ3MgdGhlblxuICAgIG1hdGNoIFN0YWNrLnBvcF9vcHQgc3RhdGUucHBfdGFnX3N0YWNrIHdpdGhcbiAgICB8IE5vbmUgLT4gKCkgKCogTm8gbW9yZSB0YWcgdG8gY2xvc2UuICopXG4gICAgfCBTb21lIHRhZ19uYW1lIC0+XG4gICAgICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgdGFnX25hbWVcblxubGV0IHBwX29wZW5fdGFnIHN0YXRlIHMgPSBwcF9vcGVuX3N0YWcgc3RhdGUgKFN0cmluZ190YWcgcylcbmxldCBwcF9jbG9zZV90YWcgc3RhdGUgKCkgPSBwcF9jbG9zZV9zdGFnIHN0YXRlICgpXG5cbmxldCBwcF9zZXRfcHJpbnRfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfcHJpbnRfdGFncyA8LSBiXG5sZXQgcHBfc2V0X21hcmtfdGFncyBzdGF0ZSBiID0gc3RhdGUucHBfbWFya190YWdzIDwtIGJcbmxldCBwcF9nZXRfcHJpbnRfdGFncyBzdGF0ZSAoKSA9IHN0YXRlLnBwX3ByaW50X3RhZ3NcbmxldCBwcF9nZXRfbWFya190YWdzIHN0YXRlICgpID0gc3RhdGUucHBfbWFya190YWdzXG5sZXQgcHBfc2V0X3RhZ3Mgc3RhdGUgYiA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0YXRlIGI7IHBwX3NldF9tYXJrX3RhZ3Mgc3RhdGUgYlxuXG5cbigqIEhhbmRsaW5nIHRhZyBoYW5kbGluZyBmdW5jdGlvbnM6IGdldC9zZXQgZnVuY3Rpb25zLiAqKVxubGV0IHBwX2dldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RhdGUgKCkgPSB7XG4gIG1hcmtfb3Blbl9zdGFnID0gc3RhdGUucHBfbWFya19vcGVuX3RhZztcbiAgbWFya19jbG9zZV9zdGFnID0gc3RhdGUucHBfbWFya19jbG9zZV90YWc7XG4gIHByaW50X29wZW5fc3RhZyA9IHN0YXRlLnBwX3ByaW50X29wZW5fdGFnO1xuICBwcmludF9jbG9zZV9zdGFnID0gc3RhdGUucHBfcHJpbnRfY2xvc2VfdGFnO1xufVxuXG5cbmxldCBwcF9zZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3N0YWcgPSBtb3Q7XG4gICAgIG1hcmtfY2xvc2Vfc3RhZyA9IG1jdDtcbiAgICAgcHJpbnRfb3Blbl9zdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV9zdGFnID0gcGN0O1xuICB9ID1cbiAgc3RhdGUucHBfbWFya19vcGVuX3RhZyA8LSBtb3Q7XG4gIHN0YXRlLnBwX21hcmtfY2xvc2VfdGFnIDwtIG1jdDtcbiAgc3RhdGUucHBfcHJpbnRfb3Blbl90YWcgPC0gcG90O1xuICBzdGF0ZS5wcF9wcmludF9jbG9zZV90YWcgPC0gcGN0XG5cblxuKCogSW5pdGlhbGl6ZSBwcmV0dHktcHJpbnRlci4gKilcbmxldCBwcF9yaW5pdCBzdGF0ZSA9XG4gIHBwX2NsZWFyX3F1ZXVlIHN0YXRlO1xuICBpbml0aWFsaXplX3NjYW5fc3RhY2sgc3RhdGUucHBfc2Nhbl9zdGFjaztcbiAgU3RhY2suY2xlYXIgc3RhdGUucHBfZm9ybWF0X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90Ym94X3N0YWNrO1xuICBTdGFjay5jbGVhciBzdGF0ZS5wcF90YWdfc3RhY2s7XG4gIFN0YWNrLmNsZWFyIHN0YXRlLnBwX21hcmtfc3RhY2s7XG4gIHN0YXRlLnBwX2N1cnJlbnRfaW5kZW50IDwtIDA7XG4gIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gMDtcbiAgc3RhdGUucHBfc3BhY2VfbGVmdCA8LSBzdGF0ZS5wcF9tYXJnaW47XG4gIHBwX29wZW5fc3lzX2JveCBzdGF0ZVxuXG5sZXQgY2xlYXJfdGFnX3N0YWNrIHN0YXRlID1cbiAgU3RhY2suaXRlciAoZnVuIF8gLT4gcHBfY2xvc2VfdGFnIHN0YXRlICgpKSBzdGF0ZS5wcF90YWdfc3RhY2tcblxuXG4oKiBGbHVzaGluZyBwcmV0dHktcHJpbnRlciBxdWV1ZS4gKilcbmxldCBwcF9mbHVzaF9xdWV1ZSBzdGF0ZSBiID1cbiAgY2xlYXJfdGFnX3N0YWNrIHN0YXRlO1xuICB3aGlsZSBzdGF0ZS5wcF9jdXJyX2RlcHRoID4gMSBkb1xuICAgIHBwX2Nsb3NlX2JveCBzdGF0ZSAoKVxuICBkb25lO1xuICBzdGF0ZS5wcF9yaWdodF90b3RhbCA8LSBwcF9pbmZpbml0eTtcbiAgYWR2YW5jZV9sZWZ0IHN0YXRlO1xuICBpZiBiIHRoZW4gcHBfb3V0cHV0X25ld2xpbmUgc3RhdGU7XG4gIHBwX3Jpbml0IHN0YXRlXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBmb3JtYXQgdmFsdWVzIGFuZCB1c2UgYm94ZXMuXG5cbiopXG5cbigqIFRvIGZvcm1hdCBhIHN0cmluZy4gKilcbmxldCBwcF9wcmludF9hc19zaXplIHN0YXRlIHNpemUgcyA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXNcbiAgdGhlbiBlbnF1ZXVlX3N0cmluZ19hcyBzdGF0ZSBzaXplIHNcblxuXG5sZXQgcHBfcHJpbnRfYXMgc3RhdGUgaXNpemUgcyA9XG4gIHBwX3ByaW50X2FzX3NpemUgc3RhdGUgKFNpemUub2ZfaW50IGlzaXplKSBzXG5cblxubGV0IHBwX3ByaW50X3N0cmluZyBzdGF0ZSBzID1cbiAgcHBfcHJpbnRfYXMgc3RhdGUgKFN0cmluZy5sZW5ndGggcykgc1xuXG5cbigqIFRvIGZvcm1hdCBhbiBpbnRlZ2VyLiAqKVxubGV0IHBwX3ByaW50X2ludCBzdGF0ZSBpID0gcHBfcHJpbnRfc3RyaW5nIHN0YXRlIChJbnQudG9fc3RyaW5nIGkpXG5cbigqIFRvIGZvcm1hdCBhIGZsb2F0LiAqKVxubGV0IHBwX3ByaW50X2Zsb2F0IHN0YXRlIGYgPSBwcF9wcmludF9zdHJpbmcgc3RhdGUgKHN0cmluZ19vZl9mbG9hdCBmKVxuXG4oKiBUbyBmb3JtYXQgYSBib29sZWFuLiAqKVxubGV0IHBwX3ByaW50X2Jvb2wgc3RhdGUgYiA9IHBwX3ByaW50X3N0cmluZyBzdGF0ZSAoc3RyaW5nX29mX2Jvb2wgYilcblxuKCogVG8gZm9ybWF0IGEgY2hhci4gKilcbmxldCBwcF9wcmludF9jaGFyIHN0YXRlIGMgPVxuICBwcF9wcmludF9hcyBzdGF0ZSAxIChTdHJpbmcubWFrZSAxIGMpXG5cblxuKCogT3BlbmluZyBib3hlcy4gKilcbmxldCBwcF9vcGVuX2hib3ggc3RhdGUgKCkgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgMCBQcF9oYm94XG5hbmQgcHBfb3Blbl92Ym94IHN0YXRlIGluZGVudCA9IHBwX29wZW5fYm94X2dlbiBzdGF0ZSBpbmRlbnQgUHBfdmJveFxuXG5hbmQgcHBfb3Blbl9odmJveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2h2Ym94XG5hbmQgcHBfb3Blbl9ob3Zib3ggc3RhdGUgaW5kZW50ID0gcHBfb3Blbl9ib3hfZ2VuIHN0YXRlIGluZGVudCBQcF9ob3Zib3hcbmFuZCBwcF9vcGVuX2JveCBzdGF0ZSBpbmRlbnQgPSBwcF9vcGVuX2JveF9nZW4gc3RhdGUgaW5kZW50IFBwX2JveFxuXG5cbigqIFByaW50aW5nIHF1ZXVlZCB0ZXh0LlxuXG4gICBbcHBfcHJpbnRfZmx1c2hdIHByaW50cyBhbGwgcGVuZGluZyBpdGVtcyBpbiB0aGUgcHJldHR5LXByaW50ZXIgcXVldWUgYW5kXG4gICB0aGVuIGZsdXNoZXMgdGhlIGxvdyBsZXZlbCBvdXRwdXQgZGV2aWNlIG9mIHRoZSBmb3JtYXR0ZXIgdG8gYWN0dWFsbHlcbiAgIGRpc3BsYXkgcHJpbnRpbmcgbWF0ZXJpYWwuXG5cbiAgIFtwcF9wcmludF9uZXdsaW5lXSBiZWhhdmVzIGFzIFtwcF9wcmludF9mbHVzaF0gYWZ0ZXIgcHJpbnRpbmcgYW4gYWRkaXRpb25hbFxuICAgbmV3IGxpbmUuICopXG5sZXQgcHBfcHJpbnRfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHN0YXRlIHRydWU7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuYW5kIHBwX3ByaW50X2ZsdXNoIHN0YXRlICgpID1cbiAgcHBfZmx1c2hfcXVldWUgc3RhdGUgZmFsc2U7IHN0YXRlLnBwX291dF9mbHVzaCAoKVxuXG5cbigqIFRvIGdldCBhIG5ld2xpbmUgd2hlbiBvbmUgZG9lcyBub3Qgd2FudCB0byBjbG9zZSB0aGUgY3VycmVudCBib3guICopXG5sZXQgcHBfZm9yY2VfbmV3bGluZSBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGVucXVldWVfYWR2YW5jZSBzdGF0ZSB7IHNpemUgPSBTaXplLnplcm87IHRva2VuID0gUHBfbmV3bGluZTsgbGVuZ3RoID0gMCB9XG5cblxuKCogVG8gZm9ybWF0IHNvbWV0aGluZywgb25seSBpbiBjYXNlIHRoZSBsaW5lIGhhcyBqdXN0IGJlZW4gYnJva2VuLiAqKVxubGV0IHBwX3ByaW50X2lmX25ld2xpbmUgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGVcbiAgICAgIHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9pZl9uZXdsaW5lOyBsZW5ndGggPSAwIH1cblxuXG4oKiBHZW5lcmFsaXplZCBicmVhayBoaW50IHRoYXQgYWxsb3dzIHByaW50aW5nIHN0cmluZ3MgYmVmb3JlL2FmdGVyXG4gICBzYW1lLWxpbmUgb2Zmc2V0ICh3aWR0aCkgb3IgbmV3LWxpbmUgb2Zmc2V0ICopXG5sZXQgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlIH5maXRzIH5icmVha3MgPVxuICBsZXQgYmVmb3JlLCB3aWR0aCwgYWZ0ZXIgPSBmaXRzIGluXG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgIGxldCBzaXplID0gU2l6ZS5vZl9pbnQgKC0gc3RhdGUucHBfcmlnaHRfdG90YWwpIGluXG4gICAgbGV0IHRva2VuID0gUHBfYnJlYWsgeyBmaXRzOyBicmVha3MgfSBpblxuICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoIGJlZm9yZSArIHdpZHRoICsgU3RyaW5nLmxlbmd0aCBhZnRlciBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbjsgbGVuZ3RoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cbigqIFByaW50aW5nIGJyZWFrIGhpbnRzOlxuICAgQSBicmVhayBoaW50IGluZGljYXRlcyB3aGVyZSBhIGJveCBtYXkgYmUgYnJva2VuLlxuICAgSWYgbGluZSBpcyBicm9rZW4gdGhlbiBvZmZzZXQgaXMgYWRkZWQgdG8gdGhlIGluZGVudGF0aW9uIG9mIHRoZSBjdXJyZW50XG4gICBib3ggZWxzZSAodGhlIHZhbHVlIG9mKSB3aWR0aCBibGFua3MgYXJlIHByaW50ZWQuICopXG5sZXQgcHBfcHJpbnRfYnJlYWsgc3RhdGUgd2lkdGggb2Zmc2V0ID1cbiAgcHBfcHJpbnRfY3VzdG9tX2JyZWFrIHN0YXRlXG4gICAgfmZpdHM6KFwiXCIsIHdpZHRoLCBcIlwiKSB+YnJlYWtzOihcIlwiLCBvZmZzZXQsIFwiXCIpXG5cblxuKCogUHJpbnQgYSBzcGFjZSA6XG4gICBhIHNwYWNlIGlzIGEgYnJlYWsgaGludCB0aGF0IHByaW50cyBhIHNpbmdsZSBzcGFjZSBpZiB0aGUgYnJlYWsgZG9lcyBub3RcbiAgIHNwbGl0IHRoZSBsaW5lO1xuICAgYSBjdXQgaXMgYSBicmVhayBoaW50IHRoYXQgcHJpbnRzIG5vdGhpbmcgaWYgdGhlIGJyZWFrIGRvZXMgbm90IHNwbGl0IHRoZVxuICAgbGluZS4gKilcbmxldCBwcF9wcmludF9zcGFjZSBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDEgMFxuYW5kIHBwX3ByaW50X2N1dCBzdGF0ZSAoKSA9IHBwX3ByaW50X2JyZWFrIHN0YXRlIDAgMFxuXG5cbigqIFRhYnVsYXRpb24gYm94ZXMuICopXG5sZXQgcHBfb3Blbl90Ym94IHN0YXRlICgpID1cbiAgc3RhdGUucHBfY3Vycl9kZXB0aCA8LSBzdGF0ZS5wcF9jdXJyX2RlcHRoICsgMTtcbiAgaWYgc3RhdGUucHBfY3Vycl9kZXB0aCA8IHN0YXRlLnBwX21heF9ib3hlcyB0aGVuXG4gICAgbGV0IHNpemUgPSBTaXplLnplcm8gaW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZTsgdG9rZW4gPSBQcF90YmVnaW4gKFBwX3Rib3ggKHJlZiBbXSkpOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqIENsb3NlIGEgdGFidWxhdGlvbiBib3guICopXG5sZXQgcHBfY2xvc2VfdGJveCBzdGF0ZSAoKSA9XG4gIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPiAxIHRoZW5cbiAgYmVnaW5cbiAgIGlmIHN0YXRlLnBwX2N1cnJfZGVwdGggPCBzdGF0ZS5wcF9tYXhfYm94ZXMgdGhlblxuICAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF90ZW5kOyBsZW5ndGggPSAwIH0gaW5cbiAgICAgZW5xdWV1ZV9hZHZhbmNlIHN0YXRlIGVsZW07XG4gICAgIHN0YXRlLnBwX2N1cnJfZGVwdGggPC0gc3RhdGUucHBfY3Vycl9kZXB0aCAtIDFcbiAgZW5kXG5cblxuKCogUHJpbnQgYSB0YWJ1bGF0aW9uIGJyZWFrLiAqKVxubGV0IHBwX3ByaW50X3RicmVhayBzdGF0ZSB3aWR0aCBvZmZzZXQgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgc2l6ZSA9IFNpemUub2ZfaW50ICgtIHN0YXRlLnBwX3JpZ2h0X3RvdGFsKSBpblxuICAgIGxldCBlbGVtID0geyBzaXplOyB0b2tlbiA9IFBwX3RicmVhayAod2lkdGgsIG9mZnNldCk7IGxlbmd0aCA9IHdpZHRoIH0gaW5cbiAgICBzY2FuX3B1c2ggc3RhdGUgdHJ1ZSBlbGVtXG5cblxubGV0IHBwX3ByaW50X3RhYiBzdGF0ZSAoKSA9IHBwX3ByaW50X3RicmVhayBzdGF0ZSAwIDBcblxubGV0IHBwX3NldF90YWIgc3RhdGUgKCkgPVxuICBpZiBzdGF0ZS5wcF9jdXJyX2RlcHRoIDwgc3RhdGUucHBfbWF4X2JveGVzIHRoZW5cbiAgICBsZXQgZWxlbSA9IHsgc2l6ZSA9IFNpemUuemVybzsgdG9rZW4gPSBQcF9zdGFiOyBsZW5ndGggPSAwIH0gaW5cbiAgICBlbnF1ZXVlX2FkdmFuY2Ugc3RhdGUgZWxlbVxuXG5cbigqXG5cbiAgUHJvY2VkdXJlcyB0byBjb250cm9sIHRoZSBwcmV0dHktcHJpbnRlcnNcblxuKilcblxuKCogU2V0X21heF9ib3hlcy4gKilcbmxldCBwcF9zZXRfbWF4X2JveGVzIHN0YXRlIG4gPSBpZiBuID4gMSB0aGVuIHN0YXRlLnBwX21heF9ib3hlcyA8LSBuXG5cbigqIFRvIGtub3cgdGhlIGN1cnJlbnQgbWF4aW11bSBudW1iZXIgb2YgYm94ZXMgYWxsb3dlZC4gKilcbmxldCBwcF9nZXRfbWF4X2JveGVzIHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2JveGVzXG5cbmxldCBwcF9vdmVyX21heF9ib3hlcyBzdGF0ZSAoKSA9IHN0YXRlLnBwX2N1cnJfZGVwdGggPSBzdGF0ZS5wcF9tYXhfYm94ZXNcblxuKCogRWxsaXBzaXMuICopXG5sZXQgcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RhdGUgcyA9IHN0YXRlLnBwX2VsbGlwc2lzIDwtIHNcbmFuZCBwcF9nZXRfZWxsaXBzaXNfdGV4dCBzdGF0ZSAoKSA9IHN0YXRlLnBwX2VsbGlwc2lzXG5cblxuKCogVG8gc2V0IHRoZSBtYXJnaW4gb2YgcHJldHR5LXByaW50ZXIuICopXG5sZXQgcHBfbGltaXQgbiA9XG4gIGlmIG4gPCBwcF9pbmZpbml0eSB0aGVuIG4gZWxzZSBwcmVkIHBwX2luZmluaXR5XG5cblxuKCogSW50ZXJuYWwgcHJldHR5LXByaW50ZXIgZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9taW5fc3BhY2VfbGVmdCBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9taW5fc3BhY2VfbGVmdCA8LSBuO1xuICAgIHN0YXRlLnBwX21heF9pbmRlbnQgPC0gc3RhdGUucHBfbWFyZ2luIC0gc3RhdGUucHBfbWluX3NwYWNlX2xlZnQ7XG4gICAgcHBfcmluaXQgc3RhdGVcblxuXG4oKiBJbml0aWFsbHksIHdlIGhhdmUgOlxuICAgcHBfbWF4X2luZGVudCA9IHBwX21hcmdpbiAtIHBwX21pbl9zcGFjZV9sZWZ0LCBhbmRcbiAgIHBwX3NwYWNlX2xlZnQgPSBwcF9tYXJnaW4uICopXG5sZXQgcHBfc2V0X21heF9pbmRlbnQgc3RhdGUgbiA9XG4gIGlmIG4gPiAxIHRoZW5cbiAgICBwcF9zZXRfbWluX3NwYWNlX2xlZnQgc3RhdGUgKHN0YXRlLnBwX21hcmdpbiAtIG4pXG5cblxubGV0IHBwX2dldF9tYXhfaW5kZW50IHN0YXRlICgpID0gc3RhdGUucHBfbWF4X2luZGVudFxuXG5sZXQgcHBfc2V0X21hcmdpbiBzdGF0ZSBuID1cbiAgaWYgbiA+PSAxIHRoZW5cbiAgICBsZXQgbiA9IHBwX2xpbWl0IG4gaW5cbiAgICBzdGF0ZS5wcF9tYXJnaW4gPC0gbjtcbiAgICBsZXQgbmV3X21heF9pbmRlbnQgPVxuICAgICAgKCogVHJ5IHRvIG1haW50YWluIG1heF9pbmRlbnQgdG8gaXRzIGFjdHVhbCB2YWx1ZS4gKilcbiAgICAgIGlmIHN0YXRlLnBwX21heF9pbmRlbnQgPD0gc3RhdGUucHBfbWFyZ2luXG4gICAgICB0aGVuIHN0YXRlLnBwX21heF9pbmRlbnQgZWxzZVxuICAgICAgKCogSWYgcG9zc2libGUgbWFpbnRhaW4gcHBfbWluX3NwYWNlX2xlZnQgdG8gaXRzIGFjdHVhbCB2YWx1ZSxcbiAgICAgICAgIGlmIHRoaXMgbGVhZHMgdG8gYSB0b28gc21hbGwgbWF4X2luZGVudCwgdGFrZSBoYWxmIG9mIHRoZVxuICAgICAgICAgbmV3IG1hcmdpbiwgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIDEuICopXG4gICAgICAgbWF4IChtYXggKHN0YXRlLnBwX21hcmdpbiAtIHN0YXRlLnBwX21pbl9zcGFjZV9sZWZ0KVxuICAgICAgICAgICAgICAgIChzdGF0ZS5wcF9tYXJnaW4gLyAyKSkgMSBpblxuICAgICgqIFJlYnVpbGQgaW52YXJpYW50cy4gKilcbiAgICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBuZXdfbWF4X2luZGVudFxuXG5cbigqKiBHZW9tZXRyeSBmdW5jdGlvbnMgYW5kIHR5cGVzICopXG50eXBlIGdlb21ldHJ5ID0geyBtYXhfaW5kZW50OmludDsgbWFyZ2luOiBpbnR9XG5cbmxldCB2YWxpZGF0ZV9nZW9tZXRyeSB7bWFyZ2luOyBtYXhfaW5kZW50fSA9XG4gIGlmIG1heF9pbmRlbnQgPCAyIHRoZW5cbiAgICBFcnJvciBcIm1heF9pbmRlbnQgPCAyXCJcbiAgZWxzZSBpZiBtYXJnaW4gPD0gbWF4X2luZGVudCB0aGVuXG4gICAgRXJyb3IgXCJtYXJnaW4gPD0gbWF4X2luZGVudFwiXG4gIGVsc2UgT2sgKClcblxubGV0IGNoZWNrX2dlb21ldHJ5IGdlb21ldHJ5ID1cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IE9rICgpIC0+IHRydWVcbiAgfCBFcnJvciBfIC0+IGZhbHNlXG5cbmxldCBwcF9nZXRfbWFyZ2luIHN0YXRlICgpID0gc3RhdGUucHBfbWFyZ2luXG5cbmxldCBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSB7bWFyZ2luOyBtYXhfaW5kZW50fSA9XG4gIHBwX3NldF9tYXJnaW4gc3RhdGUgbWFyZ2luO1xuICBwcF9zZXRfbWF4X2luZGVudCBzdGF0ZSBtYXhfaW5kZW50O1xuICAoKVxuXG5sZXQgcHBfc2V0X2dlb21ldHJ5IHN0YXRlIH5tYXhfaW5kZW50IH5tYXJnaW4gPVxuICBsZXQgZ2VvbWV0cnkgPSB7IG1heF9pbmRlbnQ7IG1hcmdpbiB9IGluXG4gIG1hdGNoIHZhbGlkYXRlX2dlb21ldHJ5IGdlb21ldHJ5IHdpdGhcbiAgfCBFcnJvciBtc2cgLT5cbiAgICByYWlzZSAoSW52YWxpZF9hcmd1bWVudCAoXCJGb3JtYXQucHBfc2V0X2dlb21ldHJ5OiBcIiBeIG1zZykpXG4gIHwgT2sgKCkgLT5cbiAgICBwcF9zZXRfZnVsbF9nZW9tZXRyeSBzdGF0ZSBnZW9tZXRyeVxuXG5sZXQgcHBfc2FmZV9zZXRfZ2VvbWV0cnkgc3RhdGUgfm1heF9pbmRlbnQgfm1hcmdpbiA9XG4gIGxldCBnZW9tZXRyeSA9IHsgbWF4X2luZGVudDsgbWFyZ2luIH0gaW5cbiAgbWF0Y2ggdmFsaWRhdGVfZ2VvbWV0cnkgZ2VvbWV0cnkgd2l0aFxuICB8IEVycm9yIF9tc2cgLT5cbiAgICAgKClcbiAgfCBPayAoKSAtPlxuICAgIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlIGdlb21ldHJ5XG5cbmxldCBwcF9nZXRfZ2VvbWV0cnkgc3RhdGUgKCkgPVxuICB7IG1hcmdpbiA9IHBwX2dldF9tYXJnaW4gc3RhdGUgKCk7IG1heF9pbmRlbnQgPSBwcF9nZXRfbWF4X2luZGVudCBzdGF0ZSAoKSB9XG5cbmxldCBwcF91cGRhdGVfZ2VvbWV0cnkgc3RhdGUgdXBkYXRlID1cbiAgbGV0IGdlb21ldHJ5ID0gcHBfZ2V0X2dlb21ldHJ5IHN0YXRlICgpIGluXG4gIHBwX3NldF9mdWxsX2dlb21ldHJ5IHN0YXRlICh1cGRhdGUgZ2VvbWV0cnkpXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgb3V0cHV0IGZ1bmN0aW9ucy4gKilcbmxldCBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RhdGUge1xuICAgICAgb3V0X3N0cmluZyA9IGY7XG4gICAgICBvdXRfZmx1c2ggPSBnO1xuICAgICAgb3V0X25ld2xpbmUgPSBoO1xuICAgICAgb3V0X3NwYWNlcyA9IGk7XG4gICAgICBvdXRfaW5kZW50ID0gajtcbiAgICB9ID1cbiAgc3RhdGUucHBfb3V0X3N0cmluZyA8LSBmO1xuICBzdGF0ZS5wcF9vdXRfZmx1c2ggPC0gZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGpcblxubGV0IHBwX2dldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyBzdGF0ZSAoKSA9IHtcbiAgb3V0X3N0cmluZyA9IHN0YXRlLnBwX291dF9zdHJpbmc7XG4gIG91dF9mbHVzaCA9IHN0YXRlLnBwX291dF9mbHVzaDtcbiAgb3V0X25ld2xpbmUgPSBzdGF0ZS5wcF9vdXRfbmV3bGluZTtcbiAgb3V0X3NwYWNlcyA9IHN0YXRlLnBwX291dF9zcGFjZXM7XG4gIG91dF9pbmRlbnQgPSBzdGF0ZS5wcF9vdXRfaW5kZW50O1xufVxuXG5cbigqIFNldHRpbmcgYSBmb3JtYXR0ZXIgYmFzaWMgc3RyaW5nIG91dHB1dCBhbmQgZmx1c2ggZnVuY3Rpb25zLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGF0ZSBmIGcgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIGY7IHN0YXRlLnBwX291dF9mbHVzaCA8LSBnXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RhdGUgKCkgPVxuICAoc3RhdGUucHBfb3V0X3N0cmluZywgc3RhdGUucHBfb3V0X2ZsdXNoKVxuXG5cbigqIFRoZSBkZWZhdWx0IGZ1bmN0aW9uIHRvIG91dHB1dCBuZXcgbGluZXMuICopXG5sZXQgZGlzcGxheV9uZXdsaW5lIHN0YXRlICgpID0gc3RhdGUucHBfb3V0X3N0cmluZyBcIlxcblwiIDAgIDFcblxuKCogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdG8gb3V0cHV0IHNwYWNlcy4gKilcbmxldCBibGFua19saW5lID0gU3RyaW5nLm1ha2UgODAgJyAnXG5sZXQgcmVjIGRpc3BsYXlfYmxhbmtzIHN0YXRlIG4gPVxuICBpZiBuID4gMCB0aGVuXG4gIGlmIG4gPD0gODAgdGhlbiBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCBuIGVsc2VcbiAgYmVnaW5cbiAgICBzdGF0ZS5wcF9vdXRfc3RyaW5nIGJsYW5rX2xpbmUgMCA4MDtcbiAgICBkaXNwbGF5X2JsYW5rcyBzdGF0ZSAobiAtIDgwKVxuICBlbmRcblxuXG4oKiBUaGUgZGVmYXVsdCBmdW5jdGlvbiB0byBvdXRwdXQgaW5kZW50YXRpb24gb2YgbmV3IGxpbmVzLiAqKVxubGV0IGRpc3BsYXlfaW5kZW50ID0gZGlzcGxheV9ibGFua3NcblxuKCogU2V0dGluZyBhIGZvcm1hdHRlciBiYXNpYyBvdXRwdXQgZnVuY3Rpb25zIGFzIHByaW50aW5nIHRvIGEgZ2l2ZW5cbiAgIFtQZXJ2YXNpdmUub3V0X2NoYW5uZWxdIHZhbHVlLiAqKVxubGV0IHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RhdGUgb2MgPVxuICBzdGF0ZS5wcF9vdXRfc3RyaW5nIDwtIG91dHB1dF9zdWJzdHJpbmcgb2M7XG4gIHN0YXRlLnBwX291dF9mbHVzaCA8LSAoZnVuICgpIC0+IGZsdXNoIG9jKTtcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gZGlzcGxheV9uZXdsaW5lIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHN0YXRlO1xuICBzdGF0ZS5wcF9vdXRfaW5kZW50IDwtIGRpc3BsYXlfaW5kZW50IHN0YXRlXG5cbigqXG5cbiAgRGVmaW5pbmcgc3BlY2lmaWMgZm9ybWF0dGVyc1xuXG4qKVxuXG5sZXQgZGVmYXVsdF9wcF9tYXJrX29wZW5fdGFnID0gZnVuY3Rpb25cbiAgfCBTdHJpbmdfdGFnIHMgLT4gXCI8XCIgXiBzIF4gXCI+XCJcbiAgfCBfIC0+IFwiXCJcbmxldCBkZWZhdWx0X3BwX21hcmtfY2xvc2VfdGFnID0gZnVuY3Rpb25cbiAgfCBTdHJpbmdfdGFnIHMgLT4gXCI8L1wiIF4gcyBeIFwiPlwiXG4gIHwgXyAtPiBcIlwiXG5cbmxldCBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnID0gaWdub3JlXG5sZXQgZGVmYXVsdF9wcF9wcmludF9jbG9zZV90YWcgPSBpZ25vcmVcblxuKCogQnVpbGRpbmcgYSBmb3JtYXR0ZXIgZ2l2ZW4gaXRzIGJhc2ljIG91dHB1dCBmdW5jdGlvbnMuXG4gICBPdGhlciBmaWVsZHMgZ2V0IHJlYXNvbmFibGUgZGVmYXVsdCB2YWx1ZXMuICopXG5sZXQgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqID1cbiAgKCogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGZvcm1hdHRlciBjb250YWlucyBhIGR1bW15IGJveC4gKilcbiAgbGV0IHBwX3F1ZXVlID0gUXVldWUuY3JlYXRlICgpIGluXG4gIGxldCBzeXNfdG9rID1cbiAgICB7IHNpemUgPSBTaXplLnVua25vd247IHRva2VuID0gUHBfYmVnaW4gKDAsIFBwX2hvdmJveCk7IGxlbmd0aCA9IDAgfSBpblxuICBRdWV1ZS5hZGQgc3lzX3RvayBwcF9xdWV1ZTtcbiAgbGV0IHNjYW5fc3RhY2sgPSBTdGFjay5jcmVhdGUgKCkgaW5cbiAgaW5pdGlhbGl6ZV9zY2FuX3N0YWNrIHNjYW5fc3RhY2s7XG4gIFN0YWNrLnB1c2ggeyBsZWZ0X3RvdGFsID0gMTsgcXVldWVfZWxlbSA9IHN5c190b2sgfSBzY2FuX3N0YWNrO1xuICBsZXQgcHBfbWFyZ2luID0gNzhcbiAgYW5kIHBwX21pbl9zcGFjZV9sZWZ0ID0gMTAgaW5cbiAge1xuICAgIHBwX3NjYW5fc3RhY2sgPSBzY2FuX3N0YWNrO1xuICAgIHBwX2Zvcm1hdF9zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF90Ym94X3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX3RhZ19zdGFjayA9IFN0YWNrLmNyZWF0ZSAoKTtcbiAgICBwcF9tYXJrX3N0YWNrID0gU3RhY2suY3JlYXRlICgpO1xuICAgIHBwX21hcmdpbiA9IHBwX21hcmdpbjtcbiAgICBwcF9taW5fc3BhY2VfbGVmdCA9IHBwX21pbl9zcGFjZV9sZWZ0O1xuICAgIHBwX21heF9pbmRlbnQgPSBwcF9tYXJnaW4gLSBwcF9taW5fc3BhY2VfbGVmdDtcbiAgICBwcF9zcGFjZV9sZWZ0ID0gcHBfbWFyZ2luO1xuICAgIHBwX2N1cnJlbnRfaW5kZW50ID0gMDtcbiAgICBwcF9pc19uZXdfbGluZSA9IHRydWU7XG4gICAgcHBfbGVmdF90b3RhbCA9IDE7XG4gICAgcHBfcmlnaHRfdG90YWwgPSAxO1xuICAgIHBwX2N1cnJfZGVwdGggPSAxO1xuICAgIHBwX21heF9ib3hlcyA9IG1heF9pbnQ7XG4gICAgcHBfZWxsaXBzaXMgPSBcIi5cIjtcbiAgICBwcF9vdXRfc3RyaW5nID0gZjtcbiAgICBwcF9vdXRfZmx1c2ggPSBnO1xuICAgIHBwX291dF9uZXdsaW5lID0gaDtcbiAgICBwcF9vdXRfc3BhY2VzID0gaTtcbiAgICBwcF9vdXRfaW5kZW50ID0gajtcbiAgICBwcF9wcmludF90YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya190YWdzID0gZmFsc2U7XG4gICAgcHBfbWFya19vcGVuX3RhZyA9IGRlZmF1bHRfcHBfbWFya19vcGVuX3RhZztcbiAgICBwcF9tYXJrX2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfbWFya19jbG9zZV90YWc7XG4gICAgcHBfcHJpbnRfb3Blbl90YWcgPSBkZWZhdWx0X3BwX3ByaW50X29wZW5fdGFnO1xuICAgIHBwX3ByaW50X2Nsb3NlX3RhZyA9IGRlZmF1bHRfcHBfcHJpbnRfY2xvc2VfdGFnO1xuICAgIHBwX3F1ZXVlID0gcHBfcXVldWU7XG4gIH1cblxuXG4oKiBCdWlsZCBhIGZvcm1hdHRlciBvdXQgb2YgaXRzIG91dCBmdW5jdGlvbnMuICopXG5sZXQgZm9ybWF0dGVyX29mX291dF9mdW5jdGlvbnMgb3V0X2Z1bnMgPVxuICBwcF9tYWtlX2Zvcm1hdHRlclxuICAgIG91dF9mdW5zLm91dF9zdHJpbmdcbiAgICBvdXRfZnVucy5vdXRfZmx1c2hcbiAgICBvdXRfZnVucy5vdXRfbmV3bGluZVxuICAgIG91dF9mdW5zLm91dF9zcGFjZXNcbiAgICBvdXRfZnVucy5vdXRfaW5kZW50XG5cblxuKCogTWFrZSBhIGZvcm1hdHRlciB3aXRoIGRlZmF1bHQgZnVuY3Rpb25zIHRvIG91dHB1dCBzcGFjZXMsXG4gIGluZGVudGF0aW9uLCBhbmQgbmV3IGxpbmVzLiAqKVxubGV0IG1ha2VfZm9ybWF0dGVyIG91dHB1dCBmbHVzaCA9XG4gIGxldCBwcGYgPSBwcF9tYWtlX2Zvcm1hdHRlciBvdXRwdXQgZmx1c2ggaWdub3JlIGlnbm9yZSBpZ25vcmUgaW5cbiAgcHBmLnBwX291dF9uZXdsaW5lIDwtIGRpc3BsYXlfbmV3bGluZSBwcGY7XG4gIHBwZi5wcF9vdXRfc3BhY2VzIDwtIGRpc3BsYXlfYmxhbmtzIHBwZjtcbiAgcHBmLnBwX291dF9pbmRlbnQgPC0gZGlzcGxheV9pbmRlbnQgcHBmO1xuICBwcGZcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbUGVydmFzaXZlLm91dF9jaGFubmVsXSB2YWx1ZS4gKilcbmxldCBmb3JtYXR0ZXJfb2Zfb3V0X2NoYW5uZWwgb2MgPVxuICBtYWtlX2Zvcm1hdHRlciAob3V0cHV0X3N1YnN0cmluZyBvYykgKGZ1biAoKSAtPiBmbHVzaCBvYylcblxuXG4oKiBNYWtlIGEgZm9ybWF0dGVyIHdyaXRpbmcgdG8gYSBnaXZlbiBbQnVmZmVyLnRdIHZhbHVlLiAqKVxubGV0IGZvcm1hdHRlcl9vZl9idWZmZXIgYiA9XG4gIG1ha2VfZm9ybWF0dGVyIChCdWZmZXIuYWRkX3N1YnN0cmluZyBiKSBpZ25vcmVcblxuXG4oKiBBbGxvY2F0aW5nIGJ1ZmZlciBmb3IgcHJldHR5LXByaW50aW5nIHB1cnBvc2VzLlxuICAgRGVmYXVsdCBidWZmZXIgc2l6ZSBpcyBwcF9idWZmZXJfc2l6ZSBvciA1MTIuXG4qKVxubGV0IHBwX2J1ZmZlcl9zaXplID0gNTEyXG5sZXQgcHBfbWFrZV9idWZmZXIgKCkgPSBCdWZmZXIuY3JlYXRlIHBwX2J1ZmZlcl9zaXplXG5cbigqIFRoZSBzdGFuZGFyZCAoc2hhcmVkKSBidWZmZXIuICopXG5sZXQgc3RkYnVmID0gcHBfbWFrZV9idWZmZXIgKClcblxuKCogUHJlZGVmaW5lZCBmb3JtYXR0ZXJzIHN0YW5kYXJkIGZvcm1hdHRlciB0byBwcmludFxuICAgdG8gW1N0ZGxpYi5zdGRvdXRdLCBbU3RkbGliLnN0ZGVycl0sIGFuZCB7IXN0ZGJ1Zn0uICopXG5sZXQgc3RkX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBTdGRsaWIuc3Rkb3V0XG5hbmQgZXJyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9vdXRfY2hhbm5lbCBTdGRsaWIuc3RkZXJyXG5hbmQgc3RyX2Zvcm1hdHRlciA9IGZvcm1hdHRlcl9vZl9idWZmZXIgc3RkYnVmXG5cblxuKCogW2ZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZl0gZmx1c2hlcyBmb3JtYXR0ZXIgW3BwZl0sXG4gICB0aGVuIHJldHVybnMgdGhlIGNvbnRlbnRzIG9mIGJ1ZmZlciBbYnVmXSB0aGF0IGlzIHJlc2V0LlxuICAgRm9ybWF0dGVyIFtwcGZdIGlzIHN1cHBvc2VkIHRvIHByaW50IHRvIGJ1ZmZlciBbYnVmXSwgb3RoZXJ3aXNlIHRoaXNcbiAgIGZ1bmN0aW9uIGlzIG5vdCByZWFsbHkgdXNlZnVsLiAqKVxubGV0IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgYnVmIHBwZiA9XG4gIHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZTtcbiAgbGV0IHMgPSBCdWZmZXIuY29udGVudHMgYnVmIGluXG4gIEJ1ZmZlci5yZXNldCBidWY7XG4gIHNcblxuXG4oKiBGbHVzaCBbc3RyX2Zvcm1hdHRlcl0gYW5kIGdldCB0aGUgY29udGVudHMgb2YgW3N0ZGJ1Zl0uICopXG5sZXQgZmx1c2hfc3RyX2Zvcm1hdHRlciAoKSA9IGZsdXNoX2J1ZmZlcl9mb3JtYXR0ZXIgc3RkYnVmIHN0cl9mb3JtYXR0ZXJcblxuKCpcbiAgU3ltYm9saWMgcHJldHR5LXByaW50aW5nXG4qKVxuXG4oKlxuICBTeW1ib2xpYyBwcmV0dHktcHJpbnRpbmcgaXMgcHJldHR5LXByaW50aW5nIHdpdGggbm8gbG93IGxldmVsIG91dHB1dC5cblxuICBXaGVuIHVzaW5nIGEgc3ltYm9saWMgZm9ybWF0dGVyLCBhbGwgcmVndWxhciBwcmV0dHktcHJpbnRpbmcgYWN0aXZpdGllc1xuICBvY2N1ciBidXQgb3V0cHV0IG1hdGVyaWFsIGlzIHN5bWJvbGljIGFuZCBzdG9yZWQgaW4gYSBidWZmZXIgb2Ygb3V0cHV0XG4gIGl0ZW1zLiBBdCB0aGUgZW5kIG9mIHByZXR0eS1wcmludGluZywgZmx1c2hpbmcgdGhlIG91dHB1dCBidWZmZXIgYWxsb3dzXG4gIHBvc3QtcHJvY2Vzc2luZyBvZiBzeW1ib2xpYyBvdXRwdXQgYmVmb3JlIGxvdyBsZXZlbCBvdXRwdXQgb3BlcmF0aW9ucy5cbiopXG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2l0ZW0gPVxuICB8IE91dHB1dF9mbHVzaFxuICB8IE91dHB1dF9uZXdsaW5lXG4gIHwgT3V0cHV0X3N0cmluZyBvZiBzdHJpbmdcbiAgfCBPdXRwdXRfc3BhY2VzIG9mIGludFxuICB8IE91dHB1dF9pbmRlbnQgb2YgaW50XG5cbnR5cGUgc3ltYm9saWNfb3V0cHV0X2J1ZmZlciA9IHtcbiAgbXV0YWJsZSBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgOiBzeW1ib2xpY19vdXRwdXRfaXRlbSBsaXN0O1xufVxuXG5sZXQgbWFrZV9zeW1ib2xpY19vdXRwdXRfYnVmZmVyICgpID1cbiAgeyBzeW1ib2xpY19vdXRwdXRfY29udGVudHMgPSBbXSB9XG5cbmxldCBjbGVhcl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHMgPC0gW11cblxubGV0IGdldF9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIExpc3QucmV2IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZsdXNoX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iID1cbiAgbGV0IGl0ZW1zID0gZ2V0X3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iIGluXG4gIGNsZWFyX3N5bWJvbGljX291dHB1dF9idWZmZXIgc29iO1xuICBpdGVtc1xuXG5sZXQgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBpdGVtID1cbiAgc29iLnN5bWJvbGljX291dHB1dF9jb250ZW50cyA8LSBpdGVtIDo6IHNvYi5zeW1ib2xpY19vdXRwdXRfY29udGVudHNcblxubGV0IGZvcm1hdHRlcl9vZl9zeW1ib2xpY19vdXRwdXRfYnVmZmVyIHNvYiA9XG4gIGxldCBzeW1ib2xpY19mbHVzaCBzb2IgKCkgPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgT3V0cHV0X2ZsdXNoXG4gIGFuZCBzeW1ib2xpY19uZXdsaW5lIHNvYiAoKSA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiBPdXRwdXRfbmV3bGluZVxuICBhbmQgc3ltYm9saWNfc3RyaW5nIHNvYiBzIGkgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X3N0cmluZyAoU3RyaW5nLnN1YiBzIGkgbikpXG4gIGFuZCBzeW1ib2xpY19zcGFjZXMgc29iIG4gPVxuICAgIGFkZF9zeW1ib2xpY19vdXRwdXRfaXRlbSBzb2IgKE91dHB1dF9zcGFjZXMgbilcbiAgYW5kIHN5bWJvbGljX2luZGVudCBzb2IgbiA9XG4gICAgYWRkX3N5bWJvbGljX291dHB1dF9pdGVtIHNvYiAoT3V0cHV0X2luZGVudCBuKSBpblxuXG4gIGxldCBmID0gc3ltYm9saWNfc3RyaW5nIHNvYlxuICBhbmQgZyA9IHN5bWJvbGljX2ZsdXNoIHNvYlxuICBhbmQgaCA9IHN5bWJvbGljX25ld2xpbmUgc29iXG4gIGFuZCBpID0gc3ltYm9saWNfc3BhY2VzIHNvYlxuICBhbmQgaiA9IHN5bWJvbGljX2luZGVudCBzb2IgaW5cbiAgcHBfbWFrZV9mb3JtYXR0ZXIgZiBnIGggaSBqXG5cbigqXG5cbiAgQmFzaWMgZnVuY3Rpb25zIG9uIHRoZSAnc3RhbmRhcmQnIGZvcm1hdHRlclxuICAodGhlIGZvcm1hdHRlciB0aGF0IHByaW50cyB0byBbU3RkbGliLnN0ZG91dF0pLlxuXG4qKVxuXG5sZXQgb3Blbl9oYm94ID0gcHBfb3Blbl9oYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX3Zib3ggPSBwcF9vcGVuX3Zib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5faHZib3ggPSBwcF9vcGVuX2h2Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2hvdmJveCA9IHBwX29wZW5faG92Ym94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBvcGVuX2JveCA9IHBwX29wZW5fYm94IHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9ib3ggPSBwcF9jbG9zZV9ib3ggc3RkX2Zvcm1hdHRlclxuYW5kIG9wZW5fdGFnID0gcHBfb3Blbl90YWcgc3RkX2Zvcm1hdHRlclxuYW5kIGNsb3NlX3RhZyA9IHBwX2Nsb3NlX3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgb3Blbl9zdGFnID0gcHBfb3Blbl9zdGFnIHN0ZF9mb3JtYXR0ZXJcbmFuZCBjbG9zZV9zdGFnID0gcHBfY2xvc2Vfc3RhZyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYXMgPSBwcF9wcmludF9hcyBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfc3RyaW5nID0gcHBfcHJpbnRfc3RyaW5nIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9pbnQgPSBwcF9wcmludF9pbnQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2Zsb2F0ID0gcHBfcHJpbnRfZmxvYXQgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2NoYXIgPSBwcF9wcmludF9jaGFyIHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9ib29sID0gcHBfcHJpbnRfYm9vbCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfYnJlYWsgPSBwcF9wcmludF9icmVhayBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfY3V0ID0gcHBfcHJpbnRfY3V0IHN0ZF9mb3JtYXR0ZXJcbmFuZCBwcmludF9zcGFjZSA9IHBwX3ByaW50X3NwYWNlIHN0ZF9mb3JtYXR0ZXJcbmFuZCBmb3JjZV9uZXdsaW5lID0gcHBfZm9yY2VfbmV3bGluZSBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfZmx1c2ggPSBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfbmV3bGluZSA9IHBwX3ByaW50X25ld2xpbmUgc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X2lmX25ld2xpbmUgPSBwcF9wcmludF9pZl9uZXdsaW5lIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIG9wZW5fdGJveCA9IHBwX29wZW5fdGJveCBzdGRfZm9ybWF0dGVyXG5hbmQgY2xvc2VfdGJveCA9IHBwX2Nsb3NlX3Rib3ggc3RkX2Zvcm1hdHRlclxuYW5kIHByaW50X3RicmVhayA9IHBwX3ByaW50X3RicmVhayBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfdGFiID0gcHBfc2V0X3RhYiBzdGRfZm9ybWF0dGVyXG5hbmQgcHJpbnRfdGFiID0gcHBfcHJpbnRfdGFiIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9tYXJnaW4gPSBwcF9zZXRfbWFyZ2luIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWFyZ2luID0gcHBfZ2V0X21hcmdpbiBzdGRfZm9ybWF0dGVyXG5cbmFuZCBzZXRfbWF4X2luZGVudCA9IHBwX3NldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfbWF4X2luZGVudCA9IHBwX2dldF9tYXhfaW5kZW50IHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9nZW9tZXRyeSA9IHBwX3NldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgc2FmZV9zZXRfZ2VvbWV0cnkgPSBwcF9zYWZlX3NldF9nZW9tZXRyeSBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2dlb21ldHJ5ID0gcHBfZ2V0X2dlb21ldHJ5IHN0ZF9mb3JtYXR0ZXJcbmFuZCB1cGRhdGVfZ2VvbWV0cnkgPSBwcF91cGRhdGVfZ2VvbWV0cnkgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X21heF9ib3hlcyA9IHBwX3NldF9tYXhfYm94ZXMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9tYXhfYm94ZXMgPSBwcF9nZXRfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBvdmVyX21heF9ib3hlcyA9IHBwX292ZXJfbWF4X2JveGVzIHN0ZF9mb3JtYXR0ZXJcblxuYW5kIHNldF9lbGxpcHNpc190ZXh0ID0gcHBfc2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9lbGxpcHNpc190ZXh0ID0gcHBfZ2V0X2VsbGlwc2lzX3RleHQgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfY2hhbm5lbCA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfb3V0X2NoYW5uZWwgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuXG5hbmQgc2V0X2Zvcm1hdHRlcl9zdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgc3RkX2Zvcm1hdHRlclxuYW5kIGdldF9mb3JtYXR0ZXJfc3RhZ19mdW5jdGlvbnMgPVxuICBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfcHJpbnRfdGFncyA9XG4gIHBwX3NldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBnZXRfcHJpbnRfdGFncyA9XG4gIHBwX2dldF9wcmludF90YWdzIHN0ZF9mb3JtYXR0ZXJcbmFuZCBzZXRfbWFya190YWdzID1cbiAgcHBfc2V0X21hcmtfdGFncyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X21hcmtfdGFncyA9XG4gIHBwX2dldF9tYXJrX3RhZ3Mgc3RkX2Zvcm1hdHRlclxuYW5kIHNldF90YWdzID1cbiAgcHBfc2V0X3RhZ3Mgc3RkX2Zvcm1hdHRlclxuXG5cbigqIENvbnZlbmllbmNlIGZ1bmN0aW9ucyAqKVxuXG4oKiBUbyBmb3JtYXQgYSBsaXN0ICopXG5sZXQgcmVjIHBwX3ByaW50X2xpc3QgPyhwcF9zZXAgPSBwcF9wcmludF9jdXQpIHBwX3YgcHBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPiAoKVxuICB8IFt2XSAtPiBwcF92IHBwZiB2XG4gIHwgdiA6OiB2cyAtPlxuICAgIHBwX3YgcHBmIHY7XG4gICAgcHBfc2VwIHBwZiAoKTtcbiAgICBwcF9wcmludF9saXN0IH5wcF9zZXAgcHBfdiBwcGYgdnNcblxuKCogVG8gZm9ybWF0IGZyZWUtZmxvd2luZyB0ZXh0ICopXG5sZXQgcHBfcHJpbnRfdGV4dCBwcGYgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGxlZnQgPSByZWYgMCBpblxuICBsZXQgcmlnaHQgPSByZWYgMCBpblxuICBsZXQgZmx1c2ggKCkgPVxuICAgIHBwX3ByaW50X3N0cmluZyBwcGYgKFN0cmluZy5zdWIgcyAhbGVmdCAoIXJpZ2h0IC0gIWxlZnQpKTtcbiAgICBpbmNyIHJpZ2h0OyBsZWZ0IDo9ICFyaWdodDtcbiAgaW5cbiAgd2hpbGUgKCFyaWdodCA8PiBsZW4pIGRvXG4gICAgbWF0Y2ggcy5bIXJpZ2h0XSB3aXRoXG4gICAgICB8ICdcXG4nIC0+XG4gICAgICAgIGZsdXNoICgpO1xuICAgICAgICBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICAgICAgfCAnICcgLT5cbiAgICAgICAgZmx1c2ggKCk7IHBwX3ByaW50X3NwYWNlIHBwZiAoKVxuICAgICAgKCogdGhlcmUgaXMgbm8gc3BlY2lmaWMgc3VwcG9ydCBmb3IgJ1xcdCdcbiAgICAgICAgIGFzIGl0IGlzIHVuY2xlYXIgd2hhdCBhIHJpZ2h0IHNlbWFudGljcyB3b3VsZCBiZSAqKVxuICAgICAgfCBfIC0+IGluY3IgcmlnaHRcbiAgZG9uZTtcbiAgaWYgIWxlZnQgPD4gbGVuIHRoZW4gZmx1c2ggKClcblxubGV0IHBwX3ByaW50X29wdGlvbiA/KG5vbmUgPSBmdW4gXyAoKSAtPiAoKSkgcHBfdiBwcGYgPSBmdW5jdGlvblxufCBOb25lIC0+IG5vbmUgcHBmICgpXG58IFNvbWUgdiAtPiBwcF92IHBwZiB2XG5cbmxldCBwcF9wcmludF9yZXN1bHQgfm9rIH5lcnJvciBwcGYgPSBmdW5jdGlvblxufCBPayB2IC0+IG9rIHBwZiB2XG58IEVycm9yIGUgLT4gZXJyb3IgcHBmIGVcblxuICgqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGNvbXB1dGVfdGFnIG91dHB1dCB0YWdfYWNjID1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYnVmIGluXG4gIG91dHB1dCBwcGYgdGFnX2FjYztcbiAgcHBfcHJpbnRfZmx1c2ggcHBmICgpO1xuICBsZXQgbGVuID0gQnVmZmVyLmxlbmd0aCBidWYgaW5cbiAgaWYgbGVuIDwgMiB0aGVuIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgZWxzZSBCdWZmZXIuc3ViIGJ1ZiAxIChsZW4gLSAyKVxuXG4gKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgRGVmaW5pbmcgY29udGludWF0aW9ucyB0byBiZSBwYXNzZWQgYXMgYXJndW1lbnRzIG9mXG4gIENhbWxpbnRlcm5hbEZvcm1hdC5tYWtlX3ByaW50Zi5cblxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIEludGVycHJldCBhIGZvcm1hdHRpbmcgZW50aXR5IG9uIGEgZm9ybWF0dGVyLiAqKVxubGV0IG91dHB1dF9mb3JtYXR0aW5nX2xpdCBwcGYgZm10aW5nX2xpdCA9IG1hdGNoIGZtdGluZ19saXQgd2l0aFxuICB8IENsb3NlX2JveCAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfYm94IHBwZiAoKVxuICB8IENsb3NlX3RhZyAgICAgICAgICAgICAgICAgLT4gcHBfY2xvc2VfdGFnIHBwZiAoKVxuICB8IEJyZWFrIChfLCB3aWR0aCwgb2Zmc2V0KSAgLT4gcHBfcHJpbnRfYnJlYWsgcHBmIHdpZHRoIG9mZnNldFxuICB8IEZGbHVzaCAgICAgICAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfZmx1c2ggcHBmICgpXG4gIHwgRm9yY2VfbmV3bGluZSAgICAgICAgICAgICAtPiBwcF9mb3JjZV9uZXdsaW5lIHBwZiAoKVxuICB8IEZsdXNoX25ld2xpbmUgICAgICAgICAgICAgLT4gcHBfcHJpbnRfbmV3bGluZSBwcGYgKClcbiAgfCBNYWdpY19zaXplIChfLCBfKSAgICAgICAgIC0+ICgpXG4gIHwgRXNjYXBlZF9hdCAgICAgICAgICAgICAgICAtPiBwcF9wcmludF9jaGFyIHBwZiAnQCdcbiAgfCBFc2NhcGVkX3BlcmNlbnQgICAgICAgICAgIC0+IHBwX3ByaW50X2NoYXIgcHBmICclJ1xuICB8IFNjYW5faW5kaWMgYyAgICAgICAgICAgICAgLT4gcHBfcHJpbnRfY2hhciBwcGYgJ0AnOyBwcF9wcmludF9jaGFyIHBwZiBjXG5cbigqIFJlY3Vyc2l2ZWx5IG91dHB1dCBhbiBcImFjY3VtdWxhdG9yXCIgY29udGFpbmluZyBhIHJldmVyc2VkIGxpc3Qgb2ZcbiAgIHByaW50aW5nIGVudGl0aWVzIChzdHJpbmcsIGNoYXIsIGZsdXMsIC4uLikgaW4gYW4gb3V0cHV0X3N0cmVhbS4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5vdXRwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIG91dHB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIG91dHB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBvdXRwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgb3V0cHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgb3V0cHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gb3V0cHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IG91dHB1dF9hY2MgcHBmIHA7IGYgcHBmO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBvdXRwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IG91dHB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCogUmVjdXJzaXZlbHkgb3V0cHV0IGFuIFwiYWNjdW11bGF0b3JcIiBjb250YWluaW5nIGEgcmV2ZXJzZWQgbGlzdCBvZlxuICAgcHJpbnRpbmcgZW50aXRpZXMgKHN0cmluZywgY2hhciwgZmx1cywgLi4uKSBpbiBhIGJ1ZmZlci4gKilcbigqIERpZmZlciBmcm9tIFByaW50Zi5idWZwdXRfYWNjIGJ5IHRoZSBpbnRlcnByZXRhdGlvbiBvZiBmb3JtYXR0aW5nLiAqKVxuKCogVXNlZCBhcyBhIGNvbnRpbnVhdGlvbiBvZiBDYW1saW50ZXJuYWxGb3JtYXQubWFrZV9wcmludGYuICopXG5sZXQgcmVjIHN0cnB1dF9hY2MgcHBmIGFjYyA9IG1hdGNoIGFjYyB3aXRoXG4gIHwgQWNjX3N0cmluZ19saXRlcmFsIChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKEFjY19mb3JtYXR0aW5nX2xpdCAocCwgTWFnaWNfc2l6ZSAoXywgc2l6ZSkpLCBzKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgcHBfcHJpbnRfYXNfc2l6ZSBwcGYgKFNpemUub2ZfaW50IHNpemUpIHM7XG4gIHwgQWNjX2NoYXJfbGl0ZXJhbCAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAoQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBNYWdpY19zaXplIChfLCBzaXplKSksIGMpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9wcmludF9hc19zaXplIHBwZiAoU2l6ZS5vZl9pbnQgc2l6ZSkgKFN0cmluZy5tYWtlIDEgYyk7XG4gIHwgQWNjX2RlbGF5IChBY2NfZm9ybWF0dGluZ19saXQgKHAsIE1hZ2ljX3NpemUgKF8sIHNpemUpKSwgZikgLT5cbiAgICBzdHJwdXRfYWNjIHBwZiBwO1xuICAgIHBwX3ByaW50X2FzX3NpemUgcHBmIChTaXplLm9mX2ludCBzaXplKSAoZiAoKSk7XG4gIHwgQWNjX2Zvcm1hdHRpbmdfbGl0IChwLCBmKSAtPlxuICAgIHN0cnB1dF9hY2MgcHBmIHA7XG4gICAgb3V0cHV0X2Zvcm1hdHRpbmdfbGl0IHBwZiBmO1xuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fdGFnIGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBwcF9vcGVuX3N0YWcgcHBmIChTdHJpbmdfdGFnIChjb21wdXRlX3RhZyBzdHJwdXRfYWNjIGFjYycpKVxuICB8IEFjY19mb3JtYXR0aW5nX2dlbiAocCwgQWNjX29wZW5fYm94IGFjYycpIC0+XG4gICAgc3RycHV0X2FjYyBwcGYgcDtcbiAgICBsZXQgKGluZGVudCwgYnR5KSA9IG9wZW5fYm94X29mX3N0cmluZyAoY29tcHV0ZV90YWcgc3RycHV0X2FjYyBhY2MnKSBpblxuICAgIHBwX29wZW5fYm94X2dlbiBwcGYgaW5kZW50IGJ0eVxuICB8IEFjY19zdHJpbmdfbGl0ZXJhbCAocCwgcylcbiAgfCBBY2NfZGF0YV9zdHJpbmcgKHAsIHMpICAgLT4gc3RycHV0X2FjYyBwcGYgcDsgcHBfcHJpbnRfc3RyaW5nIHBwZiBzO1xuICB8IEFjY19jaGFyX2xpdGVyYWwgKHAsIGMpXG4gIHwgQWNjX2RhdGFfY2hhciAocCwgYykgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X2NoYXIgcHBmIGM7XG4gIHwgQWNjX2RlbGF5IChwLCBmKSAgICAgICAgIC0+IHN0cnB1dF9hY2MgcHBmIHA7IHBwX3ByaW50X3N0cmluZyBwcGYgKGYgKCkpO1xuICB8IEFjY19mbHVzaCBwICAgICAgICAgICAgICAtPiBzdHJwdXRfYWNjIHBwZiBwOyBwcF9wcmludF9mbHVzaCBwcGYgKCk7XG4gIHwgQWNjX2ludmFsaWRfYXJnIChwLCBtc2cpIC0+IHN0cnB1dF9hY2MgcHBmIHA7IGludmFsaWRfYXJnIG1zZztcbiAgfCBFbmRfb2ZfYWNjICAgICAgICAgICAgICAgLT4gKClcblxuKCpcblxuICBEZWZpbmluZyBbZnByaW50Zl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbZnByaW50Zl0uXG5cbiopXG5cbmxldCBrZnByaW50ZiBrIHBwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gb3V0cHV0X2FjYyBwcGYgYWNjOyBrIHBwZilcbiAgICBFbmRfb2ZfYWNjIGZtdFxuXG5hbmQgaWtmcHJpbnRmIGsgcHBmIChGb3JtYXQgKGZtdCwgXykpID1cbiAgbWFrZV9pcHJpbnRmIGsgcHBmIGZtdFxuXG5sZXQgaWZwcmludGYgX3BwZiAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfaXByaW50ZiBpZ25vcmUgKCkgZm10XG5cbmxldCBmcHJpbnRmIHBwZiA9IGtmcHJpbnRmIGlnbm9yZSBwcGZcbmxldCBwcmludGYgZm10ID0gZnByaW50ZiBzdGRfZm9ybWF0dGVyIGZtdFxubGV0IGVwcmludGYgZm10ID0gZnByaW50ZiBlcnJfZm9ybWF0dGVyIGZtdFxuXG5sZXQga2RwcmludGYgayAoRm9ybWF0IChmbXQsIF8pKSA9XG4gIG1ha2VfcHJpbnRmXG4gICAgKGZ1biBhY2MgLT4gayAoZnVuIHBwZiAtPiBvdXRwdXRfYWNjIHBwZiBhY2MpKVxuICAgIEVuZF9vZl9hY2MgZm10XG5cbmxldCBkcHJpbnRmIGZtdCA9IGtkcHJpbnRmIChmdW4gaSAtPiBpKSBmbXRcblxubGV0IGtzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBzdHJwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBzcHJpbnRmIGZtdCA9IGtzcHJpbnRmIGlkIGZtdFxuXG5sZXQga2FzcHJpbnRmIGsgKEZvcm1hdCAoZm10LCBfKSkgPVxuICBsZXQgYiA9IHBwX21ha2VfYnVmZmVyICgpIGluXG4gIGxldCBwcGYgPSBmb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgbGV0IGsgYWNjID1cbiAgICBvdXRwdXRfYWNjIHBwZiBhY2M7XG4gICAgayAoZmx1c2hfYnVmZmVyX2Zvcm1hdHRlciBiIHBwZikgaW5cbiAgbWFrZV9wcmludGYgayBFbmRfb2ZfYWNjIGZtdFxuXG5cbmxldCBhc3ByaW50ZiBmbXQgPSBrYXNwcmludGYgaWQgZm10XG5cbigqIEZsdXNoaW5nIHN0YW5kYXJkIGZvcm1hdHRlcnMgYXQgZW5kIG9mIGV4ZWN1dGlvbi4gKilcblxubGV0IGZsdXNoX3N0YW5kYXJkX2Zvcm1hdHRlcnMgKCkgPVxuICBwcF9wcmludF9mbHVzaCBzdGRfZm9ybWF0dGVyICgpO1xuICBwcF9wcmludF9mbHVzaCBlcnJfZm9ybWF0dGVyICgpXG5cbmxldCAoKSA9IGF0X2V4aXQgZmx1c2hfc3RhbmRhcmRfZm9ybWF0dGVyc1xuXG4oKlxuXG4gIERlcHJlY2F0ZWQgc3R1ZmYuXG5cbiopXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9zZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9zZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlXG4gICAgfm91dDpmIH5mbHVzaDpnIH5uZXdsaW5lOmggfnNwYWNlczppID1cbiAgcHBfc2V0X2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlIGYgZztcbiAgc3RhdGUucHBfb3V0X25ld2xpbmUgPC0gaDtcbiAgc3RhdGUucHBfb3V0X3NwYWNlcyA8LSBpXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBwcF9nZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0YXRlICgpID1cbiAgKHN0YXRlLnBwX291dF9zdHJpbmcsIHN0YXRlLnBwX291dF9mbHVzaCxcbiAgIHN0YXRlLnBwX291dF9uZXdsaW5lLCBzdGF0ZS5wcF9vdXRfc3BhY2VzKVxuXG5cbigqIERlcHJlY2F0ZWQgOiBzdWJzdW1lZCBieSBzZXRfZm9ybWF0dGVyX291dF9mdW5jdGlvbnMgKilcbmxldCBzZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zID1cbiAgcHBfc2V0X2FsbF9mb3JtYXR0ZXJfb3V0cHV0X2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5cblxuKCogRGVwcmVjYXRlZCA6IHN1YnN1bWVkIGJ5IGdldF9mb3JtYXR0ZXJfb3V0X2Z1bmN0aW9ucyAqKVxubGV0IGdldF9hbGxfZm9ybWF0dGVyX291dHB1dF9mdW5jdGlvbnMgPVxuICBwcF9nZXRfYWxsX2Zvcm1hdHRlcl9vdXRwdXRfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcblxuXG4oKiBEZXByZWNhdGVkIDogZXJyb3IgcHJvbmUgZnVuY3Rpb24sIGRvIG5vdCB1c2UgaXQuXG4gICBUaGlzIGZ1bmN0aW9uIGlzIG5laXRoZXIgY29tcG9zaXRpb25hbCBub3IgaW5jcmVtZW50YWwsIHNpbmNlIGl0IGZsdXNoZXNcbiAgIHRoZSBwcmV0dHktcHJpbnRlciBxdWV1ZSBhdCBlYWNoIGNhbGwuXG4gICBUbyBnZXQgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSwgZGVmaW5lIGEgZm9ybWF0dGVyIG9mIHlvdXIgb3duIHdyaXRpbmcgdG9cbiAgIHRoZSBidWZmZXIgYXJndW1lbnQsIGFzIGluXG4gICBsZXQgcHBmID0gZm9ybWF0dGVyX29mX2J1ZmZlciBiXG4gICB0aGVuIHVzZSB7IWZwcmludGYgcHBmfSBhcyB1c3VhbC4gKilcbmxldCBicHJpbnRmIGIgKEZvcm1hdCAoZm10LCBfKSA6ICgnYSwgZm9ybWF0dGVyLCB1bml0KSBmb3JtYXQpID1cbiAgbGV0IHBwZiA9IGZvcm1hdHRlcl9vZl9idWZmZXIgYiBpblxuICBsZXQgayBhY2MgPSBvdXRwdXRfYWNjIHBwZiBhY2M7IHBwX2ZsdXNoX3F1ZXVlIHBwZiBmYWxzZSBpblxuICBtYWtlX3ByaW50ZiBrIEVuZF9vZl9hY2MgZm10XG5cblxuKCogRGVwcmVjYXRlZCA6IGFsaWFzIGZvciBrc3ByaW50Zi4gKilcbmxldCBrcHJpbnRmID0ga3NwcmludGZcblxuXG5cbigqIERlcHJlY2F0ZWQgdGFnIGZ1bmN0aW9ucyAqKVxuXG50eXBlIGZvcm1hdHRlcl90YWdfZnVuY3Rpb25zID0ge1xuICBtYXJrX29wZW5fdGFnIDogdGFnIC0+IHN0cmluZztcbiAgbWFya19jbG9zZV90YWcgOiB0YWcgLT4gc3RyaW5nO1xuICBwcmludF9vcGVuX3RhZyA6IHRhZyAtPiB1bml0O1xuICBwcmludF9jbG9zZV90YWcgOiB0YWcgLT4gdW5pdDtcbn1cblxuXG5sZXQgcHBfc2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0YXRlIHtcbiAgICAgbWFya19vcGVuX3RhZyA9IG1vdDtcbiAgICAgbWFya19jbG9zZV90YWcgPSBtY3Q7XG4gICAgIHByaW50X29wZW5fdGFnID0gcG90O1xuICAgICBwcmludF9jbG9zZV90YWcgPSBwY3Q7XG4gICB9ID1cbiAgbGV0IHN0cmluZ2lmeSBmIGUgPSBmdW5jdGlvbiBTdHJpbmdfdGFnIHMgLT4gZiBzIHwgXyAtPiBlIGluXG4gIHN0YXRlLnBwX21hcmtfb3Blbl90YWcgPC0gc3RyaW5naWZ5IG1vdCBcIlwiO1xuICBzdGF0ZS5wcF9tYXJrX2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgbWN0IFwiXCI7XG4gIHN0YXRlLnBwX3ByaW50X29wZW5fdGFnIDwtIHN0cmluZ2lmeSBwb3QgKCk7XG4gIHN0YXRlLnBwX3ByaW50X2Nsb3NlX3RhZyA8LSBzdHJpbmdpZnkgcGN0ICgpXG5cbmxldCBwcF9nZXRfZm9ybWF0dGVyX3RhZ19mdW5jdGlvbnMgZm10ICgpID1cbiAgbGV0IGZ1bnMgPSBwcF9nZXRfZm9ybWF0dGVyX3N0YWdfZnVuY3Rpb25zIGZtdCAoKSBpblxuICBsZXQgbWFya19vcGVuX3RhZyBzID0gZnVucy5tYXJrX29wZW5fc3RhZyAoU3RyaW5nX3RhZyBzKSBpblxuICBsZXQgbWFya19jbG9zZV90YWcgcyA9IGZ1bnMubWFya19jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIGxldCBwcmludF9vcGVuX3RhZyBzID0gZnVucy5wcmludF9vcGVuX3N0YWcgKFN0cmluZ190YWcgcykgaW5cbiAgbGV0IHByaW50X2Nsb3NlX3RhZyBzID0gZnVucy5wcmludF9jbG9zZV9zdGFnIChTdHJpbmdfdGFnIHMpIGluXG4gIHttYXJrX29wZW5fdGFnOyBtYXJrX2Nsb3NlX3RhZzsgcHJpbnRfb3Blbl90YWc7IHByaW50X2Nsb3NlX3RhZ31cblxubGV0IHNldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyA9XG4gIHBwX3NldF9mb3JtYXR0ZXJfdGFnX2Z1bmN0aW9ucyBzdGRfZm9ybWF0dGVyXG5hbmQgZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zID1cbiAgcHBfZ2V0X2Zvcm1hdHRlcl90YWdfZnVuY3Rpb25zIHN0ZF9mb3JtYXR0ZXJcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFBpZXJyZSBXZWlzLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDIwMDIgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxub3BlbiBDYW1saW50ZXJuYWxGb3JtYXRCYXNpY3Ncbm9wZW4gQ2FtbGludGVybmFsRm9ybWF0XG5cbigqIGFsaWFzIHRvIGF2b2lkIHdhcm5pbmcgZm9yIGFtYmlndWl0eSBiZXR3ZWVuXG4gICBTdGRsaWIuZm9ybWF0NlxuICAgYW5kIENhbWxpbnRlcm5hbEZvcm1hdEJhc2ljcy5mb3JtYXQ2XG5cbiAgICh0aGUgZm9ybWVyIGlzIGluIGZhY3QgYW4gYWxpYXMgZm9yIHRoZSBsYXR0ZXIsXG4gICAgYnV0IHRoZSBhbWJpZ3VpdHkgd2FybmluZyBkb2Vzbid0IGNhcmUpXG4qKVxudHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA9XG4gICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBTdGRsaWIuZm9ybWF0NlxuXG5cbigqIFRoZSBydW4tdGltZSBsaWJyYXJ5IGZvciBzY2FubmVycy4gKilcblxuKCogU2Nhbm5pbmcgYnVmZmVycy4gKilcbm1vZHVsZSB0eXBlIFNDQU5OSU5HID0gc2lnXG5cbiAgdHlwZSBpbl9jaGFubmVsXG5cbiAgdHlwZSBzY2FuYnVmID0gaW5fY2hhbm5lbFxuXG4gIHR5cGUgZmlsZV9uYW1lID0gc3RyaW5nXG5cbiAgdmFsIHN0ZGluIDogaW5fY2hhbm5lbFxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgW3N0ZGliXSBpcyBlcXVpdmFsZW50IHRvIFtTY2FubmluZy5mcm9tX2NoYW5uZWwgU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgc3RkaWIgOiBpbl9jaGFubmVsXG4gICgqIEFuIGFsaWFzIGZvciBbU2NhbmYuc3RkaW5dLCB0aGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbVxuICAgICBbU3RkbGliLnN0ZGluXS4gKilcblxuICB2YWwgbmV4dF9jaGFyIDogc2NhbmJ1ZiAtPiBjaGFyXG4gICgqIFtTY2FubmluZy5uZXh0X2NoYXIgaWJdIGFkdmFuY2UgdGhlIHNjYW5uaW5nIGJ1ZmZlciBmb3JcbiAgICAgb25lIGNoYXJhY3Rlci5cbiAgICAgSWYgbm8gbW9yZSBjaGFyYWN0ZXIgY2FuIGJlIHJlYWQsIHNldHMgYSBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXSBtYXJrIHRoZSBjdXJyZW50X2NoYXIgYXMgYWxyZWFkeVxuICAgICBzY2FubmVkLiAqKVxuXG4gIHZhbCBwZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogW1NjYW5uaW5nLnBlZWtfY2hhciBpYl0gcmV0dXJucyB0aGUgY3VycmVudCBjaGFyIGF2YWlsYWJsZSBpblxuICAgICB0aGUgYnVmZmVyIG9yIHJlYWRzIG9uZSBpZiBuZWNlc3NhcnkgKHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzXG4gICAgIGFscmVhZHkgc2Nhbm5lZCkuXG4gICAgIElmIG5vIGNoYXJhY3RlciBjYW4gYmUgcmVhZCwgc2V0cyBhbiBlbmQgb2YgZmlsZSBjb25kaXRpb24gYW5kXG4gICAgIHJldHVybnMgJ1xcMDAwJy4gKilcblxuICB2YWwgY2hlY2tlZF9wZWVrX2NoYXIgOiBzY2FuYnVmIC0+IGNoYXJcbiAgKCogU2FtZSBhcyBbU2Nhbm5pbmcucGVla19jaGFyXSBhYm92ZSBidXQgYWx3YXlzIHJldHVybnMgYSB2YWxpZCBjaGFyIG9yXG4gICAgIGZhaWxzOiBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG51bGwgY2hhciB3aGVuIHRoZSByZWFkaW5nIG1ldGhvZCBvZiB0aGVcbiAgICAgaW5wdXQgYnVmZmVyIGhhcyByZWFjaGVkIGFuIGVuZCBvZiBmaWxlLCB0aGUgZnVuY3Rpb24gcmFpc2VzIGV4Y2VwdGlvblxuICAgICBbRW5kX29mX2ZpbGVdLiAqKVxuXG4gIHZhbCBzdG9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gY2hhciAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnN0b3JlX2NoYXIgbGltIGliIGNdIGFkZHMgW2NdIHRvIHRoZSB0b2tlbiBidWZmZXJcbiAgICAgb2YgdGhlIHNjYW5uaW5nIGJ1ZmZlciBbaWJdLiBJdCBhbHNvIGFkdmFuY2VzIHRoZSBzY2FubmluZyBidWZmZXIgZm9yXG4gICAgIG9uZSBjaGFyYWN0ZXIgYW5kIHJldHVybnMgW2xpbSAtIDFdLCBpbmRpY2F0aW5nIHRoZSBuZXcgbGltaXQgZm9yIHRoZVxuICAgICBsZW5ndGggb2YgdGhlIGN1cnJlbnQgdG9rZW4uICopXG5cbiAgdmFsIHNraXBfY2hhciA6IGludCAtPiBzY2FuYnVmIC0+IGludFxuICAoKiBbU2Nhbm5pbmcuc2tpcF9jaGFyIGxpbSBpYl0gaWdub3JlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuICopXG5cbiAgdmFsIGlnbm9yZV9jaGFyIDogaW50IC0+IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5pZ25vcmVfY2hhciBpYiBsaW1dIGlnbm9yZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGFuZFxuICAgICBkZWNyZW1lbnRzIHRoZSBsaW1pdC4gKilcblxuICB2YWwgdG9rZW4gOiBzY2FuYnVmIC0+IHN0cmluZ1xuICAoKiBbU2Nhbm5pbmcudG9rZW4gaWJdIHJldHVybnMgdGhlIHN0cmluZyBzdG9yZWQgaW50byB0aGUgdG9rZW5cbiAgICAgYnVmZmVyIG9mIHRoZSBzY2FubmluZyBidWZmZXI6IGl0IHJldHVybnMgdGhlIHRva2VuIG1hdGNoZWQgYnkgdGhlXG4gICAgIGZvcm1hdC4gKilcblxuICB2YWwgcmVzZXRfdG9rZW4gOiBzY2FuYnVmIC0+IHVuaXRcbiAgKCogW1NjYW5uaW5nLnJlc2V0X3Rva2VuIGliXSByZXNldHMgdGhlIHRva2VuIGJ1ZmZlciBvZlxuICAgICB0aGUgZ2l2ZW4gc2Nhbm5pbmcgYnVmZmVyLiAqKVxuXG4gIHZhbCBjaGFyX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLmNoYXJfY291bnQgaWJdIHJldHVybnMgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgIHJlYWQgc28gZmFyIGZyb20gdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgbGluZV9jb3VudCA6IHNjYW5idWYgLT4gaW50XG4gICgqIFtTY2FubmluZy5saW5lX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgbmV3IGxpbmVcbiAgICAgY2hhcmFjdGVycyByZWFkIHNvIGZhciBmcm9tIHRoZSBnaXZlbiBidWZmZXIuICopXG5cbiAgdmFsIHRva2VuX2NvdW50IDogc2NhbmJ1ZiAtPiBpbnRcbiAgKCogW1NjYW5uaW5nLnRva2VuX2NvdW50IGliXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgdG9rZW5zIHJlYWRcbiAgICAgc28gZmFyIGZyb20gW2liXS4gKilcblxuICB2YWwgZW9mIDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lb2YgaWJdIHJldHVybnMgdGhlIGVuZCBvZiBpbnB1dCBjb25kaXRpb25cbiAgICAgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gKilcblxuICB2YWwgZW5kX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBib29sXG4gICgqIFtTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWJdIHRlc3RzIHRoZSBlbmQgb2YgaW5wdXQgY29uZGl0aW9uXG4gICAgIG9mIHRoZSBnaXZlbiBidWZmZXIgKGlmIG5vIGNoYXIgaGFzIGV2ZXIgYmVlbiByZWFkLCBhbiBhdHRlbXB0IHRvXG4gICAgIHJlYWQgb25lIGlzIHBlcmZvcm1lZCkuICopXG5cbiAgdmFsIGJlZ2lubmluZ19vZl9pbnB1dCA6IHNjYW5idWYgLT4gYm9vbFxuICAoKiBbU2Nhbm5pbmcuYmVnaW5uaW5nX29mX2lucHV0IGliXSB0ZXN0cyB0aGUgYmVnaW5uaW5nIG9mIGlucHV0XG4gICAgIGNvbmRpdGlvbiBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiAqKVxuXG4gIHZhbCBuYW1lX29mX2lucHV0IDogc2NhbmJ1ZiAtPiBzdHJpbmdcbiAgKCogW1NjYW5uaW5nLm5hbWVfb2ZfaW5wdXQgaWJdIHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGNoYXJhY3RlclxuICAgICBzb3VyY2UgZm9yIGlucHV0IGJ1ZmZlciBbaWJdLiAqKVxuXG4gIHZhbCBvcGVuX2luIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIG9wZW5faW5fYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZmlsZSA6IGZpbGVfbmFtZSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2ZpbGVfYmluIDogZmlsZV9uYW1lIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fc3RyaW5nIDogc3RyaW5nIC0+IGluX2NoYW5uZWxcbiAgdmFsIGZyb21fZnVuY3Rpb24gOiAodW5pdCAtPiBjaGFyKSAtPiBpbl9jaGFubmVsXG4gIHZhbCBmcm9tX2NoYW5uZWwgOiBTdGRsaWIuaW5fY2hhbm5lbCAtPiBpbl9jaGFubmVsXG5cbiAgdmFsIGNsb3NlX2luIDogaW5fY2hhbm5lbCAtPiB1bml0XG5cbiAgdmFsIG1lbW9fZnJvbV9jaGFubmVsIDogU3RkbGliLmluX2NoYW5uZWwgLT4gaW5fY2hhbm5lbFxuICAoKiBPYnNvbGV0ZS4gKilcblxuZW5kXG5cblxubW9kdWxlIFNjYW5uaW5nIDogU0NBTk5JTkcgPSBzdHJ1Y3RcblxuICAoKiBUaGUgcnVuLXRpbWUgbGlicmFyeSBmb3Igc2NhbmYuICopXG5cbiAgdHlwZSBmaWxlX25hbWUgPSBzdHJpbmdcblxuICB0eXBlIGluX2NoYW5uZWxfbmFtZSA9XG4gICAgfCBGcm9tX2NoYW5uZWwgb2YgU3RkbGliLmluX2NoYW5uZWxcbiAgICB8IEZyb21fZmlsZSBvZiBmaWxlX25hbWUgKiBTdGRsaWIuaW5fY2hhbm5lbFxuICAgIHwgRnJvbV9mdW5jdGlvblxuICAgIHwgRnJvbV9zdHJpbmdcblxuXG4gIHR5cGUgaW5fY2hhbm5lbCA9IHtcbiAgICBtdXRhYmxlIGljX2VvZiA6IGJvb2w7XG4gICAgbXV0YWJsZSBpY19jdXJyZW50X2NoYXIgOiBjaGFyO1xuICAgIG11dGFibGUgaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkIDogYm9vbDtcbiAgICBtdXRhYmxlIGljX2NoYXJfY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19saW5lX2NvdW50IDogaW50O1xuICAgIG11dGFibGUgaWNfdG9rZW5fY291bnQgOiBpbnQ7XG4gICAgbXV0YWJsZSBpY19nZXRfbmV4dF9jaGFyIDogdW5pdCAtPiBjaGFyO1xuICAgIGljX3Rva2VuX2J1ZmZlciA6IEJ1ZmZlci50O1xuICAgIGljX2lucHV0X25hbWUgOiBpbl9jaGFubmVsX25hbWU7XG4gIH1cblxuXG4gIHR5cGUgc2NhbmJ1ZiA9IGluX2NoYW5uZWxcblxuICBsZXQgbnVsbF9jaGFyID0gJ1xcMDAwJ1xuXG4gICgqIFJlYWRzIGEgbmV3IGNoYXJhY3RlciBmcm9tIGlucHV0IGJ1ZmZlci5cbiAgICAgTmV4dF9jaGFyIG5ldmVyIGZhaWxzLCBldmVuIGluIGNhc2Ugb2YgZW5kIG9mIGlucHV0OlxuICAgICBpdCB0aGVuIHNpbXBseSBzZXRzIHRoZSBlbmQgb2YgZmlsZSBjb25kaXRpb24uICopXG4gIGxldCBuZXh0X2NoYXIgaWIgPVxuICAgIHRyeVxuICAgICAgbGV0IGMgPSBpYi5pY19nZXRfbmV4dF9jaGFyICgpIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSB0cnVlO1xuICAgICAgaWIuaWNfY2hhcl9jb3VudCA8LSBzdWNjIGliLmljX2NoYXJfY291bnQ7XG4gICAgICBpZiBjID0gJ1xcbicgdGhlbiBpYi5pY19saW5lX2NvdW50IDwtIHN1Y2MgaWIuaWNfbGluZV9jb3VudDtcbiAgICAgIGMgd2l0aFxuICAgIHwgRW5kX29mX2ZpbGUgLT5cbiAgICAgIGxldCBjID0gbnVsbF9jaGFyIGluXG4gICAgICBpYi5pY19jdXJyZW50X2NoYXIgPC0gYztcbiAgICAgIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZCA8LSBmYWxzZTtcbiAgICAgIGliLmljX2VvZiA8LSB0cnVlO1xuICAgICAgY1xuXG5cbiAgbGV0IHBlZWtfY2hhciBpYiA9XG4gICAgaWYgaWIuaWNfY3VycmVudF9jaGFyX2lzX3ZhbGlkXG4gICAgdGhlbiBpYi5pY19jdXJyZW50X2NoYXJcbiAgICBlbHNlIG5leHRfY2hhciBpYlxuXG5cbiAgKCogUmV0dXJucyBhIHZhbGlkIGN1cnJlbnQgY2hhciBmb3IgdGhlIGlucHV0IGJ1ZmZlci4gSW4gcGFydGljdWxhclxuICAgICBubyBpcnJlbGV2YW50IG51bGwgY2hhcmFjdGVyIChhcyBzZXQgYnkgW25leHRfY2hhcl0gaW4gY2FzZSBvZiBlbmRcbiAgICAgb2YgaW5wdXQpIGlzIHJldHVybmVkLCBzaW5jZSBbRW5kX29mX2ZpbGVdIGlzIHJhaXNlZCB3aGVuXG4gICAgIFtuZXh0X2NoYXJdIHNldHMgdGhlIGVuZCBvZiBmaWxlIGNvbmRpdGlvbiB3aGlsZSB0cnlpbmcgdG8gcmVhZCBhXG4gICAgIG5ldyBjaGFyYWN0ZXIuICopXG4gIGxldCBjaGVja2VkX3BlZWtfY2hhciBpYiA9XG4gICAgbGV0IGMgPSBwZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBpYi5pY19lb2YgdGhlbiByYWlzZSBFbmRfb2ZfZmlsZTtcbiAgICBjXG5cblxuICBsZXQgZW5kX29mX2lucHV0IGliID1cbiAgICBpZ25vcmUgKHBlZWtfY2hhciBpYik7XG4gICAgaWIuaWNfZW9mXG5cblxuICBsZXQgZW9mIGliID0gaWIuaWNfZW9mXG5cbiAgbGV0IGJlZ2lubmluZ19vZl9pbnB1dCBpYiA9IGliLmljX2NoYXJfY291bnQgPSAwXG5cbiAgbGV0IG5hbWVfb2ZfaW5wdXQgaWIgPVxuICAgIG1hdGNoIGliLmljX2lucHV0X25hbWUgd2l0aFxuICAgIHwgRnJvbV9jaGFubmVsIF9pYyAtPiBcInVubmFtZWQgU3RkbGliIGlucHV0IGNoYW5uZWxcIlxuICAgIHwgRnJvbV9maWxlIChmbmFtZSwgX2ljKSAtPiBmbmFtZVxuICAgIHwgRnJvbV9mdW5jdGlvbiAtPiBcInVubmFtZWQgZnVuY3Rpb25cIlxuICAgIHwgRnJvbV9zdHJpbmcgLT4gXCJ1bm5hbWVkIGNoYXJhY3RlciBzdHJpbmdcIlxuXG5cbiAgbGV0IGNoYXJfY291bnQgaWIgPVxuICAgIGlmIGliLmljX2N1cnJlbnRfY2hhcl9pc192YWxpZFxuICAgIHRoZW4gaWIuaWNfY2hhcl9jb3VudCAtIDFcbiAgICBlbHNlIGliLmljX2NoYXJfY291bnRcblxuXG4gIGxldCBsaW5lX2NvdW50IGliID0gaWIuaWNfbGluZV9jb3VudFxuXG4gIGxldCByZXNldF90b2tlbiBpYiA9IEJ1ZmZlci5yZXNldCBpYi5pY190b2tlbl9idWZmZXJcblxuICBsZXQgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgPSBpYi5pY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPC0gZmFsc2VcblxuICBsZXQgdG9rZW4gaWIgPVxuICAgIGxldCB0b2tlbl9idWZmZXIgPSBpYi5pY190b2tlbl9idWZmZXIgaW5cbiAgICBsZXQgdG9rID0gQnVmZmVyLmNvbnRlbnRzIHRva2VuX2J1ZmZlciBpblxuICAgIEJ1ZmZlci5jbGVhciB0b2tlbl9idWZmZXI7XG4gICAgaWIuaWNfdG9rZW5fY291bnQgPC0gc3VjYyBpYi5pY190b2tlbl9jb3VudDtcbiAgICB0b2tcblxuXG4gIGxldCB0b2tlbl9jb3VudCBpYiA9IGliLmljX3Rva2VuX2NvdW50XG5cbiAgbGV0IHNraXBfY2hhciB3aWR0aCBpYiA9XG4gICAgaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7XG4gICAgd2lkdGhcblxuXG4gIGxldCBpZ25vcmVfY2hhciB3aWR0aCBpYiA9IHNraXBfY2hhciAod2lkdGggLSAxKSBpYlxuXG4gIGxldCBzdG9yZV9jaGFyIHdpZHRoIGliIGMgPVxuICAgIEJ1ZmZlci5hZGRfY2hhciBpYi5pY190b2tlbl9idWZmZXIgYztcbiAgICBpZ25vcmVfY2hhciB3aWR0aCBpYlxuXG5cbiAgbGV0IGRlZmF1bHRfdG9rZW5fYnVmZmVyX3NpemUgPSAxMDI0XG5cbiAgbGV0IGNyZWF0ZSBpbmFtZSBuZXh0ID0ge1xuICAgIGljX2VvZiA9IGZhbHNlO1xuICAgIGljX2N1cnJlbnRfY2hhciA9IG51bGxfY2hhcjtcbiAgICBpY19jdXJyZW50X2NoYXJfaXNfdmFsaWQgPSBmYWxzZTtcbiAgICBpY19jaGFyX2NvdW50ID0gMDtcbiAgICBpY19saW5lX2NvdW50ID0gMDtcbiAgICBpY190b2tlbl9jb3VudCA9IDA7XG4gICAgaWNfZ2V0X25leHRfY2hhciA9IG5leHQ7XG4gICAgaWNfdG9rZW5fYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBkZWZhdWx0X3Rva2VuX2J1ZmZlcl9zaXplO1xuICAgIGljX2lucHV0X25hbWUgPSBpbmFtZTtcbiAgfVxuXG5cbiAgbGV0IGZyb21fc3RyaW5nIHMgPVxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgbGV0IG5leHQgKCkgPVxuICAgICAgaWYgIWkgPj0gbGVuIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZVxuICAgICAgbGV0IGMgPSBzLlshaV0gaW5cbiAgICAgIGluY3IgaTtcbiAgICAgIGMgaW5cbiAgICBjcmVhdGUgRnJvbV9zdHJpbmcgbmV4dFxuXG5cbiAgbGV0IGZyb21fZnVuY3Rpb24gPSBjcmVhdGUgRnJvbV9mdW5jdGlvblxuXG4gICgqIFNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbC4gKilcblxuICAoKiBQb3NpdGlvbiBvZiB0aGUgcHJvYmxlbTpcblxuICAgICBXZSBjYW5ub3QgcHJldmVudCB0aGUgc2Nhbm5pbmcgbWVjaGFuaXNtIHRvIHVzZSBvbmUgbG9va2FoZWFkIGNoYXJhY3RlcixcbiAgICAgaWYgbmVlZGVkIGJ5IHRoZSBzZW1hbnRpY3Mgb2YgdGhlIGZvcm1hdCBzdHJpbmcgc3BlY2lmaWNhdGlvbnMgKGUuZy4gYVxuICAgICB0cmFpbGluZyAnc2tpcCBzcGFjZScgc3BlY2lmaWNhdGlvbiBpbiB0aGUgZm9ybWF0IHN0cmluZyk7IGluIHRoaXMgY2FzZSxcbiAgICAgdGhlIG1hbmRhdG9yeSBsb29rYWhlYWQgY2hhcmFjdGVyIGlzIGluZGVlZCByZWFkIGZyb20gdGhlIGlucHV0IGFuZCBub3RcbiAgICAgdXNlZCB0byByZXR1cm4gdGhlIHRva2VuIHJlYWQuIEl0IGlzIHRodXMgbWFuZGF0b3J5IHRvIGJlIGFibGUgdG8gc3RvcmVcbiAgICAgYW4gdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgc29tZXdoZXJlIHRvIGdldCBpdCBhcyB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgIG9mIHRoZSBuZXh0IHNjYW4uXG5cbiAgICAgVG8gY2lyY3VtdmVudCB0aGlzIHByb2JsZW0sIGFsbCB0aGUgc2Nhbm5pbmcgZnVuY3Rpb25zIGdldCBhIGxvdyBsZXZlbFxuICAgICBpbnB1dCBidWZmZXIgYXJndW1lbnQgd2hlcmUgdGhleSBzdG9yZSB0aGUgbG9va2FoZWFkIGNoYXJhY3RlciB3aGVuXG4gICAgIG5lZWRlZDsgYWRkaXRpb25hbGx5LCB0aGUgaW5wdXQgYnVmZmVyIGlzIHRoZSBvbmx5IHNvdXJjZSBvZiBjaGFyYWN0ZXIgb2ZcbiAgICAgYSBzY2FubmVyLiBUaGUgW3NjYW5idWZdIGlucHV0IGJ1ZmZlcnMgYXJlIGRlZmluZWQgaW4gbW9kdWxlIHshU2Nhbm5pbmd9LlxuXG4gICAgIE5vdyB3ZSB1bmRlcnN0YW5kIHRoYXQgaXQgaXMgZXh0cmVtZWx5IGltcG9ydGFudCB0aGF0IHJlbGF0ZWQgYW5kXG4gICAgIHN1Y2Nlc3NpdmUgY2FsbHMgdG8gc2Nhbm5lcnMgaW5kZWVkIHJlYWQgZnJvbSB0aGUgc2FtZSBpbnB1dCBidWZmZXIuXG4gICAgIEluIGVmZmVjdCwgaWYgYSBzY2FubmVyIFtzY2FuMV0gaXMgcmVhZGluZyBmcm9tIFtpYjFdIGFuZCBzdG9yZXMgYW5cbiAgICAgdW51c2VkIGxvb2thaGVhZCBjaGFyYWN0ZXIgW2MxXSBpbnRvIGl0cyBpbnB1dCBidWZmZXIgW2liMV0sIHRoZW5cbiAgICAgYW5vdGhlciBzY2FubmVyIFtzY2FuMl0gbm90IHJlYWRpbmcgZnJvbSB0aGUgc2FtZSBidWZmZXIgW2liMV0gd2lsbCBtaXNzXG4gICAgIHRoZSBjaGFyYWN0ZXIgW2MxXSwgc2VlbWluZ2x5IHZhbmlzaGVkIGluIHRoZSBhaXIgZnJvbSB0aGUgcG9pbnQgb2Ygdmlld1xuICAgICBvZiBbc2NhbjJdLlxuXG4gICAgIFRoaXMgbWVjaGFuaXNtIHdvcmtzIHBlcmZlY3RseSB0byByZWFkIGZyb20gc3RyaW5ncywgZnJvbSBmaWxlcywgYW5kIGZyb21cbiAgICAgZnVuY3Rpb25zLCBzaW5jZSBpbiB0aG9zZSBjYXNlcywgYWxsb2NhdGluZyB0d28gYnVmZmVycyByZWFkaW5nIGZyb20gdGhlXG4gICAgIHNhbWUgc291cmNlIGlzIHVubmF0dXJhbC5cblxuICAgICBTdGlsbCwgdGhlcmUgaXMgYSBkaWZmaWN1bHR5IGluIHRoZSBjYXNlIG9mIHNjYW5uaW5nIGZyb20gYW4gaW5wdXRcbiAgICAgY2hhbm5lbC4gSW4gZWZmZWN0LCB3aGVuIHNjYW5uaW5nIGZyb20gYW4gaW5wdXQgY2hhbm5lbCBbaWNdLCB0aGlzIGNoYW5uZWxcbiAgICAgbWF5IG5vdCBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gd2l0aGluIHRoaXMgbGlicmFyeS4gSGVuY2UsIGl0IG1heSBiZVxuICAgICBzaGFyZWQgKHR3byBmdW5jdGlvbnMgb2YgdGhlIHVzZXIncyBwcm9ncmFtIG1heSBzdWNjZXNzaXZlbHkgcmVhZCBmcm9tXG4gICAgIFtpY10pLiBUaGlzIGlzIGhpZ2hseSBlcnJvciBwcm9uZSBzaW5jZSwgb25lIG9mIHRoZSBmdW5jdGlvbiBtYXkgc2VlayB0aGVcbiAgICAgaW5wdXQgY2hhbm5lbCwgd2hpbGUgdGhlIG90aGVyIGZ1bmN0aW9uIGhhcyBzdGlsbCBhbiB1bnVzZWQgbG9va2FoZWFkXG4gICAgIGNoYXJhY3RlciBpbiBpdHMgaW5wdXQgYnVmZmVyLiBJbiBjb25jbHVzaW9uLCB5b3Ugc2hvdWxkIG5ldmVyIG1peCBkaXJlY3RcbiAgICAgbG93IGxldmVsIHJlYWRpbmcgYW5kIGhpZ2ggbGV2ZWwgc2Nhbm5pbmcgZnJvbSB0aGUgc2FtZSBpbnB1dCBjaGFubmVsLlxuXG4gICopXG5cbiAgKCogUGVyZm9ybSBidWZmZXJpemVkIGlucHV0IHRvIGltcHJvdmUgZWZmaWNpZW5jeS4gKilcbiAgbGV0IGZpbGVfYnVmZmVyX3NpemUgPSByZWYgMTAyNFxuXG4gICgqIFRoZSBzY2FubmVyIGNsb3NlcyB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQuICopXG4gIGxldCBzY2FuX2Nsb3NlX2F0X2VuZCBpYyA9IFN0ZGxpYi5jbG9zZV9pbiBpYzsgcmFpc2UgRW5kX29mX2ZpbGVcblxuICAoKiBUaGUgc2Nhbm5lciBkb2VzIG5vdCBjbG9zZSB0aGUgaW5wdXQgY2hhbm5lbCBhdCBlbmQgb2YgaW5wdXQ6XG4gICAgIGl0IGp1c3QgcmFpc2VzIFtFbmRfb2ZfZmlsZV0uICopXG4gIGxldCBzY2FuX3JhaXNlX2F0X2VuZCBfaWMgPSByYWlzZSBFbmRfb2ZfZmlsZVxuXG4gIGxldCBmcm9tX2ljIHNjYW5fY2xvc2VfaWMgaW5hbWUgaWMgPVxuICAgIGxldCBsZW4gPSAhZmlsZV9idWZmZXJfc2l6ZSBpblxuICAgIGxldCBidWYgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gICAgbGV0IGkgPSByZWYgMCBpblxuICAgIGxldCBsaW0gPSByZWYgMCBpblxuICAgIGxldCBlb2YgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgbmV4dCAoKSA9XG4gICAgICBpZiAhaSA8ICFsaW0gdGhlbiBiZWdpbiBsZXQgYyA9IEJ5dGVzLmdldCBidWYgIWkgaW4gaW5jciBpOyBjIGVuZCBlbHNlXG4gICAgICBpZiAhZW9mIHRoZW4gcmFpc2UgRW5kX29mX2ZpbGUgZWxzZSBiZWdpblxuICAgICAgICBsaW0gOj0gaW5wdXQgaWMgYnVmIDAgbGVuO1xuICAgICAgICBpZiAhbGltID0gMCB0aGVuIGJlZ2luIGVvZiA6PSB0cnVlOyBzY2FuX2Nsb3NlX2ljIGljIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgaSA6PSAxO1xuICAgICAgICAgIEJ5dGVzLmdldCBidWYgMFxuICAgICAgICBlbmRcbiAgICAgIGVuZCBpblxuICAgIGNyZWF0ZSBpbmFtZSBuZXh0XG5cblxuICBsZXQgZnJvbV9pY19jbG9zZV9hdF9lbmQgPSBmcm9tX2ljIHNjYW5fY2xvc2VfYXRfZW5kXG4gIGxldCBmcm9tX2ljX3JhaXNlX2F0X2VuZCA9IGZyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuICAoKiBUaGUgc2Nhbm5pbmcgYnVmZmVyIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXS5cbiAgICAgT25lIGNvdWxkIHRyeSB0byBkZWZpbmUgW3N0ZGliXSBhcyBhIHNjYW5uaW5nIGJ1ZmZlciByZWFkaW5nIGEgY2hhcmFjdGVyXG4gICAgIGF0IGEgdGltZSAobm8gYnVmZmVyaXphdGlvbiBhdCBhbGwpLCBidXQgdW5mb3J0dW5hdGVseSB0aGUgdG9wLWxldmVsXG4gICAgIGludGVyYWN0aW9uIHdvdWxkIGJlIHdyb25nLiBUaGlzIGlzIGR1ZSB0byBzb21lIGtpbmQgb2ZcbiAgICAgJ3JhY2UgY29uZGl0aW9uJyB3aGVuIHJlYWRpbmcgZnJvbSBbU3RkbGliLnN0ZGluXSxcbiAgICAgc2luY2UgdGhlIGludGVyYWN0aXZlIGNvbXBpbGVyIGFuZCBbU2NhbmYuc2NhbmZdIHdpbGwgc2ltdWx0YW5lb3VzbHlcbiAgICAgcmVhZCB0aGUgbWF0ZXJpYWwgdGhleSBuZWVkIGZyb20gW1N0ZGxpYi5zdGRpbl07IHRoZW4sIGNvbmZ1c2lvblxuICAgICB3aWxsIHJlc3VsdCBmcm9tIHdoYXQgc2hvdWxkIGJlIHJlYWQgYnkgdGhlIHRvcC1sZXZlbCBhbmQgd2hhdCBzaG91bGQgYmVcbiAgICAgcmVhZCBieSBbU2NhbmYuc2NhbmZdLlxuICAgICBUaGlzIGlzIGV2ZW4gbW9yZSBjb21wbGljYXRlZCBieSB0aGUgb25lIGNoYXJhY3RlciBsb29rYWhlYWQgdGhhdFxuICAgICBbU2NhbmYuc2NhbmZdIGlzIHNvbWV0aW1lcyBvYmxpZ2VkIHRvIG1haW50YWluOiB0aGUgbG9va2FoZWFkIGNoYXJhY3RlclxuICAgICB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgdGhlIG5leHQgW1NjYW5mLnNjYW5mXSBlbnRyeSwgc2VlbWluZ2x5IGNvbWluZyBmcm9tXG4gICAgIG5vd2hlcmUuXG4gICAgIEFsc28gbm8gW0VuZF9vZl9maWxlXSBpcyByYWlzZWQgd2hlbiByZWFkaW5nIGZyb20gc3RkaW46IGlmIG5vdCBlbm91Z2hcbiAgICAgY2hhcmFjdGVycyBoYXZlIGJlZW4gcmVhZCwgd2Ugc2ltcGx5IGFzayB0byByZWFkIG1vcmUuICopXG4gIGxldCBzdGRpbiA9XG4gICAgZnJvbV9pYyBzY2FuX3JhaXNlX2F0X2VuZFxuICAgICAgKEZyb21fZmlsZSAoXCItXCIsIFN0ZGxpYi5zdGRpbikpIFN0ZGxpYi5zdGRpblxuXG5cbiAgbGV0IHN0ZGliID0gc3RkaW5cblxuICBsZXQgb3Blbl9pbl9maWxlIG9wZW5faW4gZm5hbWUgPVxuICAgIG1hdGNoIGZuYW1lIHdpdGhcbiAgICB8IFwiLVwiIC0+IHN0ZGluXG4gICAgfCBmbmFtZSAtPlxuICAgICAgbGV0IGljID0gb3Blbl9pbiBmbmFtZSBpblxuICAgICAgZnJvbV9pY19jbG9zZV9hdF9lbmQgKEZyb21fZmlsZSAoZm5hbWUsIGljKSkgaWNcblxuXG4gIGxldCBvcGVuX2luID0gb3Blbl9pbl9maWxlIFN0ZGxpYi5vcGVuX2luXG4gIGxldCBvcGVuX2luX2JpbiA9IG9wZW5faW5fZmlsZSBTdGRsaWIub3Blbl9pbl9iaW5cblxuICBsZXQgZnJvbV9maWxlID0gb3Blbl9pblxuICBsZXQgZnJvbV9maWxlX2JpbiA9IG9wZW5faW5fYmluXG5cbiAgbGV0IGZyb21fY2hhbm5lbCBpYyA9XG4gICAgZnJvbV9pY19yYWlzZV9hdF9lbmQgKEZyb21fY2hhbm5lbCBpYykgaWNcblxuXG4gIGxldCBjbG9zZV9pbiBpYiA9XG4gICAgbWF0Y2ggaWIuaWNfaW5wdXRfbmFtZSB3aXRoXG4gICAgfCBGcm9tX2NoYW5uZWwgaWMgLT5cbiAgICAgIFN0ZGxpYi5jbG9zZV9pbiBpY1xuICAgIHwgRnJvbV9maWxlIChfZm5hbWUsIGljKSAtPiBTdGRsaWIuY2xvc2VfaW4gaWNcbiAgICB8IEZyb21fZnVuY3Rpb24gfCBGcm9tX3N0cmluZyAtPiAoKVxuXG5cbiAgKCpcbiAgICAgT2Jzb2xldGU6IGEgbWVtbyBbZnJvbV9jaGFubmVsXSB2ZXJzaW9uIHRvIGJ1aWxkIGEgW1NjYW5uaW5nLmluX2NoYW5uZWxdXG4gICAgIHNjYW5uaW5nIGJ1ZmZlciBvdXQgb2YgYSBbU3RkbGliLmluX2NoYW5uZWxdLlxuICAgICBUaGlzIGZ1bmN0aW9uIHdhcyB1c2VkIHRvIHRyeSB0byBwcmVzZXJ2ZSB0aGUgc2Nhbm5pbmdcbiAgICAgc2VtYW50aWNzIGZvciB0aGUgKG5vdyBvYnNvbGV0ZSkgZnVuY3Rpb24gW2ZzY2FuZl0uXG4gICAgIEdpdmVuIHRoYXQgYWxsIHNjYW5uZXIgbXVzdCByZWFkIGZyb20gYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gc2Nhbm5pbmdcbiAgICAgYnVmZmVyLCBbZnNjYW5mXSBtdXN0IHJlYWQgZnJvbSBvbmUhXG4gICAgIE1vcmUgcHJlY2lzZWx5LCBnaXZlbiBbaWNdLCBhbGwgc3VjY2Vzc2l2ZSBjYWxscyBbZnNjYW5mIGljXSBtdXN0IHJlYWRcbiAgICAgZnJvbSB0aGUgc2FtZSBzY2FubmluZyBidWZmZXIuXG4gICAgIFRoaXMgb2JsaWdlZCB0aGlzIGxpYnJhcnkgdG8gYWxsb2NhdGVkIHNjYW5uaW5nIGJ1ZmZlcnMgdGhhdCB3ZXJlXG4gICAgIG5vdCBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RhYmxlLCBoZW5jZSBsZWFkaW5nIHRvIG1lbW9yeSBsZWFrcy5cbiAgICAgSWYgeW91IG5lZWQgdG8gcmVhZCBmcm9tIGEgW1N0ZGxpYi5pbl9jaGFubmVsXSBpbnB1dCBjaGFubmVsXG4gICAgIFtpY10sIHNpbXBseSBkZWZpbmUgYSBbU2Nhbm5pbmcuaW5fY2hhbm5lbF0gZm9ybWF0dGVkIGlucHV0IGNoYW5uZWwgYXMgaW5cbiAgICAgW2xldCBpYiA9IFNjYW5uaW5nLmZyb21fY2hhbm5lbCBpY10sIHRoZW4gdXNlIFtTY2FuZi5ic2NhbmYgaWJdIGFzIHVzdWFsLlxuICAqKVxuICBsZXQgbWVtb19mcm9tX2ljID1cbiAgICBsZXQgbWVtbyA9IHJlZiBbXSBpblxuICAgIChmdW4gc2Nhbl9jbG9zZV9pYyBpYyAtPlxuICAgICB0cnkgTGlzdC5hc3NxIGljICFtZW1vIHdpdGhcbiAgICAgfCBOb3RfZm91bmQgLT5cbiAgICAgICBsZXQgaWIgPVxuICAgICAgICAgZnJvbV9pYyBzY2FuX2Nsb3NlX2ljIChGcm9tX2NoYW5uZWwgaWMpIGljIGluXG4gICAgICAgbWVtbyA6PSAoaWMsIGliKSA6OiAhbWVtbztcbiAgICAgICBpYilcblxuXG4gICgqIE9ic29sZXRlOiBzZWUgeyFtZW1vX2Zyb21faWN9IGFib3ZlLiAqKVxuICBsZXQgbWVtb19mcm9tX2NoYW5uZWwgPSBtZW1vX2Zyb21faWMgc2Nhbl9yYWlzZV9hdF9lbmRcblxuZW5kXG5cblxuKCogRm9ybWF0dGVkIGlucHV0IGZ1bmN0aW9ucy4gKilcblxudHlwZSAoJ2EsICdiLCAnYywgJ2QpIHNjYW5uZXIgPVxuICAgICAoJ2EsIFNjYW5uaW5nLmluX2NoYW5uZWwsICdiLCAnYywgJ2EgLT4gJ2QsICdkKSBmb3JtYXQ2IC0+ICdjXG5cblxuKCogUmVwb3J0aW5nIGVycm9ycy4gKilcbmV4Y2VwdGlvbiBTY2FuX2ZhaWx1cmUgb2Ygc3RyaW5nXG5cbmxldCBiYWRfaW5wdXQgcyA9IHJhaXNlIChTY2FuX2ZhaWx1cmUgcylcblxubGV0IGJhZF9pbnB1dF9lc2NhcGUgYyA9XG4gIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbGxlZ2FsIGVzY2FwZSBjaGFyYWN0ZXIgJUNcIiBjKVxuXG5cbmxldCBiYWRfdG9rZW5fbGVuZ3RoIG1lc3NhZ2UgPVxuICBiYWRfaW5wdXRcbiAgICAoUHJpbnRmLnNwcmludGZcbiAgICAgICBcInNjYW5uaW5nIG9mICVzIGZhaWxlZDogXFxcbiAgICAgICAgdGhlIHNwZWNpZmllZCBsZW5ndGggd2FzIHRvbyBzaG9ydCBmb3IgdG9rZW5cIlxuICAgICAgIG1lc3NhZ2UpXG5cblxubGV0IGJhZF9lbmRfb2ZfaW5wdXQgbWVzc2FnZSA9XG4gIGJhZF9pbnB1dFxuICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgIFwic2Nhbm5pbmcgb2YgJXMgZmFpbGVkOiBcXFxuICAgICAgICBwcmVtYXR1cmUgZW5kIG9mIGZpbGUgb2NjdXJyZWQgYmVmb3JlIGVuZCBvZiB0b2tlblwiXG4gICAgICAgbWVzc2FnZSlcblxuXG5sZXQgYmFkX2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm8gZG90IG9yIGV4cG9uZW50IHBhcnQgZm91bmQgaW4gZmxvYXQgdG9rZW5cIlxuXG5cbmxldCBiYWRfaGV4X2Zsb2F0ICgpID1cbiAgYmFkX2lucHV0IFwibm90IGEgdmFsaWQgZmxvYXQgaW4gaGV4YWRlY2ltYWwgbm90YXRpb25cIlxuXG5cbmxldCBjaGFyYWN0ZXJfbWlzbWF0Y2hfZXJyIGMgY2kgPVxuICBQcmludGYuc3ByaW50ZiBcImxvb2tpbmcgZm9yICVDLCBmb3VuZCAlQ1wiIGMgY2lcblxuXG5sZXQgY2hhcmFjdGVyX21pc21hdGNoIGMgY2kgPVxuICBiYWRfaW5wdXQgKGNoYXJhY3Rlcl9taXNtYXRjaF9lcnIgYyBjaSlcblxuXG5sZXQgcmVjIHNraXBfd2hpdGVzIGliID1cbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW4gYmVnaW5cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPlxuICAgICAgU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWI7IHNraXBfd2hpdGVzIGliXG4gICAgfCBfIC0+ICgpXG4gIGVuZFxuXG5cbigqIENoZWNraW5nIHRoYXQgW2NdIGlzIGluZGVlZCBpbiB0aGUgaW5wdXQsIHRoZW4gc2tpcHMgaXQuXG4gICBJbiB0aGlzIGNhc2UsIHRoZSBjaGFyYWN0ZXIgW2NdIGhhcyBiZWVuIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZVxuICAgZm9ybWF0IGFzIGJlaW5nIG1hbmRhdG9yeSBpbiB0aGUgaW5wdXQ7IGhlbmNlIHdlIHNob3VsZCBmYWlsIHdpdGhcbiAgIFtFbmRfb2ZfZmlsZV0gaW4gY2FzZSBvZiBlbmRfb2ZfaW5wdXQuXG4gICAoUmVtZW1iZXIgdGhhdCBbU2Nhbl9mYWlsdXJlXSBpcyByYWlzZWQgb25seSB3aGVuICh3ZSBjYW4gcHJvdmUgYnlcbiAgIGV2aWRlbmNlKSB0aGF0IHRoZSBpbnB1dCBkb2VzIG5vdCBtYXRjaCB0aGUgZm9ybWF0IHN0cmluZyBnaXZlbi4gV2UgbXVzdFxuICAgdGh1cyBkaWZmZXJlbnRpYXRlIFtFbmRfb2ZfZmlsZV0gYXMgYW4gZXJyb3IgZHVlIHRvIGxhY2sgb2YgaW5wdXQsIGFuZFxuICAgW1NjYW5fZmFpbHVyZV0gd2hpY2ggaXMgZHVlIHRvIHByb3ZhYmx5IHdyb25nIGlucHV0LiBJIGFtIG5vdCBzdXJlIHRoaXMgaXNcbiAgIHdvcnRoIHRoZSBidXJkZW46IGl0IGlzIGNvbXBsZXggYW5kIHNvbWVob3cgc3VibGltaW5hbDsgc2hvdWxkIGJlIGNsZWFyZXJcbiAgIHRvIGZhaWwgd2l0aCBTY2FuX2ZhaWx1cmUgXCJOb3QgZW5vdWdoIGlucHV0IHRvIGNvbXBsZXRlIHNjYW5uaW5nXCIhKVxuXG4gICBUaGF0J3Mgd2h5LCB3YWl0aW5nIGZvciBhIGJldHRlciBzb2x1dGlvbiwgd2UgdXNlIGNoZWNrZWRfcGVla19jaGFyIGhlcmUuXG4gICBXZSBhcmUgYWxzbyBjYXJlZnVsIHRvIHRyZWF0IFwiXFxyXFxuXCIgaW4gdGhlIGlucHV0IGFzIGFuIGVuZCBvZiBsaW5lIG1hcmtlcjpcbiAgIGl0IGFsd2F5cyBtYXRjaGVzIGEgJ1xcbicgc3BlY2lmaWNhdGlvbiBpbiB0aGUgaW5wdXQgZm9ybWF0IHN0cmluZy4gKilcbmxldCByZWMgY2hlY2tfY2hhciBpYiBjID1cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJyAnIC0+IHNraXBfd2hpdGVzIGliXG4gIHwgJ1xcbicgLT4gY2hlY2tfbmV3bGluZSBpYlxuICB8IGMgLT4gY2hlY2tfdGhpc19jaGFyIGliIGNcblxuYW5kIGNoZWNrX3RoaXNfY2hhciBpYiBjID1cbiAgbGV0IGNpID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgaWYgY2kgPSBjIHRoZW4gU2Nhbm5pbmcuaW52YWxpZGF0ZV9jdXJyZW50X2NoYXIgaWIgZWxzZVxuICBjaGFyYWN0ZXJfbWlzbWF0Y2ggYyBjaVxuXG5hbmQgY2hlY2tfbmV3bGluZSBpYiA9XG4gIGxldCBjaSA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIG1hdGNoIGNpIHdpdGhcbiAgfCAnXFxuJyAtPiBTY2FubmluZy5pbnZhbGlkYXRlX2N1cnJlbnRfY2hhciBpYlxuICB8ICdcXHInIC0+IFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliOyBjaGVja190aGlzX2NoYXIgaWIgJ1xcbidcbiAgfCBfIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxuJyBjaVxuXG5cbigqIEV4dHJhY3RpbmcgdG9rZW5zIGZyb20gdGhlIG91dHB1dCB0b2tlbiBidWZmZXIuICopXG5cbmxldCB0b2tlbl9jaGFyIGliID0gKFNjYW5uaW5nLnRva2VuIGliKS5bMF1cblxubGV0IHRva2VuX3N0cmluZyA9IFNjYW5uaW5nLnRva2VuXG5cbmxldCB0b2tlbl9ib29sIGliID1cbiAgbWF0Y2ggU2Nhbm5pbmcudG9rZW4gaWIgd2l0aFxuICB8IFwidHJ1ZVwiIC0+IHRydWVcbiAgfCBcImZhbHNlXCIgLT4gZmFsc2VcbiAgfCBzIC0+IGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJpbnZhbGlkIGJvb2xlYW4gJyVzJ1wiIHMpXG5cblxuKCogVGhlIHR5cGUgb2YgaW50ZWdlciBjb252ZXJzaW9ucy4gKilcbnR5cGUgaW50ZWdlcl9jb252ZXJzaW9uID1cbiAgfCBCX2NvbnZlcnNpb24gKCogVW5zaWduZWQgYmluYXJ5IGNvbnZlcnNpb24gKilcbiAgfCBEX2NvbnZlcnNpb24gKCogU2lnbmVkIGRlY2ltYWwgY29udmVyc2lvbiAqKVxuICB8IElfY29udmVyc2lvbiAoKiBTaWduZWQgaW50ZWdlciBjb252ZXJzaW9uICopXG4gIHwgT19jb252ZXJzaW9uICgqIFVuc2lnbmVkIG9jdGFsIGNvbnZlcnNpb24gKilcbiAgfCBVX2NvbnZlcnNpb24gKCogVW5zaWduZWQgZGVjaW1hbCBjb252ZXJzaW9uICopXG4gIHwgWF9jb252ZXJzaW9uICgqIFVuc2lnbmVkIGhleGFkZWNpbWFsIGNvbnZlcnNpb24gKilcblxuXG5sZXQgaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgPSBmdW5jdGlvblxuICB8ICdiJyAtPiBCX2NvbnZlcnNpb25cbiAgfCAnZCcgLT4gRF9jb252ZXJzaW9uXG4gIHwgJ2knIC0+IElfY29udmVyc2lvblxuICB8ICdvJyAtPiBPX2NvbnZlcnNpb25cbiAgfCAndScgLT4gVV9jb252ZXJzaW9uXG4gIHwgJ3gnIHwgJ1gnIC0+IFhfY29udmVyc2lvblxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cblxuKCogRXh0cmFjdCBhbiBpbnRlZ2VyIGxpdGVyYWwgdG9rZW4uXG4gICBTaW5jZSB0aGUgZnVuY3Rpb25zIFN0ZGxpYi4qaW50Kl9vZl9zdHJpbmcgZG8gbm90IGFjY2VwdCBhIGxlYWRpbmcgKyxcbiAgIHdlIHNraXAgaXQgaWYgbmVjZXNzYXJ5LiAqKVxubGV0IHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIgPVxuICBsZXQgdG9rID1cbiAgICBtYXRjaCBjb252IHdpdGhcbiAgICB8IERfY29udmVyc2lvbiB8IElfY29udmVyc2lvbiAtPiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgVV9jb252ZXJzaW9uIC0+IFwiMHVcIiBeIFNjYW5uaW5nLnRva2VuIGliXG4gICAgfCBPX2NvbnZlcnNpb24gLT4gXCIwb1wiIF4gU2Nhbm5pbmcudG9rZW4gaWJcbiAgICB8IFhfY29udmVyc2lvbiAtPiBcIjB4XCIgXiBTY2FubmluZy50b2tlbiBpYlxuICAgIHwgQl9jb252ZXJzaW9uIC0+IFwiMGJcIiBeIFNjYW5uaW5nLnRva2VuIGliIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCB0b2sgaW5cbiAgaWYgbCA9IDAgfHwgdG9rLlswXSA8PiAnKycgdGhlbiB0b2sgZWxzZSBTdHJpbmcuc3ViIHRvayAxIChsIC0gMSlcblxuXG4oKiBBbGwgdGhlIGZ1bmN0aW9ucyB0aGF0IGNvbnZlcnQgYSBzdHJpbmcgdG8gYSBudW1iZXIgcmFpc2UgdGhlIGV4Y2VwdGlvblxuICAgRmFpbHVyZSB3aGVuIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgIFRoaXMgZXhjZXB0aW9uIGlzIHRoZW4gdHJhcHBlZCBpbiBba3NjYW5mXS4gKilcbmxldCB0b2tlbl9pbnQgY29udiBpYiA9IGludF9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5cbmxldCB0b2tlbl9mbG9hdCBpYiA9IGZsb2F0X29mX3N0cmluZyAoU2Nhbm5pbmcudG9rZW4gaWIpXG5cbigqIFRvIHNjYW4gbmF0aXZlIGludHMsIGludDMyIGFuZCBpbnQ2NCBpbnRlZ2Vycy5cbiAgIFdlIGNhbm5vdCBhY2Nlc3MgdG8gY29udmVyc2lvbnMgdG8vZnJvbSBzdHJpbmdzIGZvciB0aG9zZSB0eXBlcyxcbiAgIE5hdGl2ZWludC5vZl9zdHJpbmcsIEludDMyLm9mX3N0cmluZywgYW5kIEludDY0Lm9mX3N0cmluZyxcbiAgIHNpbmNlIHRob3NlIG1vZHVsZXMgYXJlIG5vdCBhdmFpbGFibGUgdG8gW1NjYW5mXS5cbiAgIEhvd2V2ZXIsIHdlIGNhbiBiaW5kIGFuZCB1c2UgdGhlIGNvcnJlc3BvbmRpbmcgcHJpbWl0aXZlcyB0aGF0IGFyZVxuICAgYXZhaWxhYmxlIGluIHRoZSBydW50aW1lLiAqKVxuZXh0ZXJuYWwgbmF0aXZlaW50X29mX3N0cmluZyA6IHN0cmluZyAtPiBuYXRpdmVpbnRcbiAgPSBcImNhbWxfbmF0aXZlaW50X29mX3N0cmluZ1wiXG5cbmV4dGVybmFsIGludDMyX29mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQzMlxuICA9IFwiY2FtbF9pbnQzMl9vZl9zdHJpbmdcIlxuXG5leHRlcm5hbCBpbnQ2NF9vZl9zdHJpbmcgOiBzdHJpbmcgLT4gaW50NjRcbiAgPSBcImNhbWxfaW50NjRfb2Zfc3RyaW5nXCJcblxuXG5sZXQgdG9rZW5fbmF0aXZlaW50IGNvbnYgaWIgPSBuYXRpdmVpbnRfb2Zfc3RyaW5nICh0b2tlbl9pbnRfbGl0ZXJhbCBjb252IGliKVxubGV0IHRva2VuX2ludDMyIGNvbnYgaWIgPSBpbnQzMl9vZl9zdHJpbmcgKHRva2VuX2ludF9saXRlcmFsIGNvbnYgaWIpXG5sZXQgdG9rZW5faW50NjQgY29udiBpYiA9IGludDY0X29mX3N0cmluZyAodG9rZW5faW50X2xpdGVyYWwgY29udiBpYilcblxuKCogU2Nhbm5pbmcgbnVtYmVycy4gKilcblxuKCogRGlnaXRzIHNjYW5uaW5nIGZ1bmN0aW9ucyBzdXBwb3NlIHRoYXQgb25lIGNoYXJhY3RlciBoYXMgYmVlbiBjaGVja2VkIGFuZFxuICAgaXMgYXZhaWxhYmxlLCBzaW5jZSB0aGV5IHJldHVybiBhdCBlbmQgb2YgZmlsZSB3aXRoIHRoZSBjdXJyZW50bHkgZm91bmRcbiAgIHRva2VuIHNlbGVjdGVkLlxuXG4gICBQdXQgaXQgaW4gYW5vdGhlciB3YXksIHRoZSBkaWdpdHMgc2Nhbm5pbmcgZnVuY3Rpb25zIHNjYW4gZm9yIGEgcG9zc2libHlcbiAgIGVtcHR5IHNlcXVlbmNlIG9mIGRpZ2l0cywgKGhlbmNlLCBhIHN1Y2Nlc3NmdWwgc2Nhbm5pbmcgZnJvbSBvbmUgb2YgdGhvc2VcbiAgIGZ1bmN0aW9ucyBkb2VzIG5vdCBpbXBseSB0aGF0IHRoZSB0b2tlbiBpcyBhIHdlbGwtZm9ybWVkIG51bWJlcjogdG8gZ2V0IGFcbiAgIHRydWUgbnVtYmVyLCBpdCBpcyBtYW5kYXRvcnkgdG8gY2hlY2sgdGhhdCBhdCBsZWFzdCBvbmUgdmFsaWQgZGlnaXQgaXNcbiAgIGF2YWlsYWJsZSBiZWZvcmUgY2FsbGluZyBvbmUgb2YgdGhlIGRpZ2l0IHNjYW5uaW5nIGZ1bmN0aW9ucykuICopXG5cbigqIFRoZSBkZWNpbWFsIGNhc2UgaXMgdHJlYXRlZCBlc3BlY2lhbGx5IGZvciBvcHRpbWl6YXRpb24gcHVycG9zZXMuICopXG5sZXQgcmVjIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgJ18nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIgaW5cbiAgICBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYlxuICB8IF8gLT4gd2lkdGhcblxuXG5sZXQgc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXMgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGVjaW1hbCBkaWdpdHNcIiBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJzAnIC4uICc5JyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG4gIHwgYyAtPlxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJjaGFyYWN0ZXIgJUMgaXMgbm90IGEgZGVjaW1hbCBkaWdpdFwiIGMpXG5cblxuKCogVG8gc2NhbiBudW1iZXJzIGZyb20gb3RoZXIgYmFzZXMsIHdlIHVzZSBhIHByZWRpY2F0ZSBhcmd1bWVudCB0b1xuICAgc2NhbiBkaWdpdHMuICopXG5sZXQgc2Nhbl9kaWdpdF9zdGFyIGRpZ2l0cCB3aWR0aCBpYiA9XG4gIGxldCByZWMgc2Nhbl9kaWdpdHMgd2lkdGggaWIgPVxuICAgIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoIGVsc2VcbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8IGMgd2hlbiBkaWdpdHAgYyAtPlxuICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICBzY2FuX2RpZ2l0cyB3aWR0aCBpYlxuICAgIHwgJ18nIC0+XG4gICAgICBsZXQgd2lkdGggPSBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYiBpblxuICAgICAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcbiAgICB8IF8gLT4gd2lkdGggaW5cbiAgc2Nhbl9kaWdpdHMgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9kaWdpdF9wbHVzIGJhc2lzIGRpZ2l0cCB3aWR0aCBpYiA9XG4gICgqIEVuc3VyZSB3ZSBoYXZlIGdvdCBlbm91Z2ggd2lkdGggbGVmdCxcbiAgICAgYW5kIHJlYWQgYXQgbGVhc3Qgb25lIGRpZ2l0LiAqKVxuICBpZiB3aWR0aCA9IDAgdGhlbiBiYWRfdG9rZW5fbGVuZ3RoIFwiZGlnaXRzXCIgZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGlmIGRpZ2l0cCBjIHRoZW5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBzY2FuX2RpZ2l0X3N0YXIgZGlnaXRwIHdpZHRoIGliXG4gIGVsc2VcbiAgICBiYWRfaW5wdXQgKFByaW50Zi5zcHJpbnRmIFwiY2hhcmFjdGVyICVDIGlzIG5vdCBhIHZhbGlkICVzIGRpZ2l0XCIgYyBiYXNpcylcblxuXG5sZXQgaXNfYmluYXJ5X2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzEnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG5cblxubGV0IHNjYW5fYmluYXJ5X2ludCA9IHNjYW5fZGlnaXRfcGx1cyBcImJpbmFyeVwiIGlzX2JpbmFyeV9kaWdpdFxuXG5sZXQgaXNfb2N0YWxfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnNycgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9vY3RhbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJvY3RhbFwiIGlzX29jdGFsX2RpZ2l0XG5cbmxldCBpc19oZXhhX2RpZ2l0ID0gZnVuY3Rpb25cbiAgfCAnMCcgLi4gJzknIHwgJ2EnIC4uICdmJyB8ICdBJyAuLiAnRicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxuXG5sZXQgc2Nhbl9oZXhhZGVjaW1hbF9pbnQgPSBzY2FuX2RpZ2l0X3BsdXMgXCJoZXhhZGVjaW1hbFwiIGlzX2hleGFfZGlnaXRcblxuKCogU2NhbiBhIGRlY2ltYWwgaW50ZWdlci4gKilcbmxldCBzY2FuX3Vuc2lnbmVkX2RlY2ltYWxfaW50ID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3BsdXNcblxubGV0IHNjYW5fc2lnbiB3aWR0aCBpYiA9XG4gIGxldCBjID0gU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJysnIC0+IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgY1xuICB8ICctJyAtPiBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGNcbiAgfCBfIC0+IHdpZHRoXG5cblxubGV0IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuXG5cbigqIFNjYW4gYW4gdW5zaWduZWQgaW50ZWdlciB0aGF0IGNvdWxkIGJlIGdpdmVuIGluIGFueSAoY29tbW9uKSBiYXNpcy5cbiAgIElmIGRpZ2l0cyBhcmUgcHJlZml4ZWQgYnkgb25lIG9mIDB4LCAwWCwgMG8sIG9yIDBiLCB0aGUgbnVtYmVyIGlzXG4gICBhc3N1bWVkIHRvIGJlIHdyaXR0ZW4gcmVzcGVjdGl2ZWx5IGluIGhleGFkZWNpbWFsLCBoZXhhZGVjaW1hbCxcbiAgIG9jdGFsLCBvciBiaW5hcnkuICopXG5sZXQgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBtYXRjaCBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT5cbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgYmVnaW4gbWF0Y2ggYyB3aXRoXG4gICAgfCAneCcgfCAnWCcgLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYykgaWJcbiAgICB8ICdvJyAtPiBzY2FuX29jdGFsX2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgJ2InIC0+IHNjYW5fYmluYXJ5X2ludCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpYlxuICAgIHwgXyAtPiBzY2FuX2RlY2ltYWxfZGlnaXRfc3RhciB3aWR0aCBpYiBlbmRcbiAgfCBfIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9pbnQgd2lkdGggaWIgPVxuICBsZXQgd2lkdGggPSBzY2FuX3NpZ24gd2lkdGggaWIgaW5cbiAgc2Nhbl91bnNpZ25lZF9pbnQgd2lkdGggaWJcblxuXG5sZXQgc2Nhbl9pbnRfY29udmVyc2lvbiBjb252IHdpZHRoIGliID1cbiAgbWF0Y2ggY29udiB3aXRoXG4gIHwgQl9jb252ZXJzaW9uIC0+IHNjYW5fYmluYXJ5X2ludCB3aWR0aCBpYlxuICB8IERfY29udmVyc2lvbiAtPiBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IHdpZHRoIGliXG4gIHwgSV9jb252ZXJzaW9uIC0+IHNjYW5fb3B0aW9uYWxseV9zaWduZWRfaW50IHdpZHRoIGliXG4gIHwgT19jb252ZXJzaW9uIC0+IHNjYW5fb2N0YWxfaW50IHdpZHRoIGliXG4gIHwgVV9jb252ZXJzaW9uIC0+IHNjYW5fdW5zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgfCBYX2NvbnZlcnNpb24gLT4gc2Nhbl9oZXhhZGVjaW1hbF9pbnQgd2lkdGggaWJcblxuXG4oKiBTY2FubmluZyBmbG9hdGluZyBwb2ludCBudW1iZXJzLiAqKVxuXG4oKiBGcmFjdGlvbmFsIHBhcnQgaXMgb3B0aW9uYWwgYW5kIGNhbiBiZSByZWR1Y2VkIHRvIDAgZGlnaXRzLiAqKVxubGV0IHNjYW5fZnJhY3Rpb25hbF9wYXJ0IHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gd2lkdGggZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gIG1hdGNoIGMgd2l0aFxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIEV4cCBwYXJ0IGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVkdWNlZCB0byAwIGRpZ2l0cy4gKilcbmxldCBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWIgPVxuICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gIGlmIFNjYW5uaW5nLmVvZiBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJ2UnIHwgJ0UnIGFzIGMgLT5cbiAgICBzY2FuX29wdGlvbmFsbHlfc2lnbmVkX2RlY2ltYWxfaW50IChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpIGliXG4gIHwgXyAtPiB3aWR0aFxuXG5cbigqIFNjYW4gdGhlIGludGVnZXIgcGFydCBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgKG5vdCB1c2luZyB0aGVcbiAgIE9DYW1sIGxleGljYWwgY29udmVudGlvbiBzaW5jZSB0aGUgaW50ZWdlciBwYXJ0IGNhbiBiZSBlbXB0eSk6XG4gICBhbiBvcHRpb25hbCBzaWduLCBmb2xsb3dlZCBieSBhIHBvc3NpYmx5IGVtcHR5IHNlcXVlbmNlIG9mIGRlY2ltYWxcbiAgIGRpZ2l0cyAoZS5nLiAtLjEpLiAqKVxubGV0IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliID1cbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIHNjYW5fZGVjaW1hbF9kaWdpdF9zdGFyIHdpZHRoIGliXG5cblxuKCpcbiAgIEZvciB0aGUgdGltZSBiZWluZyB3ZSBoYXZlIChhcyBmb3VuZCBpbiBzY2FuZi5tbGkpOlxuICAgdGhlIGZpZWxkIHdpZHRoIGlzIGNvbXBvc2VkIG9mIGFuIG9wdGlvbmFsIGludGVnZXIgbGl0ZXJhbFxuICAgaW5kaWNhdGluZyB0aGUgbWF4aW1hbCB3aWR0aCBvZiB0aGUgdG9rZW4gdG8gcmVhZC5cbiAgIFVuZm9ydHVuYXRlbHksIHRoZSB0eXBlLWNoZWNrZXIgbGV0IHRoZSB1c2VyIHdyaXRlIGFuIG9wdGlvbmFsIHByZWNpc2lvbixcbiAgIHNpbmNlIHRoaXMgaXMgdmFsaWQgZm9yIHByaW50ZiBmb3JtYXQgc3RyaW5ncy5cblxuICAgVGh1cywgdGhlIG5leHQgc3RlcCBmb3IgU2NhbmYgaXMgdG8gc3VwcG9ydCBhIGZ1bGwgd2lkdGggYW5kIHByZWNpc2lvblxuICAgaW5kaWNhdGlvbiwgbW9yZSBvciBsZXNzIHNpbWlsYXIgdG8gdGhlIG9uZSBmb3IgcHJpbnRmLCBwb3NzaWJseSBleHRlbmRlZFxuICAgdG8gdGhlIHNwZWNpZmljYXRpb24gb2YgYSBbbWF4LCBtaW5dIHJhbmdlIGZvciB0aGUgd2lkdGggb2YgdGhlIHRva2VuIHJlYWRcbiAgIGZvciBzdHJpbmdzLiBTb21ldGhpbmcgbGlrZSB0aGUgZm9sbG93aW5nIHNwZWMgZm9yIHNjYW5mLm1saTpcblxuICAgVGhlIG9wdGlvbmFsIFt3aWR0aF0gaXMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBtYXhpbWFsXG4gICB3aWR0aCBvZiB0aGUgdG9rZW4gcmVhZC4gRm9yIGluc3RhbmNlLCBbJTZkXSByZWFkcyBhbiBpbnRlZ2VyLFxuICAgaGF2aW5nIGF0IG1vc3QgNiBjaGFyYWN0ZXJzLlxuXG4gICBUaGUgb3B0aW9uYWwgW3ByZWNpc2lvbl0gaXMgYSBkb3QgWy5dIGZvbGxvd2VkIGJ5IGFuIGludGVnZXI6XG5cbiAgIC0gaW4gdGhlIGZsb2F0aW5nIHBvaW50IG51bWJlciBjb252ZXJzaW9ucyAoWyVmXSwgWyVlXSwgWyVnXSwgWyVGXSwgWyVFXSxcbiAgIGFuZCBbJUZdIGNvbnZlcnNpb25zLCB0aGUgW3ByZWNpc2lvbl0gaW5kaWNhdGVzIHRoZSBtYXhpbXVtIG51bWJlciBvZlxuICAgZGlnaXRzIHRoYXQgbWF5IGZvbGxvdyB0aGUgZGVjaW1hbCBwb2ludC4gRm9yIGluc3RhbmNlLCBbJS40Zl0gcmVhZHMgYVxuICAgW2Zsb2F0XSB3aXRoIGF0IG1vc3QgNCBmcmFjdGlvbmFsIGRpZ2l0cyxcblxuICAgLSBpbiB0aGUgc3RyaW5nIGNvbnZlcnNpb25zIChbJXNdLCBbJVNdLCBbJVxcWyByYW5nZSBcXF1dKSwgYW5kIGluIHRoZVxuICAgaW50ZWdlciBudW1iZXIgY29udmVyc2lvbnMgKFslaV0sIFslZF0sIFsldV0sIFsleF0sIFslb10sIGFuZCB0aGVpclxuICAgW2ludDMyXSwgW2ludDY0XSwgYW5kIFtuYXRpdmVfaW50XSBjb3JyZXNwb25kZW50KSwgdGhlIFtwcmVjaXNpb25dXG4gICBpbmRpY2F0ZXMgdGhlIHJlcXVpcmVkIG1pbmltdW0gd2lkdGggb2YgdGhlIHRva2VuIHJlYWQsXG5cbiAgIC0gb24gYWxsIG90aGVyIGNvbnZlcnNpb25zLCB0aGUgd2lkdGggYW5kIHByZWNpc2lvbiBzcGVjaWZ5IHRoZSBbbWF4LCBtaW5dXG4gICByYW5nZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSB0b2tlbiByZWFkLlxuKilcbmxldCBzY2FuX2Zsb2F0IHdpZHRoIHByZWNpc2lvbiBpYiA9XG4gIGxldCB3aWR0aCA9IHNjYW5faW50ZWdlcl9wYXJ0IHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB0aGVuIHdpZHRoLCBwcmVjaXNpb24gZWxzZVxuICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCwgcHJlY2lzaW9uIGVsc2VcbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2ZyYWN0aW9uYWxfcGFydCBwcmVjaXNpb24gaWIpIGluXG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cbiAgfCBfIC0+XG4gICAgc2Nhbl9leHBvbmVudF9wYXJ0IHdpZHRoIGliLCBwcmVjaXNpb25cblxuXG5sZXQgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgZXJyb3Igc3RyID1cbiAgbGV0IGxvd2VyY2FzZSBjID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICdBJyAuLiAnWicgLT5cbiAgICAgIGNoYXJfb2ZfaW50IChpbnRfb2ZfY2hhciBjIC0gaW50X29mX2NoYXIgJ0EnICsgaW50X29mX2NoYXIgJ2EnKVxuICAgIHwgXyAtPiBjIGluXG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgd2lkdGggPSByZWYgd2lkdGggaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBsZXQgYyA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgIGlmIGxvd2VyY2FzZSBjIDw+IGxvd2VyY2FzZSBzdHIuW2ldIHRoZW4gZXJyb3IgKCk7XG4gICAgaWYgIXdpZHRoID0gMCB0aGVuIGVycm9yICgpO1xuICAgIHdpZHRoIDo9IFNjYW5uaW5nLnN0b3JlX2NoYXIgIXdpZHRoIGliIGM7XG4gIGRvbmU7XG4gICF3aWR0aFxuXG5cbmxldCBzY2FuX2hleF9mbG9hdCB3aWR0aCBwcmVjaXNpb24gaWIgPVxuICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICB8ICcwJyBhcyBjIC0+IChcbiAgICBsZXQgd2lkdGggPSBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMgaW5cbiAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICBsZXQgd2lkdGggPSBjaGVja19jYXNlX2luc2Vuc2l0aXZlX3N0cmluZyB3aWR0aCBpYiBiYWRfaGV4X2Zsb2F0IFwieFwiIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgIGxldCB3aWR0aCA9IG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgIHwgJy4nIHwgJ3AnIHwgJ1AnIC0+IHdpZHRoXG4gICAgICAgIHwgXyAtPiBzY2FuX2hleGFkZWNpbWFsX2ludCB3aWR0aCBpYiBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICB8ICcuJyBhcyBjIC0+IChcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgICAgICAgfCAncCcgfCAnUCcgLT4gd2lkdGhcbiAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAgICAgICAgICAgICB3aWR0aCAtIChwcmVjaXNpb24gLSBzY2FuX2hleGFkZWNpbWFsX2ludCBwcmVjaXNpb24gaWIpXG4gICAgICAgICAgKVxuICAgICAgICAgIHwgXyAtPiB3aWR0aCBpblxuICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgfCAncCcgfCAnUCcgYXMgYyAtPlxuICAgICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2hleF9mbG9hdCAoKTtcbiAgICAgICAgICAgIHNjYW5fb3B0aW9uYWxseV9zaWduZWRfZGVjaW1hbF9pbnQgd2lkdGggaWJcbiAgICAgICAgICB8IF8gLT4gd2lkdGhcbiAgKVxuICB8ICduJyB8ICdOJyBhcyBjIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgY2hlY2tfY2FzZV9pbnNlbnNpdGl2ZV9zdHJpbmcgd2lkdGggaWIgYmFkX2hleF9mbG9hdCBcImFuXCJcbiAgfCAnaScgfCAnSScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfaGV4X2Zsb2F0ICgpO1xuICAgIGNoZWNrX2Nhc2VfaW5zZW5zaXRpdmVfc3RyaW5nIHdpZHRoIGliIGJhZF9oZXhfZmxvYXQgXCJuZmluaXR5XCJcbiAgfCBfIC0+IGJhZF9oZXhfZmxvYXQgKClcblxuXG5sZXQgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9kZWNpbWFsX2RpZ2l0X3N0YXIgd2lkdGggaWIgaW5cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgbWF0Y2ggYyB3aXRoXG4gIHwgJy4nIC0+XG4gICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgKCogVGhlIGVmZmVjdGl2ZSB3aWR0aCBhdmFpbGFibGUgZm9yIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgaXNcbiAgICAgICB0aGUgbWluaW11bSBvZiBkZWNsYXJlZCBwcmVjaXNpb24gYW5kIHdpZHRoIGxlZnQuICopXG4gICAgbGV0IHByZWNpc2lvbiA9IG1pbiB3aWR0aCBwcmVjaXNpb24gaW5cbiAgICAoKiBBZnRlciBzY2FubmluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0IHdpdGggW3ByZWNpc2lvbl0gcHJvdmlzaW9uYWwgd2lkdGgsXG4gICAgICAgW3dpZHRoX3ByZWNpc2lvbl0gaXMgbGVmdC4gKilcbiAgICBsZXQgd2lkdGhfcHJlY2lzaW9uID0gc2Nhbl9mcmFjdGlvbmFsX3BhcnQgcHJlY2lzaW9uIGliIGluXG4gICAgKCogSGVuY2UsIHNjYW5uaW5nIHRoZSBmcmFjdGlvbmFsIHBhcnQgdG9vayBleGFjdGx5XG4gICAgICAgW3ByZWNpc2lvbiAtIHdpZHRoX3ByZWNpc2lvbl0gY2hhcnMuICopXG4gICAgbGV0IGZyYWNfd2lkdGggPSBwcmVjaXNpb24gLSB3aWR0aF9wcmVjaXNpb24gaW5cbiAgICAoKiBBbmQgbmV3IHByb3Zpc2lvbmFsIHdpZHRoIGlzIFt3aWR0aCAtIHdpZHRoX3ByZWNpc2lvbi4gKilcbiAgICBsZXQgd2lkdGggPSB3aWR0aCAtIGZyYWNfd2lkdGggaW5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCAnZScgfCAnRScgLT5cbiAgICBzY2FuX2V4cG9uZW50X3BhcnQgd2lkdGggaWJcbiAgfCBfIC0+IGJhZF9mbG9hdCAoKVxuXG5cbmxldCBzY2FuX2NhbWxfZmxvYXQgd2lkdGggcHJlY2lzaW9uIGliID1cbiAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgbGV0IHdpZHRoID0gc2Nhbl9zaWduIHdpZHRoIGliIGluXG4gIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gIHwgJzAnIGFzIGMgLT4gKFxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICB8ICd4JyB8ICdYJyBhcyBjIC0+IChcbiAgICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9mbG9hdCAoKTtcbiAgICAgIGxldCB3aWR0aCA9IHNjYW5faGV4YWRlY2ltYWxfaW50IHdpZHRoIGliIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gYmFkX2Zsb2F0ICgpO1xuICAgICAgbGV0IHdpZHRoID0gbWF0Y2ggU2Nhbm5pbmcucGVla19jaGFyIGliIHdpdGhcbiAgICAgICAgfCAnLicgYXMgYyAtPiAoXG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIHdpZHRoIGVsc2VcbiAgICAgICAgICAgIG1hdGNoIFNjYW5uaW5nLnBlZWtfY2hhciBpYiB3aXRoXG4gICAgICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgIGxldCBwcmVjaXNpb24gPSBtaW4gd2lkdGggcHJlY2lzaW9uIGluXG4gICAgICAgICAgICAgIHdpZHRoIC0gKHByZWNpc2lvbiAtIHNjYW5faGV4YWRlY2ltYWxfaW50IHByZWNpc2lvbiBpYilcbiAgICAgICAgKVxuICAgICAgICB8ICdwJyB8ICdQJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gYmFkX2Zsb2F0ICgpIGluXG4gICAgICBpZiB3aWR0aCA9IDAgfHwgU2Nhbm5pbmcuZW5kX29mX2lucHV0IGliIHRoZW4gd2lkdGggZWxzZVxuICAgICAgICBtYXRjaCBTY2FubmluZy5wZWVrX2NoYXIgaWIgd2l0aFxuICAgICAgICB8ICdwJyB8ICdQJyBhcyBjIC0+XG4gICAgICAgICAgbGV0IHdpZHRoID0gU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjIGluXG4gICAgICAgICAgaWYgd2lkdGggPSAwIHx8IFNjYW5uaW5nLmVuZF9vZl9pbnB1dCBpYiB0aGVuIGJhZF9oZXhfZmxvYXQgKCk7XG4gICAgICAgICAgc2Nhbl9vcHRpb25hbGx5X3NpZ25lZF9kZWNpbWFsX2ludCB3aWR0aCBpYlxuICAgICAgICB8IF8gLT4gd2lkdGhcbiAgICApXG4gICAgfCBfIC0+XG4gICAgICBzY2FuX2NhbWxfZmxvYXRfcmVzdCB3aWR0aCBwcmVjaXNpb24gaWJcbiAgKVxuICB8ICcxJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCB3aWR0aCA9IFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgYyBpblxuICAgIGlmIHdpZHRoID0gMCB8fCBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBiYWRfZmxvYXQgKCk7XG4gICAgc2Nhbl9jYW1sX2Zsb2F0X3Jlc3Qgd2lkdGggcHJlY2lzaW9uIGliXG4oKiBTcGVjaWFsIGNhc2Ugb2YgbmFuIGFuZCBpbmZpbml0eTpcbiAgfCAnaScgLT5cbiAgfCAnbicgLT5cbiopXG4gIHwgXyAtPiBiYWRfZmxvYXQgKClcblxuXG4oKiBTY2FuIGEgcmVndWxhciBzdHJpbmc6XG4gICBzdG9wcyB3aGVuIGVuY291bnRlcmluZyBhIHNwYWNlLCBpZiBubyBzY2FubmluZyBpbmRpY2F0aW9uIGhhcyBiZWVuIGdpdmVuO1xuICAgb3RoZXJ3aXNlLCBzdG9wcyB3aGVuIGVuY291bnRlcmluZyB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2Nhbm5pbmdcbiAgIGluZGljYXRpb24gW3N0cF0uXG4gICBJdCBhbHNvIHN0b3BzIGF0IGVuZCBvZiBmaWxlIG9yIHdoZW4gdGhlIG1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgaGFzXG4gICBiZWVuIHJlYWQuICopXG5sZXQgc2Nhbl9zdHJpbmcgc3RwIHdpZHRoIGliID1cbiAgbGV0IHJlYyBsb29wIHdpZHRoID1cbiAgICBpZiB3aWR0aCA9IDAgdGhlbiB3aWR0aCBlbHNlXG4gICAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgICBpZiBTY2FubmluZy5lb2YgaWIgdGhlbiB3aWR0aCBlbHNlXG4gICAgICBtYXRjaCBzdHAgd2l0aFxuICAgICAgfCBTb21lIGMnIHdoZW4gYyA9IGMnIC0+IFNjYW5uaW5nLnNraXBfY2hhciB3aWR0aCBpYlxuICAgICAgfCBTb21lIF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICB8ICcgJyB8ICdcXHQnIHwgJ1xcbicgfCAnXFxyJyAtPiB3aWR0aFxuICAgICAgICB8IF8gLT4gbG9vcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKSBpblxuICBsb29wIHdpZHRoXG5cblxuKCogU2NhbiBhIGNoYXI6IHBlZWsgc3RyaWN0bHkgb25lIGNoYXJhY3RlciBpbiB0aGUgaW5wdXQsIHdoYXRzb2V2ZXIuICopXG5sZXQgc2Nhbl9jaGFyIHdpZHRoIGliID1cbiAgKCogVGhlIGNhc2Ugd2lkdGggPSAwIGNvdWxkIG5vdCBoYXBwZW4gaGVyZSwgc2luY2UgaXQgaXMgdGVzdGVkIGJlZm9yZVxuICAgICBjYWxsaW5nIHNjYW5fY2hhciwgaW4gdGhlIG1haW4gc2Nhbm5pbmcgZnVuY3Rpb24uXG4gICAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBcImEgY2hhcmFjdGVyXCIgZWxzZSAqKVxuICBTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIChTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYilcblxuXG5sZXQgY2hhcl9mb3JfYmFja3NsYXNoID0gZnVuY3Rpb25cbiAgfCAnbicgLT4gJ1xcMDEwJ1xuICB8ICdyJyAtPiAnXFwwMTMnXG4gIHwgJ2InIC0+ICdcXDAwOCdcbiAgfCAndCcgLT4gJ1xcMDA5J1xuICB8IGMgLT4gY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBkZWNpbWFsIGRpZ2l0IGNoYXJhY3Rlci4gKilcbmxldCBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYyA9IGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnMCdcblxubGV0IGNoYXJfZm9yX2RlY2ltYWxfY29kZSBjMCBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxMDAgKiBkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzAgK1xuICAgICAxMCAqIGRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMSArXG4gICAgICAgICAgZGVjaW1hbF92YWx1ZV9vZl9jaGFyIGMyIGluXG4gIGlmIGMgPCAwIHx8IGMgPiAyNTUgdGhlblxuICAgIGJhZF9pbnB1dFxuICAgICAgKFByaW50Zi5zcHJpbnRmXG4gICAgICAgICBcImJhZCBjaGFyYWN0ZXIgZGVjaW1hbCBlbmNvZGluZyBcXFxcJWMlYyVjXCIgYzAgYzEgYzIpIGVsc2VcbiAgY2hhcl9vZl9pbnQgY1xuXG5cbigqIFRoZSBpbnRlZ2VyIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZhY2lhbCB2YWx1ZSBvZiBhIHZhbGlkXG4gICBoZXhhZGVjaW1hbCBkaWdpdCBjaGFyYWN0ZXIuICopXG5sZXQgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjID1cbiAgbGV0IGQgPSBpbnRfb2ZfY2hhciBjIGluXG4gICgqIENvdWxkIGFsc28gYmU6XG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnOScgdGhlbiBkIC0gaW50X29mX2NoYXIgJzAnIGVsc2VcbiAgICBpZiBkIDw9IGludF9vZl9jaGFyICdGJyB0aGVuIDEwICsgZCAtIGludF9vZl9jaGFyICdBJyBlbHNlXG4gICAgaWYgZCA8PSBpbnRfb2ZfY2hhciAnZicgdGhlbiAxMCArIGQgLSBpbnRfb2ZfY2hhciAnYScgZWxzZSBhc3NlcnQgZmFsc2VcbiAgKilcbiAgaWYgZCA+PSBpbnRfb2ZfY2hhciAnYScgdGhlblxuICAgIGQgLSA4NyAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnYScgKikgZWxzZVxuICBpZiBkID49IGludF9vZl9jaGFyICdBJyB0aGVuXG4gICAgZCAtIDU1ICAoKiAxMCArIGludF9vZl9jaGFyIGMgLSBpbnRfb2ZfY2hhciAnQScgKikgZWxzZVxuICAgIGQgLSBpbnRfb2ZfY2hhciAnMCdcblxuXG5sZXQgY2hhcl9mb3JfaGV4YWRlY2ltYWxfY29kZSBjMSBjMiA9XG4gIGxldCBjID1cbiAgICAxNiAqIGhleGFkZWNpbWFsX3ZhbHVlX29mX2NoYXIgYzEgK1xuICAgICAgICAgaGV4YWRlY2ltYWxfdmFsdWVfb2ZfY2hhciBjMiBpblxuICBpZiBjIDwgMCB8fCBjID4gMjU1IHRoZW5cbiAgICBiYWRfaW5wdXRcbiAgICAgIChQcmludGYuc3ByaW50ZiBcImJhZCBjaGFyYWN0ZXIgaGV4YWRlY2ltYWwgZW5jb2RpbmcgXFxcXCVjJWNcIiBjMSBjMikgZWxzZVxuICBjaGFyX29mX2ludCBjXG5cblxuKCogQ2FsbGVkIGluIHBhcnRpY3VsYXIgd2hlbiBlbmNvdW50ZXJpbmcgJ1xcXFwnIGFzIHN0YXJ0ZXIgb2YgYSBjaGFyLlxuICAgU3RvcHMgYmVmb3JlIHRoZSBjb3JyZXNwb25kaW5nICdcXCcnLiAqKVxubGV0IGNoZWNrX25leHRfY2hhciBtZXNzYWdlIHdpZHRoIGliID1cbiAgaWYgd2lkdGggPSAwIHRoZW4gYmFkX3Rva2VuX2xlbmd0aCBtZXNzYWdlIGVsc2VcbiAgbGV0IGMgPSBTY2FubmluZy5wZWVrX2NoYXIgaWIgaW5cbiAgaWYgU2Nhbm5pbmcuZW9mIGliIHRoZW4gYmFkX2VuZF9vZl9pbnB1dCBtZXNzYWdlIGVsc2VcbiAgY1xuXG5cbmxldCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgPSBjaGVja19uZXh0X2NoYXIgXCJhIENoYXJcIlxubGV0IGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nID0gY2hlY2tfbmV4dF9jaGFyIFwiYSBTdHJpbmdcIlxuXG5sZXQgc2Nhbl9iYWNrc2xhc2hfY2hhciB3aWR0aCBpYiA9XG4gIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gIHwgJ1xcXFwnIHwgJ1xcJycgfCAnXFxcIicgfCAnbicgfCAndCcgfCAnYicgfCAncicgYXMgYyAtPlxuICAgIFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgKGNoYXJfZm9yX2JhY2tzbGFzaCBjKVxuICB8ICcwJyAuLiAnOScgYXMgYyAtPlxuICAgIGxldCBnZXRfZGlnaXQgKCkgPVxuICAgICAgbGV0IGMgPSBTY2FubmluZy5uZXh0X2NoYXIgaWIgaW5cbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gY1xuICAgICAgfCBjIC0+IGJhZF9pbnB1dF9lc2NhcGUgYyBpblxuICAgIGxldCBjMCA9IGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9kZWNpbWFsX2NvZGUgYzAgYzEgYzIpXG4gIHwgJ3gnIC0+XG4gICAgbGV0IGdldF9kaWdpdCAoKSA9XG4gICAgICBsZXQgYyA9IFNjYW5uaW5nLm5leHRfY2hhciBpYiBpblxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIHwgJ2EnIC4uICdmJyBhcyBjIC0+IGNcbiAgICAgIHwgYyAtPiBiYWRfaW5wdXRfZXNjYXBlIGMgaW5cbiAgICBsZXQgYzEgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBsZXQgYzIgPSBnZXRfZGlnaXQgKCkgaW5cbiAgICBTY2FubmluZy5zdG9yZV9jaGFyICh3aWR0aCAtIDIpIGliIChjaGFyX2Zvcl9oZXhhZGVjaW1hbF9jb2RlIGMxIGMyKVxuICB8IGMgLT5cbiAgICBiYWRfaW5wdXRfZXNjYXBlIGNcblxuXG4oKiBTY2FuIGEgY2hhcmFjdGVyIChhbiBPQ2FtbCB0b2tlbikuICopXG5sZXQgc2Nhbl9jYW1sX2NoYXIgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcJycgLT4gZmluZF9jaGFyIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gY2hhcmFjdGVyX21pc21hdGNoICdcXCcnIGNcblxuICBhbmQgZmluZF9jaGFyIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX2NoYXIgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcXFwnIC0+XG4gICAgICBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKSBpYilcbiAgICB8IGMgLT5cbiAgICAgIGZpbmRfc3RvcCAoU2Nhbm5pbmcuc3RvcmVfY2hhciB3aWR0aCBpYiBjKVxuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3JfY2hhciB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFwnJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgYyAtPiBjaGFyYWN0ZXJfbWlzbWF0Y2ggJ1xcJycgYyBpblxuXG4gIGZpbmRfc3RhcnQgd2lkdGhcblxuXG4oKiBTY2FuIGEgZGVsaW1pdGVkIHN0cmluZyAoYW4gT0NhbWwgdG9rZW4pLiAqKVxubGV0IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgPVxuXG4gIGxldCByZWMgZmluZF9zdGFydCB3aWR0aCA9XG4gICAgbWF0Y2ggU2Nhbm5pbmcuY2hlY2tlZF9wZWVrX2NoYXIgaWIgd2l0aFxuICAgIHwgJ1xcXCInIC0+IGZpbmRfc3RvcCAoU2Nhbm5pbmcuaWdub3JlX2NoYXIgd2lkdGggaWIpXG4gICAgfCBjIC0+IGNoYXJhY3Rlcl9taXNtYXRjaCAnXFxcIicgY1xuXG4gIGFuZCBmaW5kX3N0b3Agd2lkdGggPVxuICAgIG1hdGNoIGNoZWNrX25leHRfY2hhcl9mb3Jfc3RyaW5nIHdpZHRoIGliIHdpdGhcbiAgICB8ICdcXFwiJyAtPiBTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYlxuICAgIHwgJ1xcXFwnIC0+IHNjYW5fYmFja3NsYXNoIChTY2FubmluZy5pZ25vcmVfY2hhciB3aWR0aCBpYilcbiAgICB8IGMgLT4gZmluZF9zdG9wIChTY2FubmluZy5zdG9yZV9jaGFyIHdpZHRoIGliIGMpXG5cbiAgYW5kIHNjYW5fYmFja3NsYXNoIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnXFxyJyAtPiBza2lwX25ld2xpbmUgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKHNjYW5fYmFja3NsYXNoX2NoYXIgd2lkdGggaWIpXG5cbiAgYW5kIHNraXBfbmV3bGluZSB3aWR0aCA9XG4gICAgbWF0Y2ggY2hlY2tfbmV4dF9jaGFyX2Zvcl9zdHJpbmcgd2lkdGggaWIgd2l0aFxuICAgIHwgJ1xcbicgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3AgKFNjYW5uaW5nLnN0b3JlX2NoYXIgd2lkdGggaWIgJ1xccicpXG5cbiAgYW5kIHNraXBfc3BhY2VzIHdpZHRoID1cbiAgICBtYXRjaCBjaGVja19uZXh0X2NoYXJfZm9yX3N0cmluZyB3aWR0aCBpYiB3aXRoXG4gICAgfCAnICcgLT4gc2tpcF9zcGFjZXMgKFNjYW5uaW5nLmlnbm9yZV9jaGFyIHdpZHRoIGliKVxuICAgIHwgXyAtPiBmaW5kX3N0b3Agd2lkdGggaW5cblxuICBmaW5kX3N0YXJ0IHdpZHRoXG5cblxuKCogU2NhbiBhIGJvb2xlYW4gKGFuIE9DYW1sIHRva2VuKS4gKilcbmxldCBzY2FuX2Jvb2wgaWIgPVxuICBsZXQgYyA9IFNjYW5uaW5nLmNoZWNrZWRfcGVla19jaGFyIGliIGluXG4gIGxldCBtID1cbiAgICBtYXRjaCBjIHdpdGhcbiAgICB8ICd0JyAtPiA0XG4gICAgfCAnZicgLT4gNVxuICAgIHwgYyAtPlxuICAgICAgYmFkX2lucHV0XG4gICAgICAgIChQcmludGYuc3ByaW50ZiBcInRoZSBjaGFyYWN0ZXIgJUMgY2Fubm90IHN0YXJ0IGEgYm9vbGVhblwiIGMpIGluXG4gIHNjYW5fc3RyaW5nIE5vbmUgbSBpYlxuXG5cbigqIFNjYW4gYSBzdHJpbmcgY29udGFpbmluZyBlbGVtZW50cyBpbiBjaGFyX3NldCBhbmQgdGVybWluYXRlZCBieSBzY2FuX2luZGljXG4gICBpZiBwcm92aWRlZC4gKilcbmxldCBzY2FuX2NoYXJzX2luX2NoYXJfc2V0IGNoYXJfc2V0IHNjYW5faW5kaWMgd2lkdGggaWIgPVxuICBsZXQgcmVjIHNjYW5fY2hhcnMgaSBzdHAgPVxuICAgIGxldCBjID0gU2Nhbm5pbmcucGVla19jaGFyIGliIGluXG4gICAgaWYgaSA+IDAgJiYgbm90IChTY2FubmluZy5lb2YgaWIpICYmXG4gICAgICAgaXNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgYyAmJlxuICAgICAgIGludF9vZl9jaGFyIGMgPD4gc3RwIHRoZW5cbiAgICAgIGxldCBfID0gU2Nhbm5pbmcuc3RvcmVfY2hhciBtYXhfaW50IGliIGMgaW5cbiAgICAgIHNjYW5fY2hhcnMgKGkgLSAxKSBzdHAgaW5cbiAgbWF0Y2ggc2Nhbl9pbmRpYyB3aXRoXG4gIHwgTm9uZSAtPiBzY2FuX2NoYXJzIHdpZHRoICgtMSk7XG4gIHwgU29tZSBjIC0+XG4gICAgc2Nhbl9jaGFycyB3aWR0aCAoaW50X29mX2NoYXIgYyk7XG4gICAgaWYgbm90IChTY2FubmluZy5lb2YgaWIpIHRoZW5cbiAgICAgIGxldCBjaSA9IFNjYW5uaW5nLnBlZWtfY2hhciBpYiBpblxuICAgICAgaWYgYyA9IGNpXG4gICAgICB0aGVuIFNjYW5uaW5nLmludmFsaWRhdGVfY3VycmVudF9jaGFyIGliXG4gICAgICBlbHNlIGNoYXJhY3Rlcl9taXNtYXRjaCBjIGNpXG5cblxuKCogVGhlIGdsb2JhbCBlcnJvciByZXBvcnQgZnVuY3Rpb24gZm9yIFtTY2FuZl0uICopXG5sZXQgc2NhbmZfYmFkX2lucHV0IGliID0gZnVuY3Rpb25cbiAgfCBTY2FuX2ZhaWx1cmUgcyB8IEZhaWx1cmUgcyAtPlxuICAgIGxldCBpID0gU2Nhbm5pbmcuY2hhcl9jb3VudCBpYiBpblxuICAgIGJhZF9pbnB1dCAoUHJpbnRmLnNwcmludGYgXCJzY2FuZjogYmFkIGlucHV0IGF0IGNoYXIgbnVtYmVyICVpOiAlc1wiIGkgcylcbiAgfCB4IC0+IHJhaXNlIHhcblxuXG4oKiBHZXQgdGhlIGNvbnRlbnQgb2YgYSBjb3VudGVyIGZyb20gYW4gaW5wdXQgYnVmZmVyLiAqKVxubGV0IGdldF9jb3VudGVyIGliIGNvdW50ZXIgPVxuICBtYXRjaCBjb3VudGVyIHdpdGhcbiAgfCBMaW5lX2NvdW50ZXIgLT4gU2Nhbm5pbmcubGluZV9jb3VudCBpYlxuICB8IENoYXJfY291bnRlciAtPiBTY2FubmluZy5jaGFyX2NvdW50IGliXG4gIHwgVG9rZW5fY291bnRlciAtPiBTY2FubmluZy50b2tlbl9jb3VudCBpYlxuXG5cbigqIENvbXB1dGUgdGhlIHdpZHRoIG9mIGEgcGFkZGluZyBvcHRpb24gKHNlZSBcIiU0MntcIiBhbmQgXCIlMTIzKFwiKS4gKilcbmxldCB3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQgPSBtYXRjaCBwYWRfb3B0IHdpdGhcbiAgfCBOb25lIC0+IG1heF9pbnRcbiAgfCBTb21lIHdpZHRoIC0+IHdpZHRoXG5cblxubGV0IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nID1cbiAgaWYgZm10aW5nID0gRXNjYXBlZF9wZXJjZW50IHRoZW4gJyUnLCBcIlwiIGVsc2VcbiAgICBsZXQgc3RyID0gc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZtdGluZyBpblxuICAgIGxldCBzdHAgPSBzdHIuWzFdIGluXG4gICAgbGV0IHN1Yl9zdHIgPSBTdHJpbmcuc3ViIHN0ciAyIChTdHJpbmcubGVuZ3RoIHN0ciAtIDIpIGluXG4gICAgc3RwLCBzdWJfc3RyXG5cblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICgqIFJlYWRlciBtYW5hZ2VtZW50ICopXG5cbigqIEEgY2FsbCB0byB0YWtlX2Zvcm1hdF9yZWFkZXJzIG9uIGEgZm9ybWF0IGlzIGV2YWx1YXRlZCBpbnRvIGZ1bmN0aW9uc1xuICAgdGFraW5nIHJlYWRlcnMgYXMgYXJndW1lbnRzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGFuIGhldGVyb2dlbmVvdXMgbGlzdCAqKVxuKCogV2hlbiBhbGwgcmVhZGVycyBhcmUgdGFrZW4sIGZpbmFsbHkgcGFzcyB0aGUgbGlzdCBvZiB0aGUgcmVhZGVycyB0byB0aGVcbiAgIGNvbnRpbnVhdGlvbiBrLiAqKVxubGV0IHJlYyB0YWtlX2Zvcm1hdF9yZWFkZXJzIDogdHlwZSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgZCA9XG5mdW4gayBmbXQgLT4gbWF0Y2ggZm10IHdpdGhcbiAgfCBSZWFkZXIgZm10X3Jlc3QgLT5cbiAgICBmdW4gcmVhZGVyIC0+XG4gICAgICBsZXQgbmV3X2sgcmVhZGVyc19yZXN0ID0gayAoQ29ucyAocmVhZGVyLCByZWFkZXJzX3Jlc3QpKSBpblxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBuZXdfayBmbXRfcmVzdFxuICB8IENoYXIgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQ2FtbF9jaGFyIHJlc3QgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBTdHJpbmcgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IENhbWxfc3RyaW5nIChfLCByZXN0KSAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50IChfLCBfLCBfLCByZXN0KSAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBJbnQzMiAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IE5hdGl2ZWludCAoXywgXywgXywgcmVzdCkgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgSW50NjQgKF8sIF8sIF8sIHJlc3QpICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBGbG9hdCAoXywgXywgXywgcmVzdCkgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEJvb2wgKF8sIHJlc3QpICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgQWxwaGEgcmVzdCAgICAgICAgICAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBUaGV0YSByZXN0ICAgICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEZsdXNoIHJlc3QgICAgICAgICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU3RyaW5nX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcbiAgfCBDaGFyX2xpdGVyYWwgKF8sIHJlc3QpICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IEN1c3RvbSAoXywgXywgcmVzdCkgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG5cbiAgfCBTY2FuX2NoYXJfc2V0IChfLCBfLCByZXN0KSAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgcmVzdFxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKF8sIHJlc3QpICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgU2Nhbl9uZXh0X2NoYXIgcmVzdCAgICAgICAgICAgICAgLT4gdGFrZV9mb3JtYXRfcmVhZGVycyBrIHJlc3RcblxuICB8IEZvcm1hdHRpbmdfbGl0IChfLCByZXN0KSAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCwgXykpLCByZXN0KSAtPlxuICAgICAgdGFrZV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10IGZtdCByZXN0KVxuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQsIF8pKSwgcmVzdCkgLT5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgayAoY29uY2F0X2ZtdCBmbXQgcmVzdClcblxuICB8IEZvcm1hdF9hcmcgKF8sIF8sIHJlc3QpICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayByZXN0XG4gIHwgRm9ybWF0X3N1YnN0IChfLCBmbXR0eSwgcmVzdCkgICAgLT5cbiAgICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChlcmFzZV9yZWwgKHN5bW0gZm10dHkpKSByZXN0XG4gIHwgSWdub3JlZF9wYXJhbSAoaWduLCByZXN0KSAgICAgICAgLT4gdGFrZV9pZ25vcmVkX2Zvcm1hdF9yZWFkZXJzIGsgaWduIHJlc3RcblxuICB8IEVuZF9vZl9mb3JtYXQgICAgICAgICAgICAgICAgICAgIC0+IGsgTmlsXG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGZtdHR5IGNvbWluZyBmcm9tIGEgRm9ybWF0X3N1YnN0IFwiJSguLi4lKVwiLiAqKVxuYW5kIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgOiB0eXBlIHggeSBhIGMgZCBlIGYgLlxuICAgICgoZCwgZSkgaGV0ZXJfbGlzdCAtPiBlKSAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgeCwgeSkgZm10dHkgLT5cbiAgICAgICh5LCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCB4LCBlLCBmKSBmbXQgLT4gZCA9XG5mdW4gayBmbXR0eSBmbXQgLT4gbWF0Y2ggZm10dHkgd2l0aFxuICB8IFJlYWRlcl90eSBmbXRfcmVzdCAtPlxuICAgIGZ1biByZWFkZXIgLT5cbiAgICAgIGxldCBuZXdfayByZWFkZXJzX3Jlc3QgPSBrIChDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkpIGluXG4gICAgICB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIG5ld19rIGZtdF9yZXN0IGZtdFxuICB8IElnbm9yZWRfcmVhZGVyX3R5IGZtdF9yZXN0IC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10X3Jlc3QgZm10XG4gIHwgQ2hhcl90eSByZXN0ICAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IFN0cmluZ190eSByZXN0ICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnRfdHkgcmVzdCAgICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgSW50MzJfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IE5hdGl2ZWludF90eSByZXN0ICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBJbnQ2NF90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRmxvYXRfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEJvb2xfdHkgcmVzdCAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBBbHBoYV90eSByZXN0ICAgICAgICAgICAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgVGhldGFfdHkgcmVzdCAgICAgICAgICAgICAgIC0+IHRha2VfZm10dHlfZm9ybWF0X3JlYWRlcnMgayByZXN0IGZtdFxuICB8IEFueV90eSByZXN0ICAgICAgICAgICAgICAgICAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgcmVzdCBmbXRcbiAgfCBGb3JtYXRfYXJnX3R5IChfLCByZXN0KSAgICAgLT4gdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIHJlc3QgZm10XG4gIHwgRW5kX29mX2ZtdHR5ICAgICAgICAgICAgICAgIC0+IHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcbiAgfCBGb3JtYXRfc3Vic3RfdHkgKHR5MSwgdHkyLCByZXN0KSAtPlxuICAgIGxldCB0eSA9IHRyYW5zIChzeW1tIHR5MSkgdHkyIGluXG4gICAgdGFrZV9mbXR0eV9mb3JtYXRfcmVhZGVycyBrIChjb25jYXRfZm10dHkgdHkgcmVzdCkgZm10XG5cbigqIFRha2UgcmVhZGVycyBhc3NvY2lhdGVkIHRvIGFuIGlnbm9yZWQgcGFyYW1ldGVyLiAqKVxuYW5kIHRha2VfaWdub3JlZF9mb3JtYXRfcmVhZGVycyA6IHR5cGUgeCB5IGEgYyBkIGUgZiAuXG4gICAgKChkLCBlKSBoZXRlcl9saXN0IC0+IGUpIC0+IChhLCBTY2FubmluZy5pbl9jaGFubmVsLCBjLCBkLCB4LCB5KSBpZ25vcmVkIC0+XG4gICAgICAoeSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgeCwgZSwgZikgZm10IC0+IGQgPVxuZnVuIGsgaWduIGZtdCAtPiBtYXRjaCBpZ24gd2l0aFxuICB8IElnbm9yZWRfcmVhZGVyIC0+XG4gICAgZnVuIHJlYWRlciAtPlxuICAgICAgbGV0IG5ld19rIHJlYWRlcnNfcmVzdCA9IGsgKENvbnMgKHJlYWRlciwgcmVhZGVyc19yZXN0KSkgaW5cbiAgICAgIHRha2VfZm9ybWF0X3JlYWRlcnMgbmV3X2sgZm10XG4gIHwgSWdub3JlZF9jaGFyICAgICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX2NoYXIgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zdHJpbmcgXyAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9jYW1sX3N0cmluZyBfICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQgKF8sIF8pICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQzMiAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9uYXRpdmVpbnQgKF8sIF8pICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9pbnQ2NCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mbG9hdCAoXywgXykgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9ib29sIF8gICAgICAgICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfYXJnIF8gICAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9mb3JtYXRfc3Vic3QgKF8sIGZtdHR5KSAtPiB0YWtlX2ZtdHR5X2Zvcm1hdF9yZWFkZXJzIGsgZm10dHkgZm10XG4gIHwgSWdub3JlZF9zY2FuX2NoYXJfc2V0IF8gICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX2dldF9jb3VudGVyIF8gICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG4gIHwgSWdub3JlZF9zY2FuX25leHRfY2hhciAgICAgICAgICAtPiB0YWtlX2Zvcm1hdF9yZWFkZXJzIGsgZm10XG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4gICAgICAgICAgICAgICAgICAgICAgICAgICgqIEdlbmVyaWMgc2Nhbm5pbmcgKilcblxuKCogTWFrZSBhIGdlbmVyaWMgc2Nhbm5pbmcgZnVuY3Rpb24uICopXG4oKiBTY2FuIGEgc3RyZWFtIGFjY29yZGluZyB0byBhIGZvcm1hdCBhbmQgcmVhZGVycyBvYnRhaW5lZCBieVxuICAgdGFrZV9mb3JtYXRfcmVhZGVycywgYW5kIGFnZ3JlZ2F0ZSBzY2FubmVkIHZhbHVlcyBpbnRvIGFuXG4gICBoZXRlcm9nZW5lb3VzIGxpc3QuICopXG4oKiBSZXR1cm4gdGhlIGhldGVyb2dlbmVvdXMgbGlzdCBvZiBzY2FubmVkIHZhbHVlcy4gKilcbmxldCByZWMgbWFrZV9zY2FuZiA6IHR5cGUgYSBjIGQgZSBmLlxuICAgIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKGEsIFNjYW5uaW5nLmluX2NoYW5uZWwsIGMsIGQsIGUsIGYpIGZtdCAtPlxuICAgICAgKGQsIGUpIGhldGVyX2xpc3QgLT4gKGEsIGYpIGhldGVyX2xpc3QgPVxuZnVuIGliIGZtdCByZWFkZXJzIC0+IG1hdGNoIGZtdCB3aXRoXG4gIHwgQ2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NoYXIgMCBpYiBpblxuICAgIGxldCBjID0gdG9rZW5fY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IENhbWxfY2hhciByZXN0IC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfY2hhciAwIGliIGluXG4gICAgbGV0IGMgPSB0b2tlbl9jaGFyIGliIGluXG4gICAgQ29ucyAoYywgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnMpXG5cbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSBzdHApIHdpZHRoIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiBzdHJfcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcbiAgfCBTdHJpbmcgKHBhZCwgRm9ybWF0dGluZ19nZW4gKE9wZW5fdGFnIChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fc3RyaW5nIChTb21lICd7Jykgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuXG4gICAgICAgICAgICAgICAgICAgdG9rZW5fc3RyaW5nXG4gIHwgU3RyaW5nIChwYWQsIEZvcm1hdHRpbmdfZ2VuIChPcGVuX2JveCAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpKSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyAoU29tZSAnWycpIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhblxuICAgICAgICAgICAgICAgICAgIHRva2VuX3N0cmluZ1xuICB8IFN0cmluZyAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX3N0cmluZyBOb25lIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBOb19wcmVjaXNpb24gc2NhbiB0b2tlbl9zdHJpbmdcblxuICB8IENhbWxfc3RyaW5nIChwYWQsIHJlc3QpIC0+XG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5fY2FtbF9zdHJpbmcgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIE5vX3ByZWNpc2lvbiBzY2FuIHRva2VuX3N0cmluZ1xuICB8IEludCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50IGMpXG4gIHwgSW50MzIgKGljb252LCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgbGV0IGMgPSBpbnRlZ2VyX2NvbnZlcnNpb25fb2ZfY2hhciAoY2hhcl9vZl9pY29udiBpY29udikgaW5cbiAgICBsZXQgc2NhbiB3aWR0aCBfIGliID0gc2Nhbl9pbnRfY29udmVyc2lvbiBjIHdpZHRoIGliIGluXG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW4gKHRva2VuX2ludDMyIGMpXG4gIHwgTmF0aXZlaW50IChpY29udiwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIGxldCBjID0gaW50ZWdlcl9jb252ZXJzaW9uX29mX2NoYXIgKGNoYXJfb2ZfaWNvbnYgaWNvbnYpIGluXG4gICAgbGV0IHNjYW4gd2lkdGggXyBpYiA9IHNjYW5faW50X2NvbnZlcnNpb24gYyB3aWR0aCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuICh0b2tlbl9uYXRpdmVpbnQgYylcbiAgfCBJbnQ2NCAoaWNvbnYsIHBhZCwgcHJlYywgcmVzdCkgLT5cbiAgICBsZXQgYyA9IGludGVnZXJfY29udmVyc2lvbl9vZl9jaGFyIChjaGFyX29mX2ljb252IGljb252KSBpblxuICAgIGxldCBzY2FuIHdpZHRoIF8gaWIgPSBzY2FuX2ludF9jb252ZXJzaW9uIGMgd2lkdGggaWIgaW5cbiAgICBwYWRfcHJlY19zY2FuZiBpYiByZXN0IHJlYWRlcnMgcGFkIHByZWMgc2NhbiAodG9rZW5faW50NjQgYylcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9GIHwgRmxvYXRfQ0YpKSwgcGFkLCBwcmVjLCByZXN0KSAtPlxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgcHJlYyBzY2FuX2NhbWxfZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9mIHwgRmxvYXRfZSB8IEZsb2F0X0UgfCBGbG9hdF9nIHwgRmxvYXRfRykpLFxuICAgICAgICAgICBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5fZmxvYXQgdG9rZW5fZmxvYXRcbiAgfCBGbG9hdCAoKF8sIChGbG9hdF9oIHwgRmxvYXRfSCkpLCBwYWQsIHByZWMsIHJlc3QpIC0+XG4gICAgcGFkX3ByZWNfc2NhbmYgaWIgcmVzdCByZWFkZXJzIHBhZCBwcmVjIHNjYW5faGV4X2Zsb2F0IHRva2VuX2Zsb2F0XG4gIHwgQm9vbCAocGFkLCByZXN0KSAtPlxuICAgIGxldCBzY2FuIF8gXyBpYiA9IHNjYW5fYm9vbCBpYiBpblxuICAgIHBhZF9wcmVjX3NjYW5mIGliIHJlc3QgcmVhZGVycyBwYWQgTm9fcHJlY2lzaW9uIHNjYW4gdG9rZW5fYm9vbFxuICB8IEFscGhhIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJWFcXFwiXCJcbiAgfCBUaGV0YSBfIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiV0XFxcIlwiXG4gIHwgQ3VzdG9tIF8gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJT9cXFwiIChjdXN0b20gY29udmVydGVyKVwiXG4gIHwgUmVhZGVyIGZtdF9yZXN0IC0+XG4gICAgYmVnaW4gbWF0Y2ggcmVhZGVycyB3aXRoXG4gICAgfCBDb25zIChyZWFkZXIsIHJlYWRlcnNfcmVzdCkgLT5cbiAgICAgICAgbGV0IHggPSByZWFkZXIgaWIgaW5cbiAgICAgICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXRfcmVzdCByZWFkZXJzX3Jlc3QpXG4gICAgfCBOaWwgLT5cbiAgICAgICAgaW52YWxpZF9hcmcgXCJzY2FuZjogbWlzc2luZyByZWFkZXJcIlxuICAgIGVuZFxuICB8IEZsdXNoIHJlc3QgLT5cbiAgICBpZiBTY2FubmluZy5lbmRfb2ZfaW5wdXQgaWIgdGhlbiBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICAgIGVsc2UgYmFkX2lucHV0IFwiZW5kIG9mIGlucHV0IG5vdCBmb3VuZFwiXG5cbiAgfCBTdHJpbmdfbGl0ZXJhbCAoc3RyLCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSBzdHI7XG4gICAgbWFrZV9zY2FuZiBpYiByZXN0IHJlYWRlcnNcbiAgfCBDaGFyX2xpdGVyYWwgKGNociwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliIGNocjtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuXG4gIHwgRm9ybWF0X2FyZyAocGFkX29wdCwgZm10dHksIHJlc3QpIC0+XG4gICAgbGV0IF8gPSBzY2FuX2NhbWxfc3RyaW5nICh3aWR0aF9vZl9wYWRfb3B0IHBhZF9vcHQpIGliIGluXG4gICAgbGV0IHMgPSB0b2tlbl9zdHJpbmcgaWIgaW5cbiAgICBsZXQgZm10ID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2ZtdHR5IHMgZm10dHlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoZm10LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBGb3JtYXRfc3Vic3QgKHBhZF9vcHQsIGZtdHR5LCByZXN0KSAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyAod2lkdGhfb2ZfcGFkX29wdCBwYWRfb3B0KSBpYiBpblxuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IGZtdCwgZm10JyA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IEZtdF9FQkIgZm10ID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICBsZXQgRm10X0VCQiBmbXQnID0gZm10X2ViYl9vZl9zdHJpbmcgcyBpblxuICAgICAgICAoKiBUT0RPOiBmaW5kIGEgd2F5IHRvIGF2b2lkIHJlcGFyc2luZyB0d2ljZSAqKVxuXG4gICAgICAgICgqIFRPRE86IHRoZXNlIHR5cGUtY2hlY2tzIGJlbG93ICpjYW4qIGZhaWwgYmVjYXVzZSBvZiB0eXBlXG4gICAgICAgICAgIGFtYmlndWl0eSBpbiBwcmVzZW5jZSBvZiBpZ25vcmVkLXJlYWRlcnM6IFwiJV9yJWRcIiBhbmQgXCIlZCVfclwiXG4gICAgICAgICAgIGFyZSB0eXBlZCBpbiB0aGUgc2FtZSB3YXkuXG5cbiAgICAgICAgICAgIyBTY2FuZi5zc2NhbmYgXCJcXFwiJV9yJWRcXFwiM1wiIFwiJSglZCVfciUpXCIgaWdub3JlXG4gICAgICAgICAgICAgKGZ1biBmbXQgbiAtPiBzdHJpbmdfb2ZfZm9ybWF0IGZtdCwgbilcbiAgICAgICAgICAgRXhjZXB0aW9uOiBDYW1saW50ZXJuYWxGb3JtYXQuVHlwZV9taXNtYXRjaC5cblxuICAgICAgICAgICBXZSBzaG91bGQgcHJvcGVybHkgY2F0Y2ggdGhpcyBleGNlcHRpb24uXG4gICAgICAgICopXG4gICAgICAgIHR5cGVfZm9ybWF0IGZtdCAoZXJhc2VfcmVsIGZtdHR5KSxcbiAgICAgICAgdHlwZV9mb3JtYXQgZm10JyAoZXJhc2VfcmVsIChzeW1tIGZtdHR5KSlcbiAgICAgIHdpdGggRmFpbHVyZSBtc2cgLT4gYmFkX2lucHV0IG1zZ1xuICAgIGluXG4gICAgQ29ucyAoRm9ybWF0IChmbXQsIHMpLFxuICAgICAgICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzKVxuXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgRm9ybWF0dGluZ19saXQgKGZtdGluZ19saXQsIHJlc3QpKSAtPlxuICAgIGxldCBzdHAsIHN0ciA9IHN0b3BwZXJfb2ZfZm9ybWF0dGluZ19saXQgZm10aW5nX2xpdCBpblxuICAgIGxldCB3aWR0aCA9IHdpZHRoX29mX3BhZF9vcHQgd2lkdGhfb3B0IGluXG4gICAgc2Nhbl9jaGFyc19pbl9jaGFyX3NldCBjaGFyX3NldCAoU29tZSBzdHApIHdpZHRoIGliO1xuICAgIGxldCBzID0gdG9rZW5fc3RyaW5nIGliIGluXG4gICAgbGV0IHN0cl9yZXN0ID0gU3RyaW5nX2xpdGVyYWwgKHN0ciwgcmVzdCkgaW5cbiAgICBDb25zIChzLCBtYWtlX3NjYW5mIGliIHN0cl9yZXN0IHJlYWRlcnMpXG4gIHwgU2Nhbl9jaGFyX3NldCAod2lkdGhfb3B0LCBjaGFyX3NldCwgcmVzdCkgLT5cbiAgICBsZXQgd2lkdGggPSB3aWR0aF9vZl9wYWRfb3B0IHdpZHRoX29wdCBpblxuICAgIHNjYW5fY2hhcnNfaW5fY2hhcl9zZXQgY2hhcl9zZXQgTm9uZSB3aWR0aCBpYjtcbiAgICBsZXQgcyA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIENvbnMgKHMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuICB8IFNjYW5fZ2V0X2NvdW50ZXIgKGNvdW50ZXIsIHJlc3QpIC0+XG4gICAgbGV0IGNvdW50ID0gZ2V0X2NvdW50ZXIgaWIgY291bnRlciBpblxuICAgIENvbnMgKGNvdW50LCBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVycylcbiAgfCBTY2FuX25leHRfY2hhciByZXN0IC0+XG4gICAgbGV0IGMgPSBTY2FubmluZy5jaGVja2VkX3BlZWtfY2hhciBpYiBpblxuICAgIENvbnMgKGMsIG1ha2Vfc2NhbmYgaWIgcmVzdCByZWFkZXJzKVxuXG4gIHwgRm9ybWF0dGluZ19saXQgKGZvcm1hdHRpbmdfbGl0LCByZXN0KSAtPlxuICAgIFN0cmluZy5pdGVyIChjaGVja19jaGFyIGliKSAoc3RyaW5nX29mX2Zvcm1hdHRpbmdfbGl0IGZvcm1hdHRpbmdfbGl0KTtcbiAgICBtYWtlX3NjYW5mIGliIHJlc3QgcmVhZGVyc1xuICB8IEZvcm1hdHRpbmdfZ2VuIChPcGVuX3RhZyAoRm9ybWF0IChmbXQnLCBfKSksIHJlc3QpIC0+XG4gICAgY2hlY2tfY2hhciBpYiAnQCc7IGNoZWNrX2NoYXIgaWIgJ3snO1xuICAgIG1ha2Vfc2NhbmYgaWIgKGNvbmNhdF9mbXQgZm10JyByZXN0KSByZWFkZXJzXG4gIHwgRm9ybWF0dGluZ19nZW4gKE9wZW5fYm94IChGb3JtYXQgKGZtdCcsIF8pKSwgcmVzdCkgLT5cbiAgICBjaGVja19jaGFyIGliICdAJzsgY2hlY2tfY2hhciBpYiAnWyc7XG4gICAgbWFrZV9zY2FuZiBpYiAoY29uY2F0X2ZtdCBmbXQnIHJlc3QpIHJlYWRlcnNcblxuICB8IElnbm9yZWRfcGFyYW0gKGlnbiwgcmVzdCkgLT5cbiAgICBsZXQgUGFyYW1fZm9ybWF0X0VCQiBmbXQnID0gcGFyYW1fZm9ybWF0X29mX2lnbm9yZWRfZm9ybWF0IGlnbiByZXN0IGluXG4gICAgYmVnaW4gbWF0Y2ggbWFrZV9zY2FuZiBpYiBmbXQnIHJlYWRlcnMgd2l0aFxuICAgIHwgQ29ucyAoXywgYXJnX3Jlc3QpIC0+IGFyZ19yZXN0XG4gICAgfCBOaWwgLT4gYXNzZXJ0IGZhbHNlXG4gICAgZW5kXG5cbiAgfCBFbmRfb2ZfZm9ybWF0IC0+XG4gICAgTmlsXG5cbigqIENhc2UgYW5hbHlzaXMgb24gcGFkZGluZyBhbmQgcHJlY2lzaW9uLiAqKVxuKCogUmVqZWN0IGZvcm1hdHMgY29udGFpbmluZyBcIiUqXCIgb3IgXCIlLipcIi4gKilcbigqIFBhc3MgcGFkZGluZyBhbmQgcHJlY2lzaW9uIHRvIHRoZSBnZW5lcmljIHNjYW5uZXIgYHNjYW4nLiAqKVxuYW5kIHBhZF9wcmVjX3NjYW5mIDogdHlwZSBhIGMgZCBlIGYgeCB5IHogdCAuXG4gICAgU2Nhbm5pbmcuaW5fY2hhbm5lbCAtPiAoYSwgU2Nhbm5pbmcuaW5fY2hhbm5lbCwgYywgZCwgZSwgZikgZm10IC0+XG4gICAgICAoZCwgZSkgaGV0ZXJfbGlzdCAtPiAoeCwgeSkgcGFkZGluZyAtPiAoeSwgeiAtPiBhKSBwcmVjaXNpb24gLT5cbiAgICAgIChpbnQgLT4gaW50IC0+IFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gdCkgLT5cbiAgICAgIChTY2FubmluZy5pbl9jaGFubmVsIC0+IHopIC0+XG4gICAgICAoeCwgZikgaGV0ZXJfbGlzdCA9XG5mdW4gaWIgZm10IHJlYWRlcnMgcGFkIHByZWMgc2NhbiB0b2tlbiAtPiBtYXRjaCBwYWQsIHByZWMgd2l0aFxuICB8IE5vX3BhZGRpbmcsIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiBtYXhfaW50IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBOb19wYWRkaW5nLCBMaXRfcHJlY2lzaW9uIHAgLT5cbiAgICBsZXQgXyA9IHNjYW4gbWF4X2ludCBwIGliIGluXG4gICAgbGV0IHggPSB0b2tlbiBpYiBpblxuICAgIENvbnMgKHgsIG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpXG4gIHwgTGl0X3BhZGRpbmcgKChSaWdodCB8IFplcm9zKSwgdyksIE5vX3ByZWNpc2lvbiAtPlxuICAgIGxldCBfID0gc2NhbiB3IG1heF9pbnQgaWIgaW5cbiAgICBsZXQgeCA9IHRva2VuIGliIGluXG4gICAgQ29ucyAoeCwgbWFrZV9zY2FuZiBpYiBmbXQgcmVhZGVycylcbiAgfCBMaXRfcGFkZGluZyAoKFJpZ2h0IHwgWmVyb3MpLCB3KSwgTGl0X3ByZWNpc2lvbiBwIC0+XG4gICAgbGV0IF8gPSBzY2FuIHcgcCBpYiBpblxuICAgIGxldCB4ID0gdG9rZW4gaWIgaW5cbiAgICBDb25zICh4LCBtYWtlX3NjYW5mIGliIGZtdCByZWFkZXJzKVxuICB8IExpdF9wYWRkaW5nIChMZWZ0LCBfKSwgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlLVxcXCJcIlxuICB8IExpdF9wYWRkaW5nICgoUmlnaHQgfCBaZXJvcyksIF8pLCBBcmdfcHJlY2lzaW9uIC0+XG4gICAgaW52YWxpZF9hcmcgXCJzY2FuZjogYmFkIGNvbnZlcnNpb24gXFxcIiUqXFxcIlwiXG4gIHwgQXJnX3BhZGRpbmcgXywgXyAtPlxuICAgIGludmFsaWRfYXJnIFwic2NhbmY6IGJhZCBjb252ZXJzaW9uIFxcXCIlKlxcXCJcIlxuICB8IE5vX3BhZGRpbmcsIEFyZ19wcmVjaXNpb24gLT5cbiAgICBpbnZhbGlkX2FyZyBcInNjYW5mOiBiYWQgY29udmVyc2lvbiBcXFwiJSpcXFwiXCJcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbiAgICAgICAgICAgICgqIERlZmluaW5nIFtzY2FuZl0gYW5kIHZhcmlvdXMgZmxhdm9ycyBvZiBbc2NhbmZdICopXG5cbnR5cGUgJ2Ega3NjYW5mX3Jlc3VsdCA9IEFyZ3Mgb2YgJ2EgfCBFeGMgb2YgZXhuXG5cbmxldCBrc2NhbmYgaWIgZWYgKEZvcm1hdCAoZm10LCBzdHIpKSA9XG4gIGxldCByZWMgYXBwbHkgOiB0eXBlIGEgYiAuIGEgLT4gKGEsIGIpIGhldGVyX2xpc3QgLT4gYiA9XG4gICAgZnVuIGYgYXJncyAtPiBtYXRjaCBhcmdzIHdpdGhcbiAgICB8IENvbnMgKHgsIHIpIC0+IGFwcGx5IChmIHgpIHJcbiAgICB8IE5pbCAtPiBmXG4gIGluXG4gIGxldCBrIHJlYWRlcnMgZiA9XG4gICAgU2Nhbm5pbmcucmVzZXRfdG9rZW4gaWI7XG4gICAgbWF0Y2ggdHJ5IEFyZ3MgKG1ha2Vfc2NhbmYgaWIgZm10IHJlYWRlcnMpIHdpdGhcbiAgICAgIHwgKFNjYW5fZmFpbHVyZSBfIHwgRmFpbHVyZSBfIHwgRW5kX29mX2ZpbGUpIGFzIGV4YyAtPiBFeGMgZXhjXG4gICAgICB8IEludmFsaWRfYXJndW1lbnQgbXNnIC0+XG4gICAgICAgIGludmFsaWRfYXJnIChtc2cgXiBcIiBpbiBmb3JtYXQgXFxcIlwiIF4gU3RyaW5nLmVzY2FwZWQgc3RyIF4gXCJcXFwiXCIpXG4gICAgd2l0aFxuICAgICAgfCBBcmdzIGFyZ3MgLT4gYXBwbHkgZiBhcmdzXG4gICAgICB8IEV4YyBleGMgLT4gZWYgaWIgZXhjXG4gIGluXG4gIHRha2VfZm9ybWF0X3JlYWRlcnMgayBmbXRcblxuKCoqKilcblxubGV0IGtic2NhbmYgPSBrc2NhbmZcbmxldCBic2NhbmYgaWIgZm10ID0ga2JzY2FuZiBpYiBzY2FuZl9iYWRfaW5wdXQgZm10XG5cbmxldCBrc3NjYW5mIHMgZWYgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZWYgZm10XG5sZXQgc3NjYW5mIHMgZm10ID0ga2JzY2FuZiAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgc2NhbmZfYmFkX2lucHV0IGZtdFxuXG5sZXQgc2NhbmYgZm10ID0ga3NjYW5mIFNjYW5uaW5nLnN0ZGliIHNjYW5mX2JhZF9pbnB1dCBmbXRcblxuKCoqKilcblxuKCogU2Nhbm5pbmcgZm9ybWF0IHN0cmluZ3MuICopXG5sZXQgYnNjYW5mX2Zvcm1hdCA6XG4gIFNjYW5uaW5nLmluX2NoYW5uZWwgLT4gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT5cbiAgKCgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2IC0+ICdnKSAtPiAnZyA9XG4gIGZ1biBpYiBmb3JtYXQgZiAtPlxuICAgIGxldCBfID0gc2Nhbl9jYW1sX3N0cmluZyBtYXhfaW50IGliIGluXG4gICAgbGV0IHN0ciA9IHRva2VuX3N0cmluZyBpYiBpblxuICAgIGxldCBmbXQnID1cbiAgICAgIHRyeSBmb3JtYXRfb2Zfc3RyaW5nX2Zvcm1hdCBzdHIgZm9ybWF0XG4gICAgICB3aXRoIEZhaWx1cmUgbXNnIC0+IGJhZF9pbnB1dCBtc2cgaW5cbiAgICBmIGZtdCdcblxuXG5sZXQgc3NjYW5mX2Zvcm1hdCA6XG4gIHN0cmluZyAtPiAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiAtPlxuICAoKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgLT4gJ2cpIC0+ICdnID1cbiAgZnVuIHMgZm9ybWF0IGYgLT4gYnNjYW5mX2Zvcm1hdCAoU2Nhbm5pbmcuZnJvbV9zdHJpbmcgcykgZm9ybWF0IGZcblxuXG5sZXQgZm9ybWF0X2Zyb21fc3RyaW5nIHMgZm10ID1cbiAgc3NjYW5mX2Zvcm1hdCAoXCJcXFwiXCIgXiBTdHJpbmcuZXNjYXBlZCBzIF4gXCJcXFwiXCIpIGZtdCAoZnVuIHggLT4geClcblxuXG5sZXQgdW5lc2NhcGVkIHMgPVxuICBzc2NhbmYgKFwiXFxcIlwiIF4gcyBeIFwiXFxcIlwiKSBcIiVTJSFcIiAoZnVuIHggLT4geClcblxuXG4oKiBEZXByZWNhdGVkICopXG5sZXQga2ZzY2FuZiBpYyBlZiBmbXQgPSBrYnNjYW5mIChTY2FubmluZy5tZW1vX2Zyb21fY2hhbm5lbCBpYykgZWYgZm10XG5sZXQgZnNjYW5mIGljIGZtdCA9IGtzY2FuZiAoU2Nhbm5pbmcubWVtb19mcm9tX2NoYW5uZWwgaWMpIHNjYW5mX2JhZF9pbnB1dCBmbXRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogUmVnaXN0ZXJpbmcgT0NhbWwgdmFsdWVzIHdpdGggdGhlIEMgcnVudGltZSBmb3IgbGF0ZXIgY2FsbGJhY2tzICopXG5cbmV4dGVybmFsIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIDogc3RyaW5nIC0+IE9iai50IC0+IHVuaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gXCJjYW1sX3JlZ2lzdGVyX25hbWVkX3ZhbHVlXCJcblxubGV0IHJlZ2lzdGVyIG5hbWUgdiA9XG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgKE9iai5yZXByIHYpXG5cbmxldCByZWdpc3Rlcl9leGNlcHRpb24gbmFtZSAoZXhuIDogZXhuKSA9XG4gIGxldCBleG4gPSBPYmoucmVwciBleG4gaW5cbiAgbGV0IHNsb3QgPSBpZiBPYmoudGFnIGV4biA9IE9iai5vYmplY3RfdGFnIHRoZW4gZXhuIGVsc2UgT2JqLmZpZWxkIGV4biAwIGluXG4gIHJlZ2lzdGVyX25hbWVkX3ZhbHVlIG5hbWUgc2xvdFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgSmVyb21lIFZvdWlsbG9uLCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAwMiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5vcGVuIE9ialxuXG4oKioqKiBPYmplY3QgcmVwcmVzZW50YXRpb24gKioqKilcblxuZXh0ZXJuYWwgc2V0X2lkOiAnYSAtPiAnYSA9IFwiY2FtbF9zZXRfb29faWRcIiBbQEBub2FsbG9jXVxuXG4oKioqKiBPYmplY3QgY29weSAqKioqKVxuXG5sZXQgY29weSBvID1cbiAgbGV0IG8gPSAoT2JqLm9iaiAoT2JqLmR1cCAoT2JqLnJlcHIgbykpKSBpblxuICBzZXRfaWQgb1xuXG4oKioqKiBDb21wcmVzc2lvbiBvcHRpb25zICoqKiopXG4oKiBQYXJhbWV0ZXJzICopXG50eXBlIHBhcmFtcyA9IHtcbiAgICBtdXRhYmxlIGNvbXBhY3RfdGFibGUgOiBib29sO1xuICAgIG11dGFibGUgY29weV9wYXJlbnQgOiBib29sO1xuICAgIG11dGFibGUgY2xlYW5fd2hlbl9jb3B5aW5nIDogYm9vbDtcbiAgICBtdXRhYmxlIHJldHJ5X2NvdW50IDogaW50O1xuICAgIG11dGFibGUgYnVja2V0X3NtYWxsX3NpemUgOiBpbnRcbiAgfVxuXG5sZXQgcGFyYW1zID0ge1xuICBjb21wYWN0X3RhYmxlID0gdHJ1ZTtcbiAgY29weV9wYXJlbnQgPSB0cnVlO1xuICBjbGVhbl93aGVuX2NvcHlpbmcgPSB0cnVlO1xuICByZXRyeV9jb3VudCA9IDM7XG4gIGJ1Y2tldF9zbWFsbF9zaXplID0gMTZcbn1cblxuKCoqKiogUGFyYW1ldGVycyAqKioqKVxuXG5sZXQgaW5pdGlhbF9vYmplY3Rfc2l6ZSA9IDJcblxuKCoqKiogSXRlbXMgKioqKilcblxudHlwZSBpdGVtID0gRHVtbXlBIHwgRHVtbXlCIHwgRHVtbXlDIG9mIGludFxubGV0IF8gPSBbRHVtbXlBOyBEdW1teUI7IER1bW15QyAwXSAoKiB0byBhdm9pZCB3YXJuaW5ncyAqKVxuXG5sZXQgZHVtbXlfaXRlbSA9IChtYWdpYyAoKSA6IGl0ZW0pXG5cbigqKioqIFR5cGVzICoqKiopXG5cbnR5cGUgdGFnXG50eXBlIGxhYmVsID0gaW50XG50eXBlIGNsb3N1cmUgPSBpdGVtXG50eXBlIHQgPSBEdW1teUEgfCBEdW1teUIgfCBEdW1teUMgb2YgaW50XG5sZXQgXyA9IFtEdW1teUE7IER1bW15QjsgRHVtbXlDIDBdICgqIHRvIGF2b2lkIHdhcm5pbmdzICopXG5cbnR5cGUgb2JqID0gdCBhcnJheVxuZXh0ZXJuYWwgcmV0IDogKG9iaiAtPiAnYSkgLT4gY2xvc3VyZSA9IFwiJWlkZW50aXR5XCJcblxuKCoqKiogTGFiZWxzICoqKiopXG5cbmxldCBwdWJsaWNfbWV0aG9kX2xhYmVsIHMgOiB0YWcgPVxuICBsZXQgYWNjdSA9IHJlZiAwIGluXG4gIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvXG4gICAgYWNjdSA6PSAyMjMgKiAhYWNjdSArIENoYXIuY29kZSBzLltpXVxuICBkb25lO1xuICAoKiByZWR1Y2UgdG8gMzEgYml0cyAqKVxuICBhY2N1IDo9ICFhY2N1IGxhbmQgKDEgbHNsIDMxIC0gMSk7XG4gICgqIG1ha2UgaXQgc2lnbmVkIGZvciA2NCBiaXRzIGFyY2hpdGVjdHVyZXMgKilcbiAgbGV0IHRhZyA9IGlmICFhY2N1ID4gMHgzRkZGRkZGRiB0aGVuICFhY2N1IC0gKDEgbHNsIDMxKSBlbHNlICFhY2N1IGluXG4gICgqIFByaW50Zi5lcHJpbnRmIFwiJXMgPSAlZFxcblwiIHMgdGFnOyBmbHVzaCBzdGRlcnI7ICopXG4gIG1hZ2ljIHRhZ1xuXG4oKioqKiBTcGFyc2UgYXJyYXkgKioqKilcblxubW9kdWxlIFZhcnMgPVxuICBNYXAuTWFrZShzdHJ1Y3QgdHlwZSB0ID0gc3RyaW5nIGxldCBjb21wYXJlICh4OnQpIHkgPSBjb21wYXJlIHggeSBlbmQpXG50eXBlIHZhcnMgPSBpbnQgVmFycy50XG5cbm1vZHVsZSBNZXRocyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBzdHJpbmcgbGV0IGNvbXBhcmUgKHg6dCkgeSA9IGNvbXBhcmUgeCB5IGVuZClcbnR5cGUgbWV0aHMgPSBsYWJlbCBNZXRocy50XG5tb2R1bGUgTGFicyA9XG4gIE1hcC5NYWtlKHN0cnVjdCB0eXBlIHQgPSBsYWJlbCBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxudHlwZSBsYWJzID0gYm9vbCBMYWJzLnRcblxuKCogVGhlIGNvbXBpbGVyIGFzc3VtZXMgdGhhdCB0aGUgZmlyc3QgZmllbGQgb2YgdGhpcyBzdHJ1Y3R1cmUgaXMgW3NpemVdLiAqKVxudHlwZSB0YWJsZSA9XG4geyBtdXRhYmxlIHNpemU6IGludDtcbiAgIG11dGFibGUgbWV0aG9kczogY2xvc3VyZSBhcnJheTtcbiAgIG11dGFibGUgbWV0aG9kc19ieV9uYW1lOiBtZXRocztcbiAgIG11dGFibGUgbWV0aG9kc19ieV9sYWJlbDogbGFicztcbiAgIG11dGFibGUgcHJldmlvdXNfc3RhdGVzOlxuICAgICAobWV0aHMgKiBsYWJzICogKGxhYmVsICogaXRlbSkgbGlzdCAqIHZhcnMgKlxuICAgICAgbGFiZWwgbGlzdCAqIHN0cmluZyBsaXN0KSBsaXN0O1xuICAgbXV0YWJsZSBoaWRkZW5fbWV0aHM6IChsYWJlbCAqIGl0ZW0pIGxpc3Q7XG4gICBtdXRhYmxlIHZhcnM6IHZhcnM7XG4gICBtdXRhYmxlIGluaXRpYWxpemVyczogKG9iaiAtPiB1bml0KSBsaXN0IH1cblxubGV0IGR1bW15X3RhYmxlID1cbiAgeyBtZXRob2RzID0gW3wgZHVtbXlfaXRlbSB8XTtcbiAgICBtZXRob2RzX2J5X25hbWUgPSBNZXRocy5lbXB0eTtcbiAgICBtZXRob2RzX2J5X2xhYmVsID0gTGFicy5lbXB0eTtcbiAgICBwcmV2aW91c19zdGF0ZXMgPSBbXTtcbiAgICBoaWRkZW5fbWV0aHMgPSBbXTtcbiAgICB2YXJzID0gVmFycy5lbXB0eTtcbiAgICBpbml0aWFsaXplcnMgPSBbXTtcbiAgICBzaXplID0gMCB9XG5cbmxldCB0YWJsZV9jb3VudCA9IHJlZiAwXG5cbigqIGR1bW15X21ldCBzaG91bGQgYmUgYSBwb2ludGVyLCBzbyB1c2UgYW4gYXRvbSAqKVxubGV0IGR1bW15X21ldCA6IGl0ZW0gPSBvYmogKE9iai5uZXdfYmxvY2sgMCAwKVxuKCogaWYgZGVidWdnaW5nIGlzIG5lZWRlZCwgdGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYTogKilcbigqIGxldCBkdW1teV9tZXQgKCkgPSBmYWlsd2l0aCBcIlVuZGVmaW5lZCBtZXRob2RcIiAqKVxuXG5sZXQgcmVjIGZpdF9zaXplIG4gPVxuICBpZiBuIDw9IDIgdGhlbiBuIGVsc2VcbiAgZml0X3NpemUgKChuKzEpLzIpICogMlxuXG5sZXQgbmV3X3RhYmxlIHB1Yl9sYWJlbHMgPVxuICBpbmNyIHRhYmxlX2NvdW50O1xuICBsZXQgbGVuID0gQXJyYXkubGVuZ3RoIHB1Yl9sYWJlbHMgaW5cbiAgbGV0IG1ldGhvZHMgPSBBcnJheS5tYWtlIChsZW4qMisyKSBkdW1teV9tZXQgaW5cbiAgbWV0aG9kcy4oMCkgPC0gbWFnaWMgbGVuO1xuICBtZXRob2RzLigxKSA8LSBtYWdpYyAoZml0X3NpemUgbGVuICogU3lzLndvcmRfc2l6ZSAvIDggLSAxKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG8gbWV0aG9kcy4oaSoyKzMpIDwtIG1hZ2ljIHB1Yl9sYWJlbHMuKGkpIGRvbmU7XG4gIHsgbWV0aG9kcyA9IG1ldGhvZHM7XG4gICAgbWV0aG9kc19ieV9uYW1lID0gTWV0aHMuZW1wdHk7XG4gICAgbWV0aG9kc19ieV9sYWJlbCA9IExhYnMuZW1wdHk7XG4gICAgcHJldmlvdXNfc3RhdGVzID0gW107XG4gICAgaGlkZGVuX21ldGhzID0gW107XG4gICAgdmFycyA9IFZhcnMuZW1wdHk7XG4gICAgaW5pdGlhbGl6ZXJzID0gW107XG4gICAgc2l6ZSA9IGluaXRpYWxfb2JqZWN0X3NpemUgfVxuXG5sZXQgcmVzaXplIGFycmF5IG5ld19zaXplID1cbiAgbGV0IG9sZF9zaXplID0gQXJyYXkubGVuZ3RoIGFycmF5Lm1ldGhvZHMgaW5cbiAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuIGJlZ2luXG4gICAgbGV0IG5ld19idWNrID0gQXJyYXkubWFrZSBuZXdfc2l6ZSBkdW1teV9tZXQgaW5cbiAgICBBcnJheS5ibGl0IGFycmF5Lm1ldGhvZHMgMCBuZXdfYnVjayAwIG9sZF9zaXplO1xuICAgIGFycmF5Lm1ldGhvZHMgPC0gbmV3X2J1Y2tcbiBlbmRcblxubGV0IHB1dCBhcnJheSBsYWJlbCBlbGVtZW50ID1cbiAgcmVzaXplIGFycmF5IChsYWJlbCArIDEpO1xuICBhcnJheS5tZXRob2RzLihsYWJlbCkgPC0gZWxlbWVudFxuXG4oKioqKiBDbGFzc2VzICoqKiopXG5cbmxldCBtZXRob2RfY291bnQgPSByZWYgMFxubGV0IGluc3RfdmFyX2NvdW50ID0gcmVmIDBcblxuKCogdHlwZSB0ICopXG50eXBlIG1ldGggPSBpdGVtXG5cbmxldCBuZXdfbWV0aG9kIHRhYmxlID1cbiAgbGV0IGluZGV4ID0gQXJyYXkubGVuZ3RoIHRhYmxlLm1ldGhvZHMgaW5cbiAgcmVzaXplIHRhYmxlIChpbmRleCArIDEpO1xuICBpbmRleFxuXG5sZXQgZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBuYW1lID1cbiAgdHJ5XG4gICAgTWV0aHMuZmluZCBuYW1lIHRhYmxlLm1ldGhvZHNfYnlfbmFtZVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBsYWJlbCA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgPC0gTWV0aHMuYWRkIG5hbWUgbGFiZWwgdGFibGUubWV0aG9kc19ieV9uYW1lO1xuICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiZWwgdHJ1ZSB0YWJsZS5tZXRob2RzX2J5X2xhYmVsO1xuICAgIGxhYmVsXG5cbmxldCBnZXRfbWV0aG9kX2xhYmVscyB0YWJsZSBuYW1lcyA9XG4gIEFycmF5Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgbmFtZXNcblxubGV0IHNldF9tZXRob2QgdGFibGUgbGFiZWwgZWxlbWVudCA9XG4gIGluY3IgbWV0aG9kX2NvdW50O1xuICBpZiBMYWJzLmZpbmQgbGFiZWwgdGFibGUubWV0aG9kc19ieV9sYWJlbCB0aGVuXG4gICAgcHV0IHRhYmxlIGxhYmVsIGVsZW1lbnRcbiAgZWxzZVxuICAgIHRhYmxlLmhpZGRlbl9tZXRocyA8LSAobGFiZWwsIGVsZW1lbnQpIDo6IHRhYmxlLmhpZGRlbl9tZXRoc1xuXG5sZXQgZ2V0X21ldGhvZCB0YWJsZSBsYWJlbCA9XG4gIHRyeSBMaXN0LmFzc29jIGxhYmVsIHRhYmxlLmhpZGRlbl9tZXRoc1xuICB3aXRoIE5vdF9mb3VuZCAtPiB0YWJsZS5tZXRob2RzLihsYWJlbClcblxubGV0IHRvX2xpc3QgYXJyID1cbiAgaWYgYXJyID09IG1hZ2ljIDAgdGhlbiBbXSBlbHNlIEFycmF5LnRvX2xpc3QgYXJyXG5cbmxldCBuYXJyb3cgdGFibGUgdmFycyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzID1cbiAgbGV0IHZhcnMgPSB0b19saXN0IHZhcnNcbiAgYW5kIHZpcnRfbWV0aHMgPSB0b19saXN0IHZpcnRfbWV0aHNcbiAgYW5kIGNvbmNyX21ldGhzID0gdG9fbGlzdCBjb25jcl9tZXRocyBpblxuICBsZXQgdmlydF9tZXRoX2xhYnMgPSBMaXN0Lm1hcCAoZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSkgdmlydF9tZXRocyBpblxuICBsZXQgY29uY3JfbWV0aF9sYWJzID0gTGlzdC5tYXAgKGdldF9tZXRob2RfbGFiZWwgdGFibGUpIGNvbmNyX21ldGhzIGluXG4gIHRhYmxlLnByZXZpb3VzX3N0YXRlcyA8LVxuICAgICAodGFibGUubWV0aG9kc19ieV9uYW1lLCB0YWJsZS5tZXRob2RzX2J5X2xhYmVsLCB0YWJsZS5oaWRkZW5fbWV0aHMsXG4gICAgICB0YWJsZS52YXJzLCB2aXJ0X21ldGhfbGFicywgdmFycylcbiAgICAgOjogdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgVmFycy5mb2xkXG4gICAgICAoZnVuIGxhYiBpbmZvIHR2YXJzIC0+XG4gICAgICAgIGlmIExpc3QubWVtIGxhYiB2YXJzIHRoZW4gVmFycy5hZGQgbGFiIGluZm8gdHZhcnMgZWxzZSB0dmFycylcbiAgICAgIHRhYmxlLnZhcnMgVmFycy5lbXB0eTtcbiAgbGV0IGJ5X25hbWUgPSByZWYgTWV0aHMuZW1wdHkgaW5cbiAgbGV0IGJ5X2xhYmVsID0gcmVmIExhYnMuZW1wdHkgaW5cbiAgTGlzdC5pdGVyMlxuICAgIChmdW4gbWV0IGxhYmVsIC0+XG4gICAgICAgYnlfbmFtZSA6PSBNZXRocy5hZGQgbWV0IGxhYmVsICFieV9uYW1lO1xuICAgICAgIGJ5X2xhYmVsIDo9XG4gICAgICAgICAgTGFicy5hZGQgbGFiZWxcbiAgICAgICAgICAgICh0cnkgTGFicy5maW5kIGxhYmVsIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgd2l0aCBOb3RfZm91bmQgLT4gdHJ1ZSlcbiAgICAgICAgICAgICFieV9sYWJlbClcbiAgICBjb25jcl9tZXRocyBjb25jcl9tZXRoX2xhYnM7XG4gIExpc3QuaXRlcjJcbiAgICAoZnVuIG1ldCBsYWJlbCAtPlxuICAgICAgIGJ5X25hbWUgOj0gTWV0aHMuYWRkIG1ldCBsYWJlbCAhYnlfbmFtZTtcbiAgICAgICBieV9sYWJlbCA6PSBMYWJzLmFkZCBsYWJlbCBmYWxzZSAhYnlfbGFiZWwpXG4gICAgdmlydF9tZXRocyB2aXJ0X21ldGhfbGFicztcbiAgdGFibGUubWV0aG9kc19ieV9uYW1lIDwtICFieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtICFieV9sYWJlbDtcbiAgdGFibGUuaGlkZGVuX21ldGhzIDwtXG4gICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgIChmdW4gKChsYWIsIF8pIGFzIG1ldCkgaG0gLT5cbiAgICAgICAgICBpZiBMaXN0Lm1lbSBsYWIgdmlydF9tZXRoX2xhYnMgdGhlbiBobSBlbHNlIG1ldDo6aG0pXG4gICAgICAgdGFibGUuaGlkZGVuX21ldGhzXG4gICAgICAgW11cblxubGV0IHdpZGVuIHRhYmxlID1cbiAgbGV0IChieV9uYW1lLCBieV9sYWJlbCwgc2F2ZWRfaGlkZGVuX21ldGhzLCBzYXZlZF92YXJzLCB2aXJ0X21ldGhzLCB2YXJzKSA9XG4gICAgTGlzdC5oZCB0YWJsZS5wcmV2aW91c19zdGF0ZXNcbiAgaW5cbiAgdGFibGUucHJldmlvdXNfc3RhdGVzIDwtIExpc3QudGwgdGFibGUucHJldmlvdXNfc3RhdGVzO1xuICB0YWJsZS52YXJzIDwtXG4gICAgIExpc3QuZm9sZF9sZWZ0XG4gICAgICAgKGZ1biBzIHYgLT4gVmFycy5hZGQgdiAoVmFycy5maW5kIHYgdGFibGUudmFycykgcylcbiAgICAgICBzYXZlZF92YXJzIHZhcnM7XG4gIHRhYmxlLm1ldGhvZHNfYnlfbmFtZSA8LSBieV9uYW1lO1xuICB0YWJsZS5tZXRob2RzX2J5X2xhYmVsIDwtIGJ5X2xhYmVsO1xuICB0YWJsZS5oaWRkZW5fbWV0aHMgPC1cbiAgICAgTGlzdC5mb2xkX3JpZ2h0XG4gICAgICAgKGZ1biAoKGxhYiwgXykgYXMgbWV0KSBobSAtPlxuICAgICAgICAgIGlmIExpc3QubWVtIGxhYiB2aXJ0X21ldGhzIHRoZW4gaG0gZWxzZSBtZXQ6OmhtKVxuICAgICAgIHRhYmxlLmhpZGRlbl9tZXRoc1xuICAgICAgIHNhdmVkX2hpZGRlbl9tZXRoc1xuXG5sZXQgbmV3X3Nsb3QgdGFibGUgPVxuICBsZXQgaW5kZXggPSB0YWJsZS5zaXplIGluXG4gIHRhYmxlLnNpemUgPC0gaW5kZXggKyAxO1xuICBpbmRleFxuXG5sZXQgbmV3X3ZhcmlhYmxlIHRhYmxlIG5hbWUgPVxuICB0cnkgVmFycy5maW5kIG5hbWUgdGFibGUudmFyc1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBpbmRleCA9IG5ld19zbG90IHRhYmxlIGluXG4gICAgaWYgbmFtZSA8PiBcIlwiIHRoZW4gdGFibGUudmFycyA8LSBWYXJzLmFkZCBuYW1lIGluZGV4IHRhYmxlLnZhcnM7XG4gICAgaW5kZXhcblxubGV0IHRvX2FycmF5IGFyciA9XG4gIGlmIGFyciA9IE9iai5tYWdpYyAwIHRoZW4gW3x8XSBlbHNlIGFyclxuXG5sZXQgbmV3X21ldGhvZHNfdmFyaWFibGVzIHRhYmxlIG1ldGhzIHZhbHMgPVxuICBsZXQgbWV0aHMgPSB0b19hcnJheSBtZXRocyBpblxuICBsZXQgbm1ldGhzID0gQXJyYXkubGVuZ3RoIG1ldGhzIGFuZCBudmFscyA9IEFycmF5Lmxlbmd0aCB2YWxzIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChubWV0aHMgKyBudmFscykgMCBpblxuICBmb3IgaSA9IDAgdG8gbm1ldGhzIC0gMSBkb1xuICAgIHJlcy4oaSkgPC0gZ2V0X21ldGhvZF9sYWJlbCB0YWJsZSBtZXRocy4oaSlcbiAgZG9uZTtcbiAgZm9yIGkgPSAwIHRvIG52YWxzIC0gMSBkb1xuICAgIHJlcy4oaStubWV0aHMpIDwtIG5ld192YXJpYWJsZSB0YWJsZSB2YWxzLihpKVxuICBkb25lO1xuICByZXNcblxubGV0IGdldF92YXJpYWJsZSB0YWJsZSBuYW1lID1cbiAgdHJ5IFZhcnMuZmluZCBuYW1lIHRhYmxlLnZhcnMgd2l0aCBOb3RfZm91bmQgLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBnZXRfdmFyaWFibGVzIHRhYmxlIG5hbWVzID1cbiAgQXJyYXkubWFwIChnZXRfdmFyaWFibGUgdGFibGUpIG5hbWVzXG5cbmxldCBhZGRfaW5pdGlhbGl6ZXIgdGFibGUgZiA9XG4gIHRhYmxlLmluaXRpYWxpemVycyA8LSBmOjp0YWJsZS5pbml0aWFsaXplcnNcblxuKCpcbm1vZHVsZSBLZXlzID1cbiAgTWFwLk1ha2Uoc3RydWN0IHR5cGUgdCA9IHRhZyBhcnJheSBsZXQgY29tcGFyZSAoeDp0KSB5ID0gY29tcGFyZSB4IHkgZW5kKVxubGV0IGtleV9tYXAgPSByZWYgS2V5cy5lbXB0eVxubGV0IGdldF9rZXkgdGFncyA6IGl0ZW0gPVxuICB0cnkgbWFnaWMgKEtleXMuZmluZCB0YWdzICFrZXlfbWFwIDogdGFnIGFycmF5KVxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGtleV9tYXAgOj0gS2V5cy5hZGQgdGFncyB0YWdzICFrZXlfbWFwO1xuICAgIG1hZ2ljIHRhZ3NcbiopXG5cbmxldCBjcmVhdGVfdGFibGUgcHVibGljX21ldGhvZHMgPVxuICBpZiBwdWJsaWNfbWV0aG9kcyA9PSBtYWdpYyAwIHRoZW4gbmV3X3RhYmxlIFt8fF0gZWxzZVxuICAoKiBbcHVibGljX21ldGhvZHNdIG11c3QgYmUgaW4gYXNjZW5kaW5nIG9yZGVyIGZvciBieXRlY29kZSAqKVxuICBsZXQgdGFncyA9IEFycmF5Lm1hcCBwdWJsaWNfbWV0aG9kX2xhYmVsIHB1YmxpY19tZXRob2RzIGluXG4gIGxldCB0YWJsZSA9IG5ld190YWJsZSB0YWdzIGluXG4gIEFycmF5Lml0ZXJpXG4gICAgKGZ1biBpIG1ldCAtPlxuICAgICAgbGV0IGxhYiA9IGkqMisyIGluXG4gICAgICB0YWJsZS5tZXRob2RzX2J5X25hbWUgIDwtIE1ldGhzLmFkZCBtZXQgbGFiIHRhYmxlLm1ldGhvZHNfYnlfbmFtZTtcbiAgICAgIHRhYmxlLm1ldGhvZHNfYnlfbGFiZWwgPC0gTGFicy5hZGQgbGFiIHRydWUgdGFibGUubWV0aG9kc19ieV9sYWJlbClcbiAgICBwdWJsaWNfbWV0aG9kcztcbiAgdGFibGVcblxubGV0IGluaXRfY2xhc3MgdGFibGUgPVxuICBpbnN0X3Zhcl9jb3VudCA6PSAhaW5zdF92YXJfY291bnQgKyB0YWJsZS5zaXplIC0gMTtcbiAgdGFibGUuaW5pdGlhbGl6ZXJzIDwtIExpc3QucmV2IHRhYmxlLmluaXRpYWxpemVycztcbiAgcmVzaXplIHRhYmxlICgzICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemUpXG5cbmxldCBpbmhlcml0cyBjbGEgdmFscyB2aXJ0X21ldGhzIGNvbmNyX21ldGhzIChfLCBzdXBlciwgXywgZW52KSB0b3AgPVxuICBuYXJyb3cgY2xhIHZhbHMgdmlydF9tZXRocyBjb25jcl9tZXRocztcbiAgbGV0IGluaXQgPVxuICAgIGlmIHRvcCB0aGVuIHN1cGVyIGNsYSBlbnYgZWxzZSBPYmoucmVwciAoc3VwZXIgY2xhKSBpblxuICB3aWRlbiBjbGE7XG4gIEFycmF5LmNvbmNhdFxuICAgIFtbfCByZXByIGluaXQgfF07XG4gICAgIG1hZ2ljIChBcnJheS5tYXAgKGdldF92YXJpYWJsZSBjbGEpICh0b19hcnJheSB2YWxzKSA6IGludCBhcnJheSk7XG4gICAgIEFycmF5Lm1hcFxuICAgICAgIChmdW4gbm0gLT4gcmVwciAoZ2V0X21ldGhvZCBjbGEgKGdldF9tZXRob2RfbGFiZWwgY2xhIG5tKSA6IGNsb3N1cmUpKVxuICAgICAgICh0b19hcnJheSBjb25jcl9tZXRocykgXVxuXG5sZXQgbWFrZV9jbGFzcyBwdWJfbWV0aHMgY2xhc3NfaW5pdCA9XG4gIGxldCB0YWJsZSA9IGNyZWF0ZV90YWJsZSBwdWJfbWV0aHMgaW5cbiAgbGV0IGVudl9pbml0ID0gY2xhc3NfaW5pdCB0YWJsZSBpblxuICBpbml0X2NsYXNzIHRhYmxlO1xuICAoZW52X2luaXQgKE9iai5yZXByIDApLCBjbGFzc19pbml0LCBlbnZfaW5pdCwgT2JqLnJlcHIgMClcblxudHlwZSBpbml0X3RhYmxlID0geyBtdXRhYmxlIGVudl9pbml0OiB0OyBtdXRhYmxlIGNsYXNzX2luaXQ6IHRhYmxlIC0+IHQgfVxuXG5sZXQgbWFrZV9jbGFzc19zdG9yZSBwdWJfbWV0aHMgY2xhc3NfaW5pdCBpbml0X3RhYmxlID1cbiAgbGV0IHRhYmxlID0gY3JlYXRlX3RhYmxlIHB1Yl9tZXRocyBpblxuICBsZXQgZW52X2luaXQgPSBjbGFzc19pbml0IHRhYmxlIGluXG4gIGluaXRfY2xhc3MgdGFibGU7XG4gIGluaXRfdGFibGUuY2xhc3NfaW5pdCA8LSBjbGFzc19pbml0O1xuICBpbml0X3RhYmxlLmVudl9pbml0IDwtIGVudl9pbml0XG5cbmxldCBkdW1teV9jbGFzcyBsb2MgPVxuICBsZXQgdW5kZWYgPSBmdW4gXyAtPiByYWlzZSAoVW5kZWZpbmVkX3JlY3Vyc2l2ZV9tb2R1bGUgbG9jKSBpblxuICAoT2JqLm1hZ2ljIHVuZGVmLCB1bmRlZiwgdW5kZWYsIE9iai5yZXByIDApXG5cbigqKioqIE9iamVjdHMgKioqKilcblxubGV0IGNyZWF0ZV9vYmplY3QgdGFibGUgPVxuICAoKiBYWFggQXBwZWwgZGUgW29ial9ibG9ja10gfCBDYWxsIHRvIFtvYmpfYmxvY2tdICAqKVxuICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICgqIFhYWCBBcHBlbCBkZSBbY2FtbF9tb2RpZnldIHwgQ2FsbCB0byBbY2FtbF9tb2RpZnldICopXG4gIE9iai5zZXRfZmllbGQgb2JqIDAgKE9iai5yZXByIHRhYmxlLm1ldGhvZHMpO1xuICBPYmoub2JqIChzZXRfaWQgb2JqKVxuXG5sZXQgY3JlYXRlX29iamVjdF9vcHQgb2JqXzAgdGFibGUgPVxuICBpZiAoT2JqLm1hZ2ljIG9ial8wIDogYm9vbCkgdGhlbiBvYmpfMCBlbHNlIGJlZ2luXG4gICAgKCogWFhYIEFwcGVsIGRlIFtvYmpfYmxvY2tdIHwgQ2FsbCB0byBbb2JqX2Jsb2NrXSAgKilcbiAgICBsZXQgb2JqID0gT2JqLm5ld19ibG9jayBPYmoub2JqZWN0X3RhZyB0YWJsZS5zaXplIGluXG4gICAgKCogWFhYIEFwcGVsIGRlIFtjYW1sX21vZGlmeV0gfCBDYWxsIHRvIFtjYW1sX21vZGlmeV0gKilcbiAgICBPYmouc2V0X2ZpZWxkIG9iaiAwIChPYmoucmVwciB0YWJsZS5tZXRob2RzKTtcbiAgICBPYmoub2JqIChzZXRfaWQgb2JqKVxuICBlbmRcblxubGV0IHJlYyBpdGVyX2Ygb2JqID1cbiAgZnVuY3Rpb25cbiAgICBbXSAgIC0+ICgpXG4gIHwgZjo6bCAtPiBmIG9iajsgaXRlcl9mIG9iaiBsXG5cbmxldCBydW5faW5pdGlhbGl6ZXJzIG9iaiB0YWJsZSA9XG4gIGxldCBpbml0cyA9IHRhYmxlLmluaXRpYWxpemVycyBpblxuICBpZiBpbml0cyA8PiBbXSB0aGVuXG4gICAgaXRlcl9mIG9iaiBpbml0c1xuXG5sZXQgcnVuX2luaXRpYWxpemVyc19vcHQgb2JqXzAgb2JqIHRhYmxlID1cbiAgaWYgKE9iai5tYWdpYyBvYmpfMCA6IGJvb2wpIHRoZW4gb2JqIGVsc2UgYmVnaW5cbiAgICBsZXQgaW5pdHMgPSB0YWJsZS5pbml0aWFsaXplcnMgaW5cbiAgICBpZiBpbml0cyA8PiBbXSB0aGVuIGl0ZXJfZiBvYmogaW5pdHM7XG4gICAgb2JqXG4gIGVuZFxuXG5sZXQgY3JlYXRlX29iamVjdF9hbmRfcnVuX2luaXRpYWxpemVycyBvYmpfMCB0YWJsZSA9XG4gIGlmIChPYmoubWFnaWMgb2JqXzAgOiBib29sKSB0aGVuIG9ial8wIGVsc2UgYmVnaW5cbiAgICBsZXQgb2JqID0gY3JlYXRlX29iamVjdCB0YWJsZSBpblxuICAgIHJ1bl9pbml0aWFsaXplcnMgb2JqIHRhYmxlO1xuICAgIG9ialxuICBlbmRcblxuKCogRXF1aXZhbGVudCBwcmltaXRpdmUgYmVsb3dcbmxldCBzZW5kc2VsZiBvYmogbGFiID1cbiAgKG1hZ2ljIG9iaiA6IChvYmogLT4gdCkgYXJyYXkgYXJyYXkpLigwKS4obGFiKSBvYmpcbiopXG5leHRlcm5hbCBzZW5kIDogb2JqIC0+IHRhZyAtPiAnYSA9IFwiJXNlbmRcIlxuZXh0ZXJuYWwgc2VuZGNhY2hlIDogb2JqIC0+IHRhZyAtPiB0IC0+IGludCAtPiAnYSA9IFwiJXNlbmRjYWNoZVwiXG5leHRlcm5hbCBzZW5kc2VsZiA6IG9iaiAtPiBsYWJlbCAtPiAnYSA9IFwiJXNlbmRzZWxmXCJcbmV4dGVybmFsIGdldF9wdWJsaWNfbWV0aG9kIDogb2JqIC0+IHRhZyAtPiBjbG9zdXJlXG4gICAgPSBcImNhbWxfZ2V0X3B1YmxpY19tZXRob2RcIiBbQEBub2FsbG9jXVxuXG4oKioqKiB0YWJsZSBjb2xsZWN0aW9uIGFjY2VzcyAqKioqKVxuXG50eXBlIHRhYmxlcyA9XG4gIHwgRW1wdHlcbiAgfCBDb25zIG9mIHtrZXkgOiBjbG9zdXJlOyBtdXRhYmxlIGRhdGE6IHRhYmxlczsgbXV0YWJsZSBuZXh0OiB0YWJsZXN9XG5cbmxldCBzZXRfZGF0YSB0YWJsZXMgdiA9IG1hdGNoIHRhYmxlcyB3aXRoXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmRhdGEgPC0gdlxubGV0IHNldF9uZXh0IHRhYmxlcyB2ID0gbWF0Y2ggdGFibGVzIHdpdGhcbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dCA8LSB2XG5sZXQgZ2V0X2tleSA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gIHwgQ29ucyB0YWJsZXMgLT4gdGFibGVzLmtleVxubGV0IGdldF9kYXRhID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMuZGF0YVxubGV0IGdldF9uZXh0ID0gZnVuY3Rpb25cbiAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgfCBDb25zIHRhYmxlcyAtPiB0YWJsZXMubmV4dFxuXG5sZXQgYnVpbGRfcGF0aCBuIGtleXMgdGFibGVzID1cbiAgbGV0IHJlcyA9IENvbnMge2tleSA9IE9iai5tYWdpYyAwOyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgbGV0IHIgPSByZWYgcmVzIGluXG4gIGZvciBpID0gMCB0byBuIGRvXG4gICAgciA6PSBDb25zIHtrZXkgPSBrZXlzLihpKTsgZGF0YSA9ICFyOyBuZXh0ID0gRW1wdHl9XG4gIGRvbmU7XG4gIHNldF9kYXRhIHRhYmxlcyAhcjtcbiAgcmVzXG5cbmxldCByZWMgbG9va3VwX2tleXMgaSBrZXlzIHRhYmxlcyA9XG4gIGlmIGkgPCAwIHRoZW4gdGFibGVzIGVsc2VcbiAgbGV0IGtleSA9IGtleXMuKGkpIGluXG4gIGxldCByZWMgbG9va3VwX2tleSAodGFibGVzOnRhYmxlcykgPVxuICAgIGlmIGdldF9rZXkgdGFibGVzID09IGtleSB0aGVuXG4gICAgICBtYXRjaCBnZXRfZGF0YSB0YWJsZXMgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgQ29ucyBfIGFzIHRhYmxlc19kYXRhIC0+XG4gICAgICAgICAgbG9va3VwX2tleXMgKGktMSkga2V5cyB0YWJsZXNfZGF0YVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIGdldF9uZXh0IHRhYmxlcyB3aXRoXG4gICAgICB8IENvbnMgXyBhcyBuZXh0IC0+IGxvb2t1cF9rZXkgbmV4dFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGxldCBuZXh0IDogdGFibGVzID0gQ29ucyB7a2V5OyBkYXRhID0gRW1wdHk7IG5leHQgPSBFbXB0eX0gaW5cbiAgICAgICAgICBzZXRfbmV4dCB0YWJsZXMgbmV4dDtcbiAgICAgICAgICBidWlsZF9wYXRoIChpLTEpIGtleXMgbmV4dFxuICBpblxuICBsb29rdXBfa2V5IHRhYmxlc1xuXG5sZXQgbG9va3VwX3RhYmxlcyByb290IGtleXMgPVxuICBtYXRjaCBnZXRfZGF0YSByb290IHdpdGhcbiAgfCBDb25zIF8gYXMgcm9vdF9kYXRhIC0+XG4gICAgbG9va3VwX2tleXMgKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290X2RhdGFcbiAgfCBFbXB0eSAtPlxuICAgIGJ1aWxkX3BhdGggKEFycmF5Lmxlbmd0aCBrZXlzIC0gMSkga2V5cyByb290XG5cbigqKioqIGJ1aWx0aW4gbWV0aG9kcyAqKioqKVxuXG5sZXQgZ2V0X2NvbnN0IHggPSByZXQgKGZ1biBfb2JqIC0+IHgpXG5sZXQgZ2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogLT4gQXJyYXkudW5zYWZlX2dldCBvYmogbilcbmxldCBnZXRfZW52IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pXG5sZXQgZ2V0X21ldGggbiAgPSByZXQgKGZ1biBvYmogLT4gc2VuZHNlbGYgb2JqIG4pXG5sZXQgc2V0X3ZhciBuICAgPSByZXQgKGZ1biBvYmogeCAtPiBBcnJheS51bnNhZmVfc2V0IG9iaiBuIHgpXG5sZXQgYXBwX2NvbnN0IGYgeCA9IHJldCAoZnVuIF9vYmogLT4gZiB4KVxubGV0IGFwcF92YXIgZiBuICAgPSByZXQgKGZ1biBvYmogLT4gZiAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2VudiBmIGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgKEFycmF5LnVuc2FmZV9nZXQgKE9iai5tYWdpYyAoQXJyYXkudW5zYWZlX2dldCBvYmogZSkgOiBvYmopIG4pKVxubGV0IGFwcF9tZXRoIGYgbiAgPSByZXQgKGZ1biBvYmogLT4gZiAoc2VuZHNlbGYgb2JqIG4pKVxubGV0IGFwcF9jb25zdF9jb25zdCBmIHggeSA9IHJldCAoZnVuIF9vYmogLT4gZiB4IHkpXG5sZXQgYXBwX2NvbnN0X3ZhciBmIHggbiAgID0gcmV0IChmdW4gb2JqIC0+IGYgeCAoQXJyYXkudW5zYWZlX2dldCBvYmogbikpXG5sZXQgYXBwX2NvbnN0X21ldGggZiB4IG4gPSByZXQgKGZ1biBvYmogLT4gZiB4IChzZW5kc2VsZiBvYmogbikpXG5sZXQgYXBwX3Zhcl9jb25zdCBmIG4geCA9IHJldCAoZnVuIG9iaiAtPiBmIChBcnJheS51bnNhZmVfZ2V0IG9iaiBuKSB4KVxubGV0IGFwcF9tZXRoX2NvbnN0IGYgbiB4ID0gcmV0IChmdW4gb2JqIC0+IGYgKHNlbmRzZWxmIG9iaiBuKSB4KVxubGV0IGFwcF9jb25zdF9lbnYgZiB4IGUgbiA9XG4gIHJldCAoZnVuIG9iaiAtPlxuICAgIGYgeCAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikpXG5sZXQgYXBwX2Vudl9jb25zdCBmIGUgbiB4ID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgZiAoQXJyYXkudW5zYWZlX2dldCAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0IG9iaiBlKSA6IG9iaikgbikgeClcbmxldCBtZXRoX2FwcF9jb25zdCBuIHggPSByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSB4KVxubGV0IG1ldGhfYXBwX3ZhciBuIG0gPVxuICByZXQgKGZ1biBvYmogLT4gKHNlbmRzZWxmIG9iaiBuIDogXyAtPiBfKSAoQXJyYXkudW5zYWZlX2dldCBvYmogbSkpXG5sZXQgbWV0aF9hcHBfZW52IG4gZSBtID1cbiAgcmV0IChmdW4gb2JqIC0+IChzZW5kc2VsZiBvYmogbiA6IF8gLT4gXylcbiAgICAgIChBcnJheS51bnNhZmVfZ2V0IChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBtKSlcbmxldCBtZXRoX2FwcF9tZXRoIG4gbSA9XG4gIHJldCAoZnVuIG9iaiAtPiAoc2VuZHNlbGYgb2JqIG4gOiBfIC0+IF8pIChzZW5kc2VsZiBvYmogbSkpXG5sZXQgc2VuZF9jb25zdCBtIHggYyA9XG4gIHJldCAoZnVuIG9iaiAtPiBzZW5kY2FjaGUgeCBtIChBcnJheS51bnNhZmVfZ2V0IG9iaiAwKSBjKVxubGV0IHNlbmRfdmFyIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIG4pIDogb2JqKSBtXG4gICAgICAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBzZW5kX2VudiBtIGUgbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlXG4gICAgICAoT2JqLm1hZ2ljIChBcnJheS51bnNhZmVfZ2V0XG4gICAgICAgICAgICAgICAgICAgIChPYmoubWFnaWMgKEFycmF5LnVuc2FmZV9nZXQgb2JqIGUpIDogb2JqKSBuKSA6IG9iailcbiAgICAgIG0gKEFycmF5LnVuc2FmZV9nZXQgb2JqIDApIGMpXG5sZXQgc2VuZF9tZXRoIG0gbiBjID1cbiAgcmV0IChmdW4gb2JqIC0+XG4gICAgc2VuZGNhY2hlIChzZW5kc2VsZiBvYmogbikgbSAoQXJyYXkudW5zYWZlX2dldCBvYmogMCkgYylcbmxldCBuZXdfY2FjaGUgdGFibGUgPVxuICBsZXQgbiA9IG5ld19tZXRob2QgdGFibGUgaW5cbiAgbGV0IG4gPVxuICAgIGlmIG4gbW9kIDIgPSAwIHx8IG4gPiAyICsgbWFnaWMgdGFibGUubWV0aG9kcy4oMSkgKiAxNiAvIFN5cy53b3JkX3NpemVcbiAgICB0aGVuIG4gZWxzZSBuZXdfbWV0aG9kIHRhYmxlXG4gIGluXG4gIHRhYmxlLm1ldGhvZHMuKG4pIDwtIE9iai5tYWdpYyAwO1xuICBuXG5cbnR5cGUgaW1wbCA9XG4gICAgR2V0Q29uc3RcbiAgfCBHZXRWYXJcbiAgfCBHZXRFbnZcbiAgfCBHZXRNZXRoXG4gIHwgU2V0VmFyXG4gIHwgQXBwQ29uc3RcbiAgfCBBcHBWYXJcbiAgfCBBcHBFbnZcbiAgfCBBcHBNZXRoXG4gIHwgQXBwQ29uc3RDb25zdFxuICB8IEFwcENvbnN0VmFyXG4gIHwgQXBwQ29uc3RFbnZcbiAgfCBBcHBDb25zdE1ldGhcbiAgfCBBcHBWYXJDb25zdFxuICB8IEFwcEVudkNvbnN0XG4gIHwgQXBwTWV0aENvbnN0XG4gIHwgTWV0aEFwcENvbnN0XG4gIHwgTWV0aEFwcFZhclxuICB8IE1ldGhBcHBFbnZcbiAgfCBNZXRoQXBwTWV0aFxuICB8IFNlbmRDb25zdFxuICB8IFNlbmRWYXJcbiAgfCBTZW5kRW52XG4gIHwgU2VuZE1ldGhcbiAgfCBDbG9zdXJlIG9mIGNsb3N1cmVcblxubGV0IG1ldGhvZF9pbXBsIHRhYmxlIGkgYXJyID1cbiAgbGV0IG5leHQgKCkgPSBpbmNyIGk7IG1hZ2ljIGFyci4oIWkpIGluXG4gIG1hdGNoIG5leHQoKSB3aXRoXG4gICAgR2V0Q29uc3QgLT4gbGV0IHggOiB0ID0gbmV4dCgpIGluIGdldF9jb25zdCB4XG4gIHwgR2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X3ZhciBuXG4gIHwgR2V0RW52ICAgLT4gbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW4gZ2V0X2VudiBlIG5cbiAgfCBHZXRNZXRoICAtPiBsZXQgbiA9IG5leHQoKSBpbiBnZXRfbWV0aCBuXG4gIHwgU2V0VmFyICAgLT4gbGV0IG4gPSBuZXh0KCkgaW4gc2V0X3ZhciBuXG4gIHwgQXBwQ29uc3QgLT4gbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gYXBwX2NvbnN0IGYgeFxuICB8IEFwcFZhciAgIC0+IGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBhcHBfdmFyIGYgblxuICB8IEFwcEVudiAgIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiAgbGV0IGUgPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9lbnYgZiBlIG5cbiAgfCBBcHBNZXRoICAtPiBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQgKCkgaW4gYXBwX21ldGggZiBuXG4gIHwgQXBwQ29uc3RDb25zdCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IHkgPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9jb25zdCBmIHggeVxuICB8IEFwcENvbnN0VmFyIC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgYXBwX2NvbnN0X3ZhciBmIHggblxuICB8IEFwcENvbnN0RW52IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQgKCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9lbnYgZiB4IGUgblxuICB8IEFwcENvbnN0TWV0aCAtPlxuICAgICAgbGV0IGYgPSBuZXh0KCkgaW4gbGV0IHggPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0KCkgaW5cbiAgICAgIGFwcF9jb25zdF9tZXRoIGYgeCBuXG4gIHwgQXBwVmFyQ29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluXG4gICAgICBhcHBfdmFyX2NvbnN0IGYgbiB4XG4gIHwgQXBwRW52Q29uc3QgLT5cbiAgICAgIGxldCBmID0gbmV4dCgpIGluIGxldCBlID0gbmV4dCAoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX2Vudl9jb25zdCBmIGUgbiB4XG4gIHwgQXBwTWV0aENvbnN0IC0+XG4gICAgICBsZXQgZiA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpblxuICAgICAgYXBwX21ldGhfY29uc3QgZiBuIHhcbiAgfCBNZXRoQXBwQ29uc3QgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCB4ID0gbmV4dCgpIGluIG1ldGhfYXBwX2NvbnN0IG4geFxuICB8IE1ldGhBcHBWYXIgLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX3ZhciBuIG1cbiAgfCBNZXRoQXBwRW52IC0+XG4gICAgICBsZXQgbiA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbSA9IG5leHQoKSBpblxuICAgICAgbWV0aF9hcHBfZW52IG4gZSBtXG4gIHwgTWV0aEFwcE1ldGggLT5cbiAgICAgIGxldCBuID0gbmV4dCgpIGluIGxldCBtID0gbmV4dCgpIGluIG1ldGhfYXBwX21ldGggbiBtXG4gIHwgU2VuZENvbnN0IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgeCA9IG5leHQoKSBpbiBzZW5kX2NvbnN0IG0geCAobmV3X2NhY2hlIHRhYmxlKVxuICB8IFNlbmRWYXIgLT5cbiAgICAgIGxldCBtID0gbmV4dCgpIGluIGxldCBuID0gbmV4dCAoKSBpbiBzZW5kX3ZhciBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kRW52IC0+XG4gICAgICBsZXQgbSA9IG5leHQoKSBpbiBsZXQgZSA9IG5leHQoKSBpbiBsZXQgbiA9IG5leHQoKSBpblxuICAgICAgc2VuZF9lbnYgbSBlIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBTZW5kTWV0aCAtPlxuICAgICAgbGV0IG0gPSBuZXh0KCkgaW4gbGV0IG4gPSBuZXh0ICgpIGluIHNlbmRfbWV0aCBtIG4gKG5ld19jYWNoZSB0YWJsZSlcbiAgfCBDbG9zdXJlIF8gYXMgY2xvIC0+IG1hZ2ljIGNsb1xuXG5sZXQgc2V0X21ldGhvZHMgdGFibGUgbWV0aG9kcyA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggbWV0aG9kcyBpbiBsZXQgaSA9IHJlZiAwIGluXG4gIHdoaWxlICFpIDwgbGVuIGRvXG4gICAgbGV0IGxhYmVsID0gbWV0aG9kcy4oIWkpIGluIGxldCBjbG8gPSBtZXRob2RfaW1wbCB0YWJsZSBpIG1ldGhvZHMgaW5cbiAgICBzZXRfbWV0aG9kIHRhYmxlIGxhYmVsIGNsbztcbiAgICBpbmNyIGlcbiAgZG9uZVxuXG4oKioqKiBTdGF0aXN0aWNzICoqKiopXG5cbnR5cGUgc3RhdHMgPVxuICB7IGNsYXNzZXM6IGludDsgbWV0aG9kczogaW50OyBpbnN0X3ZhcnM6IGludDsgfVxuXG5sZXQgc3RhdHMgKCkgPVxuICB7IGNsYXNzZXMgPSAhdGFibGVfY291bnQ7XG4gICAgbWV0aG9kcyA9ICFtZXRob2RfY291bnQ7IGluc3RfdmFycyA9ICFpbnN0X3Zhcl9jb3VudDsgfVxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG50eXBlIHRva2VuID1cbiAgICBLd2Qgb2Ygc3RyaW5nXG4gIHwgSWRlbnQgb2Ygc3RyaW5nXG4gIHwgSW50IG9mIGludFxuICB8IEZsb2F0IG9mIGZsb2F0XG4gIHwgU3RyaW5nIG9mIHN0cmluZ1xuICB8IENoYXIgb2YgY2hhclxuXG4oKiBUaGUgc3RyaW5nIGJ1ZmZlcmluZyBtYWNoaW5lcnkgKilcblxubGV0IGluaXRpYWxfYnVmZmVyID0gQnl0ZXMuY3JlYXRlIDMyXG5cbmxldCBidWZmZXIgPSByZWYgaW5pdGlhbF9idWZmZXJcbmxldCBidWZwb3MgPSByZWYgMFxuXG5sZXQgcmVzZXRfYnVmZmVyICgpID0gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBidWZwb3MgOj0gMFxuXG5sZXQgc3RvcmUgYyA9XG4gIGlmICFidWZwb3MgPj0gQnl0ZXMubGVuZ3RoICFidWZmZXIgdGhlbiBiZWdpblxuICAgIGxldCBuZXdidWZmZXIgPSBCeXRlcy5jcmVhdGUgKDIgKiAhYnVmcG9zKSBpblxuICAgIEJ5dGVzLmJsaXQgIWJ1ZmZlciAwIG5ld2J1ZmZlciAwICFidWZwb3M7XG4gICAgYnVmZmVyIDo9IG5ld2J1ZmZlclxuICBlbmQ7XG4gIEJ5dGVzLnNldCAhYnVmZmVyICFidWZwb3MgYztcbiAgaW5jciBidWZwb3NcblxubGV0IGdldF9zdHJpbmcgKCkgPVxuICBsZXQgcyA9IEJ5dGVzLnN1Yl9zdHJpbmcgIWJ1ZmZlciAwICFidWZwb3MgaW4gYnVmZmVyIDo9IGluaXRpYWxfYnVmZmVyOyBzXG5cbigqIFRoZSBsZXhlciAqKVxuXG5sZXQgbWFrZV9sZXhlciBrZXl3b3JkcyA9XG4gIGxldCBrd2RfdGFibGUgPSBIYXNodGJsLmNyZWF0ZSAxNyBpblxuICBMaXN0Lml0ZXIgKGZ1biBzIC0+IEhhc2h0YmwuYWRkIGt3ZF90YWJsZSBzIChLd2QgcykpIGtleXdvcmRzO1xuICBsZXQgaWRlbnRfb3Jfa2V5d29yZCBpZCA9XG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgaWQgd2l0aFxuICAgICAgTm90X2ZvdW5kIC0+IElkZW50IGlkXG4gIGFuZCBrZXl3b3JkX29yX2Vycm9yIGMgPVxuICAgIGxldCBzID0gU3RyaW5nLm1ha2UgMSBjIGluXG4gICAgdHJ5IEhhc2h0YmwuZmluZCBrd2RfdGFibGUgcyB3aXRoXG4gICAgICBOb3RfZm91bmQgLT4gcmFpc2UgKFN0cmVhbS5FcnJvciAoXCJJbGxlZ2FsIGNoYXJhY3RlciBcIiBeIHMpKVxuICBpblxuICBsZXQgcmVjIG5leHRfdG9rZW4gKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJyAnIHwgJ1xcMDEwJyB8ICdcXDAxMycgfCAnXFwwMDknIHwgJ1xcMDI2JyB8ICdcXDAxMicpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbmV4dF90b2tlbiBzdHJtX19cbiAgICB8IFNvbWUgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXycgfCAnXFwxOTInLi4nXFwyNTUnIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudCBzXG4gICAgfCBTb21lXG4gICAgICAgICgnIScgfCAnJScgfCAnJicgfCAnJCcgfCAnIycgfCAnKycgfCAnLycgfCAnOicgfCAnPCcgfCAnPScgfCAnPicgfFxuICAgICAgICAgJz8nIHwgJ0AnIHwgJ1xcXFwnIHwgJ34nIHwgJ14nIHwgJ3wnIHwgJyonIGFzIGMpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gcmVzZXRfYnVmZmVyICgpOyBzdG9yZSBjOyBpZGVudDIgc1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fO1xuICAgICAgICBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICdcXCcnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBjaGFyIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICBTdHJlYW0uRmFpbHVyZSAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgIGluXG4gICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgU29tZSAnXFwnJyAtPiBTdHJlYW0uanVuayBzdHJtX187IFNvbWUgKENoYXIgYylcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lICdcXFwiJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgU29tZSAoU3RyaW5nIChzdHJpbmcgcykpXG4gICAgfCBTb21lICctJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG5lZ19udW1iZXIgc3RybV9fXG4gICAgfCBTb21lICcoJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBTb21lIChrZXl3b3JkX29yX2Vycm9yIGMpXG4gICAgfCBfIC0+IE5vbmVcbiAgYW5kIGlkZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWVcbiAgICAgICAgKCdBJy4uJ1onIHwgJ2EnLi4neicgfCAnXFwxOTInLi4nXFwyNTUnIHwgJzAnLi4nOScgfCAnXycgfCAnXFwnJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50IHNcbiAgICB8IF8gLT4gU29tZSAoaWRlbnRfb3Jfa2V5d29yZCAoZ2V0X3N0cmluZyAoKSkpXG4gIGFuZCBpZGVudDIgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZVxuICAgICAgICAoJyEnIHwgJyUnIHwgJyYnIHwgJyQnIHwgJyMnIHwgJysnIHwgJy0nIHwgJy8nIHwgJzonIHwgJzwnIHwgJz0nIHxcbiAgICAgICAgICc+JyB8ICc/JyB8ICdAJyB8ICdcXFxcJyB8ICd+JyB8ICdeJyB8ICd8JyB8ICcqJyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGlkZW50MiBzXG4gICAgfCBfIC0+IFNvbWUgKGlkZW50X29yX2tleXdvcmQgKGdldF9zdHJpbmcgKCkpKVxuICBhbmQgbmVnX251bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187XG4gICAgICAgIGxldCBzID0gc3RybV9fIGluIHJlc2V0X2J1ZmZlciAoKTsgc3RvcmUgJy0nOyBzdG9yZSBjOyBudW1iZXIgc1xuICAgIHwgXyAtPiBsZXQgcyA9IHN0cm1fXyBpbiByZXNldF9idWZmZXIgKCk7IHN0b3JlICctJzsgaWRlbnQyIHNcbiAgYW5kIG51bWJlciAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IG51bWJlciBzXG4gICAgfCBTb21lICcuJyAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlICcuJzsgZGVjaW1hbF9wYXJ0IHNcbiAgICB8IFNvbWUgKCdlJyB8ICdFJykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSAnRSc7IGV4cG9uZW50X3BhcnQgc1xuICAgIHwgXyAtPiBTb21lIChJbnQgKGludF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIGRlY2ltYWxfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnMCcuLic5JyBhcyBjKSAtPlxuICAgICAgICBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IGRlY2ltYWxfcGFydCBzXG4gICAgfCBTb21lICgnZScgfCAnRScpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgJ0UnOyBleHBvbmVudF9wYXJ0IHNcbiAgICB8IF8gLT4gU29tZSAoRmxvYXQgKGZsb2F0X29mX3N0cmluZyAoZ2V0X3N0cmluZyAoKSkpKVxuICBhbmQgZXhwb25lbnRfcGFydCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICgnKycgfCAnLScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IGVuZF9leHBvbmVudF9wYXJ0IHN0cm1fX1xuICBhbmQgZW5kX2V4cG9uZW50X3BhcnQgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAoJzAnLi4nOScgYXMgYykgLT5cbiAgICAgICAgU3RyZWFtLmp1bmsgc3RybV9fOyBsZXQgcyA9IHN0cm1fXyBpbiBzdG9yZSBjOyBlbmRfZXhwb25lbnRfcGFydCBzXG4gICAgfCBfIC0+IFNvbWUgKEZsb2F0IChmbG9hdF9vZl9zdHJpbmcgKGdldF9zdHJpbmcgKCkpKSlcbiAgYW5kIHN0cmluZyAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICdcXFwiJyAtPiBTdHJlYW0uanVuayBzdHJtX187IGdldF9zdHJpbmcgKClcbiAgICB8IFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgbGV0IGMgPVxuICAgICAgICAgIHRyeSBlc2NhcGUgc3RybV9fIHdpdGhcbiAgICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgaW5cbiAgICAgICAgbGV0IHMgPSBzdHJtX18gaW4gc3RvcmUgYzsgc3RyaW5nIHNcbiAgICB8IFNvbWUgYyAtPiBTdHJlYW0uanVuayBzdHJtX187IGxldCBzID0gc3RybV9fIGluIHN0b3JlIGM7IHN0cmluZyBzXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBjaGFyIChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJ1xcXFwnIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gdHJ5IGVzY2FwZSBzdHJtX18gd2l0aFxuICAgICAgICAgIFN0cmVhbS5GYWlsdXJlIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBlc2NhcGUgKHN0cm1fXyA6IF8gU3RyZWFtLnQpID1cbiAgICBtYXRjaCBTdHJlYW0ucGVlayBzdHJtX18gd2l0aFxuICAgICAgU29tZSAnbicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxuJ1xuICAgIHwgU29tZSAncicgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFxyJ1xuICAgIHwgU29tZSAndCcgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyAnXFx0J1xuICAgIHwgU29tZSAoJzAnLi4nOScgYXMgYzEpIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgYmVnaW4gbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgICAgICBTb21lICgnMCcuLic5JyBhcyBjMikgLT5cbiAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICAgICAgICAgIFNvbWUgKCcwJy4uJzknIGFzIGMzKSAtPlxuICAgICAgICAgICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXztcbiAgICAgICAgICAgICAgICBDaGFyLmNoclxuICAgICAgICAgICAgICAgICAgKChDaGFyLmNvZGUgYzEgLSA0OCkgKiAxMDAgKyAoQ2hhci5jb2RlIGMyIC0gNDgpICogMTAgK1xuICAgICAgICAgICAgICAgICAgICAgKENoYXIuY29kZSBjMyAtIDQ4KSlcbiAgICAgICAgICAgIHwgXyAtPiByYWlzZSAoU3RyZWFtLkVycm9yIFwiXCIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBfIC0+IHJhaXNlIChTdHJlYW0uRXJyb3IgXCJcIilcbiAgICAgICAgZW5kXG4gICAgfCBTb21lIGMgLT4gU3RyZWFtLmp1bmsgc3RybV9fOyBjXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+XG4gICAgICAgIFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBuZXh0X3Rva2VuIHNcbiAgICB8IF8gLT4gU29tZSAoa2V5d29yZF9vcl9lcnJvciAnKCcpXG4gIGFuZCBjb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJygnIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbWF5YmVfbmVzdGVkX2NvbW1lbnQgc3RybV9fXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgYW5kIG1heWJlX25lc3RlZF9jb21tZW50IChzdHJtX18gOiBfIFN0cmVhbS50KSA9XG4gICAgbWF0Y2ggU3RyZWFtLnBlZWsgc3RybV9fIHdpdGhcbiAgICAgIFNvbWUgJyonIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgbGV0IHMgPSBzdHJtX18gaW4gY29tbWVudCBzOyBjb21tZW50IHNcbiAgICB8IFNvbWUgXyAtPiBTdHJlYW0uanVuayBzdHJtX187IGNvbW1lbnQgc3RybV9fXG4gICAgfCBfIC0+IHJhaXNlIFN0cmVhbS5GYWlsdXJlXG4gIGFuZCBtYXliZV9lbmRfY29tbWVudCAoc3RybV9fIDogXyBTdHJlYW0udCkgPVxuICAgIG1hdGNoIFN0cmVhbS5wZWVrIHN0cm1fXyB3aXRoXG4gICAgICBTb21lICcpJyAtPiBTdHJlYW0uanVuayBzdHJtX187ICgpXG4gICAgfCBTb21lICcqJyAtPiBTdHJlYW0uanVuayBzdHJtX187IG1heWJlX2VuZF9jb21tZW50IHN0cm1fX1xuICAgIHwgU29tZSBfIC0+IFN0cmVhbS5qdW5rIHN0cm1fXzsgY29tbWVudCBzdHJtX19cbiAgICB8IF8gLT4gcmFpc2UgU3RyZWFtLkZhaWx1cmVcbiAgaW5cbiAgZnVuIGlucHV0IC0+IFN0cmVhbS5mcm9tIChmdW4gX2NvdW50IC0+IG5leHRfdG9rZW4gaW5wdXQpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBEYW1pZW4gRG9saWdleiwgcHJvamV0IFBhcmEsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk3IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm1vZHVsZSB0eXBlIFNlZWRlZFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNlZWRlZFNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgaW5jbHVkZSBIYXNodGJsLlNcbiAgdmFsIGNsZWFuOiAnYSB0IC0+IHVuaXRcbiAgdmFsIHN0YXRzX2FsaXZlOiAnYSB0IC0+IEhhc2h0Ymwuc3RhdGlzdGljc1xuICAgICgqKiBzYW1lIGFzIHshc3RhdHN9IGJ1dCBvbmx5IGNvdW50IHRoZSBhbGl2ZSBiaW5kaW5ncyAqKVxuZW5kXG5cbm1vZHVsZSBHZW5IYXNoVGFibGUgPSBzdHJ1Y3RcblxuICB0eXBlIGVxdWFsID1cbiAgfCBFVHJ1ZSB8IEVGYWxzZVxuICB8IEVEZWFkICgqKiB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IgcmVjbGFpbWVkIHRoZSBkYXRhICopXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQoSDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSAnYSBjb250YWluZXJcbiAgICB2YWwgY3JlYXRlOiB0IC0+ICdhIC0+ICdhIGNvbnRhaW5lclxuICAgIHZhbCBoYXNoOiBpbnQgLT4gdCAtPiBpbnRcbiAgICB2YWwgZXF1YWw6ICdhIGNvbnRhaW5lciAtPiB0IC0+IGVxdWFsXG4gICAgdmFsIGdldF9kYXRhOiAnYSBjb250YWluZXIgLT4gJ2Egb3B0aW9uXG4gICAgdmFsIGdldF9rZXk6ICdhIGNvbnRhaW5lciAtPiB0IG9wdGlvblxuICAgIHZhbCBzZXRfa2V5X2RhdGE6ICdhIGNvbnRhaW5lciAtPiB0IC0+ICdhIC0+IHVuaXRcbiAgICB2YWwgY2hlY2tfa2V5OiAnYSBjb250YWluZXIgLT4gYm9vbFxuICBlbmQpIDogU2VlZGVkUyB3aXRoIHR5cGUga2V5ID0gSC50XG4gID0gc3RydWN0XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBtdXRhYmxlIHNpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBudW1iZXIgb2YgZW50cmllcyAqKVxuICAgICAgICBtdXRhYmxlIGRhdGE6ICdhIGJ1Y2tldGxpc3QgYXJyYXk7ICAoKiB0aGUgYnVja2V0cyAqKVxuICAgICAgICBtdXRhYmxlIHNlZWQ6IGludDsgICAgICAgICAgICAgICAgICAoKiBmb3IgcmFuZG9taXphdGlvbiAqKVxuICAgICAgICBpbml0aWFsX3NpemU6IGludDsgICAgICAgICAgICAgICAgICAoKiBpbml0aWFsIGFycmF5IHNpemUgKilcbiAgICAgIH1cblxuICAgIGFuZCAnYSBidWNrZXRsaXN0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBDb25zIG9mIGludCAoKiBoYXNoIG9mIHRoZSBrZXkgKikgKiAnYSBILmNvbnRhaW5lciAqICdhIGJ1Y2tldGxpc3RcblxuICAgICgqKiB0aGUgaGFzaCBvZiB0aGUga2V5IGlzIGtlcHQgaW4gb3JkZXIgdG8gdGVzdCB0aGUgZXF1YWxpdHkgb2YgdGhlIGhhc2hcbiAgICAgIGJlZm9yZSB0aGUga2V5LiBTYW1lIHJlYXNvbiBhcyBmb3IgV2Vhay5NYWtlICopXG5cbiAgICB0eXBlIGtleSA9IEgudFxuXG4gICAgbGV0IHJlYyBwb3dlcl8yX2Fib3ZlIHggbiA9XG4gICAgICBpZiB4ID49IG4gdGhlbiB4XG4gICAgICBlbHNlIGlmIHggKiAyID4gU3lzLm1heF9hcnJheV9sZW5ndGggdGhlbiB4XG4gICAgICBlbHNlIHBvd2VyXzJfYWJvdmUgKHggKiAyKSBuXG5cbiAgICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCgpKVxuXG4gICAgbGV0IGNyZWF0ZSA/KHJhbmRvbSA9IChIYXNodGJsLmlzX3JhbmRvbWl6ZWQgKCkpKSBpbml0aWFsX3NpemUgPVxuICAgICAgbGV0IHMgPSBwb3dlcl8yX2Fib3ZlIDE2IGluaXRpYWxfc2l6ZSBpblxuICAgICAgbGV0IHNlZWQgPSBpZiByYW5kb20gdGhlbiBSYW5kb20uU3RhdGUuYml0cyAoTGF6eS5mb3JjZSBwcm5nKSBlbHNlIDAgaW5cbiAgICAgIHsgaW5pdGlhbF9zaXplID0gczsgc2l6ZSA9IDA7IHNlZWQgPSBzZWVkOyBkYXRhID0gQXJyYXkubWFrZSBzIEVtcHR5IH1cblxuICAgIGxldCBjbGVhciBoID1cbiAgICAgIGguc2l6ZSA8LSAwO1xuICAgICAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAgIGguZGF0YS4oaSkgPC0gRW1wdHlcbiAgICAgIGRvbmVcblxuICAgIGxldCByZXNldCBoID1cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggaC5kYXRhIGluXG4gICAgICBpZiBsZW4gPSBoLmluaXRpYWxfc2l6ZSB0aGVuXG4gICAgICAgIGNsZWFyIGhcbiAgICAgIGVsc2UgYmVnaW5cbiAgICAgICAgaC5zaXplIDwtIDA7XG4gICAgICAgIGguZGF0YSA8LSBBcnJheS5tYWtlIGguaW5pdGlhbF9zaXplIEVtcHR5XG4gICAgICBlbmRcblxuICAgIGxldCBjb3B5IGggPSB7IGggd2l0aCBkYXRhID0gQXJyYXkuY29weSBoLmRhdGEgfVxuXG4gICAgbGV0IGtleV9pbmRleCBoIGhrZXkgPVxuICAgICAgaGtleSBsYW5kIChBcnJheS5sZW5ndGggaC5kYXRhIC0gMSlcblxuICAgIGxldCBjbGVhbiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgRW1wdHlcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gbm90IChILmNoZWNrX2tleSBjKSAtPlxuICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICB8IENvbnMoaGtleSwgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIENvbnMoaGtleSwgYywgZG9fYnVja2V0IHJlc3QpXG4gICAgICBpblxuICAgICAgbGV0IGQgPSBoLmRhdGEgaW5cbiAgICAgIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggZCAtIDEgZG9cbiAgICAgICAgZC4oaSkgPC0gZG9fYnVja2V0IGQuKGkpXG4gICAgICBkb25lXG5cbiAgICAoKiogcmVzaXplIGlzIHRoZSBvbmx5IGZ1bmN0aW9uIHRvIGRvIHRoZSBhY3R1YWwgY2xlYW5pbmcgb2YgZGVhZCBrZXlzXG4gICAgICAgIChyZW1vdmUgZG9lcyBpdCBqdXN0IGJlY2F1c2UgaXQgY291bGQpLlxuXG4gICAgICAgIFRoZSBnb2FsIGlzIHRvOlxuXG4gICAgICAgIC0gbm90IHJlc2l6ZSBpbmZpbml0ZWx5IHdoZW4gdGhlIGFjdHVhbCBudW1iZXIgb2YgYWxpdmUga2V5cyBpc1xuICAgICAgICBib3VuZGVkIGJ1dCBrZXlzIGFyZSBjb250aW51b3VzbHkgYWRkZWQuIFRoYXQgd291bGQgaGFwcGVuIGlmXG4gICAgICAgIHRoaXMgZnVuY3Rpb24gYWx3YXlzIHJlc2l6ZS5cbiAgICAgICAgLSBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIGVhY2ggYWRkaXRpb24sIHRoYXQgd291bGQgaGFwcGVuIGlmIHRoaXNcbiAgICAgICAgZnVuY3Rpb24gZG9uJ3QgcmVzaXplIGV2ZW4gd2hlbiBvbmx5IG9uZSBrZXkgaXMgZGVhZC5cblxuICAgICAgICBTbyB0aGUgYWxnb3JpdGhtOlxuICAgICAgICAtIGNsZWFuIHRoZSBrZXlzIGJlZm9yZSByZXNpemluZ1xuICAgICAgICAtIGlmIHRoZSBudW1iZXIgb2YgcmVtYWluaW5nIGtleXMgaXMgbGVzcyB0aGFuIGhhbGYgdGhlIHNpemUgb2YgdGhlXG4gICAgICAgIGFycmF5LCBkb24ndCByZXNpemUuXG4gICAgICAgIC0gaWYgaXQgaXMgbW9yZSwgcmVzaXplLlxuXG4gICAgICAgIFRoZSBzZWNvbmQgcHJvYmxlbSByZW1haW5zIGlmIHRoZSB0YWJsZSByZWFjaGVzIHshU3lzLm1heF9hcnJheV9sZW5ndGh9LlxuXG4gICAgKilcbiAgICBsZXQgcmVzaXplIGggPVxuICAgICAgbGV0IG9kYXRhID0gaC5kYXRhIGluXG4gICAgICBsZXQgb3NpemUgPSBBcnJheS5sZW5ndGggb2RhdGEgaW5cbiAgICAgIGxldCBuc2l6ZSA9IG9zaXplICogMiBpblxuICAgICAgY2xlYW4gaDtcbiAgICAgIGlmIG5zaXplIDwgU3lzLm1heF9hcnJheV9sZW5ndGggJiYgaC5zaXplID49IG9zaXplIGxzciAxIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IG5kYXRhID0gQXJyYXkubWFrZSBuc2l6ZSBFbXB0eSBpblxuICAgICAgICBoLmRhdGEgPC0gbmRhdGE7ICAgICAgICgqIHNvIHRoYXQga2V5X2luZGV4IHNlZXMgdGhlIG5ldyBidWNrZXQgY291bnQgKilcbiAgICAgICAgbGV0IHJlYyBpbnNlcnRfYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgICAgIEVtcHR5IC0+ICgpXG4gICAgICAgICAgfCBDb25zKGhrZXksIGRhdGEsIHJlc3QpIC0+XG4gICAgICAgICAgICAgIGluc2VydF9idWNrZXQgcmVzdDsgKCogcHJlc2VydmUgb3JpZ2luYWwgb3JkZXIgb2YgZWxlbWVudHMgKilcbiAgICAgICAgICAgICAgbGV0IG5pZHggPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICAgICAgICAgIG5kYXRhLihuaWR4KSA8LSBDb25zKGhrZXksIGRhdGEsIG5kYXRhLihuaWR4KSkgaW5cbiAgICAgICAgZm9yIGkgPSAwIHRvIG9zaXplIC0gMSBkb1xuICAgICAgICAgIGluc2VydF9idWNrZXQgb2RhdGEuKGkpXG4gICAgICAgIGRvbmVcbiAgICAgIGVuZFxuXG4gICAgbGV0IGFkZCBoIGtleSBpbmZvID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCBpID0ga2V5X2luZGV4IGggaGtleSBpblxuICAgICAgbGV0IGNvbnRhaW5lciA9IEguY3JlYXRlIGtleSBpbmZvIGluXG4gICAgICBsZXQgYnVja2V0ID0gQ29ucyhoa2V5LCBjb250YWluZXIsIGguZGF0YS4oaSkpIGluXG4gICAgICBoLmRhdGEuKGkpIDwtIGJ1Y2tldDtcbiAgICAgIGguc2l6ZSA8LSBoLnNpemUgKyAxO1xuICAgICAgaWYgaC5zaXplID4gQXJyYXkubGVuZ3RoIGguZGF0YSBsc2wgMSB0aGVuIHJlc2l6ZSBoXG5cbiAgICBsZXQgcmVtb3ZlIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgcmVtb3ZlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCBDb25zKGhrLCBjLCBuZXh0KSB3aGVuIGhrZXkgPSBoayAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgICB8IEVUcnVlIC0+IGguc2l6ZSA8LSBoLnNpemUgLSAxOyBuZXh0XG4gICAgICAgICAgICB8IEVGYWxzZSAtPiBDb25zKGhrLCBjLCByZW1vdmVfYnVja2V0IG5leHQpXG4gICAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgICAgKCogVGhlIGRlYWQga2V5IGlzIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC4gSXQgaXMgYWNjZXB0YWJsZVxuICAgICAgICAgICAgICAgICAgICBmb3IgdGhpcyBmdW5jdGlvbiBzaW5jZSBpdCBhbHJlYWR5IHJlbW92ZXMgYSBiaW5kaW5nICopXG4gICAgICAgICAgICAgICAgaC5zaXplIDwtIGguc2l6ZSAtIDE7XG4gICAgICAgICAgICAgICAgcmVtb3ZlX2J1Y2tldCBuZXh0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgfCBDb25zKGhrLGMsbmV4dCkgLT4gQ29ucyhoaywgYywgcmVtb3ZlX2J1Y2tldCBuZXh0KSBpblxuICAgICAgbGV0IGkgPSBrZXlfaW5kZXggaCBoa2V5IGluXG4gICAgICBoLmRhdGEuKGkpIDwtIHJlbW92ZV9idWNrZXQgaC5kYXRhLihpKVxuXG4gICAgKCoqIHshZmluZH0gZG9uJ3QgcmVtb3ZlIGRlYWQga2V5cyBiZWNhdXNlIGl0IHdvdWxkIGJlIHN1cnByaXNpbmcgZm9yXG4gICAgICAgIHRoZSB1c2VyIHRoYXQgYSByZWFkLW9ubHkgZnVuY3Rpb24gbXV0YXRlcyB0aGUgc3RhdGUgKGVnLiBjb25jdXJyZW50XG4gICAgICAgIGFjY2VzcykuIFNhbWUgZm9yIHshaXRlcn0sIHshZm9sZH0sIHshbWVtfS5cbiAgICAqKVxuICAgIGxldCByZWMgZmluZF9yZWMga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9mb3VuZFxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+XG4gICAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgKCogVGhpcyBjYXNlIGlzIG5vdCBpbXBvc3NpYmxlIGJlY2F1c2UgdGhlIGdjIGNhbiBydW4gYmV0d2VlblxuICAgICAgICAgICAgICAgICAgICAgIEguZXF1YWwgYW5kIEguZ2V0X2RhdGEgKilcbiAgICAgICAgICAgICAgICAgIGZpbmRfcmVjIGtleSBoa2V5IHJlc3RcbiAgICAgICAgICAgICAgfCBTb21lIGQgLT4gZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlYyBrZXkgaGtleSByZXN0XG5cbiAgICBsZXQgZmluZCBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICAoKiBUT0RPIGlubGluZSAzIGl0ZXJhdGlvbnMgKilcbiAgICAgIGZpbmRfcmVjIGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IHJlYyBmaW5kX3JlY19vcHQga2V5IGhrZXkgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIE5vbmVcbiAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgd2hlbiBoa2V5ID0gaGsgIC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPlxuICAgICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgICAgICAgICAgICgqIFRoaXMgY2FzZSBpcyBub3QgaW1wb3NzaWJsZSBiZWNhdXNlIHRoZSBnYyBjYW4gcnVuIGJldHdlZW5cbiAgICAgICAgICAgICAgICAgICAgICBILmVxdWFsIGFuZCBILmdldF9kYXRhICopXG4gICAgICAgICAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgXyBhcyBkIC0+IGRcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfCBFRmFsc2UgLT4gZmluZF9yZWNfb3B0IGtleSBoa2V5IHJlc3RcbiAgICAgICAgICB8IEVEZWFkIC0+XG4gICAgICAgICAgICAgIGZpbmRfcmVjX29wdCBrZXkgaGtleSByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX3JlY19vcHQga2V5IGhrZXkgcmVzdFxuXG4gICAgbGV0IGZpbmRfb3B0IGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgICgqIFRPRE8gaW5saW5lIDMgaXRlcmF0aW9ucyAqKVxuICAgICAgZmluZF9yZWNfb3B0IGtleSBoa2V5IChoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpKVxuXG4gICAgbGV0IGZpbmRfYWxsIGgga2V5ID1cbiAgICAgIGxldCBoa2V5ID0gSC5oYXNoIGguc2VlZCBrZXkgaW5cbiAgICAgIGxldCByZWMgZmluZF9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBbXVxuICAgICAgfCBDb25zKGhrLCBjLCByZXN0KSB3aGVuIGhrZXkgPSBoayAgLT5cbiAgICAgICAgICBiZWdpbiBtYXRjaCBILmVxdWFsIGMga2V5IHdpdGhcbiAgICAgICAgICB8IEVUcnVlIC0+IGJlZ2luIG1hdGNoIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgZmluZF9pbl9idWNrZXQgcmVzdFxuICAgICAgICAgICAgICB8IFNvbWUgZCAtPiBkOjpmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICB8IEVGYWxzZSAtPiBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgfCBFRGVhZCAtPlxuICAgICAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0XG4gICAgICAgICAgZW5kXG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT5cbiAgICAgICAgICBmaW5kX2luX2J1Y2tldCByZXN0IGluXG4gICAgICBmaW5kX2luX2J1Y2tldCBoLmRhdGEuKGtleV9pbmRleCBoIGhrZXkpXG5cblxuICAgIGxldCByZXBsYWNlIGgga2V5IGluZm8gPVxuICAgICAgbGV0IGhrZXkgPSBILmhhc2ggaC5zZWVkIGtleSBpblxuICAgICAgbGV0IHJlYyByZXBsYWNlX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgICAgIHwgQ29ucyhoaywgYywgbmV4dCkgd2hlbiBoa2V5ID0gaGsgLT5cbiAgICAgICAgICAgIGJlZ2luIG1hdGNoIEguZXF1YWwgYyBrZXkgd2l0aFxuICAgICAgICAgICAgfCBFVHJ1ZSAtPiBILnNldF9rZXlfZGF0YSBjIGtleSBpbmZvXG4gICAgICAgICAgICB8IEVGYWxzZSB8IEVEZWFkIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICB8IENvbnMoXyxfLG5leHQpIC0+IHJlcGxhY2VfYnVja2V0IG5leHRcbiAgICAgIGluXG4gICAgICBsZXQgaSA9IGtleV9pbmRleCBoIGhrZXkgaW5cbiAgICAgIGxldCBsID0gaC5kYXRhLihpKSBpblxuICAgICAgdHJ5XG4gICAgICAgIHJlcGxhY2VfYnVja2V0IGxcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgICAgIGxldCBjb250YWluZXIgPSBILmNyZWF0ZSBrZXkgaW5mbyBpblxuICAgICAgICBoLmRhdGEuKGkpIDwtIENvbnMoaGtleSwgY29udGFpbmVyLCBsKTtcbiAgICAgICAgaC5zaXplIDwtIGguc2l6ZSArIDE7XG4gICAgICAgIGlmIGguc2l6ZSA+IEFycmF5Lmxlbmd0aCBoLmRhdGEgbHNsIDEgdGhlbiByZXNpemUgaFxuXG4gICAgbGV0IG1lbSBoIGtleSA9XG4gICAgICBsZXQgaGtleSA9IEguaGFzaCBoLnNlZWQga2V5IGluXG4gICAgICBsZXQgcmVjIG1lbV9pbl9idWNrZXQgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgIGZhbHNlXG4gICAgICB8IENvbnMoaGssIGMsIHJlc3QpIHdoZW4gaGsgPSBoa2V5IC0+XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggSC5lcXVhbCBjIGtleSB3aXRoXG4gICAgICAgICAgfCBFVHJ1ZSAtPiB0cnVlXG4gICAgICAgICAgfCBFRmFsc2UgfCBFRGVhZCAtPiBtZW1faW5fYnVja2V0IHJlc3RcbiAgICAgICAgICBlbmRcbiAgICAgIHwgQ29ucyhfaGssIF9jLCByZXN0KSAtPiBtZW1faW5fYnVja2V0IHJlc3QgaW5cbiAgICAgIG1lbV9pbl9idWNrZXQgaC5kYXRhLihrZXlfaW5kZXggaCBoa2V5KVxuXG4gICAgbGV0IGl0ZXIgZiBoID1cbiAgICAgIGxldCByZWMgZG9fYnVja2V0ID0gZnVuY3Rpb25cbiAgICAgICAgfCBFbXB0eSAtPlxuICAgICAgICAgICAgKClcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBiZWdpbiBtYXRjaCBILmdldF9rZXkgYywgSC5nZXRfZGF0YSBjIHdpdGhcbiAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gKClcbiAgICAgICAgICAgIHwgU29tZSBrLCBTb21lIGQgLT4gZiBrIGRcbiAgICAgICAgICAgIGVuZDsgZG9fYnVja2V0IHJlc3QgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGZvbGQgZiBoIGluaXQgPVxuICAgICAgbGV0IHJlYyBkb19idWNrZXQgYiBhY2N1ID1cbiAgICAgICAgbWF0Y2ggYiB3aXRoXG4gICAgICAgICAgRW1wdHkgLT5cbiAgICAgICAgICAgIGFjY3VcbiAgICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIC0+XG4gICAgICAgICAgICBsZXQgYWNjdSA9IGJlZ2luIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUsIF8gfCBfLCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIGssIFNvbWUgZCAtPiBmIGsgZCBhY2N1XG4gICAgICAgICAgICBlbmQgaW5cbiAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0IGFjY3UgIGluXG4gICAgICBsZXQgZCA9IGguZGF0YSBpblxuICAgICAgbGV0IGFjY3UgPSByZWYgaW5pdCBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBkIC0gMSBkb1xuICAgICAgICBhY2N1IDo9IGRvX2J1Y2tldCBkLihpKSAhYWNjdVxuICAgICAgZG9uZTtcbiAgICAgICFhY2N1XG5cbiAgICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlIGYgaCA9XG4gICAgICBsZXQgcmVjIGRvX2J1Y2tldCA9IGZ1bmN0aW9uXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIEVtcHR5XG4gICAgICAgIHwgQ29ucyhoaywgYywgcmVzdCkgLT5cbiAgICAgICAgICAgIG1hdGNoIEguZ2V0X2tleSBjLCBILmdldF9kYXRhIGMgd2l0aFxuICAgICAgICAgICAgfCBOb25lLCBfIHwgXywgTm9uZSAtPlxuICAgICAgICAgICAgICAgIGRvX2J1Y2tldCByZXN0XG4gICAgICAgICAgICB8IFNvbWUgaywgU29tZSBkIC0+XG4gICAgICAgICAgICAgICAgbWF0Y2ggZiBrIGQgd2l0aFxuICAgICAgICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgICAgICAgICBkb19idWNrZXQgcmVzdFxuICAgICAgICAgICAgICAgIHwgU29tZSBuZXdfZCAtPlxuICAgICAgICAgICAgICAgICAgICBILnNldF9rZXlfZGF0YSBjIGsgbmV3X2Q7XG4gICAgICAgICAgICAgICAgICAgIENvbnMoaGssIGMsIGRvX2J1Y2tldCByZXN0KVxuICAgICAgaW5cbiAgICAgIGxldCBkID0gaC5kYXRhIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGQgLSAxIGRvXG4gICAgICAgIGQuKGkpIDwtIGRvX2J1Y2tldCBkLihpKVxuICAgICAgZG9uZVxuXG4gICAgbGV0IGxlbmd0aCBoID0gaC5zaXplXG5cbiAgICBsZXQgcmVjIGJ1Y2tldF9sZW5ndGggYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgQ29ucyhfLCBfLCByZXN0KSAtPiBidWNrZXRfbGVuZ3RoIChhY2N1ICsgMSkgcmVzdFxuXG4gICAgbGV0IHN0YXRzIGggPVxuICAgICAgbGV0IG1ibCA9XG4gICAgICAgIEFycmF5LmZvbGRfbGVmdCAoZnVuIG0gYiAtPiBtYXggbSAoYnVja2V0X2xlbmd0aCAwIGIpKSAwIGguZGF0YSBpblxuICAgICAgbGV0IGhpc3RvID0gQXJyYXkubWFrZSAobWJsICsgMSkgMCBpblxuICAgICAgQXJyYXkuaXRlclxuICAgICAgICAoZnVuIGIgLT5cbiAgICAgICAgICAgbGV0IGwgPSBidWNrZXRfbGVuZ3RoIDAgYiBpblxuICAgICAgICAgICBoaXN0by4obCkgPC0gaGlzdG8uKGwpICsgMSlcbiAgICAgICAgaC5kYXRhO1xuICAgICAgeyBIYXNodGJsLm51bV9iaW5kaW5ncyA9IGguc2l6ZTtcbiAgICAgICAgbnVtX2J1Y2tldHMgPSBBcnJheS5sZW5ndGggaC5kYXRhO1xuICAgICAgICBtYXhfYnVja2V0X2xlbmd0aCA9IG1ibDtcbiAgICAgICAgYnVja2V0X2hpc3RvZ3JhbSA9IGhpc3RvIH1cblxuICAgIGxldCByZWMgYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBDb25zKF8sIGMsIHJlc3QpIHdoZW4gSC5jaGVja19rZXkgYyAtPlxuICAgICAgICAgIGJ1Y2tldF9sZW5ndGhfYWxpdmUgKGFjY3UgKyAxKSByZXN0XG4gICAgICB8IENvbnMoXywgXywgcmVzdCkgLT4gYnVja2V0X2xlbmd0aF9hbGl2ZSBhY2N1IHJlc3RcblxuICAgIGxldCBzdGF0c19hbGl2ZSBoID1cbiAgICAgIGxldCBzaXplID0gcmVmIDAgaW5cbiAgICAgIGxldCBtYmwgPVxuICAgICAgICBBcnJheS5mb2xkX2xlZnQgKGZ1biBtIGIgLT4gbWF4IG0gKGJ1Y2tldF9sZW5ndGhfYWxpdmUgMCBiKSkgMCBoLmRhdGEgaW5cbiAgICAgIGxldCBoaXN0byA9IEFycmF5Lm1ha2UgKG1ibCArIDEpIDAgaW5cbiAgICAgIEFycmF5Lml0ZXJcbiAgICAgICAgKGZ1biBiIC0+XG4gICAgICAgICAgIGxldCBsID0gYnVja2V0X2xlbmd0aF9hbGl2ZSAwIGIgaW5cbiAgICAgICAgICAgc2l6ZSA6PSAhc2l6ZSArIGw7XG4gICAgICAgICAgIGhpc3RvLihsKSA8LSBoaXN0by4obCkgKyAxKVxuICAgICAgICBoLmRhdGE7XG4gICAgICB7IEhhc2h0YmwubnVtX2JpbmRpbmdzID0gIXNpemU7XG4gICAgICAgIG51bV9idWNrZXRzID0gQXJyYXkubGVuZ3RoIGguZGF0YTtcbiAgICAgICAgbWF4X2J1Y2tldF9sZW5ndGggPSBtYmw7XG4gICAgICAgIGJ1Y2tldF9oaXN0b2dyYW0gPSBoaXN0byB9XG5cbiAgICBsZXQgdG9fc2VxIHRibCA9XG4gICAgICAoKiBjYXB0dXJlIGN1cnJlbnQgYXJyYXksIHNvIHRoYXQgZXZlbiBpZiB0aGUgdGFibGUgaXMgcmVzaXplZCB3ZVxuICAgICAgICAga2VlcCBpdGVyYXRpbmcgb24gdGhlIHNhbWUgYXJyYXkgKilcbiAgICAgIGxldCB0YmxfZGF0YSA9IHRibC5kYXRhIGluXG4gICAgICAoKiBzdGF0ZTogaW5kZXggKiBuZXh0IGJ1Y2tldCB0byB0cmF2ZXJzZSAqKVxuICAgICAgbGV0IHJlYyBhdXggaSBidWNrICgpID0gbWF0Y2ggYnVjayB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT5cbiAgICAgICAgICAgIGlmIGkgPSBBcnJheS5sZW5ndGggdGJsX2RhdGFcbiAgICAgICAgICAgIHRoZW4gU2VxLk5pbFxuICAgICAgICAgICAgZWxzZSBhdXgoaSsxKSB0YmxfZGF0YS4oaSkgKClcbiAgICAgICAgfCBDb25zIChfLCBjLCBuZXh0KSAtPlxuICAgICAgICAgICAgYmVnaW4gbWF0Y2ggSC5nZXRfa2V5IGMsIEguZ2V0X2RhdGEgYyB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSwgXyB8IF8sIE5vbmUgLT4gYXV4IGkgbmV4dCAoKVxuICAgICAgICAgICAgICB8IFNvbWUga2V5LCBTb21lIGRhdGEgLT5cbiAgICAgICAgICAgICAgICAgIFNlcS5Db25zICgoa2V5LCBkYXRhKSwgYXV4IGkgbmV4dClcbiAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIGF1eCAwIEVtcHR5XG5cbiAgICBsZXQgdG9fc2VxX2tleXMgbSA9IFNlcS5tYXAgZnN0ICh0b19zZXEgbSlcblxuICAgIGxldCB0b19zZXFfdmFsdWVzIG0gPSBTZXEubWFwIHNuZCAodG9fc2VxIG0pXG5cbiAgICBsZXQgYWRkX3NlcSB0YmwgaSA9XG4gICAgICBTZXEuaXRlciAoZnVuIChrLHYpIC0+IGFkZCB0YmwgayB2KSBpXG5cbiAgICBsZXQgcmVwbGFjZV9zZXEgdGJsIGkgPVxuICAgICAgU2VxLml0ZXIgKGZ1biAoayx2KSAtPiByZXBsYWNlIHRibCBrIHYpIGlcblxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBPYmpFcGggPSBPYmouRXBoZW1lcm9uXG5cbmxldCBfb2JqX29wdCA6IE9iai50IG9wdGlvbiAtPiAnYSBvcHRpb24gPSBmdW4geCAtPlxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHhcbiAgfCBTb21lIHYgLT4gU29tZSAoT2JqLm9iaiB2KVxuXG4oKiogVGhlIHByZXZpb3VzIGZ1bmN0aW9uIGlzIHR5cGVkIHNvIHRoaXMgb25lIGlzIGFsc28gY29ycmVjdCAqKVxubGV0IG9ial9vcHQgOiBPYmoudCBvcHRpb24gLT4gJ2Egb3B0aW9uID0gZnVuIHggLT4gT2JqLm1hZ2ljIHhcblxuXG5tb2R1bGUgSzEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgKCkgOiAoJ2ssJ2QpIHQgPSBPYmpFcGguY3JlYXRlIDFcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIDogJ2sgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9rZXkgdCAwKVxuICBsZXQgZ2V0X2tleV9jb3B5ICh0OignaywnZCkgdCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgMClcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAoazonaykgOiB1bml0ID0gT2JqRXBoLnNldF9rZXkgdCAwIChPYmoucmVwciBrKVxuICBsZXQgdW5zZXRfa2V5ICh0OignaywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IDBcbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIDogYm9vbCA9IE9iakVwaC5jaGVja19rZXkgdCAwXG5cbiAgbGV0IGJsaXRfa2V5ICh0MTooJ2ssJ2QpIHQpICh0MjooJ2ssJ2QpIHQpOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcblxuICBsZXQgZ2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YSB0KVxuICBsZXQgZ2V0X2RhdGFfY29weSAodDooJ2ssJ2QpIHQpIDogJ2Qgb3B0aW9uID0gb2JqX29wdCAoT2JqRXBoLmdldF9kYXRhX2NvcHkgdClcbiAgbGV0IHNldF9kYXRhICh0OignaywnZCkgdCkgKGQ6J2QpIDogdW5pdCA9IE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2ssJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9kYXRhIHRcbiAgbGV0IGNoZWNrX2RhdGEgKHQ6KCdrLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfZGF0YSB0XG4gIGxldCBibGl0X2RhdGEgKHQxOihfLCdkKSB0KSAodDI6KF8sJ2QpIHQpIDogdW5pdCA9IE9iakVwaC5ibGl0X2RhdGEgdDEgdDJcblxuICBtb2R1bGUgTWFrZVNlZWRlZCAoSDpIYXNodGJsLlNlZWRlZEhhc2hlZFR5cGUpID1cbiAgICBHZW5IYXNoVGFibGUuTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgY29udGFpbmVyID0gKEgudCwnYSkgdFxuICAgICAgdHlwZSB0ID0gSC50XG4gICAgICBsZXQgY3JlYXRlIGsgZCA9XG4gICAgICAgIGxldCBjID0gY3JlYXRlICgpIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgc2V0X2tleSBjIGs7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoID0gSC5oYXNoXG4gICAgICBsZXQgZXF1YWwgYyBrID1cbiAgICAgICAgKCogeyFnZXRfa2V5X2NvcHl9IGlzIG5vdCB1c2VkIGJlY2F1c2UgdGhlIGVxdWFsaXR5IG9mIHRoZSB1c2VyIGNhbiBiZVxuICAgICAgICAgICAgdGhlIHBoeXNpY2FsIGVxdWFsaXR5ICopXG4gICAgICAgIG1hdGNoIGdldF9rZXkgYyB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBHZW5IYXNoVGFibGUuRURlYWRcbiAgICAgICAgfCBTb21lIGsnIC0+XG4gICAgICAgICAgICBpZiBILmVxdWFsIGsgaycgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgPSBnZXRfa2V5XG4gICAgICBsZXQgc2V0X2tleV9kYXRhIGMgayBkID1cbiAgICAgICAgdW5zZXRfZGF0YSBjO1xuICAgICAgICBzZXRfa2V5IGMgaztcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5ID0gY2hlY2tfa2V5XG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEg6IEhhc2h0YmwuSGFzaGVkVHlwZSk6IChTIHdpdGggdHlwZSBrZXkgPSBILnQpID1cbiAgc3RydWN0XG4gICAgaW5jbHVkZSBNYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgICB0eXBlIHQgPSBILnRcbiAgICAgICAgbGV0IGVxdWFsID0gSC5lcXVhbFxuICAgICAgICBsZXQgaGFzaCAoX3NlZWQ6IGludCkgeCA9IEguaGFzaCB4XG4gICAgICBlbmQpXG4gICAgbGV0IGNyZWF0ZSBzeiA9IGNyZWF0ZSB+cmFuZG9tOmZhbHNlIHN6XG4gICAgbGV0IG9mX3NlcSBpID1cbiAgICAgIGxldCB0YmwgPSBjcmVhdGUgMTYgaW5cbiAgICAgIHJlcGxhY2Vfc2VxIHRibCBpO1xuICAgICAgdGJsXG4gIGVuZFxuXG5lbmRcblxubW9kdWxlIEsyID0gc3RydWN0XG4gIHR5cGUgKCdrMSwgJ2syLCAnZCkgdCA9IE9iakVwaC50XG5cbiAgbGV0IGNyZWF0ZSAoKSA6ICgnazEsJ2syLCdkKSB0ID0gT2JqRXBoLmNyZWF0ZSAyXG5cbiAgbGV0IGdldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IDApXG4gIGxldCBnZXRfa2V5MV9jb3B5ICh0OignazEsJ2syLCdkKSB0KSA6ICdrMSBvcHRpb24gPVxuICAgIG9ial9vcHQgKE9iakVwaC5nZXRfa2V5X2NvcHkgdCAwKVxuICBsZXQgc2V0X2tleTEgKHQ6KCdrMSwnazIsJ2QpIHQpIChrOidrMSkgOiB1bml0ID1cbiAgICBPYmpFcGguc2V0X2tleSB0IDAgKE9iai5yZXByIGspXG4gIGxldCB1bnNldF9rZXkxICh0OignazEsJ2syLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfa2V5IHQgMFxuICBsZXQgY2hlY2tfa2V5MSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IDBcblxuICBsZXQgZ2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfa2V5IHQgMSlcbiAgbGV0IGdldF9rZXkyX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2syIG9wdGlvbiA9XG4gICAgb2JqX29wdCAoT2JqRXBoLmdldF9rZXlfY29weSB0IDEpXG4gIGxldCBzZXRfa2V5MiAodDooJ2sxLCdrMiwnZCkgdCkgKGs6J2syKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgMSAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleTIgKHQ6KCdrMSwnazIsJ2QpIHQpIDogdW5pdCA9IE9iakVwaC51bnNldF9rZXkgdCAxXG4gIGxldCBjaGVja19rZXkyICh0OignazEsJ2syLCdkKSB0KSA6IGJvb2wgPSBPYmpFcGguY2hlY2tfa2V5IHQgMVxuXG5cbiAgbGV0IGJsaXRfa2V5MSAodDE6KCdrMSxfLF8pIHQpICh0MjooJ2sxLF8sXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMCB0MiAwIDFcbiAgbGV0IGJsaXRfa2V5MiAodDE6KF8sJ2syLF8pIHQpICh0MjooXywnazIsXykgdCkgOiB1bml0ID1cbiAgICBPYmpFcGguYmxpdF9rZXkgdDEgMSB0MiAxIDFcbiAgbGV0IGJsaXRfa2V5MTIgKHQxOignazEsJ2syLF8pIHQpICh0MjooJ2sxLCdrMixfKSB0KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSAwIHQyIDAgMlxuXG4gIGxldCBnZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrMSwnazIsJ2QpIHQpIDogJ2Qgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGFfY29weSB0KVxuICBsZXQgc2V0X2RhdGEgKHQ6KCdrMSwnazIsJ2QpIHQpIChkOidkKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfZGF0YSB0IChPYmoucmVwciBkKVxuICBsZXQgdW5zZXRfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2RhdGEgdFxuICBsZXQgY2hlY2tfZGF0YSAodDooJ2sxLCdrMiwnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXyxfLCdkKSB0KSAodDI6KF8sXywnZCkgdCkgOiB1bml0ID0gT2JqRXBoLmJsaXRfZGF0YSB0MSB0MlxuXG4gIG1vZHVsZSBNYWtlU2VlZGVkXG4gICAgICAoSDE6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKVxuICAgICAgKEgyOkhhc2h0YmwuU2VlZGVkSGFzaGVkVHlwZSkgPVxuICAgIEdlbkhhc2hUYWJsZS5NYWtlU2VlZGVkKHN0cnVjdFxuICAgICAgdHlwZSAnYSBjb250YWluZXIgPSAoSDEudCxIMi50LCdhKSB0XG4gICAgICB0eXBlIHQgPSBIMS50ICogSDIudFxuICAgICAgbGV0IGNyZWF0ZSAoazEsazIpIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoKSBpblxuICAgICAgICBzZXRfZGF0YSBjIGQ7XG4gICAgICAgIHNldF9rZXkxIGMgazE7IHNldF9rZXkyIGMgazI7XG4gICAgICAgIGNcbiAgICAgIGxldCBoYXNoIHNlZWQgKGsxLGsyKSA9XG4gICAgICAgIEgxLmhhc2ggc2VlZCBrMSArIEgyLmhhc2ggc2VlZCBrMiAqIDY1NTk5XG4gICAgICBsZXQgZXF1YWwgYyAoazEsazIpID1cbiAgICAgICAgbWF0Y2ggZ2V0X2tleTEgYywgZ2V0X2tleTIgYyB3aXRoXG4gICAgICAgIHwgTm9uZSwgXyB8IF8gLCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICB8IFNvbWUgazEnLCBTb21lIGsyJyAtPlxuICAgICAgICAgICAgaWYgSDEuZXF1YWwgazEgazEnICYmIEgyLmVxdWFsIGsyIGsyJ1xuICAgICAgICAgICAgdGhlbiBHZW5IYXNoVGFibGUuRVRydWUgZWxzZSBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIG1hdGNoIGdldF9rZXkxIGMsIGdldF9rZXkyIGMgd2l0aFxuICAgICAgICB8IE5vbmUsIF8gfCBfICwgTm9uZSAtPiBOb25lXG4gICAgICAgIHwgU29tZSBrMScsIFNvbWUgazInIC0+IFNvbWUgKGsxJywgazInKVxuICAgICAgbGV0IHNldF9rZXlfZGF0YSBjIChrMSxrMikgZCA9XG4gICAgICAgIHVuc2V0X2RhdGEgYztcbiAgICAgICAgc2V0X2tleTEgYyBrMTsgc2V0X2tleTIgYyBrMjtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPSBjaGVja19rZXkxIGMgJiYgY2hlY2tfa2V5MiBjXG4gICAgZW5kKVxuXG4gIG1vZHVsZSBNYWtlKEgxOiBIYXNodGJsLkhhc2hlZFR5cGUpKEgyOiBIYXNodGJsLkhhc2hlZFR5cGUpOlxuICAgIChTIHdpdGggdHlwZSBrZXkgPSBIMS50ICogSDIudCkgPVxuICBzdHJ1Y3RcbiAgICBpbmNsdWRlIE1ha2VTZWVkZWRcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgxLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMS5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDEuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICAgICAgKHN0cnVjdFxuICAgICAgICAgIHR5cGUgdCA9IEgyLnRcbiAgICAgICAgICBsZXQgZXF1YWwgPSBIMi5lcXVhbFxuICAgICAgICAgIGxldCBoYXNoIChfc2VlZDogaW50KSB4ID0gSDIuaGFzaCB4XG4gICAgICAgIGVuZClcbiAgICBsZXQgY3JlYXRlIHN6ID0gY3JlYXRlIH5yYW5kb206ZmFsc2Ugc3pcbiAgICBsZXQgb2Zfc2VxIGkgPVxuICAgICAgbGV0IHRibCA9IGNyZWF0ZSAxNiBpblxuICAgICAgcmVwbGFjZV9zZXEgdGJsIGk7XG4gICAgICB0YmxcbiAgZW5kXG5cbmVuZFxuXG5tb2R1bGUgS24gPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssJ2QpIHQgPSBPYmpFcGgudFxuXG4gIGxldCBjcmVhdGUgbiA6ICgnaywnZCkgdCA9IE9iakVwaC5jcmVhdGUgblxuICBsZXQgbGVuZ3RoIChrOignaywnZCkgdCkgOiBpbnQgPSBPYmpFcGgubGVuZ3RoIGtcblxuICBsZXQgZ2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiAnayBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2tleSB0IG4pXG4gIGxldCBnZXRfa2V5X2NvcHkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIDogJ2sgb3B0aW9uID1cbiAgICBvYmpfb3B0IChPYmpFcGguZ2V0X2tleV9jb3B5IHQgbilcbiAgbGV0IHNldF9rZXkgKHQ6KCdrLCdkKSB0KSAobjppbnQpIChrOidrKSA6IHVuaXQgPVxuICAgIE9iakVwaC5zZXRfa2V5IHQgbiAoT2JqLnJlcHIgaylcbiAgbGV0IHVuc2V0X2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiB1bml0ID0gT2JqRXBoLnVuc2V0X2tleSB0IG5cbiAgbGV0IGNoZWNrX2tleSAodDooJ2ssJ2QpIHQpIChuOmludCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2tleSB0IG5cblxuICBsZXQgYmxpdF9rZXkgKHQxOignaywnZCkgdCkgKG8xOmludCkgKHQyOignaywnZCkgdCkgKG8yOmludCkgKGw6aW50KSA6IHVuaXQgPVxuICAgIE9iakVwaC5ibGl0X2tleSB0MSBvMSB0MiBvMiBsXG5cbiAgbGV0IGdldF9kYXRhICh0OignaywnZCkgdCkgOiAnZCBvcHRpb24gPSBvYmpfb3B0IChPYmpFcGguZ2V0X2RhdGEgdClcbiAgbGV0IGdldF9kYXRhX2NvcHkgKHQ6KCdrLCdkKSB0KSA6ICdkIG9wdGlvbiA9IG9ial9vcHQgKE9iakVwaC5nZXRfZGF0YV9jb3B5IHQpXG4gIGxldCBzZXRfZGF0YSAodDooJ2ssJ2QpIHQpIChkOidkKSA6IHVuaXQgPSBPYmpFcGguc2V0X2RhdGEgdCAoT2JqLnJlcHIgZClcbiAgbGV0IHVuc2V0X2RhdGEgKHQ6KCdrLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGgudW5zZXRfZGF0YSB0XG4gIGxldCBjaGVja19kYXRhICh0OignaywnZCkgdCkgOiBib29sID0gT2JqRXBoLmNoZWNrX2RhdGEgdFxuICBsZXQgYmxpdF9kYXRhICh0MTooXywnZCkgdCkgKHQyOihfLCdkKSB0KSA6IHVuaXQgPSBPYmpFcGguYmxpdF9kYXRhIHQxIHQyXG5cbiAgbW9kdWxlIE1ha2VTZWVkZWQgKEg6SGFzaHRibC5TZWVkZWRIYXNoZWRUeXBlKSA9XG4gICAgR2VuSGFzaFRhYmxlLk1ha2VTZWVkZWQoc3RydWN0XG4gICAgICB0eXBlICdhIGNvbnRhaW5lciA9IChILnQsJ2EpIHRcbiAgICAgIHR5cGUgdCA9IEgudCBhcnJheVxuICAgICAgbGV0IGNyZWF0ZSBrIGQgPVxuICAgICAgICBsZXQgYyA9IGNyZWF0ZSAoQXJyYXkubGVuZ3RoIGspIGluXG4gICAgICAgIHNldF9kYXRhIGMgZDtcbiAgICAgICAgZm9yIGk9MCB0byBBcnJheS5sZW5ndGggayAtMSBkb1xuICAgICAgICAgIHNldF9rZXkgYyBpIGsuKGkpO1xuICAgICAgICBkb25lO1xuICAgICAgICBjXG4gICAgICBsZXQgaGFzaCBzZWVkIGsgPVxuICAgICAgICBsZXQgaCA9IHJlZiAwIGluXG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBoIDo9IEguaGFzaCBzZWVkIGsuKGkpICogNjU1OTkgKyAhaDtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgIWhcbiAgICAgIGxldCBlcXVhbCBjIGsgPVxuICAgICAgICBsZXQgbGVuICA9IEFycmF5Lmxlbmd0aCBrIGluXG4gICAgICAgIGxldCBsZW4nID0gbGVuZ3RoIGMgaW5cbiAgICAgICAgaWYgbGVuICE9IGxlbicgdGhlbiBHZW5IYXNoVGFibGUuRUZhbHNlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsZXQgcmVjIGVxdWFsX2FycmF5IGsgYyBpID1cbiAgICAgICAgICAgIGlmIGkgPCAwIHRoZW4gR2VuSGFzaFRhYmxlLkVUcnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG1hdGNoIGdldF9rZXkgYyBpIHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IEdlbkhhc2hUYWJsZS5FRGVhZFxuICAgICAgICAgICAgICB8IFNvbWUga2kgLT5cbiAgICAgICAgICAgICAgICAgIGlmIEguZXF1YWwgay4oaSkga2lcbiAgICAgICAgICAgICAgICAgIHRoZW4gZXF1YWxfYXJyYXkgayBjIChpLTEpXG4gICAgICAgICAgICAgICAgICBlbHNlIEdlbkhhc2hUYWJsZS5FRmFsc2VcbiAgICAgICAgICBpblxuICAgICAgICAgIGVxdWFsX2FycmF5IGsgYyAobGVuLTEpXG4gICAgICBsZXQgZ2V0X2RhdGEgPSBnZXRfZGF0YVxuICAgICAgbGV0IGdldF9rZXkgYyA9XG4gICAgICAgIGxldCBsZW4gPSBsZW5ndGggYyBpblxuICAgICAgICBpZiBsZW4gPSAwIHRoZW4gU29tZSBbfHxdXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgMCB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgICAgICB8IFNvbWUgazAgLT5cbiAgICAgICAgICAgICAgbGV0IHJlYyBmaWxsIGEgaSA9XG4gICAgICAgICAgICAgICAgaWYgaSA8IDEgdGhlbiBTb21lIGFcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBtYXRjaCBnZXRfa2V5IGMgaSB3aXRoXG4gICAgICAgICAgICAgICAgICB8IE5vbmUgLT4gTm9uZVxuICAgICAgICAgICAgICAgICAgfCBTb21lIGtpIC0+XG4gICAgICAgICAgICAgICAgICAgICAgYS4oaSkgPC0ga2k7XG4gICAgICAgICAgICAgICAgICAgICAgZmlsbCBhIChpLTEpXG4gICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgIGxldCBhID0gQXJyYXkubWFrZSBsZW4gazAgaW5cbiAgICAgICAgICAgICAgZmlsbCBhIChsZW4tMSlcbiAgICAgIGxldCBzZXRfa2V5X2RhdGEgYyBrIGQgPVxuICAgICAgICB1bnNldF9kYXRhIGM7XG4gICAgICAgIGZvciBpPTAgdG8gQXJyYXkubGVuZ3RoIGsgLTEgZG9cbiAgICAgICAgICBzZXRfa2V5IGMgaSBrLihpKTtcbiAgICAgICAgZG9uZTtcbiAgICAgICAgc2V0X2RhdGEgYyBkXG4gICAgICBsZXQgY2hlY2tfa2V5IGMgPVxuICAgICAgICBsZXQgcmVjIGNoZWNrIGMgaSA9XG4gICAgICAgICAgaSA8IDAgfHwgKGNoZWNrX2tleSBjIGkgJiYgY2hlY2sgYyAoaS0xKSkgaW5cbiAgICAgICAgY2hlY2sgYyAobGVuZ3RoIGMgLSAxKVxuICAgIGVuZClcblxuICBtb2R1bGUgTWFrZShIOiBIYXNodGJsLkhhc2hlZFR5cGUpOiAoUyB3aXRoIHR5cGUga2V5ID0gSC50IGFycmF5KSA9XG4gIHN0cnVjdFxuICAgIGluY2x1ZGUgTWFrZVNlZWRlZChzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gSC50XG4gICAgICAgIGxldCBlcXVhbCA9IEguZXF1YWxcbiAgICAgICAgbGV0IGhhc2ggKF9zZWVkOiBpbnQpIHggPSBILmhhc2ggeFxuICAgICAgZW5kKVxuICAgIGxldCBjcmVhdGUgc3ogPSBjcmVhdGUgfnJhbmRvbTpmYWxzZSBzelxuICAgIGxldCBvZl9zZXEgaSA9XG4gICAgICBsZXQgdGJsID0gY3JlYXRlIDE2IGluXG4gICAgICByZXBsYWNlX3NlcSB0YmwgaTtcbiAgICAgIHRibFxuICBlbmRcbmVuZFxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgIE1hcmsgU2hpbndlbGwgYW5kIExlbyBXaGl0ZSwgSmFuZSBTdHJlZXQgRXVyb3BlICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMjAxNS0tMjAxNiBKYW5lIFN0cmVldCBHcm91cCBMTEMgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5leHRlcm5hbCBzcGFjZXRpbWVfZW5hYmxlZCA6IHVuaXQgLT4gYm9vbFxuICA9IFwiY2FtbF9zcGFjZXRpbWVfZW5hYmxlZFwiIFtAQG5vYWxsb2NdXG5cbmxldCBlbmFibGVkID0gc3BhY2V0aW1lX2VuYWJsZWQgKClcblxubGV0IGlmX3NwYWNldGltZV9lbmFibGVkIGYgPVxuICBpZiBlbmFibGVkIHRoZW4gZiAoKSBlbHNlICgpXG5cbm1vZHVsZSBTZXJpZXMgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge1xuICAgIGNoYW5uZWwgOiBvdXRfY2hhbm5lbDtcbiAgICBtdXRhYmxlIGNsb3NlZCA6IGJvb2w7XG4gIH1cblxuICBleHRlcm5hbCB3cml0ZV9tYWdpY19udW1iZXIgOiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfd3JpdGVfbWFnaWNfbnVtYmVyXCJcblxuICBleHRlcm5hbCByZWdpc3Rlcl9jaGFubmVsX2Zvcl9zcGFjZXRpbWUgOiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfcmVnaXN0ZXJfY2hhbm5lbF9mb3Jfc3BhY2V0aW1lXCJcblxuICBsZXQgY3JlYXRlIH5wYXRoID1cbiAgICBpZiBzcGFjZXRpbWVfZW5hYmxlZCAoKSB0aGVuIGJlZ2luXG4gICAgICBsZXQgY2hhbm5lbCA9IG9wZW5fb3V0IHBhdGggaW5cbiAgICAgIHJlZ2lzdGVyX2NoYW5uZWxfZm9yX3NwYWNldGltZSBjaGFubmVsO1xuICAgICAgbGV0IHQgPVxuICAgICAgICB7IGNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICAgIGNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICBpblxuICAgICAgd3JpdGVfbWFnaWNfbnVtYmVyIHQuY2hhbm5lbDtcbiAgICAgIHRcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgeyBjaGFubmVsID0gc3Rkb3V0OyAgKCogYXJiaXRyYXJ5IHZhbHVlICopXG4gICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgZXh0ZXJuYWwgc2F2ZV9ldmVudCA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IGV2ZW50X25hbWU6c3RyaW5nIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV9zYXZlX2V2ZW50XCJcblxuICBsZXQgc2F2ZV9ldmVudCA/dGltZSB0IH5ldmVudF9uYW1lID1cbiAgICBpZl9zcGFjZXRpbWVfZW5hYmxlZCAoZnVuICgpIC0+XG4gICAgICBzYXZlX2V2ZW50ID90aW1lIHQuY2hhbm5lbCB+ZXZlbnRfbmFtZSlcblxuICBleHRlcm5hbCBzYXZlX3RyaWUgOiA/dGltZTpmbG9hdCAtPiBvdXRfY2hhbm5lbCAtPiB1bml0XG4gICAgPSBcImNhbWxfc3BhY2V0aW1lX29ubHlfd29ya3NfZm9yX25hdGl2ZV9jb2RlXCJcbiAgICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV90cmllXCJcblxuICBsZXQgc2F2ZV9hbmRfY2xvc2UgP3RpbWUgdCA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgaWYgdC5jbG9zZWQgdGhlbiBmYWlsd2l0aCBcIlNlcmllcyBpcyBjbG9zZWRcIjtcbiAgICAgIHNhdmVfdHJpZSA/dGltZSB0LmNoYW5uZWw7XG4gICAgICBjbG9zZV9vdXQgdC5jaGFubmVsO1xuICAgICAgdC5jbG9zZWQgPC0gdHJ1ZSlcbmVuZFxuXG5tb2R1bGUgU25hcHNob3QgPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgdGFrZSA6ID90aW1lOmZsb2F0IC0+IG91dF9jaGFubmVsIC0+IHVuaXRcbiAgICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgICAgXCJjYW1sX3NwYWNldGltZV90YWtlX3NuYXBzaG90XCJcblxuICBsZXQgdGFrZSA/dGltZSB7IFNlcmllcy5jbG9zZWQ7IGNoYW5uZWwgfSA9XG4gICAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgICAgaWYgY2xvc2VkIHRoZW4gZmFpbHdpdGggXCJTZXJpZXMgaXMgY2xvc2VkXCI7XG4gICAgICBHYy5taW5vciAoKTtcbiAgICAgIHRha2UgP3RpbWUgY2hhbm5lbClcbmVuZFxuXG5leHRlcm5hbCBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIDogZXZlbnRfbmFtZTpzdHJpbmcgLT4gdW5pdFxuICA9IFwiY2FtbF9zcGFjZXRpbWVfb25seV93b3Jrc19mb3JfbmF0aXZlX2NvZGVcIlxuICAgIFwiY2FtbF9zcGFjZXRpbWVfc2F2ZV9ldmVudF9mb3JfYXV0b21hdGljX3NuYXBzaG90c1wiXG5cbmxldCBzYXZlX2V2ZW50X2Zvcl9hdXRvbWF0aWNfc25hcHNob3RzIH5ldmVudF9uYW1lID1cbiAgaWZfc3BhY2V0aW1lX2VuYWJsZWQgKGZ1biAoKSAtPlxuICAgIHNhdmVfZXZlbnRfZm9yX2F1dG9tYXRpY19zbmFwc2hvdHMgfmV2ZW50X25hbWUpXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgTWFudWVsIFNlcnJhbm8gZXQgWGF2aWVyIExlcm95LCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAyMDAwIEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqIE1vZHVsZSBbQmlnYXJyYXldOiBsYXJnZSwgbXVsdGktZGltZW5zaW9uYWwsIG51bWVyaWNhbCBhcnJheXMgKilcblxuKCogVGhlc2UgdHlwZXMgaW4gbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgdGFibGVzIGluXG4gICAuLi90eXBpbmcvdHlwZW9wdC5tbCAqKVxuXG50eXBlIGZsb2F0MzJfZWx0ID0gRmxvYXQzMl9lbHRcbnR5cGUgZmxvYXQ2NF9lbHQgPSBGbG9hdDY0X2VsdFxudHlwZSBpbnQ4X3NpZ25lZF9lbHQgPSBJbnQ4X3NpZ25lZF9lbHRcbnR5cGUgaW50OF91bnNpZ25lZF9lbHQgPSBJbnQ4X3Vuc2lnbmVkX2VsdFxudHlwZSBpbnQxNl9zaWduZWRfZWx0ID0gSW50MTZfc2lnbmVkX2VsdFxudHlwZSBpbnQxNl91bnNpZ25lZF9lbHQgPSBJbnQxNl91bnNpZ25lZF9lbHRcbnR5cGUgaW50MzJfZWx0ID0gSW50MzJfZWx0XG50eXBlIGludDY0X2VsdCA9IEludDY0X2VsdFxudHlwZSBpbnRfZWx0ID0gSW50X2VsdFxudHlwZSBuYXRpdmVpbnRfZWx0ID0gTmF0aXZlaW50X2VsdFxudHlwZSBjb21wbGV4MzJfZWx0ID0gQ29tcGxleDMyX2VsdFxudHlwZSBjb21wbGV4NjRfZWx0ID0gQ29tcGxleDY0X2VsdFxuXG50eXBlICgnYSwgJ2IpIGtpbmQgPVxuICAgIEZsb2F0MzIgOiAoZmxvYXQsIGZsb2F0MzJfZWx0KSBraW5kXG4gIHwgRmxvYXQ2NCA6IChmbG9hdCwgZmxvYXQ2NF9lbHQpIGtpbmRcbiAgfCBJbnQ4X3NpZ25lZCA6IChpbnQsIGludDhfc2lnbmVkX2VsdCkga2luZFxuICB8IEludDhfdW5zaWduZWQgOiAoaW50LCBpbnQ4X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDE2X3NpZ25lZCA6IChpbnQsIGludDE2X3NpZ25lZF9lbHQpIGtpbmRcbiAgfCBJbnQxNl91bnNpZ25lZCA6IChpbnQsIGludDE2X3Vuc2lnbmVkX2VsdCkga2luZFxuICB8IEludDMyIDogKGludDMyLCBpbnQzMl9lbHQpIGtpbmRcbiAgfCBJbnQ2NCA6IChpbnQ2NCwgaW50NjRfZWx0KSBraW5kXG4gIHwgSW50IDogKGludCwgaW50X2VsdCkga2luZFxuICB8IE5hdGl2ZWludCA6IChuYXRpdmVpbnQsIG5hdGl2ZWludF9lbHQpIGtpbmRcbiAgfCBDb21wbGV4MzIgOiAoQ29tcGxleC50LCBjb21wbGV4MzJfZWx0KSBraW5kXG4gIHwgQ29tcGxleDY0IDogKENvbXBsZXgudCwgY29tcGxleDY0X2VsdCkga2luZFxuICB8IENoYXIgOiAoY2hhciwgaW50OF91bnNpZ25lZF9lbHQpIGtpbmRcblxudHlwZSBjX2xheW91dCA9IENfbGF5b3V0X3R5cFxudHlwZSBmb3J0cmFuX2xheW91dCA9IEZvcnRyYW5fbGF5b3V0X3R5cCAoKiopXG5cbnR5cGUgJ2EgbGF5b3V0ID1cbiAgICBDX2xheW91dDogY19sYXlvdXQgbGF5b3V0XG4gIHwgRm9ydHJhbl9sYXlvdXQ6IGZvcnRyYW5fbGF5b3V0IGxheW91dFxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfa2luZCBlbnVtZXJhdGlvblxuICAgaW4gYmlnYXJyYXkuaCAqKVxuXG5sZXQgZmxvYXQzMiA9IEZsb2F0MzJcbmxldCBmbG9hdDY0ID0gRmxvYXQ2NFxubGV0IGludDhfc2lnbmVkID0gSW50OF9zaWduZWRcbmxldCBpbnQ4X3Vuc2lnbmVkID0gSW50OF91bnNpZ25lZFxubGV0IGludDE2X3NpZ25lZCA9IEludDE2X3NpZ25lZFxubGV0IGludDE2X3Vuc2lnbmVkID0gSW50MTZfdW5zaWduZWRcbmxldCBpbnQzMiA9IEludDMyXG5sZXQgaW50NjQgPSBJbnQ2NFxubGV0IGludCA9IEludFxubGV0IG5hdGl2ZWludCA9IE5hdGl2ZWludFxubGV0IGNvbXBsZXgzMiA9IENvbXBsZXgzMlxubGV0IGNvbXBsZXg2NCA9IENvbXBsZXg2NFxubGV0IGNoYXIgPSBDaGFyXG5cbmxldCBraW5kX3NpemVfaW5fYnl0ZXMgOiB0eXBlIGEgYi4gKGEsIGIpIGtpbmQgLT4gaW50ID0gZnVuY3Rpb25cbiAgfCBGbG9hdDMyIC0+IDRcbiAgfCBGbG9hdDY0IC0+IDhcbiAgfCBJbnQ4X3NpZ25lZCAtPiAxXG4gIHwgSW50OF91bnNpZ25lZCAtPiAxXG4gIHwgSW50MTZfc2lnbmVkIC0+IDJcbiAgfCBJbnQxNl91bnNpZ25lZCAtPiAyXG4gIHwgSW50MzIgLT4gNFxuICB8IEludDY0IC0+IDhcbiAgfCBJbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBOYXRpdmVpbnQgLT4gU3lzLndvcmRfc2l6ZSAvIDhcbiAgfCBDb21wbGV4MzIgLT4gOFxuICB8IENvbXBsZXg2NCAtPiAxNlxuICB8IENoYXIgLT4gMVxuXG4oKiBLZWVwIHRob3NlIGNvbnN0YW50cyBpbiBzeW5jIHdpdGggdGhlIGNhbWxfYmFfbGF5b3V0IGVudW1lcmF0aW9uXG4gICBpbiBiaWdhcnJheS5oICopXG5cbmxldCBjX2xheW91dCA9IENfbGF5b3V0XG5sZXQgZm9ydHJhbl9sYXlvdXQgPSBGb3J0cmFuX2xheW91dFxuXG5tb2R1bGUgR2VuYXJyYXkgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdFxuICBleHRlcm5hbCBjcmVhdGU6ICgnYSwgJ2IpIGtpbmQgLT4gJ2MgbGF5b3V0IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgdFxuICAgICA9IFwiY2FtbF9iYV9jcmVhdGVcIlxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCBhcnJheSAtPiAnYVxuICAgICA9IFwiY2FtbF9iYV9nZXRfZ2VuZXJpY1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IGFycmF5IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcImNhbWxfYmFfc2V0X2dlbmVyaWNcIlxuICBleHRlcm5hbCBudW1fZGltczogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCJjYW1sX2JhX251bV9kaW1zXCJcbiAgZXh0ZXJuYWwgbnRoX2RpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCA9IFwiY2FtbF9iYV9kaW1cIlxuICBsZXQgZGltcyBhID1cbiAgICBsZXQgbiA9IG51bV9kaW1zIGEgaW5cbiAgICBsZXQgZCA9IEFycmF5Lm1ha2UgbiAwIGluXG4gICAgZm9yIGkgPSAwIHRvIG4tMSBkbyBkLihpKSA8LSBudGhfZGltIGEgaSBkb25lO1xuICAgIGRcblxuICBleHRlcm5hbCBraW5kOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiKSBraW5kID0gXCJjYW1sX2JhX2tpbmRcIlxuICBleHRlcm5hbCBsYXlvdXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICdjIGxheW91dCA9IFwiY2FtbF9iYV9sYXlvdXRcIlxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKEFycmF5LmZvbGRfbGVmdCAoICogKSAxIChkaW1zIGFycikpXG5cbiAgZXh0ZXJuYWwgc3ViX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgY19sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgZXh0ZXJuYWwgc3ViX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHNsaWNlX2xlZnQ6ICgnYSwgJ2IsIGNfbGF5b3V0KSB0IC0+IGludCBhcnJheSAtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zbGljZVwiXG4gIGV4dGVybmFsIHNsaWNlX3JpZ2h0OiAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgYXJyYXkgLT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc2xpY2VcIlxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0XG4gICAgID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuZW5kXG5cbm1vZHVsZSBBcnJheTAgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfHxdXG4gIGxldCBnZXQgYXJyID0gR2VuYXJyYXkuZ2V0IGFyciBbfHxdXG4gIGxldCBzZXQgYXJyID0gR2VuYXJyYXkuc2V0IGFyciBbfHxdXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID0ga2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycilcblxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuXG4gIGxldCBvZl92YWx1ZSBraW5kIGxheW91dCB2ID1cbiAgICBsZXQgYSA9IGNyZWF0ZSBraW5kIGxheW91dCBpblxuICAgIHNldCBhIHY7XG4gICAgYVxuZW5kXG5cbm1vZHVsZSBBcnJheTEgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltID1cbiAgICBHZW5hcnJheS5jcmVhdGUga2luZCBsYXlvdXQgW3xkaW18XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzFcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlY2FtbF9iYV9zZXRfMVwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8xXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMVwiXG4gIGV4dGVybmFsIGRpbTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGtpbmQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IpIGtpbmQgPSBcImNhbWxfYmFfa2luZFwiXG4gIGV4dGVybmFsIGxheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2MgbGF5b3V0ID0gXCJjYW1sX2JhX2xheW91dFwiXG5cbiAgZXh0ZXJuYWwgY2hhbmdlX2xheW91dDogKCdhLCAnYiwgJ2MpIHQgLT4gJ2QgbGF5b3V0IC0+ICgnYSwgJ2IsICdkKSB0XG4gICAgPSBcImNhbWxfYmFfY2hhbmdlX2xheW91dFwiXG5cbiAgbGV0IHNpemVfaW5fYnl0ZXMgYXJyID1cbiAgICAoa2luZF9zaXplX2luX2J5dGVzIChraW5kIGFycikpICogKGRpbSBhcnIpXG5cbiAgZXh0ZXJuYWwgc3ViOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsICdjKSB0ID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZSAodHlwZSB0KSAoYSA6IChfLCBfLCB0KSBHZW5hcnJheS50KSBuID1cbiAgICBtYXRjaCBsYXlvdXQgYSB3aXRoXG4gICAgfCBDX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfbGVmdCBhIFt8bnxdIDogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gICAgfCBGb3J0cmFuX2xheW91dCAtPiAoR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XTogKF8sIF8sIHQpIEdlbmFycmF5LnQpXG4gIGV4dGVybmFsIGJsaXQ6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSB0IC0+IHVuaXQgPSBcImNhbWxfYmFfYmxpdFwiXG4gIGV4dGVybmFsIGZpbGw6ICgnYSwgJ2IsICdjKSB0IC0+ICdhIC0+IHVuaXQgPSBcImNhbWxfYmFfZmlsbFwiXG4gIGxldCBvZl9hcnJheSAodHlwZSB0KSBraW5kIChsYXlvdXQ6IHQgbGF5b3V0KSBkYXRhID1cbiAgICBsZXQgYmEgPSBjcmVhdGUga2luZCBsYXlvdXQgKEFycmF5Lmxlbmd0aCBkYXRhKSBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIGRhdGEgLSAxIGRvIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIGRhdGEuKGkpIGRvbmU7XG4gICAgYmFcbmVuZFxuXG5tb2R1bGUgQXJyYXkyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICBsZXQgY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiA9XG4gICAgR2VuYXJyYXkuY3JlYXRlIGtpbmQgbGF5b3V0IFt8ZGltMTsgZGltMnxdXG4gIGV4dGVybmFsIGdldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiAnYSA9IFwiJWNhbWxfYmFfcmVmXzJcIlxuICBleHRlcm5hbCBzZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWNhbWxfYmFfc2V0XzJcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhXG4gICAgID0gXCIlY2FtbF9iYV91bnNhZmVfcmVmXzJcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgICAgPSBcIiVjYW1sX2JhX3Vuc2FmZV9zZXRfMlwiXG4gIGV4dGVybmFsIGRpbTE6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzFcIlxuICBleHRlcm5hbCBkaW0yOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8yXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKVxuXG4gIGV4dGVybmFsIHN1Yl9sZWZ0OiAoJ2EsICdiLCBjX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGNfbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGV4dGVybmFsIHN1Yl9yaWdodDpcbiAgICAoJ2EsICdiLCBmb3J0cmFuX2xheW91dCkgdCAtPiBpbnQgLT4gaW50IC0+ICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0XG4gICAgID0gXCJjYW1sX2JhX3N1YlwiXG4gIGxldCBzbGljZV9sZWZ0IGEgbiA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG58XVxuICBsZXQgc2xpY2VfcmlnaHQgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGxldCBvZnMgPVxuICAgICAgbWF0Y2ggbGF5b3V0IHdpdGhcbiAgICAgICAgQ19sYXlvdXQgLT4gMFxuICAgICAgfCBGb3J0cmFuX2xheW91dCAtPiAxXG4gICAgaW5cbiAgICBmb3IgaSA9IDAgdG8gZGltMSAtIDEgZG9cbiAgICAgIGxldCByb3cgPSBkYXRhLihpKSBpblxuICAgICAgaWYgQXJyYXkubGVuZ3RoIHJvdyA8PiBkaW0yIHRoZW5cbiAgICAgICAgaW52YWxpZF9hcmcoXCJCaWdhcnJheS5BcnJheTIub2ZfYXJyYXk6IG5vbi1yZWN0YW5ndWxhciBkYXRhXCIpO1xuICAgICAgZm9yIGogPSAwIHRvIGRpbTIgLSAxIGRvXG4gICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSByb3cuKGopXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbm1vZHVsZSBBcnJheTMgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gIGxldCBjcmVhdGUga2luZCBsYXlvdXQgZGltMSBkaW0yIGRpbTMgPVxuICAgIEdlbmFycmF5LmNyZWF0ZSBraW5kIGxheW91dCBbfGRpbTE7IGRpbTI7IGRpbTN8XVxuICBleHRlcm5hbCBnZXQ6ICgnYSwgJ2IsICdjKSB0IC0+IGludCAtPiBpbnQgLT4gaW50IC0+ICdhID0gXCIlY2FtbF9iYV9yZWZfM1wiXG4gIGV4dGVybmFsIHNldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfc2V0XzNcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0OiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgLT4gaW50IC0+IGludCAtPiAnYVxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3JlZl8zXCJcbiAgZXh0ZXJuYWwgdW5zYWZlX3NldDogKCdhLCAnYiwgJ2MpIHQgLT4gaW50IC0+IGludCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICAgICA9IFwiJWNhbWxfYmFfdW5zYWZlX3NldF8zXCJcbiAgZXh0ZXJuYWwgZGltMTogKCdhLCAnYiwgJ2MpIHQgLT4gaW50ID0gXCIlY2FtbF9iYV9kaW1fMVwiXG4gIGV4dGVybmFsIGRpbTI6ICgnYSwgJ2IsICdjKSB0IC0+IGludCA9IFwiJWNhbWxfYmFfZGltXzJcIlxuICBleHRlcm5hbCBkaW0zOiAoJ2EsICdiLCAnYykgdCAtPiBpbnQgPSBcIiVjYW1sX2JhX2RpbV8zXCJcbiAgZXh0ZXJuYWwga2luZDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYikga2luZCA9IFwiY2FtbF9iYV9raW5kXCJcbiAgZXh0ZXJuYWwgbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnYyBsYXlvdXQgPSBcImNhbWxfYmFfbGF5b3V0XCJcblxuICBleHRlcm5hbCBjaGFuZ2VfbGF5b3V0OiAoJ2EsICdiLCAnYykgdCAtPiAnZCBsYXlvdXQgLT4gKCdhLCAnYiwgJ2QpIHRcbiAgICA9IFwiY2FtbF9iYV9jaGFuZ2VfbGF5b3V0XCJcblxuICBsZXQgc2l6ZV9pbl9ieXRlcyBhcnIgPVxuICAgIChraW5kX3NpemVfaW5fYnl0ZXMgKGtpbmQgYXJyKSkgKiAoZGltMSBhcnIpICogKGRpbTIgYXJyKSAqIChkaW0zIGFycilcblxuICBleHRlcm5hbCBzdWJfbGVmdDogKCdhLCAnYiwgY19sYXlvdXQpIHQgLT4gaW50IC0+IGludCAtPiAoJ2EsICdiLCBjX2xheW91dCkgdFxuICAgICA9IFwiY2FtbF9iYV9zdWJcIlxuICBleHRlcm5hbCBzdWJfcmlnaHQ6XG4gICAgICgnYSwgJ2IsIGZvcnRyYW5fbGF5b3V0KSB0IC0+IGludCAtPiBpbnQgLT4gKCdhLCAnYiwgZm9ydHJhbl9sYXlvdXQpIHRcbiAgICAgPSBcImNhbWxfYmFfc3ViXCJcbiAgbGV0IHNsaWNlX2xlZnRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX2xlZnQgYSBbfG47IG18XVxuICBsZXQgc2xpY2VfcmlnaHRfMSBhIG4gbSA9IEdlbmFycmF5LnNsaWNlX3JpZ2h0IGEgW3xuOyBtfF1cbiAgbGV0IHNsaWNlX2xlZnRfMiBhIG4gPSBHZW5hcnJheS5zbGljZV9sZWZ0IGEgW3xufF1cbiAgbGV0IHNsaWNlX3JpZ2h0XzIgYSBuID0gR2VuYXJyYXkuc2xpY2VfcmlnaHQgYSBbfG58XVxuICBleHRlcm5hbCBibGl0OiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgdCAtPiB1bml0ID0gXCJjYW1sX2JhX2JsaXRcIlxuICBleHRlcm5hbCBmaWxsOiAoJ2EsICdiLCAnYykgdCAtPiAnYSAtPiB1bml0ID0gXCJjYW1sX2JhX2ZpbGxcIlxuICBsZXQgb2ZfYXJyYXkgKHR5cGUgdCkga2luZCAobGF5b3V0OiB0IGxheW91dCkgZGF0YSA9XG4gICAgbGV0IGRpbTEgPSBBcnJheS5sZW5ndGggZGF0YSBpblxuICAgIGxldCBkaW0yID0gaWYgZGltMSA9IDAgdGhlbiAwIGVsc2UgQXJyYXkubGVuZ3RoIGRhdGEuKDApIGluXG4gICAgbGV0IGRpbTMgPSBpZiBkaW0yID0gMCB0aGVuIDAgZWxzZSBBcnJheS5sZW5ndGggZGF0YS4oMCkuKDApIGluXG4gICAgbGV0IGJhID0gY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBkaW0zIGluXG4gICAgbGV0IG9mcyA9XG4gICAgICBtYXRjaCBsYXlvdXQgd2l0aFxuICAgICAgICBDX2xheW91dCAtPiAwXG4gICAgICB8IEZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICBpblxuICAgIGZvciBpID0gMCB0byBkaW0xIC0gMSBkb1xuICAgICAgbGV0IHJvdyA9IGRhdGEuKGkpIGluXG4gICAgICBpZiBBcnJheS5sZW5ndGggcm93IDw+IGRpbTIgdGhlblxuICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICBmb3IgaiA9IDAgdG8gZGltMiAtIDEgZG9cbiAgICAgICAgbGV0IGNvbCA9IHJvdy4oaikgaW5cbiAgICAgICAgaWYgQXJyYXkubGVuZ3RoIGNvbCA8PiBkaW0zIHRoZW5cbiAgICAgICAgICBpbnZhbGlkX2FyZyhcIkJpZ2FycmF5LkFycmF5My5vZl9hcnJheTogbm9uLWN1YmljIGRhdGFcIik7XG4gICAgICAgIGZvciBrID0gMCB0byBkaW0zIC0gMSBkb1xuICAgICAgICAgIHVuc2FmZV9zZXQgYmEgKGkgKyBvZnMpIChqICsgb2ZzKSAoayArIG9mcykgY29sLihrKVxuICAgICAgICBkb25lXG4gICAgICBkb25lXG4gICAgZG9uZTtcbiAgICBiYVxuZW5kXG5cbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MDogKCdhLCAnYiwgJ2MpIEFycmF5MC50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MTogKCdhLCAnYiwgJ2MpIEFycmF5MS50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MjogKCdhLCAnYiwgJ2MpIEFycmF5Mi50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGdlbmFycmF5X29mX2FycmF5MzogKCdhLCAnYiwgJ2MpIEFycmF5My50IC0+ICgnYSwgJ2IsICdjKSBHZW5hcnJheS50XG4gICA9IFwiJWlkZW50aXR5XCJcbmxldCBhcnJheTBfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAwIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkwX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTFfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAxIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkxX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTJfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAyIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkyX29mX2dlbmFycmF5XCJcbmxldCBhcnJheTNfb2ZfZ2VuYXJyYXkgYSA9XG4gIGlmIEdlbmFycmF5Lm51bV9kaW1zIGEgPSAzIHRoZW4gYVxuICBlbHNlIGludmFsaWRfYXJnIFwiQmlnYXJyYXkuYXJyYXkzX29mX2dlbmFycmF5XCJcblxuZXh0ZXJuYWwgcmVzaGFwZTpcbiAgICgnYSwgJ2IsICdjKSBHZW5hcnJheS50IC0+IGludCBhcnJheSAtPiAoJ2EsICdiLCAnYykgR2VuYXJyYXkudFxuICAgPSBcImNhbWxfYmFfcmVzaGFwZVwiXG5sZXQgcmVzaGFwZV8wIGEgPSByZXNoYXBlIGEgW3x8XVxubGV0IHJlc2hhcGVfMSBhIGRpbTEgPSByZXNoYXBlIGEgW3xkaW0xfF1cbmxldCByZXNoYXBlXzIgYSBkaW0xIGRpbTIgPSByZXNoYXBlIGEgW3xkaW0xO2RpbTJ8XVxubGV0IHJlc2hhcGVfMyBhIGRpbTEgZGltMiBkaW0zID0gcmVzaGFwZSBhIFt8ZGltMTtkaW0yO2RpbTN8XVxuXG4oKiBGb3JjZSBjYW1sX2JhX2dldF97MSwyLDMsTn0gdG8gYmUgbGlua2VkIGluLCBzaW5jZSB3ZSBkb24ndCByZWZlclxuICAgdG8gdGhvc2UgcHJpbWl0aXZlcyBkaXJlY3RseSBpbiB0aGlzIGZpbGUgKilcblxubGV0IF8gPVxuICBsZXQgXyA9IEdlbmFycmF5LmdldCBpblxuICBsZXQgXyA9IEFycmF5MS5nZXQgaW5cbiAgbGV0IF8gPSBBcnJheTIuZ2V0IGluXG4gIGxldCBfID0gQXJyYXkzLmdldCBpblxuICAoKVxuXG5bQEBAb2NhbWwud2FybmluZyBcIi0zMlwiXVxuZXh0ZXJuYWwgZ2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX2dldF8xXCJcbmV4dGVybmFsIGdldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9nZXRfMlwiXG5leHRlcm5hbCBnZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfZ2V0XzNcIlxuZXh0ZXJuYWwgc2V0MTogdW5pdCAtPiB1bml0ID0gXCJjYW1sX2JhX3NldF8xXCJcbmV4dGVybmFsIHNldDI6IHVuaXQgLT4gdW5pdCA9IFwiY2FtbF9iYV9zZXRfMlwiXG5leHRlcm5hbCBzZXQzOiB1bml0IC0+IHVuaXQgPSBcImNhbWxfYmFfc2V0XzNcIlxuIixudWxsLCJvcGVuIEJyclxub3BlbiBCcnJfaW9cbm9wZW4gQnJyX3dlYmNyeXB0b1xub3BlbiBGdXQuUmVzdWx0X3N5bnRheFxuXG5sZXQgc3ltX2tleV9nZW4gPVxuICBsZXQgbmFtZSA9IENyeXB0b19hbGdvLmFlc19jYmMgYW5kIGxlbmd0aCA9IDEyOCBpblxuICBDcnlwdG9fYWxnby5BZXNfa2V5X2dlbl9wYXJhbXMudiB+bmFtZSB+bGVuZ3RoICgpXG5cbmxldCBzeW1fZXhwb3J0YWJsZV9rZXkgcyA9XG4gIGxldCB1c2FnZXMgPSBDcnlwdG9fa2V5LlVzYWdlLlsgZW5jcnlwdDsgZGVjcnlwdDsgXSBpblxuICBTdWJ0bGVfY3J5cHRvLmdlbmVyYXRlX2tleSBzIHN5bV9rZXlfZ2VuIH5leHRyYWN0YWJsZTp0cnVlIH51c2FnZXNcblxubGV0IGl2ID1cbiAgW3wgMHg0ODsgMHgzYjsgMHgyZTsgMHhjNDsgMHg0NDsgMHgwZDsgMHgyYzsgMHhiMDsgMHg0NjsgMHhmNDsgMHhkNTsgMHg3NjsgMHhhMTsgMHg5NDsgMHgyNjsgMHgwZDsgfF1cbmxldCBpdiA9IFRhcnJheS5vZl9pbnRfYXJyYXkgVGFycmF5LlVpbnQ4IGl2IHw+IFRhcnJheS5idWZmZXJcblxubGV0IHN5bV9hbGdvID9pdiAoKSA9XG4gIGxldCBpdiA9IG1hdGNoIGl2IHdpdGhcbiAgICB8IFNvbWUgaXYgLT4gaXZcbiAgICB8IE5vbmUgLT5cbiAgICAgIGxldCBpdiA9IFRhcnJheS5jcmVhdGUgVGFycmF5LlVpbnQ4IDE2IGluXG4gICAgICBsZXQgKCkgPSBDcnlwdG8uc2V0X3JhbmRvbV92YWx1ZXMgQ3J5cHRvLmNyeXB0byBpdiBpbiBUYXJyYXkuYnVmZmVyIGl2IGluXG4gIENyeXB0b19hbGdvLkFlc19jYmNfcGFyYW1zLnYgfml2ICgpXG5cbmxldCBzeW1fZW5jcnlwdCA/aXYgcyBrZXkgY2xlYXIgPVxuICBTdWJ0bGVfY3J5cHRvLmVuY3J5cHQgcyAoc3ltX2FsZ28gP2l2ICgpKSBrZXkgY2xlYXJcblxubGV0IHN5bV9kZWNyeXB0ID9pdiBzIGtleSBjaXBoZXIgPVxuICBTdWJ0bGVfY3J5cHRvLmRlY3J5cHQgcyAoc3ltX2FsZ28gP2l2ICgpKSBrZXkgY2lwaGVyXG5cbmxldCBwYXN0ZXVyID0gSnN0ci52IFwicGFzdGV1clwiXG5sZXQgZXJyX2VsZW1lbnRfcGFzdGV1cl9ub3RfZm91bmQgPSBKc3RyLnYgXCJObyBlbGVtZW50IHdpdGggaWQgJ3Bhc3RldXInIGZvdW5kXCJcbmxldCBlcnJfZWxlbWVudF9wYXN0ZV9ub3RfZm91bmQgPSBKc3RyLnYgXCJObyBwYXN0ZSBlbGVtZW50IGZvdW5kXCJcbmxldCBlcnJfZWxlbWVudF9wYXN0ZV9pc19ub3RfYV9zdHJpbmcgPSBKc3RyLnYgXCJQYXN0ZSBlbGVtZW50IG11c3QgYmUgYSBzdHJpbmdcIlxubGV0IGVycl9pbnZhbGlkX2hleF92YWx1ZSA9IEpzdHIudiBcIkludmFsaWQgaGV4IHZhbHVlXCJcbmxldCBlcnJfaW52YWxpZF9rZXkgPSBKc3RyLnYgXCJJbnZhbGlkIGtleSFcIlxubGV0IG9uID0gSnN0ci52IFwib25cIlxubGV0IHBvc3QgPSBKc3RyLnYgXCJQT1NUXCJcblxubGV0ICggPC4+ICkgZiBnID0gZnVuIHggLT4gZiAoZyB4KVxubGV0IGlkIHggPSB4XG5cbmxldCBtYWtlX3BhdGggP2tleSA/bG4gP2hsID9yYXcgY29kZSA9XG4gIGxldCBhcmdzID0gbWF0Y2ggbG4sIGhsLCByYXcgd2l0aFxuICAgIHwgU29tZSB0cnVlLCBTb21lIHYsIFNvbWUgdHJ1ZSAtPiBGbXQuc3RyIFwiP2xuPXRydWUmaGw9JXMmcmF3PXRydWVcIiB2XG4gICAgfCBTb21lIHRydWUsIFNvbWUgdiwgKFNvbWUgZmFsc2UgfCBOb25lKSAtPiBGbXQuc3RyIFwiP2xuPXRydWUmaGw9JXNcIiB2XG4gICAgfCBTb21lIHRydWUsIE5vbmUsIFNvbWUgdHJ1ZSAtPiBGbXQuc3RyIFwiP2xuPXRydWUmcmF3PXRydWVcIlxuICAgIHwgKFNvbWUgZmFsc2UgfCBOb25lKSwgU29tZSB2LCBTb21lIHRydWUgLT4gRm10LnN0ciBcIj9obD0lcyZyYXc9dHJ1ZVwiIHZcbiAgICB8IChTb21lIGZhbHNlIHwgTm9uZSksIFNvbWUgdiwgKFNvbWUgZmFsc2UgfCBOb25lKSAtPiBGbXQuc3RyIFwiP2hsPSVzXCIgdlxuICAgIHwgU29tZSB0cnVlLCBOb25lLCAoU29tZSBmYWxzZSB8IE5vbmUpIC0+IEZtdC5zdHIgXCI/bG49dHJ1ZVwiXG4gICAgfCAoU29tZSBmYWxzZSB8IE5vbmUpLCBOb25lLCBTb21lIHRydWUgLT4gRm10LnN0ciBcIj9yYXc9dHJ1ZVwiXG4gICAgfCAoU29tZSBmYWxzZSB8IE5vbmUpLCBOb25lLCAoU29tZSBmYWxzZSB8IE5vbmUpIC0+IFwiXCIgaW5cbiAgbWF0Y2gga2V5IHdpdGhcbiAgfCBTb21lIGtleSAtPlxuICAgIEZtdC5rc3RyIChGdXQub2sgPC4+IEpzdHIub2Zfc3RyaW5nKSBcIiVzJXMjJXNcIiAoSnN0ci50b19zdHJpbmcgY29kZSkgYXJncyAoSnN0ci50b19zdHJpbmcga2V5KVxuICB8IE5vbmUgLT4gRm10LmtzdHIgKEZ1dC5vayA8Lj4gSnN0ci5vZl9zdHJpbmcpIFwiJXMlc1wiIChKc3RyLnRvX3N0cmluZyBjb2RlKSBhcmdzXG5cbmxldCBwb3N0ICgpID1cbiAgbWF0Y2ggRG9jdW1lbnQuZmluZF9lbF9ieV9pZCBHLmRvY3VtZW50IHBhc3RldXIgd2l0aFxuICB8IE5vbmUgLT5cbiAgICBDb25zb2xlLihlcnJvciBbc3RyIFwiTm8gZWxlbWVudCB3aXRoIGlkICclcycgZm91bmRcIjsgcGFzdGV1cl0pIDtcbiAgICBGdXQucmV0dXJuIChFcnJvciAoSnYuRXJyb3IudiBlcnJfZWxlbWVudF9wYXN0ZXVyX25vdF9mb3VuZCkpXG4gIHwgU29tZSBlbCAtPlxuICAgIGxldCBmb3JtID0gRm9ybS5vZl9lbCBlbCBpblxuICAgIGxldCBkYXRhID0gRm9ybS5EYXRhLm9mX2Zvcm0gZm9ybSBpblxuICAgICggbWF0Y2ggRm9ybS5EYXRhLihmaW5kIGRhdGEgKEpzdHIudiBcInBhc3RlXCIpKSwgRm9ybS5EYXRhLihmaW5kIGRhdGEgKEpzdHIudiBcImVuY3J5cHRlZFwiKSkgd2l0aFxuICAgIHwgU29tZSAoYFN0cmluZyBzdHIpLCBTb21lIChgU3RyaW5nIGVuY3J5cHRlZCkgd2hlbiBKc3RyLmVxdWFsIGVuY3J5cHRlZCBvbiAtPlxuICAgICAgbGV0IHN1YnRsID0gQ3J5cHRvLnN1YnRsZSBDcnlwdG8uY3J5cHRvIGluXG4gICAgICBsZXQgY2xlYXIgPSBUYXJyYXkub2ZfanN0ciBzdHIgaW5cbiAgICAgIGxldCoga2V5ICA9IHN5bV9leHBvcnRhYmxlX2tleSBzdWJ0bCBpblxuICAgICAgbGV0KiBjaXBoZXIgPSBzeW1fZW5jcnlwdCB+aXYgc3VidGwga2V5IGNsZWFyIGluXG4gICAgICBsZXQgIGNpcGhlciA9IFRhcnJheS51aW50OF9vZl9idWZmZXIgY2lwaGVyIGluXG4gICAgICBsZXQgIGNpcGhlciA9IFRhcnJheS50b19oZXhfanN0ciBjaXBoZXIgaW5cbiAgICAgIEZvcm0uRGF0YS5zZXQgZGF0YSAoSnN0ci52IFwicGFzdGVcIikgY2lwaGVyIDtcbiAgICAgIGxldCBpbml0ID0gRmV0Y2guUmVxdWVzdC5pbml0IH5ib2R5OihGZXRjaC5Cb2R5Lm9mX2Zvcm1fZGF0YSBkYXRhKSB+bWV0aG9kJzpwb3N0ICgpIGluXG4gICAgICBsZXQqIGtleSA9IFN1YnRsZV9jcnlwdG8uZXhwb3J0X2tleSBzdWJ0bCBDcnlwdG9fa2V5LkZvcm1hdC5qd2sga2V5IGluXG4gICAgICBsZXRbQHdhcm5pbmcgXCItOFwiXSAoYEpzb25fd2ViX2tleSBrZXkgOiBbIGBCdWZmZXIgb2YgXyB8IGBKc29uX3dlYl9rZXkgb2YgXyBdKSA9IGtleSBpblxuICAgICAgbGV0KiBrZXkgPSBGdXQucmV0dXJuIChCYXNlNjQuZW5jb2RlIChKc29uLmVuY29kZSBrZXkpKSBpblxuICAgICAgbGV0KiByZXMgPSBGZXRjaC5yZXF1ZXN0IChGZXRjaC5SZXF1ZXN0LnYgfmluaXQ6aW5pdCAoSnN0ci52IFwiL1wiKSkgaW5cbiAgICAgIGxldCogcmVzID0gRmV0Y2guQm9keS5qc29uIChGZXRjaC5SZXNwb25zZS5hc19ib2R5IHJlcykgaW5cbiAgICAgIGxldCBjb2RlID0gSnYuZ2V0IHJlcyBcImNvZGVcIiB8PiBKdi50b19qc3RyIGluXG4gICAgICBsZXQgaGwgPSBKdi5maW5kIHJlcyBcImhsXCIgfD4gT3B0aW9uLm1hcCBKdi50b19zdHJpbmcgaW5cbiAgICAgIGxldCBsbiA9IEp2LmZpbmQgcmVzIFwibG5cIiB8PiBPcHRpb24ubWFwIEp2LnRvX2Jvb2wgaW5cbiAgICAgIGxldCByYXcgPSBKdi5maW5kIHJlcyBcInJhd1wiIHw+IE9wdGlvbi5tYXAgSnYudG9fYm9vbCBpblxuICAgICAgbGV0KiBwYXRoID0gbWFrZV9wYXRoID9obCA/bG4gP3JhdyB+a2V5IGNvZGUgaW5cbiAgICAgIGxldCogdXJpID0gRnV0LnJldHVybiAoVXJpLm9mX2pzdHIgKEpzdHIuY29uY2F0IFsgVXJpLnRvX2pzdHIgKFdpbmRvdy5sb2NhdGlvbiBHLndpbmRvdyk7IHBhdGggXSkpIGluXG4gICAgICBXaW5kb3cuc2V0X2xvY2F0aW9uIEcud2luZG93IHVyaSA7IEZ1dC5vayAoKSBcbiAgICB8IFNvbWUgKGBTdHJpbmcgXyksIF8gLT5cbiAgICAgIGxldCBpbml0ID0gRmV0Y2guUmVxdWVzdC5pbml0IH5ib2R5OihGZXRjaC5Cb2R5Lm9mX2Zvcm1fZGF0YSBkYXRhKSB+bWV0aG9kJzpwb3N0ICgpIGluXG4gICAgICBsZXQqIHJlcyA9IEZldGNoLnJlcXVlc3QgKEZldGNoLlJlcXVlc3QudiB+aW5pdDppbml0IChKc3RyLnYgXCIvXCIpKSBpblxuICAgICAgbGV0KiByZXMgPSBGZXRjaC5Cb2R5Lmpzb24gKEZldGNoLlJlc3BvbnNlLmFzX2JvZHkgcmVzKSBpblxuICAgICAgbGV0IGNvZGUgPSBKdi5nZXQgcmVzIFwiY29kZVwiIHw+IEp2LnRvX2pzdHIgaW5cbiAgICAgIGxldCBobCA9IEp2LmZpbmQgcmVzIFwiaGxcIiB8PiBPcHRpb24ubWFwIEp2LnRvX3N0cmluZyBpblxuICAgICAgbGV0IGxuID0gSnYuZmluZCByZXMgXCJsblwiIHw+IE9wdGlvbi5tYXAgSnYudG9fYm9vbCBpblxuICAgICAgbGV0IHJhdyA9IEp2LmZpbmQgcmVzIFwicmF3XCIgfD4gT3B0aW9uLm1hcCBKdi50b19ib29sIGluXG4gICAgICBsZXQqIHBhdGggPSBtYWtlX3BhdGggP2hsID9sbiA/cmF3IGNvZGUgaW5cbiAgICAgIGxldCogdXJpID0gRnV0LnJldHVybiAoVXJpLm9mX2pzdHIgKEpzdHIuY29uY2F0IFsgVXJpLnRvX2pzdHIgKFdpbmRvdy5sb2NhdGlvbiBHLndpbmRvdyk7IHBhdGggXSkpIGluXG4gICAgICBXaW5kb3cuc2V0X2xvY2F0aW9uIEcud2luZG93IHVyaSA7IEZ1dC5vayAoKSBcbiAgICB8IFNvbWUgKGBGaWxlIF8pLCBfIC0+XG4gICAgICBDb25zb2xlLihlcnJvciBbc3RyIFwiUGFzdGUgZWxlbWVudCBtdXN0IGJlIGEgc3RyaW5nXCJdKSA7XG4gICAgICBGdXQucmV0dXJuIChFcnJvciAoSnYuRXJyb3IudiBlcnJfZWxlbWVudF9wYXN0ZV9pc19ub3RfYV9zdHJpbmcpKVxuICAgIHwgTm9uZSwgXyAtPlxuICAgICAgQ29uc29sZS4oZXJyb3IgW3N0ciBcIk5vIGVsZW1lbnQgZm91bmRcIl0pIDtcbiAgICAgIEZ1dC5yZXR1cm4gKEVycm9yIChKdi5FcnJvci52IGVycl9lbGVtZW50X3Bhc3RlX25vdF9mb3VuZCkpIClcblxubGV0IHJhdyA9IEpzdHIudiBcInJhd1wiXG5sZXQgb3V0cHV0ID0gSnN0ci52IFwib3V0cHV0XCJcbmxldCBlbmNyeXB0ZWQgPSBKc3RyLnYgXCJlbmNyeXB0ZWRcIlxubGV0IGVycl9zb3VyY2Vfb3Jfb3V0cHV0X25vdF9mb3VuZCA9IEpzdHIudiBcIlNvdXJjZSBvciBPdXRwdXQgbm90IGZvdW5kXCJcblxubGV0IHRvX3VpbnQ4IHggeSA9XG4gIGxldCBjb2RlIGNociA9IG1hdGNoIGNociB3aXRoXG4gICAgfCAnMCcgLi4gJzknIC0+IENoYXIuY29kZSBjaHIgLSA0OFxuICAgIHwgJ2EnIC4uICdmJyAtPiAxMCArIENoYXIuY29kZSBjaHIgLSA5N1xuICAgIHwgJ0EnIC4uICdGJyAtPiAxMCArIENoYXIuY29kZSBjaHIgLSA2NVxuICAgIHwgXyAtPiBpbnZhbGlkX2FyZyBcIkludmFsaWQgaGV4IGNoYXJhY3RlclwiIGluXG4gIChjb2RlIHggbHNsIDQgKyBjb2RlIHkpXG5cbmxldCBvZl9oZXggc3RyID1cbiAgaWYgc3RyID0gXCJcIiB0aGVuIFt8fF1cbiAgZWxzZVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxldCBidWYgPSBBcnJheS5tYWtlIChsZW4gLyAyKSAwIGluXG4gICAgbGV0IHJlYyBnbyB4IHkgPVxuICAgICAgaWYgeCA+PSBsZW4gdGhlbiAoKVxuICAgICAgZWxzZSBpZiB5ID49IGxlbiB0aGVuIGludmFsaWRfYXJnIFwiSW52YWxpZCBoZXggdmFsdWVcIlxuICAgICAgZWxzZVxuICAgICAgICAoIGJ1Zi4oeCAvIDIpIDwtIHRvX3VpbnQ4IHN0ci5beF0gc3RyLlt5XVxuICAgICAgICA7IGdvICh4ICsgMikgKHkgKyAyKSApIGluXG4gICAgZ28gMCAxIDsgYnVmXG5cbmxldCBvZl9oZXggc3RyID1cbiAgdHJ5IE9rIChvZl9oZXggc3RyKVxuICB3aXRoIF8gLT4gRXJyb3IgKEp2LkVycm9yLnYgZXJyX2ludmFsaWRfaGV4X3ZhbHVlKVxuXG5sZXQgc2hvdyAoKSA9XG4gIG1hdGNoIERvY3VtZW50LmZpbmRfZWxfYnlfaWQgRy5kb2N1bWVudCByYXcsXG4gICAgICAgIERvY3VtZW50LmZpbmRfZWxfYnlfaWQgRy5kb2N1bWVudCBvdXRwdXQsXG4gICAgICAgIERvY3VtZW50LmZpbmRfZWxfYnlfaWQgRy5kb2N1bWVudCBlbmNyeXB0ZWQgd2l0aFxuICB8IFNvbWUgc3JjLCBTb21lIG91dHB1dCwgU29tZSBlbmNyeXB0ZWQgd2hlbiBKdi5nZXQgKEVsLnRvX2p2IGVuY3J5cHRlZCkgXCJ0ZXh0Q29udGVudFwiIHw+IEp2LnRvX2pzdHIgPSBvbiAtPlxuICAgIENvbnNvbGUuKGRlYnVnIFtzdHIgXCJEYXRhIGlzIGVuY3J5cHRlZC5cIl0pIDtcbiAgICBsZXQgc3VidGwgPSBDcnlwdG8uc3VidGxlIENyeXB0by5jcnlwdG8gaW5cbiAgICBsZXQga2V5ID0gVXJpLmZyYWdtZW50IChXaW5kb3cubG9jYXRpb24gRy53aW5kb3cpIGluXG4gICAgbGV0KiBrZXkgPSBGdXQucmV0dXJuIFJyZXN1bHQuKEJhc2U2NC5kZWNvZGUga2V5ID4+PSBKc29uLmRlY29kZSkgaW5cbiAgICBDb25zb2xlLihkZWJ1ZyBbc3RyIFwiS2V5ICclcydcIjsgSnNvbi5lbmNvZGUga2V5XSkgO1xuICAgIGxldCoga2V5ID0gU3VidGxlX2NyeXB0by5pbXBvcnRfa2V5IHN1YnRsIENyeXB0b19rZXkuRm9ybWF0Lmp3ayAoYEpzb25fd2ViX2tleSBrZXkpXG4gICAgICBzeW1fa2V5X2dlblxuICAgICAgfmV4dHJhY3RhYmxlOmZhbHNlXG4gICAgICB+dXNhZ2VzOkNyeXB0b19rZXkuVXNhZ2UuWyBkZWNyeXB0OyBdIGluXG4gICAgQ29uc29sZS4oZGVidWcgW3N0ciBcIktleSBzYW5pdGl6ZWQuXCJdKSA7XG4gICAgbGV0ICBjaXBoZXIgPSBKdi50b19qc3RyIChKdi5nZXQgKEVsLnRvX2p2IHNyYykgXCJ0ZXh0Q29udGVudFwiKSBpblxuICAgIGxldCogY2lwaGVyID0gRnV0LnJldHVybiAob2ZfaGV4IChKc3RyLnRvX3N0cmluZyBjaXBoZXIpKSBpblxuICAgIGxldCAgY2lwaGVyID0gVGFycmF5Lm9mX2ludF9hcnJheSBUYXJyYXkuVWludDggY2lwaGVyIGluXG4gICAgQ29uc29sZS4oZGVidWcgW3N0ciBcIkRlY3J5cHQuXCJdKSA7XG4gICAgbGV0KiBjbGVhciA9IHN5bV9kZWNyeXB0IH5pdiBzdWJ0bCBrZXkgY2lwaGVyIGluXG4gICAgQ29uc29sZS4oZGVidWcgW3N0ciBcIkRlY3J5cHRlZC5cIl0pIDtcbiAgICBsZXQgb3BlbiBGdXQuU3ludGF4IGluXG4gICAgbGV0KiBjbGVhciA9IEZ1dC5yZXR1cm4gVGFycmF5Lih0b19qc3RyIChvZl9idWZmZXIgVWludDggY2xlYXIpKSBpblxuICAgICggbWF0Y2ggY2xlYXIgd2l0aFxuICAgIHwgT2sgY2xlYXIgLT4gRWwuc2V0X2NoaWxkcmVuIG91dHB1dCBFbC5bdHh0IGNsZWFyXSA7IEZ1dC5vayAoKVxuICAgIHwgRXJyb3IgXyBhcyBlcnIgLT5cbiAgICAgIEVsLnNldF9jaGlsZHJlbiBvdXRwdXQgRWwuW3R4dCBlcnJfaW52YWxpZF9rZXldIDsgRnV0LnJldHVybiBlcnIgKVxuICB8IFNvbWUgc3JjLCBTb21lIG91dHB1dCwgXyAtPlxuICAgIENvbnNvbGUuKGRlYnVnIFtzdHIgXCJEYXRhIGlzIG5vdCBlbmNyeXB0ZWQuXCJdKSA7XG4gICAgbGV0IGNsZWFyID0gSnYudG9fanN0ciAoSnYuZ2V0IChFbC50b19qdiBzcmMpIFwidGV4dENvbnRlbnRcIikgaW5cbiAgICBFbC5zZXRfY2hpbGRyZW4gb3V0cHV0IEVsLlt0eHQgY2xlYXJdIDsgRnV0Lm9rICgpXG4gIHwgXyAtPlxuICAgIEZ1dC5lcnJvciAoSnYuRXJyb3IudiBlcnJfc291cmNlX29yX291dHB1dF9ub3RfZm91bmQpXG5cbmxldCBjb25zdCB4ID0gZnVuIF8gLT4geFxuXG5sZXQgKCkgPVxuICBKdi5zZXQgSnYuZ2xvYmFsIFwiZG9Qb3N0XCIgKEp2LnJlcHIgKGZ1biAoKSAtPiBGdXQudG9fcHJvbWlzZSB+b2s6KGNvbnN0IEp2LnVuZGVmaW5lZCkgKHBvc3QgKCkpKSkgO1xuICBKdi5zZXQgSnYuZ2xvYmFsIFwiZG9TaG93XCIgKEp2LnJlcHIgKGZ1biAoKSAtPiBGdXQudG9fcHJvbWlzZSB+b2s6KGNvbnN0IEp2LnVuZGVmaW5lZCkgKHNob3cgKCkpKSlcblxuIiwiKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPQ2FtbCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgICAqKVxuKCogICAgIGVuIEF1dG9tYXRpcXVlLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCogICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiAgICAqKVxuKCogICB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMi4xLCB3aXRoIHRoZSAgICAgICAgICAqKVxuKCogICBzcGVjaWFsIGV4Y2VwdGlvbiBvbiBsaW5raW5nIGRlc2NyaWJlZCBpbiB0aGUgZmlsZSBMSUNFTlNFLiAgICAgICAgICAqKVxuKCogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKVxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBFbnN1cmUgdGhhdCBbYXRfZXhpdF0gZnVuY3Rpb25zIGFyZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBwcm9ncmFtICopXG5cbmxldCBfID0gZG9fYXRfZXhpdCgpXG4iXX0=